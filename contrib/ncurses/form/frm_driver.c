begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************************  * Copyright (c) 1998-2005,2006 Free Software Foundation, Inc.              *  *                                                                          *  * Permission is hereby granted, free of charge, to any person obtaining a  *  * copy of this software and associated documentation files (the            *  * "Software"), to deal in the Software without restriction, including      *  * without limitation the rights to use, copy, modify, merge, publish,      *  * distribute, distribute with modifications, sublicense, and/or sell       *  * copies of the Software, and to permit persons to whom the Software is    *  * furnished to do so, subject to the following conditions:                 *  *                                                                          *  * The above copyright notice and this permission notice shall be included  *  * in all copies or substantial portions of the Software.                   *  *                                                                          *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *  * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *  * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *  *                                                                          *  * Except as contained in this notice, the name(s) of the above copyright   *  * holders shall not be used in advertising or otherwise to promote the     *  * sale, use or other dealings in this Software without prior written       *  * authorization.                                                           *  ****************************************************************************/
end_comment

begin_comment
comment|/****************************************************************************  *   Author:  Juergen Pfeifer, 1995,1997                                    *  ****************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"form.priv.h"
end_include

begin_macro
name|MODULE_ID
argument_list|(
literal|"$Id: frm_driver.c,v 1.76 2006/11/04 18:45:35 tom Exp $"
argument_list|)
end_macro

begin_comment
comment|/*----------------------------------------------------------------------------   This is the core module of the form library. It contains the majority   of the driver routines as well as the form_driver function.    Essentially this module is nearly the whole library. This is because   all the functions in this module depends on some others in the module,   so it makes no sense to split them into separate files because they   will always be linked together. The only acceptable concern is turnaround   time for this module, but now we have all Pentiums or RISCs, so what!    The driver routines are grouped into nine generic categories:     a)   Page Navigation            ( all functions prefixed by PN_ )         The current page of the form is left and some new page is         entered.    b)   Inter-Field Navigation     ( all functions prefixed by FN_ )         The current field of the form is left and some new field is         entered.    c)   Intra-Field Navigation     ( all functions prefixed by IFN_ )         The current position in the current field is changed.    d)   Vertical Scrolling         ( all functions prefixed by VSC_ )         Essentially this is a specialization of Intra-Field navigation.         It has to check for a multi-line field.    e)   Horizontal Scrolling       ( all functions prefixed by HSC_ )         Essentially this is a specialization of Intra-Field navigation.         It has to check for a single-line field.    f)   Field Editing              ( all functions prefixed by FE_ )         The content of the current field is changed    g)   Edit Mode requests         ( all functions prefixed by EM_ )         Switching between insert and overlay mode    h)   Field-Validation requests  ( all functions prefixed by FV_ )         Perform verifications of the field.    i)   Choice requests            ( all functions prefixed by CR_ )         Requests to enumerate possible field values   --------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*----------------------------------------------------------------------------   Some remarks on the placements of assert() macros :   I use them only on "strategic" places, i.e. top level entries where   I want to make sure that things are set correctly. Throughout subordinate   routines I omit them mostly.   --------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Some options that may effect compatibility in behavior to SVr4 forms, but they are here to allow a more intuitive and user friendly behavior of our form implementation. This doesn't affect the API, so we feel it is uncritical.  The initial implementation tries to stay very close with the behavior of the original SVr4 implementation, although in some areas it is quite clear that this isn't the most appropriate way. As far as possible this sources will allow you to build a forms lib that behaves quite similar to SVr4, but now and in the future we will give you better options. Perhaps at some time we will make this configurable at runtime. */
end_comment

begin_comment
comment|/* Implement a more user-friendly previous/next word behavior */
end_comment

begin_define
define|#
directive|define
name|FRIENDLY_PREV_NEXT_WORD
value|(1)
end_define

begin_comment
comment|/* Fix the wrong behavior for forms with all fields inactive */
end_comment

begin_define
define|#
directive|define
name|FIX_FORM_INACTIVE_BUG
value|(1)
end_define

begin_comment
comment|/* Allow dynamic field growth also when navigating past the end */
end_comment

begin_define
define|#
directive|define
name|GROW_IF_NAVIGATE
value|(1)
end_define

begin_if
if|#
directive|if
name|USE_WIDEC_SUPPORT
end_if

begin_define
define|#
directive|define
name|myADDNSTR
parameter_list|(
name|w
parameter_list|,
name|s
parameter_list|,
name|n
parameter_list|)
value|wadd_wchnstr(w, s, n)
end_define

begin_define
define|#
directive|define
name|myINSNSTR
parameter_list|(
name|w
parameter_list|,
name|s
parameter_list|,
name|n
parameter_list|)
value|wins_wchnstr(w, s, n)
end_define

begin_define
define|#
directive|define
name|myINNSTR
parameter_list|(
name|w
parameter_list|,
name|s
parameter_list|,
name|n
parameter_list|)
value|fix_wchnstr(w, s, n)
end_define

begin_define
define|#
directive|define
name|myWCWIDTH
parameter_list|(
name|w
parameter_list|,
name|y
parameter_list|,
name|x
parameter_list|)
value|cell_width(w, y, x)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|myADDNSTR
parameter_list|(
name|w
parameter_list|,
name|s
parameter_list|,
name|n
parameter_list|)
value|waddnstr(w, s, n)
end_define

begin_define
define|#
directive|define
name|myINSNSTR
parameter_list|(
name|w
parameter_list|,
name|s
parameter_list|,
name|n
parameter_list|)
value|winsnstr(w, s, n)
end_define

begin_define
define|#
directive|define
name|myINNSTR
parameter_list|(
name|w
parameter_list|,
name|s
parameter_list|,
name|n
parameter_list|)
value|winnstr(w, s, n)
end_define

begin_define
define|#
directive|define
name|myWCWIDTH
parameter_list|(
name|w
parameter_list|,
name|y
parameter_list|,
name|x
parameter_list|)
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*----------------------------------------------------------------------------   Forward references to some internally used static functions   --------------------------------------------------------------------------*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|Inter_Field_Navigation
argument_list|(
name|int
argument_list|(
operator|*
specifier|const
name|fct
argument_list|)
argument_list|(
name|FORM
operator|*
argument_list|)
argument_list|,
name|FORM
operator|*
name|form
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|FN_Next_Field
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|FN_Previous_Field
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|FE_New_Line
parameter_list|(
name|FORM
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|FE_Delete_Previous
parameter_list|(
name|FORM
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*----------------------------------------------------------------------------   Macro Definitions.    Some Remarks on that: I use the convention to use UPPERCASE for constants   defined by Macros. If I provide a macro as a kind of inline routine to   provide some logic, I use my Upper_Lower case style.   --------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Calculate the position of a single row in a field buffer */
end_comment

begin_define
define|#
directive|define
name|Position_Of_Row_In_Buffer
parameter_list|(
name|field
parameter_list|,
name|row
parameter_list|)
value|((row)*(field)->dcols)
end_define

begin_comment
comment|/* Calculate start address for the fields buffer# N */
end_comment

begin_define
define|#
directive|define
name|Address_Of_Nth_Buffer
parameter_list|(
name|field
parameter_list|,
name|N
parameter_list|)
define|\
value|((field)->buf + (N)*(1+Buffer_Length(field)))
end_define

begin_comment
comment|/* Calculate the start address of the row in the fields specified buffer# N */
end_comment

begin_define
define|#
directive|define
name|Address_Of_Row_In_Nth_Buffer
parameter_list|(
name|field
parameter_list|,
name|N
parameter_list|,
name|row
parameter_list|)
define|\
value|(Address_Of_Nth_Buffer(field,N) + Position_Of_Row_In_Buffer(field,row))
end_define

begin_comment
comment|/* Calculate the start address of the row in the fields primary buffer */
end_comment

begin_define
define|#
directive|define
name|Address_Of_Row_In_Buffer
parameter_list|(
name|field
parameter_list|,
name|row
parameter_list|)
define|\
value|Address_Of_Row_In_Nth_Buffer(field,0,row)
end_define

begin_comment
comment|/* Calculate the start address of the row in the forms current field    buffer# N */
end_comment

begin_define
define|#
directive|define
name|Address_Of_Current_Row_In_Nth_Buffer
parameter_list|(
name|form
parameter_list|,
name|N
parameter_list|)
define|\
value|Address_Of_Row_In_Nth_Buffer((form)->current,N,(form)->currow)
end_define

begin_comment
comment|/* Calculate the start address of the row in the forms current field    primary buffer */
end_comment

begin_define
define|#
directive|define
name|Address_Of_Current_Row_In_Buffer
parameter_list|(
name|form
parameter_list|)
define|\
value|Address_Of_Current_Row_In_Nth_Buffer(form,0)
end_define

begin_comment
comment|/* Calculate the address of the cursor in the forms current field    primary buffer */
end_comment

begin_define
define|#
directive|define
name|Address_Of_Current_Position_In_Nth_Buffer
parameter_list|(
name|form
parameter_list|,
name|N
parameter_list|)
define|\
value|(Address_Of_Current_Row_In_Nth_Buffer(form,N) + (form)->curcol)
end_define

begin_comment
comment|/* Calculate the address of the cursor in the forms current field    buffer# N */
end_comment

begin_define
define|#
directive|define
name|Address_Of_Current_Position_In_Buffer
parameter_list|(
name|form
parameter_list|)
define|\
value|Address_Of_Current_Position_In_Nth_Buffer(form,0)
end_define

begin_comment
comment|/* Logic to decide whether or not a field is actually a field with    vertical or horizontal scrolling */
end_comment

begin_define
define|#
directive|define
name|Is_Scroll_Field
parameter_list|(
name|field
parameter_list|)
define|\
value|(((field)->drows> (field)->rows) || \     ((field)->dcols> (field)->cols))
end_define

begin_comment
comment|/* Logic to decide whether or not a field needs to have an individual window    instead of a derived window because it contains invisible parts.    This is true for non-public fields and for scrollable fields. */
end_comment

begin_define
define|#
directive|define
name|Has_Invisible_Parts
parameter_list|(
name|field
parameter_list|)
define|\
value|(!((field)->opts& O_PUBLIC)      || \    Is_Scroll_Field(field))
end_define

begin_comment
comment|/* Logic to decide whether or not a field needs justification */
end_comment

begin_define
define|#
directive|define
name|Justification_Allowed
parameter_list|(
name|field
parameter_list|)
define|\
value|(((field)->just != NO_JUSTIFICATION)&& \     (Single_Line_Field(field))&& \     (((field)->dcols == (field)->cols)&& \     ((field)->opts& O_STATIC))             )
end_define

begin_comment
comment|/* Logic to determine whether or not a dynamic field may still grow */
end_comment

begin_define
define|#
directive|define
name|Growable
parameter_list|(
name|field
parameter_list|)
value|((field)->status& _MAY_GROW)
end_define

begin_comment
comment|/* Macro to set the attributes for a fields window */
end_comment

begin_define
define|#
directive|define
name|Set_Field_Window_Attributes
parameter_list|(
name|field
parameter_list|,
name|win
parameter_list|)
define|\
value|(  wbkgdset((win),(chtype)((field)->pad | (field)->back)), \    wattrset((win),(field)->fore) )
end_define

begin_comment
comment|/* Logic to decide whether or not a field really appears on the form */
end_comment

begin_define
define|#
directive|define
name|Field_Really_Appears
parameter_list|(
name|field
parameter_list|)
define|\
value|((field->form)&&\    (field->form->status& _POSTED)&&\    (field->opts& O_VISIBLE)&&\    (field->page == field->form->curpage))
end_define

begin_comment
comment|/* Logic to determine whether or not we are on the first position in the    current field */
end_comment

begin_define
define|#
directive|define
name|First_Position_In_Current_Field
parameter_list|(
name|form
parameter_list|)
define|\
value|(((form)->currow==0)&& ((form)->curcol==0))
end_define

begin_define
define|#
directive|define
name|Minimum
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)<=(b)) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|Maximum
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)>=(b)) ? (a) : (b))
end_define

begin_comment
comment|/*----------------------------------------------------------------------------   Useful constants   --------------------------------------------------------------------------*/
end_comment

begin_decl_stmt
specifier|static
name|FIELD_CELL
name|myBLANK
init|=
name|BLANK
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FIELD_CELL
name|myZEROS
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TRACE
end_ifdef

begin_function
specifier|static
name|void
name|check_pos
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|,
name|int
name|lineno
parameter_list|)
block|{
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
if|if
condition|(
name|form
operator|&&
name|form
operator|->
name|w
condition|)
block|{
name|getyx
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|!=
name|form
operator|->
name|currow
operator|||
name|x
operator|!=
name|form
operator|->
name|curcol
condition|)
block|{
name|T
argument_list|(
operator|(
literal|"CHECKPOS %s@%d have position %d,%d vs want %d,%d"
operator|,
name|__FILE__
operator|,
name|lineno
operator|,
name|y
operator|,
name|x
operator|,
name|form
operator|->
name|currow
operator|,
name|form
operator|->
name|curcol
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_define
define|#
directive|define
name|CHECKPOS
parameter_list|(
name|form
parameter_list|)
value|check_pos(form, __LINE__)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CHECKPOS
parameter_list|(
name|form
parameter_list|)
end_define

begin_comment
comment|/* nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*----------------------------------------------------------------------------   Wide-character special functions   --------------------------------------------------------------------------*/
end_comment

begin_if
if|#
directive|if
name|USE_WIDEC_SUPPORT
end_if

begin_comment
comment|/* like winsnstr */
end_comment

begin_function
specifier|static
name|int
name|wins_wchnstr
parameter_list|(
name|WINDOW
modifier|*
name|w
parameter_list|,
name|cchar_t
modifier|*
name|s
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|code
init|=
name|ERR
decl_stmt|;
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
block|{
name|getyx
argument_list|(
name|w
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|=
name|wins_wch
argument_list|(
name|w
argument_list|,
name|s
operator|++
argument_list|)
operator|)
operator|!=
name|OK
condition|)
break|break;
if|if
condition|(
operator|(
name|code
operator|=
name|wmove
argument_list|(
name|w
argument_list|,
name|y
argument_list|,
name|x
operator|+
literal|1
argument_list|)
operator|)
operator|!=
name|OK
condition|)
break|break;
block|}
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* win_wchnstr is inconsistent with winnstr, since it returns OK rather than  * the number of items transferred.  */
end_comment

begin_function
specifier|static
name|int
name|fix_wchnstr
parameter_list|(
name|WINDOW
modifier|*
name|w
parameter_list|,
name|cchar_t
modifier|*
name|s
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|win_wchnstr
argument_list|(
name|w
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/*  * Returns the column of the base of the given cell.  */
end_comment

begin_function
specifier|static
name|int
name|cell_base
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|x
parameter_list|)
block|{
name|int
name|result
init|=
name|x
decl_stmt|;
while|while
condition|(
name|LEGALYX
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
condition|)
block|{
name|cchar_t
modifier|*
name|data
init|=
operator|&
operator|(
name|win
operator|->
name|_line
index|[
name|y
index|]
operator|.
name|text
index|[
name|x
index|]
operator|)
decl_stmt|;
if|if
condition|(
name|isWidecBase
argument_list|(
name|CHDEREF
argument_list|(
name|data
argument_list|)
argument_list|)
operator|||
operator|!
name|isWidecExt
argument_list|(
name|CHDEREF
argument_list|(
name|data
argument_list|)
argument_list|)
condition|)
block|{
name|result
operator|=
name|x
expr_stmt|;
break|break;
block|}
operator|--
name|x
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Returns the number of columns needed for the given cell in a window.  */
end_comment

begin_function
specifier|static
name|int
name|cell_width
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|x
parameter_list|)
block|{
name|int
name|result
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|LEGALYX
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
condition|)
block|{
name|cchar_t
modifier|*
name|data
init|=
operator|&
operator|(
name|win
operator|->
name|_line
index|[
name|y
index|]
operator|.
name|text
index|[
name|x
index|]
operator|)
decl_stmt|;
if|if
condition|(
name|isWidecExt
argument_list|(
name|CHDEREF
argument_list|(
name|data
argument_list|)
argument_list|)
condition|)
block|{
comment|/* recur, providing the number of columns to the next character */
name|result
operator|=
name|cell_width
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|wcwidth
argument_list|(
name|CharOf
argument_list|(
name|CHDEREF
argument_list|(
name|data
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * There is no wide-character function such as wdel_wch(), so we must find  * all of the cells that comprise a multi-column character and delete them  * one-by-one.  */
end_comment

begin_function
specifier|static
name|void
name|delete_char
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|int
name|cells
init|=
name|cell_width
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|form
operator|->
name|currow
argument_list|,
name|form
operator|->
name|curcol
argument_list|)
decl_stmt|;
name|form
operator|->
name|curcol
operator|=
name|cell_base
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|form
operator|->
name|currow
argument_list|,
name|form
operator|->
name|curcol
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|form
operator|->
name|currow
argument_list|,
name|form
operator|->
name|curcol
argument_list|)
expr_stmt|;
while|while
condition|(
name|cells
operator|--
operator|>
literal|0
condition|)
block|{
name|wdelch
argument_list|(
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|DeleteChar
parameter_list|(
name|form
parameter_list|)
value|delete_char(form)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DeleteChar
parameter_list|(
name|form
parameter_list|)
define|\
value|wmove((form)->w, (form)->currow, (form)->curcol), \ 	  wdelch((form)->w)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static char *Get_Start_Of_Data(char * buf, int blen) | |   Description   :  Return pointer to first non-blank position in buffer. |                    If buffer is empty return pointer to buffer itself. | |   Return Values :  Pointer to first non-blank position in buffer +--------------------------------------------------------------------------*/
end_comment

begin_function
name|NCURSES_INLINE
specifier|static
name|FIELD_CELL
modifier|*
name|Get_Start_Of_Data
parameter_list|(
name|FIELD_CELL
modifier|*
name|buf
parameter_list|,
name|int
name|blen
parameter_list|)
block|{
name|FIELD_CELL
modifier|*
name|p
init|=
name|buf
decl_stmt|;
name|FIELD_CELL
modifier|*
name|end
init|=
operator|&
name|buf
index|[
name|blen
index|]
decl_stmt|;
name|assert
argument_list|(
name|buf
operator|&&
name|blen
operator|>=
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|<
name|end
operator|)
operator|&&
name|ISBLANK
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
return|return
operator|(
operator|(
name|p
operator|==
name|end
operator|)
condition|?
name|buf
else|:
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static char *After_End_Of_Data(char * buf, int blen) | |   Description   :  Return pointer after last non-blank position in buffer. |                    If buffer is empty, return pointer to buffer itself. | |   Return Values :  Pointer to position after last non-blank position in |                    buffer. +--------------------------------------------------------------------------*/
end_comment

begin_function
name|NCURSES_INLINE
specifier|static
name|FIELD_CELL
modifier|*
name|After_End_Of_Data
parameter_list|(
name|FIELD_CELL
modifier|*
name|buf
parameter_list|,
name|int
name|blen
parameter_list|)
block|{
name|FIELD_CELL
modifier|*
name|p
init|=
operator|&
name|buf
index|[
name|blen
index|]
decl_stmt|;
name|assert
argument_list|(
name|buf
operator|&&
name|blen
operator|>=
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|>
name|buf
operator|)
operator|&&
name|ISBLANK
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|p
operator|--
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static char *Get_First_Whitespace_Character( |                                     char * buf, int   blen) | |   Description   :  Position to the first whitespace character. | |   Return Values :  Pointer to first whitespace character in buffer. +--------------------------------------------------------------------------*/
end_comment

begin_function
name|NCURSES_INLINE
specifier|static
name|FIELD_CELL
modifier|*
name|Get_First_Whitespace_Character
parameter_list|(
name|FIELD_CELL
modifier|*
name|buf
parameter_list|,
name|int
name|blen
parameter_list|)
block|{
name|FIELD_CELL
modifier|*
name|p
init|=
name|buf
decl_stmt|;
name|FIELD_CELL
modifier|*
name|end
init|=
operator|&
name|p
index|[
name|blen
index|]
decl_stmt|;
name|assert
argument_list|(
name|buf
operator|&&
name|blen
operator|>=
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|<
name|end
operator|)
operator|&&
operator|!
name|ISBLANK
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
return|return
operator|(
operator|(
name|p
operator|==
name|end
operator|)
condition|?
name|buf
else|:
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static char *After_Last_Whitespace_Character( |                                     char * buf, int blen) | |   Description   :  Get the position after the last whitespace character. | |   Return Values :  Pointer to position after last whitespace character in |                    buffer. +--------------------------------------------------------------------------*/
end_comment

begin_function
name|NCURSES_INLINE
specifier|static
name|FIELD_CELL
modifier|*
name|After_Last_Whitespace_Character
parameter_list|(
name|FIELD_CELL
modifier|*
name|buf
parameter_list|,
name|int
name|blen
parameter_list|)
block|{
name|FIELD_CELL
modifier|*
name|p
init|=
operator|&
name|buf
index|[
name|blen
index|]
decl_stmt|;
name|assert
argument_list|(
name|buf
operator|&&
name|blen
operator|>=
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|>
name|buf
operator|)
operator|&&
operator|!
name|ISBLANK
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|p
operator|--
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Set this to 1 to use the div_t version. This is a good idea if your    compiler has an intrinsic div() support. Unfortunately GNU-C has it    not yet.    N.B.: This only works if form->curcol follows immediately form->currow          and both are of type int. */
end_comment

begin_define
define|#
directive|define
name|USE_DIV_T
value|(0)
end_define

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static void Adjust_Cursor_Position( |                                       FORM * form, const char * pos) | |   Description   :  Set current row and column of the form to values |                    corresponding to the buffer position. | |   Return Values :  - +--------------------------------------------------------------------------*/
end_comment

begin_function
name|NCURSES_INLINE
specifier|static
name|void
name|Adjust_Cursor_Position
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|,
specifier|const
name|FIELD_CELL
modifier|*
name|pos
parameter_list|)
block|{
name|FIELD
modifier|*
name|field
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|field
operator|=
name|form
operator|->
name|current
expr_stmt|;
name|assert
argument_list|(
name|pos
operator|>=
name|field
operator|->
name|buf
operator|&&
name|field
operator|->
name|dcols
operator|>
literal|0
argument_list|)
expr_stmt|;
name|idx
operator|=
call|(
name|int
call|)
argument_list|(
name|pos
operator|-
name|field
operator|->
name|buf
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_DIV_T
operator|*
operator|(
operator|(
name|div_t
operator|*
operator|)
operator|&
operator|(
name|form
operator|->
name|currow
operator|)
operator|)
operator|=
name|div
argument_list|(
name|idx
argument_list|,
name|field
operator|->
name|dcols
argument_list|)
expr_stmt|;
else|#
directive|else
name|form
operator|->
name|currow
operator|=
name|idx
operator|/
name|field
operator|->
name|dcols
expr_stmt|;
name|form
operator|->
name|curcol
operator|=
name|idx
operator|-
name|field
operator|->
name|cols
operator|*
name|form
operator|->
name|currow
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|field
operator|->
name|drows
operator|<
name|form
operator|->
name|currow
condition|)
name|form
operator|->
name|currow
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static void Buffer_To_Window( |                                      const FIELD  * field, |                                      WINDOW * win) | |   Description   :  Copy the buffer to the window. If it is a multi-line |                    field, the buffer is split to the lines of the |                    window without any editing. | |   Return Values :  - +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|Buffer_To_Window
parameter_list|(
specifier|const
name|FIELD
modifier|*
name|field
parameter_list|,
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|int
name|width
decl_stmt|,
name|height
decl_stmt|;
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|row
decl_stmt|;
name|FIELD_CELL
modifier|*
name|pBuffer
decl_stmt|;
name|assert
argument_list|(
name|win
operator|&&
name|field
argument_list|)
expr_stmt|;
name|getyx
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|width
operator|=
name|getmaxx
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|height
operator|=
name|getmaxy
argument_list|(
name|win
argument_list|)
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
operator|,
name|pBuffer
operator|=
name|field
operator|->
name|buf
init|;
name|row
operator|<
name|height
condition|;
name|row
operator|++
operator|,
name|pBuffer
operator|+=
name|width
control|)
block|{
if|if
condition|(
operator|(
name|len
operator|=
call|(
name|int
call|)
argument_list|(
name|After_End_Of_Data
argument_list|(
name|pBuffer
argument_list|,
name|width
argument_list|)
operator|-
name|pBuffer
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|wmove
argument_list|(
name|win
argument_list|,
name|row
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|myADDNSTR
argument_list|(
name|win
argument_list|,
name|pBuffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
name|wmove
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static void Window_To_Buffer( |                                          WINDOW * win, |                                          FIELD  * field) | |   Description   :  Copy the content of the window into the buffer. |                    The multiple lines of a window are simply |                    concatenated into the buffer. Pad characters in |                    the window will be replaced by blanks in the buffer. | |   Return Values :  - +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|Window_To_Buffer
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|FIELD
modifier|*
name|field
parameter_list|)
block|{
name|int
name|pad
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
name|FIELD_CELL
modifier|*
name|p
decl_stmt|;
name|int
name|row
decl_stmt|,
name|height
decl_stmt|;
name|assert
argument_list|(
name|win
operator|&&
name|field
operator|&&
name|field
operator|->
name|buf
argument_list|)
expr_stmt|;
name|pad
operator|=
name|field
operator|->
name|pad
expr_stmt|;
name|p
operator|=
name|field
operator|->
name|buf
expr_stmt|;
name|height
operator|=
name|getmaxy
argument_list|(
name|win
argument_list|)
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
operator|(
name|row
operator|<
name|height
operator|)
operator|&&
operator|(
name|row
operator|<
name|field
operator|->
name|drows
operator|)
condition|;
name|row
operator|++
control|)
block|{
name|wmove
argument_list|(
name|win
argument_list|,
name|row
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|+=
name|myINNSTR
argument_list|(
name|win
argument_list|,
name|p
operator|+
name|len
argument_list|,
name|field
operator|->
name|dcols
argument_list|)
expr_stmt|;
block|}
name|p
index|[
name|len
index|]
operator|=
name|myZEROS
expr_stmt|;
comment|/* replace visual padding character by blanks in buffer */
if|if
condition|(
name|pad
operator|!=
name|C_BLANK
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|CharOf
argument_list|(
operator|*
name|p
argument_list|)
operator|==
name|ChCharOf
argument_list|(
name|pad
argument_list|)
if|#
directive|if
name|USE_WIDEC_SUPPORT
operator|&&
name|p
operator|->
name|chars
index|[
literal|1
index|]
operator|==
literal|0
endif|#
directive|endif
condition|)
operator|*
name|p
operator|=
name|myBLANK
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static void Synchronize_Buffer(FORM * form) | |   Description   :  If there was a change, copy the content of the |                    window into the buffer, so the buffer is synchronized |                    with the windows content. We have to indicate that the |                    buffer needs validation due to the change. | |   Return Values :  - +--------------------------------------------------------------------------*/
end_comment

begin_function
name|NCURSES_INLINE
specifier|static
name|void
name|Synchronize_Buffer
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
if|if
condition|(
name|form
operator|->
name|status
operator|&
name|_WINDOW_MODIFIED
condition|)
block|{
name|form
operator|->
name|status
operator|&=
operator|~
name|_WINDOW_MODIFIED
expr_stmt|;
name|form
operator|->
name|status
operator||=
name|_FCHECK_REQUIRED
expr_stmt|;
name|Window_To_Buffer
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|form
operator|->
name|current
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|form
operator|->
name|currow
argument_list|,
name|form
operator|->
name|curcol
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static bool Field_Grown( FIELD *field, int amount) | |   Description   :  This function is called for growable dynamic fields |                    only. It has to increase the buffers and to allocate |                    a new window for this field. |                    This function has the side effect to set a new |                    field-buffer pointer, the dcols and drows values |                    as well as a new current Window for the field. | |   Return Values :  TRUE     - field successfully increased |                    FALSE    - there was some error +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|bool
name|Field_Grown
parameter_list|(
name|FIELD
modifier|*
name|field
parameter_list|,
name|int
name|amount
parameter_list|)
block|{
name|bool
name|result
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|field
operator|&&
name|Growable
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|bool
name|single_line_field
init|=
name|Single_Line_Field
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|int
name|old_buflen
init|=
name|Buffer_Length
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|int
name|new_buflen
decl_stmt|;
name|int
name|old_dcols
init|=
name|field
operator|->
name|dcols
decl_stmt|;
name|int
name|old_drows
init|=
name|field
operator|->
name|drows
decl_stmt|;
name|FIELD_CELL
modifier|*
name|oldbuf
init|=
name|field
operator|->
name|buf
decl_stmt|;
name|FIELD_CELL
modifier|*
name|newbuf
decl_stmt|;
name|int
name|growth
decl_stmt|;
name|FORM
modifier|*
name|form
init|=
name|field
operator|->
name|form
decl_stmt|;
name|bool
name|need_visual_update
init|=
operator|(
operator|(
name|form
operator|!=
operator|(
name|FORM
operator|*
operator|)
literal|0
operator|)
operator|&&
operator|(
name|form
operator|->
name|status
operator|&
name|_POSTED
operator|)
operator|&&
operator|(
name|form
operator|->
name|current
operator|==
name|field
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|need_visual_update
condition|)
name|Synchronize_Buffer
argument_list|(
name|form
argument_list|)
expr_stmt|;
if|if
condition|(
name|single_line_field
condition|)
block|{
name|growth
operator|=
name|field
operator|->
name|cols
operator|*
name|amount
expr_stmt|;
if|if
condition|(
name|field
operator|->
name|maxgrow
condition|)
name|growth
operator|=
name|Minimum
argument_list|(
name|field
operator|->
name|maxgrow
operator|-
name|field
operator|->
name|dcols
argument_list|,
name|growth
argument_list|)
expr_stmt|;
name|field
operator|->
name|dcols
operator|+=
name|growth
expr_stmt|;
if|if
condition|(
name|field
operator|->
name|dcols
operator|==
name|field
operator|->
name|maxgrow
condition|)
name|field
operator|->
name|status
operator|&=
operator|~
name|_MAY_GROW
expr_stmt|;
block|}
else|else
block|{
name|growth
operator|=
operator|(
name|field
operator|->
name|rows
operator|+
name|field
operator|->
name|nrow
operator|)
operator|*
name|amount
expr_stmt|;
if|if
condition|(
name|field
operator|->
name|maxgrow
condition|)
name|growth
operator|=
name|Minimum
argument_list|(
name|field
operator|->
name|maxgrow
operator|-
name|field
operator|->
name|drows
argument_list|,
name|growth
argument_list|)
expr_stmt|;
name|field
operator|->
name|drows
operator|+=
name|growth
expr_stmt|;
if|if
condition|(
name|field
operator|->
name|drows
operator|==
name|field
operator|->
name|maxgrow
condition|)
name|field
operator|->
name|status
operator|&=
operator|~
name|_MAY_GROW
expr_stmt|;
block|}
comment|/* drows, dcols changed, so we get really the new buffer length */
name|new_buflen
operator|=
name|Buffer_Length
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|newbuf
operator|=
operator|(
name|FIELD_CELL
operator|*
operator|)
name|malloc
argument_list|(
name|Total_Buffer_Size
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newbuf
condition|)
block|{
comment|/* restore to previous state */
name|field
operator|->
name|dcols
operator|=
name|old_dcols
expr_stmt|;
name|field
operator|->
name|drows
operator|=
name|old_drows
expr_stmt|;
if|if
condition|(
operator|(
name|single_line_field
operator|&&
operator|(
name|field
operator|->
name|dcols
operator|!=
name|field
operator|->
name|maxgrow
operator|)
operator|)
operator|||
operator|(
operator|!
name|single_line_field
operator|&&
operator|(
name|field
operator|->
name|drows
operator|!=
name|field
operator|->
name|maxgrow
operator|)
operator|)
condition|)
name|field
operator|->
name|status
operator||=
name|_MAY_GROW
expr_stmt|;
block|}
else|else
block|{
comment|/* Copy all the buffers.  This is the reason why we can't just use 	   * realloc(). 	   */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|FIELD_CELL
modifier|*
name|old_bp
decl_stmt|;
name|FIELD_CELL
modifier|*
name|new_bp
decl_stmt|;
name|result
operator|=
name|TRUE
expr_stmt|;
comment|/* allow sharing of recovery on failure */
name|field
operator|->
name|buf
operator|=
name|newbuf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|field
operator|->
name|nbuf
condition|;
name|i
operator|++
control|)
block|{
name|new_bp
operator|=
name|Address_Of_Nth_Buffer
argument_list|(
name|field
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|old_bp
operator|=
name|oldbuf
operator|+
name|i
operator|*
operator|(
literal|1
operator|+
name|old_buflen
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|old_buflen
condition|;
operator|++
name|j
control|)
name|new_bp
index|[
name|j
index|]
operator|=
name|old_bp
index|[
name|j
index|]
expr_stmt|;
while|while
condition|(
name|j
operator|<
name|new_buflen
condition|)
name|new_bp
index|[
name|j
operator|++
index|]
operator|=
name|myBLANK
expr_stmt|;
name|new_bp
index|[
name|new_buflen
index|]
operator|=
name|myZEROS
expr_stmt|;
block|}
if|#
directive|if
name|USE_WIDEC_SUPPORT
if|if
condition|(
name|wresize
argument_list|(
name|field
operator|->
name|working
argument_list|,
literal|1
argument_list|,
name|Buffer_Length
argument_list|(
name|field
argument_list|)
operator|+
literal|1
argument_list|)
operator|==
name|ERR
condition|)
name|result
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|need_visual_update
operator|&&
name|result
condition|)
block|{
name|WINDOW
modifier|*
name|new_window
init|=
name|newpad
argument_list|(
name|field
operator|->
name|drows
argument_list|,
name|field
operator|->
name|dcols
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_window
operator|!=
literal|0
condition|)
block|{
name|assert
argument_list|(
name|form
operator|!=
operator|(
name|FORM
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|form
operator|->
name|w
condition|)
name|delwin
argument_list|(
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
name|form
operator|->
name|w
operator|=
name|new_window
expr_stmt|;
name|Set_Field_Window_Attributes
argument_list|(
name|field
argument_list|,
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
name|werase
argument_list|(
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
name|Buffer_To_Window
argument_list|(
name|field
argument_list|,
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
name|untouchwin
argument_list|(
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|form
operator|->
name|currow
argument_list|,
name|form
operator|->
name|curcol
argument_list|)
expr_stmt|;
block|}
else|else
name|result
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|result
condition|)
block|{
name|free
argument_list|(
name|oldbuf
argument_list|)
expr_stmt|;
comment|/* reflect changes in linked fields */
if|if
condition|(
name|field
operator|!=
name|field
operator|->
name|link
condition|)
block|{
name|FIELD
modifier|*
name|linked_field
decl_stmt|;
for|for
control|(
name|linked_field
operator|=
name|field
operator|->
name|link
init|;
name|linked_field
operator|!=
name|field
condition|;
name|linked_field
operator|=
name|linked_field
operator|->
name|link
control|)
block|{
name|linked_field
operator|->
name|buf
operator|=
name|field
operator|->
name|buf
expr_stmt|;
name|linked_field
operator|->
name|drows
operator|=
name|field
operator|->
name|drows
expr_stmt|;
name|linked_field
operator|->
name|dcols
operator|=
name|field
operator|->
name|dcols
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* restore old state */
name|field
operator|->
name|dcols
operator|=
name|old_dcols
expr_stmt|;
name|field
operator|->
name|drows
operator|=
name|old_drows
expr_stmt|;
name|field
operator|->
name|buf
operator|=
name|oldbuf
expr_stmt|;
if|if
condition|(
operator|(
name|single_line_field
operator|&&
operator|(
name|field
operator|->
name|dcols
operator|!=
name|field
operator|->
name|maxgrow
operator|)
operator|)
operator|||
operator|(
operator|!
name|single_line_field
operator|&&
operator|(
name|field
operator|->
name|drows
operator|!=
name|field
operator|->
name|maxgrow
operator|)
operator|)
condition|)
name|field
operator|->
name|status
operator||=
name|_MAY_GROW
expr_stmt|;
name|free
argument_list|(
name|newbuf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  int _nc_Position_Form_Cursor(FORM * form) | |   Description   :  Position the cursor in the window for the current |                    field to be in sync. with the currow and curcol |                    values. | |   Return Values :  E_OK              - success |                    E_BAD_ARGUMENT    - invalid form pointer |                    E_SYSTEM_ERROR    - form has no current field or |                                        field-window +--------------------------------------------------------------------------*/
end_comment

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|_nc_Position_Form_Cursor
argument_list|(
argument|FORM *form
argument_list|)
end_macro

begin_block
block|{
name|FIELD
modifier|*
name|field
decl_stmt|;
name|WINDOW
modifier|*
name|formwin
decl_stmt|;
if|if
condition|(
operator|!
name|form
condition|)
return|return
operator|(
name|E_BAD_ARGUMENT
operator|)
return|;
if|if
condition|(
operator|!
name|form
operator|->
name|w
operator|||
operator|!
name|form
operator|->
name|current
condition|)
return|return
operator|(
name|E_SYSTEM_ERROR
operator|)
return|;
name|field
operator|=
name|form
operator|->
name|current
expr_stmt|;
name|formwin
operator|=
name|Get_Form_Window
argument_list|(
name|form
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|form
operator|->
name|currow
argument_list|,
name|form
operator|->
name|curcol
argument_list|)
expr_stmt|;
if|if
condition|(
name|Has_Invisible_Parts
argument_list|(
name|field
argument_list|)
condition|)
block|{
comment|/* in this case fieldwin isn't derived from formwin, so we have          to move the cursor in formwin by hand... */
name|wmove
argument_list|(
name|formwin
argument_list|,
name|field
operator|->
name|frow
operator|+
name|form
operator|->
name|currow
operator|-
name|form
operator|->
name|toprow
argument_list|,
name|field
operator|->
name|fcol
operator|+
name|form
operator|->
name|curcol
operator|-
name|form
operator|->
name|begincol
argument_list|)
expr_stmt|;
name|wcursyncup
argument_list|(
name|formwin
argument_list|)
expr_stmt|;
block|}
else|else
name|wcursyncup
argument_list|(
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
return|return
operator|(
name|E_OK
operator|)
return|;
block|}
end_block

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  int _nc_Refresh_Current_Field(FORM * form) | |   Description   :  Propagate the changes in the fields window to the |                    window of the form. | |   Return Values :  E_OK              - on success |                    E_BAD_ARGUMENT    - invalid form pointer |                    E_SYSTEM_ERROR    - general error +--------------------------------------------------------------------------*/
end_comment

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|_nc_Refresh_Current_Field
argument_list|(
argument|FORM *form
argument_list|)
end_macro

begin_block
block|{
name|WINDOW
modifier|*
name|formwin
decl_stmt|;
name|FIELD
modifier|*
name|field
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"_nc_Refresh_Current_Field(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|form
condition|)
name|RETURN
argument_list|(
name|E_BAD_ARGUMENT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|form
operator|->
name|w
operator|||
operator|!
name|form
operator|->
name|current
condition|)
name|RETURN
argument_list|(
name|E_SYSTEM_ERROR
argument_list|)
expr_stmt|;
name|field
operator|=
name|form
operator|->
name|current
expr_stmt|;
name|formwin
operator|=
name|Get_Form_Window
argument_list|(
name|form
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|->
name|opts
operator|&
name|O_PUBLIC
condition|)
block|{
if|if
condition|(
name|Is_Scroll_Field
argument_list|(
name|field
argument_list|)
condition|)
block|{
comment|/* Again, in this case the fieldwin isn't derived from formwin, 	     so we have to perform a copy operation. */
if|if
condition|(
name|Single_Line_Field
argument_list|(
name|field
argument_list|)
condition|)
block|{
comment|/* horizontal scrolling */
if|if
condition|(
name|form
operator|->
name|curcol
operator|<
name|form
operator|->
name|begincol
condition|)
name|form
operator|->
name|begincol
operator|=
name|form
operator|->
name|curcol
expr_stmt|;
else|else
block|{
if|if
condition|(
name|form
operator|->
name|curcol
operator|>=
operator|(
name|form
operator|->
name|begincol
operator|+
name|field
operator|->
name|cols
operator|)
condition|)
name|form
operator|->
name|begincol
operator|=
name|form
operator|->
name|curcol
operator|-
name|field
operator|->
name|cols
operator|+
literal|1
expr_stmt|;
block|}
name|copywin
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|formwin
argument_list|,
literal|0
argument_list|,
name|form
operator|->
name|begincol
argument_list|,
name|field
operator|->
name|frow
argument_list|,
name|field
operator|->
name|fcol
argument_list|,
name|field
operator|->
name|frow
argument_list|,
name|field
operator|->
name|cols
operator|+
name|field
operator|->
name|fcol
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* A multi-line, i.e. vertical scrolling field */
name|int
name|row_after_bottom
decl_stmt|,
name|first_modified_row
decl_stmt|,
name|first_unmodified_row
decl_stmt|;
if|if
condition|(
name|field
operator|->
name|drows
operator|>
name|field
operator|->
name|rows
condition|)
block|{
name|row_after_bottom
operator|=
name|form
operator|->
name|toprow
operator|+
name|field
operator|->
name|rows
expr_stmt|;
if|if
condition|(
name|form
operator|->
name|currow
operator|<
name|form
operator|->
name|toprow
condition|)
block|{
name|form
operator|->
name|toprow
operator|=
name|form
operator|->
name|currow
expr_stmt|;
name|field
operator|->
name|status
operator||=
name|_NEWTOP
expr_stmt|;
block|}
if|if
condition|(
name|form
operator|->
name|currow
operator|>=
name|row_after_bottom
condition|)
block|{
name|form
operator|->
name|toprow
operator|=
name|form
operator|->
name|currow
operator|-
name|field
operator|->
name|rows
operator|+
literal|1
expr_stmt|;
name|field
operator|->
name|status
operator||=
name|_NEWTOP
expr_stmt|;
block|}
if|if
condition|(
name|field
operator|->
name|status
operator|&
name|_NEWTOP
condition|)
block|{
comment|/* means we have to copy whole range */
name|first_modified_row
operator|=
name|form
operator|->
name|toprow
expr_stmt|;
name|first_unmodified_row
operator|=
name|first_modified_row
operator|+
name|field
operator|->
name|rows
expr_stmt|;
name|field
operator|->
name|status
operator|&=
operator|~
name|_NEWTOP
expr_stmt|;
block|}
else|else
block|{
comment|/* we try to optimize : finding the range of touched 		         lines */
name|first_modified_row
operator|=
name|form
operator|->
name|toprow
expr_stmt|;
while|while
condition|(
name|first_modified_row
operator|<
name|row_after_bottom
condition|)
block|{
if|if
condition|(
name|is_linetouched
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|first_modified_row
argument_list|)
condition|)
break|break;
name|first_modified_row
operator|++
expr_stmt|;
block|}
name|first_unmodified_row
operator|=
name|first_modified_row
expr_stmt|;
while|while
condition|(
name|first_unmodified_row
operator|<
name|row_after_bottom
condition|)
block|{
if|if
condition|(
operator|!
name|is_linetouched
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|first_unmodified_row
argument_list|)
condition|)
break|break;
name|first_unmodified_row
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|first_modified_row
operator|=
name|form
operator|->
name|toprow
expr_stmt|;
name|first_unmodified_row
operator|=
name|first_modified_row
operator|+
name|field
operator|->
name|rows
expr_stmt|;
block|}
if|if
condition|(
name|first_unmodified_row
operator|!=
name|first_modified_row
condition|)
name|copywin
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|formwin
argument_list|,
name|first_modified_row
argument_list|,
literal|0
argument_list|,
name|field
operator|->
name|frow
operator|+
name|first_modified_row
operator|-
name|form
operator|->
name|toprow
argument_list|,
name|field
operator|->
name|fcol
argument_list|,
name|field
operator|->
name|frow
operator|+
name|first_unmodified_row
operator|-
name|form
operator|->
name|toprow
operator|-
literal|1
argument_list|,
name|field
operator|->
name|cols
operator|+
name|field
operator|->
name|fcol
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|wsyncup
argument_list|(
name|formwin
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* if the field-window is simply a derived window, i.e. contains no 	   * invisible parts, the whole thing is trivial 	   */
name|wsyncup
argument_list|(
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
block|}
block|}
name|untouchwin
argument_list|(
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|_nc_Position_Form_Cursor
argument_list|(
name|form
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static void Perform_Justification( |                                        FIELD  * field, |                                        WINDOW * win) | |   Description   :  Output field with requested justification | |   Return Values :  - +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|Perform_Justification
parameter_list|(
name|FIELD
modifier|*
name|field
parameter_list|,
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|FIELD_CELL
modifier|*
name|bp
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|col
init|=
literal|0
decl_stmt|;
name|bp
operator|=
name|Get_Start_Of_Data
argument_list|(
name|field
operator|->
name|buf
argument_list|,
name|Buffer_Length
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
call|(
name|int
call|)
argument_list|(
name|After_End_Of_Data
argument_list|(
name|field
operator|->
name|buf
argument_list|,
name|Buffer_Length
argument_list|(
name|field
argument_list|)
argument_list|)
operator|-
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|assert
argument_list|(
name|win
operator|&&
operator|(
name|field
operator|->
name|drows
operator|==
literal|1
operator|)
operator|&&
operator|(
name|field
operator|->
name|dcols
operator|==
name|field
operator|->
name|cols
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|field
operator|->
name|just
condition|)
block|{
case|case
name|JUSTIFY_LEFT
case|:
break|break;
case|case
name|JUSTIFY_CENTER
case|:
name|col
operator|=
operator|(
name|field
operator|->
name|cols
operator|-
name|len
operator|)
operator|/
literal|2
expr_stmt|;
break|break;
case|case
name|JUSTIFY_RIGHT
case|:
name|col
operator|=
name|field
operator|->
name|cols
operator|-
name|len
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|wmove
argument_list|(
name|win
argument_list|,
literal|0
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|myADDNSTR
argument_list|(
name|win
argument_list|,
name|bp
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static void Undo_Justification( |                                     FIELD  * field, |                                     WINDOW * win) | |   Description   :  Display field without any justification, i.e. |                    left justified | |   Return Values :  - +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|Undo_Justification
parameter_list|(
name|FIELD
modifier|*
name|field
parameter_list|,
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|FIELD_CELL
modifier|*
name|bp
decl_stmt|;
name|int
name|len
decl_stmt|;
name|bp
operator|=
name|Get_Start_Of_Data
argument_list|(
name|field
operator|->
name|buf
argument_list|,
name|Buffer_Length
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
call|(
name|int
call|)
argument_list|(
name|After_End_Of_Data
argument_list|(
name|field
operator|->
name|buf
argument_list|,
name|Buffer_Length
argument_list|(
name|field
argument_list|)
argument_list|)
operator|-
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|assert
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|myADDNSTR
argument_list|(
name|win
argument_list|,
name|bp
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static bool Check_Char( |                                           FIELDTYPE * typ, |                                           int ch, |                                           TypeArgument *argp) | |   Description   :  Perform a single character check for character ch |                    according to the fieldtype instance. | |   Return Values :  TRUE             - Character is valid |                    FALSE            - Character is invalid +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|bool
name|Check_Char
parameter_list|(
name|FIELDTYPE
modifier|*
name|typ
parameter_list|,
name|int
name|ch
parameter_list|,
name|TypeArgument
modifier|*
name|argp
parameter_list|)
block|{
if|if
condition|(
name|typ
condition|)
block|{
if|if
condition|(
name|typ
operator|->
name|status
operator|&
name|_LINKED_TYPE
condition|)
block|{
name|assert
argument_list|(
name|argp
argument_list|)
expr_stmt|;
return|return
operator|(
name|Check_Char
argument_list|(
name|typ
operator|->
name|left
argument_list|,
name|ch
argument_list|,
name|argp
operator|->
name|left
argument_list|)
operator|||
name|Check_Char
argument_list|(
name|typ
operator|->
name|right
argument_list|,
name|ch
argument_list|,
name|argp
operator|->
name|right
argument_list|)
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|typ
operator|->
name|ccheck
condition|)
return|return
name|typ
operator|->
name|ccheck
argument_list|(
name|ch
argument_list|,
operator|(
name|void
operator|*
operator|)
name|argp
argument_list|)
return|;
block|}
block|}
return|return
operator|(
operator|!
name|iscntrl
argument_list|(
name|UChar
argument_list|(
name|ch
argument_list|)
argument_list|)
condition|?
name|TRUE
else|:
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int Display_Or_Erase_Field( |                                           FIELD * field, |                                           bool bEraseFlag) | |   Description   :  Create a subwindow for the field and display the |                    buffer contents (apply justification if required) |                    or simply erase the field. | |   Return Values :  E_OK           - on success |                    E_SYSTEM_ERROR - some error (typical no memory) +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|Display_Or_Erase_Field
parameter_list|(
name|FIELD
modifier|*
name|field
parameter_list|,
name|bool
name|bEraseFlag
parameter_list|)
block|{
name|WINDOW
modifier|*
name|win
decl_stmt|;
name|WINDOW
modifier|*
name|fwin
decl_stmt|;
if|if
condition|(
operator|!
name|field
condition|)
return|return
name|E_SYSTEM_ERROR
return|;
name|fwin
operator|=
name|Get_Form_Window
argument_list|(
name|field
operator|->
name|form
argument_list|)
expr_stmt|;
name|win
operator|=
name|derwin
argument_list|(
name|fwin
argument_list|,
name|field
operator|->
name|rows
argument_list|,
name|field
operator|->
name|cols
argument_list|,
name|field
operator|->
name|frow
argument_list|,
name|field
operator|->
name|fcol
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|win
condition|)
return|return
name|E_SYSTEM_ERROR
return|;
else|else
block|{
if|if
condition|(
name|field
operator|->
name|opts
operator|&
name|O_VISIBLE
condition|)
name|Set_Field_Window_Attributes
argument_list|(
name|field
argument_list|,
name|win
argument_list|)
expr_stmt|;
else|else
name|wattrset
argument_list|(
name|win
argument_list|,
name|WINDOW_ATTRS
argument_list|(
name|fwin
argument_list|)
argument_list|)
expr_stmt|;
name|werase
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bEraseFlag
condition|)
block|{
if|if
condition|(
name|field
operator|->
name|opts
operator|&
name|O_PUBLIC
condition|)
block|{
if|if
condition|(
name|Justification_Allowed
argument_list|(
name|field
argument_list|)
condition|)
name|Perform_Justification
argument_list|(
name|field
argument_list|,
name|win
argument_list|)
expr_stmt|;
else|else
name|Buffer_To_Window
argument_list|(
name|field
argument_list|,
name|win
argument_list|)
expr_stmt|;
block|}
name|field
operator|->
name|status
operator|&=
operator|~
name|_NEWTOP
expr_stmt|;
block|}
name|wsyncup
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|delwin
argument_list|(
name|win
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
end_function

begin_comment
comment|/* Macros to preset the bEraseFlag */
end_comment

begin_define
define|#
directive|define
name|Display_Field
parameter_list|(
name|field
parameter_list|)
value|Display_Or_Erase_Field(field,FALSE)
end_define

begin_define
define|#
directive|define
name|Erase_Field
parameter_list|(
name|field
parameter_list|)
value|Display_Or_Erase_Field(field,TRUE)
end_define

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int Synchronize_Field(FIELD * field) | |   Description   :  Synchronize the windows content with the value in |                    the buffer. | |   Return Values :  E_OK                - success |                    E_BAD_ARGUMENT      - invalid field pointer |                    E_SYSTEM_ERROR      - some severe basic error +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|Synchronize_Field
parameter_list|(
name|FIELD
modifier|*
name|field
parameter_list|)
block|{
name|FORM
modifier|*
name|form
decl_stmt|;
name|int
name|res
init|=
name|E_OK
decl_stmt|;
if|if
condition|(
operator|!
name|field
condition|)
return|return
operator|(
name|E_BAD_ARGUMENT
operator|)
return|;
if|if
condition|(
operator|(
operator|(
name|form
operator|=
name|field
operator|->
name|form
operator|)
operator|!=
operator|(
name|FORM
operator|*
operator|)
literal|0
operator|)
operator|&&
name|Field_Really_Appears
argument_list|(
name|field
argument_list|)
condition|)
block|{
if|if
condition|(
name|field
operator|==
name|form
operator|->
name|current
condition|)
block|{
name|form
operator|->
name|currow
operator|=
name|form
operator|->
name|curcol
operator|=
name|form
operator|->
name|toprow
operator|=
name|form
operator|->
name|begincol
operator|=
literal|0
expr_stmt|;
name|werase
argument_list|(
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|field
operator|->
name|opts
operator|&
name|O_PUBLIC
operator|)
operator|&&
name|Justification_Allowed
argument_list|(
name|field
argument_list|)
condition|)
name|Undo_Justification
argument_list|(
name|field
argument_list|,
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
else|else
name|Buffer_To_Window
argument_list|(
name|field
argument_list|,
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
name|field
operator|->
name|status
operator||=
name|_NEWTOP
expr_stmt|;
name|res
operator|=
name|_nc_Refresh_Current_Field
argument_list|(
name|form
argument_list|)
expr_stmt|;
block|}
else|else
name|res
operator|=
name|Display_Field
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
name|field
operator|->
name|status
operator||=
name|_CHANGED
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int Synchronize_Linked_Fields(FIELD * field) | |   Description   :  Propagate the Synchronize_Field function to all linked |                    fields. The first error that occurs in the sequence |                    of updates is the return value. | |   Return Values :  E_OK                - success |                    E_BAD_ARGUMENT      - invalid field pointer |                    E_SYSTEM_ERROR      - some severe basic error +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|Synchronize_Linked_Fields
parameter_list|(
name|FIELD
modifier|*
name|field
parameter_list|)
block|{
name|FIELD
modifier|*
name|linked_field
decl_stmt|;
name|int
name|res
init|=
name|E_OK
decl_stmt|;
name|int
name|syncres
decl_stmt|;
if|if
condition|(
operator|!
name|field
condition|)
return|return
operator|(
name|E_BAD_ARGUMENT
operator|)
return|;
if|if
condition|(
operator|!
name|field
operator|->
name|link
condition|)
return|return
operator|(
name|E_SYSTEM_ERROR
operator|)
return|;
for|for
control|(
name|linked_field
operator|=
name|field
operator|->
name|link
init|;
name|linked_field
operator|!=
name|field
condition|;
name|linked_field
operator|=
name|linked_field
operator|->
name|link
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|syncres
operator|=
name|Synchronize_Field
argument_list|(
name|linked_field
argument_list|)
operator|)
operator|!=
name|E_OK
operator|)
operator|&&
operator|(
name|res
operator|==
name|E_OK
operator|)
condition|)
name|res
operator|=
name|syncres
expr_stmt|;
block|}
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  int _nc_Synchronize_Attributes(FIELD * field) | |   Description   :  If a fields visual attributes have changed, this |                    routine is called to propagate those changes to the |                    screen. | |   Return Values :  E_OK             - success |                    E_BAD_ARGUMENT   - invalid field pointer |                    E_SYSTEM_ERROR   - some severe basic error +--------------------------------------------------------------------------*/
end_comment

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|_nc_Synchronize_Attributes
argument_list|(
argument|FIELD *field
argument_list|)
end_macro

begin_block
block|{
name|FORM
modifier|*
name|form
decl_stmt|;
name|int
name|res
init|=
name|E_OK
decl_stmt|;
name|WINDOW
modifier|*
name|formwin
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"_nc_Synchronize_Attributes(%p)"
argument_list|)
operator|,
name|field
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|field
condition|)
name|returnCode
argument_list|(
name|E_BAD_ARGUMENT
argument_list|)
expr_stmt|;
name|CHECKPOS
argument_list|(
name|field
operator|->
name|form
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|form
operator|=
name|field
operator|->
name|form
operator|)
operator|!=
operator|(
name|FORM
operator|*
operator|)
literal|0
operator|)
operator|&&
name|Field_Really_Appears
argument_list|(
name|field
argument_list|)
condition|)
block|{
if|if
condition|(
name|form
operator|->
name|current
operator|==
name|field
condition|)
block|{
name|Synchronize_Buffer
argument_list|(
name|form
argument_list|)
expr_stmt|;
name|Set_Field_Window_Attributes
argument_list|(
name|field
argument_list|,
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
name|werase
argument_list|(
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|form
operator|->
name|currow
argument_list|,
name|form
operator|->
name|curcol
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|->
name|opts
operator|&
name|O_PUBLIC
condition|)
block|{
if|if
condition|(
name|Justification_Allowed
argument_list|(
name|field
argument_list|)
condition|)
name|Undo_Justification
argument_list|(
name|field
argument_list|,
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
else|else
name|Buffer_To_Window
argument_list|(
name|field
argument_list|,
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|formwin
operator|=
name|Get_Form_Window
argument_list|(
name|form
argument_list|)
expr_stmt|;
name|copywin
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|formwin
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|field
operator|->
name|frow
argument_list|,
name|field
operator|->
name|fcol
argument_list|,
name|field
operator|->
name|rows
operator|-
literal|1
argument_list|,
name|field
operator|->
name|cols
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wsyncup
argument_list|(
name|formwin
argument_list|)
expr_stmt|;
name|Buffer_To_Window
argument_list|(
name|field
argument_list|,
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
name|field
operator|->
name|status
operator||=
name|_NEWTOP
expr_stmt|;
comment|/* fake refresh to paint all */
name|_nc_Refresh_Current_Field
argument_list|(
name|form
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|res
operator|=
name|Display_Field
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
block|}
name|CHECKPOS
argument_list|(
name|form
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  int _nc_Synchronize_Options(FIELD * field, |                                                Field_Options newopts) | |   Description   :  If a fields options have changed, this routine is |                    called to propagate these changes to the screen and |                    to really change the behavior of the field. | |   Return Values :  E_OK                - success |                    E_BAD_ARGUMENT      - invalid field pointer |                    E_CURRENT           - field is the current one |                    E_SYSTEM_ERROR      - some severe basic error +--------------------------------------------------------------------------*/
end_comment

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|_nc_Synchronize_Options
argument_list|(
argument|FIELD *field
argument_list|,
argument|Field_Options newopts
argument_list|)
end_macro

begin_block
block|{
name|Field_Options
name|oldopts
decl_stmt|;
name|Field_Options
name|changed_opts
decl_stmt|;
name|FORM
modifier|*
name|form
decl_stmt|;
name|int
name|res
init|=
name|E_OK
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"_nc_Synchronize_Options(%p,%#x)"
argument_list|)
operator|,
name|field
operator|,
name|newopts
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|field
condition|)
name|returnCode
argument_list|(
name|E_BAD_ARGUMENT
argument_list|)
expr_stmt|;
name|oldopts
operator|=
name|field
operator|->
name|opts
expr_stmt|;
name|changed_opts
operator|=
name|oldopts
operator|^
name|newopts
expr_stmt|;
name|field
operator|->
name|opts
operator|=
name|newopts
expr_stmt|;
name|form
operator|=
name|field
operator|->
name|form
expr_stmt|;
if|if
condition|(
name|form
condition|)
block|{
if|if
condition|(
name|form
operator|->
name|current
operator|==
name|field
condition|)
block|{
name|field
operator|->
name|opts
operator|=
name|oldopts
expr_stmt|;
name|returnCode
argument_list|(
name|E_CURRENT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|form
operator|->
name|status
operator|&
name|_POSTED
condition|)
block|{
if|if
condition|(
operator|(
name|form
operator|->
name|curpage
operator|==
name|field
operator|->
name|page
operator|)
condition|)
block|{
if|if
condition|(
name|changed_opts
operator|&
name|O_VISIBLE
condition|)
block|{
if|if
condition|(
name|newopts
operator|&
name|O_VISIBLE
condition|)
name|res
operator|=
name|Display_Field
argument_list|(
name|field
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|Erase_Field
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|changed_opts
operator|&
name|O_PUBLIC
operator|)
operator|&&
operator|(
name|newopts
operator|&
name|O_VISIBLE
operator|)
condition|)
name|res
operator|=
name|Display_Field
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|changed_opts
operator|&
name|O_STATIC
condition|)
block|{
name|bool
name|single_line_field
init|=
name|Single_Line_Field
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|int
name|res2
init|=
name|E_OK
decl_stmt|;
if|if
condition|(
name|newopts
operator|&
name|O_STATIC
condition|)
block|{
comment|/* the field becomes now static */
name|field
operator|->
name|status
operator|&=
operator|~
name|_MAY_GROW
expr_stmt|;
comment|/* if actually we have no hidden columns, justification may 	     occur again */
if|if
condition|(
name|single_line_field
operator|&&
operator|(
name|field
operator|->
name|cols
operator|==
name|field
operator|->
name|dcols
operator|)
operator|&&
operator|(
name|field
operator|->
name|just
operator|!=
name|NO_JUSTIFICATION
operator|)
operator|&&
name|Field_Really_Appears
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|res2
operator|=
name|Display_Field
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* field is no longer static */
if|if
condition|(
operator|(
name|field
operator|->
name|maxgrow
operator|==
literal|0
operator|)
operator|||
operator|(
name|single_line_field
operator|&&
operator|(
name|field
operator|->
name|dcols
operator|<
name|field
operator|->
name|maxgrow
operator|)
operator|)
operator|||
operator|(
operator|!
name|single_line_field
operator|&&
operator|(
name|field
operator|->
name|drows
operator|<
name|field
operator|->
name|maxgrow
operator|)
operator|)
condition|)
block|{
name|field
operator|->
name|status
operator||=
name|_MAY_GROW
expr_stmt|;
comment|/* a field with justification now changes its behavior, 	         so we must redisplay it */
if|if
condition|(
name|single_line_field
operator|&&
operator|(
name|field
operator|->
name|just
operator|!=
name|NO_JUSTIFICATION
operator|)
operator|&&
name|Field_Really_Appears
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|res2
operator|=
name|Display_Field
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|res2
operator|!=
name|E_OK
condition|)
name|res
operator|=
name|res2
expr_stmt|;
block|}
name|returnCode
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  int _nc_Set_Current_Field(FORM  * form, |                                              FIELD * newfield) | |   Description   :  Make the newfield the new current field. | |   Return Values :  E_OK              - success |                    E_BAD_ARGUMENT    - invalid form or field pointer |                    E_SYSTEM_ERROR    - some severe basic error |                    E_NOT_CONNECTED   - no fields are connected to the form +--------------------------------------------------------------------------*/
end_comment

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|_nc_Set_Current_Field
argument_list|(
argument|FORM *form
argument_list|,
argument|FIELD *newfield
argument_list|)
end_macro

begin_block
block|{
name|FIELD
modifier|*
name|field
decl_stmt|;
name|WINDOW
modifier|*
name|new_window
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"_nc_Set_Current_Field(%p,%p)"
argument_list|)
operator|,
name|form
operator|,
name|newfield
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|form
operator|||
operator|!
name|newfield
operator|||
operator|!
name|form
operator|->
name|current
operator|||
operator|(
name|newfield
operator|->
name|form
operator|!=
name|form
operator|)
condition|)
name|returnCode
argument_list|(
name|E_BAD_ARGUMENT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|form
operator|->
name|status
operator|&
name|_IN_DRIVER
operator|)
condition|)
name|returnCode
argument_list|(
name|E_BAD_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|form
operator|->
name|field
operator|)
condition|)
name|returnCode
argument_list|(
name|E_NOT_CONNECTED
argument_list|)
expr_stmt|;
name|field
operator|=
name|form
operator|->
name|current
expr_stmt|;
if|if
condition|(
operator|(
name|field
operator|!=
name|newfield
operator|)
operator|||
operator|!
operator|(
name|form
operator|->
name|status
operator|&
name|_POSTED
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|form
operator|->
name|w
operator|)
operator|&&
operator|(
name|field
operator|->
name|opts
operator|&
name|O_VISIBLE
operator|)
operator|&&
operator|(
name|field
operator|->
name|form
operator|->
name|curpage
operator|==
name|field
operator|->
name|page
operator|)
condition|)
block|{
name|_nc_Refresh_Current_Field
argument_list|(
name|form
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|->
name|opts
operator|&
name|O_PUBLIC
condition|)
block|{
if|if
condition|(
name|field
operator|->
name|drows
operator|>
name|field
operator|->
name|rows
condition|)
block|{
if|if
condition|(
name|form
operator|->
name|toprow
operator|==
literal|0
condition|)
name|field
operator|->
name|status
operator|&=
operator|~
name|_NEWTOP
expr_stmt|;
else|else
name|field
operator|->
name|status
operator||=
name|_NEWTOP
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Justification_Allowed
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|Window_To_Buffer
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|werase
argument_list|(
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
name|Perform_Justification
argument_list|(
name|field
argument_list|,
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
name|wsyncup
argument_list|(
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|delwin
argument_list|(
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
name|form
operator|->
name|w
operator|=
operator|(
name|WINDOW
operator|*
operator|)
literal|0
expr_stmt|;
block|}
name|field
operator|=
name|newfield
expr_stmt|;
if|if
condition|(
name|Has_Invisible_Parts
argument_list|(
name|field
argument_list|)
condition|)
name|new_window
operator|=
name|newpad
argument_list|(
name|field
operator|->
name|drows
argument_list|,
name|field
operator|->
name|dcols
argument_list|)
expr_stmt|;
else|else
name|new_window
operator|=
name|derwin
argument_list|(
name|Get_Form_Window
argument_list|(
name|form
argument_list|)
argument_list|,
name|field
operator|->
name|rows
argument_list|,
name|field
operator|->
name|cols
argument_list|,
name|field
operator|->
name|frow
argument_list|,
name|field
operator|->
name|fcol
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_window
condition|)
name|returnCode
argument_list|(
name|E_SYSTEM_ERROR
argument_list|)
expr_stmt|;
name|form
operator|->
name|current
operator|=
name|field
expr_stmt|;
if|if
condition|(
name|form
operator|->
name|w
condition|)
name|delwin
argument_list|(
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
name|form
operator|->
name|w
operator|=
name|new_window
expr_stmt|;
name|form
operator|->
name|status
operator|&=
operator|~
name|_WINDOW_MODIFIED
expr_stmt|;
name|Set_Field_Window_Attributes
argument_list|(
name|field
argument_list|,
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|Has_Invisible_Parts
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|werase
argument_list|(
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
name|Buffer_To_Window
argument_list|(
name|field
argument_list|,
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Justification_Allowed
argument_list|(
name|field
argument_list|)
condition|)
block|{
name|werase
argument_list|(
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
name|Undo_Justification
argument_list|(
name|field
argument_list|,
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
name|wsyncup
argument_list|(
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
block|}
block|}
name|untouchwin
argument_list|(
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
block|}
name|form
operator|->
name|currow
operator|=
name|form
operator|->
name|curcol
operator|=
name|form
operator|->
name|toprow
operator|=
name|form
operator|->
name|begincol
operator|=
literal|0
expr_stmt|;
name|returnCode
argument_list|(
name|E_OK
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------   Intra-Field Navigation routines   --------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int IFN_Next_Character(FORM * form) | |   Description   :  Move to the next character in the field. In a multi-line |                    field this wraps at the end of the line. | |   Return Values :  E_OK                - success |                    E_REQUEST_DENIED    - at the rightmost position +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|IFN_Next_Character
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|FIELD
modifier|*
name|field
init|=
name|form
operator|->
name|current
decl_stmt|;
name|int
name|step
init|=
name|myWCWIDTH
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|form
operator|->
name|currow
argument_list|,
name|form
operator|->
name|curcol
argument_list|)
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"IFN_Next_Character(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|form
operator|->
name|curcol
operator|+=
name|step
operator|)
operator|==
name|field
operator|->
name|dcols
condition|)
block|{
if|if
condition|(
operator|(
operator|++
operator|(
name|form
operator|->
name|currow
operator|)
operator|)
operator|==
name|field
operator|->
name|drows
condition|)
block|{
if|#
directive|if
name|GROW_IF_NAVIGATE
if|if
condition|(
operator|!
name|Single_Line_Field
argument_list|(
name|field
argument_list|)
operator|&&
name|Field_Grown
argument_list|(
name|field
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|form
operator|->
name|curcol
operator|=
literal|0
expr_stmt|;
name|returnCode
argument_list|(
name|E_OK
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|form
operator|->
name|currow
operator|--
expr_stmt|;
if|#
directive|if
name|GROW_IF_NAVIGATE
if|if
condition|(
name|Single_Line_Field
argument_list|(
name|field
argument_list|)
operator|&&
name|Field_Grown
argument_list|(
name|field
argument_list|,
literal|1
argument_list|)
condition|)
name|returnCode
argument_list|(
name|E_OK
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|form
operator|->
name|curcol
operator|-=
name|step
expr_stmt|;
name|returnCode
argument_list|(
name|E_REQUEST_DENIED
argument_list|)
expr_stmt|;
block|}
name|form
operator|->
name|curcol
operator|=
literal|0
expr_stmt|;
block|}
name|returnCode
argument_list|(
name|E_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int IFN_Previous_Character(FORM * form) | |   Description   :  Move to the previous character in the field. In a |                    multi-line field this wraps and the beginning of the |                    line. | |   Return Values :  E_OK                - success |                    E_REQUEST_DENIED    - at the leftmost position +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|IFN_Previous_Character
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|int
name|amount
init|=
name|myWCWIDTH
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|form
operator|->
name|currow
argument_list|,
name|form
operator|->
name|curcol
operator|-
literal|1
argument_list|)
decl_stmt|;
name|int
name|oldcol
init|=
name|form
operator|->
name|curcol
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"IFN_Previous_Character(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|form
operator|->
name|curcol
operator|-=
name|amount
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|--
operator|(
name|form
operator|->
name|currow
operator|)
operator|)
operator|<
literal|0
condition|)
block|{
name|form
operator|->
name|currow
operator|++
expr_stmt|;
name|form
operator|->
name|curcol
operator|=
name|oldcol
expr_stmt|;
name|returnCode
argument_list|(
name|E_REQUEST_DENIED
argument_list|)
expr_stmt|;
block|}
name|form
operator|->
name|curcol
operator|=
name|form
operator|->
name|current
operator|->
name|dcols
operator|-
literal|1
expr_stmt|;
block|}
name|returnCode
argument_list|(
name|E_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int IFN_Next_Line(FORM * form) | |   Description   :  Move to the beginning of the next line in the field | |   Return Values :  E_OK                - success |                    E_REQUEST_DENIED    - at the last line +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|IFN_Next_Line
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|FIELD
modifier|*
name|field
init|=
name|form
operator|->
name|current
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"IFN_Next_Line(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|++
operator|(
name|form
operator|->
name|currow
operator|)
operator|)
operator|==
name|field
operator|->
name|drows
condition|)
block|{
if|#
directive|if
name|GROW_IF_NAVIGATE
if|if
condition|(
operator|!
name|Single_Line_Field
argument_list|(
name|field
argument_list|)
operator|&&
name|Field_Grown
argument_list|(
name|field
argument_list|,
literal|1
argument_list|)
condition|)
name|returnCode
argument_list|(
name|E_OK
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|form
operator|->
name|currow
operator|--
expr_stmt|;
name|returnCode
argument_list|(
name|E_REQUEST_DENIED
argument_list|)
expr_stmt|;
block|}
name|form
operator|->
name|curcol
operator|=
literal|0
expr_stmt|;
name|returnCode
argument_list|(
name|E_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int IFN_Previous_Line(FORM * form) | |   Description   :  Move to the beginning of the previous line in the field | |   Return Values :  E_OK                - success |                    E_REQUEST_DENIED    - at the first line +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|IFN_Previous_Line
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"IFN_Previous_Line(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|--
operator|(
name|form
operator|->
name|currow
operator|)
operator|)
operator|<
literal|0
condition|)
block|{
name|form
operator|->
name|currow
operator|++
expr_stmt|;
name|returnCode
argument_list|(
name|E_REQUEST_DENIED
argument_list|)
expr_stmt|;
block|}
name|form
operator|->
name|curcol
operator|=
literal|0
expr_stmt|;
name|returnCode
argument_list|(
name|E_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int IFN_Next_Word(FORM * form) | |   Description   :  Move to the beginning of the next word in the field. | |   Return Values :  E_OK             - success |                    E_REQUEST_DENIED - there is no next word +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|IFN_Next_Word
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|FIELD
modifier|*
name|field
init|=
name|form
operator|->
name|current
decl_stmt|;
name|FIELD_CELL
modifier|*
name|bp
init|=
name|Address_Of_Current_Position_In_Buffer
argument_list|(
name|form
argument_list|)
decl_stmt|;
name|FIELD_CELL
modifier|*
name|s
decl_stmt|;
name|FIELD_CELL
modifier|*
name|t
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"IFN_Next_Word(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
comment|/* We really need access to the data, so we have to synchronize */
name|Synchronize_Buffer
argument_list|(
name|form
argument_list|)
expr_stmt|;
comment|/* Go to the first whitespace after the current position (including      current position). This is then the starting point to look for the      next non-blank data */
name|s
operator|=
name|Get_First_Whitespace_Character
argument_list|(
name|bp
argument_list|,
name|Buffer_Length
argument_list|(
name|field
argument_list|)
operator|-
call|(
name|int
call|)
argument_list|(
name|bp
operator|-
name|field
operator|->
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find the start of the next word */
name|t
operator|=
name|Get_Start_Of_Data
argument_list|(
name|s
argument_list|,
name|Buffer_Length
argument_list|(
name|field
argument_list|)
operator|-
call|(
name|int
call|)
argument_list|(
name|s
operator|-
name|field
operator|->
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|FRIENDLY_PREV_NEXT_WORD
if|if
condition|(
name|s
operator|==
name|t
condition|)
name|returnCode
argument_list|(
name|E_REQUEST_DENIED
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
name|Adjust_Cursor_Position
argument_list|(
name|form
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|E_OK
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int IFN_Previous_Word(FORM * form) | |   Description   :  Move to the beginning of the previous word in the field. | |   Return Values :  E_OK             - success |                    E_REQUEST_DENIED - there is no previous word +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|IFN_Previous_Word
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|FIELD
modifier|*
name|field
init|=
name|form
operator|->
name|current
decl_stmt|;
name|FIELD_CELL
modifier|*
name|bp
init|=
name|Address_Of_Current_Position_In_Buffer
argument_list|(
name|form
argument_list|)
decl_stmt|;
name|FIELD_CELL
modifier|*
name|s
decl_stmt|;
name|FIELD_CELL
modifier|*
name|t
decl_stmt|;
name|bool
name|again
init|=
name|FALSE
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"IFN_Previous_Word(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
comment|/* We really need access to the data, so we have to synchronize */
name|Synchronize_Buffer
argument_list|(
name|form
argument_list|)
expr_stmt|;
name|s
operator|=
name|After_End_Of_Data
argument_list|(
name|field
operator|->
name|buf
argument_list|,
call|(
name|int
call|)
argument_list|(
name|bp
operator|-
name|field
operator|->
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* s points now right after the last non-blank in the buffer before bp.      If bp was in a word, s equals bp. In this case we must find the last      whitespace in the buffer before bp and repeat the game to really find      the previous word! */
if|if
condition|(
name|s
operator|==
name|bp
condition|)
name|again
operator|=
name|TRUE
expr_stmt|;
comment|/* And next call now goes backward to look for the last whitespace      before that, pointing right after this, so it points to the begin      of the previous word.    */
name|t
operator|=
name|After_Last_Whitespace_Character
argument_list|(
name|field
operator|->
name|buf
argument_list|,
call|(
name|int
call|)
argument_list|(
name|s
operator|-
name|field
operator|->
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|FRIENDLY_PREV_NEXT_WORD
if|if
condition|(
name|s
operator|==
name|t
condition|)
name|returnCode
argument_list|(
name|E_REQUEST_DENIED
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|again
condition|)
block|{
comment|/* and do it again, replacing bp by t */
name|s
operator|=
name|After_End_Of_Data
argument_list|(
name|field
operator|->
name|buf
argument_list|,
call|(
name|int
call|)
argument_list|(
name|t
operator|-
name|field
operator|->
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|After_Last_Whitespace_Character
argument_list|(
name|field
operator|->
name|buf
argument_list|,
call|(
name|int
call|)
argument_list|(
name|s
operator|-
name|field
operator|->
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|FRIENDLY_PREV_NEXT_WORD
if|if
condition|(
name|s
operator|==
name|t
condition|)
name|returnCode
argument_list|(
name|E_REQUEST_DENIED
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|Adjust_Cursor_Position
argument_list|(
name|form
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|E_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int IFN_Beginning_Of_Field(FORM * form) | |   Description   :  Place the cursor at the first non-pad character in |                    the field. | |   Return Values :  E_OK             - success +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|IFN_Beginning_Of_Field
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|FIELD
modifier|*
name|field
init|=
name|form
operator|->
name|current
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"IFN_Beginning_Of_Field(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
name|Synchronize_Buffer
argument_list|(
name|form
argument_list|)
expr_stmt|;
name|Adjust_Cursor_Position
argument_list|(
name|form
argument_list|,
name|Get_Start_Of_Data
argument_list|(
name|field
operator|->
name|buf
argument_list|,
name|Buffer_Length
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|E_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int IFN_End_Of_Field(FORM * form) | |   Description   :  Place the cursor after the last non-pad character in |                    the field. If the field occupies the last position in |                    the buffer, the cursor is positioned on the last |                    character. | |   Return Values :  E_OK              - success +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|IFN_End_Of_Field
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|FIELD
modifier|*
name|field
init|=
name|form
operator|->
name|current
decl_stmt|;
name|FIELD_CELL
modifier|*
name|pos
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"IFN_End_Of_Field(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
name|Synchronize_Buffer
argument_list|(
name|form
argument_list|)
expr_stmt|;
name|pos
operator|=
name|After_End_Of_Data
argument_list|(
name|field
operator|->
name|buf
argument_list|,
name|Buffer_Length
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
operator|(
name|field
operator|->
name|buf
operator|+
name|Buffer_Length
argument_list|(
name|field
argument_list|)
operator|)
condition|)
name|pos
operator|--
expr_stmt|;
name|Adjust_Cursor_Position
argument_list|(
name|form
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|E_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int IFN_Beginning_Of_Line(FORM * form) | |   Description   :  Place the cursor on the first non-pad character in |                    the current line of the field. | |   Return Values :  E_OK         - success +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|IFN_Beginning_Of_Line
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|FIELD
modifier|*
name|field
init|=
name|form
operator|->
name|current
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"IFN_Beginning_Of_Line(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
name|Synchronize_Buffer
argument_list|(
name|form
argument_list|)
expr_stmt|;
name|Adjust_Cursor_Position
argument_list|(
name|form
argument_list|,
name|Get_Start_Of_Data
argument_list|(
name|Address_Of_Current_Row_In_Buffer
argument_list|(
name|form
argument_list|)
argument_list|,
name|field
operator|->
name|dcols
argument_list|)
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|E_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int IFN_End_Of_Line(FORM * form) | |   Description   :  Place the cursor after the last non-pad character in the |                    current line of the field. If the field occupies the |                    last column in the line, the cursor is positioned on the |                    last character of the line. | |   Return Values :  E_OK        - success +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|IFN_End_Of_Line
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|FIELD
modifier|*
name|field
init|=
name|form
operator|->
name|current
decl_stmt|;
name|FIELD_CELL
modifier|*
name|pos
decl_stmt|;
name|FIELD_CELL
modifier|*
name|bp
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"IFN_End_Of_Line(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
name|Synchronize_Buffer
argument_list|(
name|form
argument_list|)
expr_stmt|;
name|bp
operator|=
name|Address_Of_Current_Row_In_Buffer
argument_list|(
name|form
argument_list|)
expr_stmt|;
name|pos
operator|=
name|After_End_Of_Data
argument_list|(
name|bp
argument_list|,
name|field
operator|->
name|dcols
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
operator|(
name|bp
operator|+
name|field
operator|->
name|dcols
operator|)
condition|)
name|pos
operator|--
expr_stmt|;
name|Adjust_Cursor_Position
argument_list|(
name|form
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|E_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int IFN_Left_Character(FORM * form) | |   Description   :  Move one character to the left in the current line. |                    This doesn't cycle. | |   Return Values :  E_OK             - success |                    E_REQUEST_DENIED - already in first column +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|IFN_Left_Character
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|int
name|amount
init|=
name|myWCWIDTH
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|form
operator|->
name|currow
argument_list|,
name|form
operator|->
name|curcol
operator|-
literal|1
argument_list|)
decl_stmt|;
name|int
name|oldcol
init|=
name|form
operator|->
name|curcol
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"IFN_Left_Character(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|form
operator|->
name|curcol
operator|-=
name|amount
operator|)
operator|<
literal|0
condition|)
block|{
name|form
operator|->
name|curcol
operator|=
name|oldcol
expr_stmt|;
name|returnCode
argument_list|(
name|E_REQUEST_DENIED
argument_list|)
expr_stmt|;
block|}
name|returnCode
argument_list|(
name|E_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int IFN_Right_Character(FORM * form) | |   Description   :  Move one character to the right in the current line. |                    This doesn't cycle. | |   Return Values :  E_OK              - success |                    E_REQUEST_DENIED  - already in last column +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|IFN_Right_Character
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|int
name|amount
init|=
name|myWCWIDTH
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|form
operator|->
name|currow
argument_list|,
name|form
operator|->
name|curcol
argument_list|)
decl_stmt|;
name|int
name|oldcol
init|=
name|form
operator|->
name|curcol
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"IFN_Right_Character(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|form
operator|->
name|curcol
operator|+=
name|amount
operator|)
operator|>=
name|form
operator|->
name|current
operator|->
name|dcols
condition|)
block|{
if|#
directive|if
name|GROW_IF_NAVIGATE
name|FIELD
modifier|*
name|field
init|=
name|form
operator|->
name|current
decl_stmt|;
if|if
condition|(
name|Single_Line_Field
argument_list|(
name|field
argument_list|)
operator|&&
name|Field_Grown
argument_list|(
name|field
argument_list|,
literal|1
argument_list|)
condition|)
name|returnCode
argument_list|(
name|E_OK
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|form
operator|->
name|curcol
operator|=
name|oldcol
expr_stmt|;
name|returnCode
argument_list|(
name|E_REQUEST_DENIED
argument_list|)
expr_stmt|;
block|}
name|returnCode
argument_list|(
name|E_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int IFN_Up_Character(FORM * form) | |   Description   :  Move one line up. This doesn't cycle through the lines |                    of the field. | |   Return Values :  E_OK              - success |                    E_REQUEST_DENIED  - already in last column +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|IFN_Up_Character
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"IFN_Up_Character(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|--
operator|(
name|form
operator|->
name|currow
operator|)
operator|)
operator|<
literal|0
condition|)
block|{
name|form
operator|->
name|currow
operator|++
expr_stmt|;
name|returnCode
argument_list|(
name|E_REQUEST_DENIED
argument_list|)
expr_stmt|;
block|}
name|returnCode
argument_list|(
name|E_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int IFN_Down_Character(FORM * form) | |   Description   :  Move one line down. This doesn't cycle through the |                    lines of the field. | |   Return Values :  E_OK              - success |                    E_REQUEST_DENIED  - already in last column +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|IFN_Down_Character
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|FIELD
modifier|*
name|field
init|=
name|form
operator|->
name|current
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"IFN_Down_Character(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|++
operator|(
name|form
operator|->
name|currow
operator|)
operator|)
operator|==
name|field
operator|->
name|drows
condition|)
block|{
if|#
directive|if
name|GROW_IF_NAVIGATE
if|if
condition|(
operator|!
name|Single_Line_Field
argument_list|(
name|field
argument_list|)
operator|&&
name|Field_Grown
argument_list|(
name|field
argument_list|,
literal|1
argument_list|)
condition|)
name|returnCode
argument_list|(
name|E_OK
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|--
operator|(
name|form
operator|->
name|currow
operator|)
expr_stmt|;
name|returnCode
argument_list|(
name|E_REQUEST_DENIED
argument_list|)
expr_stmt|;
block|}
name|returnCode
argument_list|(
name|E_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------   END of Intra-Field Navigation routines   --------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*----------------------------------------------------------------------------   Vertical scrolling helper routines   --------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int VSC_Generic(FORM *form, int nlines) | |   Description   :  Scroll multi-line field forward (nlines>0) or |                    backward (nlines<0) this many lines. | |   Return Values :  E_OK              - success |                    E_REQUEST_DENIED  - can't scroll +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|VSC_Generic
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|,
name|int
name|nlines
parameter_list|)
block|{
name|FIELD
modifier|*
name|field
init|=
name|form
operator|->
name|current
decl_stmt|;
name|int
name|res
init|=
name|E_REQUEST_DENIED
decl_stmt|;
name|int
name|rows_to_go
init|=
operator|(
name|nlines
operator|>
literal|0
condition|?
name|nlines
else|:
operator|-
name|nlines
operator|)
decl_stmt|;
if|if
condition|(
name|nlines
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|rows_to_go
operator|+
name|form
operator|->
name|toprow
operator|)
operator|>
operator|(
name|field
operator|->
name|drows
operator|-
name|field
operator|->
name|rows
operator|)
condition|)
name|rows_to_go
operator|=
operator|(
name|field
operator|->
name|drows
operator|-
name|field
operator|->
name|rows
operator|-
name|form
operator|->
name|toprow
operator|)
expr_stmt|;
if|if
condition|(
name|rows_to_go
operator|>
literal|0
condition|)
block|{
name|form
operator|->
name|currow
operator|+=
name|rows_to_go
expr_stmt|;
name|form
operator|->
name|toprow
operator|+=
name|rows_to_go
expr_stmt|;
name|res
operator|=
name|E_OK
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|rows_to_go
operator|>
name|form
operator|->
name|toprow
condition|)
name|rows_to_go
operator|=
name|form
operator|->
name|toprow
expr_stmt|;
if|if
condition|(
name|rows_to_go
operator|>
literal|0
condition|)
block|{
name|form
operator|->
name|currow
operator|-=
name|rows_to_go
expr_stmt|;
name|form
operator|->
name|toprow
operator|-=
name|rows_to_go
expr_stmt|;
name|res
operator|=
name|E_OK
expr_stmt|;
block|}
block|}
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------   End of Vertical scrolling helper routines   --------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*----------------------------------------------------------------------------   Vertical scrolling routines   --------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int Vertical_Scrolling( |                                           int (* const fct) (FORM *), |                                           FORM * form) | |   Description   :  Performs the generic vertical scrolling routines. |                    This has to check for a multi-line field and to set |                    the _NEWTOP flag if scrolling really occurred. | |   Return Values :  Propagated error code from low-level driver calls +--------------------------------------------------------------------------*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|Vertical_Scrolling
argument_list|(
name|int
argument_list|(
operator|*
specifier|const
name|fct
argument_list|)
argument_list|(
name|FORM
operator|*
argument_list|)
argument_list|,
name|FORM
operator|*
name|form
argument_list|)
block|{
name|int
name|res
init|=
name|E_REQUEST_DENIED
decl_stmt|;
if|if
condition|(
operator|!
name|Single_Line_Field
argument_list|(
name|form
operator|->
name|current
argument_list|)
condition|)
block|{
name|res
operator|=
name|fct
argument_list|(
name|form
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|E_OK
condition|)
name|form
operator|->
name|current
operator|->
name|status
operator||=
name|_NEWTOP
expr_stmt|;
block|}
return|return
operator|(
name|res
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int VSC_Scroll_Line_Forward(FORM * form) | |   Description   :  Scroll multi-line field forward a line | |   Return Values :  E_OK                - success |                    E_REQUEST_DENIED    - no data ahead +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|VSC_Scroll_Line_Forward
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"VSC_Scroll_Line_Forward(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|VSC_Generic
argument_list|(
name|form
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int VSC_Scroll_Line_Backward(FORM * form) | |   Description   :  Scroll multi-line field backward a line | |   Return Values :  E_OK                - success |                    E_REQUEST_DENIED    - no data behind +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|VSC_Scroll_Line_Backward
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"VSC_Scroll_Line_Backward(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|VSC_Generic
argument_list|(
name|form
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int VSC_Scroll_Page_Forward(FORM * form) | |   Description   :  Scroll a multi-line field forward a page | |   Return Values :  E_OK              - success |                    E_REQUEST_DENIED  - no data ahead +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|VSC_Scroll_Page_Forward
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"VSC_Scroll_Page_Forward(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|VSC_Generic
argument_list|(
name|form
argument_list|,
name|form
operator|->
name|current
operator|->
name|rows
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int VSC_Scroll_Half_Page_Forward(FORM * form) | |   Description   :  Scroll a multi-line field forward half a page | |   Return Values :  E_OK              - success |                    E_REQUEST_DENIED  - no data ahead +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|VSC_Scroll_Half_Page_Forward
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"VSC_Scroll_Half_Page_Forward(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|VSC_Generic
argument_list|(
name|form
argument_list|,
operator|(
name|form
operator|->
name|current
operator|->
name|rows
operator|+
literal|1
operator|)
operator|/
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int VSC_Scroll_Page_Backward(FORM * form) | |   Description   :  Scroll a multi-line field backward a page | |   Return Values :  E_OK              - success |                    E_REQUEST_DENIED  - no data behind +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|VSC_Scroll_Page_Backward
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"VSC_Scroll_Page_Backward(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|VSC_Generic
argument_list|(
name|form
argument_list|,
operator|-
operator|(
name|form
operator|->
name|current
operator|->
name|rows
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int VSC_Scroll_Half_Page_Backward(FORM * form) | |   Description   :  Scroll a multi-line field backward half a page | |   Return Values :  E_OK              - success |                    E_REQUEST_DENIED  - no data behind +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|VSC_Scroll_Half_Page_Backward
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"VSC_Scroll_Half_Page_Backward(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|VSC_Generic
argument_list|(
name|form
argument_list|,
operator|-
operator|(
operator|(
name|form
operator|->
name|current
operator|->
name|rows
operator|+
literal|1
operator|)
operator|/
literal|2
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------   End of Vertical scrolling routines   --------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*----------------------------------------------------------------------------   Horizontal scrolling helper routines   --------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int HSC_Generic(FORM *form, int ncolumns) | |   Description   :  Scroll single-line field forward (ncolumns>0) or |                    backward (ncolumns<0) this many columns. | |   Return Values :  E_OK              - success |                    E_REQUEST_DENIED  - can't scroll +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|HSC_Generic
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|,
name|int
name|ncolumns
parameter_list|)
block|{
name|FIELD
modifier|*
name|field
init|=
name|form
operator|->
name|current
decl_stmt|;
name|int
name|res
init|=
name|E_REQUEST_DENIED
decl_stmt|;
name|int
name|cols_to_go
init|=
operator|(
name|ncolumns
operator|>
literal|0
condition|?
name|ncolumns
else|:
operator|-
name|ncolumns
operator|)
decl_stmt|;
if|if
condition|(
name|ncolumns
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|cols_to_go
operator|+
name|form
operator|->
name|begincol
operator|)
operator|>
operator|(
name|field
operator|->
name|dcols
operator|-
name|field
operator|->
name|cols
operator|)
condition|)
name|cols_to_go
operator|=
name|field
operator|->
name|dcols
operator|-
name|field
operator|->
name|cols
operator|-
name|form
operator|->
name|begincol
expr_stmt|;
if|if
condition|(
name|cols_to_go
operator|>
literal|0
condition|)
block|{
name|form
operator|->
name|curcol
operator|+=
name|cols_to_go
expr_stmt|;
name|form
operator|->
name|begincol
operator|+=
name|cols_to_go
expr_stmt|;
name|res
operator|=
name|E_OK
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|cols_to_go
operator|>
name|form
operator|->
name|begincol
condition|)
name|cols_to_go
operator|=
name|form
operator|->
name|begincol
expr_stmt|;
if|if
condition|(
name|cols_to_go
operator|>
literal|0
condition|)
block|{
name|form
operator|->
name|curcol
operator|-=
name|cols_to_go
expr_stmt|;
name|form
operator|->
name|begincol
operator|-=
name|cols_to_go
expr_stmt|;
name|res
operator|=
name|E_OK
expr_stmt|;
block|}
block|}
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------   End of Horizontal scrolling helper routines   --------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*----------------------------------------------------------------------------   Horizontal scrolling routines   --------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int Horizontal_Scrolling( |                                          int (* const fct) (FORM *), |                                          FORM * form) | |   Description   :  Performs the generic horizontal scrolling routines. |                    This has to check for a single-line field. | |   Return Values :  Propagated error code from low-level driver calls +--------------------------------------------------------------------------*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|Horizontal_Scrolling
argument_list|(
name|int
argument_list|(
operator|*
specifier|const
name|fct
argument_list|)
argument_list|(
name|FORM
operator|*
argument_list|)
argument_list|,
name|FORM
operator|*
name|form
argument_list|)
block|{
if|if
condition|(
name|Single_Line_Field
argument_list|(
name|form
operator|->
name|current
argument_list|)
condition|)
return|return
name|fct
argument_list|(
name|form
argument_list|)
return|;
else|else
return|return
operator|(
name|E_REQUEST_DENIED
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int HSC_Scroll_Char_Forward(FORM * form) | |   Description   :  Scroll single-line field forward a character | |   Return Values :  E_OK                - success |                    E_REQUEST_DENIED    - no data ahead +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|HSC_Scroll_Char_Forward
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"HSC_Scroll_Char_Forward(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|HSC_Generic
argument_list|(
name|form
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int HSC_Scroll_Char_Backward(FORM * form) | |   Description   :  Scroll single-line field backward a character | |   Return Values :  E_OK                - success |                    E_REQUEST_DENIED    - no data behind +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|HSC_Scroll_Char_Backward
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"HSC_Scroll_Char_Backward(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|HSC_Generic
argument_list|(
name|form
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int HSC_Horizontal_Line_Forward(FORM* form) | |   Description   :  Scroll single-line field forward a line | |   Return Values :  E_OK                - success |                    E_REQUEST_DENIED    - no data ahead +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|HSC_Horizontal_Line_Forward
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"HSC_Horizontal_Line_Forward(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|HSC_Generic
argument_list|(
name|form
argument_list|,
name|form
operator|->
name|current
operator|->
name|cols
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int HSC_Horizontal_Half_Line_Forward(FORM* form) | |   Description   :  Scroll single-line field forward half a line | |   Return Values :  E_OK               - success |                    E_REQUEST_DENIED   - no data ahead +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|HSC_Horizontal_Half_Line_Forward
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"HSC_Horizontal_Half_Line_Forward(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|HSC_Generic
argument_list|(
name|form
argument_list|,
operator|(
name|form
operator|->
name|current
operator|->
name|cols
operator|+
literal|1
operator|)
operator|/
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int HSC_Horizontal_Line_Backward(FORM* form) | |   Description   :  Scroll single-line field backward a line | |   Return Values :  E_OK                - success |                    E_REQUEST_DENIED    - no data behind +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|HSC_Horizontal_Line_Backward
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"HSC_Horizontal_Line_Backward(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|HSC_Generic
argument_list|(
name|form
argument_list|,
operator|-
operator|(
name|form
operator|->
name|current
operator|->
name|cols
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int HSC_Horizontal_Half_Line_Backward(FORM* form) | |   Description   :  Scroll single-line field backward half a line | |   Return Values :  E_OK                - success |                    E_REQUEST_DENIED    - no data behind +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|HSC_Horizontal_Half_Line_Backward
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"HSC_Horizontal_Half_Line_Backward(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|HSC_Generic
argument_list|(
name|form
argument_list|,
operator|-
operator|(
operator|(
name|form
operator|->
name|current
operator|->
name|cols
operator|+
literal|1
operator|)
operator|/
literal|2
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------   End of Horizontal scrolling routines   --------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*----------------------------------------------------------------------------   Helper routines for Field Editing   --------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static bool Is_There_Room_For_A_Line(FORM * form) | |   Description   :  Check whether or not there is enough room in the |                    buffer to enter a whole line. | |   Return Values :  TRUE   - there is enough space |                    FALSE  - there is not enough space +--------------------------------------------------------------------------*/
end_comment

begin_function
name|NCURSES_INLINE
specifier|static
name|bool
name|Is_There_Room_For_A_Line
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|FIELD
modifier|*
name|field
init|=
name|form
operator|->
name|current
decl_stmt|;
name|FIELD_CELL
modifier|*
name|begin_of_last_line
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|Synchronize_Buffer
argument_list|(
name|form
argument_list|)
expr_stmt|;
name|begin_of_last_line
operator|=
name|Address_Of_Row_In_Buffer
argument_list|(
name|field
argument_list|,
operator|(
name|field
operator|->
name|drows
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|After_End_Of_Data
argument_list|(
name|begin_of_last_line
argument_list|,
name|field
operator|->
name|dcols
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|s
operator|==
name|begin_of_last_line
operator|)
condition|?
name|TRUE
else|:
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static bool Is_There_Room_For_A_Char_In_Line(FORM * form) | |   Description   :  Checks whether or not there is room for a new character |                    in the current line. | |   Return Values :  TRUE    - there is room |                    FALSE   - there is not enough room (line full) +--------------------------------------------------------------------------*/
end_comment

begin_function
name|NCURSES_INLINE
specifier|static
name|bool
name|Is_There_Room_For_A_Char_In_Line
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|int
name|last_char_in_line
decl_stmt|;
name|wmove
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|form
operator|->
name|currow
argument_list|,
name|form
operator|->
name|current
operator|->
name|dcols
operator|-
literal|1
argument_list|)
expr_stmt|;
name|last_char_in_line
operator|=
call|(
name|int
call|)
argument_list|(
name|winch
argument_list|(
name|form
operator|->
name|w
argument_list|)
operator|&
name|A_CHARTEXT
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|form
operator|->
name|currow
argument_list|,
name|form
operator|->
name|curcol
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
operator|(
name|last_char_in_line
operator|==
name|form
operator|->
name|current
operator|->
name|pad
operator|)
operator|||
name|is_blank
argument_list|(
name|last_char_in_line
argument_list|)
operator|)
condition|?
name|TRUE
else|:
name|FALSE
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|There_Is_No_Room_For_A_Char_In_Line
parameter_list|(
name|f
parameter_list|)
define|\
value|!Is_There_Room_For_A_Char_In_Line(f)
end_define

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int Insert_String( |                                             FORM * form, |                                             int row, |                                             char *txt, |                                             int  len ) | |   Description   :  Insert the 'len' characters beginning at pointer 'txt' |                    into the 'row' of the 'form'. The insertion occurs |                    on the beginning of the row, all other characters are |                    moved to the right. After the text a pad character will |                    be inserted to separate the text from the rest. If |                    necessary the insertion moves characters on the next |                    line to make place for the requested insertion string. | |   Return Values :  E_OK              - success |                    E_REQUEST_DENIED  - |                    E_SYSTEM_ERROR    - system error +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|Insert_String
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|,
name|int
name|row
parameter_list|,
name|FIELD_CELL
modifier|*
name|txt
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|FIELD
modifier|*
name|field
init|=
name|form
operator|->
name|current
decl_stmt|;
name|FIELD_CELL
modifier|*
name|bp
init|=
name|Address_Of_Row_In_Buffer
argument_list|(
name|field
argument_list|,
name|row
argument_list|)
decl_stmt|;
name|int
name|datalen
init|=
call|(
name|int
call|)
argument_list|(
name|After_End_Of_Data
argument_list|(
name|bp
argument_list|,
name|field
operator|->
name|dcols
argument_list|)
operator|-
name|bp
argument_list|)
decl_stmt|;
name|int
name|freelen
init|=
name|field
operator|->
name|dcols
operator|-
name|datalen
decl_stmt|;
name|int
name|requiredlen
init|=
name|len
operator|+
literal|1
decl_stmt|;
name|FIELD_CELL
modifier|*
name|split
decl_stmt|;
name|int
name|result
init|=
name|E_REQUEST_DENIED
decl_stmt|;
if|if
condition|(
name|freelen
operator|>=
name|requiredlen
condition|)
block|{
name|wmove
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|row
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|myINSNSTR
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|txt
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|row
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|myINSNSTR
argument_list|(
name|form
operator|->
name|w
argument_list|,
operator|&
name|myBLANK
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
else|else
block|{
comment|/* we have to move characters on the next line. If we are on the          last line this may work, if the field is growable */
if|if
condition|(
operator|(
name|row
operator|==
operator|(
name|field
operator|->
name|drows
operator|-
literal|1
operator|)
operator|)
operator|&&
name|Growable
argument_list|(
name|field
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|Field_Grown
argument_list|(
name|field
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
name|E_SYSTEM_ERROR
operator|)
return|;
comment|/* !!!Side-Effect : might be changed due to growth!!! */
name|bp
operator|=
name|Address_Of_Row_In_Buffer
argument_list|(
name|field
argument_list|,
name|row
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|row
operator|<
operator|(
name|field
operator|->
name|drows
operator|-
literal|1
operator|)
condition|)
block|{
name|split
operator|=
name|After_Last_Whitespace_Character
argument_list|(
name|bp
argument_list|,
call|(
name|int
call|)
argument_list|(
name|Get_Start_Of_Data
argument_list|(
name|bp
operator|+
name|field
operator|->
name|dcols
operator|-
name|requiredlen
argument_list|,
name|requiredlen
argument_list|)
operator|-
name|bp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* split points now to the first character of the portion of the 	     line that must be moved to the next line */
name|datalen
operator|=
call|(
name|int
call|)
argument_list|(
name|split
operator|-
name|bp
argument_list|)
expr_stmt|;
comment|/* + freelen has to stay on this line   */
name|freelen
operator|=
name|field
operator|->
name|dcols
operator|-
operator|(
name|datalen
operator|+
name|freelen
operator|)
expr_stmt|;
comment|/* for the next line */
if|if
condition|(
operator|(
name|result
operator|=
name|Insert_String
argument_list|(
name|form
argument_list|,
name|row
operator|+
literal|1
argument_list|,
name|split
argument_list|,
name|freelen
argument_list|)
operator|)
operator|==
name|E_OK
condition|)
block|{
name|wmove
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|row
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|wclrtoeol
argument_list|(
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|row
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|myINSNSTR
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|txt
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|row
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|myINSNSTR
argument_list|(
name|form
operator|->
name|w
argument_list|,
operator|&
name|myBLANK
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|E_OK
return|;
block|}
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int Wrapping_Not_Necessary_Or_Wrapping_Ok( |                                             FORM * form) | |   Description   :  If a character has been entered into a field, it may |                    be that wrapping has to occur. This routine checks |                    whether or not wrapping is required and if so, performs |                    the wrapping. | |   Return Values :  E_OK              - no wrapping required or wrapping |                                        was successful |                    E_REQUEST_DENIED  - |                    E_SYSTEM_ERROR    - some system error +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|Wrapping_Not_Necessary_Or_Wrapping_Ok
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|FIELD
modifier|*
name|field
init|=
name|form
operator|->
name|current
decl_stmt|;
name|int
name|result
init|=
name|E_REQUEST_DENIED
decl_stmt|;
name|bool
name|Last_Row
init|=
operator|(
operator|(
name|field
operator|->
name|drows
operator|-
literal|1
operator|)
operator|==
name|form
operator|->
name|currow
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|field
operator|->
name|opts
operator|&
name|O_WRAP
operator|)
operator|&&
comment|/* wrapping wanted     */
operator|(
operator|!
name|Single_Line_Field
argument_list|(
name|field
argument_list|)
operator|)
operator|&&
comment|/* must be multi-line  */
operator|(
name|There_Is_No_Room_For_A_Char_In_Line
argument_list|(
name|form
argument_list|)
operator|)
operator|&&
comment|/* line is full        */
operator|(
operator|!
name|Last_Row
operator|||
name|Growable
argument_list|(
name|field
argument_list|)
operator|)
condition|)
comment|/* there are more lines */
block|{
name|FIELD_CELL
modifier|*
name|bp
decl_stmt|;
name|FIELD_CELL
modifier|*
name|split
decl_stmt|;
name|int
name|chars_to_be_wrapped
decl_stmt|;
name|int
name|chars_to_remain_on_line
decl_stmt|;
if|if
condition|(
name|Last_Row
condition|)
block|{
comment|/* the above logic already ensures, that in this case the field 	     is growable */
if|if
condition|(
operator|!
name|Field_Grown
argument_list|(
name|field
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|E_SYSTEM_ERROR
return|;
block|}
name|bp
operator|=
name|Address_Of_Current_Row_In_Buffer
argument_list|(
name|form
argument_list|)
expr_stmt|;
name|Window_To_Buffer
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|split
operator|=
name|After_Last_Whitespace_Character
argument_list|(
name|bp
argument_list|,
name|field
operator|->
name|dcols
argument_list|)
expr_stmt|;
comment|/* split points to the first character of the sequence to be brought          on the next line */
name|chars_to_remain_on_line
operator|=
call|(
name|int
call|)
argument_list|(
name|split
operator|-
name|bp
argument_list|)
expr_stmt|;
name|chars_to_be_wrapped
operator|=
name|field
operator|->
name|dcols
operator|-
name|chars_to_remain_on_line
expr_stmt|;
if|if
condition|(
name|chars_to_remain_on_line
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|result
operator|=
name|Insert_String
argument_list|(
name|form
argument_list|,
name|form
operator|->
name|currow
operator|+
literal|1
argument_list|,
name|split
argument_list|,
name|chars_to_be_wrapped
argument_list|)
operator|)
operator|==
name|E_OK
condition|)
block|{
name|wmove
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|form
operator|->
name|currow
argument_list|,
name|chars_to_remain_on_line
argument_list|)
expr_stmt|;
name|wclrtoeol
argument_list|(
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|form
operator|->
name|curcol
operator|>=
name|chars_to_remain_on_line
condition|)
block|{
name|form
operator|->
name|currow
operator|++
expr_stmt|;
name|form
operator|->
name|curcol
operator|-=
name|chars_to_remain_on_line
expr_stmt|;
block|}
return|return
name|E_OK
return|;
block|}
block|}
else|else
return|return
name|E_OK
return|;
if|if
condition|(
name|result
operator|!=
name|E_OK
condition|)
block|{
name|DeleteChar
argument_list|(
name|form
argument_list|)
expr_stmt|;
name|Window_To_Buffer
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|result
operator|=
name|E_REQUEST_DENIED
expr_stmt|;
block|}
block|}
else|else
name|result
operator|=
name|E_OK
expr_stmt|;
comment|/* wrapping was not necessary */
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------   Field Editing routines   --------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int Field_Editing( |                                    int (* const fct) (FORM *), |                                    FORM * form) | |   Description   :  Generic routine for field editing requests. The driver |                    routines are only called for editable fields, the |                    _WINDOW_MODIFIED flag is set if editing occurred. |                    This is somewhat special due to the overload semantics |                    of the NEW_LINE and DEL_PREV requests. | |   Return Values :  Error code from low level drivers. +--------------------------------------------------------------------------*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|Field_Editing
argument_list|(
name|int
argument_list|(
operator|*
specifier|const
name|fct
argument_list|)
argument_list|(
name|FORM
operator|*
argument_list|)
argument_list|,
name|FORM
operator|*
name|form
argument_list|)
block|{
name|int
name|res
init|=
name|E_REQUEST_DENIED
decl_stmt|;
comment|/* We have to deal here with the specific case of the overloaded      behavior of New_Line and Delete_Previous requests.      They may end up in navigational requests if we are on the first      character in a field. But navigation is also allowed on non-      editable fields.    */
if|if
condition|(
operator|(
name|fct
operator|==
name|FE_Delete_Previous
operator|)
operator|&&
operator|(
name|form
operator|->
name|opts
operator|&
name|O_BS_OVERLOAD
operator|)
operator|&&
name|First_Position_In_Current_Field
argument_list|(
name|form
argument_list|)
condition|)
block|{
name|res
operator|=
name|Inter_Field_Navigation
argument_list|(
name|FN_Previous_Field
argument_list|,
name|form
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fct
operator|==
name|FE_New_Line
condition|)
block|{
if|if
condition|(
operator|(
name|form
operator|->
name|opts
operator|&
name|O_NL_OVERLOAD
operator|)
operator|&&
name|First_Position_In_Current_Field
argument_list|(
name|form
argument_list|)
condition|)
block|{
name|res
operator|=
name|Inter_Field_Navigation
argument_list|(
name|FN_Next_Field
argument_list|,
name|form
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* FE_New_Line deals itself with the _WINDOW_MODIFIED flag */
name|res
operator|=
name|fct
argument_list|(
name|form
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* From now on, everything must be editable */
if|if
condition|(
name|form
operator|->
name|current
operator|->
name|opts
operator|&
name|O_EDIT
condition|)
block|{
name|res
operator|=
name|fct
argument_list|(
name|form
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|E_OK
condition|)
name|form
operator|->
name|status
operator||=
name|_WINDOW_MODIFIED
expr_stmt|;
block|}
block|}
block|}
return|return
name|res
return|;
block|}
end_decl_stmt

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int FE_New_Line(FORM * form) | |   Description   :  Perform a new line request. This is rather complex |                    compared to other routines in this code due to the |                    rather difficult to understand description in the |                    manuals. | |   Return Values :  E_OK               - success |                    E_REQUEST_DENIED   - new line not allowed |                    E_SYSTEM_ERROR     - system error +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|FE_New_Line
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|FIELD
modifier|*
name|field
init|=
name|form
operator|->
name|current
decl_stmt|;
name|FIELD_CELL
modifier|*
name|bp
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|bool
name|Last_Row
init|=
operator|(
operator|(
name|field
operator|->
name|drows
operator|-
literal|1
operator|)
operator|==
name|form
operator|->
name|currow
operator|)
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"FE_New_Line(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|form
operator|->
name|status
operator|&
name|_OVLMODE
condition|)
block|{
if|if
condition|(
name|Last_Row
operator|&&
operator|(
operator|!
operator|(
name|Growable
argument_list|(
name|field
argument_list|)
operator|&&
operator|!
name|Single_Line_Field
argument_list|(
name|field
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|form
operator|->
name|opts
operator|&
name|O_NL_OVERLOAD
operator|)
condition|)
name|returnCode
argument_list|(
name|E_REQUEST_DENIED
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|form
operator|->
name|currow
argument_list|,
name|form
operator|->
name|curcol
argument_list|)
expr_stmt|;
name|wclrtoeol
argument_list|(
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
comment|/* we have to set this here, although it is also 	     handled in the generic routine. The reason is, 	     that FN_Next_Field may fail, but the form is 	     definitively changed */
name|form
operator|->
name|status
operator||=
name|_WINDOW_MODIFIED
expr_stmt|;
name|returnCode
argument_list|(
name|Inter_Field_Navigation
argument_list|(
name|FN_Next_Field
argument_list|,
name|form
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Last_Row
operator|&&
operator|!
name|Field_Grown
argument_list|(
name|field
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* N.B.: due to the logic in the 'if', LastRow==TRUE 	         means here that the field is growable and not 	         a single-line field */
name|returnCode
argument_list|(
name|E_SYSTEM_ERROR
argument_list|)
expr_stmt|;
block|}
name|wmove
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|form
operator|->
name|currow
argument_list|,
name|form
operator|->
name|curcol
argument_list|)
expr_stmt|;
name|wclrtoeol
argument_list|(
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
name|form
operator|->
name|currow
operator|++
expr_stmt|;
name|form
operator|->
name|curcol
operator|=
literal|0
expr_stmt|;
name|form
operator|->
name|status
operator||=
name|_WINDOW_MODIFIED
expr_stmt|;
name|returnCode
argument_list|(
name|E_OK
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Insert Mode */
if|if
condition|(
name|Last_Row
operator|&&
operator|!
operator|(
name|Growable
argument_list|(
name|field
argument_list|)
operator|&&
operator|!
name|Single_Line_Field
argument_list|(
name|field
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|form
operator|->
name|opts
operator|&
name|O_NL_OVERLOAD
operator|)
condition|)
name|returnCode
argument_list|(
name|E_REQUEST_DENIED
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|Inter_Field_Navigation
argument_list|(
name|FN_Next_Field
argument_list|,
name|form
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bool
name|May_Do_It
init|=
operator|!
name|Last_Row
operator|&&
name|Is_There_Room_For_A_Line
argument_list|(
name|form
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|May_Do_It
operator|||
name|Growable
argument_list|(
name|field
argument_list|)
operator|)
condition|)
name|returnCode
argument_list|(
name|E_REQUEST_DENIED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|May_Do_It
operator|&&
operator|!
name|Field_Grown
argument_list|(
name|field
argument_list|,
literal|1
argument_list|)
condition|)
name|returnCode
argument_list|(
name|E_SYSTEM_ERROR
argument_list|)
expr_stmt|;
name|bp
operator|=
name|Address_Of_Current_Position_In_Buffer
argument_list|(
name|form
argument_list|)
expr_stmt|;
name|t
operator|=
name|After_End_Of_Data
argument_list|(
name|bp
argument_list|,
name|field
operator|->
name|dcols
operator|-
name|form
operator|->
name|curcol
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|form
operator|->
name|currow
argument_list|,
name|form
operator|->
name|curcol
argument_list|)
expr_stmt|;
name|wclrtoeol
argument_list|(
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
name|form
operator|->
name|currow
operator|++
expr_stmt|;
name|form
operator|->
name|curcol
operator|=
literal|0
expr_stmt|;
name|wmove
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|form
operator|->
name|currow
argument_list|,
name|form
operator|->
name|curcol
argument_list|)
expr_stmt|;
name|winsertln
argument_list|(
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
name|myADDNSTR
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|bp
argument_list|,
call|(
name|int
call|)
argument_list|(
name|t
operator|-
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|form
operator|->
name|status
operator||=
name|_WINDOW_MODIFIED
expr_stmt|;
name|returnCode
argument_list|(
name|E_OK
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int FE_Insert_Character(FORM * form) | |   Description   :  Insert blank character at the cursor position | |   Return Values :  E_OK |                    E_REQUEST_DENIED +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|FE_Insert_Character
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|FIELD
modifier|*
name|field
init|=
name|form
operator|->
name|current
decl_stmt|;
name|int
name|result
init|=
name|E_REQUEST_DENIED
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"FE_Insert_Character(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Check_Char
argument_list|(
name|field
operator|->
name|type
argument_list|,
operator|(
name|int
operator|)
name|C_BLANK
argument_list|,
operator|(
name|TypeArgument
operator|*
operator|)
operator|(
name|field
operator|->
name|arg
operator|)
argument_list|)
condition|)
block|{
name|bool
name|There_Is_Room
init|=
name|Is_There_Room_For_A_Char_In_Line
argument_list|(
name|form
argument_list|)
decl_stmt|;
if|if
condition|(
name|There_Is_Room
operator|||
operator|(
operator|(
name|Single_Line_Field
argument_list|(
name|field
argument_list|)
operator|&&
name|Growable
argument_list|(
name|field
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|There_Is_Room
operator|&&
operator|!
name|Field_Grown
argument_list|(
name|field
argument_list|,
literal|1
argument_list|)
condition|)
name|result
operator|=
name|E_SYSTEM_ERROR
expr_stmt|;
else|else
block|{
name|winsch
argument_list|(
name|form
operator|->
name|w
argument_list|,
operator|(
name|chtype
operator|)
name|C_BLANK
argument_list|)
expr_stmt|;
name|result
operator|=
name|Wrapping_Not_Necessary_Or_Wrapping_Ok
argument_list|(
name|form
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|returnCode
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int FE_Insert_Line(FORM * form) | |   Description   :  Insert a blank line at the cursor position | |   Return Values :  E_OK               - success |                    E_REQUEST_DENIED   - line can not be inserted +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|FE_Insert_Line
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|FIELD
modifier|*
name|field
init|=
name|form
operator|->
name|current
decl_stmt|;
name|int
name|result
init|=
name|E_REQUEST_DENIED
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"FE_Insert_Line(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Check_Char
argument_list|(
name|field
operator|->
name|type
argument_list|,
operator|(
name|int
operator|)
name|C_BLANK
argument_list|,
operator|(
name|TypeArgument
operator|*
operator|)
operator|(
name|field
operator|->
name|arg
operator|)
argument_list|)
condition|)
block|{
name|bool
name|Maybe_Done
init|=
operator|(
name|form
operator|->
name|currow
operator|!=
operator|(
name|field
operator|->
name|drows
operator|-
literal|1
operator|)
operator|)
operator|&&
name|Is_There_Room_For_A_Line
argument_list|(
name|form
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Single_Line_Field
argument_list|(
name|field
argument_list|)
operator|&&
operator|(
name|Maybe_Done
operator|||
name|Growable
argument_list|(
name|field
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|Maybe_Done
operator|&&
operator|!
name|Field_Grown
argument_list|(
name|field
argument_list|,
literal|1
argument_list|)
condition|)
name|result
operator|=
name|E_SYSTEM_ERROR
expr_stmt|;
else|else
block|{
name|form
operator|->
name|curcol
operator|=
literal|0
expr_stmt|;
name|winsertln
argument_list|(
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
name|result
operator|=
name|E_OK
expr_stmt|;
block|}
block|}
block|}
name|returnCode
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int FE_Delete_Character(FORM * form) | |   Description   :  Delete character at the cursor position | |   Return Values :  E_OK    - success +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|FE_Delete_Character
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"FE_Delete_Character(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
name|DeleteChar
argument_list|(
name|form
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|E_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int FE_Delete_Previous(FORM * form) | |   Description   :  Delete character before cursor. Again this is a rather |                    difficult piece compared to others due to the overloading |                    semantics of backspace. |                    N.B.: The case of overloaded BS on first field position |                          is already handled in the generic routine. | |   Return Values :  E_OK                - success |                    E_REQUEST_DENIED    - Character can't be deleted +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|FE_Delete_Previous
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|FIELD
modifier|*
name|field
init|=
name|form
operator|->
name|current
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"FE_Delete_Previous(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|First_Position_In_Current_Field
argument_list|(
name|form
argument_list|)
condition|)
name|returnCode
argument_list|(
name|E_REQUEST_DENIED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|--
operator|(
name|form
operator|->
name|curcol
operator|)
operator|)
operator|<
literal|0
condition|)
block|{
name|FIELD_CELL
modifier|*
name|this_line
decl_stmt|,
modifier|*
name|prev_line
decl_stmt|,
modifier|*
name|prev_end
decl_stmt|,
modifier|*
name|this_end
decl_stmt|;
name|int
name|this_row
init|=
name|form
operator|->
name|currow
decl_stmt|;
name|form
operator|->
name|curcol
operator|++
expr_stmt|;
if|if
condition|(
name|form
operator|->
name|status
operator|&
name|_OVLMODE
condition|)
name|returnCode
argument_list|(
name|E_REQUEST_DENIED
argument_list|)
expr_stmt|;
name|prev_line
operator|=
name|Address_Of_Row_In_Buffer
argument_list|(
name|field
argument_list|,
operator|(
name|form
operator|->
name|currow
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|this_line
operator|=
name|Address_Of_Row_In_Buffer
argument_list|(
name|field
argument_list|,
operator|(
name|form
operator|->
name|currow
operator|)
argument_list|)
expr_stmt|;
name|Synchronize_Buffer
argument_list|(
name|form
argument_list|)
expr_stmt|;
name|prev_end
operator|=
name|After_End_Of_Data
argument_list|(
name|prev_line
argument_list|,
name|field
operator|->
name|dcols
argument_list|)
expr_stmt|;
name|this_end
operator|=
name|After_End_Of_Data
argument_list|(
name|this_line
argument_list|,
name|field
operator|->
name|dcols
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|this_end
operator|-
name|this_line
argument_list|)
operator|>
operator|(
name|field
operator|->
name|cols
operator|-
call|(
name|int
call|)
argument_list|(
name|prev_end
operator|-
name|prev_line
argument_list|)
operator|)
condition|)
name|returnCode
argument_list|(
name|E_REQUEST_DENIED
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|form
operator|->
name|currow
argument_list|,
name|form
operator|->
name|curcol
argument_list|)
expr_stmt|;
name|wdeleteln
argument_list|(
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
name|Adjust_Cursor_Position
argument_list|(
name|form
argument_list|,
name|prev_end
argument_list|)
expr_stmt|;
comment|/*        * If we did not really move to the previous line, help the user a        * little.  It is however a little inconsistent.  Normally, when        * backspacing around the point where text wraps to a new line in a        * multi-line form, we absorb one keystroke for the wrapping point.  That        * is consistent with SVr4 forms.  However, SVr4 does not allow typing        * into the last column of the field, and requires the user to enter a        * newline to move to the next line.  Therefore it can consistently eat        * that keystroke.  Since ncurses allows the last column, it wraps        * automatically (given the proper options).  But we cannot eat the        * keystroke to back over the wrapping point, since that would put the        * cursor past the end of the form field.  In this case, just delete the        * character at the end of the field.        */
if|if
condition|(
name|form
operator|->
name|currow
operator|==
name|this_row
operator|&&
name|this_row
operator|>
literal|0
condition|)
block|{
name|form
operator|->
name|currow
operator|-=
literal|1
expr_stmt|;
name|form
operator|->
name|curcol
operator|=
name|field
operator|->
name|dcols
operator|-
literal|1
expr_stmt|;
name|DeleteChar
argument_list|(
name|form
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wmove
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|form
operator|->
name|currow
argument_list|,
name|form
operator|->
name|curcol
argument_list|)
expr_stmt|;
name|myADDNSTR
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|this_line
argument_list|,
call|(
name|int
call|)
argument_list|(
name|this_end
operator|-
name|this_line
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|DeleteChar
argument_list|(
name|form
argument_list|)
expr_stmt|;
block|}
name|returnCode
argument_list|(
name|E_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int FE_Delete_Line(FORM * form) | |   Description   :  Delete line at cursor position. | |   Return Values :  E_OK  - success +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|FE_Delete_Line
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"FE_Delete_Line(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
name|form
operator|->
name|curcol
operator|=
literal|0
expr_stmt|;
name|wdeleteln
argument_list|(
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|E_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int FE_Delete_Word(FORM * form) | |   Description   :  Delete word at cursor position | |   Return Values :  E_OK               - success |                    E_REQUEST_DENIED   - failure +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|FE_Delete_Word
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|FIELD
modifier|*
name|field
init|=
name|form
operator|->
name|current
decl_stmt|;
name|FIELD_CELL
modifier|*
name|bp
init|=
name|Address_Of_Current_Row_In_Buffer
argument_list|(
name|form
argument_list|)
decl_stmt|;
name|FIELD_CELL
modifier|*
name|ep
init|=
name|bp
operator|+
name|field
operator|->
name|dcols
decl_stmt|;
name|FIELD_CELL
modifier|*
name|cp
init|=
name|bp
operator|+
name|form
operator|->
name|curcol
decl_stmt|;
name|FIELD_CELL
modifier|*
name|s
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"FE_Delete_Word(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
name|Synchronize_Buffer
argument_list|(
name|form
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISBLANK
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|returnCode
argument_list|(
name|E_REQUEST_DENIED
argument_list|)
expr_stmt|;
comment|/* not in word */
comment|/* move cursor to begin of word and erase to end of screen-line */
name|Adjust_Cursor_Position
argument_list|(
name|form
argument_list|,
name|After_Last_Whitespace_Character
argument_list|(
name|bp
argument_list|,
name|form
operator|->
name|curcol
argument_list|)
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|form
operator|->
name|currow
argument_list|,
name|form
operator|->
name|curcol
argument_list|)
expr_stmt|;
name|wclrtoeol
argument_list|(
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
comment|/* skip over word in buffer */
name|s
operator|=
name|Get_First_Whitespace_Character
argument_list|(
name|cp
argument_list|,
call|(
name|int
call|)
argument_list|(
name|ep
operator|-
name|cp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* to begin of next word    */
name|s
operator|=
name|Get_Start_Of_Data
argument_list|(
name|s
argument_list|,
call|(
name|int
call|)
argument_list|(
name|ep
operator|-
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|!=
name|cp
operator|)
operator|&&
operator|!
name|ISBLANK
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
comment|/* copy remaining line to window */
name|myADDNSTR
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|s
argument_list|,
call|(
name|int
call|)
argument_list|(
name|s
operator|-
name|After_End_Of_Data
argument_list|(
name|s
argument_list|,
call|(
name|int
call|)
argument_list|(
name|ep
operator|-
name|s
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|returnCode
argument_list|(
name|E_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int FE_Clear_To_End_Of_Line(FORM * form) | |   Description   :  Clear to end of current line. | |   Return Values :  E_OK   - success +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|FE_Clear_To_End_Of_Line
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"FE_Clear_To_End_Of_Line(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|form
operator|->
name|currow
argument_list|,
name|form
operator|->
name|curcol
argument_list|)
expr_stmt|;
name|wclrtoeol
argument_list|(
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|E_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int FE_Clear_To_End_Of_Field(FORM * form) | |   Description   :  Clear to end of field. | |   Return Values :  E_OK   - success +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|FE_Clear_To_End_Of_Field
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"FE_Clear_To_End_Of_Field(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|form
operator|->
name|currow
argument_list|,
name|form
operator|->
name|curcol
argument_list|)
expr_stmt|;
name|wclrtobot
argument_list|(
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|E_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int FE_Clear_Field(FORM * form) | |   Description   :  Clear entire field. | |   Return Values :  E_OK   - success +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|FE_Clear_Field
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"FE_Clear_Field(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
name|form
operator|->
name|currow
operator|=
name|form
operator|->
name|curcol
operator|=
literal|0
expr_stmt|;
name|werase
argument_list|(
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|E_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------   END of Field Editing routines   --------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*----------------------------------------------------------------------------   Edit Mode routines   --------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int EM_Overlay_Mode(FORM * form) | |   Description   :  Switch to overlay mode. | |   Return Values :  E_OK   - success +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|EM_Overlay_Mode
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"EM_Overlay_Mode(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
name|form
operator|->
name|status
operator||=
name|_OVLMODE
expr_stmt|;
name|returnCode
argument_list|(
name|E_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int EM_Insert_Mode(FORM * form) | |   Description   :  Switch to insert mode | |   Return Values :  E_OK   - success +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|EM_Insert_Mode
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"EM_Insert_Mode(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
name|form
operator|->
name|status
operator|&=
operator|~
name|_OVLMODE
expr_stmt|;
name|returnCode
argument_list|(
name|E_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------   END of Edit Mode routines   --------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*----------------------------------------------------------------------------   Helper routines for Choice Requests   --------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static bool Next_Choice( |                                            FIELDTYPE * typ, |                                            FIELD * field, |                                            TypeArgument *argp) | |   Description   :  Get the next field choice. For linked types this is |                    done recursively. | |   Return Values :  TRUE    - next choice successfully retrieved |                    FALSE   - couldn't retrieve next choice +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|bool
name|Next_Choice
parameter_list|(
name|FIELDTYPE
modifier|*
name|typ
parameter_list|,
name|FIELD
modifier|*
name|field
parameter_list|,
name|TypeArgument
modifier|*
name|argp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|typ
operator|||
operator|!
operator|(
name|typ
operator|->
name|status
operator|&
name|_HAS_CHOICE
operator|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|typ
operator|->
name|status
operator|&
name|_LINKED_TYPE
condition|)
block|{
name|assert
argument_list|(
name|argp
argument_list|)
expr_stmt|;
return|return
operator|(
name|Next_Choice
argument_list|(
name|typ
operator|->
name|left
argument_list|,
name|field
argument_list|,
name|argp
operator|->
name|left
argument_list|)
operator|||
name|Next_Choice
argument_list|(
name|typ
operator|->
name|right
argument_list|,
name|field
argument_list|,
name|argp
operator|->
name|right
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|assert
argument_list|(
name|typ
operator|->
name|next
argument_list|)
expr_stmt|;
return|return
name|typ
operator|->
name|next
argument_list|(
name|field
argument_list|,
operator|(
name|void
operator|*
operator|)
name|argp
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static bool Previous_Choice( |                                                FIELDTYPE * typ, |                                                FIELD * field, |                                                TypeArgument *argp) | |   Description   :  Get the previous field choice. For linked types this |                    is done recursively. | |   Return Values :  TRUE    - previous choice successfully retrieved |                    FALSE   - couldn't retrieve previous choice +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|bool
name|Previous_Choice
parameter_list|(
name|FIELDTYPE
modifier|*
name|typ
parameter_list|,
name|FIELD
modifier|*
name|field
parameter_list|,
name|TypeArgument
modifier|*
name|argp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|typ
operator|||
operator|!
operator|(
name|typ
operator|->
name|status
operator|&
name|_HAS_CHOICE
operator|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|typ
operator|->
name|status
operator|&
name|_LINKED_TYPE
condition|)
block|{
name|assert
argument_list|(
name|argp
argument_list|)
expr_stmt|;
return|return
operator|(
name|Previous_Choice
argument_list|(
name|typ
operator|->
name|left
argument_list|,
name|field
argument_list|,
name|argp
operator|->
name|left
argument_list|)
operator|||
name|Previous_Choice
argument_list|(
name|typ
operator|->
name|right
argument_list|,
name|field
argument_list|,
name|argp
operator|->
name|right
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|assert
argument_list|(
name|typ
operator|->
name|prev
argument_list|)
expr_stmt|;
return|return
name|typ
operator|->
name|prev
argument_list|(
name|field
argument_list|,
operator|(
name|void
operator|*
operator|)
name|argp
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------   End of Helper routines for Choice Requests   --------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*----------------------------------------------------------------------------   Routines for Choice Requests   --------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int CR_Next_Choice(FORM * form) | |   Description   :  Get the next field choice. | |   Return Values :  E_OK              - success |                    E_REQUEST_DENIED  - next choice couldn't be retrieved +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|CR_Next_Choice
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|FIELD
modifier|*
name|field
init|=
name|form
operator|->
name|current
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"CR_Next_Choice(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
name|Synchronize_Buffer
argument_list|(
name|form
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
operator|(
name|Next_Choice
argument_list|(
name|field
operator|->
name|type
argument_list|,
name|field
argument_list|,
operator|(
name|TypeArgument
operator|*
operator|)
operator|(
name|field
operator|->
name|arg
operator|)
argument_list|)
operator|)
condition|?
name|E_OK
else|:
name|E_REQUEST_DENIED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int CR_Previous_Choice(FORM * form) | |   Description   :  Get the previous field choice. | |   Return Values :  E_OK              - success |                    E_REQUEST_DENIED  - prev. choice couldn't be retrieved +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|CR_Previous_Choice
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|FIELD
modifier|*
name|field
init|=
name|form
operator|->
name|current
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"CR_Previous_Choice(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
name|Synchronize_Buffer
argument_list|(
name|form
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
operator|(
name|Previous_Choice
argument_list|(
name|field
operator|->
name|type
argument_list|,
name|field
argument_list|,
operator|(
name|TypeArgument
operator|*
operator|)
operator|(
name|field
operator|->
name|arg
operator|)
argument_list|)
operator|)
condition|?
name|E_OK
else|:
name|E_REQUEST_DENIED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------   End of Routines for Choice Requests   --------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*----------------------------------------------------------------------------   Helper routines for Field Validations.   --------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static bool Check_Field( |                                            FIELDTYPE * typ, |                                            FIELD * field, |                                            TypeArgument * argp) | |   Description   :  Check the field according to its fieldtype and its |                    actual arguments. For linked fieldtypes this is done |                    recursively. | |   Return Values :  TRUE       - field is valid |                    FALSE      - field is invalid. +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|bool
name|Check_Field
parameter_list|(
name|FIELDTYPE
modifier|*
name|typ
parameter_list|,
name|FIELD
modifier|*
name|field
parameter_list|,
name|TypeArgument
modifier|*
name|argp
parameter_list|)
block|{
if|if
condition|(
name|typ
condition|)
block|{
if|if
condition|(
name|field
operator|->
name|opts
operator|&
name|O_NULLOK
condition|)
block|{
name|FIELD_CELL
modifier|*
name|bp
init|=
name|field
operator|->
name|buf
decl_stmt|;
name|assert
argument_list|(
name|bp
argument_list|)
expr_stmt|;
while|while
condition|(
name|ISBLANK
argument_list|(
operator|*
name|bp
argument_list|)
condition|)
block|{
name|bp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|CharOf
argument_list|(
operator|*
name|bp
argument_list|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|typ
operator|->
name|status
operator|&
name|_LINKED_TYPE
condition|)
block|{
name|assert
argument_list|(
name|argp
argument_list|)
expr_stmt|;
return|return
operator|(
name|Check_Field
argument_list|(
name|typ
operator|->
name|left
argument_list|,
name|field
argument_list|,
name|argp
operator|->
name|left
argument_list|)
operator|||
name|Check_Field
argument_list|(
name|typ
operator|->
name|right
argument_list|,
name|field
argument_list|,
name|argp
operator|->
name|right
argument_list|)
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|typ
operator|->
name|fcheck
condition|)
return|return
name|typ
operator|->
name|fcheck
argument_list|(
name|field
argument_list|,
operator|(
name|void
operator|*
operator|)
name|argp
argument_list|)
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  bool _nc_Internal_Validation(FORM * form ) | |   Description   :  Validate the current field of the form. | |   Return Values :  TRUE  - field is valid |                    FALSE - field is invalid +--------------------------------------------------------------------------*/
end_comment

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|bool
argument_list|)
end_macro

begin_macro
name|_nc_Internal_Validation
argument_list|(
argument|FORM *form
argument_list|)
end_macro

begin_block
block|{
name|FIELD
modifier|*
name|field
decl_stmt|;
name|field
operator|=
name|form
operator|->
name|current
expr_stmt|;
name|Synchronize_Buffer
argument_list|(
name|form
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|form
operator|->
name|status
operator|&
name|_FCHECK_REQUIRED
operator|)
operator|||
operator|(
operator|!
operator|(
name|field
operator|->
name|opts
operator|&
name|O_PASSOK
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|Check_Field
argument_list|(
name|field
operator|->
name|type
argument_list|,
name|field
argument_list|,
operator|(
name|TypeArgument
operator|*
operator|)
operator|(
name|field
operator|->
name|arg
operator|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|form
operator|->
name|status
operator|&=
operator|~
name|_FCHECK_REQUIRED
expr_stmt|;
name|field
operator|->
name|status
operator||=
name|_CHANGED
expr_stmt|;
name|Synchronize_Linked_Fields
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------   End of Helper routines for Field Validations.   --------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*----------------------------------------------------------------------------   Routines for Field Validation.   --------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int FV_Validation(FORM * form) | |   Description   :  Validate the current field of the form. | |   Return Values :  E_OK             - field valid |                    E_INVALID_FIELD  - field not valid +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|FV_Validation
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"FV_Validation(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|_nc_Internal_Validation
argument_list|(
name|form
argument_list|)
condition|)
name|returnCode
argument_list|(
name|E_OK
argument_list|)
expr_stmt|;
else|else
name|returnCode
argument_list|(
name|E_INVALID_FIELD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------   End of routines for Field Validation.   --------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*----------------------------------------------------------------------------   Helper routines for Inter-Field Navigation   --------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static FIELD *Next_Field_On_Page(FIELD * field) | |   Description   :  Get the next field after the given field on the current |                    page. The order of fields is the one defined by the |                    fields array. Only visible and active fields are |                    counted. | |   Return Values :  Pointer to the next field. +--------------------------------------------------------------------------*/
end_comment

begin_function
name|NCURSES_INLINE
specifier|static
name|FIELD
modifier|*
name|Next_Field_On_Page
parameter_list|(
name|FIELD
modifier|*
name|field
parameter_list|)
block|{
name|FORM
modifier|*
name|form
init|=
name|field
operator|->
name|form
decl_stmt|;
name|FIELD
modifier|*
modifier|*
name|field_on_page
init|=
operator|&
name|form
operator|->
name|field
index|[
name|field
operator|->
name|index
index|]
decl_stmt|;
name|FIELD
modifier|*
modifier|*
name|first_on_page
init|=
operator|&
name|form
operator|->
name|field
index|[
name|form
operator|->
name|page
index|[
name|form
operator|->
name|curpage
index|]
operator|.
name|pmin
index|]
decl_stmt|;
name|FIELD
modifier|*
modifier|*
name|last_on_page
init|=
operator|&
name|form
operator|->
name|field
index|[
name|form
operator|->
name|page
index|[
name|form
operator|->
name|curpage
index|]
operator|.
name|pmax
index|]
decl_stmt|;
do|do
block|{
name|field_on_page
operator|=
operator|(
name|field_on_page
operator|==
name|last_on_page
operator|)
condition|?
name|first_on_page
else|:
name|field_on_page
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|Field_Is_Selectable
argument_list|(
operator|*
name|field_on_page
argument_list|)
condition|)
break|break;
block|}
do|while
condition|(
name|field
operator|!=
operator|(
operator|*
name|field_on_page
operator|)
condition|)
do|;
return|return
operator|(
operator|*
name|field_on_page
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  FIELD* _nc_First_Active_Field(FORM * form) | |   Description   :  Get the first active field on the current page, |                    if there are such. If there are none, get the first |                    visible field on the page. If there are also none, |                    we return the first field on page and hope the best. | |   Return Values :  Pointer to calculated field. +--------------------------------------------------------------------------*/
end_comment

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|FIELD *
argument_list|)
end_macro

begin_macro
name|_nc_First_Active_Field
argument_list|(
argument|FORM *form
argument_list|)
end_macro

begin_block
block|{
name|FIELD
modifier|*
modifier|*
name|last_on_page
init|=
operator|&
name|form
operator|->
name|field
index|[
name|form
operator|->
name|page
index|[
name|form
operator|->
name|curpage
index|]
operator|.
name|pmax
index|]
decl_stmt|;
name|FIELD
modifier|*
name|proposed
init|=
name|Next_Field_On_Page
argument_list|(
operator|*
name|last_on_page
argument_list|)
decl_stmt|;
if|if
condition|(
name|proposed
operator|==
operator|*
name|last_on_page
condition|)
block|{
comment|/* there might be the special situation, where there is no          active and visible field on the current page. We then select          the first visible field on this readonly page        */
if|if
condition|(
name|Field_Is_Not_Selectable
argument_list|(
name|proposed
argument_list|)
condition|)
block|{
name|FIELD
modifier|*
modifier|*
name|field
init|=
operator|&
name|form
operator|->
name|field
index|[
name|proposed
operator|->
name|index
index|]
decl_stmt|;
name|FIELD
modifier|*
modifier|*
name|first
init|=
operator|&
name|form
operator|->
name|field
index|[
name|form
operator|->
name|page
index|[
name|form
operator|->
name|curpage
index|]
operator|.
name|pmin
index|]
decl_stmt|;
do|do
block|{
name|field
operator|=
operator|(
name|field
operator|==
name|last_on_page
operator|)
condition|?
name|first
else|:
name|field
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|*
name|field
operator|)
operator|->
name|opts
operator|&
name|O_VISIBLE
operator|)
condition|)
break|break;
block|}
do|while
condition|(
name|proposed
operator|!=
operator|(
operator|*
name|field
operator|)
condition|)
do|;
name|proposed
operator|=
operator|*
name|field
expr_stmt|;
if|if
condition|(
operator|(
name|proposed
operator|==
operator|*
name|last_on_page
operator|)
operator|&&
operator|!
operator|(
name|proposed
operator|->
name|opts
operator|&
name|O_VISIBLE
operator|)
condition|)
block|{
comment|/* This means, there is also no visible field on the page. 	         So we propose the first one and hope the very best... 	         Some very clever user has designed a readonly and invisible 	         page on this form. 	       */
name|proposed
operator|=
operator|*
name|first
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|proposed
operator|)
return|;
block|}
end_block

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static FIELD *Previous_Field_On_Page(FIELD * field) | |   Description   :  Get the previous field before the given field on the |                    current page. The order of fields is the one defined by |                    the fields array. Only visible and active fields are |                    counted. | |   Return Values :  Pointer to the previous field. +--------------------------------------------------------------------------*/
end_comment

begin_function
name|NCURSES_INLINE
specifier|static
name|FIELD
modifier|*
name|Previous_Field_On_Page
parameter_list|(
name|FIELD
modifier|*
name|field
parameter_list|)
block|{
name|FORM
modifier|*
name|form
init|=
name|field
operator|->
name|form
decl_stmt|;
name|FIELD
modifier|*
modifier|*
name|field_on_page
init|=
operator|&
name|form
operator|->
name|field
index|[
name|field
operator|->
name|index
index|]
decl_stmt|;
name|FIELD
modifier|*
modifier|*
name|first_on_page
init|=
operator|&
name|form
operator|->
name|field
index|[
name|form
operator|->
name|page
index|[
name|form
operator|->
name|curpage
index|]
operator|.
name|pmin
index|]
decl_stmt|;
name|FIELD
modifier|*
modifier|*
name|last_on_page
init|=
operator|&
name|form
operator|->
name|field
index|[
name|form
operator|->
name|page
index|[
name|form
operator|->
name|curpage
index|]
operator|.
name|pmax
index|]
decl_stmt|;
do|do
block|{
name|field_on_page
operator|=
operator|(
name|field_on_page
operator|==
name|first_on_page
operator|)
condition|?
name|last_on_page
else|:
name|field_on_page
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|Field_Is_Selectable
argument_list|(
operator|*
name|field_on_page
argument_list|)
condition|)
break|break;
block|}
do|while
condition|(
name|field
operator|!=
operator|(
operator|*
name|field_on_page
operator|)
condition|)
do|;
return|return
operator|(
operator|*
name|field_on_page
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static FIELD *Sorted_Next_Field(FIELD * field) | |   Description   :  Get the next field after the given field on the current |                    page. The order of fields is the one defined by the |                    (row,column) geometry, rows are major. | |   Return Values :  Pointer to the next field. +--------------------------------------------------------------------------*/
end_comment

begin_function
name|NCURSES_INLINE
specifier|static
name|FIELD
modifier|*
name|Sorted_Next_Field
parameter_list|(
name|FIELD
modifier|*
name|field
parameter_list|)
block|{
name|FIELD
modifier|*
name|field_on_page
init|=
name|field
decl_stmt|;
do|do
block|{
name|field_on_page
operator|=
name|field_on_page
operator|->
name|snext
expr_stmt|;
if|if
condition|(
name|Field_Is_Selectable
argument_list|(
name|field_on_page
argument_list|)
condition|)
break|break;
block|}
do|while
condition|(
name|field_on_page
operator|!=
name|field
condition|)
do|;
return|return
operator|(
name|field_on_page
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static FIELD *Sorted_Previous_Field(FIELD * field) | |   Description   :  Get the previous field before the given field on the |                    current page. The order of fields is the one defined |                    by the (row,column) geometry, rows are major. | |   Return Values :  Pointer to the previous field. +--------------------------------------------------------------------------*/
end_comment

begin_function
name|NCURSES_INLINE
specifier|static
name|FIELD
modifier|*
name|Sorted_Previous_Field
parameter_list|(
name|FIELD
modifier|*
name|field
parameter_list|)
block|{
name|FIELD
modifier|*
name|field_on_page
init|=
name|field
decl_stmt|;
do|do
block|{
name|field_on_page
operator|=
name|field_on_page
operator|->
name|sprev
expr_stmt|;
if|if
condition|(
name|Field_Is_Selectable
argument_list|(
name|field_on_page
argument_list|)
condition|)
break|break;
block|}
do|while
condition|(
name|field_on_page
operator|!=
name|field
condition|)
do|;
return|return
operator|(
name|field_on_page
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static FIELD *Left_Neighbor_Field(FIELD * field) | |   Description   :  Get the left neighbor of the field on the same line |                    and the same page. Cycles through the line. | |   Return Values :  Pointer to left neighbor field. +--------------------------------------------------------------------------*/
end_comment

begin_function
name|NCURSES_INLINE
specifier|static
name|FIELD
modifier|*
name|Left_Neighbor_Field
parameter_list|(
name|FIELD
modifier|*
name|field
parameter_list|)
block|{
name|FIELD
modifier|*
name|field_on_page
init|=
name|field
decl_stmt|;
comment|/* For a field that has really a left neighbor, the while clause      immediately fails and the loop is left, positioned at the right      neighbor. Otherwise we cycle backwards through the sorted field list      until we enter the same line (from the right end).    */
do|do
block|{
name|field_on_page
operator|=
name|Sorted_Previous_Field
argument_list|(
name|field_on_page
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|field_on_page
operator|->
name|frow
operator|!=
name|field
operator|->
name|frow
condition|)
do|;
return|return
operator|(
name|field_on_page
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static FIELD *Right_Neighbor_Field(FIELD * field) | |   Description   :  Get the right neighbor of the field on the same line |                    and the same page. | |   Return Values :  Pointer to right neighbor field. +--------------------------------------------------------------------------*/
end_comment

begin_function
name|NCURSES_INLINE
specifier|static
name|FIELD
modifier|*
name|Right_Neighbor_Field
parameter_list|(
name|FIELD
modifier|*
name|field
parameter_list|)
block|{
name|FIELD
modifier|*
name|field_on_page
init|=
name|field
decl_stmt|;
comment|/* See the comments on Left_Neighbor_Field to understand how it works */
do|do
block|{
name|field_on_page
operator|=
name|Sorted_Next_Field
argument_list|(
name|field_on_page
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|field_on_page
operator|->
name|frow
operator|!=
name|field
operator|->
name|frow
condition|)
do|;
return|return
operator|(
name|field_on_page
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static FIELD *Upper_Neighbor_Field(FIELD * field) | |   Description   :  Because of the row-major nature of sorting the fields, |                    it is more difficult to define whats the upper neighbor |                    field really means. We define that it must be on a |                    'previous' line (cyclic order!) and is the rightmost |                    field laying on the left side of the given field. If |                    this set is empty, we take the first field on the line. | |   Return Values :  Pointer to the upper neighbor field. +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|FIELD
modifier|*
name|Upper_Neighbor_Field
parameter_list|(
name|FIELD
modifier|*
name|field
parameter_list|)
block|{
name|FIELD
modifier|*
name|field_on_page
init|=
name|field
decl_stmt|;
name|int
name|frow
init|=
name|field
operator|->
name|frow
decl_stmt|;
name|int
name|fcol
init|=
name|field
operator|->
name|fcol
decl_stmt|;
comment|/* Walk back to the 'previous' line. The second term in the while clause      just guarantees that we stop if we cycled through the line because      there might be no 'previous' line if the page has just one line.    */
do|do
block|{
name|field_on_page
operator|=
name|Sorted_Previous_Field
argument_list|(
name|field_on_page
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|field_on_page
operator|->
name|frow
operator|==
name|frow
operator|&&
name|field_on_page
operator|->
name|fcol
operator|!=
name|fcol
condition|)
do|;
if|if
condition|(
name|field_on_page
operator|->
name|frow
operator|!=
name|frow
condition|)
block|{
comment|/* We really found a 'previous' line. We are positioned at the          rightmost field on this line */
name|frow
operator|=
name|field_on_page
operator|->
name|frow
expr_stmt|;
comment|/* We walk to the left as long as we are really right of the          field. */
while|while
condition|(
name|field_on_page
operator|->
name|frow
operator|==
name|frow
operator|&&
name|field_on_page
operator|->
name|fcol
operator|>
name|fcol
condition|)
name|field_on_page
operator|=
name|Sorted_Previous_Field
argument_list|(
name|field_on_page
argument_list|)
expr_stmt|;
comment|/* If we wrapped, just go to the right which is the first field on          the row */
if|if
condition|(
name|field_on_page
operator|->
name|frow
operator|!=
name|frow
condition|)
name|field_on_page
operator|=
name|Sorted_Next_Field
argument_list|(
name|field_on_page
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|field_on_page
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static FIELD *Down_Neighbor_Field(FIELD * field) | |   Description   :  Because of the row-major nature of sorting the fields, |                    its more difficult to define whats the down neighbor |                    field really means. We define that it must be on a |                    'next' line (cyclic order!) and is the leftmost |                    field laying on the right side of the given field. If |                    this set is empty, we take the last field on the line. | |   Return Values :  Pointer to the upper neighbor field. +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|FIELD
modifier|*
name|Down_Neighbor_Field
parameter_list|(
name|FIELD
modifier|*
name|field
parameter_list|)
block|{
name|FIELD
modifier|*
name|field_on_page
init|=
name|field
decl_stmt|;
name|int
name|frow
init|=
name|field
operator|->
name|frow
decl_stmt|;
name|int
name|fcol
init|=
name|field
operator|->
name|fcol
decl_stmt|;
comment|/* Walk forward to the 'next' line. The second term in the while clause      just guarantees that we stop if we cycled through the line because      there might be no 'next' line if the page has just one line.    */
do|do
block|{
name|field_on_page
operator|=
name|Sorted_Next_Field
argument_list|(
name|field_on_page
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|field_on_page
operator|->
name|frow
operator|==
name|frow
operator|&&
name|field_on_page
operator|->
name|fcol
operator|!=
name|fcol
condition|)
do|;
if|if
condition|(
name|field_on_page
operator|->
name|frow
operator|!=
name|frow
condition|)
block|{
comment|/* We really found a 'next' line. We are positioned at the rightmost          field on this line */
name|frow
operator|=
name|field_on_page
operator|->
name|frow
expr_stmt|;
comment|/* We walk to the right as long as we are really left of the          field. */
while|while
condition|(
name|field_on_page
operator|->
name|frow
operator|==
name|frow
operator|&&
name|field_on_page
operator|->
name|fcol
operator|<
name|fcol
condition|)
name|field_on_page
operator|=
name|Sorted_Next_Field
argument_list|(
name|field_on_page
argument_list|)
expr_stmt|;
comment|/* If we wrapped, just go to the left which is the last field on          the row */
if|if
condition|(
name|field_on_page
operator|->
name|frow
operator|!=
name|frow
condition|)
name|field_on_page
operator|=
name|Sorted_Previous_Field
argument_list|(
name|field_on_page
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|field_on_page
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------   Inter-Field Navigation routines   --------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int Inter_Field_Navigation( |                                           int (* const fct) (FORM *), |                                           FORM * form) | |   Description   :  Generic behavior for changing the current field, the |                    field is left and a new field is entered. So the field |                    must be validated and the field init/term hooks must |                    be called. | |   Return Values :  E_OK                - success |                    E_INVALID_FIELD     - field is invalid |                    some other          - error from subordinate call +--------------------------------------------------------------------------*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|Inter_Field_Navigation
argument_list|(
name|int
argument_list|(
operator|*
specifier|const
name|fct
argument_list|)
argument_list|(
name|FORM
operator|*
argument_list|)
argument_list|,
name|FORM
operator|*
name|form
argument_list|)
block|{
name|int
name|res
decl_stmt|;
if|if
condition|(
operator|!
name|_nc_Internal_Validation
argument_list|(
name|form
argument_list|)
condition|)
name|res
operator|=
name|E_INVALID_FIELD
expr_stmt|;
else|else
block|{
name|Call_Hook
argument_list|(
name|form
argument_list|,
name|fieldterm
argument_list|)
expr_stmt|;
name|res
operator|=
name|fct
argument_list|(
name|form
argument_list|)
expr_stmt|;
name|Call_Hook
argument_list|(
name|form
argument_list|,
name|fieldinit
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_decl_stmt

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int FN_Next_Field(FORM * form) | |   Description   :  Move to the next field on the current page of the form | |   Return Values :  E_OK                 - success |                    != E_OK              - error from subordinate call +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|FN_Next_Field
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"FN_Next_Field(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|_nc_Set_Current_Field
argument_list|(
name|form
argument_list|,
name|Next_Field_On_Page
argument_list|(
name|form
operator|->
name|current
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int FN_Previous_Field(FORM * form) | |   Description   :  Move to the previous field on the current page of the |                    form | |   Return Values :  E_OK                 - success |                    != E_OK              - error from subordinate call +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|FN_Previous_Field
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"FN_Previous_Field(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|_nc_Set_Current_Field
argument_list|(
name|form
argument_list|,
name|Previous_Field_On_Page
argument_list|(
name|form
operator|->
name|current
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int FN_First_Field(FORM * form) | |   Description   :  Move to the first field on the current page of the form | |   Return Values :  E_OK                 - success |                    != E_OK              - error from subordinate call +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|FN_First_Field
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"FN_First_Field(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|_nc_Set_Current_Field
argument_list|(
name|form
argument_list|,
name|Next_Field_On_Page
argument_list|(
name|form
operator|->
name|field
index|[
name|form
operator|->
name|page
index|[
name|form
operator|->
name|curpage
index|]
operator|.
name|pmax
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int FN_Last_Field(FORM * form) | |   Description   :  Move to the last field on the current page of the form | |   Return Values :  E_OK                 - success |                    != E_OK              - error from subordinate call +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|FN_Last_Field
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"FN_Last_Field(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|_nc_Set_Current_Field
argument_list|(
name|form
argument_list|,
name|Previous_Field_On_Page
argument_list|(
name|form
operator|->
name|field
index|[
name|form
operator|->
name|page
index|[
name|form
operator|->
name|curpage
index|]
operator|.
name|pmin
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int FN_Sorted_Next_Field(FORM * form) | |   Description   :  Move to the sorted next field on the current page |                    of the form. | |   Return Values :  E_OK            - success |                    != E_OK         - error from subordinate call +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|FN_Sorted_Next_Field
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"FN_Sorted_Next_Field(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|_nc_Set_Current_Field
argument_list|(
name|form
argument_list|,
name|Sorted_Next_Field
argument_list|(
name|form
operator|->
name|current
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int FN_Sorted_Previous_Field(FORM * form) | |   Description   :  Move to the sorted previous field on the current page |                    of the form. | |   Return Values :  E_OK            - success |                    != E_OK         - error from subordinate call +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|FN_Sorted_Previous_Field
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"FN_Sorted_Previous_Field(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|_nc_Set_Current_Field
argument_list|(
name|form
argument_list|,
name|Sorted_Previous_Field
argument_list|(
name|form
operator|->
name|current
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int FN_Sorted_First_Field(FORM * form) | |   Description   :  Move to the sorted first field on the current page |                    of the form. | |   Return Values :  E_OK            - success |                    != E_OK         - error from subordinate call +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|FN_Sorted_First_Field
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"FN_Sorted_First_Field(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|_nc_Set_Current_Field
argument_list|(
name|form
argument_list|,
name|Sorted_Next_Field
argument_list|(
name|form
operator|->
name|field
index|[
name|form
operator|->
name|page
index|[
name|form
operator|->
name|curpage
index|]
operator|.
name|smax
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int FN_Sorted_Last_Field(FORM * form) | |   Description   :  Move to the sorted last field on the current page |                    of the form. | |   Return Values :  E_OK            - success |                    != E_OK         - error from subordinate call +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|FN_Sorted_Last_Field
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"FN_Sorted_Last_Field(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|_nc_Set_Current_Field
argument_list|(
name|form
argument_list|,
name|Sorted_Previous_Field
argument_list|(
name|form
operator|->
name|field
index|[
name|form
operator|->
name|page
index|[
name|form
operator|->
name|curpage
index|]
operator|.
name|smin
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int FN_Left_Field(FORM * form) | |   Description   :  Get the field on the left of the current field on the |                    same line and the same page. Cycles through the line. | |   Return Values :  E_OK            - success |                    != E_OK         - error from subordinate call +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|FN_Left_Field
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"FN_Left_Field(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|_nc_Set_Current_Field
argument_list|(
name|form
argument_list|,
name|Left_Neighbor_Field
argument_list|(
name|form
operator|->
name|current
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int FN_Right_Field(FORM * form) | |   Description   :  Get the field on the right of the current field on the |                    same line and the same page. Cycles through the line. | |   Return Values :  E_OK            - success |                    != E_OK         - error from subordinate call +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|FN_Right_Field
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"FN_Right_Field(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|_nc_Set_Current_Field
argument_list|(
name|form
argument_list|,
name|Right_Neighbor_Field
argument_list|(
name|form
operator|->
name|current
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int FN_Up_Field(FORM * form) | |   Description   :  Get the upper neighbor of the current field. This |                    cycles through the page. See the comments of the |                    Upper_Neighbor_Field function to understand how |                    'upper' is defined. | |   Return Values :  E_OK            - success |                    != E_OK         - error from subordinate call +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|FN_Up_Field
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"FN_Up_Field(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|_nc_Set_Current_Field
argument_list|(
name|form
argument_list|,
name|Upper_Neighbor_Field
argument_list|(
name|form
operator|->
name|current
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int FN_Down_Field(FORM * form) | |   Description   :  Get the down neighbor of the current field. This |                    cycles through the page. See the comments of the |                    Down_Neighbor_Field function to understand how |                    'down' is defined. | |   Return Values :  E_OK            - success |                    != E_OK         - error from subordinate call +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|FN_Down_Field
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"FN_Down_Field(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|_nc_Set_Current_Field
argument_list|(
name|form
argument_list|,
name|Down_Neighbor_Field
argument_list|(
name|form
operator|->
name|current
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------   END of Field Navigation routines   --------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*----------------------------------------------------------------------------   Helper routines for Page Navigation   --------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  int _nc_Set_Form_Page(FORM * form, |                                          int page, |                                          FIELD * field) | |   Description   :  Make the given page number the current page and make |                    the given field the current field on the page. If |                    for the field NULL is given, make the first field on |                    the page the current field. The routine acts only |                    if the requested page is not the current page. | |   Return Values :  E_OK                - success |                    != E_OK             - error from subordinate call |                    E_BAD_ARGUMENT      - invalid field pointer |                    E_SYSTEM_ERROR      - some severe basic error +--------------------------------------------------------------------------*/
end_comment

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|_nc_Set_Form_Page
argument_list|(
argument|FORM *form
argument_list|,
argument|int page
argument_list|,
argument|FIELD *field
argument_list|)
end_macro

begin_block
block|{
name|int
name|res
init|=
name|E_OK
decl_stmt|;
if|if
condition|(
operator|(
name|form
operator|->
name|curpage
operator|!=
name|page
operator|)
condition|)
block|{
name|FIELD
modifier|*
name|last_field
decl_stmt|,
modifier|*
name|field_on_page
decl_stmt|;
name|werase
argument_list|(
name|Get_Form_Window
argument_list|(
name|form
argument_list|)
argument_list|)
expr_stmt|;
name|form
operator|->
name|curpage
operator|=
name|page
expr_stmt|;
name|last_field
operator|=
name|field_on_page
operator|=
name|form
operator|->
name|field
index|[
name|form
operator|->
name|page
index|[
name|page
index|]
operator|.
name|smin
index|]
expr_stmt|;
do|do
block|{
if|if
condition|(
name|field_on_page
operator|->
name|opts
operator|&
name|O_VISIBLE
condition|)
if|if
condition|(
operator|(
name|res
operator|=
name|Display_Field
argument_list|(
name|field_on_page
argument_list|)
operator|)
operator|!=
name|E_OK
condition|)
return|return
operator|(
name|res
operator|)
return|;
name|field_on_page
operator|=
name|field_on_page
operator|->
name|snext
expr_stmt|;
block|}
do|while
condition|(
name|field_on_page
operator|!=
name|last_field
condition|)
do|;
if|if
condition|(
name|field
condition|)
name|res
operator|=
name|_nc_Set_Current_Field
argument_list|(
name|form
argument_list|,
name|field
argument_list|)
expr_stmt|;
else|else
comment|/* N.B.: we don't encapsulate this by Inter_Field_Navigation(), 	   because this is already executed in a page navigation 	   context that contains field navigation 	 */
name|res
operator|=
name|FN_First_Field
argument_list|(
name|form
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|res
operator|)
return|;
block|}
end_block

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int Next_Page_Number(const FORM * form) | |   Description   :  Calculate the page number following the current page |                    number. This cycles if the highest page number is |                    reached. | |   Return Values :  The next page number +--------------------------------------------------------------------------*/
end_comment

begin_function
name|NCURSES_INLINE
specifier|static
name|int
name|Next_Page_Number
parameter_list|(
specifier|const
name|FORM
modifier|*
name|form
parameter_list|)
block|{
return|return
operator|(
name|form
operator|->
name|curpage
operator|+
literal|1
operator|)
operator|%
name|form
operator|->
name|maxpage
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int Previous_Page_Number(const FORM * form) | |   Description   :  Calculate the page number before the current page |                    number. This cycles if the first page number is |                    reached. | |   Return Values :  The previous page number +--------------------------------------------------------------------------*/
end_comment

begin_function
name|NCURSES_INLINE
specifier|static
name|int
name|Previous_Page_Number
parameter_list|(
specifier|const
name|FORM
modifier|*
name|form
parameter_list|)
block|{
return|return
operator|(
name|form
operator|->
name|curpage
operator|!=
literal|0
condition|?
name|form
operator|->
name|curpage
operator|-
literal|1
else|:
name|form
operator|->
name|maxpage
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------   Page Navigation routines   --------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int Page_Navigation( |                                               int (* const fct) (FORM *), |                                               FORM * form) | |   Description   :  Generic behavior for changing a page. This means |                    that the field is left and a new field is entered. |                    So the field must be validated and the field init/term |                    hooks must be called. Because also the page is changed, |                    the forms init/term hooks must be called also. | |   Return Values :  E_OK                - success |                    E_INVALID_FIELD     - field is invalid |                    some other          - error from subordinate call +--------------------------------------------------------------------------*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|Page_Navigation
argument_list|(
name|int
argument_list|(
operator|*
specifier|const
name|fct
argument_list|)
argument_list|(
name|FORM
operator|*
argument_list|)
argument_list|,
name|FORM
operator|*
name|form
argument_list|)
block|{
name|int
name|res
decl_stmt|;
if|if
condition|(
operator|!
name|_nc_Internal_Validation
argument_list|(
name|form
argument_list|)
condition|)
name|res
operator|=
name|E_INVALID_FIELD
expr_stmt|;
else|else
block|{
name|Call_Hook
argument_list|(
name|form
argument_list|,
name|fieldterm
argument_list|)
expr_stmt|;
name|Call_Hook
argument_list|(
name|form
argument_list|,
name|formterm
argument_list|)
expr_stmt|;
name|res
operator|=
name|fct
argument_list|(
name|form
argument_list|)
expr_stmt|;
name|Call_Hook
argument_list|(
name|form
argument_list|,
name|forminit
argument_list|)
expr_stmt|;
name|Call_Hook
argument_list|(
name|form
argument_list|,
name|fieldinit
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_decl_stmt

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int PN_Next_Page(FORM * form) | |   Description   :  Move to the next page of the form | |   Return Values :  E_OK                - success |                    != E_OK             - error from subordinate call +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|PN_Next_Page
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"PN_Next_Page(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|_nc_Set_Form_Page
argument_list|(
name|form
argument_list|,
name|Next_Page_Number
argument_list|(
name|form
argument_list|)
argument_list|,
operator|(
name|FIELD
operator|*
operator|)
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int PN_Previous_Page(FORM * form) | |   Description   :  Move to the previous page of the form | |   Return Values :  E_OK              - success |                    != E_OK           - error from subordinate call +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|PN_Previous_Page
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"PN_Previous_Page(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|_nc_Set_Form_Page
argument_list|(
name|form
argument_list|,
name|Previous_Page_Number
argument_list|(
name|form
argument_list|)
argument_list|,
operator|(
name|FIELD
operator|*
operator|)
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int PN_First_Page(FORM * form) | |   Description   :  Move to the first page of the form | |   Return Values :  E_OK              - success |                    != E_OK           - error from subordinate call +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|PN_First_Page
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"PN_First_Page(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|_nc_Set_Form_Page
argument_list|(
name|form
argument_list|,
literal|0
argument_list|,
operator|(
name|FIELD
operator|*
operator|)
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int PN_Last_Page(FORM * form) | |   Description   :  Move to the last page of the form | |   Return Values :  E_OK              - success |                    != E_OK           - error from subordinate call +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|PN_Last_Page
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|)
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"PN_Last_Page(%p)"
argument_list|)
operator|,
name|form
operator|)
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|_nc_Set_Form_Page
argument_list|(
name|form
argument_list|,
name|form
operator|->
name|maxpage
operator|-
literal|1
argument_list|,
operator|(
name|FIELD
operator|*
operator|)
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------   END of Field Navigation routines   --------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*----------------------------------------------------------------------------   Helper routines for the core form driver.   --------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  static int Data_Entry(FORM * form,int c) | |   Description   :  Enter character c into at the current position of the |                    current field of the form. | |   Return Values :  E_OK              - success |                    E_REQUEST_DENIED  - driver could not process the request |                    E_SYSTEM_ERROR    - +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|Data_Entry
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|FIELD
modifier|*
name|field
init|=
name|form
operator|->
name|current
decl_stmt|;
name|int
name|result
init|=
name|E_REQUEST_DENIED
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"Data_Entry(%p,%s)"
argument_list|)
operator|,
name|form
operator|,
name|_tracechtype
argument_list|(
operator|(
name|chtype
operator|)
name|c
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|field
operator|->
name|opts
operator|&
name|O_EDIT
operator|)
if|#
directive|if
name|FIX_FORM_INACTIVE_BUG
operator|&&
operator|(
name|field
operator|->
name|opts
operator|&
name|O_ACTIVE
operator|)
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
operator|(
name|field
operator|->
name|opts
operator|&
name|O_BLANK
operator|)
operator|&&
name|First_Position_In_Current_Field
argument_list|(
name|form
argument_list|)
operator|&&
operator|!
operator|(
name|form
operator|->
name|status
operator|&
name|_FCHECK_REQUIRED
operator|)
operator|&&
operator|!
operator|(
name|form
operator|->
name|status
operator|&
name|_WINDOW_MODIFIED
operator|)
condition|)
name|werase
argument_list|(
name|form
operator|->
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|form
operator|->
name|status
operator|&
name|_OVLMODE
condition|)
block|{
name|waddch
argument_list|(
name|form
operator|->
name|w
argument_list|,
operator|(
name|chtype
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* no _OVLMODE */
block|{
name|bool
name|There_Is_Room
init|=
name|Is_There_Room_For_A_Char_In_Line
argument_list|(
name|form
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|There_Is_Room
operator|||
operator|(
operator|(
name|Single_Line_Field
argument_list|(
name|field
argument_list|)
operator|&&
name|Growable
argument_list|(
name|field
argument_list|)
operator|)
operator|)
operator|)
condition|)
name|RETURN
argument_list|(
name|E_REQUEST_DENIED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|There_Is_Room
operator|&&
operator|!
name|Field_Grown
argument_list|(
name|field
argument_list|,
literal|1
argument_list|)
condition|)
name|RETURN
argument_list|(
name|E_SYSTEM_ERROR
argument_list|)
expr_stmt|;
name|winsch
argument_list|(
name|form
operator|->
name|w
argument_list|,
operator|(
name|chtype
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|result
operator|=
name|Wrapping_Not_Necessary_Or_Wrapping_Ok
argument_list|(
name|form
argument_list|)
operator|)
operator|==
name|E_OK
condition|)
block|{
name|bool
name|End_Of_Field
init|=
operator|(
operator|(
operator|(
name|field
operator|->
name|drows
operator|-
literal|1
operator|)
operator|==
name|form
operator|->
name|currow
operator|)
operator|&&
operator|(
operator|(
name|field
operator|->
name|dcols
operator|-
literal|1
operator|)
operator|==
name|form
operator|->
name|curcol
operator|)
operator|)
decl_stmt|;
name|form
operator|->
name|status
operator||=
name|_WINDOW_MODIFIED
expr_stmt|;
if|if
condition|(
name|End_Of_Field
operator|&&
operator|!
name|Growable
argument_list|(
name|field
argument_list|)
operator|&&
operator|(
name|field
operator|->
name|opts
operator|&
name|O_AUTOSKIP
operator|)
condition|)
name|result
operator|=
name|Inter_Field_Navigation
argument_list|(
name|FN_Next_Field
argument_list|,
name|form
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|End_Of_Field
operator|&&
name|Growable
argument_list|(
name|field
argument_list|)
operator|&&
operator|!
name|Field_Grown
argument_list|(
name|field
argument_list|,
literal|1
argument_list|)
condition|)
name|result
operator|=
name|E_SYSTEM_ERROR
expr_stmt|;
else|else
block|{
if|#
directive|if
name|USE_WIDEC_SUPPORT
comment|/* 		   * We have just added a byte to the form field.  It may have 		   * been part of a multibyte character.  If it was, the 		   * addch_used field is nonzero and we should not try to move 		   * to a new column. 		   */
if|if
condition|(
name|WINDOW_EXT
argument_list|(
name|form
operator|->
name|w
argument_list|,
name|addch_used
argument_list|)
operator|==
literal|0
condition|)
name|IFN_Next_Character
argument_list|(
name|form
argument_list|)
expr_stmt|;
else|#
directive|else
name|IFN_Next_Character
argument_list|(
name|form
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|result
operator|=
name|E_OK
expr_stmt|;
block|}
block|}
block|}
block|}
name|RETURN
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Structure to describe the binding of a request code to a function.    The member keycode codes the request value as well as the generic    routine to use for the request. The code for the generic routine    is coded in the upper 16 Bits while the request code is coded in    the lower 16 bits.     In terms of C++ you might think of a request as a class with a    virtual method "perform". The different types of request are    derived from this base class and overload (or not) the base class    implementation of perform. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|keycode
decl_stmt|;
comment|/* must be at least 32 bit: hi:mode, lo: key */
name|int
function_decl|(
modifier|*
name|cmd
function_decl|)
parameter_list|(
name|FORM
modifier|*
parameter_list|)
function_decl|;
comment|/* low level driver routine for this key     */
block|}
name|Binding_Info
typedef|;
end_typedef

begin_comment
comment|/* You may see this is the class-id of the request type class */
end_comment

begin_define
define|#
directive|define
name|ID_PN
value|(0x00000000)
end_define

begin_comment
comment|/* Page navigation           */
end_comment

begin_define
define|#
directive|define
name|ID_FN
value|(0x00010000)
end_define

begin_comment
comment|/* Inter-Field navigation    */
end_comment

begin_define
define|#
directive|define
name|ID_IFN
value|(0x00020000)
end_define

begin_comment
comment|/* Intra-Field navigation    */
end_comment

begin_define
define|#
directive|define
name|ID_VSC
value|(0x00030000)
end_define

begin_comment
comment|/* Vertical Scrolling        */
end_comment

begin_define
define|#
directive|define
name|ID_HSC
value|(0x00040000)
end_define

begin_comment
comment|/* Horizontal Scrolling      */
end_comment

begin_define
define|#
directive|define
name|ID_FE
value|(0x00050000)
end_define

begin_comment
comment|/* Field Editing             */
end_comment

begin_define
define|#
directive|define
name|ID_EM
value|(0x00060000)
end_define

begin_comment
comment|/* Edit Mode                 */
end_comment

begin_define
define|#
directive|define
name|ID_FV
value|(0x00070000)
end_define

begin_comment
comment|/* Field Validation          */
end_comment

begin_define
define|#
directive|define
name|ID_CH
value|(0x00080000)
end_define

begin_comment
comment|/* Choice                    */
end_comment

begin_define
define|#
directive|define
name|ID_Mask
value|(0xffff0000)
end_define

begin_define
define|#
directive|define
name|Key_Mask
value|(0x0000ffff)
end_define

begin_define
define|#
directive|define
name|ID_Shft
value|(16)
end_define

begin_comment
comment|/* This array holds all the Binding Infos */
end_comment

begin_comment
comment|/* *INDENT-OFF* */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|Binding_Info
name|bindings
index|[
name|MAX_FORM_COMMAND
operator|-
name|MIN_FORM_COMMAND
operator|+
literal|1
index|]
init|=
block|{
block|{
name|REQ_NEXT_PAGE
operator||
name|ID_PN
block|,
name|PN_Next_Page
block|}
block|,
block|{
name|REQ_PREV_PAGE
operator||
name|ID_PN
block|,
name|PN_Previous_Page
block|}
block|,
block|{
name|REQ_FIRST_PAGE
operator||
name|ID_PN
block|,
name|PN_First_Page
block|}
block|,
block|{
name|REQ_LAST_PAGE
operator||
name|ID_PN
block|,
name|PN_Last_Page
block|}
block|,
block|{
name|REQ_NEXT_FIELD
operator||
name|ID_FN
block|,
name|FN_Next_Field
block|}
block|,
block|{
name|REQ_PREV_FIELD
operator||
name|ID_FN
block|,
name|FN_Previous_Field
block|}
block|,
block|{
name|REQ_FIRST_FIELD
operator||
name|ID_FN
block|,
name|FN_First_Field
block|}
block|,
block|{
name|REQ_LAST_FIELD
operator||
name|ID_FN
block|,
name|FN_Last_Field
block|}
block|,
block|{
name|REQ_SNEXT_FIELD
operator||
name|ID_FN
block|,
name|FN_Sorted_Next_Field
block|}
block|,
block|{
name|REQ_SPREV_FIELD
operator||
name|ID_FN
block|,
name|FN_Sorted_Previous_Field
block|}
block|,
block|{
name|REQ_SFIRST_FIELD
operator||
name|ID_FN
block|,
name|FN_Sorted_First_Field
block|}
block|,
block|{
name|REQ_SLAST_FIELD
operator||
name|ID_FN
block|,
name|FN_Sorted_Last_Field
block|}
block|,
block|{
name|REQ_LEFT_FIELD
operator||
name|ID_FN
block|,
name|FN_Left_Field
block|}
block|,
block|{
name|REQ_RIGHT_FIELD
operator||
name|ID_FN
block|,
name|FN_Right_Field
block|}
block|,
block|{
name|REQ_UP_FIELD
operator||
name|ID_FN
block|,
name|FN_Up_Field
block|}
block|,
block|{
name|REQ_DOWN_FIELD
operator||
name|ID_FN
block|,
name|FN_Down_Field
block|}
block|,
block|{
name|REQ_NEXT_CHAR
operator||
name|ID_IFN
block|,
name|IFN_Next_Character
block|}
block|,
block|{
name|REQ_PREV_CHAR
operator||
name|ID_IFN
block|,
name|IFN_Previous_Character
block|}
block|,
block|{
name|REQ_NEXT_LINE
operator||
name|ID_IFN
block|,
name|IFN_Next_Line
block|}
block|,
block|{
name|REQ_PREV_LINE
operator||
name|ID_IFN
block|,
name|IFN_Previous_Line
block|}
block|,
block|{
name|REQ_NEXT_WORD
operator||
name|ID_IFN
block|,
name|IFN_Next_Word
block|}
block|,
block|{
name|REQ_PREV_WORD
operator||
name|ID_IFN
block|,
name|IFN_Previous_Word
block|}
block|,
block|{
name|REQ_BEG_FIELD
operator||
name|ID_IFN
block|,
name|IFN_Beginning_Of_Field
block|}
block|,
block|{
name|REQ_END_FIELD
operator||
name|ID_IFN
block|,
name|IFN_End_Of_Field
block|}
block|,
block|{
name|REQ_BEG_LINE
operator||
name|ID_IFN
block|,
name|IFN_Beginning_Of_Line
block|}
block|,
block|{
name|REQ_END_LINE
operator||
name|ID_IFN
block|,
name|IFN_End_Of_Line
block|}
block|,
block|{
name|REQ_LEFT_CHAR
operator||
name|ID_IFN
block|,
name|IFN_Left_Character
block|}
block|,
block|{
name|REQ_RIGHT_CHAR
operator||
name|ID_IFN
block|,
name|IFN_Right_Character
block|}
block|,
block|{
name|REQ_UP_CHAR
operator||
name|ID_IFN
block|,
name|IFN_Up_Character
block|}
block|,
block|{
name|REQ_DOWN_CHAR
operator||
name|ID_IFN
block|,
name|IFN_Down_Character
block|}
block|,
block|{
name|REQ_NEW_LINE
operator||
name|ID_FE
block|,
name|FE_New_Line
block|}
block|,
block|{
name|REQ_INS_CHAR
operator||
name|ID_FE
block|,
name|FE_Insert_Character
block|}
block|,
block|{
name|REQ_INS_LINE
operator||
name|ID_FE
block|,
name|FE_Insert_Line
block|}
block|,
block|{
name|REQ_DEL_CHAR
operator||
name|ID_FE
block|,
name|FE_Delete_Character
block|}
block|,
block|{
name|REQ_DEL_PREV
operator||
name|ID_FE
block|,
name|FE_Delete_Previous
block|}
block|,
block|{
name|REQ_DEL_LINE
operator||
name|ID_FE
block|,
name|FE_Delete_Line
block|}
block|,
block|{
name|REQ_DEL_WORD
operator||
name|ID_FE
block|,
name|FE_Delete_Word
block|}
block|,
block|{
name|REQ_CLR_EOL
operator||
name|ID_FE
block|,
name|FE_Clear_To_End_Of_Line
block|}
block|,
block|{
name|REQ_CLR_EOF
operator||
name|ID_FE
block|,
name|FE_Clear_To_End_Of_Field
block|}
block|,
block|{
name|REQ_CLR_FIELD
operator||
name|ID_FE
block|,
name|FE_Clear_Field
block|}
block|,
block|{
name|REQ_OVL_MODE
operator||
name|ID_EM
block|,
name|EM_Overlay_Mode
block|}
block|,
block|{
name|REQ_INS_MODE
operator||
name|ID_EM
block|,
name|EM_Insert_Mode
block|}
block|,
block|{
name|REQ_SCR_FLINE
operator||
name|ID_VSC
block|,
name|VSC_Scroll_Line_Forward
block|}
block|,
block|{
name|REQ_SCR_BLINE
operator||
name|ID_VSC
block|,
name|VSC_Scroll_Line_Backward
block|}
block|,
block|{
name|REQ_SCR_FPAGE
operator||
name|ID_VSC
block|,
name|VSC_Scroll_Page_Forward
block|}
block|,
block|{
name|REQ_SCR_BPAGE
operator||
name|ID_VSC
block|,
name|VSC_Scroll_Page_Backward
block|}
block|,
block|{
name|REQ_SCR_FHPAGE
operator||
name|ID_VSC
block|,
name|VSC_Scroll_Half_Page_Forward
block|}
block|,
block|{
name|REQ_SCR_BHPAGE
operator||
name|ID_VSC
block|,
name|VSC_Scroll_Half_Page_Backward
block|}
block|,
block|{
name|REQ_SCR_FCHAR
operator||
name|ID_HSC
block|,
name|HSC_Scroll_Char_Forward
block|}
block|,
block|{
name|REQ_SCR_BCHAR
operator||
name|ID_HSC
block|,
name|HSC_Scroll_Char_Backward
block|}
block|,
block|{
name|REQ_SCR_HFLINE
operator||
name|ID_HSC
block|,
name|HSC_Horizontal_Line_Forward
block|}
block|,
block|{
name|REQ_SCR_HBLINE
operator||
name|ID_HSC
block|,
name|HSC_Horizontal_Line_Backward
block|}
block|,
block|{
name|REQ_SCR_HFHALF
operator||
name|ID_HSC
block|,
name|HSC_Horizontal_Half_Line_Forward
block|}
block|,
block|{
name|REQ_SCR_HBHALF
operator||
name|ID_HSC
block|,
name|HSC_Horizontal_Half_Line_Backward
block|}
block|,
block|{
name|REQ_VALIDATION
operator||
name|ID_FV
block|,
name|FV_Validation
block|}
block|,
block|{
name|REQ_NEXT_CHOICE
operator||
name|ID_CH
block|,
name|CR_Next_Choice
block|}
block|,
block|{
name|REQ_PREV_CHOICE
operator||
name|ID_CH
block|,
name|CR_Previous_Choice
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* *INDENT-ON* */
end_comment

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  int form_driver(FORM * form,int  c) | |   Description   :  This is the workhorse of the forms system. It checks |                    to determine whether the character c is a request or |                    data. If it is a request, the form driver executes |                    the request and returns the result. If it is data |                    (printable character), it enters the data into the |                    current position in the current field. If it is not |                    recognized, the form driver assumes it is an application |                    defined command and returns E_UNKNOWN_COMMAND. |                    Application defined command should be defined relative |                    to MAX_FORM_COMMAND, the maximum value of a request. | |   Return Values :  E_OK              - success |                    E_SYSTEM_ERROR    - system error |                    E_BAD_ARGUMENT    - an argument is incorrect |                    E_NOT_POSTED      - form is not posted |                    E_INVALID_FIELD   - field contents are invalid |                    E_BAD_STATE       - called from inside a hook routine |                    E_REQUEST_DENIED  - request failed |                    E_NOT_CONNECTED   - no fields are connected to the form |                    E_UNKNOWN_COMMAND - command not known +--------------------------------------------------------------------------*/
end_comment

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|form_driver
argument_list|(
argument|FORM *form
argument_list|,
argument|int c
argument_list|)
end_macro

begin_block
block|{
specifier|const
name|Binding_Info
modifier|*
name|BI
init|=
operator|(
name|Binding_Info
operator|*
operator|)
literal|0
decl_stmt|;
name|int
name|res
init|=
name|E_UNKNOWN_COMMAND
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"form_driver(%p,%d)"
argument_list|)
operator|,
name|form
operator|,
name|c
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|form
condition|)
name|RETURN
argument_list|(
name|E_BAD_ARGUMENT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|form
operator|->
name|field
operator|)
condition|)
name|RETURN
argument_list|(
name|E_NOT_CONNECTED
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|form
operator|->
name|page
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|FIRST_ACTIVE_MAGIC
condition|)
block|{
name|form
operator|->
name|current
operator|=
name|_nc_First_Active_Field
argument_list|(
name|form
argument_list|)
expr_stmt|;
name|RETURN
argument_list|(
name|E_OK
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|form
operator|->
name|current
operator|&&
name|form
operator|->
name|current
operator|->
name|buf
operator|&&
operator|(
name|form
operator|->
name|current
operator|->
name|form
operator|==
name|form
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|form
operator|->
name|status
operator|&
name|_IN_DRIVER
condition|)
name|RETURN
argument_list|(
name|E_BAD_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|form
operator|->
name|status
operator|&
name|_POSTED
operator|)
condition|)
name|RETURN
argument_list|(
name|E_NOT_POSTED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|>=
name|MIN_FORM_COMMAND
operator|&&
name|c
operator|<=
name|MAX_FORM_COMMAND
operator|)
operator|&&
operator|(
operator|(
name|bindings
index|[
name|c
operator|-
name|MIN_FORM_COMMAND
index|]
operator|.
name|keycode
operator|&
name|Key_Mask
operator|)
operator|==
name|c
operator|)
condition|)
name|BI
operator|=
operator|&
operator|(
name|bindings
index|[
name|c
operator|-
name|MIN_FORM_COMMAND
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|BI
condition|)
block|{
typedef|typedef
name|int
argument_list|(
operator|*
name|Generic_Method
argument_list|)
argument_list|(
name|int
argument_list|(
operator|*
specifier|const
argument_list|)
argument_list|(
name|FORM
operator|*
argument_list|)
argument_list|,
name|FORM
operator|*
argument_list|)
expr_stmt|;
specifier|static
specifier|const
name|Generic_Method
name|Generic_Methods
index|[]
init|=
block|{
name|Page_Navigation
block|,
comment|/* overloaded to call field&form hooks */
name|Inter_Field_Navigation
block|,
comment|/* overloaded to call field hooks      */
name|NULL
block|,
comment|/* Intra-Field is generic              */
name|Vertical_Scrolling
block|,
comment|/* Overloaded to check multi-line      */
name|Horizontal_Scrolling
block|,
comment|/* Overloaded to check single-line     */
name|Field_Editing
block|,
comment|/* Overloaded to mark modification     */
name|NULL
block|,
comment|/* Edit Mode is generic                */
name|NULL
block|,
comment|/* Field Validation is generic         */
name|NULL
comment|/* Choice Request is generic           */
block|}
decl_stmt|;
name|size_t
name|nMethods
init|=
operator|(
sizeof|sizeof
argument_list|(
name|Generic_Methods
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|Generic_Methods
index|[
literal|0
index|]
argument_list|)
operator|)
decl_stmt|;
name|size_t
name|method
init|=
operator|(
operator|(
name|BI
operator|->
name|keycode
operator|&
name|ID_Mask
operator|)
operator|>>
name|ID_Shft
operator|)
operator|&
literal|0xffff
decl_stmt|;
if|if
condition|(
operator|(
name|method
operator|>=
name|nMethods
operator|)
operator|||
operator|!
operator|(
name|BI
operator|->
name|cmd
operator|)
condition|)
name|res
operator|=
name|E_SYSTEM_ERROR
expr_stmt|;
else|else
block|{
name|Generic_Method
name|fct
init|=
name|Generic_Methods
index|[
name|method
index|]
decl_stmt|;
if|if
condition|(
name|fct
condition|)
name|res
operator|=
name|fct
argument_list|(
name|BI
operator|->
name|cmd
argument_list|,
name|form
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
call|(
name|BI
operator|->
name|cmd
call|)
argument_list|(
name|form
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|c
operator|&
operator|(
operator|~
operator|(
name|int
operator|)
name|MAX_REGULAR_CHARACTER
operator|)
operator|)
condition|)
block|{
comment|/*        * If we're using 8-bit characters, iscntrl+isprint cover the whole set.        * But with multibyte characters, there is a third possibility, i.e.,        * parts of characters that build up into printable characters which are        * not considered printable.        *        * FIXME: the wide-character branch should also use Check_Char().        */
if|#
directive|if
name|USE_WIDEC_SUPPORT
if|if
condition|(
operator|!
name|iscntrl
argument_list|(
name|UChar
argument_list|(
name|c
argument_list|)
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
name|isprint
argument_list|(
name|UChar
argument_list|(
name|c
argument_list|)
argument_list|)
operator|&&
name|Check_Char
argument_list|(
name|form
operator|->
name|current
operator|->
name|type
argument_list|,
name|c
argument_list|,
operator|(
name|TypeArgument
operator|*
operator|)
operator|(
name|form
operator|->
name|current
operator|->
name|arg
operator|)
argument_list|)
condition|)
endif|#
directive|endif
name|res
operator|=
name|Data_Entry
argument_list|(
name|form
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|_nc_Refresh_Current_Field
argument_list|(
name|form
argument_list|)
expr_stmt|;
name|RETURN
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------------   Field-Buffer manipulation routines.   The effects of setting a buffer are tightly coupled to the core of the form   driver logic. This is especially true in the case of growable fields.   So I don't separate this into a separate module.   --------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  int set_field_buffer(FIELD *field, |                                         int buffer, char *value) | |   Description   :  Set the given buffer of the field to the given value. |                    Buffer 0 stores the displayed content of the field. |                    For dynamic fields this may grow the fieldbuffers if |                    the length of the value exceeds the current buffer |                    length. For buffer 0 only printable values are allowed. |                    For static fields, the value needs not to be zero ter- |                    minated. It is copied up to the length of the buffer. | |   Return Values :  E_OK            - success |                    E_BAD_ARGUMENT  - invalid argument |                    E_SYSTEM_ERROR  - system error +--------------------------------------------------------------------------*/
end_comment

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|set_field_buffer
argument_list|(
argument|FIELD *field
argument_list|,
argument|int buffer
argument_list|,
argument|const char *value
argument_list|)
end_macro

begin_block
block|{
name|FIELD_CELL
modifier|*
name|p
decl_stmt|;
name|int
name|res
init|=
name|E_OK
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
if|#
directive|if
name|USE_WIDEC_SUPPORT
name|FIELD_CELL
modifier|*
name|widevalue
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"set_field_buffer(%p,%d,%s)"
argument_list|)
operator|,
name|field
operator|,
name|buffer
operator|,
name|_nc_visbuf
argument_list|(
name|value
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|field
operator|||
operator|!
name|value
operator|||
operator|(
operator|(
name|buffer
operator|<
literal|0
operator|)
operator|||
operator|(
name|buffer
operator|>
name|field
operator|->
name|nbuf
operator|)
operator|)
condition|)
name|RETURN
argument_list|(
name|E_BAD_ARGUMENT
argument_list|)
expr_stmt|;
name|len
operator|=
name|Buffer_Length
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|value
index|[
name|i
index|]
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
name|i
operator|<
name|len
operator|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|iscntrl
argument_list|(
name|UChar
argument_list|(
name|value
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
name|RETURN
argument_list|(
name|E_BAD_ARGUMENT
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Growable
argument_list|(
name|field
argument_list|)
condition|)
block|{
comment|/* for a growable field we must assume zero terminated strings, because          somehow we have to detect the length of what should be copied.        */
name|unsigned
name|int
name|vlen
init|=
name|strlen
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|vlen
operator|>
name|len
condition|)
block|{
if|if
condition|(
operator|!
name|Field_Grown
argument_list|(
name|field
argument_list|,
call|(
name|int
call|)
argument_list|(
literal|1
operator|+
operator|(
name|vlen
operator|-
name|len
operator|)
operator|/
operator|(
operator|(
name|field
operator|->
name|rows
operator|+
name|field
operator|->
name|nrow
operator|)
operator|*
name|field
operator|->
name|cols
operator|)
argument_list|)
argument_list|)
condition|)
name|RETURN
argument_list|(
name|E_SYSTEM_ERROR
argument_list|)
expr_stmt|;
comment|/* in this case we also have to check, whether or not the remaining 	     characters in value are also printable for buffer 0. */
if|if
condition|(
name|buffer
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
name|len
init|;
name|i
operator|<
name|vlen
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|iscntrl
argument_list|(
name|UChar
argument_list|(
name|value
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
name|RETURN
argument_list|(
name|E_BAD_ARGUMENT
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|vlen
expr_stmt|;
block|}
block|}
name|p
operator|=
name|Address_Of_Nth_Buffer
argument_list|(
name|field
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_WIDEC_SUPPORT
comment|/*    * Use addstr's logic for converting a string to an array of cchar_t's.    * There should be a better way, but this handles nonspacing characters    * and other special cases that we really do not want to handle here.    */
name|wclear
argument_list|(
name|field
operator|->
name|working
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|field
operator|->
name|working
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|widevalue
operator|=
operator|(
name|FIELD_CELL
operator|*
operator|)
name|calloc
argument_list|(
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|FIELD_CELL
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|RETURN
argument_list|(
name|E_SYSTEM_ERROR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mvwin_wchnstr
argument_list|(
name|field
operator|->
name|working
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|widevalue
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|CharEq
argument_list|(
name|myZEROS
argument_list|,
name|widevalue
index|[
name|i
index|]
argument_list|)
condition|)
block|{
while|while
condition|(
name|i
operator|<
name|len
condition|)
name|p
index|[
name|i
operator|++
index|]
operator|=
name|myBLANK
expr_stmt|;
break|break;
block|}
name|p
index|[
name|i
index|]
operator|=
name|widevalue
index|[
name|i
index|]
expr_stmt|;
block|}
name|free
argument_list|(
name|widevalue
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|value
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
block|{
while|while
condition|(
name|i
operator|<
name|len
condition|)
name|p
index|[
name|i
operator|++
index|]
operator|=
name|myBLANK
expr_stmt|;
break|break;
block|}
name|p
index|[
name|i
index|]
operator|=
name|value
index|[
name|i
index|]
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|buffer
operator|==
literal|0
condition|)
block|{
name|int
name|syncres
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|syncres
operator|=
name|Synchronize_Field
argument_list|(
name|field
argument_list|)
operator|)
operator|!=
name|E_OK
operator|)
operator|&&
operator|(
name|res
operator|==
name|E_OK
operator|)
condition|)
name|res
operator|=
name|syncres
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|syncres
operator|=
name|Synchronize_Linked_Fields
argument_list|(
name|field
argument_list|)
operator|)
operator|!=
name|E_OK
operator|)
operator|&&
operator|(
name|res
operator|==
name|E_OK
operator|)
condition|)
name|res
operator|=
name|syncres
expr_stmt|;
block|}
name|RETURN
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform |   Function      :  char *field_buffer(const FIELD *field,int buffer) | |   Description   :  Return the address of the buffer for the field. | |   Return Values :  Pointer to buffer or NULL if arguments were invalid. +--------------------------------------------------------------------------*/
end_comment

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|char *
argument_list|)
end_macro

begin_macro
name|field_buffer
argument_list|(
argument|const FIELD *field
argument_list|,
argument|int buffer
argument_list|)
end_macro

begin_block
block|{
name|char
modifier|*
name|result
init|=
literal|0
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"field_buffer(%p,%d)"
argument_list|)
operator|,
name|field
operator|,
name|buffer
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|&&
operator|(
name|buffer
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|buffer
operator|<=
name|field
operator|->
name|nbuf
operator|)
condition|)
block|{
if|#
directive|if
name|USE_WIDEC_SUPPORT
name|FIELD_CELL
modifier|*
name|data
init|=
name|Address_Of_Nth_Buffer
argument_list|(
name|field
argument_list|,
name|buffer
argument_list|)
decl_stmt|;
name|unsigned
name|need
init|=
literal|0
decl_stmt|;
name|int
name|size
init|=
name|Buffer_Length
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|int
name|n
decl_stmt|;
comment|/* determine the number of bytes needed to store the expanded string */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|size
condition|;
operator|++
name|n
control|)
block|{
if|if
condition|(
operator|!
name|isWidecExt
argument_list|(
name|data
index|[
name|n
index|]
argument_list|)
condition|)
block|{
name|mbstate_t
name|state
decl_stmt|;
name|size_t
name|next
decl_stmt|;
name|init_mb
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|next
operator|=
name|_nc_wcrtomb
argument_list|(
literal|0
argument_list|,
name|data
index|[
name|n
index|]
operator|.
name|chars
index|[
literal|0
index|]
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isEILSEQ
argument_list|(
name|next
argument_list|)
condition|)
block|{
if|if
condition|(
name|next
operator|!=
literal|0
condition|)
name|need
operator|+=
name|next
expr_stmt|;
block|}
block|}
block|}
comment|/* allocate a place to store the expanded string */
if|if
condition|(
name|field
operator|->
name|expanded
index|[
name|buffer
index|]
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|field
operator|->
name|expanded
index|[
name|buffer
index|]
argument_list|)
expr_stmt|;
name|field
operator|->
name|expanded
index|[
name|buffer
index|]
operator|=
name|typeMalloc
argument_list|(
name|char
argument_list|,
name|need
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* expand the multibyte data */
if|if
condition|(
operator|(
name|result
operator|=
name|field
operator|->
name|expanded
index|[
name|buffer
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
name|wclear
argument_list|(
name|field
operator|->
name|working
argument_list|)
expr_stmt|;
name|mvwadd_wchnstr
argument_list|(
name|field
operator|->
name|working
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|mvwinnstr
argument_list|(
name|field
operator|->
name|working
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|result
argument_list|,
operator|(
name|int
operator|)
name|need
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|result
operator|=
name|Address_Of_Nth_Buffer
argument_list|(
name|field
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|returnPtr
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_block

begin_if
if|#
directive|if
name|USE_WIDEC_SUPPORT
end_if

begin_comment
comment|/* FIXME: see lib_get_wch.c */
end_comment

begin_if
if|#
directive|if
name|HAVE_MBTOWC
operator|&&
name|HAVE_MBLEN
end_if

begin_define
define|#
directive|define
name|reset_mbytes
parameter_list|(
name|state
parameter_list|)
value|mblen(NULL, 0), mbtowc(NULL, NULL, 0)
end_define

begin_define
define|#
directive|define
name|count_mbytes
parameter_list|(
name|buffer
parameter_list|,
name|length
parameter_list|,
name|state
parameter_list|)
value|mblen(buffer,length)
end_define

begin_define
define|#
directive|define
name|trans_mbytes
parameter_list|(
name|wch
parameter_list|,
name|buffer
parameter_list|,
name|length
parameter_list|,
name|state
parameter_list|)
define|\
value|(int) mbtowc(&wch, buffer, length)
end_define

begin_elif
elif|#
directive|elif
name|HAVE_MBRTOWC
operator|&&
name|HAVE_MBRLEN
end_elif

begin_define
define|#
directive|define
name|NEED_STATE
end_define

begin_define
define|#
directive|define
name|reset_mbytes
parameter_list|(
name|state
parameter_list|)
value|init_mb(state)
end_define

begin_define
define|#
directive|define
name|count_mbytes
parameter_list|(
name|buffer
parameter_list|,
name|length
parameter_list|,
name|state
parameter_list|)
value|mbrlen(buffer,length,&state)
end_define

begin_define
define|#
directive|define
name|trans_mbytes
parameter_list|(
name|wch
parameter_list|,
name|buffer
parameter_list|,
name|length
parameter_list|,
name|state
parameter_list|)
define|\
value|(int) mbrtowc(&wch, buffer, length,&state)
end_define

begin_else
else|#
directive|else
end_else

begin_function
name|make
name|an
name|error
endif|#
directive|endif
comment|/*--------------------------------------------------------------------------- | Convert a multibyte string to a wide-character string.  The result must be | freed by the caller. +--------------------------------------------------------------------------*/
name|NCURSES_EXPORT
parameter_list|(
name|wchar_t
modifier|*
parameter_list|)
function|_nc_Widen_String
parameter_list|(
name|char
modifier|*
name|source
parameter_list|,
name|int
modifier|*
name|lengthp
parameter_list|)
block|{
name|wchar_t
modifier|*
name|result
init|=
literal|0
decl_stmt|;
name|wchar_t
name|wch
decl_stmt|;
name|size_t
name|given
init|=
name|strlen
argument_list|(
name|source
argument_list|)
decl_stmt|;
name|size_t
name|tries
decl_stmt|;
name|int
name|pass
decl_stmt|;
name|int
name|status
decl_stmt|;
ifdef|#
directive|ifdef
name|NEED_STATE
name|mbstate_t
name|state
decl_stmt|;
endif|#
directive|endif
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
literal|2
condition|;
operator|++
name|pass
control|)
block|{
name|unsigned
name|need
init|=
literal|0
decl_stmt|;
name|size_t
name|passed
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|passed
operator|<
name|given
condition|)
block|{
name|bool
name|found
init|=
name|FALSE
decl_stmt|;
for|for
control|(
name|tries
operator|=
literal|1
operator|,
name|status
operator|=
literal|0
init|;
name|tries
operator|<=
operator|(
name|given
operator|-
name|passed
operator|)
condition|;
operator|++
name|tries
control|)
block|{
name|int
name|save
init|=
name|source
index|[
name|passed
operator|+
name|tries
index|]
decl_stmt|;
name|source
index|[
name|passed
operator|+
name|tries
index|]
operator|=
literal|0
expr_stmt|;
name|reset_mbytes
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|status
operator|=
name|trans_mbytes
argument_list|(
name|wch
argument_list|,
name|source
operator|+
name|passed
argument_list|,
name|tries
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|source
index|[
name|passed
operator|+
name|tries
index|]
operator|=
name|save
expr_stmt|;
if|if
condition|(
name|status
operator|>
literal|0
condition|)
block|{
name|found
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|found
condition|)
block|{
if|if
condition|(
name|pass
condition|)
block|{
name|result
index|[
name|need
index|]
operator|=
name|wch
expr_stmt|;
block|}
name|passed
operator|+=
name|status
expr_stmt|;
operator|++
name|need
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pass
condition|)
block|{
name|result
index|[
name|need
index|]
operator|=
name|source
index|[
name|passed
index|]
expr_stmt|;
block|}
operator|++
name|need
expr_stmt|;
operator|++
name|passed
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|pass
condition|)
block|{
if|if
condition|(
operator|!
name|need
condition|)
break|break;
name|result
operator|=
name|typeCalloc
argument_list|(
name|wchar_t
argument_list|,
name|need
argument_list|)
expr_stmt|;
operator|*
name|lengthp
operator|=
name|need
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
break|break;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* frm_driver.c ends here */
end_comment

end_unit

