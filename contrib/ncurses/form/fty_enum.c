begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * THIS CODE IS SPECIFICALLY EXEMPTED FROM THE NCURSES PACKAGE COPYRIGHT.  * You may freely copy it for use as a template for your own field types.  * If you develop a field type that might be of general use, please send  * it back to the ncurses maintainers for inclusion in the next version.  */
end_comment

begin_comment
comment|/*************************************************************************** *                                                                          * *  Author : Juergen Pfeifer, juergen.pfeifer@gmx.net                       * *                                                                          * ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"form.priv.h"
end_include

begin_macro
name|MODULE_ID
argument_list|(
literal|"$Id: fty_enum.c,v 1.13 2000/09/10 00:55:26 juergen Exp $"
argument_list|)
end_macro

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
modifier|*
name|kwds
decl_stmt|;
name|int
name|count
decl_stmt|;
name|bool
name|checkcase
decl_stmt|;
name|bool
name|checkunique
decl_stmt|;
block|}
name|enumARG
typedef|;
end_typedef

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform   |   Function      :  static void *Make_Enum_Type( va_list * ap ) |    |   Description   :  Allocate structure for enumeration type argument. | |   Return Values :  Pointer to argument structure or NULL on error +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
modifier|*
name|Make_Enum_Type
parameter_list|(
name|va_list
modifier|*
name|ap
parameter_list|)
block|{
name|enumARG
modifier|*
name|argp
init|=
operator|(
name|enumARG
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|enumARG
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|argp
condition|)
block|{
name|int
name|cnt
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|kp
init|=
operator|(
name|char
operator|*
operator|*
operator|)
literal|0
decl_stmt|;
name|int
name|ccase
decl_stmt|,
name|cunique
decl_stmt|;
name|argp
operator|->
name|kwds
operator|=
name|va_arg
argument_list|(
operator|*
name|ap
argument_list|,
name|char
operator|*
operator|*
argument_list|)
expr_stmt|;
name|ccase
operator|=
name|va_arg
argument_list|(
operator|*
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|cunique
operator|=
name|va_arg
argument_list|(
operator|*
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|argp
operator|->
name|checkcase
operator|=
name|ccase
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|argp
operator|->
name|checkunique
operator|=
name|cunique
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|kp
operator|=
name|argp
operator|->
name|kwds
expr_stmt|;
while|while
condition|(
operator|(
name|kp
operator|&&
operator|*
name|kp
operator|++
operator|)
condition|)
name|cnt
operator|++
expr_stmt|;
name|argp
operator|->
name|count
operator|=
name|cnt
expr_stmt|;
block|}
return|return
operator|(
name|void
operator|*
operator|)
name|argp
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform   |   Function      :  static void *Copy_Enum_Type( const void * argp ) |    |   Description   :  Copy structure for enumeration type argument.   | |   Return Values :  Pointer to argument structure or NULL on error. +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
modifier|*
name|Copy_Enum_Type
parameter_list|(
specifier|const
name|void
modifier|*
name|argp
parameter_list|)
block|{
name|enumARG
modifier|*
name|result
init|=
operator|(
name|enumARG
operator|*
operator|)
literal|0
decl_stmt|;
if|if
condition|(
name|argp
condition|)
block|{
specifier|const
name|enumARG
modifier|*
name|ap
init|=
operator|(
specifier|const
name|enumARG
operator|*
operator|)
name|argp
decl_stmt|;
name|result
operator|=
operator|(
name|enumARG
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|enumARG
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
operator|*
name|result
operator|=
operator|*
name|ap
expr_stmt|;
block|}
return|return
operator|(
name|void
operator|*
operator|)
name|result
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform   |   Function      :  static void Free_Enum_Type( void * argp ) |    |   Description   :  Free structure for enumeration type argument. | |   Return Values :  - +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|Free_Enum_Type
parameter_list|(
name|void
modifier|*
name|argp
parameter_list|)
block|{
if|if
condition|(
name|argp
condition|)
name|free
argument_list|(
name|argp
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|SKIP_SPACE
parameter_list|(
name|x
parameter_list|)
value|while(((*(x))!='\0')&& (is_blank(*(x)))) (x)++
end_define

begin_define
define|#
directive|define
name|NOMATCH
value|0
end_define

begin_define
define|#
directive|define
name|PARTIAL
value|1
end_define

begin_define
define|#
directive|define
name|EXACT
value|2
end_define

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform   |   Function      :  static int Compare(const unsigned char * s,   |                                       const unsigned char * buf, |                                       bool  ccase ) |    |   Description   :  Check wether or not the text in 'buf' matches the |                    text in 's', at least partial. | |   Return Values :  NOMATCH   - buffer doesn't match |                    PARTIAL   - buffer matches partially |                    EXACT     - buffer matches exactly +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|Compare
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|bool
name|ccase
parameter_list|)
block|{
name|SKIP_SPACE
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* Skip leading spaces in both texts */
name|SKIP_SPACE
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|==
literal|'\0'
condition|)
block|{
return|return
operator|(
operator|(
operator|(
operator|*
name|s
operator|)
operator|!=
literal|'\0'
operator|)
condition|?
name|NOMATCH
else|:
name|EXACT
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|ccase
condition|)
block|{
while|while
condition|(
operator|*
name|s
operator|++
operator|==
operator|*
name|buf
condition|)
block|{
if|if
condition|(
operator|*
name|buf
operator|++
operator|==
literal|'\0'
condition|)
return|return
name|EXACT
return|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|toupper
argument_list|(
operator|*
name|s
operator|++
argument_list|)
operator|==
name|toupper
argument_list|(
operator|*
name|buf
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|buf
operator|++
operator|==
literal|'\0'
condition|)
return|return
name|EXACT
return|;
block|}
block|}
block|}
comment|/* At this location buf points to the first character where it no longer      matches with s. So if only blanks are following, we have a partial      match otherwise there is no match */
name|SKIP_SPACE
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buf
condition|)
return|return
name|NOMATCH
return|;
comment|/* If it happens that the reference buffer is at its end, the partial      match is actually an exact match. */
return|return
operator|(
operator|(
name|s
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\0'
operator|)
condition|?
name|PARTIAL
else|:
name|EXACT
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform   |   Function      :  static bool Check_Enum_Field( |                                      FIELD * field, |                                      const void  * argp) |    |   Description   :  Validate buffer content to be a valid enumeration value | |   Return Values :  TRUE  - field is valid |                    FALSE - field is invalid +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|bool
name|Check_Enum_Field
parameter_list|(
name|FIELD
modifier|*
name|field
parameter_list|,
specifier|const
name|void
modifier|*
name|argp
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|kwds
init|=
operator|(
operator|(
specifier|const
name|enumARG
operator|*
operator|)
name|argp
operator|)
operator|->
name|kwds
decl_stmt|;
name|bool
name|ccase
init|=
operator|(
operator|(
specifier|const
name|enumARG
operator|*
operator|)
name|argp
operator|)
operator|->
name|checkcase
decl_stmt|;
name|bool
name|unique
init|=
operator|(
operator|(
specifier|const
name|enumARG
operator|*
operator|)
name|argp
operator|)
operator|->
name|checkunique
decl_stmt|;
name|unsigned
name|char
modifier|*
name|bp
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|field_buffer
argument_list|(
name|field
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|res
decl_stmt|;
while|while
condition|(
name|kwds
operator|&&
operator|(
name|s
operator|=
operator|(
operator|*
name|kwds
operator|++
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|res
operator|=
name|Compare
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
argument_list|,
name|bp
argument_list|,
name|ccase
argument_list|)
operator|)
operator|!=
name|NOMATCH
condition|)
block|{
name|p
operator|=
name|t
operator|=
name|s
expr_stmt|;
comment|/* t is at least a partial match */
if|if
condition|(
operator|(
name|unique
operator|&&
name|res
operator|!=
name|EXACT
operator|)
condition|)
block|{
while|while
condition|(
name|kwds
operator|&&
operator|(
name|p
operator|=
operator|*
name|kwds
operator|++
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|res
operator|=
name|Compare
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|p
argument_list|,
name|bp
argument_list|,
name|ccase
argument_list|)
operator|)
operator|!=
name|NOMATCH
condition|)
block|{
if|if
condition|(
name|res
operator|==
name|EXACT
condition|)
block|{
name|t
operator|=
name|p
expr_stmt|;
break|break;
block|}
else|else
name|t
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|t
condition|)
block|{
name|set_field_buffer
argument_list|(
name|field
argument_list|,
literal|0
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
operator|!
name|p
condition|)
break|break;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|dummy
index|[]
init|=
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform   |   Function      :  static bool Next_Enum(FIELD * field, |                                          const void * argp) |    |   Description   :  Check for the next enumeration value | |   Return Values :  TRUE  - next value found and loaded |                    FALSE - no next value loaded +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|bool
name|Next_Enum
parameter_list|(
name|FIELD
modifier|*
name|field
parameter_list|,
specifier|const
name|void
modifier|*
name|argp
parameter_list|)
block|{
specifier|const
name|enumARG
modifier|*
name|args
init|=
operator|(
specifier|const
name|enumARG
operator|*
operator|)
name|argp
decl_stmt|;
name|char
modifier|*
modifier|*
name|kwds
init|=
name|args
operator|->
name|kwds
decl_stmt|;
name|bool
name|ccase
init|=
name|args
operator|->
name|checkcase
decl_stmt|;
name|int
name|cnt
init|=
name|args
operator|->
name|count
decl_stmt|;
name|unsigned
name|char
modifier|*
name|bp
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|field_buffer
argument_list|(
name|field
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|kwds
condition|)
block|{
while|while
condition|(
name|cnt
operator|--
condition|)
block|{
if|if
condition|(
name|Compare
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
operator|*
name|kwds
operator|++
operator|)
argument_list|,
name|bp
argument_list|,
name|ccase
argument_list|)
operator|==
name|EXACT
condition|)
break|break;
block|}
if|if
condition|(
name|cnt
operator|<=
literal|0
condition|)
name|kwds
operator|=
name|args
operator|->
name|kwds
expr_stmt|;
if|if
condition|(
operator|(
name|cnt
operator|>=
literal|0
operator|)
operator|||
operator|(
name|Compare
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|dummy
argument_list|,
name|bp
argument_list|,
name|ccase
argument_list|)
operator|==
name|EXACT
operator|)
condition|)
block|{
name|set_field_buffer
argument_list|(
name|field
argument_list|,
literal|0
argument_list|,
operator|*
name|kwds
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- |   Facility      :  libnform   |   Function      :  static bool Previous_Enum( |                                          FIELD * field, |                                          const void * argp) |    |   Description   :  Check for the previous enumeration value | |   Return Values :  TRUE  - previous value found and loaded |                    FALSE - no previous value loaded +--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|bool
name|Previous_Enum
parameter_list|(
name|FIELD
modifier|*
name|field
parameter_list|,
specifier|const
name|void
modifier|*
name|argp
parameter_list|)
block|{
specifier|const
name|enumARG
modifier|*
name|args
init|=
operator|(
specifier|const
name|enumARG
operator|*
operator|)
name|argp
decl_stmt|;
name|int
name|cnt
init|=
name|args
operator|->
name|count
decl_stmt|;
name|char
modifier|*
modifier|*
name|kwds
init|=
operator|&
name|args
operator|->
name|kwds
index|[
name|cnt
operator|-
literal|1
index|]
decl_stmt|;
name|bool
name|ccase
init|=
name|args
operator|->
name|checkcase
decl_stmt|;
name|unsigned
name|char
modifier|*
name|bp
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|field_buffer
argument_list|(
name|field
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|kwds
condition|)
block|{
while|while
condition|(
name|cnt
operator|--
condition|)
block|{
if|if
condition|(
name|Compare
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
operator|*
name|kwds
operator|--
operator|)
argument_list|,
name|bp
argument_list|,
name|ccase
argument_list|)
operator|==
name|EXACT
condition|)
break|break;
block|}
if|if
condition|(
name|cnt
operator|<=
literal|0
condition|)
name|kwds
operator|=
operator|&
name|args
operator|->
name|kwds
index|[
name|args
operator|->
name|count
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|cnt
operator|>=
literal|0
operator|)
operator|||
operator|(
name|Compare
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|dummy
argument_list|,
name|bp
argument_list|,
name|ccase
argument_list|)
operator|==
name|EXACT
operator|)
condition|)
block|{
name|set_field_buffer
argument_list|(
name|field
argument_list|,
literal|0
argument_list|,
operator|*
name|kwds
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|FIELDTYPE
name|typeENUM
init|=
block|{
name|_HAS_ARGS
operator||
name|_HAS_CHOICE
operator||
name|_RESIDENT
block|,
literal|1
block|,
comment|/* this is mutable, so we can't be const */
operator|(
name|FIELDTYPE
operator|*
operator|)
literal|0
block|,
operator|(
name|FIELDTYPE
operator|*
operator|)
literal|0
block|,
name|Make_Enum_Type
block|,
name|Copy_Enum_Type
block|,
name|Free_Enum_Type
block|,
name|Check_Enum_Field
block|,
name|NULL
block|,
name|Next_Enum
block|,
name|Previous_Enum
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FIELDTYPE
modifier|*
name|TYPE_ENUM
init|=
operator|&
name|typeENUM
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* fty_enum.c ends here */
end_comment

end_unit

