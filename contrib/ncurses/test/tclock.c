begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"test.priv.h"
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_comment
comment|/*   tclock - analog/digital clock for curses.   If it gives you joy, then   (a) I'm glad   (b) you need to get out more :-)    This program is copyright Howard Jones, September 1994   (ha.jones@ic.ac.uk). It may be freely distributed as   long as this copyright message remains intact, and any   modifications are clearly marked as such. [In fact, if   you modify it, I wouldn't mind the modifications back,   especially if they add any nice features. A good one   would be a precalc table for the 60 hand positions, so   that the floating point stuff can be ditched. As I said,   it was a 20 hackup minute job.]    COMING SOON: tfishtank. Be the envy of your mac-owning   colleagues. */
end_comment

begin_comment
comment|/* To compile: cc -o tclock tclock.c -lcurses -lm */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PI
end_ifndef

begin_define
define|#
directive|define
name|PI
value|3.141592654
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|sign
parameter_list|(
name|_x
parameter_list|)
value|(_x<0?-1:1)
end_define

begin_define
define|#
directive|define
name|ASPECT
value|2.2
end_define

begin_define
define|#
directive|define
name|ROUND
parameter_list|(
name|value
parameter_list|)
value|((int)((value) + 0.5))
end_define

begin_define
define|#
directive|define
name|A2X
parameter_list|(
name|angle
parameter_list|,
name|radius
parameter_list|)
value|ROUND(ASPECT * radius * sin(angle))
end_define

begin_define
define|#
directive|define
name|A2Y
parameter_list|(
name|angle
parameter_list|,
name|radius
parameter_list|)
value|ROUND(radius * cos(angle))
end_define

begin_comment
comment|/* Plot a point */
end_comment

begin_function
specifier|static
name|void
name|plot
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|char
name|col
parameter_list|)
block|{
name|mvaddch
argument_list|(
name|y
argument_list|,
name|x
argument_list|,
operator|(
name|chtype
operator|)
name|col
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Draw a diagonal(arbitrary) line using Bresenham's alogrithm. */
end_comment

begin_function
specifier|static
name|void
name|dline
parameter_list|(
name|int
name|pair
parameter_list|,
name|int
name|from_x
parameter_list|,
name|int
name|from_y
parameter_list|,
name|int
name|x2
parameter_list|,
name|int
name|y2
parameter_list|,
name|char
name|ch
parameter_list|)
block|{
name|int
name|dx
decl_stmt|,
name|dy
decl_stmt|;
name|int
name|ax
decl_stmt|,
name|ay
decl_stmt|;
name|int
name|sx
decl_stmt|,
name|sy
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|d
decl_stmt|;
if|if
condition|(
name|has_colors
argument_list|()
condition|)
name|attrset
argument_list|(
name|COLOR_PAIR
argument_list|(
name|pair
argument_list|)
argument_list|)
expr_stmt|;
name|dx
operator|=
name|x2
operator|-
name|from_x
expr_stmt|;
name|dy
operator|=
name|y2
operator|-
name|from_y
expr_stmt|;
name|ax
operator|=
name|abs
argument_list|(
name|dx
operator|*
literal|2
argument_list|)
expr_stmt|;
name|ay
operator|=
name|abs
argument_list|(
name|dy
operator|*
literal|2
argument_list|)
expr_stmt|;
name|sx
operator|=
name|sign
argument_list|(
name|dx
argument_list|)
expr_stmt|;
name|sy
operator|=
name|sign
argument_list|(
name|dy
argument_list|)
expr_stmt|;
name|x
operator|=
name|from_x
expr_stmt|;
name|y
operator|=
name|from_y
expr_stmt|;
if|if
condition|(
name|ax
operator|>
name|ay
condition|)
block|{
name|d
operator|=
name|ay
operator|-
operator|(
name|ax
operator|/
literal|2
operator|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|plot
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|x2
condition|)
return|return;
if|if
condition|(
name|d
operator|>=
literal|0
condition|)
block|{
name|y
operator|+=
name|sy
expr_stmt|;
name|d
operator|-=
name|ax
expr_stmt|;
block|}
name|x
operator|+=
name|sx
expr_stmt|;
name|d
operator|+=
name|ay
expr_stmt|;
block|}
block|}
else|else
block|{
name|d
operator|=
name|ax
operator|-
operator|(
name|ay
operator|/
literal|2
operator|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|plot
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|==
name|y2
condition|)
return|return;
if|if
condition|(
name|d
operator|>=
literal|0
condition|)
block|{
name|x
operator|+=
name|sx
expr_stmt|;
name|d
operator|-=
name|ay
expr_stmt|;
block|}
name|y
operator|+=
name|sy
expr_stmt|;
name|d
operator|+=
name|ax
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
name|GCC_UNUSED
parameter_list|,
name|char
modifier|*
name|argv
index|[]
name|GCC_UNUSED
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|cx
decl_stmt|,
name|cy
decl_stmt|;
name|double
name|mradius
decl_stmt|,
name|hradius
decl_stmt|,
name|mangle
decl_stmt|,
name|hangle
decl_stmt|;
name|double
name|sangle
decl_stmt|,
name|sradius
decl_stmt|,
name|hours
decl_stmt|;
name|int
name|hdx
decl_stmt|,
name|hdy
decl_stmt|;
name|int
name|mdx
decl_stmt|,
name|mdy
decl_stmt|;
name|int
name|sdx
decl_stmt|,
name|sdy
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|int
name|lastbeep
init|=
operator|-
literal|1
decl_stmt|;
name|time_t
name|tim
decl_stmt|;
name|struct
name|tm
modifier|*
name|t
decl_stmt|;
name|char
name|szChar
index|[
literal|10
index|]
decl_stmt|;
name|int
name|my_bg
init|=
name|COLOR_BLACK
decl_stmt|;
name|initscr
argument_list|()
expr_stmt|;
name|noecho
argument_list|()
expr_stmt|;
name|cbreak
argument_list|()
expr_stmt|;
name|nodelay
argument_list|(
name|stdscr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|curs_set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_colors
argument_list|()
condition|)
block|{
name|start_color
argument_list|()
expr_stmt|;
if|#
directive|if
name|HAVE_USE_DEFAULT_COLORS
if|if
condition|(
name|use_default_colors
argument_list|()
operator|==
name|OK
condition|)
name|my_bg
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
name|init_pair
argument_list|(
literal|1
argument_list|,
name|COLOR_RED
argument_list|,
name|my_bg
argument_list|)
expr_stmt|;
name|init_pair
argument_list|(
literal|2
argument_list|,
name|COLOR_MAGENTA
argument_list|,
name|my_bg
argument_list|)
expr_stmt|;
name|init_pair
argument_list|(
literal|3
argument_list|,
name|COLOR_GREEN
argument_list|,
name|my_bg
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|KEY_RESIZE
name|keypad
argument_list|(
name|stdscr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|restart
label|:
endif|#
directive|endif
name|cx
operator|=
operator|(
name|COLS
operator|-
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
comment|/* 39 */
name|cy
operator|=
name|LINES
operator|/
literal|2
expr_stmt|;
comment|/* 12 */
name|ch
operator|=
operator|(
name|cx
operator|>
name|cy
operator|)
condition|?
name|cy
else|:
name|cx
expr_stmt|;
comment|/* usually cy */
name|mradius
operator|=
operator|(
literal|3
operator|*
name|cy
operator|)
operator|/
literal|4
expr_stmt|;
comment|/* 9 */
name|hradius
operator|=
name|cy
operator|/
literal|2
expr_stmt|;
comment|/* 6 */
name|sradius
operator|=
operator|(
literal|2
operator|*
name|cy
operator|)
operator|/
literal|3
expr_stmt|;
comment|/* 8 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|12
condition|;
name|i
operator|++
control|)
block|{
name|sangle
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
operator|(
literal|2.0
operator|*
name|PI
operator|)
operator|/
literal|12.0
expr_stmt|;
name|sradius
operator|=
operator|(
literal|5
operator|*
name|cy
operator|)
operator|/
literal|6
expr_stmt|;
comment|/* 10 */
name|sdx
operator|=
name|A2X
argument_list|(
name|sangle
argument_list|,
name|sradius
argument_list|)
expr_stmt|;
name|sdy
operator|=
name|A2Y
argument_list|(
name|sangle
argument_list|,
name|sradius
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|szChar
argument_list|,
literal|"%d"
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|cy
operator|-
name|sdy
argument_list|,
name|cx
operator|+
name|sdx
argument_list|,
name|szChar
argument_list|)
expr_stmt|;
block|}
name|mvaddstr
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"ASCII Clock by Howard Jones (ha.jones@ic.ac.uk),1994"
argument_list|)
expr_stmt|;
name|sradius
operator|=
literal|8
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|napms
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|tim
operator|=
name|time
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|t
operator|=
name|localtime
argument_list|(
operator|&
name|tim
argument_list|)
expr_stmt|;
name|hours
operator|=
operator|(
name|t
operator|->
name|tm_hour
operator|+
operator|(
name|t
operator|->
name|tm_min
operator|/
literal|60.0
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|hours
operator|>
literal|12.0
condition|)
name|hours
operator|-=
literal|12.0
expr_stmt|;
name|mangle
operator|=
operator|(
operator|(
name|t
operator|->
name|tm_min
operator|)
operator|*
operator|(
literal|2
operator|*
name|PI
operator|)
operator|/
literal|60.0
operator|)
expr_stmt|;
name|mdx
operator|=
name|A2X
argument_list|(
name|mangle
argument_list|,
name|mradius
argument_list|)
expr_stmt|;
name|mdy
operator|=
name|A2Y
argument_list|(
name|mangle
argument_list|,
name|mradius
argument_list|)
expr_stmt|;
name|hangle
operator|=
operator|(
operator|(
name|hours
operator|)
operator|*
operator|(
literal|2.0
operator|*
name|PI
operator|)
operator|/
literal|12.0
operator|)
expr_stmt|;
name|hdx
operator|=
name|A2X
argument_list|(
name|hangle
argument_list|,
name|hradius
argument_list|)
expr_stmt|;
name|hdy
operator|=
name|A2Y
argument_list|(
name|hangle
argument_list|,
name|hradius
argument_list|)
expr_stmt|;
name|sangle
operator|=
operator|(
operator|(
name|t
operator|->
name|tm_sec
operator|)
operator|*
operator|(
literal|2.0
operator|*
name|PI
operator|)
operator|/
literal|60.0
operator|)
expr_stmt|;
name|sdx
operator|=
name|A2X
argument_list|(
name|sangle
argument_list|,
name|sradius
argument_list|)
expr_stmt|;
name|sdy
operator|=
name|A2Y
argument_list|(
name|sangle
argument_list|,
name|sradius
argument_list|)
expr_stmt|;
name|dline
argument_list|(
literal|3
argument_list|,
name|cx
argument_list|,
name|cy
argument_list|,
name|cx
operator|+
name|mdx
argument_list|,
name|cy
operator|-
name|mdy
argument_list|,
literal|'#'
argument_list|)
expr_stmt|;
name|attrset
argument_list|(
name|A_REVERSE
argument_list|)
expr_stmt|;
name|dline
argument_list|(
literal|2
argument_list|,
name|cx
argument_list|,
name|cy
argument_list|,
name|cx
operator|+
name|hdx
argument_list|,
name|cy
operator|-
name|hdy
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
name|attroff
argument_list|(
name|A_REVERSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_colors
argument_list|()
condition|)
name|attrset
argument_list|(
name|COLOR_PAIR
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|plot
argument_list|(
name|cx
operator|+
name|sdx
argument_list|,
name|cy
operator|-
name|sdy
argument_list|,
literal|'O'
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_colors
argument_list|()
condition|)
name|attrset
argument_list|(
name|COLOR_PAIR
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|LINES
operator|-
literal|2
argument_list|,
literal|0
argument_list|,
name|ctime
argument_list|(
operator|&
name|tim
argument_list|)
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|->
name|tm_sec
operator|%
literal|5
operator|)
operator|==
literal|0
operator|&&
name|t
operator|->
name|tm_sec
operator|!=
name|lastbeep
condition|)
block|{
name|lastbeep
operator|=
name|t
operator|->
name|tm_sec
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ch
operator|=
name|getch
argument_list|()
operator|)
operator|!=
name|ERR
condition|)
block|{
ifdef|#
directive|ifdef
name|KEY_RESIZE
if|if
condition|(
name|ch
operator|==
name|KEY_RESIZE
condition|)
block|{
name|erase
argument_list|()
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
endif|#
directive|endif
break|break;
block|}
name|plot
argument_list|(
name|cx
operator|+
name|sdx
argument_list|,
name|cy
operator|-
name|sdy
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|dline
argument_list|(
literal|0
argument_list|,
name|cx
argument_list|,
name|cy
argument_list|,
name|cx
operator|+
name|hdx
argument_list|,
name|cy
operator|-
name|hdy
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|dline
argument_list|(
literal|0
argument_list|,
name|cx
argument_list|,
name|cy
argument_list|,
name|cx
operator|+
name|mdx
argument_list|,
name|cy
operator|-
name|mdy
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
name|curs_set
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

