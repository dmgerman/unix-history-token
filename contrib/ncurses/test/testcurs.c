begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * This is a test program for the PDCurses screen package for IBM PC type  * machines.  *  * This program was written by John Burnell (johnb@kea.am.dsir.govt.nz)  *  wrs(5/28/93) -- modified to be consistent (perform identically) with either  *                  PDCurses or under Unix System V, R4  *  * $Id: testcurs.c,v 1.19 1999/02/14 00:42:28 tom Exp $  */
end_comment

begin_include
include|#
directive|include
file|<test.priv.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|XCURSES
argument_list|)
end_if

begin_decl_stmt
name|char
modifier|*
name|XCursesProgramName
init|=
literal|"testcurs"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|initTest
parameter_list|(
name|WINDOW
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|display_menu
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|inputTest
parameter_list|(
name|WINDOW
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|introTest
parameter_list|(
name|WINDOW
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|outputTest
parameter_list|(
name|WINDOW
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|padTest
parameter_list|(
name|WINDOW
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scrollTest
parameter_list|(
name|WINDOW
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PDCURSES
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|XCURSES
argument_list|)
end_if

begin_function_decl
specifier|static
name|void
name|resizeTest
parameter_list|(
name|WINDOW
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|commands
block|{
name|NCURSES_CONST
name|char
modifier|*
name|text
decl_stmt|;
name|void
function_decl|(
modifier|*
name|function
function_decl|)
parameter_list|(
name|WINDOW
modifier|*
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|commands
name|COMMAND
typedef|;
end_typedef

begin_decl_stmt
specifier|const
name|COMMAND
name|command
index|[]
init|=
block|{
block|{
literal|"Intro Test"
block|,
name|introTest
block|}
block|,
block|{
literal|"Pad Test"
block|,
name|padTest
block|}
block|,
if|#
directive|if
name|defined
argument_list|(
name|PDCURSES
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|XCURSES
argument_list|)
block|{
literal|"Resize Test"
block|,
name|resizeTest
block|}
block|,
endif|#
directive|endif
block|{
literal|"Scroll Test"
block|,
name|scrollTest
block|}
block|,
block|{
literal|"Input Test"
block|,
name|inputTest
block|}
block|,
block|{
literal|"Output Test"
block|,
name|outputTest
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAX_OPTIONS
value|((sizeof(command)/sizeof(command[0])))
end_define

begin_decl_stmt
name|int
name|width
decl_stmt|,
name|height
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
name|GCC_UNUSED
parameter_list|,
name|char
modifier|*
name|argv
index|[]
name|GCC_UNUSED
parameter_list|)
block|{
name|WINDOW
modifier|*
name|win
decl_stmt|;
name|int
name|key
decl_stmt|,
name|old_option
init|=
operator|(
operator|-
literal|1
operator|)
decl_stmt|,
name|new_option
init|=
literal|0
decl_stmt|;
name|bool
name|quit
init|=
name|FALSE
decl_stmt|;
ifdef|#
directive|ifdef
name|PDCDEBUG
name|PDC_debug
argument_list|(
literal|"testcurs started\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|initTest
argument_list|(
operator|&
name|win
argument_list|)
condition|)
return|return
name|EXIT_FAILURE
return|;
ifdef|#
directive|ifdef
name|A_COLOR
if|if
condition|(
name|has_colors
argument_list|()
condition|)
block|{
name|init_pair
argument_list|(
literal|1
argument_list|,
name|COLOR_WHITE
argument_list|,
name|COLOR_BLUE
argument_list|)
expr_stmt|;
name|wbkgd
argument_list|(
name|win
argument_list|,
name|COLOR_PAIR
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|wbkgd
argument_list|(
name|win
argument_list|,
name|A_REVERSE
argument_list|)
expr_stmt|;
else|#
directive|else
name|wbkgd
argument_list|(
name|win
argument_list|,
name|A_REVERSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|erase
argument_list|()
expr_stmt|;
name|display_menu
argument_list|(
name|old_option
argument_list|,
name|new_option
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|noecho
argument_list|()
expr_stmt|;
name|keypad
argument_list|(
name|stdscr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|raw
argument_list|()
expr_stmt|;
name|key
operator|=
name|getch
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|key
condition|)
block|{
case|case
literal|10
case|:
case|case
literal|13
case|:
case|case
name|KEY_ENTER
case|:
name|erase
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
operator|(
operator|*
name|command
index|[
name|new_option
index|]
operator|.
name|function
operator|)
operator|(
name|win
operator|)
expr_stmt|;
name|erase
argument_list|()
expr_stmt|;
name|display_menu
argument_list|(
name|old_option
argument_list|,
name|new_option
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_UP
case|:
name|new_option
operator|=
operator|(
name|new_option
operator|==
literal|0
operator|)
condition|?
name|new_option
else|:
name|new_option
operator|-
literal|1
expr_stmt|;
name|display_menu
argument_list|(
name|old_option
argument_list|,
name|new_option
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_DOWN
case|:
name|new_option
operator|=
operator|(
name|new_option
operator|==
name|MAX_OPTIONS
operator|-
literal|1
operator|)
condition|?
name|new_option
else|:
name|new_option
operator|+
literal|1
expr_stmt|;
name|display_menu
argument_list|(
name|old_option
argument_list|,
name|new_option
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
case|case
literal|'q'
case|:
name|quit
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|quit
operator|==
name|TRUE
condition|)
break|break;
block|}
name|delwin
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|XCURSES
name|XCursesExit
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|EXIT_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|Continue
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|wmove
argument_list|(
name|win
argument_list|,
literal|10
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|wclrtoeol
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|10
argument_list|,
literal|1
argument_list|,
literal|" Press any key to continue"
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|raw
argument_list|()
expr_stmt|;
name|wgetch
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|initTest
parameter_list|(
name|WINDOW
modifier|*
modifier|*
name|win
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PDCDEBUG
name|PDC_debug
argument_list|(
literal|"initTest called\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NCURSES_VERSION
name|trace
argument_list|(
name|TRACE_MAXIMUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|initscr
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|PDCDEBUG
name|PDC_debug
argument_list|(
literal|"after initscr()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|A_COLOR
if|if
condition|(
name|has_colors
argument_list|()
condition|)
name|start_color
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|width
operator|=
literal|60
expr_stmt|;
name|height
operator|=
literal|13
expr_stmt|;
comment|/* Create a drawing window */
operator|*
name|win
operator|=
name|newwin
argument_list|(
name|height
argument_list|,
name|width
argument_list|,
operator|(
name|LINES
operator|-
name|height
operator|)
operator|/
literal|2
argument_list|,
operator|(
name|COLS
operator|-
name|width
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|win
operator|==
name|NULL
condition|)
block|{
name|endwin
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|introTest
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|wmove
argument_list|(
name|win
argument_list|,
name|height
operator|/
literal|2
operator|-
literal|5
argument_list|,
name|width
operator|/
literal|2
argument_list|)
expr_stmt|;
name|wvline
argument_list|(
name|win
argument_list|,
name|ACS_VLINE
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
name|height
operator|/
literal|2
argument_list|,
name|width
operator|/
literal|2
operator|-
literal|10
argument_list|)
expr_stmt|;
name|whline
argument_list|(
name|win
argument_list|,
name|ACS_HLINE
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|Continue
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
name|werase
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|box
argument_list|(
name|win
argument_list|,
name|ACS_VLINE
argument_list|,
name|ACS_HLINE
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|cbreak
argument_list|()
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"You should have rectangle in the middle of the screen"
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|"You should have heard a beep"
argument_list|)
expr_stmt|;
name|Continue
argument_list|(
name|win
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|scrollTest
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|OldX
decl_stmt|,
name|OldY
decl_stmt|;
name|NCURSES_CONST
name|char
modifier|*
name|Message
init|=
literal|"The window will now scroll slowly"
decl_stmt|;
name|wclear
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|mvwprintw
argument_list|(
name|win
argument_list|,
name|height
operator|-
literal|2
argument_list|,
literal|1
argument_list|,
name|Message
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|scrollok
argument_list|(
name|win
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|height
condition|;
name|i
operator|++
control|)
block|{
name|napms
argument_list|(
literal|250
argument_list|)
expr_stmt|;
name|scroll
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
name|getmaxyx
argument_list|(
name|win
argument_list|,
name|OldY
argument_list|,
name|OldX
argument_list|)
expr_stmt|;
name|mvwprintw
argument_list|(
name|win
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
literal|"The top of the window will scroll"
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|wsetscrreg
argument_list|(
name|win
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|box
argument_list|(
name|win
argument_list|,
name|ACS_VLINE
argument_list|,
name|ACS_HLINE
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|napms
argument_list|(
literal|500
argument_list|)
expr_stmt|;
name|scroll
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
name|mvwprintw
argument_list|(
name|win
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
literal|"The bottom of the window will scroll"
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|wsetscrreg
argument_list|(
name|win
argument_list|,
literal|5
argument_list|,
operator|--
name|OldY
argument_list|)
expr_stmt|;
name|box
argument_list|(
name|win
argument_list|,
name|ACS_VLINE
argument_list|,
name|ACS_HLINE
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|5
init|;
name|i
operator|<=
name|OldY
condition|;
name|i
operator|++
control|)
block|{
name|napms
argument_list|(
literal|300
argument_list|)
expr_stmt|;
name|wscrl
argument_list|(
name|win
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
name|wsetscrreg
argument_list|(
name|win
argument_list|,
literal|0
argument_list|,
name|OldY
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|inputTest
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|int
name|w
decl_stmt|,
name|h
decl_stmt|,
name|bx
decl_stmt|,
name|by
decl_stmt|,
name|sw
decl_stmt|,
name|sh
decl_stmt|,
name|i
decl_stmt|,
name|c
decl_stmt|,
name|num
decl_stmt|;
name|char
name|buffer
index|[
literal|80
index|]
decl_stmt|;
name|WINDOW
modifier|*
name|subWin
decl_stmt|;
name|wclear
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|getmaxyx
argument_list|(
name|win
argument_list|,
name|h
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|getbegyx
argument_list|(
name|win
argument_list|,
name|by
argument_list|,
name|bx
argument_list|)
expr_stmt|;
name|sw
operator|=
name|w
operator|/
literal|3
expr_stmt|;
name|sh
operator|=
name|h
operator|/
literal|3
expr_stmt|;
if|if
condition|(
operator|(
name|subWin
operator|=
name|subwin
argument_list|(
name|win
argument_list|,
name|sh
argument_list|,
name|sw
argument_list|,
name|by
operator|+
name|h
operator|-
name|sh
operator|-
literal|2
argument_list|,
name|bx
operator|+
name|w
operator|-
name|sw
operator|-
literal|2
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
ifdef|#
directive|ifdef
name|A_COLOR
if|if
condition|(
name|has_colors
argument_list|()
condition|)
block|{
name|init_pair
argument_list|(
literal|2
argument_list|,
name|COLOR_WHITE
argument_list|,
name|COLOR_RED
argument_list|)
expr_stmt|;
name|wbkgd
argument_list|(
name|subWin
argument_list|,
name|COLOR_PAIR
argument_list|(
literal|2
argument_list|)
operator||
name|A_BOLD
argument_list|)
expr_stmt|;
block|}
else|else
name|wbkgd
argument_list|(
name|subWin
argument_list|,
name|A_BOLD
argument_list|)
expr_stmt|;
else|#
directive|else
name|wbkgd
argument_list|(
name|subWin
argument_list|,
name|A_BOLD
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|box
argument_list|(
name|subWin
argument_list|,
name|ACS_VLINE
argument_list|,
name|ACS_HLINE
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|nocbreak
argument_list|()
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|"Press some keys for 5 seconds"
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"Pressing ^C should do nothing"
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|werase
argument_list|(
name|subWin
argument_list|)
expr_stmt|;
name|box
argument_list|(
name|subWin
argument_list|,
name|ACS_VLINE
argument_list|,
name|ACS_HLINE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|mvwprintw
argument_list|(
name|subWin
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"Time = %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|subWin
argument_list|)
expr_stmt|;
name|napms
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|flushinp
argument_list|()
expr_stmt|;
block|}
name|delwin
argument_list|(
name|subWin
argument_list|)
expr_stmt|;
name|werase
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|flash
argument_list|()
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|napms
argument_list|(
literal|500
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|"Press a key, followed by ENTER"
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
literal|9
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|echo
argument_list|()
expr_stmt|;
name|noraw
argument_list|()
expr_stmt|;
name|wgetch
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|flushinp
argument_list|()
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
literal|9
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|wdelch
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
literal|"The character should now have been deleted"
argument_list|)
expr_stmt|;
name|Continue
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wclear
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"Press keys (or mouse buttons) to show their names"
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|"Press spacebar to finish"
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|keypad
argument_list|(
name|win
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|raw
argument_list|()
expr_stmt|;
name|noecho
argument_list|()
expr_stmt|;
name|typeahead
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PDCURSES
argument_list|)
name|mouse_set
argument_list|(
name|ALL_MOUSE_EVENTS
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
literal|1
condition|)
block|{
name|wmove
argument_list|(
name|win
argument_list|,
literal|3
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|c
operator|=
name|wgetch
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wclrtobot
argument_list|(
name|win
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>=
name|KEY_MIN
condition|)
name|wprintw
argument_list|(
name|win
argument_list|,
literal|"Key Pressed: %s"
argument_list|,
name|keyname
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
name|wprintw
argument_list|(
name|win
argument_list|,
literal|"Key Pressed: %c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|wprintw
argument_list|(
name|win
argument_list|,
literal|"Key Pressed: %s"
argument_list|,
name|unctrl
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PDCURSES
argument_list|)
if|if
condition|(
name|c
operator|==
name|KEY_MOUSE
condition|)
block|{
name|int
name|button
init|=
literal|0
decl_stmt|;
name|request_mouse_pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|BUTTON_CHANGED
argument_list|(
literal|1
argument_list|)
condition|)
name|button
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|BUTTON_CHANGED
argument_list|(
literal|2
argument_list|)
condition|)
name|button
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|BUTTON_CHANGED
argument_list|(
literal|3
argument_list|)
condition|)
name|button
operator|=
literal|3
expr_stmt|;
else|else
name|button
operator|=
literal|0
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
literal|4
argument_list|,
literal|18
argument_list|)
expr_stmt|;
name|wprintw
argument_list|(
name|win
argument_list|,
literal|"Button %d: "
argument_list|,
name|button
argument_list|)
expr_stmt|;
if|if
condition|(
name|MOUSE_MOVED
condition|)
name|wprintw
argument_list|(
name|win
argument_list|,
literal|"moved: "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|BUTTON_STATUS
argument_list|(
name|button
argument_list|)
operator|&
name|BUTTON_ACTION_MASK
operator|)
operator|==
name|BUTTON_PRESSED
condition|)
name|wprintw
argument_list|(
name|win
argument_list|,
literal|"pressed: "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|BUTTON_STATUS
argument_list|(
name|button
argument_list|)
operator|&
name|BUTTON_ACTION_MASK
operator|)
operator|==
name|BUTTON_DOUBLE_CLICKED
condition|)
name|wprintw
argument_list|(
name|win
argument_list|,
literal|"double: "
argument_list|)
expr_stmt|;
else|else
name|wprintw
argument_list|(
name|win
argument_list|,
literal|"released: "
argument_list|)
expr_stmt|;
name|wprintw
argument_list|(
name|win
argument_list|,
literal|" Position: Y: %d X: %d"
argument_list|,
name|MOUSE_Y_POS
argument_list|,
name|MOUSE_X_POS
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|' '
condition|)
break|break;
block|}
if|#
directive|if
literal|0
block|nodelay(win, TRUE);     wgetch(win);     nodelay(win, FALSE);
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PDCURSES
argument_list|)
name|mouse_set
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|refresh
argument_list|()
expr_stmt|;
name|wclear
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|3
argument_list|,
literal|2
argument_list|,
literal|"The window should have moved"
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|4
argument_list|,
literal|2
argument_list|,
literal|"This text should have appeared without you pressing a key"
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|6
argument_list|,
literal|2
argument_list|,
literal|"Enter a number then a string separated by space"
argument_list|)
expr_stmt|;
name|mvwin
argument_list|(
name|win
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|echo
argument_list|()
expr_stmt|;
name|noraw
argument_list|()
expr_stmt|;
name|num
operator|=
literal|0
expr_stmt|;
operator|*
name|buffer
operator|=
literal|0
expr_stmt|;
name|mvwscanw
argument_list|(
name|win
argument_list|,
literal|7
argument_list|,
literal|6
argument_list|,
literal|"%d %s"
argument_list|,
operator|&
name|num
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|mvwprintw
argument_list|(
name|win
argument_list|,
literal|8
argument_list|,
literal|6
argument_list|,
literal|"String: %s Number: %d"
argument_list|,
name|buffer
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|Continue
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|outputTest
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|WINDOW
modifier|*
name|win1
decl_stmt|;
name|char
name|Buffer
index|[
literal|80
index|]
decl_stmt|;
name|chtype
name|ch
decl_stmt|;
name|int
name|by
decl_stmt|,
name|bx
decl_stmt|;
name|nl
argument_list|()
expr_stmt|;
name|wclear
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"You should now have a screen in the upper left corner, and this text should have wrapped"
argument_list|)
expr_stmt|;
name|mvwin
argument_list|(
name|win
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|waddstr
argument_list|(
name|win
argument_list|,
literal|"\nThis text should be down\n"
argument_list|)
expr_stmt|;
name|waddstr
argument_list|(
name|win
argument_list|,
literal|"and broken into two here ^"
argument_list|)
expr_stmt|;
name|Continue
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wclear
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wattron
argument_list|(
name|win
argument_list|,
name|A_BOLD
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"A new window will appear with this text in it"
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
literal|"Press any key to continue"
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wgetch
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|getbegyx
argument_list|(
name|win
argument_list|,
name|by
argument_list|,
name|bx
argument_list|)
expr_stmt|;
if|if
condition|(
name|LINES
operator|<
literal|24
operator|||
name|COLS
operator|<
literal|75
condition|)
block|{
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|,
literal|"Some tests have been skipped as they require a"
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
literal|"display of at least 24 LINES by 75 COLUMNS"
argument_list|)
expr_stmt|;
name|Continue
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|win1
operator|=
name|newwin
argument_list|(
literal|10
argument_list|,
literal|50
argument_list|,
literal|14
argument_list|,
literal|25
argument_list|)
expr_stmt|;
if|if
condition|(
name|win1
operator|==
name|NULL
condition|)
block|{
name|endwin
argument_list|()
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|A_COLOR
if|if
condition|(
name|has_colors
argument_list|()
condition|)
block|{
name|init_pair
argument_list|(
literal|3
argument_list|,
name|COLOR_BLUE
argument_list|,
name|COLOR_WHITE
argument_list|)
expr_stmt|;
name|wbkgd
argument_list|(
name|win1
argument_list|,
name|COLOR_PAIR
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|wbkgd
argument_list|(
name|win1
argument_list|,
name|A_NORMAL
argument_list|)
expr_stmt|;
else|#
directive|else
name|wbkgd
argument_list|(
name|win1
argument_list|,
name|A_NORMAL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|wclear
argument_list|(
name|win1
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win1
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|,
literal|"This text should appear; using overlay option"
argument_list|)
expr_stmt|;
name|copywin
argument_list|(
name|win
argument_list|,
name|win1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|9
argument_list|,
literal|49
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PDCURSES
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|XCURSES
argument_list|)
name|box
argument_list|(
name|win1
argument_list|,
literal|0xb3
argument_list|,
literal|0xc4
argument_list|)
expr_stmt|;
else|#
directive|else
name|box
argument_list|(
name|win1
argument_list|,
name|ACS_VLINE
argument_list|,
name|ACS_HLINE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|wmove
argument_list|(
name|win1
argument_list|,
literal|8
argument_list|,
literal|26
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win1
argument_list|)
expr_stmt|;
name|wgetch
argument_list|(
name|win1
argument_list|)
expr_stmt|;
name|wclear
argument_list|(
name|win1
argument_list|)
expr_stmt|;
name|wattron
argument_list|(
name|win1
argument_list|,
name|A_BLINK
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win1
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
literal|"This blinking text should appear in only the second window"
argument_list|)
expr_stmt|;
name|wattroff
argument_list|(
name|win1
argument_list|,
name|A_BLINK
argument_list|)
expr_stmt|;
name|mvwin
argument_list|(
name|win1
argument_list|,
name|by
argument_list|,
name|bx
argument_list|)
expr_stmt|;
name|overlay
argument_list|(
name|win
argument_list|,
name|win1
argument_list|)
expr_stmt|;
name|mvwin
argument_list|(
name|win1
argument_list|,
literal|14
argument_list|,
literal|25
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win1
argument_list|,
literal|8
argument_list|,
literal|26
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win1
argument_list|)
expr_stmt|;
name|wgetch
argument_list|(
name|win1
argument_list|)
expr_stmt|;
name|delwin
argument_list|(
name|win1
argument_list|)
expr_stmt|;
block|}
name|clear
argument_list|()
expr_stmt|;
name|wclear
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|6
argument_list|,
literal|2
argument_list|,
literal|"This line shouldn't appear"
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|4
argument_list|,
literal|2
argument_list|,
literal|"Only half of the next line is visible"
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|5
argument_list|,
literal|2
argument_list|,
literal|"Only half of the next line is visible"
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|wclrtobot
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
literal|5
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|wclrtoeol
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|8
argument_list|,
literal|2
argument_list|,
literal|"This line also shouldn't appear"
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|wdeleteln
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|Continue
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
literal|5
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|ch
operator|=
name|winch
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wclear
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
literal|6
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|waddstr
argument_list|(
name|win
argument_list|,
literal|"The next char should be l:  "
argument_list|)
expr_stmt|;
name|winsch
argument_list|(
name|win
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|Continue
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|mvwinsstr
argument_list|(
name|win
argument_list|,
literal|6
argument_list|,
literal|2
argument_list|,
literal|"A1B2C3D4E5"
argument_list|)
expr_stmt|;
name|Continue
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|winsertln
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|5
argument_list|,
literal|2
argument_list|,
literal|"The lines below should have moved down"
argument_list|)
expr_stmt|;
name|Continue
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wclear
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|wprintw
argument_list|(
name|win
argument_list|,
literal|"This is a formatted string in a window: %d %s\n"
argument_list|,
literal|42
argument_list|,
literal|"is it"
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|10
argument_list|,
literal|1
argument_list|,
literal|"Enter a string: "
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|noraw
argument_list|()
expr_stmt|;
name|echo
argument_list|()
expr_stmt|;
operator|*
name|Buffer
operator|=
literal|0
expr_stmt|;
name|wscanw
argument_list|(
name|win
argument_list|,
literal|"%s"
argument_list|,
name|Buffer
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"This is a formatted string in stdscr: %d %s\n"
argument_list|,
literal|42
argument_list|,
literal|"is it"
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|10
argument_list|,
literal|1
argument_list|,
literal|"Enter a string: "
argument_list|)
expr_stmt|;
operator|*
name|Buffer
operator|=
literal|0
expr_stmt|;
name|scanw
argument_list|(
literal|"%s"
argument_list|,
name|Buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|tigetstr
argument_list|(
literal|"cvvis"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|wclear
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|curs_set
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"The cursor should appear as a block (visible)"
argument_list|)
expr_stmt|;
name|Continue
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tigetstr
argument_list|(
literal|"civis"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|wclear
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|curs_set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"The cursor should have disappeared (invisible)"
argument_list|)
expr_stmt|;
name|Continue
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tigetstr
argument_list|(
literal|"cnorm"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|wclear
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|curs_set
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"The cursor should be an underline (normal)"
argument_list|)
expr_stmt|;
name|Continue
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|A_COLOR
if|if
condition|(
name|has_colors
argument_list|()
condition|)
block|{
name|wclear
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"Colors should change after you press a key"
argument_list|)
expr_stmt|;
name|Continue
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|init_pair
argument_list|(
literal|1
argument_list|,
name|COLOR_RED
argument_list|,
name|COLOR_WHITE
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|werase
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"Information About Your Terminal"
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
name|termname
argument_list|()
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|longname
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|termattrs
argument_list|()
operator|&
name|A_BLINK
condition|)
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|,
literal|"This terminal supports blinking."
argument_list|)
expr_stmt|;
else|else
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|,
literal|"This terminal does NOT support blinking."
argument_list|)
expr_stmt|;
name|mvwaddnstr
argument_list|(
name|win
argument_list|,
literal|7
argument_list|,
literal|5
argument_list|,
literal|"Have a nice day!ok"
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|mvwinnstr
argument_list|(
name|win
argument_list|,
literal|7
argument_list|,
literal|5
argument_list|,
name|Buffer
argument_list|,
literal|18
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|LINES
operator|-
literal|2
argument_list|,
literal|10
argument_list|,
name|Buffer
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|Continue
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PDCURSES
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|XCURSES
argument_list|)
end_if

begin_function
specifier|static
name|void
name|resizeTest
parameter_list|(
name|WINDOW
modifier|*
name|dummy
name|GCC_UNUSED
parameter_list|)
block|{
name|WINDOW
modifier|*
name|win1
decl_stmt|;
name|savetty
argument_list|()
expr_stmt|;
name|clear
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|OS2
argument_list|)
name|resize_term
argument_list|(
literal|50
argument_list|,
literal|120
argument_list|)
expr_stmt|;
else|#
directive|else
name|resize_term
argument_list|(
literal|50
argument_list|,
literal|80
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|win1
operator|=
name|newwin
argument_list|(
literal|10
argument_list|,
literal|50
argument_list|,
literal|14
argument_list|,
literal|25
argument_list|)
expr_stmt|;
if|if
condition|(
name|win1
operator|==
name|NULL
condition|)
block|{
name|endwin
argument_list|()
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|A_COLOR
if|if
condition|(
name|has_colors
argument_list|()
condition|)
block|{
name|init_pair
argument_list|(
literal|3
argument_list|,
name|COLOR_BLUE
argument_list|,
name|COLOR_WHITE
argument_list|)
expr_stmt|;
name|wattrset
argument_list|(
name|win1
argument_list|,
name|COLOR_PAIR
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|wclear
argument_list|(
name|win1
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"The screen may now have 50 lines"
argument_list|)
expr_stmt|;
name|Continue
argument_list|(
name|win1
argument_list|)
expr_stmt|;
name|wclear
argument_list|(
name|win1
argument_list|)
expr_stmt|;
name|resetty
argument_list|()
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"The screen should now be reset"
argument_list|)
expr_stmt|;
name|Continue
argument_list|(
name|win1
argument_list|)
expr_stmt|;
name|delwin
argument_list|(
name|win1
argument_list|)
expr_stmt|;
name|clear
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|padTest
parameter_list|(
name|WINDOW
modifier|*
name|dummy
name|GCC_UNUSED
parameter_list|)
block|{
name|WINDOW
modifier|*
name|pad
decl_stmt|,
modifier|*
name|spad
decl_stmt|;
name|pad
operator|=
name|newpad
argument_list|(
literal|50
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|wattron
argument_list|(
name|pad
argument_list|,
name|A_REVERSE
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|pad
argument_list|,
literal|5
argument_list|,
literal|2
argument_list|,
literal|"This is a new pad"
argument_list|)
expr_stmt|;
name|wattrset
argument_list|(
name|pad
argument_list|,
name|A_NORMAL
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|pad
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
literal|"The end of this line should be truncated here:except  now"
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|pad
argument_list|,
literal|11
argument_list|,
literal|1
argument_list|,
literal|"This line should not appear.It will now"
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|pad
argument_list|,
literal|10
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|wclrtoeol
argument_list|(
name|pad
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|pad
argument_list|,
literal|10
argument_list|,
literal|1
argument_list|,
literal|" Press any key to continue"
argument_list|)
expr_stmt|;
name|prefresh
argument_list|(
name|pad
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
literal|45
argument_list|)
expr_stmt|;
name|keypad
argument_list|(
name|pad
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|raw
argument_list|()
expr_stmt|;
name|wgetch
argument_list|(
name|pad
argument_list|)
expr_stmt|;
name|spad
operator|=
name|subpad
argument_list|(
name|pad
argument_list|,
literal|12
argument_list|,
literal|25
argument_list|,
literal|6
argument_list|,
literal|52
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|spad
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|"This is a new subpad"
argument_list|)
expr_stmt|;
name|box
argument_list|(
name|spad
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|prefresh
argument_list|(
name|pad
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|15
argument_list|,
literal|75
argument_list|)
expr_stmt|;
name|keypad
argument_list|(
name|pad
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|raw
argument_list|()
expr_stmt|;
name|wgetch
argument_list|(
name|pad
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|pad
argument_list|,
literal|35
argument_list|,
literal|2
argument_list|,
literal|"This is displayed at line 35 in the pad"
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|pad
argument_list|,
literal|40
argument_list|,
literal|1
argument_list|,
literal|" Press any key to continue"
argument_list|)
expr_stmt|;
name|prefresh
argument_list|(
name|pad
argument_list|,
literal|30
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
literal|45
argument_list|)
expr_stmt|;
name|keypad
argument_list|(
name|pad
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|raw
argument_list|()
expr_stmt|;
name|wgetch
argument_list|(
name|pad
argument_list|)
expr_stmt|;
name|delwin
argument_list|(
name|pad
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|display_menu
parameter_list|(
name|int
name|old_option
parameter_list|,
name|int
name|new_option
parameter_list|)
block|{
specifier|register
name|size_t
name|i
decl_stmt|;
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|3
argument_list|,
literal|20
argument_list|,
literal|"PDCurses Test Program"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_OPTIONS
condition|;
name|i
operator|++
control|)
name|mvaddstr
argument_list|(
literal|5
operator|+
name|i
argument_list|,
literal|25
argument_list|,
name|command
index|[
name|i
index|]
operator|.
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_option
operator|!=
operator|(
operator|-
literal|1
operator|)
condition|)
name|mvaddstr
argument_list|(
literal|5
operator|+
name|old_option
argument_list|,
literal|25
argument_list|,
name|command
index|[
name|old_option
index|]
operator|.
name|text
argument_list|)
expr_stmt|;
name|attrset
argument_list|(
name|A_REVERSE
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|5
operator|+
name|new_option
argument_list|,
literal|25
argument_list|,
name|command
index|[
name|new_option
index|]
operator|.
name|text
argument_list|)
expr_stmt|;
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|13
argument_list|,
literal|3
argument_list|,
literal|"Use Up and Down Arrows to select - Enter to run - Q to quit"
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

