begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************************  * Copyright (c) 1999-2001,2002 Free Software Foundation, Inc.              *  *                                                                          *  * Permission is hereby granted, free of charge, to any person obtaining a  *  * copy of this software and associated documentation files (the            *  * "Software"), to deal in the Software without restriction, including      *  * without limitation the rights to use, copy, modify, merge, publish,      *  * distribute, distribute with modifications, sublicense, and/or sell       *  * copies of the Software, and to permit persons to whom the Software is    *  * furnished to do so, subject to the following conditions:                 *  *                                                                          *  * The above copyright notice and this permission notice shall be included  *  * in all copies or substantial portions of the Software.                   *  *                                                                          *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *  * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *  * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *  *                                                                          *  * Except as contained in this notice, the name(s) of the above copyright   *  * holders shall not be used in advertising or otherwise to promote the     *  * sale, use or other dealings in this Software without prior written       *  * authorization.                                                           *  ****************************************************************************/
end_comment

begin_comment
comment|/*  * Author: Thomas E. Dickey<dickey@clark.net> 1999  *  * $Id: cardfile.c,v 1.11 2002/04/06 23:12:50 tom Exp $  *  * File format: text beginning in column 1 is a title; other text forms the content.  */
end_comment

begin_include
include|#
directive|include
file|<test.priv.h>
end_include

begin_if
if|#
directive|if
name|HAVE_FORM_H
operator|&&
name|HAVE_PANEL_H
operator|&&
name|HAVE_LIBFORM
operator|&&
name|HAVE_LIBPANEL
end_if

begin_include
include|#
directive|include
file|<form.h>
end_include

begin_include
include|#
directive|include
file|<panel.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_define
define|#
directive|define
name|VISIBLE_CARDS
value|10
end_define

begin_define
define|#
directive|define
name|OFFSET_CARD
value|2
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|CTRL
end_ifndef

begin_define
define|#
directive|define
name|CTRL
parameter_list|(
name|x
parameter_list|)
value|((x)& 0x1f)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
struct|struct
name|_card
block|{
name|struct
name|_card
modifier|*
name|link
decl_stmt|;
name|PANEL
modifier|*
name|panel
decl_stmt|;
name|FORM
modifier|*
name|form
decl_stmt|;
name|char
modifier|*
name|title
decl_stmt|;
name|char
modifier|*
name|content
decl_stmt|;
block|}
name|CARD
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|CARD
modifier|*
name|all_cards
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|default_name
index|[]
init|=
literal|"cardfile.dat"
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|HAVE_STRDUP
end_if

begin_define
define|#
directive|define
name|strdup
value|my_strdup
end_define

begin_function
specifier|static
name|char
modifier|*
name|strdup
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
name|strcpy
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not HAVE_STRDUP */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|skip
parameter_list|(
specifier|const
name|char
modifier|*
name|buffer
parameter_list|)
block|{
while|while
condition|(
name|isspace
argument_list|(
name|UChar
argument_list|(
operator|*
name|buffer
argument_list|)
argument_list|)
condition|)
name|buffer
operator|++
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|trim
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|)
block|{
name|unsigned
name|n
init|=
name|strlen
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
while|while
condition|(
name|n
operator|--
operator|&&
name|isspace
argument_list|(
name|UChar
argument_list|(
name|buffer
index|[
name|n
index|]
argument_list|)
argument_list|)
condition|)
name|buffer
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
specifier|static
name|CARD
modifier|*
name|add_title
parameter_list|(
specifier|const
name|char
modifier|*
name|title
parameter_list|)
block|{
name|CARD
modifier|*
name|card
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|p
operator|=
name|all_cards
operator|,
name|q
operator|=
literal|0
init|;
name|p
operator|!=
literal|0
condition|;
name|q
operator|=
name|p
operator|,
name|p
operator|=
name|p
operator|->
name|link
control|)
block|{
name|int
name|cmp
init|=
name|strcmp
argument_list|(
name|p
operator|->
name|title
argument_list|,
name|title
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
return|return
name|p
return|;
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
break|break;
block|}
name|card
operator|=
operator|(
name|CARD
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|CARD
argument_list|)
argument_list|)
expr_stmt|;
name|card
operator|->
name|title
operator|=
name|strdup
argument_list|(
name|title
argument_list|)
expr_stmt|;
name|card
operator|->
name|content
operator|=
name|strdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
literal|0
condition|)
block|{
name|card
operator|->
name|link
operator|=
name|all_cards
expr_stmt|;
name|all_cards
operator|=
name|card
expr_stmt|;
block|}
else|else
block|{
name|card
operator|->
name|link
operator|=
name|q
operator|->
name|link
expr_stmt|;
name|q
operator|->
name|link
operator|=
name|card
expr_stmt|;
block|}
return|return
name|card
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_content
parameter_list|(
name|CARD
modifier|*
name|card
parameter_list|,
specifier|const
name|char
modifier|*
name|content
parameter_list|)
block|{
name|unsigned
name|total
decl_stmt|,
name|offset
decl_stmt|;
name|content
operator|=
name|skip
argument_list|(
name|content
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|total
operator|=
name|strlen
argument_list|(
name|content
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|offset
operator|=
name|strlen
argument_list|(
name|card
operator|->
name|content
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|total
operator|+=
literal|1
operator|+
name|offset
expr_stmt|;
name|card
operator|->
name|content
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|card
operator|->
name|content
argument_list|,
name|total
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|card
operator|->
name|content
operator|+
name|offset
operator|++
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|card
operator|->
name|content
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|total
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|card
operator|->
name|content
operator|+
name|offset
argument_list|,
name|content
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|CARD
modifier|*
name|new_card
parameter_list|(
name|void
parameter_list|)
block|{
name|CARD
modifier|*
name|card
init|=
name|add_title
argument_list|(
literal|""
argument_list|)
decl_stmt|;
name|add_content
argument_list|(
name|card
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
name|card
return|;
block|}
end_function

begin_function
specifier|static
name|CARD
modifier|*
name|find_card
parameter_list|(
name|char
modifier|*
name|title
parameter_list|)
block|{
name|CARD
modifier|*
name|card
decl_stmt|;
for|for
control|(
name|card
operator|=
name|all_cards
init|;
name|card
operator|!=
literal|0
condition|;
name|card
operator|=
name|card
operator|->
name|link
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|card
operator|->
name|title
argument_list|,
name|title
argument_list|)
condition|)
break|break;
return|return
name|card
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|read_data
parameter_list|(
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|CARD
modifier|*
name|card
init|=
literal|0
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|fp
argument_list|)
condition|)
block|{
name|trim
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|isspace
argument_list|(
name|UChar
argument_list|(
operator|*
name|buffer
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|card
operator|==
literal|0
condition|)
name|card
operator|=
name|add_title
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|add_content
argument_list|(
name|card
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|card
operator|=
name|find_card
argument_list|(
name|buffer
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|card
operator|=
name|add_title
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|write_data
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|CARD
modifier|*
name|p
init|=
literal|0
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|fname
argument_list|,
name|default_name
argument_list|)
condition|)
name|fname
operator|=
literal|"cardfile.out"
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|p
operator|=
name|all_cards
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|link
control|)
block|{
name|FIELD
modifier|*
modifier|*
name|f
init|=
name|form_fields
argument_list|(
name|p
operator|->
name|form
argument_list|)
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|f
index|[
name|n
index|]
operator|!=
literal|0
condition|;
name|n
operator|++
control|)
block|{
name|char
modifier|*
name|s
init|=
name|field_buffer
argument_list|(
name|f
index|[
name|n
index|]
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|!=
literal|0
operator|&&
operator|(
name|s
operator|=
name|strdup
argument_list|(
name|s
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|trim
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s%s\n"
argument_list|,
name|n
condition|?
literal|"\t"
else|:
literal|""
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************/
end_comment

begin_comment
comment|/*  * Count the cards  */
end_comment

begin_function
specifier|static
name|int
name|count_cards
parameter_list|(
name|void
parameter_list|)
block|{
name|CARD
modifier|*
name|p
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|p
operator|=
name|all_cards
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|link
control|)
name|count
operator|++
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/*  * Shuffle the panels to keep them in a natural hierarchy.  */
end_comment

begin_function
specifier|static
name|void
name|order_cards
parameter_list|(
name|CARD
modifier|*
name|first
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
if|if
condition|(
name|first
condition|)
block|{
if|if
condition|(
name|depth
operator|&&
name|first
operator|->
name|link
condition|)
name|order_cards
argument_list|(
name|first
operator|->
name|link
argument_list|,
name|depth
operator|-
literal|1
argument_list|)
expr_stmt|;
name|top_panel
argument_list|(
name|first
operator|->
name|panel
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Return the next card in the list  */
end_comment

begin_function
specifier|static
name|CARD
modifier|*
name|next_card
parameter_list|(
name|CARD
modifier|*
name|now
parameter_list|)
block|{
if|if
condition|(
name|now
operator|->
name|link
condition|)
name|now
operator|=
name|now
operator|->
name|link
expr_stmt|;
return|return
name|now
return|;
block|}
end_function

begin_comment
comment|/*  * Return the previous card in the list  */
end_comment

begin_function
specifier|static
name|CARD
modifier|*
name|prev_card
parameter_list|(
name|CARD
modifier|*
name|now
parameter_list|)
block|{
name|CARD
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|all_cards
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|link
control|)
if|if
condition|(
name|p
operator|->
name|link
operator|==
name|now
condition|)
return|return
name|p
return|;
return|return
name|now
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|form_virtualize
parameter_list|(
name|WINDOW
modifier|*
name|w
parameter_list|)
block|{
name|int
name|c
init|=
name|wgetch
argument_list|(
name|w
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|CTRL
argument_list|(
literal|'W'
argument_list|)
case|:
return|return
operator|(
name|MAX_FORM_COMMAND
operator|+
literal|4
operator|)
return|;
case|case
name|CTRL
argument_list|(
literal|'N'
argument_list|)
case|:
return|return
operator|(
name|MAX_FORM_COMMAND
operator|+
literal|3
operator|)
return|;
case|case
name|CTRL
argument_list|(
literal|'P'
argument_list|)
case|:
return|return
operator|(
name|MAX_FORM_COMMAND
operator|+
literal|2
operator|)
return|;
case|case
name|CTRL
argument_list|(
literal|'Q'
argument_list|)
case|:
case|case
literal|033
case|:
return|return
operator|(
name|MAX_FORM_COMMAND
operator|+
literal|1
operator|)
return|;
case|case
name|KEY_BACKSPACE
case|:
return|return
operator|(
name|REQ_DEL_PREV
operator|)
return|;
case|case
name|KEY_DC
case|:
return|return
operator|(
name|REQ_DEL_CHAR
operator|)
return|;
case|case
name|KEY_LEFT
case|:
return|return
operator|(
name|REQ_LEFT_CHAR
operator|)
return|;
case|case
name|KEY_RIGHT
case|:
return|return
operator|(
name|REQ_RIGHT_CHAR
operator|)
return|;
case|case
name|KEY_DOWN
case|:
case|case
name|KEY_NEXT
case|:
return|return
operator|(
name|REQ_NEXT_FIELD
operator|)
return|;
case|case
name|KEY_UP
case|:
case|case
name|KEY_PREVIOUS
case|:
return|return
operator|(
name|REQ_PREV_FIELD
operator|)
return|;
default|default:
return|return
operator|(
name|c
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|cardfile
parameter_list|(
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|WINDOW
modifier|*
name|win
decl_stmt|;
name|CARD
modifier|*
name|p
decl_stmt|;
name|CARD
modifier|*
name|top_card
decl_stmt|;
name|int
name|visible_cards
init|=
name|count_cards
argument_list|()
decl_stmt|;
name|int
name|panel_wide
init|=
name|COLS
operator|-
operator|(
name|visible_cards
operator|*
name|OFFSET_CARD
operator|)
decl_stmt|;
name|int
name|panel_high
init|=
name|LINES
operator|-
operator|(
name|visible_cards
operator|*
name|OFFSET_CARD
operator|)
operator|-
literal|5
decl_stmt|;
name|int
name|form_wide
init|=
name|panel_wide
operator|-
literal|2
decl_stmt|;
name|int
name|form_high
init|=
name|panel_high
operator|-
literal|2
decl_stmt|;
name|int
name|x
init|=
operator|(
name|visible_cards
operator|-
literal|1
operator|)
operator|*
name|OFFSET_CARD
decl_stmt|;
name|int
name|y
init|=
literal|0
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|int
name|finished
init|=
name|FALSE
decl_stmt|;
name|move
argument_list|(
name|LINES
operator|-
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"^Q/ESC -- exit form            ^W   -- writes data to file\n"
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"^N   -- go to next card        ^P   -- go to previous card\n"
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"Arrow keys move left/right within a field, up/down between fields"
argument_list|)
expr_stmt|;
comment|/* make a panel for each CARD */
for|for
control|(
name|p
operator|=
name|all_cards
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|link
control|)
block|{
name|FIELD
modifier|*
modifier|*
name|f
init|=
operator|(
name|FIELD
operator|*
operator|*
operator|)
name|calloc
argument_list|(
literal|3
argument_list|,
sizeof|sizeof
argument_list|(
name|FIELD
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|win
operator|=
name|newwin
argument_list|(
name|panel_high
argument_list|,
name|panel_wide
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|keypad
argument_list|(
name|win
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|p
operator|->
name|panel
operator|=
name|new_panel
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|box
argument_list|(
name|win
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ...and a form in each panel */
name|f
index|[
literal|0
index|]
operator|=
name|new_field
argument_list|(
literal|1
argument_list|,
name|form_wide
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_field_back
argument_list|(
name|f
index|[
literal|0
index|]
argument_list|,
name|A_REVERSE
argument_list|)
expr_stmt|;
name|set_field_buffer
argument_list|(
name|f
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
name|p
operator|->
name|title
argument_list|)
expr_stmt|;
name|f
index|[
literal|1
index|]
operator|=
name|new_field
argument_list|(
name|form_high
operator|-
literal|1
argument_list|,
name|form_wide
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_field_buffer
argument_list|(
name|f
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|p
operator|->
name|content
argument_list|)
expr_stmt|;
name|set_field_just
argument_list|(
name|f
index|[
literal|1
index|]
argument_list|,
name|JUSTIFY_LEFT
argument_list|)
expr_stmt|;
name|f
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|form
operator|=
name|new_form
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|set_form_win
argument_list|(
name|p
operator|->
name|form
argument_list|,
name|win
argument_list|)
expr_stmt|;
name|set_form_sub
argument_list|(
name|p
operator|->
name|form
argument_list|,
name|derwin
argument_list|(
name|win
argument_list|,
name|form_high
argument_list|,
name|form_wide
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|post_form
argument_list|(
name|p
operator|->
name|form
argument_list|)
expr_stmt|;
name|x
operator|-=
name|OFFSET_CARD
expr_stmt|;
name|y
operator|+=
name|OFFSET_CARD
expr_stmt|;
block|}
name|order_cards
argument_list|(
name|top_card
operator|=
name|all_cards
argument_list|,
name|visible_cards
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|finished
condition|)
block|{
name|update_panels
argument_list|()
expr_stmt|;
name|doupdate
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|form_driver
argument_list|(
name|top_card
operator|->
name|form
argument_list|,
name|ch
operator|=
name|form_virtualize
argument_list|(
name|panel_window
argument_list|(
name|top_card
operator|->
name|panel
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|E_OK
case|:
break|break;
case|case
name|E_UNKNOWN_COMMAND
case|:
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|MAX_FORM_COMMAND
operator|+
literal|1
case|:
name|finished
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|MAX_FORM_COMMAND
operator|+
literal|2
case|:
name|top_card
operator|=
name|prev_card
argument_list|(
name|top_card
argument_list|)
expr_stmt|;
name|order_cards
argument_list|(
name|top_card
argument_list|,
name|visible_cards
argument_list|)
expr_stmt|;
break|break;
case|case
name|MAX_FORM_COMMAND
operator|+
literal|3
case|:
name|top_card
operator|=
name|next_card
argument_list|(
name|top_card
argument_list|)
expr_stmt|;
name|order_cards
argument_list|(
name|top_card
argument_list|,
name|visible_cards
argument_list|)
expr_stmt|;
break|break;
case|case
name|MAX_FORM_COMMAND
operator|+
literal|4
case|:
name|write_data
argument_list|(
name|fname
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|KEY_RESIZE
case|case
name|KEY_RESIZE
case|:
name|flash
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|beep
argument_list|()
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|flash
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*******************************************************************************/
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|initscr
argument_list|()
expr_stmt|;
name|cbreak
argument_list|()
expr_stmt|;
name|noecho
argument_list|()
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|1
init|;
name|n
operator|<
name|argc
condition|;
name|n
operator|++
control|)
name|read_data
argument_list|(
name|argv
index|[
name|n
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|count_cards
argument_list|()
operator|==
literal|0
condition|)
name|new_card
argument_list|()
expr_stmt|;
name|cardfile
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|read_data
argument_list|(
name|default_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|count_cards
argument_list|()
operator|==
literal|0
condition|)
name|new_card
argument_list|()
expr_stmt|;
name|cardfile
argument_list|(
name|default_name
argument_list|)
expr_stmt|;
block|}
name|endwin
argument_list|()
expr_stmt|;
name|ExitProgram
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|int
name|main
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"This program requires the curses form and panel libraries\n"
argument_list|)
expr_stmt|;
name|ExitProgram
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

