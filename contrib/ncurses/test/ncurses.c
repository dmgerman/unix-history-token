begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************************  * Copyright (c) 1998,1999,2000 Free Software Foundation, Inc.              *  *                                                                          *  * Permission is hereby granted, free of charge, to any person obtaining a  *  * copy of this software and associated documentation files (the            *  * "Software"), to deal in the Software without restriction, including      *  * without limitation the rights to use, copy, modify, merge, publish,      *  * distribute, distribute with modifications, sublicense, and/or sell       *  * copies of the Software, and to permit persons to whom the Software is    *  * furnished to do so, subject to the following conditions:                 *  *                                                                          *  * The above copyright notice and this permission notice shall be included  *  * in all copies or substantial portions of the Software.                   *  *                                                                          *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *  * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *  * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *  *                                                                          *  * Except as contained in this notice, the name(s) of the above copyright   *  * holders shall not be used in advertising or otherwise to promote the     *  * sale, use or other dealings in this Software without prior written       *  * authorization.                                                           *  ****************************************************************************/
end_comment

begin_comment
comment|/****************************************************************************  NAME    ncurses.c --- ncurses library exerciser  SYNOPSIS    ncurses  DESCRIPTION    An interactive test module for the ncurses library.  AUTHOR    Author: Eric S. Raymond<esr@snark.thyrsus.com> 1993  $Id: ncurses.c,v 1.138 2000/09/17 01:24:00 tom Exp $  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<test.priv.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_if
if|#
directive|if
name|HAVE_LOCALE_H
end_if

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_GETTIMEOFDAY
end_if

begin_if
if|#
directive|if
name|HAVE_SYS_TIME_H
operator|&&
name|HAVE_SYS_TIME_SELECT
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_SYS_SELECT_H
end_if

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_PANEL_H
end_if

begin_define
define|#
directive|define
name|USE_LIBPANEL
value|1
end_define

begin_include
include|#
directive|include
file|<panel.h>
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|USE_LIBPANEL
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_MENU_H
operator|&&
name|HAVE_LIBMENU
end_if

begin_define
define|#
directive|define
name|USE_LIBMENU
value|1
end_define

begin_include
include|#
directive|include
file|<menu.h>
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|USE_LIBMENU
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_FORM_H
operator|&&
name|HAVE_LIBFORM
end_if

begin_define
define|#
directive|define
name|USE_LIBFORM
value|1
end_define

begin_include
include|#
directive|include
file|<form.h>
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|USE_LIBFORM
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NCURSES_VERSION
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|TRACE
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|save_trace
init|=
name|TRACE_ORDINARY
operator||
name|TRACE_CALLS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_nc_tracing
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_NAPMS
argument_list|)
end_if

begin_define
define|#
directive|define
name|HAVE_NAPMS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|mmask_t
value|chtype
end_define

begin_comment
comment|/* not specified in XSI */
end_comment

begin_define
define|#
directive|define
name|attr_t
value|chtype
end_define

begin_comment
comment|/* not specified in XSI */
end_comment

begin_define
define|#
directive|define
name|ACS_S3
value|(acs_map['p'])
end_define

begin_comment
comment|/* scan line 3 */
end_comment

begin_define
define|#
directive|define
name|ACS_S7
value|(acs_map['r'])
end_define

begin_comment
comment|/* scan line 7 */
end_comment

begin_define
define|#
directive|define
name|ACS_LEQUAL
value|(acs_map['y'])
end_define

begin_comment
comment|/* less/equal */
end_comment

begin_define
define|#
directive|define
name|ACS_GEQUAL
value|(acs_map['z'])
end_define

begin_comment
comment|/* greater/equal */
end_comment

begin_define
define|#
directive|define
name|ACS_PI
value|(acs_map['{'])
end_define

begin_comment
comment|/* Pi */
end_comment

begin_define
define|#
directive|define
name|ACS_NEQUAL
value|(acs_map['|'])
end_define

begin_comment
comment|/* not equal */
end_comment

begin_define
define|#
directive|define
name|ACS_STERLING
value|(acs_map['}'])
end_define

begin_comment
comment|/* UK pound sign */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|P
parameter_list|(
name|string
parameter_list|)
value|printw("%s\n", string)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|CTRL
end_ifndef

begin_define
define|#
directive|define
name|CTRL
parameter_list|(
name|x
parameter_list|)
value|((x)& 0x1f)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|QUIT
value|CTRL('Q')
end_define

begin_define
define|#
directive|define
name|ESCAPE
value|CTRL('[')
end_define

begin_define
define|#
directive|define
name|BLANK
value|' '
end_define

begin_comment
comment|/* this is the background character */
end_comment

begin_comment
comment|/* The behavior of mvhline, mvvline for negative/zero length is unspecified,  * though we can rely on negative x/y values to stop the macro.  */
end_comment

begin_function
specifier|static
name|void
name|do_h_line
parameter_list|(
name|int
name|y
parameter_list|,
name|int
name|x
parameter_list|,
name|chtype
name|c
parameter_list|,
name|int
name|to
parameter_list|)
block|{
if|if
condition|(
operator|(
name|to
operator|)
operator|>
operator|(
name|x
operator|)
condition|)
name|mvhline
argument_list|(
name|y
argument_list|,
name|x
argument_list|,
name|c
argument_list|,
operator|(
name|to
operator|)
operator|-
operator|(
name|x
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_v_line
parameter_list|(
name|int
name|y
parameter_list|,
name|int
name|x
parameter_list|,
name|chtype
name|c
parameter_list|,
name|int
name|to
parameter_list|)
block|{
if|if
condition|(
operator|(
name|to
operator|)
operator|>
operator|(
name|y
operator|)
condition|)
name|mvvline
argument_list|(
name|y
argument_list|,
name|x
argument_list|,
name|c
argument_list|,
operator|(
name|to
operator|)
operator|-
operator|(
name|y
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Common function to allow ^T to toggle trace-mode in the middle of a test  * so that trace-files can be made smaller.  */
end_comment

begin_function
specifier|static
name|int
name|wGetchar
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|TRACE
while|while
condition|(
operator|(
name|c
operator|=
name|wgetch
argument_list|(
name|win
argument_list|)
operator|)
operator|==
name|CTRL
argument_list|(
literal|'T'
argument_list|)
condition|)
block|{
if|if
condition|(
name|_nc_tracing
condition|)
block|{
name|save_trace
operator|=
name|_nc_tracing
expr_stmt|;
name|_tracef
argument_list|(
literal|"TOGGLE-TRACING OFF"
argument_list|)
expr_stmt|;
name|_nc_tracing
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|_nc_tracing
operator|=
name|save_trace
expr_stmt|;
block|}
name|trace
argument_list|(
name|_nc_tracing
argument_list|)
expr_stmt|;
if|if
condition|(
name|_nc_tracing
condition|)
name|_tracef
argument_list|(
literal|"TOGGLE-TRACING ON"
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|c
operator|=
name|wgetch
argument_list|(
name|win
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|c
return|;
block|}
end_function

begin_define
define|#
directive|define
name|Getchar
parameter_list|()
value|wGetchar(stdscr)
end_define

begin_function
specifier|static
name|void
name|Pause
parameter_list|(
name|void
parameter_list|)
block|{
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"Press any key to continue... "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Getchar
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Cannot
parameter_list|(
specifier|const
name|char
modifier|*
name|what
parameter_list|)
block|{
name|printw
argument_list|(
literal|"\nThis %s terminal %s\n\n"
argument_list|,
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
argument_list|,
name|what
argument_list|)
expr_stmt|;
name|Pause
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ShellOut
parameter_list|(
name|bool
name|message
parameter_list|)
block|{
if|if
condition|(
name|message
condition|)
name|addstr
argument_list|(
literal|"Shelling out..."
argument_list|)
expr_stmt|;
name|def_prog_mode
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
name|system
argument_list|(
literal|"sh"
argument_list|)
expr_stmt|;
if|if
condition|(
name|message
condition|)
name|addstr
argument_list|(
literal|"returned from shellout.\n"
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NCURSES_MOUSE_VERSION
end_ifdef

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|mouse_decode
parameter_list|(
name|MEVENT
specifier|const
modifier|*
name|ep
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"id %2d  at (%2d, %2d, %2d) state %4lx = {"
argument_list|,
name|ep
operator|->
name|id
argument_list|,
name|ep
operator|->
name|x
argument_list|,
name|ep
operator|->
name|y
argument_list|,
name|ep
operator|->
name|z
argument_list|,
name|ep
operator|->
name|bstate
argument_list|)
expr_stmt|;
define|#
directive|define
name|SHOW
parameter_list|(
name|m
parameter_list|,
name|s
parameter_list|)
value|if ((ep->bstate& m)==m) {strcat(buf,s); strcat(buf, ", ");}
name|SHOW
argument_list|(
name|BUTTON1_RELEASED
argument_list|,
literal|"release-1"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON1_PRESSED
argument_list|,
literal|"press-1"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON1_CLICKED
argument_list|,
literal|"click-1"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON1_DOUBLE_CLICKED
argument_list|,
literal|"doubleclick-1"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON1_TRIPLE_CLICKED
argument_list|,
literal|"tripleclick-1"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON1_RESERVED_EVENT
argument_list|,
literal|"reserved-1"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON2_RELEASED
argument_list|,
literal|"release-2"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON2_PRESSED
argument_list|,
literal|"press-2"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON2_CLICKED
argument_list|,
literal|"click-2"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON2_DOUBLE_CLICKED
argument_list|,
literal|"doubleclick-2"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON2_TRIPLE_CLICKED
argument_list|,
literal|"tripleclick-2"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON2_RESERVED_EVENT
argument_list|,
literal|"reserved-2"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON3_RELEASED
argument_list|,
literal|"release-3"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON3_PRESSED
argument_list|,
literal|"press-3"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON3_CLICKED
argument_list|,
literal|"click-3"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON3_DOUBLE_CLICKED
argument_list|,
literal|"doubleclick-3"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON3_TRIPLE_CLICKED
argument_list|,
literal|"tripleclick-3"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON3_RESERVED_EVENT
argument_list|,
literal|"reserved-3"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON4_RELEASED
argument_list|,
literal|"release-4"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON4_PRESSED
argument_list|,
literal|"press-4"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON4_CLICKED
argument_list|,
literal|"click-4"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON4_DOUBLE_CLICKED
argument_list|,
literal|"doubleclick-4"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON4_TRIPLE_CLICKED
argument_list|,
literal|"tripleclick-4"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON4_RESERVED_EVENT
argument_list|,
literal|"reserved-4"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON_CTRL
argument_list|,
literal|"ctrl"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON_SHIFT
argument_list|,
literal|"shift"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|BUTTON_ALT
argument_list|,
literal|"alt"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|ALL_MOUSE_EVENTS
argument_list|,
literal|"all-events"
argument_list|)
expr_stmt|;
name|SHOW
argument_list|(
name|REPORT_MOUSE_POSITION
argument_list|,
literal|"position"
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|SHOW
if|if
condition|(
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NCURSES_MOUSE_VERSION */
end_comment

begin_comment
comment|/****************************************************************************  *  * Character input test  *  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|getch_test
parameter_list|(
name|void
parameter_list|)
comment|/* test the keypad feature */
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|incount
init|=
literal|0
decl_stmt|,
name|firsttime
init|=
literal|0
decl_stmt|;
name|bool
name|blocking
init|=
name|TRUE
decl_stmt|;
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
name|refresh
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|NCURSES_MOUSE_VERSION
name|mousemask
argument_list|(
name|ALL_MOUSE_EVENTS
argument_list|,
operator|(
name|mmask_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"Delay in 10ths of a second (<CR> for blocking input)? "
argument_list|)
expr_stmt|;
name|echo
argument_list|()
expr_stmt|;
name|getstr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|noecho
argument_list|()
expr_stmt|;
name|nonl
argument_list|()
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|timeout
argument_list|(
name|atoi
argument_list|(
name|buf
argument_list|)
operator|*
literal|100
argument_list|)
expr_stmt|;
name|blocking
operator|=
name|FALSE
expr_stmt|;
block|}
name|c
operator|=
literal|'?'
expr_stmt|;
name|raw
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|firsttime
operator|++
condition|)
block|{
name|printw
argument_list|(
literal|"Key pressed: %04o "
argument_list|,
name|c
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NCURSES_MOUSE_VERSION
if|if
condition|(
name|c
operator|==
name|KEY_MOUSE
condition|)
block|{
name|MEVENT
name|event
decl_stmt|;
name|getmouse
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"KEY_MOUSE, %s\n"
argument_list|,
name|mouse_decode
argument_list|(
operator|&
name|event
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* NCURSES_MOUSE_VERSION */
if|if
condition|(
name|c
operator|>=
name|KEY_MIN
condition|)
block|{
operator|(
name|void
operator|)
name|addstr
argument_list|(
name|keyname
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|addch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>
literal|0x80
condition|)
block|{
name|int
name|c2
init|=
operator|(
name|c
operator|&
literal|0x7f
operator|)
decl_stmt|;
if|if
condition|(
name|isprint
argument_list|(
name|c2
argument_list|)
condition|)
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"M-%c"
argument_list|,
name|c2
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"M-%s"
argument_list|,
name|unctrl
argument_list|(
name|c2
argument_list|)
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|" (high-half character)\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"%c (ASCII printable character)\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"%s (ASCII control character)\n"
argument_list|,
name|unctrl
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|getyx
argument_list|(
name|stdscr
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|>=
name|LINES
operator|-
literal|1
condition|)
name|move
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'g'
condition|)
block|{
name|addstr
argument_list|(
literal|"getstr test: "
argument_list|)
expr_stmt|;
name|echo
argument_list|()
expr_stmt|;
name|getstr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|noecho
argument_list|()
expr_stmt|;
name|printw
argument_list|(
literal|"I saw `%s'.\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'s'
condition|)
block|{
name|ShellOut
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'x'
operator|||
name|c
operator|==
literal|'q'
operator|||
operator|(
name|c
operator|==
name|ERR
operator|&&
name|blocking
operator|)
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'?'
condition|)
block|{
name|addstr
argument_list|(
literal|"Type any key to see its keypad value.  Also:\n"
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"g -- triggers a getstr test\n"
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"s -- shell out\n"
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"q -- quit\n"
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"? -- repeats this help message\n"
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|Getchar
argument_list|()
operator|)
operator|==
name|ERR
condition|)
if|if
condition|(
operator|!
name|blocking
condition|)
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"%05d: input timed out\n"
argument_list|,
name|incount
operator|++
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"%05d: input error\n"
argument_list|,
name|incount
operator|++
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|NCURSES_MOUSE_VERSION
name|mousemask
argument_list|(
literal|0
argument_list|,
operator|(
name|mmask_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|timeout
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|erase
argument_list|()
expr_stmt|;
name|noraw
argument_list|()
expr_stmt|;
name|nl
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|show_attr
parameter_list|(
name|int
name|row
parameter_list|,
name|int
name|skip
parameter_list|,
name|chtype
name|attr
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|string
init|=
literal|"abcde fghij klmno pqrst uvwxy z"
decl_stmt|;
name|int
name|ncv
init|=
name|tigetnum
argument_list|(
literal|"ncv"
argument_list|)
decl_stmt|;
name|mvprintw
argument_list|(
name|row
argument_list|,
literal|8
argument_list|,
literal|"%s mode:"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
name|row
argument_list|,
literal|24
argument_list|,
literal|"|"
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip
condition|)
name|printw
argument_list|(
literal|"%*s"
argument_list|,
name|skip
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|attrset
argument_list|(
name|attr
argument_list|)
expr_stmt|;
comment|/*      * If we're to write a string in the alternate character set, it is not      * sufficient to just set A_ALTCHARSET.  We have to perform the mapping      * that corresponds.  This is not needed for vt100-compatible devices      * because the acs_map[] is 1:1, but for PC-style devices such as Linux      * console, the acs_map[] is scattered about the range.      *      * The addch/addstr functions do not themselves do this mapping, since it      * is possible to turn off the A_ALTCHARSET flag for the characters which      * are added, and it would be an unexpected result to have the mapped      * characters visible on the screen.      *      * This example works because the indices into acs_map[] are mostly from      * the lowercase characters.      */
if|if
condition|(
name|attr
operator|&
name|A_ALTCHARSET
condition|)
block|{
specifier|const
name|char
modifier|*
name|s
init|=
name|string
decl_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|int
name|ch
init|=
operator|*
name|s
operator|++
decl_stmt|;
if|if
condition|(
operator|(
name|ch
operator|=
name|acs_map
index|[
name|ch
index|]
operator|)
operator|==
literal|0
condition|)
name|ch
operator|=
literal|' '
expr_stmt|;
name|addch
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|addstr
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
name|attroff
argument_list|(
name|attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip
condition|)
name|printw
argument_list|(
literal|"%*s"
argument_list|,
name|skip
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"|"
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|!=
name|A_NORMAL
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|termattrs
argument_list|()
operator|&
name|attr
operator|)
condition|)
block|{
name|printw
argument_list|(
literal|" (N/A)"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ncv
operator|>
literal|0
operator|&&
operator|(
name|getbkgd
argument_list|(
name|stdscr
argument_list|)
operator|&
name|A_COLOR
operator|)
condition|)
block|{
specifier|static
specifier|const
name|attr_t
name|table
index|[]
init|=
block|{
name|A_STANDOUT
block|,
name|A_UNDERLINE
block|,
name|A_REVERSE
block|,
name|A_BLINK
block|,
name|A_DIM
block|,
name|A_BOLD
block|,
name|A_INVIS
block|,
name|A_PROTECT
block|,
name|A_ALTCHARSET
block|}
decl_stmt|;
name|unsigned
name|n
decl_stmt|;
name|bool
name|found
init|=
name|FALSE
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
sizeof|sizeof
argument_list|(
name|table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|table
index|[
literal|0
index|]
argument_list|)
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|table
index|[
name|n
index|]
operator|&
name|attr
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
literal|1
operator|<<
name|n
operator|)
operator|&
name|ncv
operator|)
operator|!=
literal|0
condition|)
block|{
name|found
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|found
condition|)
name|printw
argument_list|(
literal|" (NCV)"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|row
operator|+
literal|2
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|attr_getc
parameter_list|(
name|int
modifier|*
name|skip
parameter_list|,
name|int
modifier|*
name|fg
parameter_list|,
name|int
modifier|*
name|bg
parameter_list|,
name|int
modifier|*
name|ac
parameter_list|)
block|{
name|int
name|ch
init|=
name|Getchar
argument_list|()
decl_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|ch
argument_list|)
condition|)
block|{
operator|*
name|skip
operator|=
operator|(
name|ch
operator|-
literal|'0'
operator|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|CTRL
argument_list|(
literal|'L'
argument_list|)
condition|)
block|{
name|touchwin
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
name|touchwin
argument_list|(
name|curscr
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
elseif|else
if|if
condition|(
name|has_colors
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'a'
case|:
operator|*
name|ac
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
operator|*
name|ac
operator|=
name|A_ALTCHARSET
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
operator|*
name|fg
operator|=
operator|(
operator|*
name|fg
operator|+
literal|1
operator|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
operator|*
name|fg
operator|=
operator|(
operator|*
name|fg
operator|-
literal|1
operator|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
operator|*
name|bg
operator|=
operator|(
operator|*
name|bg
operator|+
literal|1
operator|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
operator|*
name|bg
operator|=
operator|(
operator|*
name|bg
operator|-
literal|1
operator|)
expr_stmt|;
break|break;
default|default:
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|*
name|fg
operator|>=
name|COLORS
condition|)
operator|*
name|fg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|fg
operator|<
literal|0
condition|)
operator|*
name|fg
operator|=
name|COLORS
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|bg
operator|>=
name|COLORS
condition|)
operator|*
name|bg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|bg
operator|<
literal|0
condition|)
operator|*
name|bg
operator|=
name|COLORS
operator|-
literal|1
expr_stmt|;
return|return
name|TRUE
return|;
block|}
else|else
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'a'
case|:
operator|*
name|ac
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
operator|*
name|ac
operator|=
name|A_ALTCHARSET
expr_stmt|;
break|break;
default|default:
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|attr_test
parameter_list|(
name|void
parameter_list|)
comment|/* test text attributes */
block|{
name|int
name|n
decl_stmt|;
name|int
name|skip
init|=
name|tigetnum
argument_list|(
literal|"xmc"
argument_list|)
decl_stmt|;
name|int
name|fg
init|=
name|COLOR_BLACK
decl_stmt|;
comment|/* color pair 0 is special */
name|int
name|bg
init|=
name|COLOR_BLACK
decl_stmt|;
name|int
name|ac
init|=
literal|0
decl_stmt|;
name|bool
modifier|*
name|pairs
init|=
operator|(
name|bool
operator|*
operator|)
name|calloc
argument_list|(
name|COLOR_PAIRS
argument_list|,
sizeof|sizeof
argument_list|(
name|bool
argument_list|)
argument_list|)
decl_stmt|;
name|pairs
index|[
literal|0
index|]
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|skip
operator|<
literal|0
condition|)
name|skip
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|skip
expr_stmt|;
comment|/* make it easy */
do|do
block|{
name|int
name|row
init|=
literal|2
decl_stmt|;
name|int
name|normal
init|=
name|A_NORMAL
operator||
name|BLANK
decl_stmt|;
if|if
condition|(
name|has_colors
argument_list|()
condition|)
block|{
name|int
name|pair
init|=
operator|(
name|fg
operator|*
name|COLORS
operator|)
operator|+
name|bg
decl_stmt|;
if|if
condition|(
operator|!
name|pairs
index|[
name|pair
index|]
condition|)
block|{
name|init_pair
argument_list|(
name|pair
argument_list|,
name|fg
argument_list|,
name|bg
argument_list|)
expr_stmt|;
name|pairs
index|[
name|pair
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
name|normal
operator||=
name|COLOR_PAIR
argument_list|(
name|pair
argument_list|)
expr_stmt|;
block|}
name|bkgdset
argument_list|(
name|normal
argument_list|)
expr_stmt|;
name|erase
argument_list|()
expr_stmt|;
name|mvaddstr
argument_list|(
literal|0
argument_list|,
literal|20
argument_list|,
literal|"Character attribute test display"
argument_list|)
expr_stmt|;
name|row
operator|=
name|show_attr
argument_list|(
name|row
argument_list|,
name|n
argument_list|,
name|ac
operator||
name|A_STANDOUT
argument_list|,
literal|"STANDOUT"
argument_list|)
expr_stmt|;
name|row
operator|=
name|show_attr
argument_list|(
name|row
argument_list|,
name|n
argument_list|,
name|ac
operator||
name|A_REVERSE
argument_list|,
literal|"REVERSE"
argument_list|)
expr_stmt|;
name|row
operator|=
name|show_attr
argument_list|(
name|row
argument_list|,
name|n
argument_list|,
name|ac
operator||
name|A_BOLD
argument_list|,
literal|"BOLD"
argument_list|)
expr_stmt|;
name|row
operator|=
name|show_attr
argument_list|(
name|row
argument_list|,
name|n
argument_list|,
name|ac
operator||
name|A_UNDERLINE
argument_list|,
literal|"UNDERLINE"
argument_list|)
expr_stmt|;
name|row
operator|=
name|show_attr
argument_list|(
name|row
argument_list|,
name|n
argument_list|,
name|ac
operator||
name|A_DIM
argument_list|,
literal|"DIM"
argument_list|)
expr_stmt|;
name|row
operator|=
name|show_attr
argument_list|(
name|row
argument_list|,
name|n
argument_list|,
name|ac
operator||
name|A_BLINK
argument_list|,
literal|"BLINK"
argument_list|)
expr_stmt|;
name|row
operator|=
name|show_attr
argument_list|(
name|row
argument_list|,
name|n
argument_list|,
name|ac
operator||
name|A_PROTECT
argument_list|,
literal|"PROTECT"
argument_list|)
expr_stmt|;
name|row
operator|=
name|show_attr
argument_list|(
name|row
argument_list|,
name|n
argument_list|,
name|ac
operator||
name|A_INVIS
argument_list|,
literal|"INVISIBLE"
argument_list|)
expr_stmt|;
name|row
operator|=
name|show_attr
argument_list|(
name|row
argument_list|,
name|n
argument_list|,
name|ac
operator||
name|A_NORMAL
argument_list|,
literal|"NORMAL"
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
name|row
argument_list|,
literal|8
argument_list|,
literal|"This terminal does %shave the magic-cookie glitch"
argument_list|,
name|tigetnum
argument_list|(
literal|"xmc"
argument_list|)
operator|>
operator|-
literal|1
condition|?
literal|""
else|:
literal|"not "
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
name|row
operator|+
literal|1
argument_list|,
literal|8
argument_list|,
literal|"Enter a digit to set gaps on each side of displayed attributes"
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
name|row
operator|+
literal|2
argument_list|,
literal|8
argument_list|,
literal|"^L = repaint"
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_colors
argument_list|()
condition|)
name|printw
argument_list|(
literal|".  f/F/b/F toggle colors (now %d/%d), a/A altcharset (%d)"
argument_list|,
name|fg
argument_list|,
name|bg
argument_list|,
name|ac
operator|!=
literal|0
argument_list|)
expr_stmt|;
else|else
name|printw
argument_list|(
literal|".  a/A altcharset (%d)"
argument_list|,
name|ac
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|attr_getc
argument_list|(
operator|&
name|n
argument_list|,
operator|&
name|fg
argument_list|,
operator|&
name|bg
argument_list|,
operator|&
name|ac
argument_list|)
condition|)
do|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pairs
argument_list|)
expr_stmt|;
name|bkgdset
argument_list|(
name|A_NORMAL
operator||
name|BLANK
argument_list|)
expr_stmt|;
name|erase
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  *  * Color support tests  *  ****************************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|NCURSES_CONST
name|char
modifier|*
name|color_names
index|[]
init|=
block|{
literal|"black"
block|,
literal|"red"
block|,
literal|"green"
block|,
literal|"yellow"
block|,
literal|"blue"
block|,
literal|"magenta"
block|,
literal|"cyan"
block|,
literal|"white"
block|,
literal|"BLACK"
block|,
literal|"RED"
block|,
literal|"GREEN"
block|,
literal|"YELLOW"
block|,
literal|"BLUE"
block|,
literal|"MAGENTA"
block|,
literal|"CYAN"
block|,
literal|"WHITE"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|show_color_name
parameter_list|(
name|int
name|y
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|color
parameter_list|)
block|{
if|if
condition|(
name|COLORS
operator|>
literal|8
condition|)
name|mvprintw
argument_list|(
name|y
argument_list|,
name|x
argument_list|,
literal|"%02d   "
argument_list|,
name|color
argument_list|)
expr_stmt|;
else|else
name|mvaddstr
argument_list|(
name|y
argument_list|,
name|x
argument_list|,
name|color_names
index|[
name|color
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|color_test
parameter_list|(
name|void
parameter_list|)
comment|/* generate a color test pattern */
block|{
name|int
name|i
decl_stmt|;
name|int
name|base
decl_stmt|,
name|top
decl_stmt|,
name|width
decl_stmt|;
name|NCURSES_CONST
name|char
modifier|*
name|hello
decl_stmt|;
name|refresh
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"There are %d color pairs\n"
argument_list|,
name|COLOR_PAIRS
argument_list|)
expr_stmt|;
name|width
operator|=
operator|(
name|COLORS
operator|>
literal|8
operator|)
condition|?
literal|4
else|:
literal|8
expr_stmt|;
name|hello
operator|=
operator|(
name|COLORS
operator|>
literal|8
operator|)
condition|?
literal|"Test"
else|:
literal|"Hello"
expr_stmt|;
for|for
control|(
name|base
operator|=
literal|0
init|;
name|base
operator|<
literal|2
condition|;
name|base
operator|++
control|)
block|{
name|top
operator|=
operator|(
name|COLORS
operator|>
literal|8
operator|)
condition|?
literal|0
else|:
name|base
operator|*
operator|(
name|COLORS
operator|+
literal|3
operator|)
expr_stmt|;
name|clrtobot
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|mvprintw
argument_list|(
name|top
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%dx%d matrix of foreground/background colors, bright *%s*\n"
argument_list|,
name|COLORS
argument_list|,
name|COLORS
argument_list|,
name|base
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|COLORS
condition|;
name|i
operator|++
control|)
name|show_color_name
argument_list|(
name|top
operator|+
literal|2
argument_list|,
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|width
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|COLORS
condition|;
name|i
operator|++
control|)
name|show_color_name
argument_list|(
name|top
operator|+
literal|3
operator|+
name|i
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|COLOR_PAIRS
condition|;
name|i
operator|++
control|)
block|{
name|init_pair
argument_list|(
name|i
argument_list|,
name|i
operator|%
name|COLORS
argument_list|,
name|i
operator|/
name|COLORS
argument_list|)
expr_stmt|;
name|attron
argument_list|(
operator|(
name|attr_t
operator|)
name|COLOR_PAIR
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
condition|)
name|attron
argument_list|(
operator|(
name|attr_t
operator|)
name|A_BOLD
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|top
operator|+
literal|3
operator|+
operator|(
name|i
operator|/
name|COLORS
operator|)
argument_list|,
operator|(
name|i
operator|%
name|COLORS
operator|+
literal|1
operator|)
operator|*
name|width
argument_list|,
name|hello
argument_list|)
expr_stmt|;
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|COLORS
operator|>
literal|8
operator|)
operator|||
name|base
condition|)
name|Pause
argument_list|()
expr_stmt|;
block|}
name|erase
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|change_color
parameter_list|(
name|int
name|current
parameter_list|,
name|int
name|field
parameter_list|,
name|int
name|value
parameter_list|,
name|int
name|usebase
parameter_list|)
block|{
name|short
name|red
decl_stmt|,
name|green
decl_stmt|,
name|blue
decl_stmt|;
if|if
condition|(
name|usebase
condition|)
name|color_content
argument_list|(
name|current
argument_list|,
operator|&
name|red
argument_list|,
operator|&
name|green
argument_list|,
operator|&
name|blue
argument_list|)
expr_stmt|;
else|else
name|red
operator|=
name|green
operator|=
name|blue
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|field
condition|)
block|{
case|case
literal|0
case|:
name|red
operator|+=
name|value
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|green
operator|+=
name|value
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|blue
operator|+=
name|value
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|init_color
argument_list|(
name|current
argument_list|,
name|red
argument_list|,
name|green
argument_list|,
name|blue
argument_list|)
operator|==
name|ERR
condition|)
name|beep
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|color_edit
parameter_list|(
name|void
parameter_list|)
comment|/* display the color test pattern, without trying to edit colors */
block|{
name|int
name|i
decl_stmt|,
name|this_c
init|=
literal|0
decl_stmt|,
name|value
init|=
literal|0
decl_stmt|,
name|current
init|=
literal|0
decl_stmt|,
name|field
init|=
literal|0
decl_stmt|;
name|int
name|last_c
decl_stmt|;
name|int
name|max_colors
init|=
name|COLORS
operator|>
literal|16
condition|?
literal|16
else|:
name|COLORS
decl_stmt|;
name|refresh
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_colors
condition|;
name|i
operator|++
control|)
name|init_pair
argument_list|(
name|i
argument_list|,
name|COLOR_WHITE
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
name|LINES
operator|-
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Number: %d"
argument_list|,
name|value
argument_list|)
expr_stmt|;
do|do
block|{
name|short
name|red
decl_stmt|,
name|green
decl_stmt|,
name|blue
decl_stmt|;
name|attron
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|0
argument_list|,
literal|20
argument_list|,
literal|"Color RGB Value Editing"
argument_list|)
expr_stmt|;
name|attroff
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_colors
condition|;
name|i
operator|++
control|)
block|{
name|mvprintw
argument_list|(
literal|2
operator|+
name|i
argument_list|,
literal|0
argument_list|,
literal|"%c %-8s:"
argument_list|,
operator|(
name|i
operator|==
name|current
condition|?
literal|'>'
else|:
literal|' '
operator|)
argument_list|,
operator|(
name|i
operator|<
operator|(
name|int
operator|)
name|SIZEOF
argument_list|(
name|color_names
argument_list|)
condition|?
name|color_names
index|[
name|i
index|]
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|attrset
argument_list|(
name|COLOR_PAIR
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"        "
argument_list|)
expr_stmt|;
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
comment|/* 	     * Note: this refresh should *not* be necessary!  It works around 	     * a bug in attribute handling that apparently causes the A_NORMAL 	     * attribute sets to interfere with the actual emission of the 	     * color setting somehow.  This needs to be fixed. 	     */
name|refresh
argument_list|()
expr_stmt|;
name|color_content
argument_list|(
name|i
argument_list|,
operator|&
name|red
argument_list|,
operator|&
name|green
argument_list|,
operator|&
name|blue
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"   R = "
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|==
name|i
operator|&&
name|field
operator|==
literal|0
condition|)
name|attron
argument_list|(
name|A_STANDOUT
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"%04d"
argument_list|,
name|red
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|==
name|i
operator|&&
name|field
operator|==
literal|0
condition|)
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|", G = "
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|==
name|i
operator|&&
name|field
operator|==
literal|1
condition|)
name|attron
argument_list|(
name|A_STANDOUT
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"%04d"
argument_list|,
name|green
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|==
name|i
operator|&&
name|field
operator|==
literal|1
condition|)
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|", B = "
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|==
name|i
operator|&&
name|field
operator|==
literal|2
condition|)
name|attron
argument_list|(
name|A_STANDOUT
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"%04d"
argument_list|,
name|blue
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|==
name|i
operator|&&
name|field
operator|==
literal|2
condition|)
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
name|mvaddstr
argument_list|(
name|max_colors
operator|+
literal|3
argument_list|,
literal|0
argument_list|,
literal|"Use up/down to select a color, left/right to change fields."
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|max_colors
operator|+
literal|4
argument_list|,
literal|0
argument_list|,
literal|"Modify field by typing nnn=, nnn-, or nnn+.  ? for help."
argument_list|)
expr_stmt|;
name|move
argument_list|(
literal|2
operator|+
name|current
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|last_c
operator|=
name|this_c
expr_stmt|;
name|this_c
operator|=
name|Getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|this_c
argument_list|)
operator|&&
operator|!
name|isdigit
argument_list|(
name|last_c
argument_list|)
condition|)
name|value
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|this_c
condition|)
block|{
case|case
name|KEY_UP
case|:
name|current
operator|=
operator|(
name|current
operator|==
literal|0
condition|?
operator|(
name|max_colors
operator|-
literal|1
operator|)
else|:
name|current
operator|-
literal|1
operator|)
expr_stmt|;
break|break;
case|case
name|KEY_DOWN
case|:
name|current
operator|=
operator|(
name|current
operator|==
operator|(
name|max_colors
operator|-
literal|1
operator|)
condition|?
literal|0
else|:
name|current
operator|+
literal|1
operator|)
expr_stmt|;
break|break;
case|case
name|KEY_RIGHT
case|:
name|field
operator|=
operator|(
name|field
operator|==
literal|2
condition|?
literal|0
else|:
name|field
operator|+
literal|1
operator|)
expr_stmt|;
break|break;
case|case
name|KEY_LEFT
case|:
name|field
operator|=
operator|(
name|field
operator|==
literal|0
condition|?
literal|2
else|:
name|field
operator|-
literal|1
operator|)
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|value
operator|=
name|value
operator|*
literal|10
operator|+
operator|(
name|this_c
operator|-
literal|'0'
operator|)
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|change_color
argument_list|(
name|current
argument_list|,
name|field
argument_list|,
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|change_color
argument_list|(
name|current
argument_list|,
name|field
argument_list|,
operator|-
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'='
case|:
name|change_color
argument_list|(
name|current
argument_list|,
name|field
argument_list|,
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|erase
argument_list|()
expr_stmt|;
name|P
argument_list|(
literal|"                      RGB Value Editing Help"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"You are in the RGB value editor.  Use the arrow keys to select one of"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"the fields in one of the RGB triples of the current colors; the one"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"currently selected will be reverse-video highlighted."
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"To change a field, enter the digits of the new value; they are echoed"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"as entered.  Finish by typing `='.  The change will take effect instantly."
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"To increment or decrement a value, use the same procedure, but finish"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"with a `+' or `-'."
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"To quit, do `x' or 'q'"
argument_list|)
expr_stmt|;
name|Pause
argument_list|()
expr_stmt|;
name|erase
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'q'
case|:
break|break;
default|default:
name|beep
argument_list|()
expr_stmt|;
break|break;
block|}
name|mvprintw
argument_list|(
name|LINES
operator|-
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Number: %d"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|this_c
operator|!=
literal|'x'
operator|&&
name|this_c
operator|!=
literal|'q'
condition|)
do|;
name|erase
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  *  * Soft-key label test  *  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|slk_test
parameter_list|(
name|void
parameter_list|)
comment|/* exercise the soft keys */
block|{
name|int
name|c
decl_stmt|,
name|fmt
init|=
literal|1
decl_stmt|;
name|char
name|buf
index|[
literal|9
index|]
decl_stmt|;
name|c
operator|=
name|CTRL
argument_list|(
literal|'l'
argument_list|)
expr_stmt|;
do|do
block|{
name|move
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|CTRL
argument_list|(
literal|'l'
argument_list|)
case|:
name|erase
argument_list|()
expr_stmt|;
name|attron
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|0
argument_list|,
literal|20
argument_list|,
literal|"Soft Key Exerciser"
argument_list|)
expr_stmt|;
name|attroff
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|move
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"Available commands are:"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"^L         -- refresh screen"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"a          -- activate or restore soft keys"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"d          -- disable soft keys"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"c          -- set centered format for labels"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"l          -- set left-justified format for labels"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"r          -- set right-justified format for labels"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"[12345678] -- set label; labels are numbered 1 through 8"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"e          -- erase stdscr (should not erase labels)"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"s          -- test scrolling of shortened screen"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"x, q       -- return to main menu"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"Note: if activating the soft keys causes your terminal to"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"scroll up one line, your terminal auto-scrolls when anything"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"is written to the last screen position.  The ncurses code"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"does not yet handle this gracefully."
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
comment|/* fall through */
case|case
literal|'a'
case|:
name|slk_restore
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|wclear
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|mvprintw
argument_list|(
literal|20
argument_list|,
literal|0
argument_list|,
literal|"Press Q to stop the scrolling-test: "
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|Getchar
argument_list|()
operator|)
operator|!=
literal|'Q'
operator|&&
operator|(
name|c
operator|!=
name|ERR
operator|)
condition|)
name|addch
argument_list|(
operator|(
name|chtype
operator|)
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|slk_clear
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|fmt
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|fmt
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|fmt
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
operator|(
name|void
operator|)
name|mvaddstr
argument_list|(
literal|20
argument_list|,
literal|0
argument_list|,
literal|"Please enter the label value: "
argument_list|)
expr_stmt|;
name|echo
argument_list|()
expr_stmt|;
name|wgetnstr
argument_list|(
name|stdscr
argument_list|,
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|noecho
argument_list|()
expr_stmt|;
name|slk_set
argument_list|(
operator|(
name|c
operator|-
literal|'0'
operator|)
argument_list|,
name|buf
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|slk_refresh
argument_list|()
expr_stmt|;
name|move
argument_list|(
literal|20
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'q'
case|:
goto|goto
name|done
goto|;
default|default:
name|beep
argument_list|()
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|c
operator|=
name|Getchar
argument_list|()
operator|)
operator|!=
name|EOF
condition|)
do|;
name|done
label|:
name|erase
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  *  * Alternate character-set stuff  *  ****************************************************************************/
end_comment

begin_comment
comment|/* ISO 6429:  codes 0x80 to 0x9f may be control characters that cause the  * terminal to perform functions.  The remaining codes can be graphic.  */
end_comment

begin_function
specifier|static
name|void
name|show_upper_chars
parameter_list|(
name|int
name|first
parameter_list|)
block|{
name|bool
name|C1
init|=
operator|(
name|first
operator|==
literal|128
operator|)
decl_stmt|;
name|int
name|code
decl_stmt|;
name|int
name|last
init|=
name|first
operator|+
literal|31
decl_stmt|;
name|int
name|reply
decl_stmt|;
name|erase
argument_list|()
expr_stmt|;
name|attron
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
literal|0
argument_list|,
literal|20
argument_list|,
literal|"Display of %s Character Codes %d to %d"
argument_list|,
name|C1
condition|?
literal|"C1"
else|:
literal|"GR"
argument_list|,
name|first
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|attroff
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
for|for
control|(
name|code
operator|=
name|first
init|;
name|code
operator|<=
name|last
condition|;
name|code
operator|++
control|)
block|{
name|int
name|row
init|=
literal|4
operator|+
operator|(
operator|(
name|code
operator|-
name|first
operator|)
operator|%
literal|16
operator|)
decl_stmt|;
name|int
name|col
init|=
operator|(
operator|(
name|code
operator|-
name|first
operator|)
operator|/
literal|16
operator|)
operator|*
name|COLS
operator|/
literal|2
decl_stmt|;
name|char
name|tmp
index|[
literal|80
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%3d (0x%x)"
argument_list|,
name|code
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
name|row
argument_list|,
name|col
argument_list|,
literal|"%*s: "
argument_list|,
name|COLS
operator|/
literal|4
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|C1
condition|)
name|nodelay
argument_list|(
name|stdscr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|echochar
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|C1
condition|)
block|{
comment|/* (yes, this _is_ crude) */
while|while
condition|(
operator|(
name|reply
operator|=
name|Getchar
argument_list|()
operator|)
operator|!=
name|ERR
condition|)
block|{
name|addch
argument_list|(
name|reply
argument_list|)
expr_stmt|;
name|napms
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|nodelay
argument_list|(
name|stdscr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|show_1_acs
parameter_list|(
name|int
name|n
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|chtype
name|code
parameter_list|)
block|{
specifier|const
name|int
name|height
init|=
literal|16
decl_stmt|;
name|int
name|row
init|=
literal|4
operator|+
operator|(
name|n
operator|%
name|height
operator|)
decl_stmt|;
name|int
name|col
init|=
operator|(
name|n
operator|/
name|height
operator|)
operator|*
name|COLS
operator|/
literal|2
decl_stmt|;
name|mvprintw
argument_list|(
name|row
argument_list|,
name|col
argument_list|,
literal|"%*s : "
argument_list|,
name|COLS
operator|/
literal|4
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|code
argument_list|)
expr_stmt|;
return|return
name|n
operator|+
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_acs_chars
parameter_list|(
name|void
parameter_list|)
comment|/* display the ACS character set */
block|{
name|int
name|n
decl_stmt|;
define|#
directive|define
name|BOTH
parameter_list|(
name|name
parameter_list|)
value|#name, name
name|erase
argument_list|()
expr_stmt|;
name|attron
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|0
argument_list|,
literal|20
argument_list|,
literal|"Display of the ACS Character Set"
argument_list|)
expr_stmt|;
name|attroff
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
literal|0
argument_list|,
name|BOTH
argument_list|(
name|ACS_ULCORNER
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|BOTH
argument_list|(
name|ACS_LLCORNER
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|BOTH
argument_list|(
name|ACS_URCORNER
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|BOTH
argument_list|(
name|ACS_LRCORNER
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|BOTH
argument_list|(
name|ACS_RTEE
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|BOTH
argument_list|(
name|ACS_LTEE
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|BOTH
argument_list|(
name|ACS_BTEE
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|BOTH
argument_list|(
name|ACS_TTEE
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|BOTH
argument_list|(
name|ACS_HLINE
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|BOTH
argument_list|(
name|ACS_VLINE
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|BOTH
argument_list|(
name|ACS_PLUS
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|BOTH
argument_list|(
name|ACS_S1
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|BOTH
argument_list|(
name|ACS_S9
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|BOTH
argument_list|(
name|ACS_DIAMOND
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|BOTH
argument_list|(
name|ACS_CKBOARD
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|BOTH
argument_list|(
name|ACS_DEGREE
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|BOTH
argument_list|(
name|ACS_PLMINUS
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|BOTH
argument_list|(
name|ACS_BULLET
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|BOTH
argument_list|(
name|ACS_LARROW
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|BOTH
argument_list|(
name|ACS_RARROW
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|BOTH
argument_list|(
name|ACS_DARROW
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|BOTH
argument_list|(
name|ACS_UARROW
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|BOTH
argument_list|(
name|ACS_BOARD
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|BOTH
argument_list|(
name|ACS_LANTERN
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|BOTH
argument_list|(
name|ACS_BLOCK
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|BOTH
argument_list|(
name|ACS_S3
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|BOTH
argument_list|(
name|ACS_S7
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|BOTH
argument_list|(
name|ACS_LEQUAL
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|BOTH
argument_list|(
name|ACS_GEQUAL
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|BOTH
argument_list|(
name|ACS_PI
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|BOTH
argument_list|(
name|ACS_NEQUAL
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|show_1_acs
argument_list|(
name|n
argument_list|,
name|BOTH
argument_list|(
name|ACS_STERLING
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|acs_display
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
init|=
literal|'a'
decl_stmt|;
do|do
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|show_acs_chars
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
name|show_upper_chars
argument_list|(
operator|(
name|c
operator|-
literal|'0'
operator|)
operator|*
literal|32
operator|+
literal|128
argument_list|)
expr_stmt|;
break|break;
block|}
name|mvprintw
argument_list|(
name|LINES
operator|-
literal|3
argument_list|,
literal|0
argument_list|,
literal|"Note: ANSI terminals may not display C1 characters."
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
name|LINES
operator|-
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Select: a=ACS, 0=C1, 1,2,3=GR characters, q=quit"
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|c
operator|=
name|Getchar
argument_list|()
operator|)
operator|!=
literal|'x'
operator|&&
name|c
operator|!=
literal|'q'
condition|)
do|;
name|Pause
argument_list|()
expr_stmt|;
name|erase
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Graphic-rendition test (adapted from vttest)  */
end_comment

begin_function
specifier|static
name|void
name|test_sgr_attributes
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|pass
decl_stmt|;
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
literal|2
condition|;
name|pass
operator|++
control|)
block|{
name|int
name|normal
init|=
operator|(
operator|(
name|pass
operator|==
literal|0
condition|?
name|A_NORMAL
else|:
name|A_REVERSE
operator|)
operator|)
operator||
name|BLANK
decl_stmt|;
comment|/* Use non-default colors if possible to exercise bce a little */
if|if
condition|(
name|has_colors
argument_list|()
condition|)
block|{
name|init_pair
argument_list|(
literal|1
argument_list|,
name|COLOR_WHITE
argument_list|,
name|COLOR_BLUE
argument_list|)
expr_stmt|;
name|normal
operator||=
name|COLOR_PAIR
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|bkgdset
argument_list|(
name|normal
argument_list|)
expr_stmt|;
name|erase
argument_list|()
expr_stmt|;
name|mvprintw
argument_list|(
literal|1
argument_list|,
literal|20
argument_list|,
literal|"Graphic rendition test pattern:"
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
literal|4
argument_list|,
literal|1
argument_list|,
literal|"vanilla"
argument_list|)
expr_stmt|;
define|#
directive|define
name|set_sgr
parameter_list|(
name|mask
parameter_list|)
value|bkgdset((normal^(mask)));
name|set_sgr
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
literal|4
argument_list|,
literal|40
argument_list|,
literal|"bold"
argument_list|)
expr_stmt|;
name|set_sgr
argument_list|(
name|A_UNDERLINE
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
literal|6
argument_list|,
literal|6
argument_list|,
literal|"underline"
argument_list|)
expr_stmt|;
name|set_sgr
argument_list|(
name|A_BOLD
operator||
name|A_UNDERLINE
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
literal|6
argument_list|,
literal|45
argument_list|,
literal|"bold underline"
argument_list|)
expr_stmt|;
name|set_sgr
argument_list|(
name|A_BLINK
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
literal|8
argument_list|,
literal|1
argument_list|,
literal|"blink"
argument_list|)
expr_stmt|;
name|set_sgr
argument_list|(
name|A_BLINK
operator||
name|A_BOLD
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
literal|8
argument_list|,
literal|40
argument_list|,
literal|"bold blink"
argument_list|)
expr_stmt|;
name|set_sgr
argument_list|(
name|A_UNDERLINE
operator||
name|A_BLINK
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
literal|10
argument_list|,
literal|6
argument_list|,
literal|"underline blink"
argument_list|)
expr_stmt|;
name|set_sgr
argument_list|(
name|A_BOLD
operator||
name|A_UNDERLINE
operator||
name|A_BLINK
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
literal|10
argument_list|,
literal|45
argument_list|,
literal|"bold underline blink"
argument_list|)
expr_stmt|;
name|set_sgr
argument_list|(
name|A_REVERSE
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
literal|12
argument_list|,
literal|1
argument_list|,
literal|"negative"
argument_list|)
expr_stmt|;
name|set_sgr
argument_list|(
name|A_BOLD
operator||
name|A_REVERSE
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
literal|12
argument_list|,
literal|40
argument_list|,
literal|"bold negative"
argument_list|)
expr_stmt|;
name|set_sgr
argument_list|(
name|A_UNDERLINE
operator||
name|A_REVERSE
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
literal|14
argument_list|,
literal|6
argument_list|,
literal|"underline negative"
argument_list|)
expr_stmt|;
name|set_sgr
argument_list|(
name|A_BOLD
operator||
name|A_UNDERLINE
operator||
name|A_REVERSE
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
literal|14
argument_list|,
literal|45
argument_list|,
literal|"bold underline negative"
argument_list|)
expr_stmt|;
name|set_sgr
argument_list|(
name|A_BLINK
operator||
name|A_REVERSE
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
literal|16
argument_list|,
literal|1
argument_list|,
literal|"blink negative"
argument_list|)
expr_stmt|;
name|set_sgr
argument_list|(
name|A_BOLD
operator||
name|A_BLINK
operator||
name|A_REVERSE
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
literal|16
argument_list|,
literal|40
argument_list|,
literal|"bold blink negative"
argument_list|)
expr_stmt|;
name|set_sgr
argument_list|(
name|A_UNDERLINE
operator||
name|A_BLINK
operator||
name|A_REVERSE
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
literal|18
argument_list|,
literal|6
argument_list|,
literal|"underline blink negative"
argument_list|)
expr_stmt|;
name|set_sgr
argument_list|(
name|A_BOLD
operator||
name|A_UNDERLINE
operator||
name|A_BLINK
operator||
name|A_REVERSE
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
literal|18
argument_list|,
literal|45
argument_list|,
literal|"bold underline blink negative"
argument_list|)
expr_stmt|;
name|bkgdset
argument_list|(
name|normal
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
name|LINES
operator|-
literal|2
argument_list|,
literal|1
argument_list|,
literal|"%s background. "
argument_list|,
name|pass
operator|==
literal|0
condition|?
literal|"Dark"
else|:
literal|"Light"
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
name|Pause
argument_list|()
expr_stmt|;
block|}
name|bkgdset
argument_list|(
name|A_NORMAL
operator||
name|BLANK
argument_list|)
expr_stmt|;
name|erase
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  *  * Windows and scrolling tester.  *  ****************************************************************************/
end_comment

begin_define
define|#
directive|define
name|BOTLINES
value|4
end_define

begin_comment
comment|/* number of line stolen from screen bottom */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
block|}
name|pair
typedef|;
end_typedef

begin_define
define|#
directive|define
name|FRAME
value|struct frame
end_define

begin_macro
name|FRAME
end_macro

begin_block
block|{
name|FRAME
modifier|*
name|next
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|bool
name|do_scroll
decl_stmt|;
name|bool
name|do_keypad
decl_stmt|;
name|WINDOW
modifier|*
name|wind
decl_stmt|;
block|}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* We need to know if these flags are actually set, so don't look in FRAME.  * These names are known to work with SVr4 curses as well as ncurses.  */
end_comment

begin_function
specifier|static
name|bool
name|HaveKeypad
parameter_list|(
name|FRAME
modifier|*
name|curp
parameter_list|)
block|{
name|WINDOW
modifier|*
name|win
init|=
operator|(
name|curp
condition|?
name|curp
operator|->
name|wind
else|:
name|stdscr
operator|)
decl_stmt|;
return|return
name|win
operator|->
name|_use_keypad
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|HaveScroll
parameter_list|(
name|FRAME
modifier|*
name|curp
parameter_list|)
block|{
name|WINDOW
modifier|*
name|win
init|=
operator|(
name|curp
condition|?
name|curp
operator|->
name|wind
else|:
name|stdscr
operator|)
decl_stmt|;
return|return
name|win
operator|->
name|_scroll
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|newwin_legend
parameter_list|(
name|FRAME
modifier|*
name|curp
parameter_list|)
block|{
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
name|int
name|code
decl_stmt|;
block|}
name|legend
index|[]
init|=
block|{
block|{
literal|"^C = create window"
block|,
literal|0
block|}
block|,
block|{
literal|"^N = next window"
block|,
literal|0
block|}
block|,
block|{
literal|"^P = previous window"
block|,
literal|0
block|}
block|,
block|{
literal|"^F = scroll forward"
block|,
literal|0
block|}
block|,
block|{
literal|"^B = scroll backward"
block|,
literal|0
block|}
block|,
block|{
literal|"^K = keypad(%s)"
block|,
literal|1
block|}
block|,
block|{
literal|"^S = scrollok(%s)"
block|,
literal|2
block|}
block|,
block|{
literal|"^W = save window to file"
block|,
literal|0
block|}
block|,
block|{
literal|"^R = restore window"
block|,
literal|0
block|}
block|,
if|#
directive|if
name|HAVE_WRESIZE
block|{
literal|"^X = resize"
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
literal|"^Q%s = exit"
block|,
literal|3
block|}
block|}
struct|;
name|size_t
name|n
decl_stmt|;
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
name|bool
name|do_keypad
init|=
name|HaveKeypad
argument_list|(
name|curp
argument_list|)
decl_stmt|;
name|bool
name|do_scroll
init|=
name|HaveScroll
argument_list|(
name|curp
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|move
argument_list|(
name|LINES
operator|-
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|SIZEOF
argument_list|(
name|legend
argument_list|)
condition|;
name|n
operator|++
control|)
block|{
switch|switch
condition|(
name|legend
index|[
name|n
index|]
operator|.
name|code
condition|)
block|{
default|default:
name|strcpy
argument_list|(
name|buf
argument_list|,
name|legend
index|[
name|n
index|]
operator|.
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
name|legend
index|[
name|n
index|]
operator|.
name|msg
argument_list|,
name|do_keypad
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
name|legend
index|[
name|n
index|]
operator|.
name|msg
argument_list|,
name|do_scroll
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
name|legend
index|[
name|n
index|]
operator|.
name|msg
argument_list|,
name|do_keypad
condition|?
literal|"/ESC"
else|:
literal|""
argument_list|)
expr_stmt|;
break|break;
block|}
name|getyx
argument_list|(
name|stdscr
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
operator|(
name|COLS
operator|<
operator|(
name|x
operator|+
literal|3
operator|+
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|buf
argument_list|)
operator|)
operator|)
condition|?
literal|"\n"
else|:
operator|(
name|n
condition|?
literal|", "
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|clrtoeol
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|transient
parameter_list|(
name|FRAME
modifier|*
name|curp
parameter_list|,
name|NCURSES_CONST
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|newwin_legend
argument_list|(
name|curp
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
condition|)
block|{
name|mvaddstr
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|napms
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"%s characters are echoed, window should %sscroll."
argument_list|,
name|HaveKeypad
argument_list|(
name|curp
argument_list|)
condition|?
literal|"Non-arrow"
else|:
literal|"All other"
argument_list|,
name|HaveScroll
argument_list|(
name|curp
argument_list|)
condition|?
literal|""
else|:
literal|"not "
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|newwin_report
parameter_list|(
name|FRAME
modifier|*
name|curp
parameter_list|)
comment|/* report on the cursor's current position, then restore it */
block|{
name|WINDOW
modifier|*
name|win
init|=
operator|(
name|curp
operator|!=
literal|0
operator|)
condition|?
name|curp
operator|->
name|wind
else|:
name|stdscr
decl_stmt|;
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
if|if
condition|(
name|win
operator|!=
name|stdscr
condition|)
name|transient
argument_list|(
name|curp
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|getyx
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
name|COLS
operator|-
literal|17
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"Y = %2d X = %2d"
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|win
operator|!=
name|stdscr
condition|)
name|refresh
argument_list|()
expr_stmt|;
else|else
name|wmove
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|pair
modifier|*
name|selectcell
parameter_list|(
name|int
name|uli
parameter_list|,
name|int
name|ulj
parameter_list|,
name|int
name|lri
parameter_list|,
name|int
name|lrj
parameter_list|)
comment|/* arrows keys move cursor, return location at current on non-arrow key */
block|{
specifier|static
name|pair
name|res
decl_stmt|;
comment|/* result cell */
name|int
name|si
init|=
name|lri
operator|-
name|uli
operator|+
literal|1
decl_stmt|;
comment|/* depth of the select area */
name|int
name|sj
init|=
name|lrj
operator|-
name|ulj
operator|+
literal|1
decl_stmt|;
comment|/* width of the select area */
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
comment|/* offsets into the select area */
name|res
operator|.
name|y
operator|=
name|uli
expr_stmt|;
name|res
operator|.
name|x
operator|=
name|ulj
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|move
argument_list|(
name|uli
operator|+
name|i
argument_list|,
name|ulj
operator|+
name|j
argument_list|)
expr_stmt|;
name|newwin_report
argument_list|(
operator|(
name|FRAME
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|Getchar
argument_list|()
condition|)
block|{
case|case
name|KEY_UP
case|:
name|i
operator|+=
name|si
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|KEY_DOWN
case|:
name|i
operator|++
expr_stmt|;
break|break;
case|case
name|KEY_LEFT
case|:
name|j
operator|+=
name|sj
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|KEY_RIGHT
case|:
name|j
operator|++
expr_stmt|;
break|break;
case|case
name|QUIT
case|:
case|case
name|ESCAPE
case|:
return|return
operator|(
operator|(
name|pair
operator|*
operator|)
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|NCURSES_MOUSE_VERSION
case|case
name|KEY_MOUSE
case|:
block|{
name|MEVENT
name|event
decl_stmt|;
name|getmouse
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|.
name|y
operator|>
name|uli
operator|&&
name|event
operator|.
name|x
operator|>
name|ulj
condition|)
block|{
name|i
operator|=
name|event
operator|.
name|y
operator|-
name|uli
expr_stmt|;
name|j
operator|=
name|event
operator|.
name|x
operator|-
name|ulj
expr_stmt|;
block|}
else|else
block|{
name|beep
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
comment|/* FALLTHRU */
endif|#
directive|endif
default|default:
name|res
operator|.
name|y
operator|=
name|uli
operator|+
name|i
expr_stmt|;
name|res
operator|.
name|x
operator|=
name|ulj
operator|+
name|j
expr_stmt|;
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
name|i
operator|%=
name|si
expr_stmt|;
name|j
operator|%=
name|sj
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|outerbox
parameter_list|(
name|pair
name|ul
parameter_list|,
name|pair
name|lr
parameter_list|,
name|bool
name|onoff
parameter_list|)
comment|/* draw or erase a box *outside* the given pair of corners */
block|{
name|mvaddch
argument_list|(
name|ul
operator|.
name|y
operator|-
literal|1
argument_list|,
name|lr
operator|.
name|x
operator|-
literal|1
argument_list|,
name|onoff
condition|?
name|ACS_ULCORNER
else|:
literal|' '
argument_list|)
expr_stmt|;
name|mvaddch
argument_list|(
name|ul
operator|.
name|y
operator|-
literal|1
argument_list|,
name|lr
operator|.
name|x
operator|+
literal|1
argument_list|,
name|onoff
condition|?
name|ACS_URCORNER
else|:
literal|' '
argument_list|)
expr_stmt|;
name|mvaddch
argument_list|(
name|lr
operator|.
name|y
operator|+
literal|1
argument_list|,
name|lr
operator|.
name|x
operator|+
literal|1
argument_list|,
name|onoff
condition|?
name|ACS_LRCORNER
else|:
literal|' '
argument_list|)
expr_stmt|;
name|mvaddch
argument_list|(
name|lr
operator|.
name|y
operator|+
literal|1
argument_list|,
name|ul
operator|.
name|x
operator|-
literal|1
argument_list|,
name|onoff
condition|?
name|ACS_LLCORNER
else|:
literal|' '
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|ul
operator|.
name|y
operator|-
literal|1
argument_list|,
name|ul
operator|.
name|x
argument_list|)
expr_stmt|;
name|hline
argument_list|(
name|onoff
condition|?
name|ACS_HLINE
else|:
literal|' '
argument_list|,
name|lr
operator|.
name|x
operator|-
name|ul
operator|.
name|x
operator|+
literal|1
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|ul
operator|.
name|y
argument_list|,
name|ul
operator|.
name|x
operator|-
literal|1
argument_list|)
expr_stmt|;
name|vline
argument_list|(
name|onoff
condition|?
name|ACS_VLINE
else|:
literal|' '
argument_list|,
name|lr
operator|.
name|y
operator|-
name|ul
operator|.
name|y
operator|+
literal|1
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|lr
operator|.
name|y
operator|+
literal|1
argument_list|,
name|ul
operator|.
name|x
argument_list|)
expr_stmt|;
name|hline
argument_list|(
name|onoff
condition|?
name|ACS_HLINE
else|:
literal|' '
argument_list|,
name|lr
operator|.
name|x
operator|-
name|ul
operator|.
name|x
operator|+
literal|1
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|ul
operator|.
name|y
argument_list|,
name|lr
operator|.
name|x
operator|+
literal|1
argument_list|)
expr_stmt|;
name|vline
argument_list|(
name|onoff
condition|?
name|ACS_VLINE
else|:
literal|' '
argument_list|,
name|lr
operator|.
name|y
operator|-
name|ul
operator|.
name|y
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|WINDOW
modifier|*
name|getwindow
parameter_list|(
name|void
parameter_list|)
comment|/* Ask user for a window definition */
block|{
name|WINDOW
modifier|*
name|rwindow
decl_stmt|;
name|pair
name|ul
decl_stmt|,
name|lr
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|move
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
name|addstr
argument_list|(
literal|"Use arrows to move cursor, anything else to mark corner 1"
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|=
name|selectcell
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
name|LINES
operator|-
name|BOTLINES
operator|-
literal|2
argument_list|,
name|COLS
operator|-
literal|2
argument_list|)
operator|)
operator|==
operator|(
name|pair
operator|*
operator|)
literal|0
condition|)
return|return
operator|(
operator|(
name|WINDOW
operator|*
operator|)
literal|0
operator|)
return|;
name|memcpy
argument_list|(
operator|&
name|ul
argument_list|,
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|pair
argument_list|)
argument_list|)
expr_stmt|;
name|mvaddch
argument_list|(
name|ul
operator|.
name|y
operator|-
literal|1
argument_list|,
name|ul
operator|.
name|x
operator|-
literal|1
argument_list|,
name|ACS_ULCORNER
argument_list|)
expr_stmt|;
name|move
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
name|addstr
argument_list|(
literal|"Use arrows to move cursor, anything else to mark corner 2"
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|=
name|selectcell
argument_list|(
name|ul
operator|.
name|y
argument_list|,
name|ul
operator|.
name|x
argument_list|,
name|LINES
operator|-
name|BOTLINES
operator|-
literal|2
argument_list|,
name|COLS
operator|-
literal|2
argument_list|)
operator|)
operator|==
operator|(
name|pair
operator|*
operator|)
literal|0
condition|)
return|return
operator|(
operator|(
name|WINDOW
operator|*
operator|)
literal|0
operator|)
return|;
name|memcpy
argument_list|(
operator|&
name|lr
argument_list|,
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|pair
argument_list|)
argument_list|)
expr_stmt|;
name|rwindow
operator|=
name|subwin
argument_list|(
name|stdscr
argument_list|,
name|lr
operator|.
name|y
operator|-
name|ul
operator|.
name|y
operator|+
literal|1
argument_list|,
name|lr
operator|.
name|x
operator|-
name|ul
operator|.
name|x
operator|+
literal|1
argument_list|,
name|ul
operator|.
name|y
argument_list|,
name|ul
operator|.
name|x
argument_list|)
expr_stmt|;
name|outerbox
argument_list|(
name|ul
argument_list|,
name|lr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|wrefresh
argument_list|(
name|rwindow
argument_list|)
expr_stmt|;
name|move
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
return|return
operator|(
name|rwindow
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|newwin_move
parameter_list|(
name|FRAME
modifier|*
name|curp
parameter_list|,
name|int
name|dy
parameter_list|,
name|int
name|dx
parameter_list|)
block|{
name|WINDOW
modifier|*
name|win
init|=
operator|(
name|curp
operator|!=
literal|0
operator|)
condition|?
name|curp
operator|->
name|wind
else|:
name|stdscr
decl_stmt|;
name|int
name|cur_y
decl_stmt|,
name|cur_x
decl_stmt|;
name|int
name|max_y
decl_stmt|,
name|max_x
decl_stmt|;
name|getyx
argument_list|(
name|win
argument_list|,
name|cur_y
argument_list|,
name|cur_x
argument_list|)
expr_stmt|;
name|getmaxyx
argument_list|(
name|win
argument_list|,
name|max_y
argument_list|,
name|max_x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cur_x
operator|+=
name|dx
operator|)
operator|<
literal|0
condition|)
name|cur_x
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|cur_x
operator|>=
name|max_x
condition|)
name|cur_x
operator|=
name|max_x
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|cur_y
operator|+=
name|dy
operator|)
operator|<
literal|0
condition|)
name|cur_y
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|cur_y
operator|>=
name|max_y
condition|)
name|cur_y
operator|=
name|max_y
operator|-
literal|1
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
name|cur_y
argument_list|,
name|cur_x
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|FRAME
modifier|*
name|delete_framed
parameter_list|(
name|FRAME
modifier|*
name|fp
parameter_list|,
name|bool
name|showit
parameter_list|)
block|{
name|FRAME
modifier|*
name|np
decl_stmt|;
name|fp
operator|->
name|last
operator|->
name|next
operator|=
name|fp
operator|->
name|next
expr_stmt|;
name|fp
operator|->
name|next
operator|->
name|last
operator|=
name|fp
operator|->
name|last
expr_stmt|;
if|if
condition|(
name|showit
condition|)
block|{
name|werase
argument_list|(
name|fp
operator|->
name|wind
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|fp
operator|->
name|wind
argument_list|)
expr_stmt|;
block|}
name|delwin
argument_list|(
name|fp
operator|->
name|wind
argument_list|)
expr_stmt|;
name|np
operator|=
operator|(
name|fp
operator|==
name|fp
operator|->
name|next
operator|)
condition|?
literal|0
else|:
name|fp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|np
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|acs_and_scroll
parameter_list|(
name|void
parameter_list|)
comment|/* Demonstrate windows */
block|{
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|FRAME
modifier|*
name|current
init|=
operator|(
name|FRAME
operator|*
operator|)
literal|0
decl_stmt|,
modifier|*
name|neww
decl_stmt|;
name|WINDOW
modifier|*
name|usescr
init|=
name|stdscr
decl_stmt|;
define|#
directive|define
name|DUMPFILE
value|"screendump"
ifdef|#
directive|ifdef
name|NCURSES_MOUSE_VERSION
name|mousemask
argument_list|(
name|BUTTON1_CLICKED
argument_list|,
operator|(
name|mmask_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|c
operator|=
name|CTRL
argument_list|(
literal|'C'
argument_list|)
expr_stmt|;
name|raw
argument_list|()
expr_stmt|;
do|do
block|{
name|transient
argument_list|(
operator|(
name|FRAME
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|CTRL
argument_list|(
literal|'C'
argument_list|)
case|:
name|neww
operator|=
operator|(
name|FRAME
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|FRAME
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|neww
operator|->
name|wind
operator|=
name|getwindow
argument_list|()
operator|)
operator|==
operator|(
name|WINDOW
operator|*
operator|)
literal|0
condition|)
goto|goto
name|breakout
goto|;
if|if
condition|(
name|current
operator|==
literal|0
condition|)
block|{
comment|/* First element,  */
name|neww
operator|->
name|next
operator|=
name|neww
expr_stmt|;
comment|/*   so point it at itself */
name|neww
operator|->
name|last
operator|=
name|neww
expr_stmt|;
block|}
else|else
block|{
name|neww
operator|->
name|next
operator|=
name|current
operator|->
name|next
expr_stmt|;
name|neww
operator|->
name|last
operator|=
name|current
expr_stmt|;
name|neww
operator|->
name|last
operator|->
name|next
operator|=
name|neww
expr_stmt|;
name|neww
operator|->
name|next
operator|->
name|last
operator|=
name|neww
expr_stmt|;
block|}
name|current
operator|=
name|neww
expr_stmt|;
comment|/* SVr4 curses sets the keypad on all newly-created windows to 	     * false.  Someone reported that PDCurses makes new windows inherit 	     * this flag.  Remove the following 'keypad()' call to test this 	     */
name|keypad
argument_list|(
name|current
operator|->
name|wind
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|current
operator|->
name|do_keypad
operator|=
name|HaveKeypad
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|current
operator|->
name|do_scroll
operator|=
name|HaveScroll
argument_list|(
name|current
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTRL
argument_list|(
literal|'N'
argument_list|)
case|:
comment|/* go to next window */
if|if
condition|(
name|current
condition|)
name|current
operator|=
name|current
operator|->
name|next
expr_stmt|;
break|break;
case|case
name|CTRL
argument_list|(
literal|'P'
argument_list|)
case|:
comment|/* go to previous window */
if|if
condition|(
name|current
condition|)
name|current
operator|=
name|current
operator|->
name|last
expr_stmt|;
break|break;
case|case
name|CTRL
argument_list|(
literal|'F'
argument_list|)
case|:
comment|/* scroll current window forward */
if|if
condition|(
name|current
condition|)
name|wscrl
argument_list|(
name|current
operator|->
name|wind
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTRL
argument_list|(
literal|'B'
argument_list|)
case|:
comment|/* scroll current window backwards */
if|if
condition|(
name|current
condition|)
name|wscrl
argument_list|(
name|current
operator|->
name|wind
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTRL
argument_list|(
literal|'K'
argument_list|)
case|:
comment|/* toggle keypad mode for current */
if|if
condition|(
name|current
condition|)
block|{
name|current
operator|->
name|do_keypad
operator|=
operator|!
name|current
operator|->
name|do_keypad
expr_stmt|;
name|keypad
argument_list|(
name|current
operator|->
name|wind
argument_list|,
name|current
operator|->
name|do_keypad
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CTRL
argument_list|(
literal|'S'
argument_list|)
case|:
if|if
condition|(
name|current
condition|)
block|{
name|current
operator|->
name|do_scroll
operator|=
operator|!
name|current
operator|->
name|do_scroll
expr_stmt|;
name|scrollok
argument_list|(
name|current
operator|->
name|wind
argument_list|,
name|current
operator|->
name|do_scroll
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CTRL
argument_list|(
literal|'W'
argument_list|)
case|:
comment|/* save and delete window */
if|if
condition|(
name|current
operator|==
name|current
operator|->
name|next
condition|)
break|break;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|DUMPFILE
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
operator|(
name|FILE
operator|*
operator|)
literal|0
condition|)
name|transient
argument_list|(
name|current
argument_list|,
literal|"Can't open screen dump file"
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|putwin
argument_list|(
name|current
operator|->
name|wind
argument_list|,
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|current
operator|=
name|delete_framed
argument_list|(
name|current
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CTRL
argument_list|(
literal|'R'
argument_list|)
case|:
comment|/* restore window */
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|DUMPFILE
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
operator|(
name|FILE
operator|*
operator|)
literal|0
condition|)
name|transient
argument_list|(
name|current
argument_list|,
literal|"Can't open screen dump file"
argument_list|)
expr_stmt|;
else|else
block|{
name|neww
operator|=
operator|(
name|FRAME
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|FRAME
argument_list|)
argument_list|)
expr_stmt|;
name|neww
operator|->
name|next
operator|=
name|current
operator|->
name|next
expr_stmt|;
name|neww
operator|->
name|last
operator|=
name|current
expr_stmt|;
name|neww
operator|->
name|last
operator|->
name|next
operator|=
name|neww
expr_stmt|;
name|neww
operator|->
name|next
operator|->
name|last
operator|=
name|neww
expr_stmt|;
name|neww
operator|->
name|wind
operator|=
name|getwin
argument_list|(
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|neww
operator|->
name|wind
argument_list|)
expr_stmt|;
block|}
break|break;
if|#
directive|if
name|HAVE_WRESIZE
case|case
name|CTRL
argument_list|(
literal|'X'
argument_list|)
case|:
comment|/* resize window */
if|if
condition|(
name|current
condition|)
block|{
name|pair
modifier|*
name|tmp
decl_stmt|,
name|ul
decl_stmt|,
name|lr
decl_stmt|;
name|int
name|mx
decl_stmt|,
name|my
decl_stmt|;
name|move
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
name|addstr
argument_list|(
literal|"Use arrows to move cursor, anything else to mark new corner"
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|getbegyx
argument_list|(
name|current
operator|->
name|wind
argument_list|,
name|ul
operator|.
name|y
argument_list|,
name|ul
operator|.
name|x
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|selectcell
argument_list|(
name|ul
operator|.
name|y
argument_list|,
name|ul
operator|.
name|x
argument_list|,
name|LINES
operator|-
name|BOTLINES
operator|-
literal|2
argument_list|,
name|COLS
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
operator|(
name|pair
operator|*
operator|)
literal|0
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
break|break;
block|}
name|getmaxyx
argument_list|(
name|current
operator|->
name|wind
argument_list|,
name|lr
operator|.
name|y
argument_list|,
name|lr
operator|.
name|x
argument_list|)
expr_stmt|;
name|lr
operator|.
name|y
operator|+=
operator|(
name|ul
operator|.
name|y
operator|-
literal|1
operator|)
expr_stmt|;
name|lr
operator|.
name|x
operator|+=
operator|(
name|ul
operator|.
name|x
operator|-
literal|1
operator|)
expr_stmt|;
name|outerbox
argument_list|(
name|ul
argument_list|,
name|lr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|wnoutrefresh
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
comment|/* strictly cosmetic hack for the test */
name|getmaxyx
argument_list|(
name|current
operator|->
name|wind
argument_list|,
name|my
argument_list|,
name|mx
argument_list|)
expr_stmt|;
if|if
condition|(
name|my
operator|>
name|tmp
operator|->
name|y
operator|-
name|ul
operator|.
name|y
condition|)
block|{
name|getyx
argument_list|(
name|current
operator|->
name|wind
argument_list|,
name|lr
operator|.
name|y
argument_list|,
name|lr
operator|.
name|x
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|current
operator|->
name|wind
argument_list|,
name|tmp
operator|->
name|y
operator|-
name|ul
operator|.
name|y
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wclrtobot
argument_list|(
name|current
operator|->
name|wind
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|current
operator|->
name|wind
argument_list|,
name|lr
operator|.
name|y
argument_list|,
name|lr
operator|.
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mx
operator|>
name|tmp
operator|->
name|x
operator|-
name|ul
operator|.
name|x
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|my
condition|;
name|i
operator|++
control|)
block|{
name|wmove
argument_list|(
name|current
operator|->
name|wind
argument_list|,
name|i
argument_list|,
name|tmp
operator|->
name|x
operator|-
name|ul
operator|.
name|x
operator|+
literal|1
argument_list|)
expr_stmt|;
name|wclrtoeol
argument_list|(
name|current
operator|->
name|wind
argument_list|)
expr_stmt|;
block|}
name|wnoutrefresh
argument_list|(
name|current
operator|->
name|wind
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lr
argument_list|,
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|pair
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wresize
argument_list|(
name|current
operator|->
name|wind
argument_list|,
name|lr
operator|.
name|y
operator|-
name|ul
operator|.
name|y
operator|+
literal|0
argument_list|,
name|lr
operator|.
name|x
operator|-
name|ul
operator|.
name|x
operator|+
literal|0
argument_list|)
expr_stmt|;
name|getbegyx
argument_list|(
name|current
operator|->
name|wind
argument_list|,
name|ul
operator|.
name|y
argument_list|,
name|ul
operator|.
name|x
argument_list|)
expr_stmt|;
name|getmaxyx
argument_list|(
name|current
operator|->
name|wind
argument_list|,
name|lr
operator|.
name|y
argument_list|,
name|lr
operator|.
name|x
argument_list|)
expr_stmt|;
name|lr
operator|.
name|y
operator|+=
operator|(
name|ul
operator|.
name|y
operator|-
literal|1
operator|)
expr_stmt|;
name|lr
operator|.
name|x
operator|+=
operator|(
name|ul
operator|.
name|x
operator|-
literal|1
operator|)
expr_stmt|;
name|outerbox
argument_list|(
name|ul
argument_list|,
name|lr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|wnoutrefresh
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
name|wnoutrefresh
argument_list|(
name|current
operator|->
name|wind
argument_list|)
expr_stmt|;
name|move
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
name|doupdate
argument_list|()
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* HAVE_WRESIZE */
case|case
name|KEY_F
argument_list|(
literal|10
argument_list|)
case|:
comment|/* undocumented --- use this to test area clears */
name|selectcell
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|LINES
operator|-
literal|1
argument_list|,
name|COLS
operator|-
literal|1
argument_list|)
expr_stmt|;
name|clrtobot
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
break|break;
case|case
name|KEY_UP
case|:
name|newwin_move
argument_list|(
name|current
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_DOWN
case|:
name|newwin_move
argument_list|(
name|current
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_LEFT
case|:
name|newwin_move
argument_list|(
name|current
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_RIGHT
case|:
name|newwin_move
argument_list|(
name|current
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_BACKSPACE
case|:
comment|/* FALLTHROUGH */
case|case
name|KEY_DC
case|:
block|{
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
name|getyx
argument_list|(
name|current
operator|->
name|wind
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|x
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|--
name|y
operator|<
literal|0
condition|)
break|break;
name|x
operator|=
name|getmaxx
argument_list|(
name|current
operator|->
name|wind
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
name|mvwdelch
argument_list|(
name|current
operator|->
name|wind
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'\r'
case|:
name|c
operator|=
literal|'\n'
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
if|if
condition|(
name|current
condition|)
name|waddch
argument_list|(
name|current
operator|->
name|wind
argument_list|,
operator|(
name|chtype
operator|)
name|c
argument_list|)
expr_stmt|;
else|else
name|beep
argument_list|()
expr_stmt|;
break|break;
block|}
name|newwin_report
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|usescr
operator|=
operator|(
name|current
condition|?
name|current
operator|->
name|wind
else|:
name|stdscr
operator|)
expr_stmt|;
name|wrefresh
argument_list|(
name|usescr
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|c
operator|=
name|wGetchar
argument_list|(
name|usescr
argument_list|)
operator|)
operator|!=
name|QUIT
operator|&&
operator|!
operator|(
operator|(
name|c
operator|==
name|ESCAPE
operator|)
operator|&&
operator|(
name|usescr
operator|->
name|_use_keypad
operator|)
operator|)
operator|&&
operator|(
name|c
operator|!=
name|ERR
operator|)
condition|)
do|;
name|breakout
label|:
while|while
condition|(
name|current
operator|!=
literal|0
condition|)
name|current
operator|=
name|delete_framed
argument_list|(
name|current
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|scrollok
argument_list|(
name|stdscr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* reset to driver's default */
ifdef|#
directive|ifdef
name|NCURSES_MOUSE_VERSION
name|mousemask
argument_list|(
literal|0
argument_list|,
operator|(
name|mmask_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|noraw
argument_list|()
expr_stmt|;
name|erase
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  *  * Panels tester  *  ****************************************************************************/
end_comment

begin_if
if|#
directive|if
name|USE_LIBPANEL
end_if

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|nap_msec
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|NCURSES_CONST
name|char
modifier|*
name|mod
index|[]
init|=
block|{
literal|"test "
block|,
literal|"TEST "
block|,
literal|"(**) "
block|,
literal|"*()* "
block|,
literal|"<--> "
block|,
literal|"LAST "
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*+------------------------------------------------------------------------- 	wait_a_while(msec) --------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|wait_a_while
parameter_list|(
name|unsigned
name|long
name|msec
name|GCC_UNUSED
parameter_list|)
block|{
if|#
directive|if
name|HAVE_NAPMS
if|if
condition|(
name|nap_msec
operator|==
literal|1
condition|)
name|wGetchar
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
else|else
name|napms
argument_list|(
name|nap_msec
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|nap_msec
operator|==
literal|1
condition|)
name|wGetchar
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|msec
operator|>
literal|1000L
condition|)
name|sleep
argument_list|(
operator|(
name|int
operator|)
name|msec
operator|/
literal|1000L
argument_list|)
expr_stmt|;
else|else
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* end of wait_a_while */
end_comment

begin_comment
comment|/*+------------------------------------------------------------------------- 	saywhat(text) --------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|saywhat
parameter_list|(
name|NCURSES_CONST
name|char
modifier|*
name|text
parameter_list|)
block|{
name|wmove
argument_list|(
name|stdscr
argument_list|,
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wclrtoeol
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
name|waddstr
argument_list|(
name|stdscr
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end of saywhat */
end_comment

begin_comment
comment|/*+------------------------------------------------------------------------- 	mkpanel(rows,cols,tly,tlx) - alloc a win and panel and associate them --------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|PANEL
modifier|*
name|mkpanel
parameter_list|(
name|int
name|color
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|cols
parameter_list|,
name|int
name|tly
parameter_list|,
name|int
name|tlx
parameter_list|)
block|{
name|WINDOW
modifier|*
name|win
decl_stmt|;
name|PANEL
modifier|*
name|pan
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|win
operator|=
name|newwin
argument_list|(
name|rows
argument_list|,
name|cols
argument_list|,
name|tly
argument_list|,
name|tlx
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pan
operator|=
name|new_panel
argument_list|(
name|win
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|delwin
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|has_colors
argument_list|()
condition|)
block|{
name|int
name|fg
init|=
operator|(
name|color
operator|==
name|COLOR_BLUE
operator|)
condition|?
name|COLOR_WHITE
else|:
name|COLOR_BLACK
decl_stmt|;
name|int
name|bg
init|=
name|color
decl_stmt|;
name|init_pair
argument_list|(
name|color
argument_list|,
name|fg
argument_list|,
name|bg
argument_list|)
expr_stmt|;
name|wbkgdset
argument_list|(
name|win
argument_list|,
name|COLOR_PAIR
argument_list|(
name|color
argument_list|)
operator||
literal|' '
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wbkgdset
argument_list|(
name|win
argument_list|,
name|A_BOLD
operator||
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|pan
return|;
block|}
end_function

begin_comment
comment|/* end of mkpanel */
end_comment

begin_comment
comment|/*+------------------------------------------------------------------------- 	rmpanel(pan) --------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|rmpanel
parameter_list|(
name|PANEL
modifier|*
name|pan
parameter_list|)
block|{
name|WINDOW
modifier|*
name|win
init|=
name|panel_window
argument_list|(
name|pan
argument_list|)
decl_stmt|;
name|del_panel
argument_list|(
name|pan
argument_list|)
expr_stmt|;
name|delwin
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end of rmpanel */
end_comment

begin_comment
comment|/*+------------------------------------------------------------------------- 	pflush() --------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|pflush
parameter_list|(
name|void
parameter_list|)
block|{
name|update_panels
argument_list|()
expr_stmt|;
name|doupdate
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end of pflush */
end_comment

begin_comment
comment|/*+------------------------------------------------------------------------- 	fill_panel(win) --------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|fill_panel
parameter_list|(
name|PANEL
modifier|*
name|pan
parameter_list|)
block|{
name|WINDOW
modifier|*
name|win
init|=
name|panel_window
argument_list|(
name|pan
argument_list|)
decl_stmt|;
name|int
name|num
init|=
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|panel_userptr
argument_list|(
name|pan
argument_list|)
operator|)
index|[
literal|1
index|]
decl_stmt|;
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|wprintw
argument_list|(
name|win
argument_list|,
literal|"-pan%c-"
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|wclrtoeol
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|box
argument_list|(
name|win
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|2
init|;
name|y
operator|<
name|getmaxy
argument_list|(
name|win
argument_list|)
operator|-
literal|1
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|x
operator|=
literal|1
init|;
name|x
operator|<
name|getmaxx
argument_list|(
name|win
argument_list|)
operator|-
literal|1
condition|;
name|x
operator|++
control|)
block|{
name|wmove
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|waddch
argument_list|(
name|win
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* end of fill_panel */
end_comment

begin_function
specifier|static
name|void
name|demo_panels
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|itmp
decl_stmt|;
specifier|register
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
name|refresh
argument_list|()
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|LINES
operator|-
literal|1
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|COLS
condition|;
name|x
operator|++
control|)
name|wprintw
argument_list|(
name|stdscr
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|y
operator|+
name|x
operator|)
operator|%
literal|10
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
literal|5
condition|;
name|y
operator|++
control|)
block|{
name|PANEL
modifier|*
name|p1
decl_stmt|;
name|PANEL
modifier|*
name|p2
decl_stmt|;
name|PANEL
modifier|*
name|p3
decl_stmt|;
name|PANEL
modifier|*
name|p4
decl_stmt|;
name|PANEL
modifier|*
name|p5
decl_stmt|;
name|p1
operator|=
name|mkpanel
argument_list|(
name|COLOR_RED
argument_list|,
name|LINES
operator|/
literal|2
operator|-
literal|2
argument_list|,
name|COLS
operator|/
literal|8
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_panel_userptr
argument_list|(
name|p1
argument_list|,
literal|"p1"
argument_list|)
expr_stmt|;
name|p2
operator|=
name|mkpanel
argument_list|(
name|COLOR_GREEN
argument_list|,
name|LINES
operator|/
literal|2
operator|+
literal|1
argument_list|,
name|COLS
operator|/
literal|7
argument_list|,
name|LINES
operator|/
literal|4
argument_list|,
name|COLS
operator|/
literal|10
argument_list|)
expr_stmt|;
name|set_panel_userptr
argument_list|(
name|p2
argument_list|,
literal|"p2"
argument_list|)
expr_stmt|;
name|p3
operator|=
name|mkpanel
argument_list|(
name|COLOR_YELLOW
argument_list|,
name|LINES
operator|/
literal|4
argument_list|,
name|COLS
operator|/
literal|10
argument_list|,
name|LINES
operator|/
literal|2
argument_list|,
name|COLS
operator|/
literal|9
argument_list|)
expr_stmt|;
name|set_panel_userptr
argument_list|(
name|p3
argument_list|,
literal|"p3"
argument_list|)
expr_stmt|;
name|p4
operator|=
name|mkpanel
argument_list|(
name|COLOR_BLUE
argument_list|,
name|LINES
operator|/
literal|2
operator|-
literal|2
argument_list|,
name|COLS
operator|/
literal|8
argument_list|,
name|LINES
operator|/
literal|2
operator|-
literal|2
argument_list|,
name|COLS
operator|/
literal|3
argument_list|)
expr_stmt|;
name|set_panel_userptr
argument_list|(
name|p4
argument_list|,
literal|"p4"
argument_list|)
expr_stmt|;
name|p5
operator|=
name|mkpanel
argument_list|(
name|COLOR_MAGENTA
argument_list|,
name|LINES
operator|/
literal|2
operator|-
literal|2
argument_list|,
name|COLS
operator|/
literal|8
argument_list|,
name|LINES
operator|/
literal|2
argument_list|,
name|COLS
operator|/
literal|2
operator|-
literal|2
argument_list|)
expr_stmt|;
name|set_panel_userptr
argument_list|(
name|p5
argument_list|,
literal|"p5"
argument_list|)
expr_stmt|;
name|fill_panel
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|fill_panel
argument_list|(
name|p2
argument_list|)
expr_stmt|;
name|fill_panel
argument_list|(
name|p3
argument_list|)
expr_stmt|;
name|fill_panel
argument_list|(
name|p4
argument_list|)
expr_stmt|;
name|fill_panel
argument_list|(
name|p5
argument_list|)
expr_stmt|;
name|hide_panel
argument_list|(
name|p4
argument_list|)
expr_stmt|;
name|hide_panel
argument_list|(
name|p5
argument_list|)
expr_stmt|;
name|pflush
argument_list|()
expr_stmt|;
name|saywhat
argument_list|(
literal|"press any key to continue"
argument_list|)
expr_stmt|;
name|wait_a_while
argument_list|(
name|nap_msec
argument_list|)
expr_stmt|;
name|saywhat
argument_list|(
literal|"h3 s1 s2 s4 s5; press any key to continue"
argument_list|)
expr_stmt|;
name|move_panel
argument_list|(
name|p1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hide_panel
argument_list|(
name|p3
argument_list|)
expr_stmt|;
name|show_panel
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|show_panel
argument_list|(
name|p2
argument_list|)
expr_stmt|;
name|show_panel
argument_list|(
name|p4
argument_list|)
expr_stmt|;
name|show_panel
argument_list|(
name|p5
argument_list|)
expr_stmt|;
name|pflush
argument_list|()
expr_stmt|;
name|wait_a_while
argument_list|(
name|nap_msec
argument_list|)
expr_stmt|;
name|saywhat
argument_list|(
literal|"s1; press any key to continue"
argument_list|)
expr_stmt|;
name|show_panel
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|pflush
argument_list|()
expr_stmt|;
name|wait_a_while
argument_list|(
name|nap_msec
argument_list|)
expr_stmt|;
name|saywhat
argument_list|(
literal|"s2; press any key to continue"
argument_list|)
expr_stmt|;
name|show_panel
argument_list|(
name|p2
argument_list|)
expr_stmt|;
name|pflush
argument_list|()
expr_stmt|;
name|wait_a_while
argument_list|(
name|nap_msec
argument_list|)
expr_stmt|;
name|saywhat
argument_list|(
literal|"m2; press any key to continue"
argument_list|)
expr_stmt|;
name|move_panel
argument_list|(
name|p2
argument_list|,
name|LINES
operator|/
literal|3
operator|+
literal|1
argument_list|,
name|COLS
operator|/
literal|8
argument_list|)
expr_stmt|;
name|pflush
argument_list|()
expr_stmt|;
name|wait_a_while
argument_list|(
name|nap_msec
argument_list|)
expr_stmt|;
name|saywhat
argument_list|(
literal|"s3;"
argument_list|)
expr_stmt|;
name|show_panel
argument_list|(
name|p3
argument_list|)
expr_stmt|;
name|pflush
argument_list|()
expr_stmt|;
name|wait_a_while
argument_list|(
name|nap_msec
argument_list|)
expr_stmt|;
name|saywhat
argument_list|(
literal|"m3; press any key to continue"
argument_list|)
expr_stmt|;
name|move_panel
argument_list|(
name|p3
argument_list|,
name|LINES
operator|/
literal|4
operator|+
literal|1
argument_list|,
name|COLS
operator|/
literal|15
argument_list|)
expr_stmt|;
name|pflush
argument_list|()
expr_stmt|;
name|wait_a_while
argument_list|(
name|nap_msec
argument_list|)
expr_stmt|;
name|saywhat
argument_list|(
literal|"b3; press any key to continue"
argument_list|)
expr_stmt|;
name|bottom_panel
argument_list|(
name|p3
argument_list|)
expr_stmt|;
name|pflush
argument_list|()
expr_stmt|;
name|wait_a_while
argument_list|(
name|nap_msec
argument_list|)
expr_stmt|;
name|saywhat
argument_list|(
literal|"s4; press any key to continue"
argument_list|)
expr_stmt|;
name|show_panel
argument_list|(
name|p4
argument_list|)
expr_stmt|;
name|pflush
argument_list|()
expr_stmt|;
name|wait_a_while
argument_list|(
name|nap_msec
argument_list|)
expr_stmt|;
name|saywhat
argument_list|(
literal|"s5; press any key to continue"
argument_list|)
expr_stmt|;
name|show_panel
argument_list|(
name|p5
argument_list|)
expr_stmt|;
name|pflush
argument_list|()
expr_stmt|;
name|wait_a_while
argument_list|(
name|nap_msec
argument_list|)
expr_stmt|;
name|saywhat
argument_list|(
literal|"t3; press any key to continue"
argument_list|)
expr_stmt|;
name|top_panel
argument_list|(
name|p3
argument_list|)
expr_stmt|;
name|pflush
argument_list|()
expr_stmt|;
name|wait_a_while
argument_list|(
name|nap_msec
argument_list|)
expr_stmt|;
name|saywhat
argument_list|(
literal|"t1; press any key to continue"
argument_list|)
expr_stmt|;
name|top_panel
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|pflush
argument_list|()
expr_stmt|;
name|wait_a_while
argument_list|(
name|nap_msec
argument_list|)
expr_stmt|;
name|saywhat
argument_list|(
literal|"t2; press any key to continue"
argument_list|)
expr_stmt|;
name|top_panel
argument_list|(
name|p2
argument_list|)
expr_stmt|;
name|pflush
argument_list|()
expr_stmt|;
name|wait_a_while
argument_list|(
name|nap_msec
argument_list|)
expr_stmt|;
name|saywhat
argument_list|(
literal|"t3; press any key to continue"
argument_list|)
expr_stmt|;
name|top_panel
argument_list|(
name|p3
argument_list|)
expr_stmt|;
name|pflush
argument_list|()
expr_stmt|;
name|wait_a_while
argument_list|(
name|nap_msec
argument_list|)
expr_stmt|;
name|saywhat
argument_list|(
literal|"t4; press any key to continue"
argument_list|)
expr_stmt|;
name|top_panel
argument_list|(
name|p4
argument_list|)
expr_stmt|;
name|pflush
argument_list|()
expr_stmt|;
name|wait_a_while
argument_list|(
name|nap_msec
argument_list|)
expr_stmt|;
for|for
control|(
name|itmp
operator|=
literal|0
init|;
name|itmp
operator|<
literal|6
condition|;
name|itmp
operator|++
control|)
block|{
name|WINDOW
modifier|*
name|w4
init|=
name|panel_window
argument_list|(
name|p4
argument_list|)
decl_stmt|;
name|WINDOW
modifier|*
name|w5
init|=
name|panel_window
argument_list|(
name|p5
argument_list|)
decl_stmt|;
name|saywhat
argument_list|(
literal|"m4; press any key to continue"
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|w4
argument_list|,
name|LINES
operator|/
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|waddstr
argument_list|(
name|w4
argument_list|,
name|mod
index|[
name|itmp
index|]
argument_list|)
expr_stmt|;
name|move_panel
argument_list|(
name|p4
argument_list|,
name|LINES
operator|/
literal|6
argument_list|,
name|itmp
operator|*
operator|(
name|COLS
operator|/
literal|8
operator|)
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|w5
argument_list|,
name|LINES
operator|/
literal|6
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|waddstr
argument_list|(
name|w5
argument_list|,
name|mod
index|[
name|itmp
index|]
argument_list|)
expr_stmt|;
name|pflush
argument_list|()
expr_stmt|;
name|wait_a_while
argument_list|(
name|nap_msec
argument_list|)
expr_stmt|;
name|saywhat
argument_list|(
literal|"m5; press any key to continue"
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|w4
argument_list|,
name|LINES
operator|/
literal|6
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|waddstr
argument_list|(
name|w4
argument_list|,
name|mod
index|[
name|itmp
index|]
argument_list|)
expr_stmt|;
name|move_panel
argument_list|(
name|p5
argument_list|,
name|LINES
operator|/
literal|3
operator|-
literal|1
argument_list|,
operator|(
name|itmp
operator|*
literal|10
operator|)
operator|+
literal|6
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|w5
argument_list|,
name|LINES
operator|/
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|waddstr
argument_list|(
name|w5
argument_list|,
name|mod
index|[
name|itmp
index|]
argument_list|)
expr_stmt|;
name|pflush
argument_list|()
expr_stmt|;
name|wait_a_while
argument_list|(
name|nap_msec
argument_list|)
expr_stmt|;
block|}
name|saywhat
argument_list|(
literal|"m4; press any key to continue"
argument_list|)
expr_stmt|;
name|move_panel
argument_list|(
name|p4
argument_list|,
name|LINES
operator|/
literal|6
argument_list|,
name|itmp
operator|*
operator|(
name|COLS
operator|/
literal|8
operator|)
argument_list|)
expr_stmt|;
name|pflush
argument_list|()
expr_stmt|;
name|wait_a_while
argument_list|(
name|nap_msec
argument_list|)
expr_stmt|;
name|saywhat
argument_list|(
literal|"t5; press any key to continue"
argument_list|)
expr_stmt|;
name|top_panel
argument_list|(
name|p5
argument_list|)
expr_stmt|;
name|pflush
argument_list|()
expr_stmt|;
name|wait_a_while
argument_list|(
name|nap_msec
argument_list|)
expr_stmt|;
name|saywhat
argument_list|(
literal|"t2; press any key to continue"
argument_list|)
expr_stmt|;
name|top_panel
argument_list|(
name|p2
argument_list|)
expr_stmt|;
name|pflush
argument_list|()
expr_stmt|;
name|wait_a_while
argument_list|(
name|nap_msec
argument_list|)
expr_stmt|;
name|saywhat
argument_list|(
literal|"t1; press any key to continue"
argument_list|)
expr_stmt|;
name|top_panel
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|pflush
argument_list|()
expr_stmt|;
name|wait_a_while
argument_list|(
name|nap_msec
argument_list|)
expr_stmt|;
name|saywhat
argument_list|(
literal|"d2; press any key to continue"
argument_list|)
expr_stmt|;
name|rmpanel
argument_list|(
name|p2
argument_list|)
expr_stmt|;
name|pflush
argument_list|()
expr_stmt|;
name|wait_a_while
argument_list|(
name|nap_msec
argument_list|)
expr_stmt|;
name|saywhat
argument_list|(
literal|"h3; press any key to continue"
argument_list|)
expr_stmt|;
name|hide_panel
argument_list|(
name|p3
argument_list|)
expr_stmt|;
name|pflush
argument_list|()
expr_stmt|;
name|wait_a_while
argument_list|(
name|nap_msec
argument_list|)
expr_stmt|;
name|saywhat
argument_list|(
literal|"d1; press any key to continue"
argument_list|)
expr_stmt|;
name|rmpanel
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|pflush
argument_list|()
expr_stmt|;
name|wait_a_while
argument_list|(
name|nap_msec
argument_list|)
expr_stmt|;
name|saywhat
argument_list|(
literal|"d4; press any key to continue"
argument_list|)
expr_stmt|;
name|rmpanel
argument_list|(
name|p4
argument_list|)
expr_stmt|;
name|pflush
argument_list|()
expr_stmt|;
name|wait_a_while
argument_list|(
name|nap_msec
argument_list|)
expr_stmt|;
name|saywhat
argument_list|(
literal|"d5; press any key to continue"
argument_list|)
expr_stmt|;
name|rmpanel
argument_list|(
name|p5
argument_list|)
expr_stmt|;
name|pflush
argument_list|()
expr_stmt|;
name|wait_a_while
argument_list|(
name|nap_msec
argument_list|)
expr_stmt|;
if|if
condition|(
name|nap_msec
operator|==
literal|1
condition|)
break|break;
name|nap_msec
operator|=
literal|100L
expr_stmt|;
block|}
name|erase
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  *  * Pad tester  *  ****************************************************************************/
end_comment

begin_define
define|#
directive|define
name|GRIDSIZE
value|3
end_define

begin_decl_stmt
specifier|static
name|bool
name|pending_pan
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|show_panner_legend
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|panner_legend
parameter_list|(
name|int
name|line
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|legend
index|[]
init|=
block|{
literal|"Use arrow keys (or U,D,L,R) to pan, q to quit, ! to shell-out."
block|,
literal|"Use +,- (or j,k) to grow/shrink the panner vertically."
block|,
literal|"Use<,> (or h,l) to grow/shrink the panner horizontally."
block|,
literal|"Number repeats.  Toggle legend:?, timer:t, scroll mark:s."
block|}
decl_stmt|;
name|int
name|n
init|=
operator|(
name|SIZEOF
argument_list|(
name|legend
argument_list|)
operator|-
operator|(
name|LINES
operator|-
name|line
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|line
operator|<
name|LINES
operator|&&
operator|(
name|n
operator|>=
literal|0
operator|)
condition|)
block|{
name|move
argument_list|(
name|line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|show_panner_legend
condition|)
name|printw
argument_list|(
literal|"%s"
argument_list|,
name|legend
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
return|return
name|show_panner_legend
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|panner_h_cleanup
parameter_list|(
name|int
name|from_y
parameter_list|,
name|int
name|from_x
parameter_list|,
name|int
name|to_x
parameter_list|)
block|{
if|if
condition|(
operator|!
name|panner_legend
argument_list|(
name|from_y
argument_list|)
condition|)
name|do_h_line
argument_list|(
name|from_y
argument_list|,
name|from_x
argument_list|,
literal|' '
argument_list|,
name|to_x
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|panner_v_cleanup
parameter_list|(
name|int
name|from_y
parameter_list|,
name|int
name|from_x
parameter_list|,
name|int
name|to_y
parameter_list|)
block|{
if|if
condition|(
operator|!
name|panner_legend
argument_list|(
name|from_y
argument_list|)
condition|)
name|do_v_line
argument_list|(
name|from_y
argument_list|,
name|from_x
argument_list|,
literal|' '
argument_list|,
name|to_y
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|panner
parameter_list|(
name|WINDOW
modifier|*
name|pad
parameter_list|,
name|int
name|top_x
parameter_list|,
name|int
name|top_y
parameter_list|,
name|int
name|porty
parameter_list|,
name|int
name|portx
parameter_list|,
name|int
function_decl|(
modifier|*
name|pgetc
function_decl|)
parameter_list|(
name|WINDOW
modifier|*
parameter_list|)
parameter_list|)
block|{
if|#
directive|if
name|HAVE_GETTIMEOFDAY
name|struct
name|timeval
name|before
decl_stmt|,
name|after
decl_stmt|;
name|bool
name|timing
init|=
name|TRUE
decl_stmt|;
endif|#
directive|endif
name|bool
name|scrollers
init|=
name|TRUE
decl_stmt|;
name|int
name|basex
init|=
literal|0
decl_stmt|;
name|int
name|basey
init|=
literal|0
decl_stmt|;
name|int
name|pxmax
decl_stmt|,
name|pymax
decl_stmt|,
name|lowend
decl_stmt|,
name|highend
decl_stmt|,
name|c
decl_stmt|;
name|getmaxyx
argument_list|(
name|pad
argument_list|,
name|pymax
argument_list|,
name|pxmax
argument_list|)
expr_stmt|;
name|scrollok
argument_list|(
name|stdscr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* we don't want stdscr to scroll! */
name|c
operator|=
name|KEY_REFRESH
expr_stmt|;
do|do
block|{
ifdef|#
directive|ifdef
name|NCURSES_VERSION
comment|/* 	 * During shell-out, the user may have resized the window.  Adjust 	 * the port size of the pad to accommodate this.  Ncurses automatically 	 * resizes all of the normal windows to fit on the new screen. 	 */
if|if
condition|(
name|top_x
operator|>
name|COLS
condition|)
name|top_x
operator|=
name|COLS
expr_stmt|;
if|if
condition|(
name|portx
operator|>
name|COLS
condition|)
name|portx
operator|=
name|COLS
expr_stmt|;
if|if
condition|(
name|top_y
operator|>
name|LINES
condition|)
name|top_y
operator|=
name|LINES
expr_stmt|;
if|if
condition|(
name|porty
operator|>
name|LINES
condition|)
name|porty
operator|=
name|LINES
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|KEY_REFRESH
case|:
name|erase
argument_list|()
expr_stmt|;
comment|/* FALLTHRU */
case|case
literal|'?'
case|:
if|if
condition|(
name|c
operator|==
literal|'?'
condition|)
name|show_panner_legend
operator|=
operator|!
name|show_panner_legend
expr_stmt|;
name|panner_legend
argument_list|(
name|LINES
operator|-
literal|4
argument_list|)
expr_stmt|;
name|panner_legend
argument_list|(
name|LINES
operator|-
literal|3
argument_list|)
expr_stmt|;
name|panner_legend
argument_list|(
name|LINES
operator|-
literal|2
argument_list|)
expr_stmt|;
name|panner_legend
argument_list|(
name|LINES
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|HAVE_GETTIMEOFDAY
case|case
literal|'t'
case|:
name|timing
operator|=
operator|!
name|timing
expr_stmt|;
if|if
condition|(
operator|!
name|timing
condition|)
name|panner_legend
argument_list|(
name|LINES
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'s'
case|:
name|scrollers
operator|=
operator|!
name|scrollers
expr_stmt|;
break|break;
comment|/* Move the top-left corner of the pad, keeping the bottom-right 	     * corner fixed. 	     */
case|case
literal|'h'
case|:
comment|/* increase-columns: move left edge to left */
if|if
condition|(
name|top_x
operator|<=
literal|0
condition|)
name|beep
argument_list|()
expr_stmt|;
else|else
block|{
name|panner_v_cleanup
argument_list|(
name|top_y
argument_list|,
name|top_x
argument_list|,
name|porty
argument_list|)
expr_stmt|;
name|top_x
operator|--
expr_stmt|;
block|}
break|break;
case|case
literal|'j'
case|:
comment|/* decrease-lines: move top-edge down */
if|if
condition|(
name|top_y
operator|>=
name|porty
condition|)
name|beep
argument_list|()
expr_stmt|;
else|else
block|{
name|panner_h_cleanup
argument_list|(
name|top_y
operator|-
literal|1
argument_list|,
name|top_x
operator|-
operator|(
name|top_x
operator|>
literal|0
operator|)
argument_list|,
name|portx
argument_list|)
expr_stmt|;
name|top_y
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'k'
case|:
comment|/* increase-lines: move top-edge up */
if|if
condition|(
name|top_y
operator|<=
literal|0
condition|)
name|beep
argument_list|()
expr_stmt|;
else|else
block|{
name|top_y
operator|--
expr_stmt|;
name|panner_h_cleanup
argument_list|(
name|top_y
argument_list|,
name|top_x
argument_list|,
name|portx
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'l'
case|:
comment|/* decrease-columns: move left-edge to right */
if|if
condition|(
name|top_x
operator|>=
name|portx
condition|)
name|beep
argument_list|()
expr_stmt|;
else|else
block|{
name|panner_v_cleanup
argument_list|(
name|top_y
operator|-
operator|(
name|top_y
operator|>
literal|0
operator|)
argument_list|,
name|top_x
operator|-
literal|1
argument_list|,
name|porty
argument_list|)
expr_stmt|;
name|top_x
operator|++
expr_stmt|;
block|}
break|break;
comment|/* Move the bottom-right corner of the pad, keeping the top-left 	     * corner fixed. 	     */
case|case
name|KEY_IC
case|:
comment|/* increase-columns: move right-edge to right */
if|if
condition|(
name|portx
operator|>=
name|pxmax
operator|||
name|portx
operator|>=
name|COLS
condition|)
name|beep
argument_list|()
expr_stmt|;
else|else
block|{
name|panner_v_cleanup
argument_list|(
name|top_y
operator|-
operator|(
name|top_y
operator|>
literal|0
operator|)
argument_list|,
name|portx
operator|-
literal|1
argument_list|,
name|porty
argument_list|)
expr_stmt|;
operator|++
name|portx
expr_stmt|;
block|}
break|break;
case|case
name|KEY_IL
case|:
comment|/* increase-lines: move bottom-edge down */
if|if
condition|(
name|porty
operator|>=
name|pymax
operator|||
name|porty
operator|>=
name|LINES
condition|)
name|beep
argument_list|()
expr_stmt|;
else|else
block|{
name|panner_h_cleanup
argument_list|(
name|porty
operator|-
literal|1
argument_list|,
name|top_x
operator|-
operator|(
name|top_x
operator|>
literal|0
operator|)
argument_list|,
name|portx
argument_list|)
expr_stmt|;
operator|++
name|porty
expr_stmt|;
block|}
break|break;
case|case
name|KEY_DC
case|:
comment|/* decrease-columns: move bottom edge up */
if|if
condition|(
name|portx
operator|<=
name|top_x
condition|)
name|beep
argument_list|()
expr_stmt|;
else|else
block|{
name|portx
operator|--
expr_stmt|;
name|panner_v_cleanup
argument_list|(
name|top_y
operator|-
operator|(
name|top_y
operator|>
literal|0
operator|)
argument_list|,
name|portx
argument_list|,
name|porty
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|KEY_DL
case|:
comment|/* decrease-lines */
if|if
condition|(
name|porty
operator|<=
name|top_y
condition|)
name|beep
argument_list|()
expr_stmt|;
else|else
block|{
name|porty
operator|--
expr_stmt|;
name|panner_h_cleanup
argument_list|(
name|porty
argument_list|,
name|top_x
operator|-
operator|(
name|top_x
operator|>
literal|0
operator|)
argument_list|,
name|portx
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|KEY_LEFT
case|:
comment|/* pan leftwards */
if|if
condition|(
name|basex
operator|>
literal|0
condition|)
name|basex
operator|--
expr_stmt|;
else|else
name|beep
argument_list|()
expr_stmt|;
break|break;
case|case
name|KEY_RIGHT
case|:
comment|/* pan rightwards */
if|if
condition|(
name|basex
operator|+
name|portx
operator|-
operator|(
name|pymax
operator|>
name|porty
operator|)
operator|<
name|pxmax
condition|)
name|basex
operator|++
expr_stmt|;
else|else
name|beep
argument_list|()
expr_stmt|;
break|break;
case|case
name|KEY_UP
case|:
comment|/* pan upwards */
if|if
condition|(
name|basey
operator|>
literal|0
condition|)
name|basey
operator|--
expr_stmt|;
else|else
name|beep
argument_list|()
expr_stmt|;
break|break;
case|case
name|KEY_DOWN
case|:
comment|/* pan downwards */
if|if
condition|(
name|basey
operator|+
name|porty
operator|-
operator|(
name|pxmax
operator|>
name|portx
operator|)
operator|<
name|pymax
condition|)
name|basey
operator|++
expr_stmt|;
else|else
name|beep
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
case|case
name|KEY_HOME
case|:
case|case
name|KEY_FIND
case|:
name|basey
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
case|case
name|KEY_END
case|:
case|case
name|KEY_SELECT
case|:
name|basey
operator|=
name|pymax
operator|-
name|porty
expr_stmt|;
if|if
condition|(
name|basey
operator|<
literal|0
condition|)
name|basey
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|beep
argument_list|()
expr_stmt|;
break|break;
block|}
name|mvaddch
argument_list|(
name|top_y
operator|-
literal|1
argument_list|,
name|top_x
operator|-
literal|1
argument_list|,
name|ACS_ULCORNER
argument_list|)
expr_stmt|;
name|do_v_line
argument_list|(
name|top_y
argument_list|,
name|top_x
operator|-
literal|1
argument_list|,
name|ACS_VLINE
argument_list|,
name|porty
argument_list|)
expr_stmt|;
name|do_h_line
argument_list|(
name|top_y
operator|-
literal|1
argument_list|,
name|top_x
argument_list|,
name|ACS_HLINE
argument_list|,
name|portx
argument_list|)
expr_stmt|;
if|if
condition|(
name|scrollers
operator|&&
operator|(
name|pxmax
operator|>
name|portx
operator|-
literal|1
operator|)
condition|)
block|{
name|int
name|length
init|=
operator|(
name|portx
operator|-
name|top_x
operator|-
literal|1
operator|)
decl_stmt|;
name|float
name|ratio
init|=
operator|(
operator|(
name|float
operator|)
name|length
operator|)
operator|/
operator|(
operator|(
name|float
operator|)
name|pxmax
operator|)
decl_stmt|;
name|lowend
operator|=
call|(
name|int
call|)
argument_list|(
name|top_x
operator|+
operator|(
name|basex
operator|*
name|ratio
operator|)
argument_list|)
expr_stmt|;
name|highend
operator|=
call|(
name|int
call|)
argument_list|(
name|top_x
operator|+
operator|(
operator|(
name|basex
operator|+
name|length
operator|)
operator|*
name|ratio
operator|)
argument_list|)
expr_stmt|;
name|do_h_line
argument_list|(
name|porty
operator|-
literal|1
argument_list|,
name|top_x
argument_list|,
name|ACS_HLINE
argument_list|,
name|lowend
argument_list|)
expr_stmt|;
if|if
condition|(
name|highend
operator|<
name|portx
condition|)
block|{
name|attron
argument_list|(
name|A_REVERSE
argument_list|)
expr_stmt|;
name|do_h_line
argument_list|(
name|porty
operator|-
literal|1
argument_list|,
name|lowend
argument_list|,
literal|' '
argument_list|,
name|highend
operator|+
literal|1
argument_list|)
expr_stmt|;
name|attroff
argument_list|(
name|A_REVERSE
argument_list|)
expr_stmt|;
name|do_h_line
argument_list|(
name|porty
operator|-
literal|1
argument_list|,
name|highend
operator|+
literal|1
argument_list|,
name|ACS_HLINE
argument_list|,
name|portx
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|do_h_line
argument_list|(
name|porty
operator|-
literal|1
argument_list|,
name|top_x
argument_list|,
name|ACS_HLINE
argument_list|,
name|portx
argument_list|)
expr_stmt|;
if|if
condition|(
name|scrollers
operator|&&
operator|(
name|pymax
operator|>
name|porty
operator|-
literal|1
operator|)
condition|)
block|{
name|int
name|length
init|=
operator|(
name|porty
operator|-
name|top_y
operator|-
literal|1
operator|)
decl_stmt|;
name|float
name|ratio
init|=
operator|(
operator|(
name|float
operator|)
name|length
operator|)
operator|/
operator|(
operator|(
name|float
operator|)
name|pymax
operator|)
decl_stmt|;
name|lowend
operator|=
call|(
name|int
call|)
argument_list|(
name|top_y
operator|+
operator|(
name|basey
operator|*
name|ratio
operator|)
argument_list|)
expr_stmt|;
name|highend
operator|=
call|(
name|int
call|)
argument_list|(
name|top_y
operator|+
operator|(
operator|(
name|basey
operator|+
name|length
operator|)
operator|*
name|ratio
operator|)
argument_list|)
expr_stmt|;
name|do_v_line
argument_list|(
name|top_y
argument_list|,
name|portx
operator|-
literal|1
argument_list|,
name|ACS_VLINE
argument_list|,
name|lowend
argument_list|)
expr_stmt|;
if|if
condition|(
name|highend
operator|<
name|porty
condition|)
block|{
name|attron
argument_list|(
name|A_REVERSE
argument_list|)
expr_stmt|;
name|do_v_line
argument_list|(
name|lowend
argument_list|,
name|portx
operator|-
literal|1
argument_list|,
literal|' '
argument_list|,
name|highend
operator|+
literal|1
argument_list|)
expr_stmt|;
name|attroff
argument_list|(
name|A_REVERSE
argument_list|)
expr_stmt|;
name|do_v_line
argument_list|(
name|highend
operator|+
literal|1
argument_list|,
name|portx
operator|-
literal|1
argument_list|,
name|ACS_VLINE
argument_list|,
name|porty
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|do_v_line
argument_list|(
name|top_y
argument_list|,
name|portx
operator|-
literal|1
argument_list|,
name|ACS_VLINE
argument_list|,
name|porty
argument_list|)
expr_stmt|;
name|mvaddch
argument_list|(
name|top_y
operator|-
literal|1
argument_list|,
name|portx
operator|-
literal|1
argument_list|,
name|ACS_URCORNER
argument_list|)
expr_stmt|;
name|mvaddch
argument_list|(
name|porty
operator|-
literal|1
argument_list|,
name|top_x
operator|-
literal|1
argument_list|,
name|ACS_LLCORNER
argument_list|)
expr_stmt|;
name|mvaddch
argument_list|(
name|porty
operator|-
literal|1
argument_list|,
name|portx
operator|-
literal|1
argument_list|,
name|ACS_LRCORNER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pending_pan
condition|)
block|{
if|#
directive|if
name|HAVE_GETTIMEOFDAY
name|gettimeofday
argument_list|(
operator|&
name|before
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|wnoutrefresh
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
name|pnoutrefresh
argument_list|(
name|pad
argument_list|,
name|basey
argument_list|,
name|basex
argument_list|,
name|top_y
argument_list|,
name|top_x
argument_list|,
name|porty
operator|-
operator|(
name|pxmax
operator|>
name|portx
operator|)
operator|-
literal|1
argument_list|,
name|portx
operator|-
operator|(
name|pymax
operator|>
name|porty
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|doupdate
argument_list|()
expr_stmt|;
if|#
directive|if
name|HAVE_GETTIMEOFDAY
if|if
condition|(
name|timing
condition|)
block|{
name|double
name|elapsed
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|after
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|elapsed
operator|=
operator|(
name|after
operator|.
name|tv_sec
operator|+
name|after
operator|.
name|tv_usec
operator|/
literal|1.0e6
operator|)
operator|-
operator|(
name|before
operator|.
name|tv_sec
operator|+
name|before
operator|.
name|tv_usec
operator|/
literal|1.0e6
operator|)
expr_stmt|;
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
name|COLS
operator|-
literal|20
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"Secs: %2.03f"
argument_list|,
name|elapsed
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
do|while
condition|(
operator|(
name|c
operator|=
name|pgetc
argument_list|(
name|pad
argument_list|)
operator|)
operator|!=
name|KEY_EXIT
condition|)
do|;
name|scrollok
argument_list|(
name|stdscr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* reset to driver's default */
block|}
end_function

begin_function
specifier|static
name|int
name|padgetch
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
specifier|static
name|int
name|count
decl_stmt|;
specifier|static
name|int
name|last
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|pending_pan
operator|=
operator|(
name|count
operator|>
literal|0
operator|)
operator|)
operator|!=
name|FALSE
condition|)
block|{
name|count
operator|--
expr_stmt|;
name|pending_pan
operator|=
operator|(
name|count
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|c
operator|=
name|wGetchar
argument_list|(
name|win
argument_list|)
condition|)
block|{
case|case
literal|'!'
case|:
name|ShellOut
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|c
operator|=
name|KEY_REFRESH
expr_stmt|;
case|case
name|CTRL
argument_list|(
literal|'r'
argument_list|)
case|:
name|endwin
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|c
operator|=
name|KEY_REFRESH
expr_stmt|;
break|break;
case|case
name|CTRL
argument_list|(
literal|'l'
argument_list|)
case|:
name|c
operator|=
name|KEY_REFRESH
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|c
operator|=
name|KEY_UP
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|c
operator|=
name|KEY_DOWN
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|c
operator|=
name|KEY_RIGHT
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|c
operator|=
name|KEY_LEFT
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|c
operator|=
name|KEY_IL
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|c
operator|=
name|KEY_DL
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|c
operator|=
name|KEY_IC
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|c
operator|=
name|KEY_DC
expr_stmt|;
break|break;
case|case
name|ERR
case|:
comment|/* FALLTHRU */
case|case
literal|'q'
case|:
name|count
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|KEY_EXIT
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|count
operator|=
name|count
operator|*
literal|10
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
name|last
operator|=
name|c
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|count
operator|>
literal|0
condition|)
name|count
operator|--
expr_stmt|;
block|}
return|return
operator|(
name|last
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PAD_HIGH
value|200
end_define

begin_define
define|#
directive|define
name|PAD_WIDE
value|200
end_define

begin_function
specifier|static
name|void
name|demo_pad
parameter_list|(
name|void
parameter_list|)
comment|/* Demonstrate pads. */
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|gridcount
init|=
literal|0
decl_stmt|;
name|WINDOW
modifier|*
name|panpad
init|=
name|newpad
argument_list|(
name|PAD_HIGH
argument_list|,
name|PAD_WIDE
argument_list|)
decl_stmt|;
if|if
condition|(
name|panpad
operator|==
literal|0
condition|)
block|{
name|Cannot
argument_list|(
literal|"cannot create requested pad"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PAD_HIGH
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|PAD_WIDE
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|i
operator|%
name|GRIDSIZE
operator|==
literal|0
operator|&&
name|j
operator|%
name|GRIDSIZE
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|j
operator|==
literal|0
condition|)
name|waddch
argument_list|(
name|panpad
argument_list|,
literal|'+'
argument_list|)
expr_stmt|;
else|else
name|waddch
argument_list|(
name|panpad
argument_list|,
call|(
name|chtype
call|)
argument_list|(
literal|'A'
operator|+
operator|(
name|gridcount
operator|++
operator|%
literal|26
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|%
name|GRIDSIZE
operator|==
literal|0
condition|)
name|waddch
argument_list|(
name|panpad
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|j
operator|%
name|GRIDSIZE
operator|==
literal|0
condition|)
name|waddch
argument_list|(
name|panpad
argument_list|,
literal|'|'
argument_list|)
expr_stmt|;
else|else
name|waddch
argument_list|(
name|panpad
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
name|panner_legend
argument_list|(
name|LINES
operator|-
literal|4
argument_list|)
expr_stmt|;
name|panner_legend
argument_list|(
name|LINES
operator|-
literal|3
argument_list|)
expr_stmt|;
name|panner_legend
argument_list|(
name|LINES
operator|-
literal|2
argument_list|)
expr_stmt|;
name|panner_legend
argument_list|(
name|LINES
operator|-
literal|1
argument_list|)
expr_stmt|;
name|keypad
argument_list|(
name|panpad
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Make the pad (initially) narrow enough that a trace file won't wrap.      * We'll still be able to widen it during a test, since that's required      * for testing boundaries.      */
name|panner
argument_list|(
name|panpad
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
name|LINES
operator|-
literal|5
argument_list|,
name|COLS
operator|-
literal|15
argument_list|,
name|padgetch
argument_list|)
expr_stmt|;
name|delwin
argument_list|(
name|panpad
argument_list|)
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
name|erase
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_LIBPANEL */
end_comment

begin_comment
comment|/****************************************************************************  *  * Tests from John Burnell's PDCurses tester  *  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|Continue
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|noecho
argument_list|()
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
literal|10
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|10
argument_list|,
literal|1
argument_list|,
literal|" Press any key to continue"
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wGetchar
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|flushinp_test
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
comment|/* Input test, adapted from John Burnell's PDCurses tester */
block|{
name|int
name|w
decl_stmt|,
name|h
decl_stmt|,
name|bx
decl_stmt|,
name|by
decl_stmt|,
name|sw
decl_stmt|,
name|sh
decl_stmt|,
name|i
decl_stmt|;
name|WINDOW
modifier|*
name|subWin
decl_stmt|;
name|wclear
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|getmaxyx
argument_list|(
name|win
argument_list|,
name|h
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|getbegyx
argument_list|(
name|win
argument_list|,
name|by
argument_list|,
name|bx
argument_list|)
expr_stmt|;
name|sw
operator|=
name|w
operator|/
literal|3
expr_stmt|;
name|sh
operator|=
name|h
operator|/
literal|3
expr_stmt|;
if|if
condition|(
operator|(
name|subWin
operator|=
name|subwin
argument_list|(
name|win
argument_list|,
name|sh
argument_list|,
name|sw
argument_list|,
name|by
operator|+
name|h
operator|-
name|sh
operator|-
literal|2
argument_list|,
name|bx
operator|+
name|w
operator|-
name|sw
operator|-
literal|2
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
ifdef|#
directive|ifdef
name|A_COLOR
if|if
condition|(
name|has_colors
argument_list|()
condition|)
block|{
name|init_pair
argument_list|(
literal|2
argument_list|,
name|COLOR_CYAN
argument_list|,
name|COLOR_BLUE
argument_list|)
expr_stmt|;
name|wbkgd
argument_list|(
name|subWin
argument_list|,
name|COLOR_PAIR
argument_list|(
literal|2
argument_list|)
operator||
literal|' '
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|wattrset
argument_list|(
name|subWin
argument_list|,
name|A_BOLD
argument_list|)
expr_stmt|;
name|box
argument_list|(
name|subWin
argument_list|,
name|ACS_VLINE
argument_list|,
name|ACS_HLINE
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|subWin
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|"This is a subwindow"
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
comment|/*      * This used to set 'nocbreak()'.  However, Alexander Lukyanov says that      * it only happened to "work" on SVr4 because that implementation does not      * emulate nocbreak+noecho mode, whereas ncurses does.  To get the desired      * test behavior, we're using 'cbreak()', which will allow a single      * character to return without needing a newline. - T.Dickey 1997/10/11.      */
name|cbreak
argument_list|()
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|"This is a test of the flushinp() call."
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|"Type random keys for 5 seconds."
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
literal|"These should be discarded (not echoed) after the subwindow goes away."
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|mvwprintw
argument_list|(
name|subWin
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"Time = %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|subWin
argument_list|)
expr_stmt|;
name|napms
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|flushinp
argument_list|()
expr_stmt|;
block|}
name|delwin
argument_list|(
name|subWin
argument_list|)
expr_stmt|;
name|werase
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|flash
argument_list|()
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|napms
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|"If you were still typing when the window timer expired,"
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
literal|"or else you typed nothing at all while it was running,"
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
literal|"test was invalid.  You'll see garbage or nothing at all. "
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
literal|"Press a key"
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
literal|9
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|echo
argument_list|()
expr_stmt|;
name|wGetchar
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|flushinp
argument_list|()
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|12
argument_list|,
literal|0
argument_list|,
literal|"If you see any key other than what you typed, flushinp() is broken."
argument_list|)
expr_stmt|;
name|Continue
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
literal|9
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|wdelch
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
literal|12
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
name|waddstr
argument_list|(
name|win
argument_list|,
literal|"What you typed should now have been deleted; if not, wdelch() failed."
argument_list|)
expr_stmt|;
name|Continue
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|cbreak
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  *  * Menu test  *  ****************************************************************************/
end_comment

begin_if
if|#
directive|if
name|USE_LIBMENU
end_if

begin_define
define|#
directive|define
name|MENU_Y
value|8
end_define

begin_define
define|#
directive|define
name|MENU_X
value|8
end_define

begin_function
specifier|static
name|int
name|menu_virtualize
parameter_list|(
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
name|KEY_EXIT
condition|)
return|return
operator|(
name|MAX_COMMAND
operator|+
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'u'
condition|)
return|return
operator|(
name|REQ_SCR_ULINE
operator|)
return|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'d'
condition|)
return|return
operator|(
name|REQ_SCR_DLINE
operator|)
return|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'b'
operator|||
name|c
operator|==
name|KEY_NPAGE
condition|)
return|return
operator|(
name|REQ_SCR_UPAGE
operator|)
return|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'f'
operator|||
name|c
operator|==
name|KEY_PPAGE
condition|)
return|return
operator|(
name|REQ_SCR_DPAGE
operator|)
return|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'n'
operator|||
name|c
operator|==
name|KEY_DOWN
condition|)
return|return
operator|(
name|REQ_NEXT_ITEM
operator|)
return|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'p'
operator|||
name|c
operator|==
name|KEY_UP
condition|)
return|return
operator|(
name|REQ_PREV_ITEM
operator|)
return|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|' '
condition|)
return|return
operator|(
name|REQ_TOGGLE_ITEM
operator|)
return|;
else|else
block|{
if|if
condition|(
name|c
operator|!=
name|KEY_MOUSE
condition|)
name|beep
argument_list|()
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|animals
index|[]
init|=
block|{
literal|"Lions"
block|,
literal|"Tigers"
block|,
literal|"Bears"
block|,
literal|"(Oh my!)"
block|,
literal|"Newts"
block|,
literal|"Platypi"
block|,
literal|"Lemurs"
block|,
operator|(
name|char
operator|*
operator|)
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|menu_test
parameter_list|(
name|void
parameter_list|)
block|{
name|MENU
modifier|*
name|m
decl_stmt|;
name|ITEM
modifier|*
name|items
index|[
name|SIZEOF
argument_list|(
name|animals
argument_list|)
index|]
decl_stmt|;
name|ITEM
modifier|*
modifier|*
name|ip
init|=
name|items
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|ap
decl_stmt|;
name|int
name|mrows
decl_stmt|,
name|mcols
decl_stmt|,
name|c
decl_stmt|;
name|WINDOW
modifier|*
name|menuwin
decl_stmt|;
ifdef|#
directive|ifdef
name|NCURSES_MOUSE_VERSION
name|mousemask
argument_list|(
name|ALL_MOUSE_EVENTS
argument_list|,
operator|(
name|mmask_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mvaddstr
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"This is the menu test:"
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"  Use up and down arrow to move the select bar."
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|,
literal|"  'n' and 'p' act like arrows."
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|,
literal|"  'b' and 'f' scroll up/down (page), 'u' and 'd' (line)."
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|5
argument_list|,
literal|0
argument_list|,
literal|"  Press return to exit."
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|animals
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
control|)
operator|*
name|ip
operator|++
operator|=
name|new_item
argument_list|(
operator|*
name|ap
argument_list|,
literal|""
argument_list|)
expr_stmt|;
operator|*
name|ip
operator|=
operator|(
name|ITEM
operator|*
operator|)
literal|0
expr_stmt|;
name|m
operator|=
name|new_menu
argument_list|(
name|items
argument_list|)
expr_stmt|;
name|set_menu_format
argument_list|(
name|m
argument_list|,
operator|(
name|SIZEOF
argument_list|(
name|animals
argument_list|)
operator|+
literal|1
operator|)
operator|/
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|scale_menu
argument_list|(
name|m
argument_list|,
operator|&
name|mrows
argument_list|,
operator|&
name|mcols
argument_list|)
expr_stmt|;
name|menuwin
operator|=
name|newwin
argument_list|(
name|mrows
operator|+
literal|2
argument_list|,
name|mcols
operator|+
literal|2
argument_list|,
name|MENU_Y
argument_list|,
name|MENU_X
argument_list|)
expr_stmt|;
name|set_menu_win
argument_list|(
name|m
argument_list|,
name|menuwin
argument_list|)
expr_stmt|;
name|keypad
argument_list|(
name|menuwin
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|box
argument_list|(
name|menuwin
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_menu_sub
argument_list|(
name|m
argument_list|,
name|derwin
argument_list|(
name|menuwin
argument_list|,
name|mrows
argument_list|,
name|mcols
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|post_menu
argument_list|(
name|m
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|menu_driver
argument_list|(
name|m
argument_list|,
name|menu_virtualize
argument_list|(
name|wGetchar
argument_list|(
name|menuwin
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|!=
name|E_UNKNOWN_COMMAND
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|E_REQUEST_DENIED
condition|)
name|beep
argument_list|()
expr_stmt|;
continue|continue;
block|}
operator|(
name|void
operator|)
name|mvprintw
argument_list|(
name|LINES
operator|-
literal|2
argument_list|,
literal|0
argument_list|,
literal|"You chose: %s\n"
argument_list|,
name|item_name
argument_list|(
name|current_item
argument_list|(
name|m
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|addstr
argument_list|(
literal|"Press any key to continue..."
argument_list|)
expr_stmt|;
name|wGetchar
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
name|unpost_menu
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|delwin
argument_list|(
name|menuwin
argument_list|)
expr_stmt|;
name|free_menu
argument_list|(
name|m
argument_list|)
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|items
init|;
operator|*
name|ip
condition|;
name|ip
operator|++
control|)
name|free_item
argument_list|(
operator|*
name|ip
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NCURSES_MOUSE_VERSION
name|mousemask
argument_list|(
literal|0
argument_list|,
operator|(
name|mmask_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TRACE
end_ifdef

begin_define
define|#
directive|define
name|T_TBL
parameter_list|(
name|name
parameter_list|)
value|{ #name, name }
end_define

begin_struct
specifier|static
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|mask
decl_stmt|;
block|}
name|t_tbl
index|[]
init|=
block|{
name|T_TBL
argument_list|(
name|TRACE_DISABLE
argument_list|)
block|,
name|T_TBL
argument_list|(
name|TRACE_TIMES
argument_list|)
block|,
name|T_TBL
argument_list|(
name|TRACE_TPUTS
argument_list|)
block|,
name|T_TBL
argument_list|(
name|TRACE_UPDATE
argument_list|)
block|,
name|T_TBL
argument_list|(
name|TRACE_MOVE
argument_list|)
block|,
name|T_TBL
argument_list|(
name|TRACE_CHARPUT
argument_list|)
block|,
name|T_TBL
argument_list|(
name|TRACE_ORDINARY
argument_list|)
block|,
name|T_TBL
argument_list|(
name|TRACE_CALLS
argument_list|)
block|,
name|T_TBL
argument_list|(
name|TRACE_VIRTPUT
argument_list|)
block|,
name|T_TBL
argument_list|(
name|TRACE_IEVENT
argument_list|)
block|,
name|T_TBL
argument_list|(
name|TRACE_BITS
argument_list|)
block|,
name|T_TBL
argument_list|(
name|TRACE_ICALLS
argument_list|)
block|,
name|T_TBL
argument_list|(
name|TRACE_CCALLS
argument_list|)
block|,
name|T_TBL
argument_list|(
name|TRACE_DATABASE
argument_list|)
block|,
name|T_TBL
argument_list|(
name|TRACE_ATTRS
argument_list|)
block|,
name|T_TBL
argument_list|(
name|TRACE_MAXIMUM
argument_list|)
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|char
modifier|*
name|tracetrace
parameter_list|(
name|int
name|tlevel
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|buf
operator|==
literal|0
condition|)
block|{
name|size_t
name|need
init|=
literal|12
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|t_tbl
index|[
name|n
index|]
operator|.
name|name
operator|!=
literal|0
condition|;
name|n
operator|++
control|)
name|need
operator|+=
name|strlen
argument_list|(
name|t_tbl
index|[
name|n
index|]
operator|.
name|name
argument_list|)
operator|+
literal|2
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|need
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"0x%02x = {"
argument_list|,
name|tlevel
argument_list|)
expr_stmt|;
if|if
condition|(
name|tlevel
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s, "
argument_list|,
name|t_tbl
index|[
literal|0
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|n
operator|=
literal|1
init|;
name|t_tbl
index|[
name|n
index|]
operator|.
name|name
operator|!=
literal|0
condition|;
name|n
operator|++
control|)
if|if
condition|(
operator|(
name|tlevel
operator|&
name|t_tbl
index|[
name|n
index|]
operator|.
name|mask
operator|)
operator|==
name|t_tbl
index|[
name|n
index|]
operator|.
name|mask
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
name|t_tbl
index|[
name|n
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|2
index|]
operator|==
literal|','
condition|)
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"}"
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* fake a dynamically reconfigurable menu using the 0th entry to deselect  * the others  */
end_comment

begin_function
specifier|static
name|int
name|run_trace_menu
parameter_list|(
name|MENU
modifier|*
name|m
parameter_list|)
block|{
name|ITEM
modifier|*
modifier|*
name|items
decl_stmt|;
name|ITEM
modifier|*
name|i
decl_stmt|,
modifier|*
modifier|*
name|p
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bool
name|changed
init|=
name|FALSE
decl_stmt|;
switch|switch
condition|(
name|menu_driver
argument_list|(
name|m
argument_list|,
name|menu_virtualize
argument_list|(
name|wGetchar
argument_list|(
name|menu_win
argument_list|(
name|m
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|E_UNKNOWN_COMMAND
case|:
return|return
name|FALSE
return|;
default|default:
name|items
operator|=
name|menu_items
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|i
operator|=
name|current_item
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|items
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|item_value
argument_list|(
name|i
argument_list|)
condition|)
block|{
for|for
control|(
name|p
operator|=
name|items
operator|+
literal|1
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|item_value
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|set_item_value
argument_list|(
operator|*
name|p
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|changed
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|p
operator|=
name|items
operator|+
literal|1
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|item_value
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|set_item_value
argument_list|(
name|items
index|[
literal|0
index|]
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|changed
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|changed
condition|)
return|return
name|TRUE
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|trace_set
parameter_list|(
name|void
parameter_list|)
comment|/* interactively set the trace level */
block|{
name|MENU
modifier|*
name|m
decl_stmt|;
name|ITEM
modifier|*
name|items
index|[
name|SIZEOF
argument_list|(
name|t_tbl
argument_list|)
index|]
decl_stmt|;
name|ITEM
modifier|*
modifier|*
name|ip
init|=
name|items
decl_stmt|;
name|int
name|mrows
decl_stmt|,
name|mcols
decl_stmt|,
name|newtrace
decl_stmt|;
name|int
name|n
decl_stmt|;
name|WINDOW
modifier|*
name|menuwin
decl_stmt|;
name|mvaddstr
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Interactively set trace level:"
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"  Press space bar to toggle a selection."
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|,
literal|"  Use up and down arrow to move the select bar."
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|,
literal|"  Press return to set the trace level."
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
literal|6
argument_list|,
literal|0
argument_list|,
literal|"(Current trace level is %s)"
argument_list|,
name|tracetrace
argument_list|(
name|_nc_tracing
argument_list|)
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|t_tbl
index|[
name|n
index|]
operator|.
name|name
operator|!=
literal|0
condition|;
name|n
operator|++
control|)
operator|*
name|ip
operator|++
operator|=
name|new_item
argument_list|(
name|t_tbl
index|[
name|n
index|]
operator|.
name|name
argument_list|,
literal|""
argument_list|)
expr_stmt|;
operator|*
name|ip
operator|=
operator|(
name|ITEM
operator|*
operator|)
literal|0
expr_stmt|;
name|m
operator|=
name|new_menu
argument_list|(
name|items
argument_list|)
expr_stmt|;
name|set_menu_format
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|scale_menu
argument_list|(
name|m
argument_list|,
operator|&
name|mrows
argument_list|,
operator|&
name|mcols
argument_list|)
expr_stmt|;
name|menu_opts_off
argument_list|(
name|m
argument_list|,
name|O_ONEVALUE
argument_list|)
expr_stmt|;
name|menuwin
operator|=
name|newwin
argument_list|(
name|mrows
operator|+
literal|2
argument_list|,
name|mcols
operator|+
literal|2
argument_list|,
name|MENU_Y
argument_list|,
name|MENU_X
argument_list|)
expr_stmt|;
name|set_menu_win
argument_list|(
name|m
argument_list|,
name|menuwin
argument_list|)
expr_stmt|;
name|keypad
argument_list|(
name|menuwin
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|box
argument_list|(
name|menuwin
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_menu_sub
argument_list|(
name|m
argument_list|,
name|derwin
argument_list|(
name|menuwin
argument_list|,
name|mrows
argument_list|,
name|mcols
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|post_menu
argument_list|(
name|m
argument_list|)
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|menu_items
argument_list|(
name|m
argument_list|)
init|;
operator|*
name|ip
condition|;
name|ip
operator|++
control|)
block|{
name|int
name|mask
init|=
name|t_tbl
index|[
name|item_index
argument_list|(
operator|*
name|ip
argument_list|)
index|]
operator|.
name|mask
decl_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
name|set_item_value
argument_list|(
operator|*
name|ip
argument_list|,
name|_nc_tracing
operator|==
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|mask
operator|&
name|_nc_tracing
operator|)
operator|==
name|mask
condition|)
name|set_item_value
argument_list|(
operator|*
name|ip
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|run_trace_menu
argument_list|(
name|m
argument_list|)
condition|)
continue|continue;
name|newtrace
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|menu_items
argument_list|(
name|m
argument_list|)
init|;
operator|*
name|ip
condition|;
name|ip
operator|++
control|)
if|if
condition|(
name|item_value
argument_list|(
operator|*
name|ip
argument_list|)
condition|)
name|newtrace
operator||=
name|t_tbl
index|[
name|item_index
argument_list|(
operator|*
name|ip
argument_list|)
index|]
operator|.
name|mask
expr_stmt|;
name|trace
argument_list|(
name|newtrace
argument_list|)
expr_stmt|;
name|_tracef
argument_list|(
literal|"trace level interactively set to %s"
argument_list|,
name|tracetrace
argument_list|(
name|_nc_tracing
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mvprintw
argument_list|(
name|LINES
operator|-
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Trace level is %s\n"
argument_list|,
name|tracetrace
argument_list|(
name|_nc_tracing
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|addstr
argument_list|(
literal|"Press any key to continue..."
argument_list|)
expr_stmt|;
name|wGetchar
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
name|unpost_menu
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|delwin
argument_list|(
name|menuwin
argument_list|)
expr_stmt|;
name|free_menu
argument_list|(
name|m
argument_list|)
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|items
init|;
operator|*
name|ip
condition|;
name|ip
operator|++
control|)
name|free_item
argument_list|(
operator|*
name|ip
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TRACE */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_LIBMENU */
end_comment

begin_comment
comment|/****************************************************************************  *  * Forms test  *  ****************************************************************************/
end_comment

begin_if
if|#
directive|if
name|USE_LIBFORM
end_if

begin_function
specifier|static
name|FIELD
modifier|*
name|make_label
parameter_list|(
name|int
name|frow
parameter_list|,
name|int
name|fcol
parameter_list|,
name|NCURSES_CONST
name|char
modifier|*
name|label
parameter_list|)
block|{
name|FIELD
modifier|*
name|f
init|=
name|new_field
argument_list|(
literal|1
argument_list|,
name|strlen
argument_list|(
name|label
argument_list|)
argument_list|,
name|frow
argument_list|,
name|fcol
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
condition|)
block|{
name|set_field_buffer
argument_list|(
name|f
argument_list|,
literal|0
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|set_field_opts
argument_list|(
name|f
argument_list|,
name|field_opts
argument_list|(
name|f
argument_list|)
operator|&
operator|~
name|O_ACTIVE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|f
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|FIELD
modifier|*
name|make_field
parameter_list|(
name|int
name|frow
parameter_list|,
name|int
name|fcol
parameter_list|,
name|int
name|rows
parameter_list|,
name|int
name|cols
parameter_list|,
name|bool
name|secure
parameter_list|)
block|{
name|FIELD
modifier|*
name|f
init|=
name|new_field
argument_list|(
name|rows
argument_list|,
name|cols
argument_list|,
name|frow
argument_list|,
name|fcol
argument_list|,
literal|0
argument_list|,
name|secure
condition|?
literal|1
else|:
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
condition|)
block|{
name|set_field_back
argument_list|(
name|f
argument_list|,
name|A_UNDERLINE
argument_list|)
expr_stmt|;
name|set_field_userptr
argument_list|(
name|f
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|f
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|display_form
parameter_list|(
name|FORM
modifier|*
name|f
parameter_list|)
block|{
name|WINDOW
modifier|*
name|w
decl_stmt|;
name|int
name|rows
decl_stmt|,
name|cols
decl_stmt|;
name|scale_form
argument_list|(
name|f
argument_list|,
operator|&
name|rows
argument_list|,
operator|&
name|cols
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|w
operator|=
name|newwin
argument_list|(
name|rows
operator|+
literal|2
argument_list|,
name|cols
operator|+
literal|4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
operator|(
name|WINDOW
operator|*
operator|)
literal|0
condition|)
block|{
name|set_form_win
argument_list|(
name|f
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|set_form_sub
argument_list|(
name|f
argument_list|,
name|derwin
argument_list|(
name|w
argument_list|,
name|rows
argument_list|,
name|cols
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|box
argument_list|(
name|w
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|keypad
argument_list|(
name|w
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|post_form
argument_list|(
name|f
argument_list|)
operator|!=
name|E_OK
condition|)
name|wrefresh
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|erase_form
parameter_list|(
name|FORM
modifier|*
name|f
parameter_list|)
block|{
name|WINDOW
modifier|*
name|w
init|=
name|form_win
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|WINDOW
modifier|*
name|s
init|=
name|form_sub
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|unpost_form
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|werase
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|delwin
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|delwin
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|edit_secure
parameter_list|(
name|FIELD
modifier|*
name|me
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|int
name|rows
decl_stmt|,
name|cols
decl_stmt|,
name|frow
decl_stmt|,
name|fcol
decl_stmt|,
name|nrow
decl_stmt|,
name|nbuf
decl_stmt|;
if|if
condition|(
name|field_info
argument_list|(
name|me
argument_list|,
operator|&
name|rows
argument_list|,
operator|&
name|cols
argument_list|,
operator|&
name|frow
argument_list|,
operator|&
name|fcol
argument_list|,
operator|&
name|nrow
argument_list|,
operator|&
name|nbuf
argument_list|)
operator|==
name|E_OK
operator|&&
name|nbuf
operator|>
literal|0
condition|)
block|{
name|char
name|temp
index|[
literal|80
index|]
decl_stmt|;
name|long
name|len
decl_stmt|;
name|strcpy
argument_list|(
name|temp
argument_list|,
name|field_buffer
argument_list|(
name|me
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
operator|(
name|long
operator|)
operator|(
name|char
operator|*
operator|)
name|field_userptr
argument_list|(
name|me
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<=
name|KEY_MAX
condition|)
block|{
if|if
condition|(
name|isgraph
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|temp
index|[
name|len
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|temp
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|set_field_buffer
argument_list|(
name|me
argument_list|,
literal|1
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'*'
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|REQ_BEG_FIELD
case|:
case|case
name|REQ_CLR_EOF
case|:
case|case
name|REQ_CLR_EOL
case|:
case|case
name|REQ_DEL_LINE
case|:
case|case
name|REQ_DEL_WORD
case|:
case|case
name|REQ_DOWN_CHAR
case|:
case|case
name|REQ_END_FIELD
case|:
case|case
name|REQ_INS_CHAR
case|:
case|case
name|REQ_INS_LINE
case|:
case|case
name|REQ_LEFT_CHAR
case|:
case|case
name|REQ_NEW_LINE
case|:
case|case
name|REQ_NEXT_WORD
case|:
case|case
name|REQ_PREV_WORD
case|:
case|case
name|REQ_RIGHT_CHAR
case|:
case|case
name|REQ_UP_CHAR
case|:
name|c
operator|=
literal|0
expr_stmt|;
comment|/* we don't want to do inline editing */
break|break;
case|case
name|REQ_CLR_FIELD
case|:
if|if
condition|(
name|len
condition|)
block|{
name|temp
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|set_field_buffer
argument_list|(
name|me
argument_list|,
literal|1
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|REQ_DEL_CHAR
case|:
case|case
name|REQ_DEL_PREV
case|:
if|if
condition|(
name|len
condition|)
block|{
name|temp
index|[
operator|--
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|set_field_buffer
argument_list|(
name|me
argument_list|,
literal|1
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
name|set_field_userptr
argument_list|(
name|me
argument_list|,
operator|(
name|void
operator|*
operator|)
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|form_virtualize
parameter_list|(
name|FORM
modifier|*
name|f
parameter_list|,
name|WINDOW
modifier|*
name|w
parameter_list|)
block|{
specifier|static
specifier|const
struct|struct
block|{
name|int
name|code
decl_stmt|;
name|int
name|result
decl_stmt|;
block|}
name|lookup
index|[]
init|=
block|{
block|{
name|CTRL
argument_list|(
literal|'A'
argument_list|)
block|,
name|REQ_NEXT_CHOICE
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'B'
argument_list|)
block|,
name|REQ_PREV_WORD
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'C'
argument_list|)
block|,
name|REQ_CLR_EOL
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'D'
argument_list|)
block|,
name|REQ_DOWN_FIELD
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'E'
argument_list|)
block|,
name|REQ_END_FIELD
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'F'
argument_list|)
block|,
name|REQ_NEXT_PAGE
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'G'
argument_list|)
block|,
name|REQ_DEL_WORD
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'H'
argument_list|)
block|,
name|REQ_DEL_PREV
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'I'
argument_list|)
block|,
name|REQ_INS_CHAR
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'K'
argument_list|)
block|,
name|REQ_CLR_EOF
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'L'
argument_list|)
block|,
name|REQ_LEFT_FIELD
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'M'
argument_list|)
block|,
name|REQ_NEW_LINE
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'N'
argument_list|)
block|,
name|REQ_NEXT_FIELD
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'O'
argument_list|)
block|,
name|REQ_INS_LINE
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'P'
argument_list|)
block|,
name|REQ_PREV_FIELD
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'R'
argument_list|)
block|,
name|REQ_RIGHT_FIELD
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'S'
argument_list|)
block|,
name|REQ_BEG_FIELD
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'U'
argument_list|)
block|,
name|REQ_UP_FIELD
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'V'
argument_list|)
block|,
name|REQ_DEL_CHAR
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'W'
argument_list|)
block|,
name|REQ_NEXT_WORD
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'X'
argument_list|)
block|,
name|REQ_CLR_FIELD
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'Y'
argument_list|)
block|,
name|REQ_DEL_LINE
block|}
block|,
block|{
name|CTRL
argument_list|(
literal|'Z'
argument_list|)
block|,
name|REQ_PREV_CHOICE
block|}
block|,
block|{
name|ESCAPE
block|,
name|MAX_FORM_COMMAND
operator|+
literal|1
block|}
block|,
block|{
name|KEY_BACKSPACE
block|,
name|REQ_DEL_PREV
block|}
block|,
block|{
name|KEY_DOWN
block|,
name|REQ_DOWN_CHAR
block|}
block|,
block|{
name|KEY_END
block|,
name|REQ_LAST_FIELD
block|}
block|,
block|{
name|KEY_HOME
block|,
name|REQ_FIRST_FIELD
block|}
block|,
block|{
name|KEY_LEFT
block|,
name|REQ_LEFT_CHAR
block|}
block|,
block|{
name|KEY_LL
block|,
name|REQ_LAST_FIELD
block|}
block|,
block|{
name|KEY_NEXT
block|,
name|REQ_NEXT_FIELD
block|}
block|,
block|{
name|KEY_NPAGE
block|,
name|REQ_NEXT_PAGE
block|}
block|,
block|{
name|KEY_PPAGE
block|,
name|REQ_PREV_PAGE
block|}
block|,
block|{
name|KEY_PREVIOUS
block|,
name|REQ_PREV_FIELD
block|}
block|,
block|{
name|KEY_RIGHT
block|,
name|REQ_RIGHT_CHAR
block|}
block|,
block|{
name|KEY_UP
block|,
name|REQ_UP_CHAR
block|}
block|,
block|{
name|QUIT
block|,
name|MAX_FORM_COMMAND
operator|+
literal|1
block|}
block|}
struct|;
specifier|static
name|int
name|mode
init|=
name|REQ_INS_MODE
decl_stmt|;
name|int
name|c
init|=
name|wGetchar
argument_list|(
name|w
argument_list|)
decl_stmt|;
name|unsigned
name|n
decl_stmt|;
name|FIELD
modifier|*
name|me
init|=
name|current_field
argument_list|(
name|f
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|CTRL
argument_list|(
literal|']'
argument_list|)
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|REQ_INS_MODE
condition|)
name|mode
operator|=
name|REQ_OVL_MODE
expr_stmt|;
else|else
name|mode
operator|=
name|REQ_INS_MODE
expr_stmt|;
name|c
operator|=
name|mode
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
sizeof|sizeof
argument_list|(
name|lookup
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|lookup
index|[
literal|0
index|]
argument_list|)
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|lookup
index|[
name|n
index|]
operator|.
name|code
operator|==
name|c
condition|)
block|{
name|c
operator|=
name|lookup
index|[
name|n
index|]
operator|.
name|result
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/*      * Force the field that the user is typing into to be in reverse video,      * while the other fields are shown underlined.      */
if|if
condition|(
name|c
operator|<=
name|KEY_MAX
condition|)
block|{
name|c
operator|=
name|edit_secure
argument_list|(
name|me
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|set_field_back
argument_list|(
name|me
argument_list|,
name|A_REVERSE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|<=
name|MAX_FORM_COMMAND
condition|)
block|{
name|c
operator|=
name|edit_secure
argument_list|(
name|me
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|set_field_back
argument_list|(
name|me
argument_list|,
name|A_UNDERLINE
argument_list|)
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|my_form_driver
parameter_list|(
name|FORM
modifier|*
name|form
parameter_list|,
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|==
operator|(
name|MAX_FORM_COMMAND
operator|+
literal|1
operator|)
operator|&&
name|form_driver
argument_list|(
name|form
argument_list|,
name|REQ_VALIDATION
argument_list|)
operator|==
name|E_OK
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
else|else
block|{
name|beep
argument_list|()
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|demo_forms
parameter_list|(
name|void
parameter_list|)
block|{
name|WINDOW
modifier|*
name|w
decl_stmt|;
name|FORM
modifier|*
name|form
decl_stmt|;
name|FIELD
modifier|*
name|f
index|[
literal|12
index|]
decl_stmt|,
modifier|*
name|secure
decl_stmt|;
name|int
name|finished
init|=
literal|0
decl_stmt|,
name|c
decl_stmt|;
name|unsigned
name|n
init|=
literal|0
decl_stmt|;
name|move
argument_list|(
literal|18
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"Defined form-traversal keys:   ^Q/ESC- exit form\n"
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"^N   -- go to next field       ^P  -- go to previous field\n"
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"Home -- go to first field      End -- go to last field\n"
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"^L   -- go to field to left    ^R  -- go to field to right\n"
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"^U   -- move upward to field   ^D  -- move downward to field\n"
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"^W   -- go to next word        ^B  -- go to previous word\n"
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"^S   -- go to start of field   ^E  -- go to end of field\n"
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"^H   -- delete previous char   ^Y  -- delete line\n"
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"^G   -- delete current word    ^C  -- clear to end of line\n"
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"^K   -- clear to end of field  ^X  -- clear field\n"
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"Arrow keys move within a field as you would expect."
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|4
argument_list|,
literal|57
argument_list|,
literal|"Forms Entry Test"
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
comment|/* describe the form */
name|f
index|[
name|n
operator|++
index|]
operator|=
name|make_label
argument_list|(
literal|0
argument_list|,
literal|15
argument_list|,
literal|"Sample Form"
argument_list|)
expr_stmt|;
name|f
index|[
name|n
operator|++
index|]
operator|=
name|make_label
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Last Name"
argument_list|)
expr_stmt|;
name|f
index|[
name|n
operator|++
index|]
operator|=
name|make_field
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|18
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|f
index|[
name|n
operator|++
index|]
operator|=
name|make_label
argument_list|(
literal|2
argument_list|,
literal|20
argument_list|,
literal|"First Name"
argument_list|)
expr_stmt|;
name|f
index|[
name|n
operator|++
index|]
operator|=
name|make_field
argument_list|(
literal|3
argument_list|,
literal|20
argument_list|,
literal|1
argument_list|,
literal|12
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|f
index|[
name|n
operator|++
index|]
operator|=
name|make_label
argument_list|(
literal|2
argument_list|,
literal|34
argument_list|,
literal|"Middle Name"
argument_list|)
expr_stmt|;
name|f
index|[
name|n
operator|++
index|]
operator|=
name|make_field
argument_list|(
literal|3
argument_list|,
literal|34
argument_list|,
literal|1
argument_list|,
literal|12
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|f
index|[
name|n
operator|++
index|]
operator|=
name|make_label
argument_list|(
literal|5
argument_list|,
literal|0
argument_list|,
literal|"Comments"
argument_list|)
expr_stmt|;
name|f
index|[
name|n
operator|++
index|]
operator|=
name|make_field
argument_list|(
literal|6
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
literal|46
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|f
index|[
name|n
operator|++
index|]
operator|=
name|make_label
argument_list|(
literal|5
argument_list|,
literal|20
argument_list|,
literal|"Password:"
argument_list|)
expr_stmt|;
name|secure
operator|=
name|f
index|[
name|n
operator|++
index|]
operator|=
name|make_field
argument_list|(
literal|5
argument_list|,
literal|30
argument_list|,
literal|1
argument_list|,
literal|9
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|f
index|[
name|n
operator|++
index|]
operator|=
operator|(
name|FIELD
operator|*
operator|)
literal|0
expr_stmt|;
name|form
operator|=
name|new_form
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|display_form
argument_list|(
name|form
argument_list|)
expr_stmt|;
name|w
operator|=
name|form_win
argument_list|(
name|form
argument_list|)
expr_stmt|;
name|raw
argument_list|()
expr_stmt|;
name|nonl
argument_list|()
expr_stmt|;
comment|/* lets us read ^M's */
while|while
condition|(
operator|!
name|finished
condition|)
block|{
switch|switch
condition|(
name|form_driver
argument_list|(
name|form
argument_list|,
name|c
operator|=
name|form_virtualize
argument_list|(
name|form
argument_list|,
name|w
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|E_OK
case|:
name|mvaddstr
argument_list|(
literal|5
argument_list|,
literal|57
argument_list|,
name|field_buffer
argument_list|(
name|secure
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
break|break;
case|case
name|E_UNKNOWN_COMMAND
case|:
name|finished
operator|=
name|my_form_driver
argument_list|(
name|form
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
default|default:
name|beep
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
name|erase_form
argument_list|(
name|form
argument_list|)
expr_stmt|;
name|free_form
argument_list|(
name|form
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|f
index|[
name|c
index|]
operator|!=
literal|0
condition|;
name|c
operator|++
control|)
name|free_field
argument_list|(
name|f
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|noraw
argument_list|()
expr_stmt|;
name|nl
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_LIBFORM */
end_comment

begin_comment
comment|/****************************************************************************  *  * Overlap test  *  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|fillwin
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|char
name|ch
parameter_list|)
block|{
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
name|int
name|y1
decl_stmt|,
name|x1
decl_stmt|;
name|getmaxyx
argument_list|(
name|win
argument_list|,
name|y1
argument_list|,
name|x1
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|y1
condition|;
name|y
operator|++
control|)
block|{
name|wmove
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|x1
condition|;
name|x
operator|++
control|)
name|waddch
argument_list|(
name|win
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|crosswin
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|char
name|ch
parameter_list|)
block|{
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
name|int
name|y1
decl_stmt|,
name|x1
decl_stmt|;
name|getmaxyx
argument_list|(
name|win
argument_list|,
name|y1
argument_list|,
name|x1
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|y1
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|x1
condition|;
name|x
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|x
operator|>
operator|(
name|x1
operator|-
literal|1
operator|)
operator|/
literal|3
operator|)
operator|&&
operator|(
name|x
operator|<=
operator|(
literal|2
operator|*
operator|(
name|x1
operator|-
literal|1
operator|)
operator|)
operator|/
literal|3
operator|)
operator|)
operator|||
operator|(
operator|(
operator|(
name|y
operator|>
operator|(
name|y1
operator|-
literal|1
operator|)
operator|/
literal|3
operator|)
operator|&&
operator|(
name|y
operator|<=
operator|(
literal|2
operator|*
operator|(
name|y1
operator|-
literal|1
operator|)
operator|)
operator|/
literal|3
operator|)
operator|)
operator|)
condition|)
block|{
name|wmove
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|waddch
argument_list|(
name|win
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|overlap_test
parameter_list|(
name|void
parameter_list|)
comment|/* test effects of overlapping windows */
block|{
name|int
name|ch
decl_stmt|;
name|WINDOW
modifier|*
name|win1
init|=
name|newwin
argument_list|(
literal|9
argument_list|,
literal|20
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|WINDOW
modifier|*
name|win2
init|=
name|newwin
argument_list|(
literal|9
argument_list|,
literal|20
argument_list|,
literal|9
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|raw
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|move
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"This test shows the behavior of wnoutrefresh() with respect to\n"
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"the shared region of two overlapping windows A and B.  The cross\n"
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"pattern in each window does not overlap the other.\n"
argument_list|)
expr_stmt|;
name|move
argument_list|(
literal|18
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"a = refresh A, then B, then doupdate. b = refresh B, then A, then doupdaute\n"
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"c = fill window A with letter A.      d = fill window B with letter B.\n"
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"e = cross pattern in window A.        f = cross pattern in window B.\n"
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"g = clear window A.                   h = clear window B.\n"
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"i = overwrite A onto B.               j = overwrite B onto A.\n"
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"^Q/ESC = terminate test."
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|Getchar
argument_list|()
operator|)
operator|!=
name|QUIT
operator|&&
name|ch
operator|!=
name|ESCAPE
condition|)
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'a'
case|:
comment|/* refresh window A first, then B */
name|wnoutrefresh
argument_list|(
name|win1
argument_list|)
expr_stmt|;
name|wnoutrefresh
argument_list|(
name|win2
argument_list|)
expr_stmt|;
name|doupdate
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* refresh window B first, then A */
name|wnoutrefresh
argument_list|(
name|win2
argument_list|)
expr_stmt|;
name|wnoutrefresh
argument_list|(
name|win1
argument_list|)
expr_stmt|;
name|doupdate
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* fill window A so it's visible */
name|fillwin
argument_list|(
name|win1
argument_list|,
literal|'A'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* fill window B so it's visible */
name|fillwin
argument_list|(
name|win2
argument_list|,
literal|'B'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* cross test pattern in window A */
name|crosswin
argument_list|(
name|win1
argument_list|,
literal|'A'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* cross test pattern in window A */
name|crosswin
argument_list|(
name|win2
argument_list|,
literal|'B'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
comment|/* clear window A */
name|wclear
argument_list|(
name|win1
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* clear window B */
name|wclear
argument_list|(
name|win2
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* overwrite A onto B */
name|overwrite
argument_list|(
name|win1
argument_list|,
name|win2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
comment|/* overwrite B onto A */
name|overwrite
argument_list|(
name|win2
argument_list|,
name|win1
argument_list|)
expr_stmt|;
break|break;
block|}
name|delwin
argument_list|(
name|win2
argument_list|)
expr_stmt|;
name|delwin
argument_list|(
name|win1
argument_list|)
expr_stmt|;
name|erase
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  *  * Main sequence  *  ****************************************************************************/
end_comment

begin_function
specifier|static
name|bool
name|do_single_test
parameter_list|(
specifier|const
name|char
name|c
parameter_list|)
comment|/* perform a single specified test */
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|getch_test
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|attr_test
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
operator|!
name|has_colors
argument_list|()
condition|)
name|Cannot
argument_list|(
literal|"does not support color."
argument_list|)
expr_stmt|;
else|else
name|color_test
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
operator|!
name|has_colors
argument_list|()
condition|)
name|Cannot
argument_list|(
literal|"does not support color."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|can_change_color
argument_list|()
condition|)
name|Cannot
argument_list|(
literal|"has hardwired color values."
argument_list|)
expr_stmt|;
else|else
name|color_edit
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|slk_test
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|acs_display
argument_list|()
expr_stmt|;
break|break;
if|#
directive|if
name|USE_LIBPANEL
case|case
literal|'o'
case|:
name|demo_panels
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'g'
case|:
name|acs_and_scroll
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|flushinp_test
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|test_sgr_attributes
argument_list|()
expr_stmt|;
break|break;
if|#
directive|if
name|USE_LIBMENU
case|case
literal|'m'
case|:
name|menu_test
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|USE_LIBPANEL
case|case
literal|'p'
case|:
name|demo_pad
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|USE_LIBFORM
case|case
literal|'r'
case|:
name|demo_forms
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'s'
case|:
name|overlap_test
argument_list|()
expr_stmt|;
break|break;
if|#
directive|if
name|USE_LIBMENU
operator|&&
name|defined
argument_list|(
name|TRACE
argument_list|)
case|case
literal|'t'
case|:
name|trace_set
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'?'
case|:
break|break;
default|default:
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|tbl
index|[]
init|=
block|{
literal|"Usage: ncurses [options]"
block|,
literal|""
block|,
literal|"Options:"
ifdef|#
directive|ifdef
name|NCURSES_VERSION
block|,
literal|"  -a f,b   set default-colors (assumed white-on-black)"
block|,
literal|"  -d       use default-colors if terminal supports them"
endif|#
directive|endif
block|,
literal|"  -e fmt   specify format for soft-keys test (e)"
block|,
literal|"  -f       rip-off footer line (can repeat)"
block|,
literal|"  -h       rip-off header line (can repeat)"
block|,
literal|"  -s msec  specify nominal time for panel-demo (default: 1, to hold)"
ifdef|#
directive|ifdef
name|TRACE
block|,
literal|"  -t mask  specify default trace-level (may toggle with ^T)"
endif|#
directive|endif
block|}
decl_stmt|;
name|size_t
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
sizeof|sizeof
argument_list|(
name|tbl
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|tbl
index|[
literal|0
index|]
argument_list|)
condition|;
name|n
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|tbl
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_terminal_modes
parameter_list|(
name|void
parameter_list|)
block|{
name|noraw
argument_list|()
expr_stmt|;
name|cbreak
argument_list|()
expr_stmt|;
name|noecho
argument_list|()
expr_stmt|;
name|scrollok
argument_list|(
name|stdscr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|idlok
argument_list|(
name|stdscr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|keypad
argument_list|(
name|stdscr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SIGUSR1
end_ifdef

begin_function
specifier|static
name|RETSIGTYPE
name|announce_sig
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Handled signal %d\r\n"
argument_list|,
name|sig
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|rip_footer
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|int
name|columns
parameter_list|)
block|{
name|wbkgd
argument_list|(
name|win
argument_list|,
name|A_REVERSE
argument_list|)
expr_stmt|;
name|werase
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wprintw
argument_list|(
name|win
argument_list|,
literal|"footer: %d columns"
argument_list|,
name|columns
argument_list|)
expr_stmt|;
name|wnoutrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rip_header
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|int
name|columns
parameter_list|)
block|{
name|wbkgd
argument_list|(
name|win
argument_list|,
name|A_REVERSE
argument_list|)
expr_stmt|;
name|werase
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wprintw
argument_list|(
name|win
argument_list|,
literal|"header: %d columns"
argument_list|,
name|columns
argument_list|)
expr_stmt|;
name|wnoutrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*+------------------------------------------------------------------------- 	main(argc,argv) --------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|command
decl_stmt|,
name|c
decl_stmt|;
name|int
name|my_e_param
init|=
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|NCURSES_VERSION
name|int
name|default_fg
init|=
name|COLOR_WHITE
decl_stmt|;
name|int
name|default_bg
init|=
name|COLOR_BLACK
decl_stmt|;
name|bool
name|assumed_colors
init|=
name|FALSE
decl_stmt|;
name|bool
name|default_colors
init|=
name|FALSE
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_LOCALE_H
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"a:de:fhs:t:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
ifdef|#
directive|ifdef
name|NCURSES_VERSION
case|case
literal|'a'
case|:
name|assumed_colors
operator|=
name|TRUE
expr_stmt|;
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%d,%d"
argument_list|,
operator|&
name|default_fg
argument_list|,
operator|&
name|default_bg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|default_colors
operator|=
name|TRUE
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'e'
case|:
name|my_e_param
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NCURSES_VERSION
if|if
condition|(
name|my_e_param
operator|>
literal|3
condition|)
comment|/* allow extended layouts */
name|usage
argument_list|()
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|my_e_param
operator|>
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'f'
case|:
name|ripoffline
argument_list|(
operator|-
literal|1
argument_list|,
name|rip_footer
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|ripoffline
argument_list|(
literal|1
argument_list|,
name|rip_header
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|USE_LIBPANEL
case|case
literal|'s'
case|:
name|nap_msec
operator|=
name|atol
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TRACE
case|case
literal|'t'
case|:
name|save_trace
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*      * If there's no menus (unlikely for ncurses!), then we'll have to set      * tracing on initially, just in case the user wants to test something that      * doesn't involve wGetchar.      */
ifdef|#
directive|ifdef
name|TRACE
comment|/* enable debugging */
if|#
directive|if
operator|!
name|USE_LIBMENU
name|trace
argument_list|(
name|save_trace
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
condition|)
name|trace
argument_list|(
name|save_trace
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_LIBMENU */
endif|#
directive|endif
comment|/* TRACE */
comment|/* tell it we're going to play with soft keys */
name|slk_init
argument_list|(
name|my_e_param
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGUSR1
comment|/* set up null signal catcher so we can see what interrupts to getch do */
name|signal
argument_list|(
name|SIGUSR1
argument_list|,
name|announce_sig
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* we must initialize the curses data structure only once */
name|initscr
argument_list|()
expr_stmt|;
name|bkgdset
argument_list|(
name|BLANK
argument_list|)
expr_stmt|;
comment|/* tests, in general, will want these modes */
if|if
condition|(
name|has_colors
argument_list|()
condition|)
block|{
name|start_color
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|NCURSES_VERSION
if|if
condition|(
name|default_colors
condition|)
name|use_default_colors
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|assumed_colors
condition|)
name|assume_default_colors
argument_list|(
name|default_fg
argument_list|,
name|default_bg
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|set_terminal_modes
argument_list|()
expr_stmt|;
name|def_prog_mode
argument_list|()
expr_stmt|;
comment|/*      * Return to terminal mode, so we're guaranteed of being able to      * select terminal commands even if the capabilities are wrong.      */
name|endwin
argument_list|()
expr_stmt|;
if|#
directive|if
name|HAVE_CURSES_VERSION
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Welcome to %s.  Press ? for help.\n"
argument_list|,
name|curses_version
argument_list|()
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|NCURSES_VERSION_MAJOR
argument_list|)
operator|&&
name|defined
argument_list|(
name|NCURSES_VERSION_MINOR
argument_list|)
operator|&&
name|defined
argument_list|(
name|NCURSES_VERSION_PATCH
argument_list|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Welcome to ncurses %d.%d.%d.  Press ? for help.\n"
argument_list|,
name|NCURSES_VERSION_MAJOR
argument_list|,
name|NCURSES_VERSION_MINOR
argument_list|,
name|NCURSES_VERSION_PATCH
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"Welcome to ncurses.  Press ? for help."
argument_list|)
expr_stmt|;
endif|#
directive|endif
do|do
block|{
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"This is the ncurses main menu"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"a = keyboard and mouse input test"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"b = character attribute test"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"c = color test pattern"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"d = edit RGB color values"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"e = exercise soft keys"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"f = display ACS characters"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"g = display windows and scrolling"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"i = test of flushinp()"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"k = display character attributes"
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_LIBMENU
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"m = menu code test"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|USE_LIBPANEL
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"o = exercise panels library"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"p = exercise pad features"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"q = quit"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|USE_LIBFORM
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"r = exercise forms code"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"s = overlapping-refresh test"
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_LIBMENU
operator|&&
name|defined
argument_list|(
name|TRACE
argument_list|)
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"t = set trace level"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"? = repeat this command summary"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"> "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* necessary under SVr4 curses */
comment|/* 	 * This used to be an 'fgets()' call.  However (on Linux, at least) 	 * mixing stream I/O and 'read()' (used in the library) causes the 	 * input stream to be flushed when switching between the two. 	 */
name|command
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|ch
decl_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|ch
argument_list|,
literal|1
argument_list|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|command
operator|==
literal|0
condition|)
name|command
operator|=
literal|'q'
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|command
operator|==
literal|0
operator|&&
operator|!
name|isspace
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|command
operator|=
name|ch
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\n'
operator|||
name|ch
operator|==
literal|'\r'
condition|)
block|{
if|if
condition|(
name|command
operator|!=
literal|0
condition|)
break|break;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"> "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|do_single_test
argument_list|(
name|command
argument_list|)
condition|)
block|{
comment|/* 	     * This may be overkill; it's intended to reset everything back 	     * to the initial terminal modes so that tests don't get in 	     * each other's way. 	     */
name|flushinp
argument_list|()
expr_stmt|;
name|set_terminal_modes
argument_list|()
expr_stmt|;
name|reset_prog_mode
argument_list|()
expr_stmt|;
name|clear
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
if|if
condition|(
name|command
operator|==
literal|'?'
condition|)
block|{
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"This is the ncurses capability tester."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"You may select a test from the main menu by typing the"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"key letter of the choice (the letter to left of the =)"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"at the> prompt.  The commands `x' or `q' will exit."
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
block|}
do|while
condition|(
name|command
operator|!=
literal|'q'
condition|)
do|;
name|ExitProgram
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ncurses.c ends here */
end_comment

end_unit

