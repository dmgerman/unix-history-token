begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************************  * Copyright (c) 1998-2005,2006 Free Software Foundation, Inc.              *  *                                                                          *  * Permission is hereby granted, free of charge, to any person obtaining a  *  * copy of this software and associated documentation files (the            *  * "Software"), to deal in the Software without restriction, including      *  * without limitation the rights to use, copy, modify, merge, publish,      *  * distribute, distribute with modifications, sublicense, and/or sell       *  * copies of the Software, and to permit persons to whom the Software is    *  * furnished to do so, subject to the following conditions:                 *  *                                                                          *  * The above copyright notice and this permission notice shall be included  *  * in all copies or substantial portions of the Software.                   *  *                                                                          *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *  * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *  * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *  *                                                                          *  * Except as contained in this notice, the name(s) of the above copyright   *  * holders shall not be used in advertising or otherwise to promote the     *  * sale, use or other dealings in this Software without prior written       *  * authorization.                                                           *  ****************************************************************************/
end_comment

begin_comment
comment|/****************************************************************************  *  Author: Zeyd M. Ben-Halim<zmbenhal@netcom.com> 1992,1995               *  *     and: Eric S. Raymond<esr@snark.thyrsus.com>                         *  *     and: Thomas E. Dickey                        1996-on                 *  ****************************************************************************/
end_comment

begin_comment
comment|/*-----------------------------------------------------------------  *  *	lib_doupdate.c  *  * 	The routine doupdate() and its dependents.  * 	All physical output is concentrated here (except _nc_outch()   *	in lib_tputs.c).  *  *-----------------------------------------------------------------*/
end_comment

begin_include
include|#
directive|include
file|<curses.priv.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__BEOS__
end_ifdef

begin_undef
undef|#
directive|undef
name|false
end_undef

begin_undef
undef|#
directive|undef
name|true
end_undef

begin_include
include|#
directive|include
file|<OS.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TRACE
argument_list|)
operator|&&
name|HAVE_SYS_TIMES_H
operator|&&
name|HAVE_TIMES
end_if

begin_define
define|#
directive|define
name|USE_TRACE_TIMES
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|USE_TRACE_TIMES
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_SYS_TIME_H
operator|&&
name|HAVE_SYS_TIME_SELECT
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|USE_TRACE_TIMES
end_if

begin_include
include|#
directive|include
file|<sys/times.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|USE_FUNC_POLL
end_if

begin_elif
elif|#
directive|elif
name|HAVE_SELECT
end_elif

begin_if
if|#
directive|if
name|HAVE_SYS_SELECT_H
end_if

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<term.h>
end_include

begin_macro
name|MODULE_ID
argument_list|(
literal|"$Id: tty_update.c,v 1.238 2006/11/25 22:33:21 tom Exp $"
argument_list|)
end_macro

begin_comment
comment|/*  * This define controls the line-breakout optimization.  Every once in a  * while during screen refresh, we want to check for input and abort the  * update if there's some waiting.  CHECK_INTERVAL controls the number of  * changed lines to be emitted between input checks.  *  * Note: Input-check-and-abort is no longer done if the screen is being  * updated from scratch.  This is a feature, not a bug.  */
end_comment

begin_define
define|#
directive|define
name|CHECK_INTERVAL
value|5
end_define

begin_define
define|#
directive|define
name|FILL_BCE
parameter_list|()
value|(SP->_coloron&& !SP->_default_color&& !back_color_erase)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|NCURSES_CH_T
name|blankchar
init|=
name|NewChar
argument_list|(
name|BLANK_TEXT
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|NCURSES_CH_T
name|normal
init|=
name|NewChar
argument_list|(
name|BLANK_TEXT
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Enable checking to see if doupdate and friends are tracking the true  * cursor position correctly.  NOTE: this is a debugging hack which will  * work ONLY on ANSI-compatible terminals!  */
end_comment

begin_comment
comment|/* #define POSITION_DEBUG */
end_comment

begin_function_decl
specifier|static
name|NCURSES_INLINE
name|NCURSES_CH_T
name|ClrBlank
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ClrBottom
parameter_list|(
name|int
name|total
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ClearScreen
parameter_list|(
name|NCURSES_CH_T
name|blank
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ClrUpdate
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|DelChar
parameter_list|(
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|InsStr
parameter_list|(
name|NCURSES_CH_T
modifier|*
name|line
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|TransformLine
parameter_list|(
name|int
specifier|const
name|lineno
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|POSITION_DEBUG
end_ifdef

begin_comment
comment|/****************************************************************************  *  * Debugging code.  Only works on ANSI-standard terminals.  *  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|position_check
parameter_list|(
name|int
name|expected_y
parameter_list|,
name|int
name|expected_x
parameter_list|,
name|char
modifier|*
name|legend
parameter_list|)
comment|/* check to see if the real cursor position matches the virtual */
block|{
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
if|if
condition|(
operator|!
name|_nc_tracing
operator|||
operator|(
name|expected_y
operator|<
literal|0
operator|&&
name|expected_x
operator|<
literal|0
operator|)
condition|)
return|return;
name|_nc_flush
argument_list|()
expr_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|putp
argument_list|(
literal|"\033[6n"
argument_list|)
expr_stmt|;
comment|/* only works on ANSI-compatibles */
name|_nc_flush
argument_list|()
expr_stmt|;
operator|*
operator|(
name|s
operator|=
name|buf
operator|)
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|int
name|ask
init|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
operator|-
operator|(
name|s
operator|-
name|buf
operator|)
decl_stmt|;
name|int
name|got
init|=
name|read
argument_list|(
literal|0
argument_list|,
name|s
argument_list|,
name|ask
argument_list|)
decl_stmt|;
if|if
condition|(
name|got
operator|==
literal|0
condition|)
break|break;
name|s
operator|+=
name|got
expr_stmt|;
block|}
do|while
condition|(
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'R'
argument_list|)
operator|==
literal|0
condition|)
do|;
name|_tracef
argument_list|(
literal|"probe returned %s"
argument_list|,
name|_nc_visbuf
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* try to interpret as a position report */
if|if
condition|(
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"\033[%d;%dR"
argument_list|,
operator|&
name|y
argument_list|,
operator|&
name|x
argument_list|)
operator|!=
literal|2
condition|)
block|{
name|_tracef
argument_list|(
literal|"position probe failed in %s"
argument_list|,
name|legend
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|expected_x
operator|<
literal|0
condition|)
name|expected_x
operator|=
name|x
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|expected_y
operator|<
literal|0
condition|)
name|expected_y
operator|=
name|y
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|y
operator|-
literal|1
operator|!=
name|expected_y
operator|||
name|x
operator|-
literal|1
operator|!=
name|expected_x
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
name|tputs
argument_list|(
name|tparm
argument_list|(
literal|"\033[%d;%dH"
argument_list|,
name|expected_y
operator|+
literal|1
argument_list|,
name|expected_x
operator|+
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|,
name|_nc_outch
argument_list|)
expr_stmt|;
name|_tracef
argument_list|(
literal|"position seen (%d, %d) doesn't match expected one (%d, %d) in %s"
argument_list|,
name|y
operator|-
literal|1
argument_list|,
name|x
operator|-
literal|1
argument_list|,
name|expected_y
argument_list|,
name|expected_x
argument_list|,
name|legend
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|_tracef
argument_list|(
literal|"position matches OK in %s"
argument_list|,
name|legend
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|position_check
parameter_list|(
name|expected_y
parameter_list|,
name|expected_x
parameter_list|,
name|legend
parameter_list|)
end_define

begin_comment
comment|/* nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* POSITION_DEBUG */
end_comment

begin_comment
comment|/****************************************************************************  *  * Optimized update code  *  ****************************************************************************/
end_comment

begin_function
specifier|static
name|NCURSES_INLINE
name|void
name|GoTo
parameter_list|(
name|int
specifier|const
name|row
parameter_list|,
name|int
specifier|const
name|col
parameter_list|)
block|{
name|TR
argument_list|(
name|TRACE_MOVE
argument_list|,
operator|(
literal|"GoTo(%d, %d) from (%d, %d)"
operator|,
name|row
operator|,
name|col
operator|,
name|SP
operator|->
name|_cursrow
operator|,
name|SP
operator|->
name|_curscol
operator|)
argument_list|)
expr_stmt|;
name|position_check
argument_list|(
name|SP
operator|->
name|_cursrow
argument_list|,
name|SP
operator|->
name|_curscol
argument_list|,
literal|"GoTo"
argument_list|)
expr_stmt|;
name|mvcur
argument_list|(
name|SP
operator|->
name|_cursrow
argument_list|,
name|SP
operator|->
name|_curscol
argument_list|,
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|position_check
argument_list|(
name|SP
operator|->
name|_cursrow
argument_list|,
name|SP
operator|->
name|_curscol
argument_list|,
literal|"GoTo2"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|NCURSES_INLINE
name|void
name|PutAttrChar
parameter_list|(
name|CARG_CH_T
name|ch
parameter_list|)
block|{
name|int
name|chlen
init|=
literal|1
decl_stmt|;
name|NCURSES_CH_T
name|my_ch
decl_stmt|;
name|PUTC_DATA
expr_stmt|;
name|NCURSES_CH_T
name|tilde
decl_stmt|;
name|NCURSES_CH_T
name|attr
init|=
name|CHDEREF
argument_list|(
name|ch
argument_list|)
decl_stmt|;
name|TR
argument_list|(
name|TRACE_CHARPUT
argument_list|,
operator|(
literal|"PutAttrChar(%s) at (%d, %d)"
operator|,
name|_tracech_t
argument_list|(
name|ch
argument_list|)
operator|,
name|SP
operator|->
name|_cursrow
operator|,
name|SP
operator|->
name|_curscol
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_WIDEC_SUPPORT
comment|/*      * If this is not a valid character, there is nothing more to do.      */
if|if
condition|(
name|isWidecExt
argument_list|(
name|CHDEREF
argument_list|(
name|ch
argument_list|)
argument_list|)
condition|)
block|{
name|TR
argument_list|(
name|TRACE_CHARPUT
argument_list|,
operator|(
literal|"...skip"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * Determine the number of character cells which the 'ch' value will use      * on the screen.  It should be at least one.      */
if|if
condition|(
operator|(
name|chlen
operator|=
name|wcwidth
argument_list|(
name|CharOf
argument_list|(
name|CHDEREF
argument_list|(
name|ch
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
specifier|static
specifier|const
name|NCURSES_CH_T
name|blank
init|=
name|NewChar
argument_list|(
name|BLANK_TEXT
argument_list|)
decl_stmt|;
comment|/* 	 * If the character falls into any of these special cases, do 	 * not force the result to a blank: 	 * 	 * a) it is printable (this works around a bug in wcwidth()). 	 * b) use_legacy_coding() has been called to modify the treatment 	 *    of codes 128-255. 	 * c) the acs_map[] has been initialized to allow codes 0-31 	 *    to be rendered.  This supports Linux console's "PC" 	 *    characters.  Codes 128-255 are allowed though this is 	 *    not checked. 	 */
if|if
condition|(
name|is8bits
argument_list|(
name|CharOf
argument_list|(
name|CHDEREF
argument_list|(
name|ch
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|(
name|isprint
argument_list|(
name|CharOf
argument_list|(
name|CHDEREF
argument_list|(
name|ch
argument_list|)
argument_list|)
argument_list|)
operator|||
operator|(
name|SP
operator|->
name|_legacy_coding
operator|>
literal|0
operator|&&
name|CharOf
argument_list|(
name|CHDEREF
argument_list|(
name|ch
argument_list|)
argument_list|)
operator|>=
literal|160
operator|)
operator|||
operator|(
name|SP
operator|->
name|_legacy_coding
operator|>
literal|1
operator|&&
name|CharOf
argument_list|(
name|CHDEREF
argument_list|(
name|ch
argument_list|)
argument_list|)
operator|>=
literal|128
operator|)
operator|||
operator|(
name|AttrOf
argument_list|(
name|attr
argument_list|)
operator|&
name|A_ALTCHARSET
operator|&&
operator|(
operator|(
name|CharOfD
argument_list|(
name|ch
argument_list|)
operator|<
name|ACS_LEN
operator|&&
name|SP
operator|->
name|_acs_map
operator|!=
literal|0
operator|&&
name|SP
operator|->
name|_acs_map
index|[
name|CharOfD
argument_list|(
name|ch
argument_list|)
index|]
operator|!=
literal|0
operator|)
operator|||
operator|(
name|CharOfD
argument_list|(
name|ch
argument_list|)
operator|>=
literal|128
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
empty_stmt|;
block|}
else|else
block|{
name|ch
operator|=
name|CHREF
argument_list|(
name|blank
argument_list|)
expr_stmt|;
name|TR
argument_list|(
name|TRACE_CHARPUT
argument_list|,
operator|(
literal|"forced to blank"
operator|)
argument_list|)
expr_stmt|;
block|}
name|chlen
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|AttrOf
argument_list|(
name|attr
argument_list|)
operator|&
name|A_ALTCHARSET
operator|)
operator|&&
name|SP
operator|->
name|_acs_map
operator|!=
literal|0
operator|&&
name|CharOfD
argument_list|(
name|ch
argument_list|)
operator|<
name|ACS_LEN
condition|)
block|{
name|my_ch
operator|=
name|CHDEREF
argument_list|(
name|ch
argument_list|)
expr_stmt|;
comment|/* work around const param */
if|#
directive|if
name|USE_WIDEC_SUPPORT
comment|/* 	 * This is crude& ugly, but works most of the time.  It checks if the 	 * acs_chars string specified that we have a mapping for this 	 * character, and uses the wide-character mapping when we expect the 	 * normal one to be broken (by mis-design ;-). 	 */
if|if
condition|(
name|SP
operator|->
name|_screen_acs_fix
operator|&&
name|SP
operator|->
name|_screen_acs_map
index|[
name|CharOf
argument_list|(
name|my_ch
argument_list|)
index|]
condition|)
block|{
name|RemAttr
argument_list|(
name|attr
argument_list|,
name|A_ALTCHARSET
argument_list|)
expr_stmt|;
name|my_ch
operator|=
name|_nc_wacs
index|[
name|CharOf
argument_list|(
name|my_ch
argument_list|)
index|]
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * If we (still) have alternate character set, it is the normal 8bit 	 * flavor.  The _screen_acs_map[] array tells if the character was 	 * really in acs_chars, needed because of the way wide/normal line 	 * drawing flavors are integrated. 	 */
if|if
condition|(
name|AttrOf
argument_list|(
name|attr
argument_list|)
operator|&
name|A_ALTCHARSET
condition|)
block|{
name|int
name|j
init|=
name|CharOfD
argument_list|(
name|ch
argument_list|)
decl_stmt|;
name|chtype
name|temp
init|=
name|UChar
argument_list|(
name|SP
operator|->
name|_acs_map
index|[
name|j
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|SP
operator|->
name|_screen_acs_map
index|[
name|j
index|]
operator|)
condition|)
block|{
name|RemAttr
argument_list|(
name|attr
argument_list|,
name|A_ALTCHARSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|temp
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
name|SetChar
argument_list|(
name|my_ch
argument_list|,
name|temp
argument_list|,
name|AttrOf
argument_list|(
name|attr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ch
operator|=
name|CHREF
argument_list|(
name|my_ch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tilde_glitch
operator|&&
operator|(
name|CharOfD
argument_list|(
name|ch
argument_list|)
operator|==
name|L
argument_list|(
literal|'~'
argument_list|)
operator|)
condition|)
block|{
name|SetChar
argument_list|(
name|tilde
argument_list|,
name|L
argument_list|(
literal|'`'
argument_list|)
argument_list|,
name|AttrOf
argument_list|(
name|attr
argument_list|)
argument_list|)
expr_stmt|;
name|ch
operator|=
name|CHREF
argument_list|(
name|tilde
argument_list|)
expr_stmt|;
block|}
name|UpdateAttrs
argument_list|(
name|attr
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|USE_WIDEC_SUPPORT
comment|/* FIXME - we do this special case for signal handling, should see how to      * make it work for wide characters.      */
if|if
condition|(
name|SP
operator|->
name|_outch
operator|!=
literal|0
condition|)
block|{
name|SP
operator|->
name|_outch
argument_list|(
name|UChar
argument_list|(
name|ch
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|PUTC
argument_list|(
name|CHDEREF
argument_list|(
name|ch
argument_list|)
argument_list|,
name|SP
operator|->
name|_ofp
argument_list|)
expr_stmt|;
comment|/* macro's fastest... */
name|TRACE_OUTCHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|SP
operator|->
name|_curscol
operator|+=
name|chlen
expr_stmt|;
if|if
condition|(
name|char_padding
condition|)
block|{
name|TPUTS_TRACE
argument_list|(
literal|"char_padding"
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|char_padding
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|check_pending
parameter_list|(
name|void
parameter_list|)
comment|/* check for pending input */
block|{
name|bool
name|have_pending
init|=
name|FALSE
decl_stmt|;
comment|/*      * Only carry out this check when the flag is zero, otherwise we'll      * have the refreshing slow down drastically (or stop) if there's an      * unread character available.      */
if|if
condition|(
name|SP
operator|->
name|_fifohold
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|SP
operator|->
name|_checkfd
operator|>=
literal|0
condition|)
block|{
if|#
directive|if
name|USE_FUNC_POLL
name|struct
name|pollfd
name|fds
index|[
literal|1
index|]
decl_stmt|;
name|fds
index|[
literal|0
index|]
operator|.
name|fd
operator|=
name|SP
operator|->
name|_checkfd
expr_stmt|;
name|fds
index|[
literal|0
index|]
operator|.
name|events
operator|=
name|POLLIN
expr_stmt|;
if|if
condition|(
name|poll
argument_list|(
name|fds
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
block|{
name|have_pending
operator|=
name|TRUE
expr_stmt|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|__BEOS__
argument_list|)
comment|/* 	 * BeOS's select() is declared in socket.h, so the configure script does 	 * not see it.  That's just as well, since that function works only for 	 * sockets.  This (using snooze and ioctl) was distilled from Be's patch 	 * for ncurses which uses a separate thread to simulate select(). 	 * 	 * FIXME: the return values from the ioctl aren't very clear if we get 	 * interrupted. 	 */
name|int
name|n
init|=
literal|0
decl_stmt|;
name|int
name|howmany
init|=
name|ioctl
argument_list|(
literal|0
argument_list|,
literal|'ichr'
argument_list|,
operator|&
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|howmany
operator|>=
literal|0
operator|&&
name|n
operator|>
literal|0
condition|)
block|{
name|have_pending
operator|=
name|TRUE
expr_stmt|;
block|}
elif|#
directive|elif
name|HAVE_SELECT
name|fd_set
name|fdset
decl_stmt|;
name|struct
name|timeval
name|ktimeout
decl_stmt|;
name|ktimeout
operator|.
name|tv_sec
operator|=
name|ktimeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fdset
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|SP
operator|->
name|_checkfd
argument_list|,
operator|&
name|fdset
argument_list|)
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
name|SP
operator|->
name|_checkfd
operator|+
literal|1
argument_list|,
operator|&
name|fdset
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|ktimeout
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|have_pending
operator|=
name|TRUE
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|have_pending
condition|)
block|{
name|SP
operator|->
name|_fifohold
operator|=
literal|5
expr_stmt|;
name|_nc_flush
argument_list|()
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* put char at lower right corner */
end_comment

begin_function
specifier|static
name|void
name|PutCharLR
parameter_list|(
specifier|const
name|ARG_CH_T
name|ch
parameter_list|)
block|{
if|if
condition|(
operator|!
name|auto_right_margin
condition|)
block|{
comment|/* we can put the char directly */
name|PutAttrChar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|enter_am_mode
operator|&&
name|exit_am_mode
condition|)
block|{
comment|/* we can suppress automargin */
name|TPUTS_TRACE
argument_list|(
literal|"exit_am_mode"
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|exit_am_mode
argument_list|)
expr_stmt|;
name|PutAttrChar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|SP
operator|->
name|_curscol
operator|--
expr_stmt|;
name|position_check
argument_list|(
name|SP
operator|->
name|_cursrow
argument_list|,
name|SP
operator|->
name|_curscol
argument_list|,
literal|"exit_am_mode"
argument_list|)
expr_stmt|;
name|TPUTS_TRACE
argument_list|(
literal|"enter_am_mode"
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|enter_am_mode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|enter_insert_mode
operator|&&
name|exit_insert_mode
operator|)
operator|||
name|insert_character
operator|||
name|parm_ich
condition|)
block|{
name|GoTo
argument_list|(
name|screen_lines
operator|-
literal|1
argument_list|,
name|screen_columns
operator|-
literal|2
argument_list|)
expr_stmt|;
name|PutAttrChar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|GoTo
argument_list|(
name|screen_lines
operator|-
literal|1
argument_list|,
name|screen_columns
operator|-
literal|2
argument_list|)
expr_stmt|;
name|InsStr
argument_list|(
name|newscr
operator|->
name|_line
index|[
name|screen_lines
operator|-
literal|1
index|]
operator|.
name|text
operator|+
name|screen_columns
operator|-
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Wrap the cursor position, i.e., advance to the beginning of the next line.  */
end_comment

begin_function
specifier|static
name|void
name|wrap_cursor
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|eat_newline_glitch
condition|)
block|{
comment|/* 	 * xenl can manifest two different ways.  The vt100 way is that, when 	 * you'd expect the cursor to wrap, it stays hung at the right margin 	 * (on top of the character just emitted) and doesn't wrap until the 	 * *next* graphic char is emitted.  The c100 way is to ignore LF 	 * received just after an am wrap. 	 * 	 * An aggressive way to handle this would be to emit CR/LF after the 	 * char and then assume the wrap is done, you're on the first position 	 * of the next line, and the terminal out of its weird state.  Here 	 * it's safe to just tell the code that the cursor is in hyperspace and 	 * let the next mvcur() call straighten things out. 	 */
name|SP
operator|->
name|_curscol
operator|=
operator|-
literal|1
expr_stmt|;
name|SP
operator|->
name|_cursrow
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|auto_right_margin
condition|)
block|{
name|SP
operator|->
name|_curscol
operator|=
literal|0
expr_stmt|;
name|SP
operator|->
name|_cursrow
operator|++
expr_stmt|;
comment|/* 	 * We've actually moved - but may have to work around problems with 	 * video attributes not working. 	 */
if|if
condition|(
operator|!
name|move_standout_mode
operator|&&
name|AttrOf
argument_list|(
name|SCREEN_ATTRS
argument_list|(
name|SP
argument_list|)
argument_list|)
condition|)
block|{
name|TR
argument_list|(
name|TRACE_CHARPUT
argument_list|,
operator|(
literal|"turning off (%#lx) %s before wrapping"
operator|,
operator|(
name|unsigned
name|long
operator|)
name|AttrOf
argument_list|(
name|SCREEN_ATTRS
argument_list|(
name|SP
argument_list|)
argument_list|)
operator|,
name|_traceattr
argument_list|(
name|AttrOf
argument_list|(
name|SCREEN_ATTRS
argument_list|(
name|SP
argument_list|)
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|VIDATTR
argument_list|(
name|A_NORMAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|SP
operator|->
name|_curscol
operator|--
expr_stmt|;
block|}
name|position_check
argument_list|(
name|SP
operator|->
name|_cursrow
argument_list|,
name|SP
operator|->
name|_curscol
argument_list|,
literal|"wrap_cursor"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|NCURSES_INLINE
name|void
name|PutChar
parameter_list|(
specifier|const
name|ARG_CH_T
name|ch
parameter_list|)
comment|/* insert character, handling automargin stuff */
block|{
if|if
condition|(
name|SP
operator|->
name|_cursrow
operator|==
name|screen_lines
operator|-
literal|1
operator|&&
name|SP
operator|->
name|_curscol
operator|==
name|screen_columns
operator|-
literal|1
condition|)
name|PutCharLR
argument_list|(
name|ch
argument_list|)
expr_stmt|;
else|else
name|PutAttrChar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|SP
operator|->
name|_curscol
operator|>=
name|screen_columns
condition|)
name|wrap_cursor
argument_list|()
expr_stmt|;
name|position_check
argument_list|(
name|SP
operator|->
name|_cursrow
argument_list|,
name|SP
operator|->
name|_curscol
argument_list|,
literal|"PutChar"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check whether the given character can be output by clearing commands.  This  * includes test for being a space and not including any 'bad' attributes, such  * as A_REVERSE.  All attribute flags which don't affect appearance of a space  * or can be output by clearing (A_COLOR in case of bce-terminal) are excluded.  */
end_comment

begin_function
specifier|static
name|NCURSES_INLINE
name|bool
name|can_clear_with
parameter_list|(
name|ARG_CH_T
name|ch
parameter_list|)
block|{
if|if
condition|(
operator|!
name|back_color_erase
operator|&&
name|SP
operator|->
name|_coloron
condition|)
block|{
if|#
directive|if
name|NCURSES_EXT_FUNCS
name|int
name|pair
decl_stmt|;
if|if
condition|(
operator|!
name|SP
operator|->
name|_default_color
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|SP
operator|->
name|_default_fg
operator|!=
name|C_MASK
operator|||
name|SP
operator|->
name|_default_bg
operator|!=
name|C_MASK
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
name|pair
operator|=
name|GetPair
argument_list|(
name|CHDEREF
argument_list|(
name|ch
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|short
name|fg
decl_stmt|,
name|bg
decl_stmt|;
name|pair_content
argument_list|(
name|pair
argument_list|,
operator|&
name|fg
argument_list|,
operator|&
name|bg
argument_list|)
expr_stmt|;
if|if
condition|(
name|fg
operator|!=
name|C_MASK
operator|||
name|bg
operator|!=
name|C_MASK
condition|)
return|return
name|FALSE
return|;
block|}
else|#
directive|else
if|if
condition|(
name|AttrOfD
argument_list|(
name|ch
argument_list|)
operator|&
name|A_COLOR
condition|)
return|return
name|FALSE
return|;
endif|#
directive|endif
block|}
return|return
operator|(
name|ISBLANK
argument_list|(
name|CHDEREF
argument_list|(
name|ch
argument_list|)
argument_list|)
operator|&&
operator|(
name|AttrOfD
argument_list|(
name|ch
argument_list|)
operator|&
operator|~
operator|(
name|NONBLANK_ATTR
operator||
name|A_COLOR
operator|)
operator|)
operator|==
name|BLANK_ATTR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Issue a given span of characters from an array.  * Must be functionally equivalent to:  *	for (i = 0; i< num; i++)  *	    PutChar(ntext[i]);  * but can leave the cursor positioned at the middle of the interval.  *  * Returns: 0 - cursor is at the end of interval  *	    1 - cursor is somewhere in the middle  *  * This code is optimized using ech and rep.  */
end_comment

begin_function
specifier|static
name|int
name|EmitRange
parameter_list|(
specifier|const
name|NCURSES_CH_T
modifier|*
name|ntext
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|TR
argument_list|(
name|TRACE_CHARPUT
argument_list|,
operator|(
literal|"EmitRange %d:%s"
operator|,
name|num
operator|,
name|_nc_viscbuf
argument_list|(
name|ntext
argument_list|,
name|num
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|erase_chars
operator|||
name|repeat_char
condition|)
block|{
while|while
condition|(
name|num
operator|>
literal|0
condition|)
block|{
name|int
name|runcount
decl_stmt|;
name|NCURSES_CH_T
name|ntext0
decl_stmt|;
while|while
condition|(
name|num
operator|>
literal|1
operator|&&
operator|!
name|CharEq
argument_list|(
name|ntext
index|[
literal|0
index|]
argument_list|,
name|ntext
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|PutChar
argument_list|(
name|CHREF
argument_list|(
name|ntext
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ntext
operator|++
expr_stmt|;
name|num
operator|--
expr_stmt|;
block|}
name|ntext0
operator|=
name|ntext
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|num
operator|==
literal|1
condition|)
block|{
name|PutChar
argument_list|(
name|CHREF
argument_list|(
name|ntext0
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|runcount
operator|=
literal|2
expr_stmt|;
while|while
condition|(
name|runcount
operator|<
name|num
operator|&&
name|CharEq
argument_list|(
name|ntext
index|[
name|runcount
index|]
argument_list|,
name|ntext0
argument_list|)
condition|)
name|runcount
operator|++
expr_stmt|;
comment|/* 	     * The cost expression in the middle isn't exactly right. 	     * _cup_ch_cost is an upper bound on the cost for moving to the 	     * end of the erased area, but not the cost itself (which we 	     * can't compute without emitting the move).  This may result 	     * in erase_chars not getting used in some situations for 	     * which it would be marginally advantageous. 	     */
if|if
condition|(
name|erase_chars
operator|&&
name|runcount
operator|>
name|SP
operator|->
name|_ech_cost
operator|+
name|SP
operator|->
name|_cup_ch_cost
operator|&&
name|can_clear_with
argument_list|(
name|CHREF
argument_list|(
name|ntext0
argument_list|)
argument_list|)
condition|)
block|{
name|UpdateAttrs
argument_list|(
name|ntext0
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|TPARM_1
argument_list|(
name|erase_chars
argument_list|,
name|runcount
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * If this is the last part of the given interval, 		 * don't bother moving cursor, since it can be the 		 * last update on the line. 		 */
if|if
condition|(
name|runcount
operator|<
name|num
condition|)
block|{
name|GoTo
argument_list|(
name|SP
operator|->
name|_cursrow
argument_list|,
name|SP
operator|->
name|_curscol
operator|+
name|runcount
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
literal|1
return|;
comment|/* cursor stays in the middle */
block|}
block|}
elseif|else
if|if
condition|(
name|repeat_char
operator|&&
name|runcount
operator|>
name|SP
operator|->
name|_rep_cost
condition|)
block|{
name|bool
name|wrap_possible
init|=
operator|(
name|SP
operator|->
name|_curscol
operator|+
name|runcount
operator|>=
name|screen_columns
operator|)
decl_stmt|;
name|int
name|rep_count
init|=
name|runcount
decl_stmt|;
if|if
condition|(
name|wrap_possible
condition|)
name|rep_count
operator|--
expr_stmt|;
name|UpdateAttrs
argument_list|(
name|ntext0
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|TPARM_2
argument_list|(
name|repeat_char
argument_list|,
name|CharOf
argument_list|(
name|ntext0
argument_list|)
argument_list|,
name|rep_count
argument_list|)
argument_list|,
name|rep_count
argument_list|,
name|_nc_outch
argument_list|)
expr_stmt|;
name|SP
operator|->
name|_curscol
operator|+=
name|rep_count
expr_stmt|;
if|if
condition|(
name|wrap_possible
condition|)
name|PutChar
argument_list|(
name|CHREF
argument_list|(
name|ntext0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|runcount
condition|;
name|i
operator|++
control|)
name|PutChar
argument_list|(
name|CHREF
argument_list|(
name|ntext
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ntext
operator|+=
name|runcount
expr_stmt|;
name|num
operator|-=
name|runcount
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|PutChar
argument_list|(
name|CHREF
argument_list|(
name|ntext
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Output the line in the given range [first .. last]  *  * If there's a run of identical characters that's long enough to justify  * cursor movement, use that also.  *  * Returns: same as EmitRange  */
end_comment

begin_function
specifier|static
name|int
name|PutRange
parameter_list|(
specifier|const
name|NCURSES_CH_T
modifier|*
name|otext
parameter_list|,
specifier|const
name|NCURSES_CH_T
modifier|*
name|ntext
parameter_list|,
name|int
name|row
parameter_list|,
name|int
name|first
parameter_list|,
name|int
name|last
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|same
decl_stmt|;
name|TR
argument_list|(
name|TRACE_CHARPUT
argument_list|,
operator|(
literal|"PutRange(%p, %p, %d, %d, %d)"
operator|,
name|otext
operator|,
name|ntext
operator|,
name|row
operator|,
name|first
operator|,
name|last
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|otext
operator|!=
name|ntext
operator|&&
operator|(
name|last
operator|-
name|first
operator|+
literal|1
operator|)
operator|>
name|SP
operator|->
name|_inline_cost
condition|)
block|{
for|for
control|(
name|j
operator|=
name|first
operator|,
name|same
operator|=
literal|0
init|;
name|j
operator|<=
name|last
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|same
operator|&&
name|isWidecExt
argument_list|(
name|otext
index|[
name|j
index|]
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|CharEq
argument_list|(
name|otext
index|[
name|j
index|]
argument_list|,
name|ntext
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|same
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|same
operator|>
name|SP
operator|->
name|_inline_cost
condition|)
block|{
name|EmitRange
argument_list|(
name|ntext
operator|+
name|first
argument_list|,
name|j
operator|-
name|same
operator|-
name|first
argument_list|)
expr_stmt|;
name|GoTo
argument_list|(
name|row
argument_list|,
name|first
operator|=
name|j
argument_list|)
expr_stmt|;
block|}
name|same
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|i
operator|=
name|EmitRange
argument_list|(
name|ntext
operator|+
name|first
argument_list|,
name|j
operator|-
name|same
operator|-
name|first
argument_list|)
expr_stmt|;
comment|/* 	 * Always return 1 for the next GoTo() after a PutRange() if we found 	 * identical characters at end of interval 	 */
return|return
operator|(
name|same
operator|==
literal|0
condition|?
name|i
else|:
literal|1
operator|)
return|;
block|}
return|return
name|EmitRange
argument_list|(
name|ntext
operator|+
name|first
argument_list|,
name|last
operator|-
name|first
operator|+
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* leave unbracketed here so 'indent' works */
end_comment

begin_define
define|#
directive|define
name|MARK_NOCHANGE
parameter_list|(
name|win
parameter_list|,
name|row
parameter_list|)
define|\
value|win->_line[row].firstchar = _NOCHANGE; \ 		win->_line[row].lastchar = _NOCHANGE; \ 		if_USE_SCROLL_HINTS(win->_line[row].oldindex = row)
end_define

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|doupdate
argument_list|(
argument|void
argument_list|)
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
name|int
name|nonempty
decl_stmt|;
if|#
directive|if
name|USE_TRACE_TIMES
name|struct
name|tms
name|before
decl_stmt|,
name|after
decl_stmt|;
endif|#
directive|endif
comment|/* USE_TRACE_TIMES */
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"doupdate()"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|_nc_tracing
operator|&
name|TRACE_UPDATE
condition|)
block|{
if|if
condition|(
name|curscr
operator|->
name|_clear
condition|)
name|_tracef
argument_list|(
literal|"curscr is clear"
argument_list|)
expr_stmt|;
else|else
name|_tracedump
argument_list|(
literal|"curscr"
argument_list|,
name|curscr
argument_list|)
expr_stmt|;
name|_tracedump
argument_list|(
literal|"newscr"
argument_list|,
name|newscr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TRACE */
name|_nc_signal_handler
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|SP
operator|->
name|_fifohold
condition|)
name|SP
operator|->
name|_fifohold
operator|--
expr_stmt|;
if|#
directive|if
name|USE_SIZECHANGE
if|if
condition|(
name|SP
operator|->
name|_endwin
operator|||
name|SP
operator|->
name|_sig_winch
condition|)
block|{
comment|/* 	 * This is a transparent extension:  XSI does not address it, 	 * and applications need not know that ncurses can do it. 	 * 	 * Check if the terminal size has changed while curses was off 	 * (this can happen in an xterm, for example), and resize the 	 * ncurses data structures accordingly. 	 */
name|_nc_update_screensize
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|SP
operator|->
name|_endwin
condition|)
block|{
name|T
argument_list|(
operator|(
literal|"coming back from shell mode"
operator|)
argument_list|)
expr_stmt|;
name|reset_prog_mode
argument_list|()
expr_stmt|;
name|_nc_mvcur_resume
argument_list|()
expr_stmt|;
name|_nc_screen_resume
argument_list|()
expr_stmt|;
name|SP
operator|->
name|_mouse_resume
argument_list|(
name|SP
argument_list|)
expr_stmt|;
name|SP
operator|->
name|_endwin
operator|=
name|FALSE
expr_stmt|;
block|}
if|#
directive|if
name|USE_TRACE_TIMES
comment|/* zero the metering machinery */
name|_nc_outchars
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|times
argument_list|(
operator|&
name|before
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_TRACE_TIMES */
comment|/*      * This is the support for magic-cookie terminals.  The theory:  we scan      * the virtual screen looking for attribute turnons.  Where we find one,      * check to make sure it's realizable by seeing if the required number of      * un-attributed blanks are present before and after the attributed range;      * try to shift the range boundaries over blanks (not changing the screen      * display) so this becomes true.  If it is, shift the beginning attribute      * change appropriately (the end one, if we've gotten this far, is      * guaranteed room for its cookie).  If not, nuke the added attributes out      * of the span.      */
if|#
directive|if
name|USE_XMC_SUPPORT
if|if
condition|(
name|magic_cookie_glitch
operator|>
literal|0
condition|)
block|{
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
name|attr_t
name|rattr
init|=
name|A_NORMAL
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|screen_lines
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|screen_columns
condition|;
name|j
operator|++
control|)
block|{
name|bool
name|failed
init|=
name|FALSE
decl_stmt|;
name|NCURSES_CH_T
modifier|*
name|thisline
init|=
name|newscr
operator|->
name|_line
index|[
name|i
index|]
operator|.
name|text
decl_stmt|;
name|attr_t
name|thisattr
init|=
name|AttrOf
argument_list|(
name|thisline
index|[
name|j
index|]
argument_list|)
operator|&
name|SP
operator|->
name|_xmc_triggers
decl_stmt|;
name|attr_t
name|turnon
init|=
name|thisattr
operator|&
operator|~
name|rattr
decl_stmt|;
comment|/* is an attribute turned on here? */
if|if
condition|(
name|turnon
operator|==
literal|0
condition|)
block|{
name|rattr
operator|=
name|thisattr
expr_stmt|;
continue|continue;
block|}
name|TR
argument_list|(
name|TRACE_ATTRS
argument_list|,
operator|(
literal|"At (%d, %d): from %s..."
operator|,
name|i
operator|,
name|j
operator|,
name|_traceattr
argument_list|(
name|rattr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|TR
argument_list|(
name|TRACE_ATTRS
argument_list|,
operator|(
literal|"...to %s"
operator|,
name|_traceattr
argument_list|(
name|turnon
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * If the attribute change location is a blank with a "safe" 		 * attribute, undo the attribute turnon.  This may ensure 		 * there's enough room to set the attribute before the first 		 * non-blank in the run. 		 */
define|#
directive|define
name|SAFE
parameter_list|(
name|a
parameter_list|)
value|(!((a)& SP->_xmc_triggers))
if|if
condition|(
name|ISBLANK
argument_list|(
name|thisline
index|[
name|j
index|]
argument_list|)
operator|&&
name|SAFE
argument_list|(
name|turnon
argument_list|)
condition|)
block|{
name|RemAttr
argument_list|(
name|thisline
index|[
name|j
index|]
argument_list|,
name|turnon
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* check that there's enough room at start of span */
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<=
name|magic_cookie_glitch
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|-
name|k
operator|<
literal|0
operator|||
operator|!
name|ISBLANK
argument_list|(
name|thisline
index|[
name|j
operator|-
name|k
index|]
argument_list|)
operator|||
operator|!
name|SAFE
argument_list|(
name|AttrOf
argument_list|(
name|thisline
index|[
name|j
operator|-
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
name|failed
operator|=
name|TRUE
expr_stmt|;
name|TR
argument_list|(
name|TRACE_ATTRS
argument_list|,
operator|(
literal|"No room at start in %d,%d%s%s"
operator|,
name|i
operator|,
name|j
operator|-
name|k
operator|,
operator|(
name|ISBLANK
argument_list|(
name|thisline
index|[
name|j
operator|-
name|k
index|]
argument_list|)
condition|?
literal|""
else|:
literal|":nonblank"
operator|)
operator|,
operator|(
name|SAFE
argument_list|(
name|AttrOf
argument_list|(
name|thisline
index|[
name|j
operator|-
name|k
index|]
argument_list|)
argument_list|)
condition|?
literal|""
else|:
literal|":unsafe"
operator|)
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|failed
condition|)
block|{
name|bool
name|end_onscreen
init|=
name|FALSE
decl_stmt|;
name|int
name|m
decl_stmt|,
name|n
init|=
name|j
decl_stmt|;
comment|/* find end of span, if it's onscreen */
for|for
control|(
name|m
operator|=
name|i
init|;
name|m
operator|<
name|screen_lines
condition|;
name|m
operator|++
control|)
block|{
for|for
control|(
init|;
name|n
operator|<
name|screen_columns
condition|;
name|n
operator|++
control|)
block|{
name|attr_t
name|testattr
init|=
name|AttrOf
argument_list|(
name|newscr
operator|->
name|_line
index|[
name|m
index|]
operator|.
name|text
index|[
name|n
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|testattr
operator|&
name|SP
operator|->
name|_xmc_triggers
operator|)
operator|==
name|rattr
condition|)
block|{
name|end_onscreen
operator|=
name|TRUE
expr_stmt|;
name|TR
argument_list|(
name|TRACE_ATTRS
argument_list|,
operator|(
literal|"Range attributed with %s ends at (%d, %d)"
operator|,
name|_traceattr
argument_list|(
name|turnon
argument_list|)
operator|,
name|m
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|foundit
goto|;
block|}
block|}
name|n
operator|=
literal|0
expr_stmt|;
block|}
name|TR
argument_list|(
name|TRACE_ATTRS
argument_list|,
operator|(
literal|"Range attributed with %s ends offscreen"
operator|,
name|_traceattr
argument_list|(
name|turnon
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|foundit
label|:
empty_stmt|;
if|if
condition|(
name|end_onscreen
condition|)
block|{
name|NCURSES_CH_T
modifier|*
name|lastline
init|=
name|newscr
operator|->
name|_line
index|[
name|m
index|]
operator|.
name|text
decl_stmt|;
comment|/* 			 * If there are safely-attributed blanks at the end of 			 * the range, shorten the range.  This will help ensure 			 * that there is enough room at end of span. 			 */
while|while
condition|(
name|n
operator|>=
literal|0
operator|&&
name|ISBLANK
argument_list|(
name|lastline
index|[
name|n
index|]
argument_list|)
operator|&&
name|SAFE
argument_list|(
name|AttrOf
argument_list|(
name|lastline
index|[
name|n
index|]
argument_list|)
argument_list|)
condition|)
block|{
name|RemAttr
argument_list|(
name|lastline
index|[
name|n
operator|--
index|]
argument_list|,
name|turnon
argument_list|)
expr_stmt|;
block|}
comment|/* check that there's enough room at end of span */
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<=
name|magic_cookie_glitch
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|n
operator|+
name|k
operator|>=
name|screen_columns
operator|||
operator|!
name|ISBLANK
argument_list|(
name|lastline
index|[
name|n
operator|+
name|k
index|]
argument_list|)
operator|||
operator|!
name|SAFE
argument_list|(
name|AttrOf
argument_list|(
name|lastline
index|[
name|n
operator|+
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
name|failed
operator|=
name|TRUE
expr_stmt|;
name|TR
argument_list|(
name|TRACE_ATTRS
argument_list|,
operator|(
literal|"No room at end in %d,%d%s%s"
operator|,
name|i
operator|,
name|j
operator|-
name|k
operator|,
operator|(
name|ISBLANK
argument_list|(
name|lastline
index|[
name|n
operator|+
name|k
index|]
argument_list|)
condition|?
literal|""
else|:
literal|":nonblank"
operator|)
operator|,
operator|(
name|SAFE
argument_list|(
name|AttrOf
argument_list|(
name|lastline
index|[
name|n
operator|+
name|k
index|]
argument_list|)
argument_list|)
condition|?
literal|""
else|:
literal|":unsafe"
operator|)
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|failed
condition|)
block|{
name|int
name|p
decl_stmt|,
name|q
init|=
name|j
decl_stmt|;
name|TR
argument_list|(
name|TRACE_ATTRS
argument_list|,
operator|(
literal|"Clearing %s beginning at (%d, %d)"
operator|,
name|_traceattr
argument_list|(
name|turnon
argument_list|)
operator|,
name|i
operator|,
name|j
operator|)
argument_list|)
expr_stmt|;
comment|/* turn off new attributes over span */
for|for
control|(
name|p
operator|=
name|i
init|;
name|p
operator|<
name|screen_lines
condition|;
name|p
operator|++
control|)
block|{
for|for
control|(
init|;
name|q
operator|<
name|screen_columns
condition|;
name|q
operator|++
control|)
block|{
name|attr_t
name|testattr
init|=
name|AttrOf
argument_list|(
name|newscr
operator|->
name|_line
index|[
name|p
index|]
operator|.
name|text
index|[
name|q
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|testattr
operator|&
name|SP
operator|->
name|_xmc_triggers
operator|)
operator|==
name|rattr
condition|)
goto|goto
name|foundend
goto|;
name|RemAttr
argument_list|(
name|newscr
operator|->
name|_line
index|[
name|p
index|]
operator|.
name|text
index|[
name|q
index|]
argument_list|,
name|turnon
argument_list|)
expr_stmt|;
block|}
name|q
operator|=
literal|0
expr_stmt|;
block|}
name|foundend
label|:
empty_stmt|;
block|}
else|else
block|{
name|TR
argument_list|(
name|TRACE_ATTRS
argument_list|,
operator|(
literal|"Cookie space for %s found before (%d, %d)"
operator|,
name|_traceattr
argument_list|(
name|turnon
argument_list|)
operator|,
name|i
operator|,
name|j
operator|)
argument_list|)
expr_stmt|;
comment|/* 		     * Back up the start of range so there's room for cookies 		     * before the first nonblank character. 		     */
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<=
name|magic_cookie_glitch
condition|;
name|k
operator|++
control|)
name|AddAttr
argument_list|(
name|thisline
index|[
name|j
operator|-
name|k
index|]
argument_list|,
name|turnon
argument_list|)
expr_stmt|;
block|}
name|rattr
operator|=
name|thisattr
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|TRACE
comment|/* show altered highlights after magic-cookie check */
if|if
condition|(
name|_nc_tracing
operator|&
name|TRACE_UPDATE
condition|)
block|{
name|_tracef
argument_list|(
literal|"After magic-cookie check..."
argument_list|)
expr_stmt|;
name|_tracedump
argument_list|(
literal|"newscr"
argument_list|,
name|newscr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TRACE */
block|}
endif|#
directive|endif
comment|/* USE_XMC_SUPPORT */
name|nonempty
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|curscr
operator|->
name|_clear
operator|||
name|newscr
operator|->
name|_clear
condition|)
block|{
comment|/* force refresh ? */
name|TR
argument_list|(
name|TRACE_UPDATE
argument_list|,
operator|(
literal|"clearing and updating from scratch"
operator|)
argument_list|)
expr_stmt|;
name|ClrUpdate
argument_list|()
expr_stmt|;
name|curscr
operator|->
name|_clear
operator|=
name|FALSE
expr_stmt|;
comment|/* reset flag */
name|newscr
operator|->
name|_clear
operator|=
name|FALSE
expr_stmt|;
comment|/* reset flag */
block|}
else|else
block|{
name|int
name|changedlines
init|=
name|CHECK_INTERVAL
decl_stmt|;
if|if
condition|(
name|check_pending
argument_list|()
condition|)
goto|goto
name|cleanup
goto|;
name|nonempty
operator|=
name|min
argument_list|(
name|screen_lines
argument_list|,
name|newscr
operator|->
name|_maxy
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|SP
operator|->
name|_scrolling
condition|)
block|{
name|_nc_scroll_optimize
argument_list|()
expr_stmt|;
block|}
name|nonempty
operator|=
name|ClrBottom
argument_list|(
name|nonempty
argument_list|)
expr_stmt|;
name|TR
argument_list|(
name|TRACE_UPDATE
argument_list|,
operator|(
literal|"Transforming lines, nonempty %d"
operator|,
name|nonempty
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nonempty
condition|;
name|i
operator|++
control|)
block|{
comment|/* 	     * Here is our line-breakout optimization. 	     */
if|if
condition|(
name|changedlines
operator|==
name|CHECK_INTERVAL
condition|)
block|{
if|if
condition|(
name|check_pending
argument_list|()
condition|)
goto|goto
name|cleanup
goto|;
name|changedlines
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	     * newscr->line[i].firstchar is normally set 	     * by wnoutrefresh.  curscr->line[i].firstchar 	     * is normally set by _nc_scroll_window in the 	     * vertical-movement optimization code, 	     */
if|if
condition|(
name|newscr
operator|->
name|_line
index|[
name|i
index|]
operator|.
name|firstchar
operator|!=
name|_NOCHANGE
operator|||
name|curscr
operator|->
name|_line
index|[
name|i
index|]
operator|.
name|firstchar
operator|!=
name|_NOCHANGE
condition|)
block|{
name|TransformLine
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|changedlines
operator|++
expr_stmt|;
block|}
comment|/* mark line changed successfully */
if|if
condition|(
name|i
operator|<=
name|newscr
operator|->
name|_maxy
condition|)
block|{
name|MARK_NOCHANGE
argument_list|(
name|newscr
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<=
name|curscr
operator|->
name|_maxy
condition|)
block|{
name|MARK_NOCHANGE
argument_list|(
name|curscr
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* put everything back in sync */
for|for
control|(
name|i
operator|=
name|nonempty
init|;
name|i
operator|<=
name|newscr
operator|->
name|_maxy
condition|;
name|i
operator|++
control|)
block|{
name|MARK_NOCHANGE
argument_list|(
name|newscr
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|nonempty
init|;
name|i
operator|<=
name|curscr
operator|->
name|_maxy
condition|;
name|i
operator|++
control|)
block|{
name|MARK_NOCHANGE
argument_list|(
name|curscr
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|newscr
operator|->
name|_leaveok
condition|)
block|{
name|curscr
operator|->
name|_curx
operator|=
name|newscr
operator|->
name|_curx
expr_stmt|;
name|curscr
operator|->
name|_cury
operator|=
name|newscr
operator|->
name|_cury
expr_stmt|;
name|GoTo
argument_list|(
name|curscr
operator|->
name|_cury
argument_list|,
name|curscr
operator|->
name|_curx
argument_list|)
expr_stmt|;
block|}
name|cleanup
label|:
comment|/*      * We would like to keep the physical screen in normal mode in case we get      * other processes writing to the screen.  This goal cannot be met for      * magic cookies since it interferes with attributes that may propagate      * past the current position.      */
if|#
directive|if
name|USE_XMC_SUPPORT
if|if
condition|(
name|magic_cookie_glitch
operator|!=
literal|0
condition|)
endif|#
directive|endif
name|UpdateAttrs
argument_list|(
name|normal
argument_list|)
expr_stmt|;
name|_nc_flush
argument_list|()
expr_stmt|;
name|WINDOW_ATTRS
argument_list|(
name|curscr
argument_list|)
operator|=
name|WINDOW_ATTRS
argument_list|(
name|newscr
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_TRACE_TIMES
operator|(
name|void
operator|)
name|times
argument_list|(
operator|&
name|after
argument_list|)
expr_stmt|;
name|TR
argument_list|(
name|TRACE_TIMES
argument_list|,
operator|(
literal|"Update cost: %ld chars, %ld clocks system time, %ld clocks user time"
operator|,
name|_nc_outchars
operator|,
call|(
name|long
call|)
argument_list|(
name|after
operator|.
name|tms_stime
operator|-
name|before
operator|.
name|tms_stime
argument_list|)
operator|,
call|(
name|long
call|)
argument_list|(
name|after
operator|.
name|tms_utime
operator|-
name|before
operator|.
name|tms_utime
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_TRACE_TIMES */
name|_nc_signal_handler
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|OK
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	ClrBlank(win)  *  *	Returns the attributed character that corresponds to the "cleared"  *	screen.  If the terminal has the back-color-erase feature, this will be  *	colored according to the wbkgd() call.  *  *	We treat 'curscr' specially because it isn't supposed to be set directly  *	in the wbkgd() call.  Assume 'stdscr' for this case.  */
end_comment

begin_define
define|#
directive|define
name|BCE_ATTRS
value|(A_NORMAL|A_COLOR)
end_define

begin_define
define|#
directive|define
name|BCE_BKGD
parameter_list|(
name|win
parameter_list|)
value|(((win) == curscr ? stdscr : (win))->_nc_bkgd)
end_define

begin_function
specifier|static
name|NCURSES_INLINE
name|NCURSES_CH_T
name|ClrBlank
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|NCURSES_CH_T
name|blank
init|=
name|blankchar
decl_stmt|;
if|if
condition|(
name|back_color_erase
condition|)
name|AddAttr
argument_list|(
name|blank
argument_list|,
operator|(
name|AttrOf
argument_list|(
name|BCE_BKGD
argument_list|(
name|win
argument_list|)
argument_list|)
operator|&
name|BCE_ATTRS
operator|)
argument_list|)
expr_stmt|;
return|return
name|blank
return|;
block|}
end_function

begin_comment
comment|/* **	ClrUpdate() ** **	Update by clearing and redrawing the entire screen. ** */
end_comment

begin_function
specifier|static
name|void
name|ClrUpdate
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|NCURSES_CH_T
name|blank
init|=
name|ClrBlank
argument_list|(
name|stdscr
argument_list|)
decl_stmt|;
name|int
name|nonempty
init|=
name|min
argument_list|(
name|screen_lines
argument_list|,
name|newscr
operator|->
name|_maxy
operator|+
literal|1
argument_list|)
decl_stmt|;
name|TR
argument_list|(
name|TRACE_UPDATE
argument_list|,
operator|(
literal|"ClrUpdate() called"
operator|)
argument_list|)
expr_stmt|;
name|ClearScreen
argument_list|(
name|blank
argument_list|)
expr_stmt|;
name|TR
argument_list|(
name|TRACE_UPDATE
argument_list|,
operator|(
literal|"updating screen from scratch"
operator|)
argument_list|)
expr_stmt|;
name|nonempty
operator|=
name|ClrBottom
argument_list|(
name|nonempty
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nonempty
condition|;
name|i
operator|++
control|)
name|TransformLine
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	ClrToEOL(blank) ** **	Clear to end of current line, starting at the cursor position */
end_comment

begin_function
specifier|static
name|void
name|ClrToEOL
parameter_list|(
name|NCURSES_CH_T
name|blank
parameter_list|,
name|bool
name|needclear
parameter_list|)
block|{
name|int
name|j
decl_stmt|;
if|if
condition|(
name|curscr
operator|!=
literal|0
operator|&&
name|SP
operator|->
name|_cursrow
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|j
operator|=
name|SP
operator|->
name|_curscol
init|;
name|j
operator|<
name|screen_columns
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|>=
literal|0
condition|)
block|{
name|NCURSES_CH_T
modifier|*
name|cp
init|=
operator|&
operator|(
name|curscr
operator|->
name|_line
index|[
name|SP
operator|->
name|_cursrow
index|]
operator|.
name|text
index|[
name|j
index|]
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|CharEq
argument_list|(
operator|*
name|cp
argument_list|,
name|blank
argument_list|)
condition|)
block|{
operator|*
name|cp
operator|=
name|blank
expr_stmt|;
name|needclear
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|needclear
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|needclear
condition|)
block|{
name|UpdateAttrs
argument_list|(
name|blank
argument_list|)
expr_stmt|;
name|TPUTS_TRACE
argument_list|(
literal|"clr_eol"
argument_list|)
expr_stmt|;
if|if
condition|(
name|clr_eol
operator|&&
name|SP
operator|->
name|_el_cost
operator|<=
operator|(
name|screen_columns
operator|-
name|SP
operator|->
name|_curscol
operator|)
condition|)
block|{
name|putp
argument_list|(
name|clr_eol
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|count
init|=
operator|(
name|screen_columns
operator|-
name|SP
operator|->
name|_curscol
operator|)
decl_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
name|PutChar
argument_list|(
name|CHREF
argument_list|(
name|blank
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* **	ClrToEOS(blank) ** **	Clear to end of screen, starting at the cursor position */
end_comment

begin_function
specifier|static
name|void
name|ClrToEOS
parameter_list|(
name|NCURSES_CH_T
name|blank
parameter_list|)
block|{
name|int
name|row
decl_stmt|,
name|col
decl_stmt|;
name|row
operator|=
name|SP
operator|->
name|_cursrow
expr_stmt|;
name|col
operator|=
name|SP
operator|->
name|_curscol
expr_stmt|;
name|UpdateAttrs
argument_list|(
name|blank
argument_list|)
expr_stmt|;
name|TPUTS_TRACE
argument_list|(
literal|"clr_eos"
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|clr_eos
argument_list|,
name|screen_lines
operator|-
name|row
argument_list|,
name|_nc_outch
argument_list|)
expr_stmt|;
while|while
condition|(
name|col
operator|<
name|screen_columns
condition|)
name|curscr
operator|->
name|_line
index|[
name|row
index|]
operator|.
name|text
index|[
name|col
operator|++
index|]
operator|=
name|blank
expr_stmt|;
for|for
control|(
name|row
operator|++
init|;
name|row
operator|<
name|screen_lines
condition|;
name|row
operator|++
control|)
block|{
for|for
control|(
name|col
operator|=
literal|0
init|;
name|col
operator|<
name|screen_columns
condition|;
name|col
operator|++
control|)
name|curscr
operator|->
name|_line
index|[
name|row
index|]
operator|.
name|text
index|[
name|col
index|]
operator|=
name|blank
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	ClrBottom(total)  *  *	Test if clearing the end of the screen would satisfy part of the  *	screen-update.  Do this by scanning backwards through the lines in the  *	screen, checking if each is blank, and one or more are changed.  */
end_comment

begin_function
specifier|static
name|int
name|ClrBottom
parameter_list|(
name|int
name|total
parameter_list|)
block|{
name|int
name|row
decl_stmt|;
name|int
name|col
decl_stmt|;
name|int
name|top
init|=
name|total
decl_stmt|;
name|int
name|last
init|=
name|min
argument_list|(
name|screen_columns
argument_list|,
name|newscr
operator|->
name|_maxx
operator|+
literal|1
argument_list|)
decl_stmt|;
name|NCURSES_CH_T
name|blank
init|=
name|newscr
operator|->
name|_line
index|[
name|total
operator|-
literal|1
index|]
operator|.
name|text
index|[
name|last
operator|-
literal|1
index|]
decl_stmt|;
name|bool
name|ok
decl_stmt|;
if|if
condition|(
name|clr_eos
operator|&&
name|can_clear_with
argument_list|(
name|CHREF
argument_list|(
name|blank
argument_list|)
argument_list|)
condition|)
block|{
for|for
control|(
name|row
operator|=
name|total
operator|-
literal|1
init|;
name|row
operator|>=
literal|0
condition|;
name|row
operator|--
control|)
block|{
for|for
control|(
name|col
operator|=
literal|0
operator|,
name|ok
operator|=
name|TRUE
init|;
name|ok
operator|&&
name|col
operator|<
name|last
condition|;
name|col
operator|++
control|)
block|{
name|ok
operator|=
operator|(
name|CharEq
argument_list|(
name|newscr
operator|->
name|_line
index|[
name|row
index|]
operator|.
name|text
index|[
name|col
index|]
argument_list|,
name|blank
argument_list|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
break|break;
for|for
control|(
name|col
operator|=
literal|0
init|;
name|ok
operator|&&
name|col
operator|<
name|last
condition|;
name|col
operator|++
control|)
block|{
name|ok
operator|=
operator|(
name|CharEq
argument_list|(
name|curscr
operator|->
name|_line
index|[
name|row
index|]
operator|.
name|text
index|[
name|col
index|]
argument_list|,
name|blank
argument_list|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
name|top
operator|=
name|row
expr_stmt|;
block|}
comment|/* don't use clr_eos for just one line if clr_eol available */
if|if
condition|(
name|top
operator|<
name|total
condition|)
block|{
name|GoTo
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ClrToEOS
argument_list|(
name|blank
argument_list|)
expr_stmt|;
if|if
condition|(
name|SP
operator|->
name|oldhash
operator|&&
name|SP
operator|->
name|newhash
condition|)
block|{
for|for
control|(
name|row
operator|=
name|top
init|;
name|row
operator|<
name|screen_lines
condition|;
name|row
operator|++
control|)
name|SP
operator|->
name|oldhash
index|[
name|row
index|]
operator|=
name|SP
operator|->
name|newhash
index|[
name|row
index|]
expr_stmt|;
block|}
block|}
block|}
return|return
name|top
return|;
block|}
end_function

begin_if
if|#
directive|if
name|USE_XMC_SUPPORT
end_if

begin_if
if|#
directive|if
name|USE_WIDEC_SUPPORT
end_if

begin_define
define|#
directive|define
name|check_xmc_transition
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
define|\
value|((((a)->attr ^ (b)->attr)& ~((a)->attr)& SP->_xmc_triggers) != 0)
end_define

begin_define
define|#
directive|define
name|xmc_turn_on
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|check_xmc_transition(&(a),&(b))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|xmc_turn_on
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((((a)^(b))& ~(a)& SP->_xmc_triggers) != 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|xmc_new
parameter_list|(
name|r
parameter_list|,
name|c
parameter_list|)
value|newscr->_line[r].text[c]
end_define

begin_define
define|#
directive|define
name|xmc_turn_off
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|xmc_turn_on(b,a)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_XMC_SUPPORT */
end_comment

begin_comment
comment|/* **	TransformLine(lineno) ** **	Transform the given line in curscr to the one in newscr, using **	Insert/Delete Character if _nc_idcok&& has_ic(). ** **		firstChar = position of first different character in line **		oLastChar = position of last different character in old line **		nLastChar = position of last different character in new line ** **		move to firstChar **		overwrite chars up to min(oLastChar, nLastChar) **		if oLastChar< nLastChar **			insert newLine[oLastChar+1..nLastChar] **		else **			delete oLastChar - nLastChar spaces */
end_comment

begin_function
specifier|static
name|void
name|TransformLine
parameter_list|(
name|int
specifier|const
name|lineno
parameter_list|)
block|{
name|int
name|firstChar
decl_stmt|,
name|oLastChar
decl_stmt|,
name|nLastChar
decl_stmt|;
name|NCURSES_CH_T
modifier|*
name|newLine
init|=
name|newscr
operator|->
name|_line
index|[
name|lineno
index|]
operator|.
name|text
decl_stmt|;
name|NCURSES_CH_T
modifier|*
name|oldLine
init|=
name|curscr
operator|->
name|_line
index|[
name|lineno
index|]
operator|.
name|text
decl_stmt|;
name|int
name|n
decl_stmt|;
name|bool
name|attrchanged
init|=
name|FALSE
decl_stmt|;
name|TR
argument_list|(
name|TRACE_UPDATE
argument_list|,
operator|(
name|T_CALLED
argument_list|(
literal|"TransformLine(%d)"
argument_list|)
operator|,
name|lineno
operator|)
argument_list|)
expr_stmt|;
comment|/* copy new hash value to old one */
if|if
condition|(
name|SP
operator|->
name|oldhash
operator|&&
name|SP
operator|->
name|newhash
condition|)
name|SP
operator|->
name|oldhash
index|[
name|lineno
index|]
operator|=
name|SP
operator|->
name|newhash
index|[
name|lineno
index|]
expr_stmt|;
comment|/*      * If we have colors, there is the possibility of having two color pairs      * that display as the same colors.  For instance, Lynx does this.  Check      * for this case, and update the old line with the new line's colors when      * they are equivalent.      */
if|if
condition|(
name|SP
operator|->
name|_coloron
condition|)
block|{
name|int
name|oldPair
decl_stmt|;
name|int
name|newPair
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|screen_columns
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|CharEq
argument_list|(
name|newLine
index|[
name|n
index|]
argument_list|,
name|oldLine
index|[
name|n
index|]
argument_list|)
condition|)
block|{
name|oldPair
operator|=
name|GetPair
argument_list|(
name|oldLine
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|newPair
operator|=
name|GetPair
argument_list|(
name|newLine
index|[
name|n
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldPair
operator|!=
name|newPair
operator|&&
name|unColor
argument_list|(
name|oldLine
index|[
name|n
index|]
argument_list|)
operator|==
name|unColor
argument_list|(
name|newLine
index|[
name|n
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|oldPair
operator|<
name|COLOR_PAIRS
operator|&&
name|newPair
operator|<
name|COLOR_PAIRS
operator|&&
name|SP
operator|->
name|_color_pairs
index|[
name|oldPair
index|]
operator|==
name|SP
operator|->
name|_color_pairs
index|[
name|newPair
index|]
condition|)
block|{
name|SetPair
argument_list|(
name|oldLine
index|[
name|n
index|]
argument_list|,
name|GetPair
argument_list|(
name|newLine
index|[
name|n
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|ceol_standout_glitch
operator|&&
name|clr_eol
condition|)
block|{
name|firstChar
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|firstChar
operator|<
name|screen_columns
condition|)
block|{
if|if
condition|(
operator|!
name|SameAttrOf
argument_list|(
name|newLine
index|[
name|firstChar
index|]
argument_list|,
name|oldLine
index|[
name|firstChar
index|]
argument_list|)
condition|)
block|{
name|attrchanged
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|firstChar
operator|++
expr_stmt|;
block|}
block|}
name|firstChar
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|attrchanged
condition|)
block|{
comment|/* we may have to disregard the whole line */
name|GoTo
argument_list|(
name|lineno
argument_list|,
name|firstChar
argument_list|)
expr_stmt|;
name|ClrToEOL
argument_list|(
name|ClrBlank
argument_list|(
name|curscr
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|PutRange
argument_list|(
name|oldLine
argument_list|,
name|newLine
argument_list|,
name|lineno
argument_list|,
literal|0
argument_list|,
operator|(
name|screen_columns
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_XMC_SUPPORT
comment|/* 	 * This is a very simple loop to paint characters which may have the 	 * magic cookie glitch embedded.  It doesn't know much about video 	 * attributes which are continued from one line to the next.  It 	 * assumes that we have filtered out requests for attribute changes 	 * that do not get mapped to blank positions. 	 * 	 * FIXME: we are not keeping track of where we put the cookies, so this 	 * will work properly only once, since we may overwrite a cookie in a 	 * following operation. 	 */
block|}
elseif|else
if|if
condition|(
name|magic_cookie_glitch
operator|>
literal|0
condition|)
block|{
name|GoTo
argument_list|(
name|lineno
argument_list|,
name|firstChar
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|screen_columns
condition|;
name|n
operator|++
control|)
block|{
name|int
name|m
init|=
name|n
operator|+
name|magic_cookie_glitch
decl_stmt|;
comment|/* check for turn-on: 	     * If we are writing an attributed blank, where the 	     * previous cell is not attributed. 	     */
if|if
condition|(
name|ISBLANK
argument_list|(
name|newLine
index|[
name|n
index|]
argument_list|)
operator|&&
operator|(
operator|(
name|n
operator|>
literal|0
operator|&&
name|xmc_turn_on
argument_list|(
name|newLine
index|[
name|n
operator|-
literal|1
index|]
argument_list|,
name|newLine
index|[
name|n
index|]
argument_list|)
operator|)
operator|||
operator|(
name|n
operator|==
literal|0
operator|&&
name|lineno
operator|>
literal|0
operator|&&
name|xmc_turn_on
argument_list|(
name|xmc_new
argument_list|(
name|lineno
operator|-
literal|1
argument_list|,
name|screen_columns
operator|-
literal|1
argument_list|)
argument_list|,
name|newLine
index|[
name|n
index|]
argument_list|)
operator|)
operator|)
condition|)
block|{
name|n
operator|=
name|m
expr_stmt|;
block|}
name|PutChar
argument_list|(
name|CHREF
argument_list|(
name|newLine
index|[
name|n
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* check for turn-off: 	     * If we are writing an attributed non-blank, where the 	     * next cell is blank, and not attributed. 	     */
if|if
condition|(
operator|!
name|ISBLANK
argument_list|(
name|newLine
index|[
name|n
index|]
argument_list|)
operator|&&
operator|(
operator|(
name|n
operator|+
literal|1
operator|<
name|screen_columns
operator|&&
name|xmc_turn_off
argument_list|(
name|newLine
index|[
name|n
index|]
argument_list|,
name|newLine
index|[
name|n
operator|+
literal|1
index|]
argument_list|)
operator|)
operator|||
operator|(
name|n
operator|+
literal|1
operator|>=
name|screen_columns
operator|&&
name|lineno
operator|+
literal|1
operator|<
name|screen_lines
operator|&&
name|xmc_turn_off
argument_list|(
name|newLine
index|[
name|n
index|]
argument_list|,
name|xmc_new
argument_list|(
name|lineno
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
name|n
operator|=
name|m
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|NCURSES_CH_T
name|blank
decl_stmt|;
comment|/* it may be cheap to clear leading whitespace with clr_bol */
name|blank
operator|=
name|newLine
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|clr_bol
operator|&&
name|can_clear_with
argument_list|(
name|CHREF
argument_list|(
name|blank
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|oFirstChar
decl_stmt|,
name|nFirstChar
decl_stmt|;
for|for
control|(
name|oFirstChar
operator|=
literal|0
init|;
name|oFirstChar
operator|<
name|screen_columns
condition|;
name|oFirstChar
operator|++
control|)
if|if
condition|(
operator|!
name|CharEq
argument_list|(
name|oldLine
index|[
name|oFirstChar
index|]
argument_list|,
name|blank
argument_list|)
condition|)
break|break;
for|for
control|(
name|nFirstChar
operator|=
literal|0
init|;
name|nFirstChar
operator|<
name|screen_columns
condition|;
name|nFirstChar
operator|++
control|)
if|if
condition|(
operator|!
name|CharEq
argument_list|(
name|newLine
index|[
name|nFirstChar
index|]
argument_list|,
name|blank
argument_list|)
condition|)
break|break;
if|if
condition|(
name|nFirstChar
operator|==
name|oFirstChar
condition|)
block|{
name|firstChar
operator|=
name|nFirstChar
expr_stmt|;
comment|/* find the first differing character */
while|while
condition|(
name|firstChar
operator|<
name|screen_columns
operator|&&
name|CharEq
argument_list|(
name|newLine
index|[
name|firstChar
index|]
argument_list|,
name|oldLine
index|[
name|firstChar
index|]
argument_list|)
condition|)
name|firstChar
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|oFirstChar
operator|>
name|nFirstChar
condition|)
block|{
name|firstChar
operator|=
name|nFirstChar
expr_stmt|;
block|}
else|else
block|{
comment|/* oFirstChar< nFirstChar */
name|firstChar
operator|=
name|oFirstChar
expr_stmt|;
if|if
condition|(
name|SP
operator|->
name|_el1_cost
operator|<
name|nFirstChar
operator|-
name|oFirstChar
condition|)
block|{
if|if
condition|(
name|nFirstChar
operator|>=
name|screen_columns
operator|&&
name|SP
operator|->
name|_el_cost
operator|<=
name|SP
operator|->
name|_el1_cost
condition|)
block|{
name|GoTo
argument_list|(
name|lineno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|UpdateAttrs
argument_list|(
name|blank
argument_list|)
expr_stmt|;
name|TPUTS_TRACE
argument_list|(
literal|"clr_eol"
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|clr_eol
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|GoTo
argument_list|(
name|lineno
argument_list|,
name|nFirstChar
operator|-
literal|1
argument_list|)
expr_stmt|;
name|UpdateAttrs
argument_list|(
name|blank
argument_list|)
expr_stmt|;
name|TPUTS_TRACE
argument_list|(
literal|"clr_bol"
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|clr_bol
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|firstChar
operator|<
name|nFirstChar
condition|)
name|oldLine
index|[
name|firstChar
operator|++
index|]
operator|=
name|blank
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* find the first differing character */
while|while
condition|(
name|firstChar
operator|<
name|screen_columns
operator|&&
name|CharEq
argument_list|(
name|newLine
index|[
name|firstChar
index|]
argument_list|,
name|oldLine
index|[
name|firstChar
index|]
argument_list|)
condition|)
name|firstChar
operator|++
expr_stmt|;
block|}
comment|/* if there wasn't one, we're done */
if|if
condition|(
name|firstChar
operator|>=
name|screen_columns
condition|)
block|{
name|TR
argument_list|(
name|TRACE_UPDATE
argument_list|,
operator|(
name|T_RETURN
argument_list|(
literal|""
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|blank
operator|=
name|newLine
index|[
name|screen_columns
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|can_clear_with
argument_list|(
name|CHREF
argument_list|(
name|blank
argument_list|)
argument_list|)
condition|)
block|{
comment|/* find the last differing character */
name|nLastChar
operator|=
name|screen_columns
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|nLastChar
operator|>
name|firstChar
operator|&&
name|CharEq
argument_list|(
name|newLine
index|[
name|nLastChar
index|]
argument_list|,
name|oldLine
index|[
name|nLastChar
index|]
argument_list|)
condition|)
name|nLastChar
operator|--
expr_stmt|;
if|if
condition|(
name|nLastChar
operator|>=
name|firstChar
condition|)
block|{
name|GoTo
argument_list|(
name|lineno
argument_list|,
name|firstChar
argument_list|)
expr_stmt|;
name|PutRange
argument_list|(
name|oldLine
argument_list|,
name|newLine
argument_list|,
name|lineno
argument_list|,
name|firstChar
argument_list|,
name|nLastChar
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|oldLine
operator|+
name|firstChar
argument_list|,
name|newLine
operator|+
name|firstChar
argument_list|,
operator|(
name|nLastChar
operator|-
name|firstChar
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|NCURSES_CH_T
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|TR
argument_list|(
name|TRACE_UPDATE
argument_list|,
operator|(
name|T_RETURN
argument_list|(
literal|""
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* find last non-blank character on old line */
name|oLastChar
operator|=
name|screen_columns
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|oLastChar
operator|>
name|firstChar
operator|&&
name|CharEq
argument_list|(
name|oldLine
index|[
name|oLastChar
index|]
argument_list|,
name|blank
argument_list|)
condition|)
name|oLastChar
operator|--
expr_stmt|;
comment|/* find last non-blank character on new line */
name|nLastChar
operator|=
name|screen_columns
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|nLastChar
operator|>
name|firstChar
operator|&&
name|CharEq
argument_list|(
name|newLine
index|[
name|nLastChar
index|]
argument_list|,
name|blank
argument_list|)
condition|)
name|nLastChar
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|nLastChar
operator|==
name|firstChar
operator|)
operator|&&
operator|(
name|SP
operator|->
name|_el_cost
operator|<
operator|(
name|oLastChar
operator|-
name|nLastChar
operator|)
operator|)
condition|)
block|{
name|GoTo
argument_list|(
name|lineno
argument_list|,
name|firstChar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CharEq
argument_list|(
name|newLine
index|[
name|firstChar
index|]
argument_list|,
name|blank
argument_list|)
condition|)
name|PutChar
argument_list|(
name|CHREF
argument_list|(
name|newLine
index|[
name|firstChar
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ClrToEOL
argument_list|(
name|blank
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|nLastChar
operator|!=
name|oLastChar
operator|)
operator|&&
operator|(
operator|!
name|CharEq
argument_list|(
name|newLine
index|[
name|nLastChar
index|]
argument_list|,
name|oldLine
index|[
name|oLastChar
index|]
argument_list|)
operator|||
operator|!
operator|(
name|_nc_idcok
operator|&&
name|has_ic
argument_list|()
operator|)
operator|)
condition|)
block|{
name|GoTo
argument_list|(
name|lineno
argument_list|,
name|firstChar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|oLastChar
operator|-
name|nLastChar
operator|)
operator|>
name|SP
operator|->
name|_el_cost
condition|)
block|{
if|if
condition|(
name|PutRange
argument_list|(
name|oldLine
argument_list|,
name|newLine
argument_list|,
name|lineno
argument_list|,
name|firstChar
argument_list|,
name|nLastChar
argument_list|)
condition|)
name|GoTo
argument_list|(
name|lineno
argument_list|,
name|nLastChar
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ClrToEOL
argument_list|(
name|blank
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|max
argument_list|(
name|nLastChar
argument_list|,
name|oLastChar
argument_list|)
expr_stmt|;
name|PutRange
argument_list|(
name|oldLine
argument_list|,
name|newLine
argument_list|,
name|lineno
argument_list|,
name|firstChar
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|nLastNonblank
init|=
name|nLastChar
decl_stmt|;
name|int
name|oLastNonblank
init|=
name|oLastChar
decl_stmt|;
comment|/* find the last characters that really differ */
comment|/* can be -1 if no characters differ */
while|while
condition|(
name|CharEq
argument_list|(
name|newLine
index|[
name|nLastChar
index|]
argument_list|,
name|oldLine
index|[
name|oLastChar
index|]
argument_list|)
condition|)
block|{
comment|/* don't split a wide char */
if|if
condition|(
name|isWidecExt
argument_list|(
name|newLine
index|[
name|nLastChar
index|]
argument_list|)
operator|&&
operator|!
name|CharEq
argument_list|(
name|newLine
index|[
name|nLastChar
operator|-
literal|1
index|]
argument_list|,
name|oldLine
index|[
name|oLastChar
operator|-
literal|1
index|]
argument_list|)
condition|)
break|break;
name|nLastChar
operator|--
expr_stmt|;
name|oLastChar
operator|--
expr_stmt|;
if|if
condition|(
name|nLastChar
operator|==
operator|-
literal|1
operator|||
name|oLastChar
operator|==
operator|-
literal|1
condition|)
break|break;
block|}
name|n
operator|=
name|min
argument_list|(
name|oLastChar
argument_list|,
name|nLastChar
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|firstChar
condition|)
block|{
name|GoTo
argument_list|(
name|lineno
argument_list|,
name|firstChar
argument_list|)
expr_stmt|;
name|PutRange
argument_list|(
name|oldLine
argument_list|,
name|newLine
argument_list|,
name|lineno
argument_list|,
name|firstChar
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oLastChar
operator|<
name|nLastChar
condition|)
block|{
name|int
name|m
init|=
name|max
argument_list|(
name|nLastNonblank
argument_list|,
name|oLastNonblank
argument_list|)
decl_stmt|;
if|#
directive|if
name|USE_WIDEC_SUPPORT
while|while
condition|(
name|isWidecExt
argument_list|(
name|newLine
index|[
name|n
operator|+
literal|1
index|]
argument_list|)
operator|&&
name|n
condition|)
block|{
operator|--
name|n
expr_stmt|;
operator|--
name|oLastChar
expr_stmt|;
block|}
endif|#
directive|endif
name|GoTo
argument_list|(
name|lineno
argument_list|,
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nLastChar
operator|<
name|nLastNonblank
operator|)
operator|||
name|InsCharCost
argument_list|(
name|nLastChar
operator|-
name|oLastChar
argument_list|)
operator|>
operator|(
name|m
operator|-
name|n
operator|)
condition|)
block|{
name|PutRange
argument_list|(
name|oldLine
argument_list|,
name|newLine
argument_list|,
name|lineno
argument_list|,
name|n
operator|+
literal|1
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|InsStr
argument_list|(
operator|&
name|newLine
index|[
name|n
operator|+
literal|1
index|]
argument_list|,
name|nLastChar
operator|-
name|oLastChar
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|oLastChar
operator|>
name|nLastChar
condition|)
block|{
name|GoTo
argument_list|(
name|lineno
argument_list|,
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|DelCharCost
argument_list|(
name|oLastChar
operator|-
name|nLastChar
argument_list|)
operator|>
name|SP
operator|->
name|_el_cost
operator|+
name|nLastNonblank
operator|-
operator|(
name|n
operator|+
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|PutRange
argument_list|(
name|oldLine
argument_list|,
name|newLine
argument_list|,
name|lineno
argument_list|,
name|n
operator|+
literal|1
argument_list|,
name|nLastNonblank
argument_list|)
condition|)
name|GoTo
argument_list|(
name|lineno
argument_list|,
name|nLastNonblank
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ClrToEOL
argument_list|(
name|blank
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		     * The delete-char sequence will 		     * effectively shift in blanks from the 		     * right margin of the screen.  Ensure 		     * that they are the right color by 		     * setting the video attributes from 		     * the last character on the row. 		     */
name|UpdateAttrs
argument_list|(
name|blank
argument_list|)
expr_stmt|;
name|DelChar
argument_list|(
name|oLastChar
operator|-
name|nLastChar
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* update the code's internal representation */
if|if
condition|(
name|screen_columns
operator|>
name|firstChar
condition|)
name|memcpy
argument_list|(
name|oldLine
operator|+
name|firstChar
argument_list|,
name|newLine
operator|+
name|firstChar
argument_list|,
operator|(
name|screen_columns
operator|-
name|firstChar
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|NCURSES_CH_T
argument_list|)
argument_list|)
expr_stmt|;
name|TR
argument_list|(
name|TRACE_UPDATE
argument_list|,
operator|(
name|T_RETURN
argument_list|(
literal|""
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* **	ClearScreen(blank) ** **	Clear the physical screen and put cursor at home ** */
end_comment

begin_function
specifier|static
name|void
name|ClearScreen
parameter_list|(
name|NCURSES_CH_T
name|blank
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|bool
name|fast_clear
init|=
operator|(
name|clear_screen
operator|||
name|clr_eos
operator|||
name|clr_eol
operator|)
decl_stmt|;
name|TR
argument_list|(
name|TRACE_UPDATE
argument_list|,
operator|(
literal|"ClearScreen() called"
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|NCURSES_EXT_FUNCS
if|if
condition|(
name|SP
operator|->
name|_coloron
operator|&&
operator|!
name|SP
operator|->
name|_default_color
condition|)
block|{
name|_nc_do_color
argument_list|(
name|GET_SCREEN_PAIR
argument_list|(
name|SP
argument_list|)
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|_nc_outch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|back_color_erase
condition|)
block|{
name|fast_clear
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|fast_clear
condition|)
block|{
if|if
condition|(
name|clear_screen
condition|)
block|{
name|UpdateAttrs
argument_list|(
name|blank
argument_list|)
expr_stmt|;
name|TPUTS_TRACE
argument_list|(
literal|"clear_screen"
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|clear_screen
argument_list|)
expr_stmt|;
name|SP
operator|->
name|_cursrow
operator|=
name|SP
operator|->
name|_curscol
operator|=
literal|0
expr_stmt|;
name|position_check
argument_list|(
name|SP
operator|->
name|_cursrow
argument_list|,
name|SP
operator|->
name|_curscol
argument_list|,
literal|"ClearScreen"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|clr_eos
condition|)
block|{
name|SP
operator|->
name|_cursrow
operator|=
name|SP
operator|->
name|_curscol
operator|=
operator|-
literal|1
expr_stmt|;
name|GoTo
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|UpdateAttrs
argument_list|(
name|blank
argument_list|)
expr_stmt|;
name|TPUTS_TRACE
argument_list|(
literal|"clr_eos"
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|clr_eos
argument_list|,
name|screen_lines
argument_list|,
name|_nc_outch
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|clr_eol
condition|)
block|{
name|SP
operator|->
name|_cursrow
operator|=
name|SP
operator|->
name|_curscol
operator|=
operator|-
literal|1
expr_stmt|;
name|UpdateAttrs
argument_list|(
name|blank
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|screen_lines
condition|;
name|i
operator|++
control|)
block|{
name|GoTo
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TPUTS_TRACE
argument_list|(
literal|"clr_eol"
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|clr_eol
argument_list|)
expr_stmt|;
block|}
name|GoTo
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|UpdateAttrs
argument_list|(
name|blank
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|screen_lines
condition|;
name|i
operator|++
control|)
block|{
name|GoTo
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|screen_columns
condition|;
name|j
operator|++
control|)
name|PutChar
argument_list|(
name|CHREF
argument_list|(
name|blank
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|GoTo
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|screen_lines
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|screen_columns
condition|;
name|j
operator|++
control|)
name|curscr
operator|->
name|_line
index|[
name|i
index|]
operator|.
name|text
index|[
name|j
index|]
operator|=
name|blank
expr_stmt|;
block|}
name|TR
argument_list|(
name|TRACE_UPDATE
argument_list|,
operator|(
literal|"screen cleared"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	InsStr(line, count) ** **	Insert the count characters pointed to by line. ** */
end_comment

begin_function
specifier|static
name|void
name|InsStr
parameter_list|(
name|NCURSES_CH_T
modifier|*
name|line
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|TR
argument_list|(
name|TRACE_UPDATE
argument_list|,
operator|(
literal|"InsStr(%p,%d) called"
operator|,
name|line
operator|,
name|count
operator|)
argument_list|)
expr_stmt|;
comment|/* Prefer parm_ich as it has the smallest cost - no need to shift      * the whole line on each character. */
comment|/* The order must match that of InsCharCost. */
if|if
condition|(
name|parm_ich
condition|)
block|{
name|TPUTS_TRACE
argument_list|(
literal|"parm_ich"
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|TPARM_1
argument_list|(
name|parm_ich
argument_list|,
name|count
argument_list|)
argument_list|,
name|count
argument_list|,
name|_nc_outch
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
condition|)
block|{
name|PutAttrChar
argument_list|(
name|CHREF
argument_list|(
operator|*
name|line
argument_list|)
argument_list|)
expr_stmt|;
name|line
operator|++
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|enter_insert_mode
operator|&&
name|exit_insert_mode
condition|)
block|{
name|TPUTS_TRACE
argument_list|(
literal|"enter_insert_mode"
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|enter_insert_mode
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
condition|)
block|{
name|PutAttrChar
argument_list|(
name|CHREF
argument_list|(
operator|*
name|line
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|insert_padding
condition|)
block|{
name|TPUTS_TRACE
argument_list|(
literal|"insert_padding"
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|insert_padding
argument_list|)
expr_stmt|;
block|}
name|line
operator|++
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
name|TPUTS_TRACE
argument_list|(
literal|"exit_insert_mode"
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|exit_insert_mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|count
condition|)
block|{
name|TPUTS_TRACE
argument_list|(
literal|"insert_character"
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|insert_character
argument_list|)
expr_stmt|;
name|PutAttrChar
argument_list|(
name|CHREF
argument_list|(
operator|*
name|line
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|insert_padding
condition|)
block|{
name|TPUTS_TRACE
argument_list|(
literal|"insert_padding"
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|insert_padding
argument_list|)
expr_stmt|;
block|}
name|line
operator|++
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
block|}
name|position_check
argument_list|(
name|SP
operator|->
name|_cursrow
argument_list|,
name|SP
operator|->
name|_curscol
argument_list|,
literal|"InsStr"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	DelChar(count) ** **	Delete count characters at current position ** */
end_comment

begin_function
specifier|static
name|void
name|DelChar
parameter_list|(
name|int
name|count
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|TR
argument_list|(
name|TRACE_UPDATE
argument_list|,
operator|(
literal|"DelChar(%d) called, position = (%ld,%ld)"
operator|,
name|count
operator|,
operator|(
name|long
operator|)
name|newscr
operator|->
name|_cury
operator|,
operator|(
name|long
operator|)
name|newscr
operator|->
name|_curx
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parm_dch
condition|)
block|{
name|TPUTS_TRACE
argument_list|(
literal|"parm_dch"
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|TPARM_1
argument_list|(
name|parm_dch
argument_list|,
name|count
argument_list|)
argument_list|,
name|count
argument_list|,
name|_nc_outch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|count
condition|;
name|n
operator|++
control|)
block|{
name|TPUTS_TRACE
argument_list|(
literal|"delete_character"
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|delete_character
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Physical-scrolling support  *  * This code was adapted from Keith Bostic's hardware scrolling  * support for 4.4BSD curses.  I (esr) translated it to use terminfo  * capabilities, narrowed the call interface slightly, and cleaned  * up some convoluted tests.  I also added support for the memory_above  * memory_below, and non_dest_scroll_region capabilities.  *  * For this code to work, we must have either  * change_scroll_region and scroll forward/reverse commands, or  * insert and delete line capabilities.  * When the scrolling region has been set, the cursor has to  * be at the last line of the region to make the scroll up  * happen, or on the first line of region to scroll down.  *  * This code makes one aesthetic decision in the opposite way from  * BSD curses.  BSD curses preferred pairs of il/dl operations  * over scrolls, allegedly because il/dl looked faster.  We, on  * the other hand, prefer scrolls because (a) they're just as fast  * on many terminals and (b) using them avoids bouncing an  * unchanged bottom section of the screen up and down, which is  * visually nasty.  *  * (lav): added more cases, used dl/il when bot==maxy and in csr case.  *  * I used assumption that capabilities il/il1/dl/dl1 work inside  * changed scroll region not shifting screen contents outside of it.  * If there are any terminals behaving different way, it would be  * necessary to add some conditions to scroll_csr_forward/backward.  */
end_comment

begin_comment
comment|/* Try to scroll up assuming given csr (miny, maxy). Returns ERR on failure */
end_comment

begin_function
specifier|static
name|int
name|scroll_csr_forward
parameter_list|(
name|int
name|n
parameter_list|,
name|int
name|top
parameter_list|,
name|int
name|bot
parameter_list|,
name|int
name|miny
parameter_list|,
name|int
name|maxy
parameter_list|,
name|NCURSES_CH_T
name|blank
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|1
operator|&&
name|scroll_forward
operator|&&
name|top
operator|==
name|miny
operator|&&
name|bot
operator|==
name|maxy
condition|)
block|{
name|GoTo
argument_list|(
name|bot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|UpdateAttrs
argument_list|(
name|blank
argument_list|)
expr_stmt|;
name|TPUTS_TRACE
argument_list|(
literal|"scroll_forward"
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|scroll_forward
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|==
literal|1
operator|&&
name|delete_line
operator|&&
name|bot
operator|==
name|maxy
condition|)
block|{
name|GoTo
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|UpdateAttrs
argument_list|(
name|blank
argument_list|)
expr_stmt|;
name|TPUTS_TRACE
argument_list|(
literal|"delete_line"
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|delete_line
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parm_index
operator|&&
name|top
operator|==
name|miny
operator|&&
name|bot
operator|==
name|maxy
condition|)
block|{
name|GoTo
argument_list|(
name|bot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|UpdateAttrs
argument_list|(
name|blank
argument_list|)
expr_stmt|;
name|TPUTS_TRACE
argument_list|(
literal|"parm_index"
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|TPARM_2
argument_list|(
name|parm_index
argument_list|,
name|n
argument_list|,
literal|0
argument_list|)
argument_list|,
name|n
argument_list|,
name|_nc_outch
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parm_delete_line
operator|&&
name|bot
operator|==
name|maxy
condition|)
block|{
name|GoTo
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|UpdateAttrs
argument_list|(
name|blank
argument_list|)
expr_stmt|;
name|TPUTS_TRACE
argument_list|(
literal|"parm_delete_line"
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|TPARM_2
argument_list|(
name|parm_delete_line
argument_list|,
name|n
argument_list|,
literal|0
argument_list|)
argument_list|,
name|n
argument_list|,
name|_nc_outch
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scroll_forward
operator|&&
name|top
operator|==
name|miny
operator|&&
name|bot
operator|==
name|maxy
condition|)
block|{
name|GoTo
argument_list|(
name|bot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|UpdateAttrs
argument_list|(
name|blank
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|TPUTS_TRACE
argument_list|(
literal|"scroll_forward"
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|scroll_forward
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|delete_line
operator|&&
name|bot
operator|==
name|maxy
condition|)
block|{
name|GoTo
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|UpdateAttrs
argument_list|(
name|blank
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|TPUTS_TRACE
argument_list|(
literal|"delete_line"
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|delete_line
argument_list|)
expr_stmt|;
block|}
block|}
else|else
return|return
name|ERR
return|;
if|#
directive|if
name|NCURSES_EXT_FUNCS
if|if
condition|(
name|FILL_BCE
argument_list|()
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|GoTo
argument_list|(
name|bot
operator|-
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|screen_columns
condition|;
name|j
operator|++
control|)
name|PutChar
argument_list|(
name|CHREF
argument_list|(
name|blank
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/* Try to scroll down assuming given csr (miny, maxy). Returns ERR on failure */
end_comment

begin_comment
comment|/* n> 0 */
end_comment

begin_function
specifier|static
name|int
name|scroll_csr_backward
parameter_list|(
name|int
name|n
parameter_list|,
name|int
name|top
parameter_list|,
name|int
name|bot
parameter_list|,
name|int
name|miny
parameter_list|,
name|int
name|maxy
parameter_list|,
name|NCURSES_CH_T
name|blank
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|1
operator|&&
name|scroll_reverse
operator|&&
name|top
operator|==
name|miny
operator|&&
name|bot
operator|==
name|maxy
condition|)
block|{
name|GoTo
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|UpdateAttrs
argument_list|(
name|blank
argument_list|)
expr_stmt|;
name|TPUTS_TRACE
argument_list|(
literal|"scroll_reverse"
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|scroll_reverse
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|==
literal|1
operator|&&
name|insert_line
operator|&&
name|bot
operator|==
name|maxy
condition|)
block|{
name|GoTo
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|UpdateAttrs
argument_list|(
name|blank
argument_list|)
expr_stmt|;
name|TPUTS_TRACE
argument_list|(
literal|"insert_line"
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|insert_line
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parm_rindex
operator|&&
name|top
operator|==
name|miny
operator|&&
name|bot
operator|==
name|maxy
condition|)
block|{
name|GoTo
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|UpdateAttrs
argument_list|(
name|blank
argument_list|)
expr_stmt|;
name|TPUTS_TRACE
argument_list|(
literal|"parm_rindex"
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|TPARM_2
argument_list|(
name|parm_rindex
argument_list|,
name|n
argument_list|,
literal|0
argument_list|)
argument_list|,
name|n
argument_list|,
name|_nc_outch
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parm_insert_line
operator|&&
name|bot
operator|==
name|maxy
condition|)
block|{
name|GoTo
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|UpdateAttrs
argument_list|(
name|blank
argument_list|)
expr_stmt|;
name|TPUTS_TRACE
argument_list|(
literal|"parm_insert_line"
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|TPARM_2
argument_list|(
name|parm_insert_line
argument_list|,
name|n
argument_list|,
literal|0
argument_list|)
argument_list|,
name|n
argument_list|,
name|_nc_outch
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scroll_reverse
operator|&&
name|top
operator|==
name|miny
operator|&&
name|bot
operator|==
name|maxy
condition|)
block|{
name|GoTo
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|UpdateAttrs
argument_list|(
name|blank
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|TPUTS_TRACE
argument_list|(
literal|"scroll_reverse"
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|scroll_reverse
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|insert_line
operator|&&
name|bot
operator|==
name|maxy
condition|)
block|{
name|GoTo
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|UpdateAttrs
argument_list|(
name|blank
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|TPUTS_TRACE
argument_list|(
literal|"insert_line"
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|insert_line
argument_list|)
expr_stmt|;
block|}
block|}
else|else
return|return
name|ERR
return|;
if|#
directive|if
name|NCURSES_EXT_FUNCS
if|if
condition|(
name|FILL_BCE
argument_list|()
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|GoTo
argument_list|(
name|top
operator|+
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|screen_columns
condition|;
name|j
operator|++
control|)
name|PutChar
argument_list|(
name|CHREF
argument_list|(
name|blank
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/* scroll by using delete_line at del and insert_line at ins */
end_comment

begin_comment
comment|/* n> 0 */
end_comment

begin_function
specifier|static
name|int
name|scroll_idl
parameter_list|(
name|int
name|n
parameter_list|,
name|int
name|del
parameter_list|,
name|int
name|ins
parameter_list|,
name|NCURSES_CH_T
name|blank
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|parm_delete_line
operator|||
name|delete_line
operator|)
operator|&&
operator|(
name|parm_insert_line
operator|||
name|insert_line
operator|)
operator|)
condition|)
return|return
name|ERR
return|;
name|GoTo
argument_list|(
name|del
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|UpdateAttrs
argument_list|(
name|blank
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|1
operator|&&
name|delete_line
condition|)
block|{
name|TPUTS_TRACE
argument_list|(
literal|"delete_line"
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|delete_line
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parm_delete_line
condition|)
block|{
name|TPUTS_TRACE
argument_list|(
literal|"parm_delete_line"
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|TPARM_2
argument_list|(
name|parm_delete_line
argument_list|,
name|n
argument_list|,
literal|0
argument_list|)
argument_list|,
name|n
argument_list|,
name|_nc_outch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* if (delete_line) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|TPUTS_TRACE
argument_list|(
literal|"delete_line"
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|delete_line
argument_list|)
expr_stmt|;
block|}
block|}
name|GoTo
argument_list|(
name|ins
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|UpdateAttrs
argument_list|(
name|blank
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|1
operator|&&
name|insert_line
condition|)
block|{
name|TPUTS_TRACE
argument_list|(
literal|"insert_line"
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|insert_line
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parm_insert_line
condition|)
block|{
name|TPUTS_TRACE
argument_list|(
literal|"parm_insert_line"
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|TPARM_2
argument_list|(
name|parm_insert_line
argument_list|,
name|n
argument_list|,
literal|0
argument_list|)
argument_list|,
name|n
argument_list|,
name|_nc_outch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* if (insert_line) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|TPUTS_TRACE
argument_list|(
literal|"insert_line"
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|insert_line
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*  * Note:  some terminals require the cursor to be within the scrolling margins  * before setting them.  Generally, the cursor must be at the appropriate end  * of the scrolling margins when issuing an indexing operation (it is not  * apparent whether it must also be at the left margin; we do this just to be  * safe).  To make the related cursor movement a little faster, we use the  * save/restore cursor capabilities if the terminal has them.  */
end_comment

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|_nc_scrolln
argument_list|(
argument|int n
argument_list|,
argument|int top
argument_list|,
argument|int bot
argument_list|,
argument|int maxy
argument_list|)
end_macro

begin_comment
comment|/* scroll region from top to bot by n lines */
end_comment

begin_block
block|{
name|NCURSES_CH_T
name|blank
init|=
name|ClrBlank
argument_list|(
name|stdscr
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bool
name|cursor_saved
init|=
name|FALSE
decl_stmt|;
name|int
name|res
decl_stmt|;
name|TR
argument_list|(
name|TRACE_MOVE
argument_list|,
operator|(
literal|"mvcur_scrolln(%d, %d, %d, %d)"
operator|,
name|n
operator|,
name|top
operator|,
name|bot
operator|,
name|maxy
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_XMC_SUPPORT
comment|/*      * If we scroll, we might remove a cookie.      */
if|if
condition|(
name|magic_cookie_glitch
operator|>
literal|0
condition|)
block|{
return|return
operator|(
name|ERR
operator|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
comment|/* scroll up (forward) */
comment|/* 	 * Explicitly clear if stuff pushed off top of region might 	 * be saved by the terminal. 	 */
name|res
operator|=
name|scroll_csr_forward
argument_list|(
name|n
argument_list|,
name|top
argument_list|,
name|bot
argument_list|,
literal|0
argument_list|,
name|maxy
argument_list|,
name|blank
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|ERR
operator|&&
name|change_scroll_region
condition|)
block|{
if|if
condition|(
operator|(
operator|(
operator|(
name|n
operator|==
literal|1
operator|&&
name|scroll_forward
operator|)
operator|||
name|parm_index
operator|)
operator|&&
operator|(
name|SP
operator|->
name|_cursrow
operator|==
name|bot
operator|||
name|SP
operator|->
name|_cursrow
operator|==
name|bot
operator|-
literal|1
operator|)
operator|)
operator|&&
name|save_cursor
operator|&&
name|restore_cursor
condition|)
block|{
name|cursor_saved
operator|=
name|TRUE
expr_stmt|;
name|TPUTS_TRACE
argument_list|(
literal|"save_cursor"
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|save_cursor
argument_list|)
expr_stmt|;
block|}
name|TPUTS_TRACE
argument_list|(
literal|"change_scroll_region"
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|TPARM_2
argument_list|(
name|change_scroll_region
argument_list|,
name|top
argument_list|,
name|bot
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cursor_saved
condition|)
block|{
name|TPUTS_TRACE
argument_list|(
literal|"restore_cursor"
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|restore_cursor
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SP
operator|->
name|_cursrow
operator|=
name|SP
operator|->
name|_curscol
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|res
operator|=
name|scroll_csr_forward
argument_list|(
name|n
argument_list|,
name|top
argument_list|,
name|bot
argument_list|,
name|top
argument_list|,
name|bot
argument_list|,
name|blank
argument_list|)
expr_stmt|;
name|TPUTS_TRACE
argument_list|(
literal|"change_scroll_region"
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|TPARM_2
argument_list|(
name|change_scroll_region
argument_list|,
literal|0
argument_list|,
name|maxy
argument_list|)
argument_list|)
expr_stmt|;
name|SP
operator|->
name|_cursrow
operator|=
name|SP
operator|->
name|_curscol
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|==
name|ERR
operator|&&
name|_nc_idlok
condition|)
name|res
operator|=
name|scroll_idl
argument_list|(
name|n
argument_list|,
name|top
argument_list|,
name|bot
operator|-
name|n
operator|+
literal|1
argument_list|,
name|blank
argument_list|)
expr_stmt|;
comment|/* 	 * Clear the newly shifted-in text. 	 */
if|if
condition|(
name|res
operator|!=
name|ERR
operator|&&
operator|(
name|non_dest_scroll_region
operator|||
operator|(
name|memory_below
operator|&&
name|bot
operator|==
name|maxy
operator|)
operator|)
condition|)
block|{
specifier|static
specifier|const
name|NCURSES_CH_T
name|blank2
init|=
name|NewChar
argument_list|(
name|BLANK_TEXT
argument_list|)
decl_stmt|;
if|if
condition|(
name|bot
operator|==
name|maxy
operator|&&
name|clr_eos
condition|)
block|{
name|GoTo
argument_list|(
name|bot
operator|-
name|n
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ClrToEOS
argument_list|(
name|blank2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|GoTo
argument_list|(
name|bot
operator|-
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ClrToEOL
argument_list|(
name|blank2
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* (n< 0) - scroll down (backward) */
name|res
operator|=
name|scroll_csr_backward
argument_list|(
operator|-
name|n
argument_list|,
name|top
argument_list|,
name|bot
argument_list|,
literal|0
argument_list|,
name|maxy
argument_list|,
name|blank
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|ERR
operator|&&
name|change_scroll_region
condition|)
block|{
if|if
condition|(
name|top
operator|!=
literal|0
operator|&&
operator|(
name|SP
operator|->
name|_cursrow
operator|==
name|top
operator|||
name|SP
operator|->
name|_cursrow
operator|==
name|top
operator|-
literal|1
operator|)
operator|&&
name|save_cursor
operator|&&
name|restore_cursor
condition|)
block|{
name|cursor_saved
operator|=
name|TRUE
expr_stmt|;
name|TPUTS_TRACE
argument_list|(
literal|"save_cursor"
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|save_cursor
argument_list|)
expr_stmt|;
block|}
name|TPUTS_TRACE
argument_list|(
literal|"change_scroll_region"
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|TPARM_2
argument_list|(
name|change_scroll_region
argument_list|,
name|top
argument_list|,
name|bot
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cursor_saved
condition|)
block|{
name|TPUTS_TRACE
argument_list|(
literal|"restore_cursor"
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|restore_cursor
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SP
operator|->
name|_cursrow
operator|=
name|SP
operator|->
name|_curscol
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|res
operator|=
name|scroll_csr_backward
argument_list|(
operator|-
name|n
argument_list|,
name|top
argument_list|,
name|bot
argument_list|,
name|top
argument_list|,
name|bot
argument_list|,
name|blank
argument_list|)
expr_stmt|;
name|TPUTS_TRACE
argument_list|(
literal|"change_scroll_region"
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|TPARM_2
argument_list|(
name|change_scroll_region
argument_list|,
literal|0
argument_list|,
name|maxy
argument_list|)
argument_list|)
expr_stmt|;
name|SP
operator|->
name|_cursrow
operator|=
name|SP
operator|->
name|_curscol
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|==
name|ERR
operator|&&
name|_nc_idlok
condition|)
name|res
operator|=
name|scroll_idl
argument_list|(
operator|-
name|n
argument_list|,
name|bot
operator|+
name|n
operator|+
literal|1
argument_list|,
name|top
argument_list|,
name|blank
argument_list|)
expr_stmt|;
comment|/* 	 * Clear the newly shifted-in text. 	 */
if|if
condition|(
name|res
operator|!=
name|ERR
operator|&&
operator|(
name|non_dest_scroll_region
operator|||
operator|(
name|memory_above
operator|&&
name|top
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
specifier|static
specifier|const
name|NCURSES_CH_T
name|blank2
init|=
name|NewChar
argument_list|(
name|BLANK_TEXT
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|-
name|n
condition|;
name|i
operator|++
control|)
block|{
name|GoTo
argument_list|(
name|i
operator|+
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ClrToEOL
argument_list|(
name|blank2
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|res
operator|==
name|ERR
condition|)
return|return
operator|(
name|ERR
operator|)
return|;
name|_nc_scroll_window
argument_list|(
name|curscr
argument_list|,
name|n
argument_list|,
name|top
argument_list|,
name|bot
argument_list|,
name|blank
argument_list|)
expr_stmt|;
comment|/* shift hash values too - they can be reused */
name|_nc_scroll_oldhash
argument_list|(
name|n
argument_list|,
name|top
argument_list|,
name|bot
argument_list|)
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
block|}
end_block

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|_nc_screen_resume
argument_list|(
argument|void
argument_list|)
end_macro

begin_block
block|{
comment|/* make sure terminal is in a sane known state */
name|SetAttr
argument_list|(
name|SCREEN_ATTRS
argument_list|(
name|SP
argument_list|)
argument_list|,
name|A_NORMAL
argument_list|)
expr_stmt|;
name|newscr
operator|->
name|_clear
operator|=
name|TRUE
expr_stmt|;
comment|/* reset color pairs and definitions */
if|if
condition|(
name|SP
operator|->
name|_coloron
operator|||
name|SP
operator|->
name|_color_defs
condition|)
name|_nc_reset_colors
argument_list|()
expr_stmt|;
comment|/* restore user-defined colors, if any */
if|if
condition|(
name|SP
operator|->
name|_color_defs
operator|<
literal|0
condition|)
block|{
name|int
name|n
decl_stmt|;
name|SP
operator|->
name|_color_defs
operator|=
operator|-
operator|(
name|SP
operator|->
name|_color_defs
operator|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|SP
operator|->
name|_color_defs
condition|;
operator|++
name|n
control|)
block|{
if|if
condition|(
name|SP
operator|->
name|_color_table
index|[
name|n
index|]
operator|.
name|init
condition|)
block|{
name|init_color
argument_list|(
name|n
argument_list|,
name|SP
operator|->
name|_color_table
index|[
name|n
index|]
operator|.
name|r
argument_list|,
name|SP
operator|->
name|_color_table
index|[
name|n
index|]
operator|.
name|g
argument_list|,
name|SP
operator|->
name|_color_table
index|[
name|n
index|]
operator|.
name|b
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|exit_attribute_mode
condition|)
name|putp
argument_list|(
name|exit_attribute_mode
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* turn off attributes */
if|if
condition|(
name|exit_alt_charset_mode
condition|)
name|putp
argument_list|(
name|exit_alt_charset_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|exit_standout_mode
condition|)
name|putp
argument_list|(
name|exit_standout_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|exit_underline_mode
condition|)
name|putp
argument_list|(
name|exit_underline_mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exit_insert_mode
condition|)
name|putp
argument_list|(
name|exit_insert_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|enter_am_mode
operator|&&
name|exit_am_mode
condition|)
name|putp
argument_list|(
name|auto_right_margin
condition|?
name|enter_am_mode
else|:
name|exit_am_mode
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|_nc_screen_init
argument_list|(
argument|void
argument_list|)
end_macro

begin_block
block|{
name|_nc_screen_resume
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* wrap up screen handling */
end_comment

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|_nc_screen_wrap
argument_list|(
argument|void
argument_list|)
end_macro

begin_block
block|{
name|UpdateAttrs
argument_list|(
name|normal
argument_list|)
expr_stmt|;
if|#
directive|if
name|NCURSES_EXT_FUNCS
if|if
condition|(
name|SP
operator|->
name|_coloron
operator|&&
operator|!
name|SP
operator|->
name|_default_color
condition|)
block|{
specifier|static
specifier|const
name|NCURSES_CH_T
name|blank
init|=
name|NewChar
argument_list|(
name|BLANK_TEXT
argument_list|)
decl_stmt|;
name|SP
operator|->
name|_default_color
operator|=
name|TRUE
expr_stmt|;
name|_nc_do_color
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|_nc_outch
argument_list|)
expr_stmt|;
name|SP
operator|->
name|_default_color
operator|=
name|FALSE
expr_stmt|;
name|mvcur
argument_list|(
name|SP
operator|->
name|_cursrow
argument_list|,
name|SP
operator|->
name|_curscol
argument_list|,
name|screen_lines
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ClrToEOL
argument_list|(
name|blank
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|SP
operator|->
name|_color_defs
condition|)
block|{
name|_nc_reset_colors
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_if
if|#
directive|if
name|USE_XMC_SUPPORT
end_if

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|_nc_do_xmc_glitch
argument_list|(
argument|attr_t previous
argument_list|)
end_macro

begin_block
block|{
name|attr_t
name|chg
init|=
name|XMC_CHANGES
argument_list|(
name|previous
operator|^
name|AttrOf
argument_list|(
name|SCREEN_ATTRS
argument_list|(
name|SP
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|chg
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|chg
operator|&
literal|1
condition|)
block|{
name|SP
operator|->
name|_curscol
operator|+=
name|magic_cookie_glitch
expr_stmt|;
if|if
condition|(
name|SP
operator|->
name|_curscol
operator|>=
name|SP
operator|->
name|_columns
condition|)
name|wrap_cursor
argument_list|()
expr_stmt|;
name|TR
argument_list|(
name|TRACE_UPDATE
argument_list|,
operator|(
literal|"bumped to %d,%d after cookie"
operator|,
name|SP
operator|->
name|_cursrow
operator|,
name|SP
operator|->
name|_curscol
operator|)
argument_list|)
expr_stmt|;
block|}
name|chg
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_XMC_SUPPORT */
end_comment

end_unit

