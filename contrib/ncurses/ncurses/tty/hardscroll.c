begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************************  * Copyright (c) 1998 Free Software Foundation, Inc.                        *  *                                                                          *  * Permission is hereby granted, free of charge, to any person obtaining a  *  * copy of this software and associated documentation files (the            *  * "Software"), to deal in the Software without restriction, including      *  * without limitation the rights to use, copy, modify, merge, publish,      *  * distribute, distribute with modifications, sublicense, and/or sell       *  * copies of the Software, and to permit persons to whom the Software is    *  * furnished to do so, subject to the following conditions:                 *  *                                                                          *  * The above copyright notice and this permission notice shall be included  *  * in all copies or substantial portions of the Software.                   *  *                                                                          *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *  * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *  * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *  *                                                                          *  * Except as contained in this notice, the name(s) of the above copyright   *  * holders shall not be used in advertising or otherwise to promote the     *  * sale, use or other dealings in this Software without prior written       *  * authorization.                                                           *  ****************************************************************************/
end_comment

begin_comment
comment|/****************************************************************************  *  Author: Zeyd M. Ben-Halim<zmbenhal@netcom.com> 1992,1995               *  *     and: Eric S. Raymond<esr@snark.thyrsus.com>                         *  ****************************************************************************/
end_comment

begin_comment
comment|/******************************************************************************  NAME    hardscroll.c -- hardware-scrolling optimization for ncurses  SYNOPSIS    void _nc_scroll_optimize(void)  DESCRIPTION 			OVERVIEW  This algorithm for computes optimum hardware scrolling to transform an old screen (curscr) into a new screen (newscr) via vertical line moves.  Because the screen has a `grain' (there are insert/delete/scroll line operations but no insert/delete/scroll column operations), it is efficient break the update algorithm into two pieces: a first stage that does only line moves, optimizing the end product of user-invoked insertions, deletions, and scrolls; and a second phase (corresponding to the present doupdate code in ncurses) that does only line transformations.  The common case we want hardware scrolling for is to handle line insertions and deletions in screen-oriented text-editors.  This two-stage approach will accomplish that at a low computation and code-size cost.  			LINE-MOVE COMPUTATION  Now, to a discussion of the line-move computation.  For expository purposes, consider the screen lines to be represented by integers 0..23 (with the understanding that the value of 23 may vary). Let a new line introduced by insertion, scrolling, or at the bottom of the screen following a line delete be given the index -1.  Assume that the real screen starts with lines 0..23.  Now, we have the following possible line-oriented operations on the screen:  Insertion: inserts a line at a given screen row, forcing all lines below to scroll forward.  The last screen line is lost.  For example, an insertion at line 5 would produce: 0..4 -1 5..23.  Deletion: deletes a line at a given screen row, forcing all lines below to scroll forward.  The last screen line is made new.  For example, a deletion at line 7 would produce: 0..6 8..23 -1.  Scroll up: move a range of lines up 1.  The bottom line of the range becomes new.  For example, scrolling up the region from 9 to 14 will produce 0..8 10..14 -1 15..23.  Scroll down: move a range of lines down 1.  The top line of the range becomes new.  For example, scrolling down the region from 12 to 16 will produce 0..11 -1 12..15 17..23.  Now, an obvious property of all these operations is that they preserve the order of old lines, though not their position in the sequence.  The key trick of this algorithm is that the original line indices described above are actually maintained as _line[].oldindex fields in the window structure, and stick to each line through scroll and insert/delete operations.  Thus, it is possible at update time to look at the oldnum fields and compute an optimal set of il/dl/scroll operations that will take the real screen lines to the virtual screen lines.  Once these vertical moves have been done, we can hand off to the second stage of the update algorithm, which does line transformations.  Note that the move computation does not need to have the full generality of a diff algorithm (which it superficially resembles) because lines cannot be moved out of order.  			THE ALGORITHM  The scrolling is done in two passes. The first pass is from top to bottom scroling hunks UP. The second one is from bottom to top scrolling hunks DOWN. Obviously enough, no lines to be scrolled will be destroyed. (lav)  HOW TO TEST THIS:  Use the following production:  hardscroll: hardscroll.c 	$(CC) -g -DSCROLLDEBUG hardscroll.c -o hardscroll  Then just type scramble vectors and watch.  The following test loads are a representative sample of cases:  -----------------------------  CUT HERE ------------------------------------ # No lines moved  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # # A scroll up  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 -1 # # A scroll down -1  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 # # An insertion (after line 12)  0  1  2  3  4  5  6  7  8  9 10 11 12 -1 13 14 15 16 17 18 19 20 21 22 # # A simple deletion (line 10)  0  1  2  3  4  5  6  7  8  9  11 12 13 14 15 16 17 18 19 20 21 22 23 -1 # # A more complex case -1 -1 -1 -1 -1  3  4  5  6  7  -1 -1  8  9 10 11 12 13 14 15 16 17 -1 -1 -----------------------------  CUT HERE ------------------------------------  AUTHOR     Eric S. Raymond<esr@snark.thyrsus.com>, November 1994     New algorithm by Alexander V. Lukyanov<lav@yars.free.net>, Aug 1997  *****************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<curses.priv.h>
end_include

begin_macro
name|MODULE_ID
argument_list|(
literal|"$Id: hardscroll.c,v 1.33 1999/02/27 20:01:29 tom Exp $"
argument_list|)
end_macro

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SCROLLDEBUG
argument_list|)
operator|||
name|defined
argument_list|(
name|HASHDEBUG
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|screen_lines
end_undef

begin_define
define|#
directive|define
name|screen_lines
value|MAXLINES
end_define

begin_decl_stmt
name|int
name|oldnums
index|[
name|MAXLINES
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|OLDNUM
parameter_list|(
name|n
parameter_list|)
value|oldnums[n]
end_define

begin_define
define|#
directive|define
name|_tracef
value|printf
end_define

begin_undef
undef|#
directive|undef
name|TR
end_undef

begin_define
define|#
directive|define
name|TR
parameter_list|(
name|n
parameter_list|,
name|a
parameter_list|)
value|if (_nc_tracing& (n)) { _tracef a ; putchar('\n'); }
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* no debug */
end_comment

begin_comment
comment|/* OLDNUM(n) indicates which line will be shifted to the position n.    if OLDNUM(n) == _NEWINDEX, then the line n in new, not shifted from    somewhere. */
end_comment

begin_if
if|#
directive|if
name|USE_HASHMAP
end_if

begin_decl_stmt
name|int
modifier|*
name|_nc_oldnums
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|oldnums_allocated
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|oldnums
value|_nc_oldnums
end_define

begin_define
define|#
directive|define
name|OLDNUM
parameter_list|(
name|n
parameter_list|)
value|oldnums[n]
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !USE_HASHMAP */
end_comment

begin_define
define|#
directive|define
name|OLDNUM
parameter_list|(
name|n
parameter_list|)
value|newscr->_line[n].oldindex
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !USE_HASHMAP */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(SCROLLDEBUG) || defined(HASHDEBUG) */
end_comment

begin_function
name|void
name|_nc_scroll_optimize
parameter_list|(
name|void
parameter_list|)
comment|/* scroll optimization to transform curscr to newscr */
block|{
name|int
name|i
decl_stmt|;
name|int
name|start
decl_stmt|,
name|end
decl_stmt|,
name|shift
decl_stmt|;
name|TR
argument_list|(
name|TRACE_ICALLS
argument_list|,
operator|(
literal|"_nc_scroll_optimize() begins"
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SCROLLDEBUG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HASHDEBUG
argument_list|)
if|#
directive|if
name|USE_HASHMAP
comment|/* get enough storage */
if|if
condition|(
name|oldnums_allocated
operator|<
name|screen_lines
condition|)
block|{
name|int
modifier|*
name|new_oldnums
init|=
name|typeRealloc
argument_list|(
name|int
argument_list|,
name|screen_lines
argument_list|,
name|oldnums
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|new_oldnums
condition|)
return|return;
name|oldnums
operator|=
name|new_oldnums
expr_stmt|;
name|oldnums_allocated
operator|=
name|screen_lines
expr_stmt|;
block|}
comment|/* calculate the indices */
name|_nc_hash_map
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* !defined(SCROLLDEBUG)&& !defined(HASHDEBUG) */
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|_nc_tracing
operator|&
operator|(
name|TRACE_UPDATE
operator||
name|TRACE_MOVE
operator|)
condition|)
name|_nc_linedump
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* TRACE */
comment|/* pass 1 - from top to bottom scrolling up */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|screen_lines
condition|;
control|)
block|{
while|while
condition|(
name|i
operator|<
name|screen_lines
operator|&&
operator|(
name|OLDNUM
argument_list|(
name|i
argument_list|)
operator|==
name|_NEWINDEX
operator|||
name|OLDNUM
argument_list|(
name|i
argument_list|)
operator|<=
name|i
operator|)
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|screen_lines
condition|)
break|break;
name|shift
operator|=
name|OLDNUM
argument_list|(
name|i
argument_list|)
operator|-
name|i
expr_stmt|;
comment|/* shift> 0 */
name|start
operator|=
name|i
expr_stmt|;
name|i
operator|++
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|screen_lines
operator|&&
name|OLDNUM
argument_list|(
name|i
argument_list|)
operator|!=
name|_NEWINDEX
operator|&&
name|OLDNUM
argument_list|(
name|i
argument_list|)
operator|-
name|i
operator|==
name|shift
condition|)
name|i
operator|++
expr_stmt|;
name|end
operator|=
name|i
operator|-
literal|1
operator|+
name|shift
expr_stmt|;
name|TR
argument_list|(
name|TRACE_UPDATE
operator||
name|TRACE_MOVE
argument_list|,
operator|(
literal|"scroll [%d, %d] by %d"
operator|,
name|start
operator|,
name|end
operator|,
name|shift
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SCROLLDEBUG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HASHDEBUG
argument_list|)
if|if
condition|(
name|_nc_scrolln
argument_list|(
name|shift
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|screen_lines
operator|-
literal|1
argument_list|)
operator|==
name|ERR
condition|)
block|{
name|TR
argument_list|(
name|TRACE_UPDATE
operator||
name|TRACE_MOVE
argument_list|,
operator|(
literal|"unable to scroll"
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
comment|/* !defined(SCROLLDEBUG)&& !defined(HASHDEBUG) */
block|}
comment|/* pass 2 - from bottom to top scrolling down */
for|for
control|(
name|i
operator|=
name|screen_lines
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
control|)
block|{
while|while
condition|(
name|i
operator|>=
literal|0
operator|&&
operator|(
name|OLDNUM
argument_list|(
name|i
argument_list|)
operator|==
name|_NEWINDEX
operator|||
name|OLDNUM
argument_list|(
name|i
argument_list|)
operator|>=
name|i
operator|)
condition|)
name|i
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
break|break;
name|shift
operator|=
name|OLDNUM
argument_list|(
name|i
argument_list|)
operator|-
name|i
expr_stmt|;
comment|/* shift< 0 */
name|end
operator|=
name|i
expr_stmt|;
name|i
operator|--
expr_stmt|;
while|while
condition|(
name|i
operator|>=
literal|0
operator|&&
name|OLDNUM
argument_list|(
name|i
argument_list|)
operator|!=
name|_NEWINDEX
operator|&&
name|OLDNUM
argument_list|(
name|i
argument_list|)
operator|-
name|i
operator|==
name|shift
condition|)
name|i
operator|--
expr_stmt|;
name|start
operator|=
name|i
operator|+
literal|1
operator|-
operator|(
operator|-
name|shift
operator|)
expr_stmt|;
name|TR
argument_list|(
name|TRACE_UPDATE
operator||
name|TRACE_MOVE
argument_list|,
operator|(
literal|"scroll [%d, %d] by %d"
operator|,
name|start
operator|,
name|end
operator|,
name|shift
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SCROLLDEBUG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HASHDEBUG
argument_list|)
if|if
condition|(
name|_nc_scrolln
argument_list|(
name|shift
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|screen_lines
operator|-
literal|1
argument_list|)
operator|==
name|ERR
condition|)
block|{
name|TR
argument_list|(
name|TRACE_UPDATE
operator||
name|TRACE_MOVE
argument_list|,
operator|(
literal|"unable to scroll"
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
comment|/* !defined(SCROLLDEBUG)&& !defined(HASHDEBUG) */
block|}
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TRACE
argument_list|)
operator|||
name|defined
argument_list|(
name|SCROLLDEBUG
argument_list|)
operator|||
name|defined
argument_list|(
name|HASHDEBUG
argument_list|)
end_if

begin_function
name|void
name|_nc_linedump
parameter_list|(
name|void
parameter_list|)
comment|/* dump the state of the real and virtual oldnum fields */
block|{
specifier|static
name|size_t
name|have
decl_stmt|;
specifier|static
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|n
decl_stmt|;
name|size_t
name|want
init|=
operator|(
name|screen_lines
operator|+
literal|1
operator|)
operator|*
literal|4
decl_stmt|;
if|if
condition|(
name|have
operator|<
name|want
condition|)
name|buf
operator|=
name|typeMalloc
argument_list|(
name|char
argument_list|,
name|have
operator|=
name|want
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"virt"
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|screen_lines
condition|;
name|n
operator|++
control|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|" %02d"
argument_list|,
name|OLDNUM
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|TR
argument_list|(
name|TRACE_UPDATE
operator||
name|TRACE_MOVE
argument_list|,
operator|(
name|buf
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|NO_LEAKS
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|have
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(TRACE) || defined(SCROLLDEBUG) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SCROLLDEBUG
end_ifdef

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
name|GCC_UNUSED
parameter_list|,
name|char
modifier|*
name|argv
index|[]
name|GCC_UNUSED
parameter_list|)
block|{
name|char
name|line
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|st
decl_stmt|;
ifdef|#
directive|ifdef
name|TRACE
name|_nc_tracing
operator|=
name|TRACE_MOVE
expr_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|screen_lines
condition|;
name|n
operator|++
control|)
name|oldnums
index|[
name|n
index|]
operator|=
name|_NEWINDEX
expr_stmt|;
comment|/* grab the test vector */
if|if
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|stdin
argument_list|)
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
comment|/* parse it */
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
block|{
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|line
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|st
operator|=
name|strtok
argument_list|(
name|line
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
do|do
block|{
name|oldnums
index|[
name|n
operator|++
index|]
operator|=
name|atoi
argument_list|(
name|st
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|st
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" "
argument_list|)
operator|)
operator|!=
literal|0
condition|)
do|;
comment|/* display it */
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"Initial input:\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|_nc_linedump
argument_list|()
expr_stmt|;
name|_nc_scroll_optimize
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SCROLLDEBUG */
end_comment

begin_comment
comment|/* hardscroll.c ends here */
end_comment

end_unit

