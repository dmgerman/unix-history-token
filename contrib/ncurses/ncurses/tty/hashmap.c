begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************************  * Copyright (c) 1998-2005,2006 Free Software Foundation, Inc.                   *  *                                                                          *  * Permission is hereby granted, free of charge, to any person obtaining a  *  * copy of this software and associated documentation files (the            *  * "Software"), to deal in the Software without restriction, including      *  * without limitation the rights to use, copy, modify, merge, publish,      *  * distribute, distribute with modifications, sublicense, and/or sell       *  * copies of the Software, and to permit persons to whom the Software is    *  * furnished to do so, subject to the following conditions:                 *  *                                                                          *  * The above copyright notice and this permission notice shall be included  *  * in all copies or substantial portions of the Software.                   *  *                                                                          *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *  * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *  * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *  *                                                                          *  * Except as contained in this notice, the name(s) of the above copyright   *  * holders shall not be used in advertising or otherwise to promote the     *  * sale, use or other dealings in this Software without prior written       *  * authorization.                                                           *  ****************************************************************************/
end_comment

begin_comment
comment|/****************************************************************************  *  Author: Zeyd M. Ben-Halim<zmbenhal@netcom.com> 1992,1995               *  *     and: Eric S. Raymond<esr@snark.thyrsus.com>                         *  ****************************************************************************/
end_comment

begin_comment
comment|/******************************************************************************  NAME    hashmap.c -- fill in scramble vector based on text hashes  SYNOPSIS    void _nc_hash_map(void)  DESCRIPTION:    This code attempts to recognize pairs of old and new lines in the physical and virtual screens.  When a line pair is recognized, the old line index is placed in the oldindex member of the virtual screen line, to be used by the vertical-motion optimizer portion of the update logic (see hardscroll.c).     Line pairs are recognized by applying a modified Heckel's algorithm, sped up by hashing.  If a line hash is unique in both screens, those lines must be a pair. Then if the lines just before or after the pair are the same or similar, they are a pair too.     We don't worry about false pairs produced by hash collisions, on the assumption that such cases are rare and will only make the latter stages of update less efficient, not introduce errors.  HOW TO TEST THIS:  Use the following production:  hashmap: hashmap.c 	$(CC) -g -DHASHDEBUG hashmap.c hardscroll.c ../objects/lib_trace.o -o hashmap  AUTHOR     Eric S. Raymond<esr@snark.thyrsus.com>, May 1996     Bug fixes and improvements by Alexander V. Lukyanov<lav@yars.free.net>, 1997  *****************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<curses.priv.h>
end_include

begin_include
include|#
directive|include
file|<term.h>
end_include

begin_comment
comment|/* for back_color_erase */
end_comment

begin_macro
name|MODULE_ID
argument_list|(
literal|"$Id: hashmap.c,v 1.49 2006/03/11 19:33:49 tom Exp $"
argument_list|)
end_macro

begin_ifdef
ifdef|#
directive|ifdef
name|HASHDEBUG
end_ifdef

begin_define
define|#
directive|define
name|_tracef
value|printf
end_define

begin_undef
undef|#
directive|undef
name|TR
end_undef

begin_define
define|#
directive|define
name|TR
parameter_list|(
name|n
parameter_list|,
name|a
parameter_list|)
value|if (_nc_tracing& (n)) { _tracef a ; putchar('\n'); }
end_define

begin_undef
undef|#
directive|undef
name|screen_lines
end_undef

begin_define
define|#
directive|define
name|screen_lines
value|MAXLINES
end_define

begin_define
define|#
directive|define
name|TEXTWIDTH
value|1
end_define

begin_decl_stmt
name|int
name|oldnums
index|[
name|MAXLINES
index|]
decl_stmt|,
name|reallines
index|[
name|MAXLINES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|chtype
name|oldtext
index|[
name|MAXLINES
index|]
index|[
name|TEXTWIDTH
index|]
decl_stmt|,
name|newtext
index|[
name|MAXLINES
index|]
index|[
name|TEXTWIDTH
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|OLDNUM
parameter_list|(
name|n
parameter_list|)
value|oldnums[n]
end_define

begin_define
define|#
directive|define
name|OLDTEXT
parameter_list|(
name|n
parameter_list|)
value|oldtext[n]
end_define

begin_define
define|#
directive|define
name|NEWTEXT
parameter_list|(
name|m
parameter_list|)
value|newtext[m]
end_define

begin_define
define|#
directive|define
name|PENDING
parameter_list|(
name|n
parameter_list|)
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !HASHDEBUG */
end_comment

begin_define
define|#
directive|define
name|OLDNUM
parameter_list|(
name|n
parameter_list|)
value|_nc_oldnums[n]
end_define

begin_define
define|#
directive|define
name|OLDTEXT
parameter_list|(
name|n
parameter_list|)
value|curscr->_line[n].text
end_define

begin_define
define|#
directive|define
name|NEWTEXT
parameter_list|(
name|m
parameter_list|)
value|newscr->_line[m].text
end_define

begin_define
define|#
directive|define
name|TEXTWIDTH
value|(curscr->_maxx+1)
end_define

begin_define
define|#
directive|define
name|PENDING
parameter_list|(
name|n
parameter_list|)
value|(newscr->_line[n].firstchar != _NOCHANGE)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HASHDEBUG */
end_comment

begin_define
define|#
directive|define
name|oldhash
value|(SP->oldhash)
end_define

begin_define
define|#
directive|define
name|newhash
value|(SP->newhash)
end_define

begin_define
define|#
directive|define
name|hashtab
value|(SP->hashtab)
end_define

begin_define
define|#
directive|define
name|lines_alloc
value|(SP->hashtab_len)
end_define

begin_if
if|#
directive|if
name|USE_WIDEC_SUPPORT
end_if

begin_define
define|#
directive|define
name|HASH_VAL
parameter_list|(
name|ch
parameter_list|)
value|(ch.chars[0])
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|HASH_VAL
parameter_list|(
name|ch
parameter_list|)
value|(ch)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|NCURSES_CH_T
name|blankchar
init|=
name|NewChar
argument_list|(
name|BLANK_TEXT
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|NCURSES_INLINE
name|unsigned
name|long
name|hash
parameter_list|(
name|NCURSES_CH_T
modifier|*
name|text
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|NCURSES_CH_T
name|ch
decl_stmt|;
name|unsigned
name|long
name|result
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|TEXTWIDTH
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|ch
operator|=
operator|*
name|text
operator|++
expr_stmt|;
name|result
operator|+=
operator|(
name|result
operator|<<
literal|5
operator|)
operator|+
name|HASH_VAL
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* approximate update cost */
end_comment

begin_function
specifier|static
name|int
name|update_cost
parameter_list|(
name|NCURSES_CH_T
modifier|*
name|from
parameter_list|,
name|NCURSES_CH_T
modifier|*
name|to
parameter_list|)
block|{
name|int
name|cost
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|TEXTWIDTH
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|!
operator|(
name|CharEq
argument_list|(
operator|*
name|from
operator|++
argument_list|,
operator|*
name|to
operator|++
argument_list|)
operator|)
condition|)
name|cost
operator|++
expr_stmt|;
return|return
name|cost
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|update_cost_from_blank
parameter_list|(
name|NCURSES_CH_T
modifier|*
name|to
parameter_list|)
block|{
name|int
name|cost
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|NCURSES_CH_T
name|blank
init|=
name|blankchar
decl_stmt|;
if|if
condition|(
name|back_color_erase
condition|)
name|SetPair
argument_list|(
name|blank
argument_list|,
name|GetPair
argument_list|(
name|stdscr
operator|->
name|_nc_bkgd
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|TEXTWIDTH
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|!
operator|(
name|CharEq
argument_list|(
name|blank
argument_list|,
operator|*
name|to
operator|++
argument_list|)
operator|)
condition|)
name|cost
operator|++
expr_stmt|;
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/*  * Returns true when moving line 'from' to line 'to' seems to be cost  * effective. 'blank' indicates whether the line 'to' would become blank.  */
end_comment

begin_function
specifier|static
name|NCURSES_INLINE
name|bool
name|cost_effective
parameter_list|(
specifier|const
name|int
name|from
parameter_list|,
specifier|const
name|int
name|to
parameter_list|,
specifier|const
name|bool
name|blank
parameter_list|)
block|{
name|int
name|new_from
decl_stmt|;
if|if
condition|(
name|from
operator|==
name|to
condition|)
return|return
name|FALSE
return|;
name|new_from
operator|=
name|OLDNUM
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_from
operator|==
name|_NEWINDEX
condition|)
name|new_from
operator|=
name|from
expr_stmt|;
comment|/*      * On the left side of>= is the cost before moving;      * on the right side -- cost after moving.      */
return|return
operator|(
operator|(
operator|(
name|blank
condition|?
name|update_cost_from_blank
argument_list|(
name|NEWTEXT
argument_list|(
name|to
argument_list|)
argument_list|)
else|:
name|update_cost
argument_list|(
name|OLDTEXT
argument_list|(
name|to
argument_list|)
argument_list|,
name|NEWTEXT
argument_list|(
name|to
argument_list|)
argument_list|)
operator|)
operator|+
name|update_cost
argument_list|(
name|OLDTEXT
argument_list|(
name|new_from
argument_list|)
argument_list|,
name|NEWTEXT
argument_list|(
name|from
argument_list|)
argument_list|)
operator|)
operator|>=
operator|(
operator|(
name|new_from
operator|==
name|from
condition|?
name|update_cost_from_blank
argument_list|(
name|NEWTEXT
argument_list|(
name|from
argument_list|)
argument_list|)
else|:
name|update_cost
argument_list|(
name|OLDTEXT
argument_list|(
name|new_from
argument_list|)
argument_list|,
name|NEWTEXT
argument_list|(
name|from
argument_list|)
argument_list|)
operator|)
operator|+
name|update_cost
argument_list|(
name|OLDTEXT
argument_list|(
name|from
argument_list|)
argument_list|,
name|NEWTEXT
argument_list|(
name|to
argument_list|)
argument_list|)
operator|)
operator|)
condition|?
name|TRUE
else|:
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|grow_hunks
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|start
decl_stmt|,
name|end
decl_stmt|,
name|shift
decl_stmt|;
name|int
name|back_limit
decl_stmt|,
name|forward_limit
decl_stmt|;
comment|/* limits for cells to fill */
name|int
name|back_ref_limit
decl_stmt|,
name|forward_ref_limit
decl_stmt|;
comment|/* limits for refrences */
name|int
name|i
decl_stmt|;
name|int
name|next_hunk
decl_stmt|;
comment|/*      * This is tricky part.  We have unique pairs to use as anchors.      * Use these to deduce the presence of spans of identical lines.      */
name|back_limit
operator|=
literal|0
expr_stmt|;
name|back_ref_limit
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|screen_lines
operator|&&
name|OLDNUM
argument_list|(
name|i
argument_list|)
operator|==
name|_NEWINDEX
condition|)
name|i
operator|++
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|screen_lines
condition|;
name|i
operator|=
name|next_hunk
control|)
block|{
name|start
operator|=
name|i
expr_stmt|;
name|shift
operator|=
name|OLDNUM
argument_list|(
name|i
argument_list|)
operator|-
name|i
expr_stmt|;
comment|/* get forward limit */
name|i
operator|=
name|start
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|screen_lines
operator|&&
name|OLDNUM
argument_list|(
name|i
argument_list|)
operator|!=
name|_NEWINDEX
operator|&&
name|OLDNUM
argument_list|(
name|i
argument_list|)
operator|-
name|i
operator|==
name|shift
condition|)
name|i
operator|++
expr_stmt|;
name|end
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|screen_lines
operator|&&
name|OLDNUM
argument_list|(
name|i
argument_list|)
operator|==
name|_NEWINDEX
condition|)
name|i
operator|++
expr_stmt|;
name|next_hunk
operator|=
name|i
expr_stmt|;
name|forward_limit
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|screen_lines
operator|||
name|OLDNUM
argument_list|(
name|i
argument_list|)
operator|>=
name|i
condition|)
name|forward_ref_limit
operator|=
name|i
expr_stmt|;
else|else
name|forward_ref_limit
operator|=
name|OLDNUM
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|i
operator|=
name|start
operator|-
literal|1
expr_stmt|;
comment|/* grow back */
if|if
condition|(
name|shift
operator|<
literal|0
condition|)
name|back_limit
operator|=
name|back_ref_limit
operator|+
operator|(
operator|-
name|shift
operator|)
expr_stmt|;
while|while
condition|(
name|i
operator|>=
name|back_limit
condition|)
block|{
if|if
condition|(
name|newhash
index|[
name|i
index|]
operator|==
name|oldhash
index|[
name|i
operator|+
name|shift
index|]
operator|||
name|cost_effective
argument_list|(
name|i
operator|+
name|shift
argument_list|,
name|i
argument_list|,
name|shift
operator|<
literal|0
argument_list|)
condition|)
block|{
name|OLDNUM
argument_list|(
name|i
argument_list|)
operator|=
name|i
operator|+
name|shift
expr_stmt|;
name|TR
argument_list|(
name|TRACE_UPDATE
operator||
name|TRACE_MOVE
argument_list|,
operator|(
literal|"connected new line %d to old line %d (backward continuation)"
operator|,
name|i
operator|,
name|i
operator|+
name|shift
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TR
argument_list|(
name|TRACE_UPDATE
operator||
name|TRACE_MOVE
argument_list|,
operator|(
literal|"not connecting new line %d to old line %d (backward continuation)"
operator|,
name|i
operator|,
name|i
operator|+
name|shift
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|i
operator|--
expr_stmt|;
block|}
name|i
operator|=
name|end
expr_stmt|;
comment|/* grow forward */
if|if
condition|(
name|shift
operator|>
literal|0
condition|)
name|forward_limit
operator|=
name|forward_ref_limit
operator|-
name|shift
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|forward_limit
condition|)
block|{
if|if
condition|(
name|newhash
index|[
name|i
index|]
operator|==
name|oldhash
index|[
name|i
operator|+
name|shift
index|]
operator|||
name|cost_effective
argument_list|(
name|i
operator|+
name|shift
argument_list|,
name|i
argument_list|,
name|shift
operator|>
literal|0
argument_list|)
condition|)
block|{
name|OLDNUM
argument_list|(
name|i
argument_list|)
operator|=
name|i
operator|+
name|shift
expr_stmt|;
name|TR
argument_list|(
name|TRACE_UPDATE
operator||
name|TRACE_MOVE
argument_list|,
operator|(
literal|"connected new line %d to old line %d (forward continuation)"
operator|,
name|i
operator|,
name|i
operator|+
name|shift
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TR
argument_list|(
name|TRACE_UPDATE
operator||
name|TRACE_MOVE
argument_list|,
operator|(
literal|"not connecting new line %d to old line %d (forward continuation)"
operator|,
name|i
operator|,
name|i
operator|+
name|shift
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|i
operator|++
expr_stmt|;
block|}
name|back_ref_limit
operator|=
name|back_limit
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|shift
operator|>
literal|0
condition|)
name|back_ref_limit
operator|+=
name|shift
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|_nc_hash_map
argument_list|(
argument|void
argument_list|)
end_macro

begin_block
block|{
name|HASHMAP
modifier|*
name|sp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|start
decl_stmt|,
name|shift
decl_stmt|,
name|size
decl_stmt|;
if|if
condition|(
name|screen_lines
operator|>
name|lines_alloc
condition|)
block|{
if|if
condition|(
name|hashtab
condition|)
name|free
argument_list|(
name|hashtab
argument_list|)
expr_stmt|;
name|hashtab
operator|=
name|typeMalloc
argument_list|(
name|HASHMAP
argument_list|,
operator|(
name|screen_lines
operator|+
literal|1
operator|)
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hashtab
condition|)
block|{
if|if
condition|(
name|oldhash
condition|)
block|{
name|FreeAndNull
argument_list|(
name|oldhash
argument_list|)
expr_stmt|;
block|}
name|lines_alloc
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|lines_alloc
operator|=
name|screen_lines
expr_stmt|;
block|}
if|if
condition|(
name|oldhash
operator|&&
name|newhash
condition|)
block|{
comment|/* re-hash only changed lines */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|screen_lines
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|PENDING
argument_list|(
name|i
argument_list|)
condition|)
name|newhash
index|[
name|i
index|]
operator|=
name|hash
argument_list|(
name|NEWTEXT
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* re-hash all */
if|if
condition|(
name|oldhash
operator|==
literal|0
condition|)
name|oldhash
operator|=
name|typeCalloc
argument_list|(
argument|unsigned long
argument_list|,
argument|(unsigned) screen_lines
argument_list|)
expr_stmt|;
if|if
condition|(
name|newhash
operator|==
literal|0
condition|)
name|newhash
operator|=
name|typeCalloc
argument_list|(
argument|unsigned long
argument_list|,
argument|(unsigned) screen_lines
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|oldhash
operator|||
operator|!
name|newhash
condition|)
return|return;
comment|/* malloc failure */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|screen_lines
condition|;
name|i
operator|++
control|)
block|{
name|newhash
index|[
name|i
index|]
operator|=
name|hash
argument_list|(
name|NEWTEXT
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|oldhash
index|[
name|i
index|]
operator|=
name|hash
argument_list|(
name|OLDTEXT
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|HASH_VERIFY
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|screen_lines
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|newhash
index|[
name|i
index|]
operator|!=
name|hash
argument_list|(
name|NEWTEXT
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error in newhash[%d]\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldhash
index|[
name|i
index|]
operator|!=
name|hash
argument_list|(
name|OLDTEXT
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error in oldhash[%d]\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*      * Set up and count line-hash values.      */
name|memset
argument_list|(
name|hashtab
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hashtab
argument_list|)
operator|*
operator|(
name|screen_lines
operator|+
literal|1
operator|)
operator|*
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|screen_lines
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|long
name|hashval
init|=
name|oldhash
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|sp
operator|=
name|hashtab
init|;
name|sp
operator|->
name|hashval
condition|;
name|sp
operator|++
control|)
if|if
condition|(
name|sp
operator|->
name|hashval
operator|==
name|hashval
condition|)
break|break;
name|sp
operator|->
name|hashval
operator|=
name|hashval
expr_stmt|;
comment|/* in case this is a new entry */
name|sp
operator|->
name|oldcount
operator|++
expr_stmt|;
name|sp
operator|->
name|oldindex
operator|=
name|i
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|screen_lines
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|long
name|hashval
init|=
name|newhash
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|sp
operator|=
name|hashtab
init|;
name|sp
operator|->
name|hashval
condition|;
name|sp
operator|++
control|)
if|if
condition|(
name|sp
operator|->
name|hashval
operator|==
name|hashval
condition|)
break|break;
name|sp
operator|->
name|hashval
operator|=
name|hashval
expr_stmt|;
comment|/* in case this is a new entry */
name|sp
operator|->
name|newcount
operator|++
expr_stmt|;
name|sp
operator|->
name|newindex
operator|=
name|i
expr_stmt|;
name|OLDNUM
argument_list|(
name|i
argument_list|)
operator|=
name|_NEWINDEX
expr_stmt|;
comment|/* initialize old indices array */
block|}
comment|/*      * Mark line pairs corresponding to unique hash pairs.      *      * We don't mark lines with offset 0, because it can make fail      * extending hunks by cost_effective. Otherwise, it does not      * have any side effects.      */
for|for
control|(
name|sp
operator|=
name|hashtab
init|;
name|sp
operator|->
name|hashval
condition|;
name|sp
operator|++
control|)
if|if
condition|(
name|sp
operator|->
name|oldcount
operator|==
literal|1
operator|&&
name|sp
operator|->
name|newcount
operator|==
literal|1
operator|&&
name|sp
operator|->
name|oldindex
operator|!=
name|sp
operator|->
name|newindex
condition|)
block|{
name|TR
argument_list|(
name|TRACE_UPDATE
operator||
name|TRACE_MOVE
argument_list|,
operator|(
literal|"new line %d is hash-identical to old line %d (unique)"
operator|,
name|sp
operator|->
name|newindex
operator|,
name|sp
operator|->
name|oldindex
operator|)
argument_list|)
expr_stmt|;
name|OLDNUM
argument_list|(
name|sp
operator|->
name|newindex
argument_list|)
operator|=
name|sp
operator|->
name|oldindex
expr_stmt|;
block|}
name|grow_hunks
argument_list|()
expr_stmt|;
comment|/*      * Eliminate bad or impossible shifts -- this includes removing      * those hunks which could not grow because of conflicts, as well      * those which are to be moved too far, they are likely to destroy      * more than carry.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|screen_lines
condition|;
control|)
block|{
while|while
condition|(
name|i
operator|<
name|screen_lines
operator|&&
name|OLDNUM
argument_list|(
name|i
argument_list|)
operator|==
name|_NEWINDEX
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|screen_lines
condition|)
break|break;
name|start
operator|=
name|i
expr_stmt|;
name|shift
operator|=
name|OLDNUM
argument_list|(
name|i
argument_list|)
operator|-
name|i
expr_stmt|;
name|i
operator|++
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|screen_lines
operator|&&
name|OLDNUM
argument_list|(
name|i
argument_list|)
operator|!=
name|_NEWINDEX
operator|&&
name|OLDNUM
argument_list|(
name|i
argument_list|)
operator|-
name|i
operator|==
name|shift
condition|)
name|i
operator|++
expr_stmt|;
name|size
operator|=
name|i
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|3
operator|||
name|size
operator|+
name|min
argument_list|(
name|size
operator|/
literal|8
argument_list|,
literal|2
argument_list|)
operator|<
name|abs
argument_list|(
name|shift
argument_list|)
condition|)
block|{
while|while
condition|(
name|start
operator|<
name|i
condition|)
block|{
name|OLDNUM
argument_list|(
name|start
argument_list|)
operator|=
name|_NEWINDEX
expr_stmt|;
name|start
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* After clearing invalid hunks, try grow the rest. */
name|grow_hunks
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|_nc_make_oldhash
argument_list|(
argument|int i
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|oldhash
condition|)
name|oldhash
index|[
name|i
index|]
operator|=
name|hash
argument_list|(
name|OLDTEXT
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|_nc_scroll_oldhash
argument_list|(
argument|int n
argument_list|,
argument|int top
argument_list|,
argument|int bot
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|size
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|oldhash
condition|)
return|return;
name|size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|oldhash
argument_list|)
operator|*
operator|(
name|bot
operator|-
name|top
operator|+
literal|1
operator|-
name|abs
argument_list|(
name|n
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|memmove
argument_list|(
name|oldhash
operator|+
name|top
argument_list|,
name|oldhash
operator|+
name|top
operator|+
name|n
argument_list|,
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|bot
init|;
name|i
operator|>
name|bot
operator|-
name|n
condition|;
name|i
operator|--
control|)
name|oldhash
index|[
name|i
index|]
operator|=
name|hash
argument_list|(
name|OLDTEXT
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memmove
argument_list|(
name|oldhash
operator|+
name|top
operator|-
name|n
argument_list|,
name|oldhash
operator|+
name|top
argument_list|,
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|top
init|;
name|i
operator|<
name|top
operator|-
name|n
condition|;
name|i
operator|++
control|)
name|oldhash
index|[
name|i
index|]
operator|=
name|hash
argument_list|(
name|OLDTEXT
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|HASHDEBUG
end_ifdef

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|table
index|[]
init|=
block|{
literal|"hashmap test-driver"
block|,
literal|""
block|,
literal|"#  comment"
block|,
literal|"l  get initial line number vector"
block|,
literal|"n  use following letters as text of new lines"
block|,
literal|"o  use following letters as text of old lines"
block|,
literal|"d  dump state of test arrays"
block|,
literal|"h  apply hash mapper and see scroll optimization"
block|,
literal|"?  this message"
block|}
decl_stmt|;
name|size_t
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
sizeof|sizeof
argument_list|(
name|table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|table
index|[
literal|0
index|]
argument_list|)
condition|;
name|n
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|table
index|[
name|n
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
name|GCC_UNUSED
parameter_list|,
name|char
modifier|*
name|argv
index|[]
name|GCC_UNUSED
parameter_list|)
block|{
name|char
name|line
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|st
decl_stmt|;
name|int
name|n
decl_stmt|;
name|SP
operator|=
name|typeCalloc
argument_list|(
name|SCREEN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|screen_lines
condition|;
name|n
operator|++
control|)
block|{
name|reallines
index|[
name|n
index|]
operator|=
name|n
expr_stmt|;
name|oldnums
index|[
name|n
index|]
operator|=
name|_NEWINDEX
expr_stmt|;
name|oldtext
index|[
name|n
index|]
index|[
literal|0
index|]
operator|=
name|newtext
index|[
name|n
index|]
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
block|}
if|if
condition|(
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
condition|)
name|usage
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|TRACE
name|_nc_tracing
operator|=
name|TRACE_MOVE
expr_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* grab a test command */
if|if
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|stdin
argument_list|)
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|line
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'#'
case|:
comment|/* comment */
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|line
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* get initial line number vector */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|screen_lines
condition|;
name|n
operator|++
control|)
block|{
name|reallines
index|[
name|n
index|]
operator|=
name|n
expr_stmt|;
name|oldnums
index|[
name|n
index|]
operator|=
name|_NEWINDEX
expr_stmt|;
block|}
name|n
operator|=
literal|0
expr_stmt|;
name|st
operator|=
name|strtok
argument_list|(
name|line
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
do|do
block|{
name|oldnums
index|[
name|n
operator|++
index|]
operator|=
name|atoi
argument_list|(
name|st
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|st
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" "
argument_list|)
operator|)
operator|!=
literal|0
condition|)
do|;
break|break;
case|case
literal|'n'
case|:
comment|/* use following letters as text of new lines */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|screen_lines
condition|;
name|n
operator|++
control|)
name|newtext
index|[
name|n
index|]
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|screen_lines
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|line
index|[
name|n
operator|+
literal|1
index|]
operator|==
literal|'\n'
condition|)
break|break;
else|else
name|newtext
index|[
name|n
index|]
index|[
literal|0
index|]
operator|=
name|line
index|[
name|n
operator|+
literal|1
index|]
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* use following letters as text of old lines */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|screen_lines
condition|;
name|n
operator|++
control|)
name|oldtext
index|[
name|n
index|]
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|screen_lines
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|line
index|[
name|n
operator|+
literal|1
index|]
operator|==
literal|'\n'
condition|)
break|break;
else|else
name|oldtext
index|[
name|n
index|]
index|[
literal|0
index|]
operator|=
name|line
index|[
name|n
operator|+
literal|1
index|]
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* dump state of test arrays */
ifdef|#
directive|ifdef
name|TRACE
name|_nc_linedump
argument_list|()
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"Old lines: ["
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|screen_lines
condition|;
name|n
operator|++
control|)
name|putchar
argument_list|(
name|oldtext
index|[
name|n
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"New lines: ["
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|screen_lines
condition|;
name|n
operator|++
control|)
name|putchar
argument_list|(
name|newtext
index|[
name|n
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* apply hash mapper and see scroll optimization */
name|_nc_hash_map
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"Result:\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TRACE
name|_nc_linedump
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|_nc_scroll_optimize
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"Done.\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|usage
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
return|return
name|EXIT_SUCCESS
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HASHDEBUG */
end_comment

begin_comment
comment|/* hashmap.c ends here */
end_comment

end_unit

