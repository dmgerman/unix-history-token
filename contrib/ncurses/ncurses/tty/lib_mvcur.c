begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************************  * Copyright (c) 1998-2005,2006 Free Software Foundation, Inc.              *  *                                                                          *  * Permission is hereby granted, free of charge, to any person obtaining a  *  * copy of this software and associated documentation files (the            *  * "Software"), to deal in the Software without restriction, including      *  * without limitation the rights to use, copy, modify, merge, publish,      *  * distribute, distribute with modifications, sublicense, and/or sell       *  * copies of the Software, and to permit persons to whom the Software is    *  * furnished to do so, subject to the following conditions:                 *  *                                                                          *  * The above copyright notice and this permission notice shall be included  *  * in all copies or substantial portions of the Software.                   *  *                                                                          *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *  * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *  * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *  *                                                                          *  * Except as contained in this notice, the name(s) of the above copyright   *  * holders shall not be used in advertising or otherwise to promote the     *  * sale, use or other dealings in this Software without prior written       *  * authorization.                                                           *  ****************************************************************************/
end_comment

begin_comment
comment|/****************************************************************************  *  Author: Zeyd M. Ben-Halim<zmbenhal@netcom.com> 1992,1995               *  *     and: Eric S. Raymond<esr@snark.thyrsus.com>                         *  *     and: Thomas E. Dickey                        1996-on                 *  ****************************************************************************/
end_comment

begin_comment
comment|/* **	lib_mvcur.c ** **	The routines for moving the physical cursor and scrolling: ** **		void _nc_mvcur_init(void) ** **		void _nc_mvcur_resume(void) ** **		int mvcur(int old_y, int old_x, int new_y, int new_x) ** **		void _nc_mvcur_wrap(void) ** ** Comparisons with older movement optimizers: **    SVr3 curses mvcur() can't use cursor_to_ll or auto_left_margin. **    4.4BSD curses can't use cuu/cud/cuf/cub/hpa/vpa/tab/cbt for local ** motions.  It doesn't use tactics based on auto_left_margin.  Weirdly ** enough, it doesn't use its own hardware-scrolling routine to scroll up ** destination lines for out-of-bounds addresses! **    old ncurses optimizer: less accurate cost computations (in fact, ** it was broken and had to be commented out!). ** ** Compile with -DMAIN to build an interactive tester/timer for the movement ** optimizer.  You can use it to investigate the optimizer's behavior. ** You can also use it for tuning the formulas used to determine whether ** or not full optimization is attempted. ** ** This code has a nasty tendency to find bugs in terminfo entries, because it ** exercises the non-cup movement capabilities heavily.  If you think you've ** found a bug, try deleting subsets of the following capabilities (arranged ** in decreasing order of suspiciousness): it, tab, cbt, hpa, vpa, cuu, cud, ** cuf, cub, cuu1, cud1, cuf1, cub1.  It may be that one or more are wrong. ** ** Note: you should expect this code to look like a resource hog in a profile. ** That's because it does a lot of I/O, through the tputs() calls.  The I/O ** cost swamps the computation overhead (and as machines get faster, this ** will become even more true).  Comments in the test exerciser at the end ** go into detail about tuning and how you can gauge the optimizer's ** effectiveness. **/
end_comment

begin_comment
comment|/****************************************************************************  *  * Constants and macros for optimizer tuning.  *  ****************************************************************************/
end_comment

begin_comment
comment|/*  * The average overhead of a full optimization computation in character  * transmission times.  If it's too high, the algorithm will be a bit  * over-biased toward using cup rather than local motions; if it's too  * low, the algorithm may spend more time than is strictly optimal  * looking for non-cup motions.  Profile the optimizer using the `t'  * command of the exerciser (see below), and round to the nearest integer.  *  * Yes, I (esr) thought about computing expected overhead dynamically, say  * by derivation from a running average of optimizer times.  But the  * whole point of this optimization is to *decrease* the frequency of  * system calls. :-)  */
end_comment

begin_define
define|#
directive|define
name|COMPUTE_OVERHEAD
value|1
end_define

begin_comment
comment|/* I use a 90MHz Pentium @ 9.6Kbps */
end_comment

begin_comment
comment|/*  * LONG_DIST is the distance we consider to be just as costly to move over as a  * cup sequence is to emit.  In other words, it's the length of a cup sequence  * adjusted for average computation overhead.  The magic number is the length  * of "\033[yy;xxH", the typical cup sequence these days.  */
end_comment

begin_define
define|#
directive|define
name|LONG_DIST
value|(8 - COMPUTE_OVERHEAD)
end_define

begin_comment
comment|/*  * Tell whether a motion is optimizable by local motions.  Needs to be cheap to  * compute. In general, all the fast moves go to either the right or left edge  * of the screen.  So any motion to a location that is (a) further away than  * LONG_DIST and (b) further inward from the right or left edge than LONG_DIST,  * we'll consider nonlocal.  */
end_comment

begin_define
define|#
directive|define
name|NOT_LOCAL
parameter_list|(
name|fy
parameter_list|,
name|fx
parameter_list|,
name|ty
parameter_list|,
name|tx
parameter_list|)
value|((tx> LONG_DIST) \&& (tx< screen_columns - 1 - LONG_DIST) \&& (abs(ty-fy) + abs(tx-fx)> LONG_DIST))
end_define

begin_comment
comment|/****************************************************************************  *  * External interfaces  *  ****************************************************************************/
end_comment

begin_comment
comment|/*  * For this code to work OK, the following components must live in the  * screen structure:  *  *	int		_char_padding;	// cost of character put  *	int		_cr_cost;	// cost of (carriage_return)  *	int		_cup_cost;	// cost of (cursor_address)  *	int		_home_cost;	// cost of (cursor_home)  *	int		_ll_cost;	// cost of (cursor_to_ll)  *#if USE_HARD_TABS  *	int		_ht_cost;	// cost of (tab)  *	int		_cbt_cost;	// cost of (back_tab)  *#endif USE_HARD_TABS  *	int		_cub1_cost;	// cost of (cursor_left)  *	int		_cuf1_cost;	// cost of (cursor_right)  *	int		_cud1_cost;	// cost of (cursor_down)  *	int		_cuu1_cost;	// cost of (cursor_up)  *	int		_cub_cost;	// cost of (parm_cursor_left)  *	int		_cuf_cost;	// cost of (parm_cursor_right)  *	int		_cud_cost;	// cost of (parm_cursor_down)  *	int		_cuu_cost;	// cost of (parm_cursor_up)  *	int		_hpa_cost;	// cost of (column_address)  *	int		_vpa_cost;	// cost of (row_address)  *	int		_ech_cost;	// cost of (erase_chars)  *	int		_rep_cost;	// cost of (repeat_char)  *  * The USE_HARD_TABS switch controls whether it is reliable to use tab/backtabs  * for local motions.  On many systems, it's not, due to uncertainties about  * tab delays and whether or not tabs will be expanded in raw mode.  If you  * have parm_right_cursor, tab motions don't win you a lot anyhow.  */
end_comment

begin_include
include|#
directive|include
file|<curses.priv.h>
end_include

begin_include
include|#
directive|include
file|<term.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_macro
name|MODULE_ID
argument_list|(
literal|"$Id: lib_mvcur.c,v 1.107 2006/11/25 22:31:59 tom Exp $"
argument_list|)
end_macro

begin_define
define|#
directive|define
name|WANT_CHAR
parameter_list|(
name|y
parameter_list|,
name|x
parameter_list|)
value|SP->_newscr->_line[y].text[x]
end_define

begin_comment
comment|/* desired state */
end_comment

begin_define
define|#
directive|define
name|BAUDRATE
value|cur_term->_baudrate
end_define

begin_comment
comment|/* bits per second */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|MAIN
argument_list|)
operator|||
name|defined
argument_list|(
name|NCURSES_TEST
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_decl_stmt
specifier|static
name|bool
name|profiling
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|float
name|diff
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAIN */
end_comment

begin_define
define|#
directive|define
name|OPT_SIZE
value|512
end_define

begin_function_decl
specifier|static
name|int
name|normalized_cost
parameter_list|(
specifier|const
name|char
modifier|*
specifier|const
name|cap
parameter_list|,
name|int
name|affcnt
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/****************************************************************************  *  * Initialization/wrapup (including cost pre-computation)  *  ****************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TRACE
end_ifdef

begin_function
specifier|static
name|int
name|trace_cost_of
parameter_list|(
specifier|const
name|char
modifier|*
name|capname
parameter_list|,
specifier|const
name|char
modifier|*
name|cap
parameter_list|,
name|int
name|affcnt
parameter_list|)
block|{
name|int
name|result
init|=
name|_nc_msec_cost
argument_list|(
name|cap
argument_list|,
name|affcnt
argument_list|)
decl_stmt|;
name|TR
argument_list|(
name|TRACE_CHARPUT
operator||
name|TRACE_MOVE
argument_list|,
operator|(
literal|"CostOf %s %d %s"
operator|,
name|capname
operator|,
name|result
operator|,
name|_nc_visbuf
argument_list|(
name|cap
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CostOf
parameter_list|(
name|cap
parameter_list|,
name|affcnt
parameter_list|)
value|trace_cost_of(#cap,cap,affcnt);
end_define

begin_function
specifier|static
name|int
name|trace_normalized_cost
parameter_list|(
specifier|const
name|char
modifier|*
name|capname
parameter_list|,
specifier|const
name|char
modifier|*
name|cap
parameter_list|,
name|int
name|affcnt
parameter_list|)
block|{
name|int
name|result
init|=
name|normalized_cost
argument_list|(
name|cap
argument_list|,
name|affcnt
argument_list|)
decl_stmt|;
name|TR
argument_list|(
name|TRACE_CHARPUT
operator||
name|TRACE_MOVE
argument_list|,
operator|(
literal|"NormalizedCost %s %d %s"
operator|,
name|capname
operator|,
name|result
operator|,
name|_nc_visbuf
argument_list|(
name|cap
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_define
define|#
directive|define
name|NormalizedCost
parameter_list|(
name|cap
parameter_list|,
name|affcnt
parameter_list|)
value|trace_normalized_cost(#cap,cap,affcnt);
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CostOf
parameter_list|(
name|cap
parameter_list|,
name|affcnt
parameter_list|)
value|_nc_msec_cost(cap,affcnt);
end_define

begin_define
define|#
directive|define
name|NormalizedCost
parameter_list|(
name|cap
parameter_list|,
name|affcnt
parameter_list|)
value|normalized_cost(cap,affcnt);
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|_nc_msec_cost
argument_list|(
argument|const char *const cap
argument_list|,
argument|int affcnt
argument_list|)
end_macro

begin_comment
comment|/* compute the cost of a given operation */
end_comment

begin_block
block|{
if|if
condition|(
name|cap
operator|==
literal|0
condition|)
return|return
operator|(
name|INFINITY
operator|)
return|;
else|else
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|float
name|cum_cost
init|=
literal|0.0
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|cap
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
comment|/* extract padding, either mandatory or required */
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|==
literal|'$'
operator|&&
name|cp
index|[
literal|1
index|]
operator|==
literal|'<'
operator|&&
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'>'
argument_list|)
condition|)
block|{
name|float
name|number
init|=
literal|0.0
decl_stmt|;
for|for
control|(
name|cp
operator|+=
literal|2
init|;
operator|*
name|cp
operator|!=
literal|'>'
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|UChar
argument_list|(
operator|*
name|cp
argument_list|)
argument_list|)
condition|)
name|number
operator|=
name|number
operator|*
literal|10
operator|+
operator|(
operator|*
name|cp
operator|-
literal|'0'
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'*'
condition|)
name|number
operator|*=
name|affcnt
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'.'
operator|&&
operator|(
operator|*
operator|++
name|cp
operator|!=
literal|'>'
operator|)
operator|&&
name|isdigit
argument_list|(
name|UChar
argument_list|(
operator|*
name|cp
argument_list|)
argument_list|)
condition|)
name|number
operator|+=
operator|(
operator|*
name|cp
operator|-
literal|'0'
operator|)
operator|/
literal|10.0
expr_stmt|;
block|}
if|#
directive|if
name|NCURSES_NO_PADDING
if|if
condition|(
operator|!
operator|(
name|SP
operator|->
name|_no_padding
operator|)
condition|)
endif|#
directive|endif
name|cum_cost
operator|+=
name|number
operator|*
literal|10
expr_stmt|;
block|}
else|else
name|cum_cost
operator|+=
name|SP
operator|->
name|_char_padding
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|int
operator|)
name|cum_cost
operator|)
return|;
block|}
block|}
end_block

begin_function
specifier|static
name|int
name|normalized_cost
parameter_list|(
specifier|const
name|char
modifier|*
specifier|const
name|cap
parameter_list|,
name|int
name|affcnt
parameter_list|)
comment|/* compute the effective character-count for an operation (round up) */
block|{
name|int
name|cost
init|=
name|_nc_msec_cost
argument_list|(
name|cap
argument_list|,
name|affcnt
argument_list|)
decl_stmt|;
if|if
condition|(
name|cost
operator|!=
name|INFINITY
condition|)
name|cost
operator|=
operator|(
name|cost
operator|+
name|SP
operator|->
name|_char_padding
operator|-
literal|1
operator|)
operator|/
name|SP
operator|->
name|_char_padding
expr_stmt|;
return|return
name|cost
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|reset_scroll_region
parameter_list|(
name|void
parameter_list|)
comment|/* Set the scroll-region to a known state (the default) */
block|{
if|if
condition|(
name|change_scroll_region
condition|)
block|{
name|TPUTS_TRACE
argument_list|(
literal|"change_scroll_region"
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|TPARM_2
argument_list|(
name|change_scroll_region
argument_list|,
literal|0
argument_list|,
name|screen_lines
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|_nc_mvcur_resume
argument_list|(
argument|void
argument_list|)
end_macro

begin_comment
comment|/* what to do at initialization time and after each shellout */
end_comment

begin_block
block|{
comment|/* initialize screen for cursor access */
if|if
condition|(
name|enter_ca_mode
condition|)
block|{
name|TPUTS_TRACE
argument_list|(
literal|"enter_ca_mode"
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|enter_ca_mode
argument_list|)
expr_stmt|;
block|}
comment|/*      * Doing this here rather than in _nc_mvcur_wrap() ensures that      * ncurses programs will see a reset scroll region even if a      * program that messed with it died ungracefully.      *      * This also undoes the effects of terminal init strings that assume      * they know the screen size.  This is useful when you're running      * a vt100 emulation through xterm.      */
name|reset_scroll_region
argument_list|()
expr_stmt|;
name|SP
operator|->
name|_cursrow
operator|=
name|SP
operator|->
name|_curscol
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* restore cursor shape */
if|if
condition|(
name|SP
operator|->
name|_cursor
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|cursor
init|=
name|SP
operator|->
name|_cursor
decl_stmt|;
name|SP
operator|->
name|_cursor
operator|=
operator|-
literal|1
expr_stmt|;
name|curs_set
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|_nc_mvcur_init
argument_list|(
argument|void
argument_list|)
end_macro

begin_comment
comment|/* initialize the cost structure */
end_comment

begin_block
block|{
if|if
condition|(
name|isatty
argument_list|(
name|fileno
argument_list|(
name|SP
operator|->
name|_ofp
argument_list|)
argument_list|)
condition|)
name|SP
operator|->
name|_char_padding
operator|=
operator|(
operator|(
name|BAUDBYTE
operator|*
literal|1000
operator|*
literal|10
operator|)
operator|/
operator|(
name|BAUDRATE
operator|>
literal|0
condition|?
name|BAUDRATE
else|:
literal|9600
operator|)
operator|)
expr_stmt|;
else|else
name|SP
operator|->
name|_char_padding
operator|=
literal|1
expr_stmt|;
comment|/* must be nonzero */
if|if
condition|(
name|SP
operator|->
name|_char_padding
operator|<=
literal|0
condition|)
name|SP
operator|->
name|_char_padding
operator|=
literal|1
expr_stmt|;
comment|/* must be nonzero */
name|TR
argument_list|(
name|TRACE_CHARPUT
operator||
name|TRACE_MOVE
argument_list|,
operator|(
literal|"char_padding %d msecs"
operator|,
name|SP
operator|->
name|_char_padding
operator|)
argument_list|)
expr_stmt|;
comment|/* non-parameterized local-motion strings */
name|SP
operator|->
name|_cr_cost
operator|=
name|CostOf
argument_list|(
name|carriage_return
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SP
operator|->
name|_home_cost
operator|=
name|CostOf
argument_list|(
name|cursor_home
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SP
operator|->
name|_ll_cost
operator|=
name|CostOf
argument_list|(
name|cursor_to_ll
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_HARD_TABS
if|if
condition|(
name|getenv
argument_list|(
literal|"NCURSES_NO_HARD_TABS"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SP
operator|->
name|_ht_cost
operator|=
name|CostOf
argument_list|(
name|tab
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SP
operator|->
name|_cbt_cost
operator|=
name|CostOf
argument_list|(
name|back_tab
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SP
operator|->
name|_ht_cost
operator|=
name|INFINITY
expr_stmt|;
name|SP
operator|->
name|_cbt_cost
operator|=
name|INFINITY
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USE_HARD_TABS */
name|SP
operator|->
name|_cub1_cost
operator|=
name|CostOf
argument_list|(
name|cursor_left
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SP
operator|->
name|_cuf1_cost
operator|=
name|CostOf
argument_list|(
name|cursor_right
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SP
operator|->
name|_cud1_cost
operator|=
name|CostOf
argument_list|(
name|cursor_down
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SP
operator|->
name|_cuu1_cost
operator|=
name|CostOf
argument_list|(
name|cursor_up
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SP
operator|->
name|_smir_cost
operator|=
name|CostOf
argument_list|(
name|enter_insert_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SP
operator|->
name|_rmir_cost
operator|=
name|CostOf
argument_list|(
name|exit_insert_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SP
operator|->
name|_ip_cost
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|insert_padding
condition|)
block|{
name|SP
operator|->
name|_ip_cost
operator|=
name|CostOf
argument_list|(
name|insert_padding
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*      * Assumption: if the terminal has memory_relative addressing, the      * initialization strings or smcup will set single-page mode so we      * can treat it like absolute screen addressing.  This seems to be true      * for all cursor_mem_address terminal types in the terminfo database.      */
name|SP
operator|->
name|_address_cursor
operator|=
name|cursor_address
condition|?
name|cursor_address
else|:
name|cursor_mem_address
expr_stmt|;
comment|/*      * Parametrized local-motion strings.  This static cost computation      * depends on the following assumptions:      *      * (1) They never have * padding.  In the entire master terminfo database      *     as of March 1995, only the obsolete Zenith Z-100 pc violates this.      *     (Proportional padding is found mainly in insert, delete and scroll      *     capabilities).      *      * (2) The average case of cup has two two-digit parameters.  Strictly,      *     the average case for a 24 * 80 screen has ((10*10*(1 + 1)) +      *     (14*10*(1 + 2)) + (10*70*(2 + 1)) + (14*70*4)) / (24*80) = 3.458      *     digits of parameters.  On a 25x80 screen the average is 3.6197.      *     On larger screens the value gets much closer to 4.      *      * (3) The average case of cub/cuf/hpa/ech/rep has 2 digits of parameters      *     (strictly, (((10 * 1) + (70 * 2)) / 80) = 1.8750).      *      * (4) The average case of cud/cuu/vpa has 2 digits of parameters      *     (strictly, (((10 * 1) + (14 * 2)) / 24) = 1.5833).      *      * All these averages depend on the assumption that all parameter values      * are equally probable.      */
name|SP
operator|->
name|_cup_cost
operator|=
name|CostOf
argument_list|(
name|TPARM_2
argument_list|(
name|SP
operator|->
name|_address_cursor
argument_list|,
literal|23
argument_list|,
literal|23
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SP
operator|->
name|_cub_cost
operator|=
name|CostOf
argument_list|(
name|TPARM_1
argument_list|(
name|parm_left_cursor
argument_list|,
literal|23
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SP
operator|->
name|_cuf_cost
operator|=
name|CostOf
argument_list|(
name|TPARM_1
argument_list|(
name|parm_right_cursor
argument_list|,
literal|23
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SP
operator|->
name|_cud_cost
operator|=
name|CostOf
argument_list|(
name|TPARM_1
argument_list|(
name|parm_down_cursor
argument_list|,
literal|23
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SP
operator|->
name|_cuu_cost
operator|=
name|CostOf
argument_list|(
name|TPARM_1
argument_list|(
name|parm_up_cursor
argument_list|,
literal|23
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SP
operator|->
name|_hpa_cost
operator|=
name|CostOf
argument_list|(
name|TPARM_1
argument_list|(
name|column_address
argument_list|,
literal|23
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SP
operator|->
name|_vpa_cost
operator|=
name|CostOf
argument_list|(
name|TPARM_1
argument_list|(
name|row_address
argument_list|,
literal|23
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* non-parameterized screen-update strings */
name|SP
operator|->
name|_ed_cost
operator|=
name|NormalizedCost
argument_list|(
name|clr_eos
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SP
operator|->
name|_el_cost
operator|=
name|NormalizedCost
argument_list|(
name|clr_eol
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SP
operator|->
name|_el1_cost
operator|=
name|NormalizedCost
argument_list|(
name|clr_bol
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SP
operator|->
name|_dch1_cost
operator|=
name|NormalizedCost
argument_list|(
name|delete_character
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SP
operator|->
name|_ich1_cost
operator|=
name|NormalizedCost
argument_list|(
name|insert_character
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*      * If this is a bce-terminal, we want to bias the choice so we use clr_eol      * rather than spaces at the end of a line.      */
if|if
condition|(
name|back_color_erase
condition|)
name|SP
operator|->
name|_el_cost
operator|=
literal|0
expr_stmt|;
comment|/* parameterized screen-update strings */
name|SP
operator|->
name|_dch_cost
operator|=
name|NormalizedCost
argument_list|(
name|TPARM_1
argument_list|(
name|parm_dch
argument_list|,
literal|23
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SP
operator|->
name|_ich_cost
operator|=
name|NormalizedCost
argument_list|(
name|TPARM_1
argument_list|(
name|parm_ich
argument_list|,
literal|23
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SP
operator|->
name|_ech_cost
operator|=
name|NormalizedCost
argument_list|(
name|TPARM_1
argument_list|(
name|erase_chars
argument_list|,
literal|23
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SP
operator|->
name|_rep_cost
operator|=
name|NormalizedCost
argument_list|(
name|TPARM_2
argument_list|(
name|repeat_char
argument_list|,
literal|' '
argument_list|,
literal|23
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SP
operator|->
name|_cup_ch_cost
operator|=
name|NormalizedCost
argument_list|(
name|TPARM_2
argument_list|(
name|SP
operator|->
name|_address_cursor
argument_list|,
literal|23
argument_list|,
literal|23
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SP
operator|->
name|_hpa_ch_cost
operator|=
name|NormalizedCost
argument_list|(
name|TPARM_1
argument_list|(
name|column_address
argument_list|,
literal|23
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SP
operator|->
name|_cuf_ch_cost
operator|=
name|NormalizedCost
argument_list|(
name|TPARM_1
argument_list|(
name|parm_right_cursor
argument_list|,
literal|23
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SP
operator|->
name|_inline_cost
operator|=
name|min
argument_list|(
name|SP
operator|->
name|_cup_ch_cost
argument_list|,
name|min
argument_list|(
name|SP
operator|->
name|_hpa_ch_cost
argument_list|,
name|SP
operator|->
name|_cuf_ch_cost
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * If save_cursor is used within enter_ca_mode, we should not use it for      * scrolling optimization, since the corresponding restore_cursor is not      * nested on the various terminals (vt100, xterm, etc.) which use this      * feature.      */
if|if
condition|(
name|save_cursor
operator|!=
literal|0
operator|&&
name|enter_ca_mode
operator|!=
literal|0
operator|&&
name|strstr
argument_list|(
name|enter_ca_mode
argument_list|,
name|save_cursor
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|T
argument_list|(
operator|(
literal|"...suppressed sc/rc capability due to conflict with smcup/rmcup"
operator|)
argument_list|)
expr_stmt|;
name|save_cursor
operator|=
literal|0
expr_stmt|;
name|restore_cursor
operator|=
literal|0
expr_stmt|;
block|}
comment|/*      * A different, possibly better way to arrange this would be to set      * SP->_endwin = TRUE at window initialization time and let this be      * called by doupdate's return-from-shellout code.      */
name|_nc_mvcur_resume
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|_nc_mvcur_wrap
argument_list|(
argument|void
argument_list|)
end_macro

begin_comment
comment|/* wrap up cursor-addressing mode */
end_comment

begin_block
block|{
comment|/* leave cursor at screen bottom */
name|mvcur
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|screen_lines
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* set cursor to normal mode */
if|if
condition|(
name|SP
operator|->
name|_cursor
operator|!=
operator|-
literal|1
condition|)
name|curs_set
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|exit_ca_mode
condition|)
block|{
name|TPUTS_TRACE
argument_list|(
literal|"exit_ca_mode"
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|exit_ca_mode
argument_list|)
expr_stmt|;
block|}
comment|/*      * Reset terminal's tab counter.  There's a long-time bug that      * if you exit a "curses" program such as vi or more, tab      * forward, and then backspace, the cursor doesn't go to the      * right place.  The problem is that the kernel counts the      * escape sequences that reset things as column positions.      * Utter a \r to reset this invisibly.      */
name|_nc_outch
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/****************************************************************************  *  * Optimized cursor movement  *  ****************************************************************************/
end_comment

begin_comment
comment|/*  * Perform repeated-append, returning cost  */
end_comment

begin_function
specifier|static
name|NCURSES_INLINE
name|int
name|repeated_append
parameter_list|(
name|string_desc
modifier|*
name|target
parameter_list|,
name|int
name|total
parameter_list|,
name|int
name|num
parameter_list|,
name|int
name|repeat
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
name|size_t
name|need
init|=
name|repeat
operator|*
name|strlen
argument_list|(
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
name|need
operator|<
name|target
operator|->
name|s_size
condition|)
block|{
while|while
condition|(
name|repeat
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|_nc_safe_strcat
argument_list|(
name|target
argument_list|,
name|src
argument_list|)
condition|)
block|{
name|total
operator|+=
name|num
expr_stmt|;
block|}
else|else
block|{
name|total
operator|=
name|INFINITY
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|total
operator|=
name|INFINITY
expr_stmt|;
block|}
return|return
name|total
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_OPTIMIZE
end_ifndef

begin_define
define|#
directive|define
name|NEXTTAB
parameter_list|(
name|fr
parameter_list|)
value|(fr + init_tabs - (fr % init_tabs))
end_define

begin_comment
comment|/*  * Assume back_tab (CBT) does not wrap backwards at the left margin, return  * a negative value at that point to simplify the loop.  */
end_comment

begin_define
define|#
directive|define
name|LASTTAB
parameter_list|(
name|fr
parameter_list|)
value|((fr> 0) ? ((fr - 1) / init_tabs) * init_tabs : -1)
end_define

begin_function
specifier|static
name|int
name|relative_move
parameter_list|(
name|string_desc
modifier|*
name|target
parameter_list|,
name|int
name|from_y
parameter_list|,
name|int
name|from_x
parameter_list|,
name|int
name|to_y
parameter_list|,
name|int
name|to_x
parameter_list|,
name|bool
name|ovw
parameter_list|)
comment|/* move via local motions (cuu/cuu1/cud/cud1/cub1/cub/cuf1/cuf/vpa/hpa) */
block|{
name|string_desc
name|save
decl_stmt|;
name|int
name|n
decl_stmt|,
name|vcost
init|=
literal|0
decl_stmt|,
name|hcost
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|_nc_str_copy
argument_list|(
operator|&
name|save
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|to_y
operator|!=
name|from_y
condition|)
block|{
name|vcost
operator|=
name|INFINITY
expr_stmt|;
if|if
condition|(
name|row_address
operator|!=
literal|0
operator|&&
name|_nc_safe_strcat
argument_list|(
name|target
argument_list|,
name|TPARM_1
argument_list|(
name|row_address
argument_list|,
name|to_y
argument_list|)
argument_list|)
condition|)
block|{
name|vcost
operator|=
name|SP
operator|->
name|_vpa_cost
expr_stmt|;
block|}
if|if
condition|(
name|to_y
operator|>
name|from_y
condition|)
block|{
name|n
operator|=
operator|(
name|to_y
operator|-
name|from_y
operator|)
expr_stmt|;
if|if
condition|(
name|parm_down_cursor
operator|&&
name|SP
operator|->
name|_cud_cost
operator|<
name|vcost
operator|&&
name|_nc_safe_strcat
argument_list|(
name|_nc_str_copy
argument_list|(
name|target
argument_list|,
operator|&
name|save
argument_list|)
argument_list|,
name|TPARM_1
argument_list|(
name|parm_down_cursor
argument_list|,
name|n
argument_list|)
argument_list|)
condition|)
block|{
name|vcost
operator|=
name|SP
operator|->
name|_cud_cost
expr_stmt|;
block|}
if|if
condition|(
name|cursor_down
operator|&&
operator|(
operator|*
name|cursor_down
operator|!=
literal|'\n'
operator|||
name|SP
operator|->
name|_nl
operator|)
operator|&&
operator|(
name|n
operator|*
name|SP
operator|->
name|_cud1_cost
operator|<
name|vcost
operator|)
condition|)
block|{
name|vcost
operator|=
name|repeated_append
argument_list|(
name|_nc_str_copy
argument_list|(
name|target
argument_list|,
operator|&
name|save
argument_list|)
argument_list|,
literal|0
argument_list|,
name|SP
operator|->
name|_cud1_cost
argument_list|,
name|n
argument_list|,
name|cursor_down
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* (to_y< from_y) */
name|n
operator|=
operator|(
name|from_y
operator|-
name|to_y
operator|)
expr_stmt|;
if|if
condition|(
name|parm_up_cursor
operator|&&
name|SP
operator|->
name|_cuu_cost
operator|<
name|vcost
operator|&&
name|_nc_safe_strcat
argument_list|(
name|_nc_str_copy
argument_list|(
name|target
argument_list|,
operator|&
name|save
argument_list|)
argument_list|,
name|TPARM_1
argument_list|(
name|parm_up_cursor
argument_list|,
name|n
argument_list|)
argument_list|)
condition|)
block|{
name|vcost
operator|=
name|SP
operator|->
name|_cuu_cost
expr_stmt|;
block|}
if|if
condition|(
name|cursor_up
operator|&&
operator|(
name|n
operator|*
name|SP
operator|->
name|_cuu1_cost
operator|<
name|vcost
operator|)
condition|)
block|{
name|vcost
operator|=
name|repeated_append
argument_list|(
name|_nc_str_copy
argument_list|(
name|target
argument_list|,
operator|&
name|save
argument_list|)
argument_list|,
literal|0
argument_list|,
name|SP
operator|->
name|_cuu1_cost
argument_list|,
name|n
argument_list|,
name|cursor_up
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|vcost
operator|==
name|INFINITY
condition|)
return|return
operator|(
name|INFINITY
operator|)
return|;
block|}
name|save
operator|=
operator|*
name|target
expr_stmt|;
if|if
condition|(
name|to_x
operator|!=
name|from_x
condition|)
block|{
name|char
name|str
index|[
name|OPT_SIZE
index|]
decl_stmt|;
name|string_desc
name|check
decl_stmt|;
name|hcost
operator|=
name|INFINITY
expr_stmt|;
if|if
condition|(
name|column_address
operator|&&
name|_nc_safe_strcat
argument_list|(
name|_nc_str_copy
argument_list|(
name|target
argument_list|,
operator|&
name|save
argument_list|)
argument_list|,
name|TPARM_1
argument_list|(
name|column_address
argument_list|,
name|to_x
argument_list|)
argument_list|)
condition|)
block|{
name|hcost
operator|=
name|SP
operator|->
name|_hpa_cost
expr_stmt|;
block|}
if|if
condition|(
name|to_x
operator|>
name|from_x
condition|)
block|{
name|n
operator|=
name|to_x
operator|-
name|from_x
expr_stmt|;
if|if
condition|(
name|parm_right_cursor
operator|&&
name|SP
operator|->
name|_cuf_cost
operator|<
name|hcost
operator|&&
name|_nc_safe_strcat
argument_list|(
name|_nc_str_copy
argument_list|(
name|target
argument_list|,
operator|&
name|save
argument_list|)
argument_list|,
name|TPARM_1
argument_list|(
name|parm_right_cursor
argument_list|,
name|n
argument_list|)
argument_list|)
condition|)
block|{
name|hcost
operator|=
name|SP
operator|->
name|_cuf_cost
expr_stmt|;
block|}
if|if
condition|(
name|cursor_right
condition|)
block|{
name|int
name|lhcost
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|_nc_str_init
argument_list|(
operator|&
name|check
argument_list|,
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_HARD_TABS
comment|/* use hard tabs, if we have them, to do as much as possible */
if|if
condition|(
name|init_tabs
operator|>
literal|0
operator|&&
name|tab
condition|)
block|{
name|int
name|nxt
decl_stmt|,
name|fr
decl_stmt|;
for|for
control|(
name|fr
operator|=
name|from_x
init|;
operator|(
name|nxt
operator|=
name|NEXTTAB
argument_list|(
name|fr
argument_list|)
operator|)
operator|<=
name|to_x
condition|;
name|fr
operator|=
name|nxt
control|)
block|{
name|lhcost
operator|=
name|repeated_append
argument_list|(
operator|&
name|check
argument_list|,
name|lhcost
argument_list|,
name|SP
operator|->
name|_ht_cost
argument_list|,
literal|1
argument_list|,
name|tab
argument_list|)
expr_stmt|;
if|if
condition|(
name|lhcost
operator|==
name|INFINITY
condition|)
break|break;
block|}
name|n
operator|=
name|to_x
operator|-
name|fr
expr_stmt|;
name|from_x
operator|=
name|fr
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USE_HARD_TABS */
if|if
condition|(
name|n
operator|<=
literal|0
operator|||
name|n
operator|>=
operator|(
name|int
operator|)
name|check
operator|.
name|s_size
condition|)
name|ovw
operator|=
name|FALSE
expr_stmt|;
if|#
directive|if
name|BSD_TPUTS
comment|/* 		 * If we're allowing BSD-style padding in tputs, don't generate 		 * a string with a leading digit.  Otherwise, that will be 		 * interpreted as a padding value rather than sent to the 		 * screen. 		 */
if|if
condition|(
name|ovw
operator|&&
name|n
operator|>
literal|0
operator|&&
name|n
operator|<
operator|(
name|int
operator|)
name|check
operator|.
name|s_size
operator|&&
name|vcost
operator|==
literal|0
operator|&&
name|str
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|int
name|wanted
init|=
name|CharOf
argument_list|(
name|WANT_CHAR
argument_list|(
name|to_y
argument_list|,
name|from_x
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|is8bits
argument_list|(
name|wanted
argument_list|)
operator|&&
name|isdigit
argument_list|(
name|wanted
argument_list|)
condition|)
name|ovw
operator|=
name|FALSE
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 		 * If we have no attribute changes, overwrite is cheaper. 		 * Note: must suppress this by passing in ovw = FALSE whenever 		 * WANT_CHAR would return invalid data.  In particular, this 		 * is true between the time a hardware scroll has been done 		 * and the time the structure WANT_CHAR would access has been 		 * updated. 		 */
if|if
condition|(
name|ovw
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|NCURSES_CH_T
name|ch
init|=
name|WANT_CHAR
argument_list|(
name|to_y
argument_list|,
name|from_x
operator|+
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|SameAttrOf
argument_list|(
name|ch
argument_list|,
name|SCREEN_ATTRS
argument_list|(
name|SP
argument_list|)
argument_list|)
if|#
directive|if
name|USE_WIDEC_SUPPORT
operator|||
operator|!
name|Charable
argument_list|(
name|ch
argument_list|)
endif|#
directive|endif
condition|)
block|{
name|ovw
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|ovw
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
operator|*
name|check
operator|.
name|s_tail
operator|++
operator|=
name|CharOf
argument_list|(
name|WANT_CHAR
argument_list|(
name|to_y
argument_list|,
name|from_x
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|check
operator|.
name|s_tail
operator|=
literal|'\0'
expr_stmt|;
name|check
operator|.
name|s_size
operator|-=
name|n
expr_stmt|;
name|lhcost
operator|+=
name|n
operator|*
name|SP
operator|->
name|_char_padding
expr_stmt|;
block|}
else|else
block|{
name|lhcost
operator|=
name|repeated_append
argument_list|(
operator|&
name|check
argument_list|,
name|lhcost
argument_list|,
name|SP
operator|->
name|_cuf1_cost
argument_list|,
name|n
argument_list|,
name|cursor_right
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lhcost
operator|<
name|hcost
operator|&&
name|_nc_safe_strcat
argument_list|(
name|_nc_str_copy
argument_list|(
name|target
argument_list|,
operator|&
name|save
argument_list|)
argument_list|,
name|str
argument_list|)
condition|)
block|{
name|hcost
operator|=
name|lhcost
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* (to_x< from_x) */
name|n
operator|=
name|from_x
operator|-
name|to_x
expr_stmt|;
if|if
condition|(
name|parm_left_cursor
operator|&&
name|SP
operator|->
name|_cub_cost
operator|<
name|hcost
operator|&&
name|_nc_safe_strcat
argument_list|(
name|_nc_str_copy
argument_list|(
name|target
argument_list|,
operator|&
name|save
argument_list|)
argument_list|,
name|TPARM_1
argument_list|(
name|parm_left_cursor
argument_list|,
name|n
argument_list|)
argument_list|)
condition|)
block|{
name|hcost
operator|=
name|SP
operator|->
name|_cub_cost
expr_stmt|;
block|}
if|if
condition|(
name|cursor_left
condition|)
block|{
name|int
name|lhcost
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|_nc_str_init
argument_list|(
operator|&
name|check
argument_list|,
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_HARD_TABS
if|if
condition|(
name|init_tabs
operator|>
literal|0
operator|&&
name|back_tab
condition|)
block|{
name|int
name|nxt
decl_stmt|,
name|fr
decl_stmt|;
for|for
control|(
name|fr
operator|=
name|from_x
init|;
operator|(
name|nxt
operator|=
name|LASTTAB
argument_list|(
name|fr
argument_list|)
operator|)
operator|>=
name|to_x
condition|;
name|fr
operator|=
name|nxt
control|)
block|{
name|lhcost
operator|=
name|repeated_append
argument_list|(
operator|&
name|check
argument_list|,
name|lhcost
argument_list|,
name|SP
operator|->
name|_cbt_cost
argument_list|,
literal|1
argument_list|,
name|back_tab
argument_list|)
expr_stmt|;
if|if
condition|(
name|lhcost
operator|==
name|INFINITY
condition|)
break|break;
block|}
name|n
operator|=
name|fr
operator|-
name|to_x
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USE_HARD_TABS */
name|lhcost
operator|=
name|repeated_append
argument_list|(
operator|&
name|check
argument_list|,
name|lhcost
argument_list|,
name|SP
operator|->
name|_cub1_cost
argument_list|,
name|n
argument_list|,
name|cursor_left
argument_list|)
expr_stmt|;
if|if
condition|(
name|lhcost
operator|<
name|hcost
operator|&&
name|_nc_safe_strcat
argument_list|(
name|_nc_str_copy
argument_list|(
name|target
argument_list|,
operator|&
name|save
argument_list|)
argument_list|,
name|str
argument_list|)
condition|)
block|{
name|hcost
operator|=
name|lhcost
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|hcost
operator|==
name|INFINITY
condition|)
return|return
operator|(
name|INFINITY
operator|)
return|;
block|}
return|return
operator|(
name|vcost
operator|+
name|hcost
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !NO_OPTIMIZE */
end_comment

begin_comment
comment|/*  * With the machinery set up above, it's conceivable that  * onscreen_mvcur could be modified into a recursive function that does  * an alpha-beta search of motion space, as though it were a chess  * move tree, with the weight function being boolean and the search  * depth equated to length of string.  However, this would jack up the  * computation cost a lot, especially on terminals without a cup  * capability constraining the search tree depth.  So we settle for  * the simpler method below.  */
end_comment

begin_function
specifier|static
name|NCURSES_INLINE
name|int
name|onscreen_mvcur
parameter_list|(
name|int
name|yold
parameter_list|,
name|int
name|xold
parameter_list|,
name|int
name|ynew
parameter_list|,
name|int
name|xnew
parameter_list|,
name|bool
name|ovw
parameter_list|)
comment|/* onscreen move from (yold, xold) to (ynew, xnew) */
block|{
name|string_desc
name|result
decl_stmt|;
name|char
name|buffer
index|[
name|OPT_SIZE
index|]
decl_stmt|;
name|int
name|tactic
init|=
literal|0
decl_stmt|,
name|newcost
decl_stmt|,
name|usecost
init|=
name|INFINITY
decl_stmt|;
name|int
name|t5_cr_cost
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MAIN
argument_list|)
operator|||
name|defined
argument_list|(
name|NCURSES_TEST
argument_list|)
name|struct
name|timeval
name|before
decl_stmt|,
name|after
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|before
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MAIN */
define|#
directive|define
name|NullResult
value|_nc_str_null(&result, sizeof(buffer))
define|#
directive|define
name|InitResult
value|_nc_str_init(&result, buffer, sizeof(buffer))
comment|/* tactic #0: use direct cursor addressing */
if|if
condition|(
name|_nc_safe_strcpy
argument_list|(
name|InitResult
argument_list|,
name|TPARM_2
argument_list|(
name|SP
operator|->
name|_address_cursor
argument_list|,
name|ynew
argument_list|,
name|xnew
argument_list|)
argument_list|)
condition|)
block|{
name|tactic
operator|=
literal|0
expr_stmt|;
name|usecost
operator|=
name|SP
operator|->
name|_cup_cost
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TRACE
argument_list|)
operator|||
name|defined
argument_list|(
name|NCURSES_TEST
argument_list|)
if|if
condition|(
operator|!
operator|(
name|_nc_optimize_enable
operator|&
name|OPTIMIZE_MVCUR
operator|)
condition|)
goto|goto
name|nonlocal
goto|;
endif|#
directive|endif
comment|/* TRACE */
comment|/* 	 * We may be able to tell in advance that the full optimization 	 * will probably not be worth its overhead.  Also, don't try to 	 * use local movement if the current attribute is anything but 	 * A_NORMAL...there are just too many ways this can screw up 	 * (like, say, local-movement \n getting mapped to some obscure 	 * character because A_ALTCHARSET is on). 	 */
if|if
condition|(
name|yold
operator|==
operator|-
literal|1
operator|||
name|xold
operator|==
operator|-
literal|1
operator|||
name|NOT_LOCAL
argument_list|(
name|yold
argument_list|,
name|xold
argument_list|,
name|ynew
argument_list|,
name|xnew
argument_list|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|MAIN
argument_list|)
operator|||
name|defined
argument_list|(
name|NCURSES_TEST
argument_list|)
if|if
condition|(
operator|!
name|profiling
condition|)
block|{
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"nonlocal\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
goto|goto
name|nonlocal
goto|;
comment|/* always run the optimizer if profiling */
block|}
else|#
directive|else
goto|goto
name|nonlocal
goto|;
endif|#
directive|endif
comment|/* MAIN */
block|}
block|}
ifndef|#
directive|ifndef
name|NO_OPTIMIZE
comment|/* tactic #1: use local movement */
if|if
condition|(
name|yold
operator|!=
operator|-
literal|1
operator|&&
name|xold
operator|!=
operator|-
literal|1
operator|&&
operator|(
operator|(
name|newcost
operator|=
name|relative_move
argument_list|(
name|NullResult
argument_list|,
name|yold
argument_list|,
name|xold
argument_list|,
name|ynew
argument_list|,
name|xnew
argument_list|,
name|ovw
argument_list|)
operator|)
operator|!=
name|INFINITY
operator|)
operator|&&
name|newcost
operator|<
name|usecost
condition|)
block|{
name|tactic
operator|=
literal|1
expr_stmt|;
name|usecost
operator|=
name|newcost
expr_stmt|;
block|}
comment|/* tactic #2: use carriage-return + local movement */
if|if
condition|(
name|yold
operator|!=
operator|-
literal|1
operator|&&
name|carriage_return
operator|&&
operator|(
operator|(
name|newcost
operator|=
name|relative_move
argument_list|(
name|NullResult
argument_list|,
name|yold
argument_list|,
literal|0
argument_list|,
name|ynew
argument_list|,
name|xnew
argument_list|,
name|ovw
argument_list|)
operator|)
operator|!=
name|INFINITY
operator|)
operator|&&
name|SP
operator|->
name|_cr_cost
operator|+
name|newcost
operator|<
name|usecost
condition|)
block|{
name|tactic
operator|=
literal|2
expr_stmt|;
name|usecost
operator|=
name|SP
operator|->
name|_cr_cost
operator|+
name|newcost
expr_stmt|;
block|}
comment|/* tactic #3: use home-cursor + local movement */
if|if
condition|(
name|cursor_home
operator|&&
operator|(
operator|(
name|newcost
operator|=
name|relative_move
argument_list|(
name|NullResult
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ynew
argument_list|,
name|xnew
argument_list|,
name|ovw
argument_list|)
operator|)
operator|!=
name|INFINITY
operator|)
operator|&&
name|SP
operator|->
name|_home_cost
operator|+
name|newcost
operator|<
name|usecost
condition|)
block|{
name|tactic
operator|=
literal|3
expr_stmt|;
name|usecost
operator|=
name|SP
operator|->
name|_home_cost
operator|+
name|newcost
expr_stmt|;
block|}
comment|/* tactic #4: use home-down + local movement */
if|if
condition|(
name|cursor_to_ll
operator|&&
operator|(
operator|(
name|newcost
operator|=
name|relative_move
argument_list|(
name|NullResult
argument_list|,
name|screen_lines
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|ynew
argument_list|,
name|xnew
argument_list|,
name|ovw
argument_list|)
operator|)
operator|!=
name|INFINITY
operator|)
operator|&&
name|SP
operator|->
name|_ll_cost
operator|+
name|newcost
operator|<
name|usecost
condition|)
block|{
name|tactic
operator|=
literal|4
expr_stmt|;
name|usecost
operator|=
name|SP
operator|->
name|_ll_cost
operator|+
name|newcost
expr_stmt|;
block|}
comment|/*      * tactic #5: use left margin for wrap to right-hand side,      * unless strange wrap behavior indicated by xenl might hose us.      */
name|t5_cr_cost
operator|=
operator|(
name|xold
operator|>
literal|0
condition|?
name|SP
operator|->
name|_cr_cost
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|auto_left_margin
operator|&&
operator|!
name|eat_newline_glitch
operator|&&
name|yold
operator|>
literal|0
operator|&&
name|cursor_left
operator|&&
operator|(
operator|(
name|newcost
operator|=
name|relative_move
argument_list|(
name|NullResult
argument_list|,
name|yold
operator|-
literal|1
argument_list|,
name|screen_columns
operator|-
literal|1
argument_list|,
name|ynew
argument_list|,
name|xnew
argument_list|,
name|ovw
argument_list|)
operator|)
operator|!=
name|INFINITY
operator|)
operator|&&
name|t5_cr_cost
operator|+
name|SP
operator|->
name|_cub1_cost
operator|+
name|newcost
operator|<
name|usecost
condition|)
block|{
name|tactic
operator|=
literal|5
expr_stmt|;
name|usecost
operator|=
name|t5_cr_cost
operator|+
name|SP
operator|->
name|_cub1_cost
operator|+
name|newcost
expr_stmt|;
block|}
comment|/*      * These cases are ordered by estimated relative frequency.      */
if|if
condition|(
name|tactic
condition|)
name|InitResult
expr_stmt|;
switch|switch
condition|(
name|tactic
condition|)
block|{
case|case
literal|1
case|:
operator|(
name|void
operator|)
name|relative_move
argument_list|(
operator|&
name|result
argument_list|,
name|yold
argument_list|,
name|xold
argument_list|,
name|ynew
argument_list|,
name|xnew
argument_list|,
name|ovw
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
operator|(
name|void
operator|)
name|_nc_safe_strcpy
argument_list|(
operator|&
name|result
argument_list|,
name|carriage_return
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|relative_move
argument_list|(
operator|&
name|result
argument_list|,
name|yold
argument_list|,
literal|0
argument_list|,
name|ynew
argument_list|,
name|xnew
argument_list|,
name|ovw
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
operator|(
name|void
operator|)
name|_nc_safe_strcpy
argument_list|(
operator|&
name|result
argument_list|,
name|cursor_home
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|relative_move
argument_list|(
operator|&
name|result
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ynew
argument_list|,
name|xnew
argument_list|,
name|ovw
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
operator|(
name|void
operator|)
name|_nc_safe_strcpy
argument_list|(
operator|&
name|result
argument_list|,
name|cursor_to_ll
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|relative_move
argument_list|(
operator|&
name|result
argument_list|,
name|screen_lines
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|ynew
argument_list|,
name|xnew
argument_list|,
name|ovw
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
if|if
condition|(
name|xold
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|_nc_safe_strcat
argument_list|(
operator|&
name|result
argument_list|,
name|carriage_return
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|_nc_safe_strcat
argument_list|(
operator|&
name|result
argument_list|,
name|cursor_left
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|relative_move
argument_list|(
operator|&
name|result
argument_list|,
name|yold
operator|-
literal|1
argument_list|,
name|screen_columns
operator|-
literal|1
argument_list|,
name|ynew
argument_list|,
name|xnew
argument_list|,
name|ovw
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* !NO_OPTIMIZE */
name|nonlocal
label|:
if|#
directive|if
name|defined
argument_list|(
name|MAIN
argument_list|)
operator|||
name|defined
argument_list|(
name|NCURSES_TEST
argument_list|)
name|gettimeofday
argument_list|(
operator|&
name|after
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|diff
operator|=
name|after
operator|.
name|tv_usec
operator|-
name|before
operator|.
name|tv_usec
operator|+
operator|(
name|after
operator|.
name|tv_sec
operator|-
name|before
operator|.
name|tv_sec
operator|)
operator|*
literal|1000000
expr_stmt|;
if|if
condition|(
operator|!
name|profiling
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"onscreen: %d microsec, %f 28.8Kbps char-equivalents\n"
argument_list|,
operator|(
name|int
operator|)
name|diff
argument_list|,
name|diff
operator|/
literal|288
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MAIN */
if|if
condition|(
name|usecost
operator|!=
name|INFINITY
condition|)
block|{
name|TPUTS_TRACE
argument_list|(
literal|"mvcur"
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|_nc_outch
argument_list|)
expr_stmt|;
name|SP
operator|->
name|_cursrow
operator|=
name|ynew
expr_stmt|;
name|SP
operator|->
name|_curscol
operator|=
name|xnew
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
block|}
else|else
return|return
operator|(
name|ERR
operator|)
return|;
block|}
end_function

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|mvcur
argument_list|(
argument|int yold
argument_list|,
argument|int xold
argument_list|,
argument|int ynew
argument_list|,
argument|int xnew
argument_list|)
end_macro

begin_comment
comment|/* optimized cursor move from (yold, xold) to (ynew, xnew) */
end_comment

begin_block
block|{
name|NCURSES_CH_T
name|oldattr
decl_stmt|;
name|int
name|code
decl_stmt|;
name|TR
argument_list|(
name|TRACE_CALLS
operator||
name|TRACE_MOVE
argument_list|,
operator|(
name|T_CALLED
argument_list|(
literal|"mvcur(%d,%d,%d,%d)"
argument_list|)
operator|,
name|yold
operator|,
name|xold
operator|,
name|ynew
operator|,
name|xnew
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SP
operator|==
literal|0
condition|)
block|{
name|code
operator|=
name|ERR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|yold
operator|==
name|ynew
operator|&&
name|xold
operator|==
name|xnew
condition|)
block|{
name|code
operator|=
name|OK
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * Most work here is rounding for terminal boundaries getting the 	 * column position implied by wraparound or the lack thereof and 	 * rolling up the screen to get ynew on the screen. 	 */
if|if
condition|(
name|xnew
operator|>=
name|screen_columns
condition|)
block|{
name|ynew
operator|+=
name|xnew
operator|/
name|screen_columns
expr_stmt|;
name|xnew
operator|%=
name|screen_columns
expr_stmt|;
block|}
comment|/* 	 * Force restore even if msgr is on when we're in an alternate 	 * character set -- these have a strong tendency to screw up the CR& 	 * LF used for local character motions! 	 */
name|oldattr
operator|=
name|SCREEN_ATTRS
argument_list|(
name|SP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|AttrOf
argument_list|(
name|oldattr
argument_list|)
operator|&
name|A_ALTCHARSET
operator|)
operator|||
operator|(
name|AttrOf
argument_list|(
name|oldattr
argument_list|)
operator|&&
operator|!
name|move_standout_mode
operator|)
condition|)
block|{
name|TR
argument_list|(
name|TRACE_CHARPUT
argument_list|,
operator|(
literal|"turning off (%#lx) %s before move"
operator|,
operator|(
name|unsigned
name|long
operator|)
name|AttrOf
argument_list|(
name|oldattr
argument_list|)
operator|,
name|_traceattr
argument_list|(
name|AttrOf
argument_list|(
name|oldattr
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|VIDATTR
argument_list|(
name|A_NORMAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xold
operator|>=
name|screen_columns
condition|)
block|{
name|int
name|l
decl_stmt|;
if|if
condition|(
name|SP
operator|->
name|_nl
condition|)
block|{
name|l
operator|=
operator|(
name|xold
operator|+
literal|1
operator|)
operator|/
name|screen_columns
expr_stmt|;
name|yold
operator|+=
name|l
expr_stmt|;
if|if
condition|(
name|yold
operator|>=
name|screen_lines
condition|)
name|l
operator|-=
operator|(
name|yold
operator|-
name|screen_lines
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|l
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|carriage_return
condition|)
block|{
name|TPUTS_TRACE
argument_list|(
literal|"carriage_return"
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|carriage_return
argument_list|)
expr_stmt|;
block|}
else|else
name|_nc_outch
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|xold
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|l
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|newline
condition|)
block|{
name|TPUTS_TRACE
argument_list|(
literal|"newline"
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|newline
argument_list|)
expr_stmt|;
block|}
else|else
name|_nc_outch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|l
operator|--
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 		 * If caller set nonl(), we cannot really use newlines to 		 * position to the next row. 		 */
name|xold
operator|=
operator|-
literal|1
expr_stmt|;
name|yold
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|yold
operator|>
name|screen_lines
operator|-
literal|1
condition|)
name|yold
operator|=
name|screen_lines
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ynew
operator|>
name|screen_lines
operator|-
literal|1
condition|)
name|ynew
operator|=
name|screen_lines
operator|-
literal|1
expr_stmt|;
comment|/* destination location is on screen now */
name|code
operator|=
name|onscreen_mvcur
argument_list|(
name|yold
argument_list|,
name|xold
argument_list|,
name|ynew
argument_list|,
name|xnew
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* 	 * Restore attributes if we disabled them before moving. 	 */
if|if
condition|(
operator|!
name|SameAttrOf
argument_list|(
name|oldattr
argument_list|,
name|SCREEN_ATTRS
argument_list|(
name|SP
argument_list|)
argument_list|)
condition|)
block|{
name|TR
argument_list|(
name|TRACE_CHARPUT
argument_list|,
operator|(
literal|"turning on (%#lx) %s after move"
operator|,
operator|(
name|unsigned
name|long
operator|)
name|AttrOf
argument_list|(
name|oldattr
argument_list|)
operator|,
name|_traceattr
argument_list|(
name|AttrOf
argument_list|(
name|oldattr
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|VIDATTR
argument_list|(
name|AttrOf
argument_list|(
name|oldattr
argument_list|)
argument_list|,
name|GetPair
argument_list|(
name|oldattr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|returnCode
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
end_block

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TRACE
argument_list|)
operator|||
name|defined
argument_list|(
name|NCURSES_TEST
argument_list|)
end_if

begin_macro
name|NCURSES_EXPORT_VAR
argument_list|(
argument|int
argument_list|)
end_macro

begin_expr_stmt
name|_nc_optimize_enable
operator|=
name|OPTIMIZE_ALL
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|MAIN
argument_list|)
operator|||
name|defined
argument_list|(
name|NCURSES_TEST
argument_list|)
end_if

begin_comment
comment|/****************************************************************************  *  * Movement optimizer test code  *  ****************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<tic.h>
end_include

begin_include
include|#
directive|include
file|<dump_entry.h>
end_include

begin_macro
name|NCURSES_EXPORT_VAR
argument_list|(
argument|const char *
argument_list|)
end_macro

begin_expr_stmt
name|_nc_progname
operator|=
literal|"mvcur"
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|xmits
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* these override lib_tputs.c */
end_comment

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|tputs
argument_list|(
argument|const char *string
argument_list|,
argument|int affcnt GCC_UNUSED
argument_list|,
argument|int (*outc) (int) GCC_UNUSED
argument_list|)
end_macro

begin_comment
comment|/* stub tputs() that dumps sequences in a visible form */
end_comment

begin_block
block|{
if|if
condition|(
name|profiling
condition|)
name|xmits
operator|+=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|_nc_visbuf
argument_list|(
name|string
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
block|}
end_block

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|putp
argument_list|(
argument|const char *string
argument_list|)
end_macro

begin_block
block|{
return|return
operator|(
name|tputs
argument_list|(
name|string
argument_list|,
literal|1
argument_list|,
name|_nc_outch
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|_nc_outch
argument_list|(
argument|int ch
argument_list|)
end_macro

begin_block
block|{
name|putc
argument_list|(
name|ch
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_block

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|delay_output
argument_list|(
argument|int ms GCC_UNUSED
argument_list|)
end_macro

begin_block
block|{
return|return
name|OK
return|;
block|}
end_block

begin_decl_stmt
specifier|static
name|char
name|tname
index|[
name|PATH_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|load_term
parameter_list|(
name|void
parameter_list|)
block|{
operator|(
name|void
operator|)
name|setupterm
argument_list|(
name|tname
argument_list|,
name|STDOUT_FILENO
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|roll
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|i
operator|=
operator|(
name|RAND_MAX
operator|/
name|n
operator|)
operator|*
name|n
expr_stmt|;
while|while
condition|(
operator|(
name|j
operator|=
name|rand
argument_list|()
operator|)
operator|>=
name|i
condition|)
continue|continue;
return|return
operator|(
name|j
operator|%
name|n
operator|)
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
name|GCC_UNUSED
parameter_list|,
name|char
modifier|*
name|argv
index|[]
name|GCC_UNUSED
parameter_list|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tname
argument_list|,
name|termname
argument_list|()
argument_list|)
expr_stmt|;
name|load_term
argument_list|()
expr_stmt|;
name|_nc_setupscreen
argument_list|(
name|lines
argument_list|,
name|columns
argument_list|,
name|stdout
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|baudrate
argument_list|()
expr_stmt|;
name|_nc_mvcur_init
argument_list|()
expr_stmt|;
name|NC_BUFFERED
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"The mvcur tester.  Type ? for help"
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"smcup:"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|fy
decl_stmt|,
name|fx
decl_stmt|,
name|ty
decl_stmt|,
name|tx
decl_stmt|,
name|n
decl_stmt|,
name|i
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|capname
index|[
name|BUFSIZ
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"> "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'?'
condition|)
block|{
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"?                -- display this help message"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"fy fx ty tx      -- (4 numbers) display (fy,fx)->(ty,tx) move"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"s[croll] n t b m -- display scrolling sequence"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"r[eload]         -- reload terminal info for %s\n"
argument_list|,
name|termname
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"l[oad]<term>    -- load terminal info for type<term>"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"d[elete]<cap>   -- delete named capability"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"i[nspect]        -- display terminal capabilities"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"c[ost]           -- dump cursor-optimization cost table"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"o[optimize]      -- toggle movement optimization"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"t[orture]<num>  -- torture-test with<num> random moves"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"q[uit]           -- quit the program"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%d %d %d %d"
argument_list|,
operator|&
name|fy
argument_list|,
operator|&
name|fx
argument_list|,
operator|&
name|ty
argument_list|,
operator|&
name|tx
argument_list|)
operator|==
literal|4
condition|)
block|{
name|struct
name|timeval
name|before
decl_stmt|,
name|after
decl_stmt|;
name|putchar
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|before
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mvcur
argument_list|(
name|fy
argument_list|,
name|fx
argument_list|,
name|ty
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|after
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\" (%ld msec)\n"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|after
operator|.
name|tv_usec
operator|-
name|before
operator|.
name|tv_usec
operator|+
operator|(
name|after
operator|.
name|tv_sec
operator|-
name|before
operator|.
name|tv_sec
operator|)
operator|*
literal|1000000
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"s %d %d %d %d"
argument_list|,
operator|&
name|fy
argument_list|,
operator|&
name|fx
argument_list|,
operator|&
name|ty
argument_list|,
operator|&
name|tx
argument_list|)
operator|==
literal|4
condition|)
block|{
name|struct
name|timeval
name|before
decl_stmt|,
name|after
decl_stmt|;
name|putchar
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|before
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|_nc_scrolln
argument_list|(
name|fy
argument_list|,
name|fx
argument_list|,
name|ty
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|after
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\" (%ld msec)\n"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|after
operator|.
name|tv_usec
operator|-
name|before
operator|.
name|tv_usec
operator|+
operator|(
name|after
operator|.
name|tv_sec
operator|-
name|before
operator|.
name|tv_sec
operator|)
operator|*
literal|1000000
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'r'
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tname
argument_list|,
name|termname
argument_list|()
argument_list|)
expr_stmt|;
name|load_term
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"l %s"
argument_list|,
name|tname
argument_list|)
operator|==
literal|1
condition|)
block|{
name|load_term
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"d %s"
argument_list|,
name|capname
argument_list|)
operator|==
literal|1
condition|)
block|{
name|struct
name|name_table_entry
specifier|const
modifier|*
name|np
init|=
name|_nc_find_entry
argument_list|(
name|capname
argument_list|,
name|_nc_info_hash_table
argument_list|)
decl_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"No such capability as \"%s\"\n"
argument_list|,
name|capname
argument_list|)
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|np
operator|->
name|nte_type
condition|)
block|{
case|case
name|BOOLEAN
case|:
name|cur_term
operator|->
name|type
operator|.
name|Booleans
index|[
name|np
operator|->
name|nte_index
index|]
operator|=
name|FALSE
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Boolean capability `%s' (%d) turned off.\n"
argument_list|,
name|np
operator|->
name|nte_name
argument_list|,
name|np
operator|->
name|nte_index
argument_list|)
expr_stmt|;
break|break;
case|case
name|NUMBER
case|:
name|cur_term
operator|->
name|type
operator|.
name|Numbers
index|[
name|np
operator|->
name|nte_index
index|]
operator|=
name|ABSENT_NUMERIC
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Number capability `%s' (%d) set to -1.\n"
argument_list|,
name|np
operator|->
name|nte_name
argument_list|,
name|np
operator|->
name|nte_index
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRING
case|:
name|cur_term
operator|->
name|type
operator|.
name|Strings
index|[
name|np
operator|->
name|nte_index
index|]
operator|=
name|ABSENT_STRING
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"String capability `%s' (%d) deleted.\n"
argument_list|,
name|np
operator|->
name|nte_name
argument_list|,
name|np
operator|->
name|nte_index
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'i'
condition|)
block|{
name|dump_init
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|F_TERMINFO
argument_list|,
name|S_TERMINFO
argument_list|,
literal|70
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|dump_entry
argument_list|(
operator|&
name|cur_term
operator|->
name|type
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'o'
condition|)
block|{
if|if
condition|(
name|_nc_optimize_enable
operator|&
name|OPTIMIZE_MVCUR
condition|)
block|{
name|_nc_optimize_enable
operator|&=
operator|~
name|OPTIMIZE_MVCUR
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"Optimization is now off."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|_nc_optimize_enable
operator||=
name|OPTIMIZE_MVCUR
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"Optimization is now on."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * You can use the `t' test to profile and tune the movement 	 * optimizer.  Use iteration values in three digits or more. 	 * At above 5000 iterations the profile timing averages are stable 	 * to within a millisecond or three. 	 * 	 * The `overhead' field of the report will help you pick a 	 * COMPUTE_OVERHEAD figure appropriate for your processor and 	 * expected line speed.  The `total estimated time' is 	 * computation time plus a character-transmission time 	 * estimate computed from the number of transmits and the baud 	 * rate. 	 * 	 * Use this together with the `o' command to get a read on the 	 * optimizer's effectiveness.  Compare the total estimated times 	 * for `t' runs of the same length in both optimized and un-optimized 	 * modes.  As long as the optimized times are less, the optimizer 	 * is winning. 	 */
elseif|else
if|if
condition|(
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"t %d"
argument_list|,
operator|&
name|n
argument_list|)
operator|==
literal|1
condition|)
block|{
name|float
name|cumtime
init|=
literal|0.0
decl_stmt|,
name|perchar
decl_stmt|;
name|int
name|speeds
index|[]
init|=
block|{
literal|2400
block|,
literal|9600
block|,
literal|14400
block|,
literal|19200
block|,
literal|28800
block|,
literal|38400
block|,
literal|0
block|}
decl_stmt|;
name|srand
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|getpid
argument_list|()
operator|+
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|profiling
operator|=
name|TRUE
expr_stmt|;
name|xmits
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * This does a move test between two random locations, 		 * Random moves probably short-change the optimizer, 		 * which will work better on the short moves probably 		 * typical of doupdate()'s usage pattern.  Still, 		 * until we have better data... 		 */
ifdef|#
directive|ifdef
name|FIND_COREDUMP
name|int
name|from_y
init|=
name|roll
argument_list|(
name|lines
argument_list|)
decl_stmt|;
name|int
name|to_y
init|=
name|roll
argument_list|(
name|lines
argument_list|)
decl_stmt|;
name|int
name|from_x
init|=
name|roll
argument_list|(
name|columns
argument_list|)
decl_stmt|;
name|int
name|to_x
init|=
name|roll
argument_list|(
name|columns
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"(%d,%d) -> (%d,%d)\n"
argument_list|,
name|from_y
argument_list|,
name|from_x
argument_list|,
name|to_y
argument_list|,
name|to_x
argument_list|)
expr_stmt|;
name|mvcur
argument_list|(
name|from_y
argument_list|,
name|from_x
argument_list|,
name|to_y
argument_list|,
name|to_x
argument_list|)
expr_stmt|;
else|#
directive|else
name|mvcur
argument_list|(
name|roll
argument_list|(
name|lines
argument_list|)
argument_list|,
name|roll
argument_list|(
name|columns
argument_list|)
argument_list|,
name|roll
argument_list|(
name|lines
argument_list|)
argument_list|,
name|roll
argument_list|(
name|columns
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FIND_COREDUMP */
if|if
condition|(
name|diff
condition|)
name|cumtime
operator|+=
name|diff
expr_stmt|;
block|}
name|profiling
operator|=
name|FALSE
expr_stmt|;
comment|/* 	     * Average milliseconds per character optimization time. 	     * This is the key figure to watch when tuning the optimizer. 	     */
name|perchar
operator|=
name|cumtime
operator|/
name|n
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%d moves (%ld chars) in %d msec, %f msec each:\n"
argument_list|,
name|n
argument_list|,
name|xmits
argument_list|,
operator|(
name|int
operator|)
name|cumtime
argument_list|,
name|perchar
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|speeds
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Total estimated time for the moves, computation and 		 * transmission both. Transmission time is an estimate 		 * assuming 9 bits/char, 8 bits + 1 stop bit. 		 */
name|float
name|totalest
init|=
name|cumtime
operator|+
name|xmits
operator|*
literal|9
operator|*
literal|1e6
operator|/
name|speeds
index|[
name|i
index|]
decl_stmt|;
comment|/* 		 * Per-character optimization overhead in character transmits 		 * at the current speed.  Round this to the nearest integer 		 * to figure COMPUTE_OVERHEAD for the speed. 		 */
name|float
name|overhead
init|=
name|speeds
index|[
name|i
index|]
operator|*
name|perchar
operator|/
literal|1e6
decl_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%6d bps: %3.2f char-xmits overhead; total estimated time %15.2f\n"
argument_list|,
name|speeds
index|[
name|i
index|]
argument_list|,
name|overhead
argument_list|,
name|totalest
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'c'
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"char padding: %d\n"
argument_list|,
name|SP
operator|->
name|_char_padding
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"cr cost: %d\n"
argument_list|,
name|SP
operator|->
name|_cr_cost
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"cup cost: %d\n"
argument_list|,
name|SP
operator|->
name|_cup_cost
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"home cost: %d\n"
argument_list|,
name|SP
operator|->
name|_home_cost
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"ll cost: %d\n"
argument_list|,
name|SP
operator|->
name|_ll_cost
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_HARD_TABS
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"ht cost: %d\n"
argument_list|,
name|SP
operator|->
name|_ht_cost
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"cbt cost: %d\n"
argument_list|,
name|SP
operator|->
name|_cbt_cost
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_HARD_TABS */
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"cub1 cost: %d\n"
argument_list|,
name|SP
operator|->
name|_cub1_cost
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"cuf1 cost: %d\n"
argument_list|,
name|SP
operator|->
name|_cuf1_cost
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"cud1 cost: %d\n"
argument_list|,
name|SP
operator|->
name|_cud1_cost
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"cuu1 cost: %d\n"
argument_list|,
name|SP
operator|->
name|_cuu1_cost
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"cub cost: %d\n"
argument_list|,
name|SP
operator|->
name|_cub_cost
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"cuf cost: %d\n"
argument_list|,
name|SP
operator|->
name|_cuf_cost
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"cud cost: %d\n"
argument_list|,
name|SP
operator|->
name|_cud_cost
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"cuu cost: %d\n"
argument_list|,
name|SP
operator|->
name|_cuu_cost
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"hpa cost: %d\n"
argument_list|,
name|SP
operator|->
name|_hpa_cost
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"vpa cost: %d\n"
argument_list|,
name|SP
operator|->
name|_vpa_cost
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'x'
operator|||
name|buf
index|[
literal|0
index|]
operator|==
literal|'q'
condition|)
break|break;
else|else
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"Invalid command."
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"rmcup:"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|_nc_mvcur_wrap
argument_list|()
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAIN */
end_comment

begin_comment
comment|/* lib_mvcur.c ends here */
end_comment

end_unit

