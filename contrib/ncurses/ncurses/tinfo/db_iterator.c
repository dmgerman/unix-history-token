begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************************  * Copyright (c) 2006-2012,2013 Free Software Foundation, Inc.              *  *                                                                          *  * Permission is hereby granted, free of charge, to any person obtaining a  *  * copy of this software and associated documentation files (the            *  * "Software"), to deal in the Software without restriction, including      *  * without limitation the rights to use, copy, modify, merge, publish,      *  * distribute, distribute with modifications, sublicense, and/or sell       *  * copies of the Software, and to permit persons to whom the Software is    *  * furnished to do so, subject to the following conditions:                 *  *                                                                          *  * The above copyright notice and this permission notice shall be included  *  * in all copies or substantial portions of the Software.                   *  *                                                                          *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *  * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *  * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *  *                                                                          *  * Except as contained in this notice, the name(s) of the above copyright   *  * holders shall not be used in advertising or otherwise to promote the     *  * sale, use or other dealings in this Software without prior written       *  * authorization.                                                           *  ****************************************************************************/
end_comment

begin_comment
comment|/****************************************************************************  *  Author: Thomas E. Dickey                                                *  ****************************************************************************/
end_comment

begin_comment
comment|/*  * Iterators for terminal databases.  */
end_comment

begin_include
include|#
directive|include
file|<curses.priv.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<tic.h>
end_include

begin_if
if|#
directive|if
name|USE_HASHED_DB
end_if

begin_include
include|#
directive|include
file|<hashed_db.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|MODULE_ID
argument_list|(
literal|"$Id: db_iterator.c,v 1.38 2013/12/14 21:23:20 tom Exp $"
argument_list|)
end_macro

begin_define
define|#
directive|define
name|HaveTicDirectory
value|_nc_globals.have_tic_directory
end_define

begin_define
define|#
directive|define
name|KeepTicDirectory
value|_nc_globals.keep_tic_directory
end_define

begin_define
define|#
directive|define
name|TicDirectory
value|_nc_globals.tic_directory
end_define

begin_define
define|#
directive|define
name|my_blob
value|_nc_globals.dbd_blob
end_define

begin_define
define|#
directive|define
name|my_list
value|_nc_globals.dbd_list
end_define

begin_define
define|#
directive|define
name|my_size
value|_nc_globals.dbd_size
end_define

begin_define
define|#
directive|define
name|my_time
value|_nc_globals.dbd_time
end_define

begin_define
define|#
directive|define
name|my_vars
value|_nc_globals.dbd_vars
end_define

begin_function
specifier|static
name|void
name|add_to_blob
parameter_list|(
specifier|const
name|char
modifier|*
name|text
parameter_list|,
name|size_t
name|limit
parameter_list|)
block|{
operator|(
name|void
operator|)
name|limit
expr_stmt|;
if|if
condition|(
operator|*
name|text
operator|!=
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|last
init|=
name|my_blob
operator|+
name|strlen
argument_list|(
name|my_blob
argument_list|)
decl_stmt|;
if|if
condition|(
name|last
operator|!=
name|my_blob
condition|)
operator|*
name|last
operator|++
operator|=
name|NCURSES_PATHSEP
expr_stmt|;
name|_nc_STRCPY
argument_list|(
name|last
argument_list|,
name|text
argument_list|,
name|limit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|check_existence
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|stat
modifier|*
name|sb
parameter_list|)
block|{
name|bool
name|result
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
name|sb
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|S_ISDIR
argument_list|(
name|sb
operator|->
name|st_mode
argument_list|)
operator|||
name|S_ISREG
argument_list|(
name|sb
operator|->
name|st_mode
argument_list|)
operator|)
condition|)
block|{
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
if|#
directive|if
name|USE_HASHED_DB
elseif|else
if|if
condition|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|<
name|PATH_MAX
operator|-
sizeof|sizeof
argument_list|(
name|DBM_SUFFIX
argument_list|)
condition|)
block|{
name|char
name|temp
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|_nc_SPRINTF
argument_list|(
name|temp
argument_list|,
name|_nc_SLIMIT
argument_list|(
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|)
literal|"%s%s"
argument_list|,
name|name
argument_list|,
name|DBM_SUFFIX
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|temp
argument_list|,
name|sb
argument_list|)
operator|==
literal|0
operator|&&
name|S_ISREG
argument_list|(
name|sb
operator|->
name|st_mode
argument_list|)
condition|)
block|{
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Store the latest value of an environment variable in my_vars[] so we can  * detect if one changes, invalidating the cached search-list.  */
end_comment

begin_function
specifier|static
name|bool
name|update_getenv
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|DBDIRS
name|which
parameter_list|)
block|{
name|bool
name|result
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|which
operator|<
name|dbdLAST
condition|)
block|{
name|char
modifier|*
name|value
decl_stmt|;
if|if
condition|(
operator|(
name|value
operator|=
name|getenv
argument_list|(
name|name
argument_list|)
operator|)
operator|==
literal|0
operator|||
operator|(
name|value
operator|=
name|strdup
argument_list|(
name|value
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|my_vars
index|[
name|which
index|]
operator|.
name|name
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|my_vars
index|[
name|which
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|FreeIfNeeded
argument_list|(
name|my_vars
index|[
name|which
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
name|my_vars
index|[
name|which
index|]
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|my_vars
index|[
name|which
index|]
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|my_vars
index|[
name|which
index|]
operator|.
name|value
operator|!=
literal|0
operator|)
operator|^
operator|(
name|value
operator|!=
literal|0
operator|)
condition|)
block|{
name|FreeIfNeeded
argument_list|(
name|my_vars
index|[
name|which
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
name|my_vars
index|[
name|which
index|]
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|value
argument_list|,
name|my_vars
index|[
name|which
index|]
operator|.
name|value
argument_list|)
condition|)
block|{
name|FreeIfNeeded
argument_list|(
name|my_vars
index|[
name|which
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
name|my_vars
index|[
name|which
index|]
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|cache_getenv
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|DBDIRS
name|which
parameter_list|)
block|{
name|char
modifier|*
name|result
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|update_getenv
argument_list|(
name|name
argument_list|,
name|which
argument_list|)
expr_stmt|;
if|if
condition|(
name|which
operator|<
name|dbdLAST
condition|)
block|{
name|result
operator|=
name|my_vars
index|[
name|which
index|]
operator|.
name|value
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * The cache expires if at least a second has passed since the initial lookup,  * or if one of the environment variables changed.  *  * Only a few applications use multiple lookups of terminal entries, seems that  * aside from bulk I/O such as tic and toe, that leaves interactive programs  * which should not be modifying the terminal databases in a way that would  * invalidate the search-list.  *  * The "1-second" is to allow for user-directed changes outside the program.  */
end_comment

begin_function
specifier|static
name|bool
name|cache_expired
parameter_list|(
name|void
parameter_list|)
block|{
name|bool
name|result
init|=
name|FALSE
decl_stmt|;
name|time_t
name|now
init|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|now
operator|>
name|my_time
condition|)
block|{
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|DBDIRS
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
operator|(
name|DBDIRS
operator|)
literal|0
init|;
name|n
operator|<
name|dbdLAST
condition|;
operator|++
name|n
control|)
block|{
if|if
condition|(
name|my_vars
index|[
name|n
index|]
operator|.
name|name
operator|!=
literal|0
operator|&&
name|update_getenv
argument_list|(
name|my_vars
index|[
name|n
index|]
operator|.
name|name
argument_list|,
name|n
argument_list|)
condition|)
block|{
name|result
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_cache
parameter_list|(
name|void
parameter_list|)
block|{
name|FreeAndNull
argument_list|(
name|my_blob
argument_list|)
expr_stmt|;
name|FreeAndNull
argument_list|(
name|my_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Record the "official" location of the terminfo directory, according to  * the place where we're writing to, or the normal default, if not.  */
end_comment

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|const char *
argument_list|)
end_macro

begin_macro
name|_nc_tic_dir
argument_list|(
argument|const char *path
argument_list|)
end_macro

begin_block
block|{
name|T
argument_list|(
operator|(
literal|"_nc_tic_dir %s"
operator|,
name|NonNull
argument_list|(
name|path
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|KeepTicDirectory
condition|)
block|{
if|if
condition|(
name|path
operator|!=
literal|0
condition|)
block|{
name|TicDirectory
operator|=
name|path
expr_stmt|;
name|HaveTicDirectory
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|HaveTicDirectory
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|use_terminfo_vars
argument_list|()
condition|)
block|{
name|char
modifier|*
name|envp
decl_stmt|;
if|if
condition|(
operator|(
name|envp
operator|=
name|getenv
argument_list|(
literal|"TERMINFO"
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|_nc_tic_dir
argument_list|(
name|envp
argument_list|)
return|;
block|}
block|}
block|}
return|return
name|TicDirectory
condition|?
name|TicDirectory
else|:
name|TERMINFO
return|;
block|}
end_block

begin_comment
comment|/*  * Special fix to prevent the terminfo directory from being moved after tic  * has chdir'd to it.  If we let it be changed, then if $TERMINFO has a  * relative path, we'll lose track of the actual directory.  */
end_comment

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|_nc_keep_tic_dir
argument_list|(
argument|const char *path
argument_list|)
end_macro

begin_block
block|{
name|_nc_tic_dir
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|KeepTicDirectory
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Cleanup.  */
end_comment

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|_nc_last_db
argument_list|(
argument|void
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|my_blob
operator|!=
literal|0
operator|&&
name|cache_expired
argument_list|()
condition|)
block|{
name|free_cache
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * This is a simple iterator which allows the caller to step through the  * possible locations for a terminfo directory.  ncurses uses this to find  * terminfo files to read.  */
end_comment

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|const char *
argument_list|)
end_macro

begin_macro
name|_nc_next_db
argument_list|(
argument|DBDIRS * state
argument_list|,
argument|int *offset
argument_list|)
end_macro

begin_block
block|{
specifier|const
name|char
modifier|*
name|result
decl_stmt|;
operator|(
name|void
operator|)
name|offset
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
operator|*
name|state
operator|<
name|my_size
operator|&&
name|my_list
operator|!=
literal|0
operator|&&
name|my_list
index|[
operator|*
name|state
index|]
operator|!=
literal|0
condition|)
block|{
name|result
operator|=
name|my_list
index|[
operator|*
name|state
index|]
expr_stmt|;
operator|(
operator|*
name|state
operator|)
operator|++
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
name|T
argument_list|(
operator|(
literal|"_nc_next_db %d %s"
operator|,
operator|*
name|state
operator|,
name|result
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_block

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|_nc_first_db
argument_list|(
argument|DBDIRS * state
argument_list|,
argument|int *offset
argument_list|)
end_macro

begin_block
block|{
name|bool
name|cache_has_expired
init|=
name|FALSE
decl_stmt|;
operator|*
name|state
operator|=
name|dbdTIC
expr_stmt|;
operator|*
name|offset
operator|=
literal|0
expr_stmt|;
name|T
argument_list|(
operator|(
literal|"_nc_first_db"
operator|)
argument_list|)
expr_stmt|;
comment|/* build a blob containing all of the strings we will use for a lookup      * table.      */
if|if
condition|(
name|my_blob
operator|==
literal|0
operator|||
operator|(
name|cache_has_expired
operator|=
name|cache_expired
argument_list|()
operator|)
condition|)
block|{
name|size_t
name|blobsize
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|values
index|[
name|dbdLAST
index|]
decl_stmt|;
name|struct
name|stat
modifier|*
name|my_stat
decl_stmt|;
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
if|if
condition|(
name|cache_has_expired
condition|)
name|free_cache
argument_list|()
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|dbdLAST
condition|;
operator|++
name|j
control|)
name|values
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 	 * This is the first item in the list, and is used only when tic is 	 * writing to the database, as a performance improvement. 	 */
name|values
index|[
name|dbdTIC
index|]
operator|=
name|TicDirectory
expr_stmt|;
if|#
directive|if
name|NCURSES_USE_DATABASE
ifdef|#
directive|ifdef
name|TERMINFO_DIRS
name|values
index|[
name|dbdCfgList
index|]
operator|=
name|TERMINFO_DIRS
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERMINFO
name|values
index|[
name|dbdCfgOnce
index|]
operator|=
name|TERMINFO
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|NCURSES_USE_TERMCAP
name|values
index|[
name|dbdCfgList2
index|]
operator|=
name|TERMPATH
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|use_terminfo_vars
argument_list|()
condition|)
block|{
if|#
directive|if
name|NCURSES_USE_DATABASE
name|values
index|[
name|dbdEnvOnce
index|]
operator|=
name|cache_getenv
argument_list|(
literal|"TERMINFO"
argument_list|,
name|dbdEnvOnce
argument_list|)
expr_stmt|;
name|values
index|[
name|dbdHome
index|]
operator|=
name|_nc_home_terminfo
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|cache_getenv
argument_list|(
literal|"HOME"
argument_list|,
name|dbdHome
argument_list|)
expr_stmt|;
name|values
index|[
name|dbdEnvList
index|]
operator|=
name|cache_getenv
argument_list|(
literal|"TERMINFO_DIRS"
argument_list|,
name|dbdEnvList
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|NCURSES_USE_TERMCAP
name|values
index|[
name|dbdEnvOnce2
index|]
operator|=
name|cache_getenv
argument_list|(
literal|"TERMCAP"
argument_list|,
name|dbdEnvOnce2
argument_list|)
expr_stmt|;
comment|/* only use $TERMCAP if it is an absolute path */
if|if
condition|(
name|values
index|[
name|dbdEnvOnce2
index|]
operator|!=
literal|0
operator|&&
operator|*
name|values
index|[
name|dbdEnvOnce2
index|]
operator|!=
literal|'/'
condition|)
block|{
name|values
index|[
name|dbdEnvOnce2
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|values
index|[
name|dbdEnvList2
index|]
operator|=
name|cache_getenv
argument_list|(
literal|"TERMPATH"
argument_list|,
name|dbdEnvList2
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NCURSES_USE_TERMCAP */
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|dbdLAST
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|values
index|[
name|j
index|]
operator|==
literal|0
condition|)
name|values
index|[
name|j
index|]
operator|=
literal|""
expr_stmt|;
name|blobsize
operator|+=
literal|2
operator|+
name|strlen
argument_list|(
name|values
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|my_blob
operator|=
name|malloc
argument_list|(
name|blobsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_blob
operator|!=
literal|0
condition|)
block|{
operator|*
name|my_blob
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|dbdLAST
condition|;
operator|++
name|j
control|)
block|{
name|add_to_blob
argument_list|(
name|values
index|[
name|j
index|]
argument_list|,
name|blobsize
argument_list|)
expr_stmt|;
block|}
comment|/* Now, build an array which will be pointers to the distinct 	     * strings in the blob. 	     */
name|blobsize
operator|=
literal|2
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|my_blob
index|[
name|j
index|]
operator|!=
literal|'\0'
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|my_blob
index|[
name|j
index|]
operator|==
name|NCURSES_PATHSEP
condition|)
operator|++
name|blobsize
expr_stmt|;
block|}
name|my_list
operator|=
name|typeCalloc
argument_list|(
name|char
operator|*
argument_list|,
name|blobsize
argument_list|)
expr_stmt|;
name|my_stat
operator|=
name|typeCalloc
argument_list|(
expr|struct
name|stat
argument_list|,
name|blobsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_list
operator|!=
literal|0
operator|&&
name|my_stat
operator|!=
literal|0
condition|)
block|{
name|k
operator|=
literal|0
expr_stmt|;
name|my_list
index|[
name|k
operator|++
index|]
operator|=
name|my_blob
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|my_blob
index|[
name|j
index|]
operator|!=
literal|'\0'
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|my_blob
index|[
name|j
index|]
operator|==
name|NCURSES_PATHSEP
condition|)
block|{
name|my_blob
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
name|my_list
index|[
name|k
operator|++
index|]
operator|=
operator|&
name|my_blob
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
block|}
block|}
comment|/* 		 * Eliminate duplicates from the list. 		 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|my_list
index|[
name|j
index|]
operator|!=
literal|0
condition|;
operator|++
name|j
control|)
block|{
ifdef|#
directive|ifdef
name|TERMINFO
if|if
condition|(
operator|*
name|my_list
index|[
name|j
index|]
operator|==
literal|'\0'
condition|)
name|my_list
index|[
name|j
index|]
operator|=
name|strdup
argument_list|(
name|TERMINFO
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|j
condition|;
operator|++
name|k
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|my_list
index|[
name|j
index|]
argument_list|,
name|my_list
index|[
name|k
index|]
argument_list|)
condition|)
block|{
name|k
operator|=
name|j
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|my_list
index|[
name|j
index|]
operator|=
name|my_list
index|[
name|j
operator|+
literal|1
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
operator|++
name|j
expr_stmt|;
block|}
name|j
operator|=
name|k
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* 		 * Eliminate non-existent databases, and those that happen to 		 * be symlinked to another location. 		 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|my_list
index|[
name|j
index|]
operator|!=
literal|0
condition|;
operator|++
name|j
control|)
block|{
name|bool
name|found
init|=
name|check_existence
argument_list|(
name|my_list
index|[
name|j
index|]
argument_list|,
operator|&
name|my_stat
index|[
name|j
index|]
argument_list|)
decl_stmt|;
if|#
directive|if
name|HAVE_LINK
if|if
condition|(
name|found
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|j
condition|;
operator|++
name|k
control|)
block|{
if|if
condition|(
name|my_stat
index|[
name|j
index|]
operator|.
name|st_dev
operator|==
name|my_stat
index|[
name|k
index|]
operator|.
name|st_dev
operator|&&
name|my_stat
index|[
name|j
index|]
operator|.
name|st_ino
operator|==
name|my_stat
index|[
name|k
index|]
operator|.
name|st_ino
condition|)
block|{
name|found
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|k
operator|=
name|j
expr_stmt|;
while|while
condition|(
operator|(
name|my_list
index|[
name|k
index|]
operator|=
name|my_list
index|[
name|k
operator|+
literal|1
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
operator|++
name|k
expr_stmt|;
block|}
operator|--
name|j
expr_stmt|;
block|}
block|}
name|my_size
operator|=
name|j
expr_stmt|;
name|my_time
operator|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FreeAndNull
argument_list|(
name|my_blob
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|my_stat
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_if
if|#
directive|if
name|NO_LEAKS
end_if

begin_function
name|void
name|_nc_db_iterator_leaks
parameter_list|(
name|void
parameter_list|)
block|{
name|DBDIRS
name|which
decl_stmt|;
if|if
condition|(
name|my_blob
operator|!=
literal|0
condition|)
name|FreeAndNull
argument_list|(
name|my_blob
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_list
operator|!=
literal|0
condition|)
name|FreeAndNull
argument_list|(
name|my_list
argument_list|)
expr_stmt|;
for|for
control|(
name|which
operator|=
literal|0
init|;
operator|(
name|int
operator|)
name|which
operator|<
name|dbdLAST
condition|;
operator|++
name|which
control|)
block|{
name|my_vars
index|[
name|which
index|]
operator|.
name|name
operator|=
literal|0
expr_stmt|;
name|FreeIfNeeded
argument_list|(
name|my_vars
index|[
name|which
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
name|my_vars
index|[
name|which
index|]
operator|.
name|value
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

