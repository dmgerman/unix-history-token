begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************************  * Copyright (c) 1998-2005,2006 Free Software Foundation, Inc.              *  *                                                                          *  * Permission is hereby granted, free of charge, to any person obtaining a  *  * copy of this software and associated documentation files (the            *  * "Software"), to deal in the Software without restriction, including      *  * without limitation the rights to use, copy, modify, merge, publish,      *  * distribute, distribute with modifications, sublicense, and/or sell       *  * copies of the Software, and to permit persons to whom the Software is    *  * furnished to do so, subject to the following conditions:                 *  *                                                                          *  * The above copyright notice and this permission notice shall be included  *  * in all copies or substantial portions of the Software.                   *  *                                                                          *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *  * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *  * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *  *                                                                          *  * Except as contained in this notice, the name(s) of the above copyright   *  * holders shall not be used in advertising or otherwise to promote the     *  * sale, use or other dealings in this Software without prior written       *  * authorization.                                                           *  ****************************************************************************/
end_comment

begin_comment
comment|/****************************************************************************  *  Author: Zeyd M. Ben-Halim<zmbenhal@netcom.com> 1992,1995               *  *     and: Eric S. Raymond<esr@snark.thyrsus.com>                         *  *     and: Thomas E. Dickey                        1996-on                 *  ****************************************************************************/
end_comment

begin_comment
comment|/*  *	parse_entry.c -- compile one terminfo or termcap entry  *  *	Get an exact in-core representation of an entry.  Don't  *	try to resolve use or tc capabilities, that is someone  *	else's job.  Depends on the lexical analyzer to get tokens  *	from the input stream.  */
end_comment

begin_define
define|#
directive|define
name|__INTERNAL_CAPS_VISIBLE
end_define

begin_include
include|#
directive|include
file|<curses.priv.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<tic.h>
end_include

begin_include
include|#
directive|include
file|<term_entry.h>
end_include

begin_macro
name|MODULE_ID
argument_list|(
literal|"$Id: parse_entry.c,v 1.63 2006/06/17 17:57:50 tom Exp $"
argument_list|)
end_macro

begin_ifdef
ifdef|#
directive|ifdef
name|LINT
end_ifdef

begin_decl_stmt
specifier|static
name|short
specifier|const
name|parametrized
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<parametrized.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|postprocess_termcap
parameter_list|(
name|TERMTYPE
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|postprocess_terminfo
parameter_list|(
name|TERMTYPE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|name_table_entry
specifier|const
modifier|*
name|lookup_fullname
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|NCURSES_XNAMES
end_if

begin_function
specifier|static
name|struct
name|name_table_entry
specifier|const
modifier|*
name|_nc_extend_names
parameter_list|(
name|ENTRY
modifier|*
name|entryp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|token_type
parameter_list|)
block|{
specifier|static
name|struct
name|name_table_entry
name|temp
decl_stmt|;
name|TERMTYPE
modifier|*
name|tp
init|=
operator|&
operator|(
name|entryp
operator|->
name|tterm
operator|)
decl_stmt|;
name|unsigned
name|offset
init|=
literal|0
decl_stmt|;
name|unsigned
name|actual
decl_stmt|;
name|unsigned
name|tindex
decl_stmt|;
name|unsigned
name|first
decl_stmt|,
name|last
decl_stmt|,
name|n
decl_stmt|;
name|bool
name|found
decl_stmt|;
switch|switch
condition|(
name|token_type
condition|)
block|{
case|case
name|BOOLEAN
case|:
name|first
operator|=
literal|0
expr_stmt|;
name|last
operator|=
name|tp
operator|->
name|ext_Booleans
expr_stmt|;
name|offset
operator|=
name|tp
operator|->
name|ext_Booleans
expr_stmt|;
name|tindex
operator|=
name|tp
operator|->
name|num_Booleans
expr_stmt|;
break|break;
case|case
name|NUMBER
case|:
name|first
operator|=
name|tp
operator|->
name|ext_Booleans
expr_stmt|;
name|last
operator|=
name|tp
operator|->
name|ext_Numbers
operator|+
name|first
expr_stmt|;
name|offset
operator|=
name|tp
operator|->
name|ext_Booleans
operator|+
name|tp
operator|->
name|ext_Numbers
expr_stmt|;
name|tindex
operator|=
name|tp
operator|->
name|num_Numbers
expr_stmt|;
break|break;
case|case
name|STRING
case|:
name|first
operator|=
name|tp
operator|->
name|ext_Booleans
operator|+
name|tp
operator|->
name|ext_Numbers
expr_stmt|;
name|last
operator|=
name|tp
operator|->
name|ext_Strings
operator|+
name|first
expr_stmt|;
name|offset
operator|=
name|tp
operator|->
name|ext_Booleans
operator|+
name|tp
operator|->
name|ext_Numbers
operator|+
name|tp
operator|->
name|ext_Strings
expr_stmt|;
name|tindex
operator|=
name|tp
operator|->
name|num_Strings
expr_stmt|;
break|break;
case|case
name|CANCEL
case|:
name|actual
operator|=
name|NUM_EXT_NAMES
argument_list|(
name|tp
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|actual
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|tp
operator|->
name|ext_Names
index|[
name|n
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|n
operator|>
call|(
name|unsigned
call|)
argument_list|(
name|tp
operator|->
name|ext_Booleans
operator|+
name|tp
operator|->
name|ext_Numbers
argument_list|)
condition|)
block|{
name|token_type
operator|=
name|STRING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|>
name|tp
operator|->
name|ext_Booleans
condition|)
block|{
name|token_type
operator|=
name|NUMBER
expr_stmt|;
block|}
else|else
block|{
name|token_type
operator|=
name|BOOLEAN
expr_stmt|;
block|}
return|return
name|_nc_extend_names
argument_list|(
name|entryp
argument_list|,
name|name
argument_list|,
name|token_type
argument_list|)
return|;
block|}
block|}
comment|/* Well, we are given a cancel for a name that we don't recognize */
return|return
name|_nc_extend_names
argument_list|(
name|entryp
argument_list|,
name|name
argument_list|,
name|STRING
argument_list|)
return|;
default|default:
return|return
literal|0
return|;
block|}
comment|/* Adjust the 'offset' (insertion-point) to keep the lists of extended      * names sorted.      */
for|for
control|(
name|n
operator|=
name|first
operator|,
name|found
operator|=
name|FALSE
init|;
name|n
operator|<
name|last
condition|;
name|n
operator|++
control|)
block|{
name|int
name|cmp
init|=
name|strcmp
argument_list|(
name|tp
operator|->
name|ext_Names
index|[
name|n
index|]
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
name|found
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|cmp
operator|>=
literal|0
condition|)
block|{
name|offset
operator|=
name|n
expr_stmt|;
name|tindex
operator|=
name|n
operator|-
name|first
expr_stmt|;
switch|switch
condition|(
name|token_type
condition|)
block|{
case|case
name|BOOLEAN
case|:
name|tindex
operator|+=
name|BOOLCOUNT
expr_stmt|;
break|break;
case|case
name|NUMBER
case|:
name|tindex
operator|+=
name|NUMCOUNT
expr_stmt|;
break|break;
case|case
name|STRING
case|:
name|tindex
operator|+=
name|STRCOUNT
expr_stmt|;
break|break;
block|}
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
switch|switch
condition|(
name|token_type
condition|)
block|{
case|case
name|BOOLEAN
case|:
name|tp
operator|->
name|ext_Booleans
operator|+=
literal|1
expr_stmt|;
name|tp
operator|->
name|num_Booleans
operator|+=
literal|1
expr_stmt|;
name|tp
operator|->
name|Booleans
operator|=
name|typeRealloc
argument_list|(
name|NCURSES_SBOOL
argument_list|,
name|tp
operator|->
name|num_Booleans
argument_list|,
name|tp
operator|->
name|Booleans
argument_list|)
expr_stmt|;
for|for
control|(
name|last
operator|=
name|tp
operator|->
name|num_Booleans
operator|-
literal|1
init|;
name|last
operator|>
name|tindex
condition|;
name|last
operator|--
control|)
name|tp
operator|->
name|Booleans
index|[
name|last
index|]
operator|=
name|tp
operator|->
name|Booleans
index|[
name|last
operator|-
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|NUMBER
case|:
name|tp
operator|->
name|ext_Numbers
operator|+=
literal|1
expr_stmt|;
name|tp
operator|->
name|num_Numbers
operator|+=
literal|1
expr_stmt|;
name|tp
operator|->
name|Numbers
operator|=
name|typeRealloc
argument_list|(
name|short
argument_list|,
name|tp
operator|->
name|num_Numbers
argument_list|,
name|tp
operator|->
name|Numbers
argument_list|)
expr_stmt|;
for|for
control|(
name|last
operator|=
name|tp
operator|->
name|num_Numbers
operator|-
literal|1
init|;
name|last
operator|>
name|tindex
condition|;
name|last
operator|--
control|)
name|tp
operator|->
name|Numbers
index|[
name|last
index|]
operator|=
name|tp
operator|->
name|Numbers
index|[
name|last
operator|-
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|STRING
case|:
name|tp
operator|->
name|ext_Strings
operator|+=
literal|1
expr_stmt|;
name|tp
operator|->
name|num_Strings
operator|+=
literal|1
expr_stmt|;
name|tp
operator|->
name|Strings
operator|=
name|typeRealloc
argument_list|(
name|char
operator|*
argument_list|,
name|tp
operator|->
name|num_Strings
argument_list|,
name|tp
operator|->
name|Strings
argument_list|)
expr_stmt|;
for|for
control|(
name|last
operator|=
name|tp
operator|->
name|num_Strings
operator|-
literal|1
init|;
name|last
operator|>
name|tindex
condition|;
name|last
operator|--
control|)
name|tp
operator|->
name|Strings
index|[
name|last
index|]
operator|=
name|tp
operator|->
name|Strings
index|[
name|last
operator|-
literal|1
index|]
expr_stmt|;
break|break;
block|}
name|actual
operator|=
name|NUM_EXT_NAMES
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|ext_Names
operator|=
name|typeRealloc
argument_list|(
name|char
operator|*
argument_list|,
name|actual
argument_list|,
name|tp
operator|->
name|ext_Names
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|actual
operator|>
name|offset
condition|)
name|tp
operator|->
name|ext_Names
index|[
name|actual
index|]
operator|=
name|tp
operator|->
name|ext_Names
index|[
name|actual
operator|-
literal|1
index|]
expr_stmt|;
name|tp
operator|->
name|ext_Names
index|[
name|offset
index|]
operator|=
name|_nc_save_str
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|temp
operator|.
name|nte_name
operator|=
name|tp
operator|->
name|ext_Names
index|[
name|offset
index|]
expr_stmt|;
name|temp
operator|.
name|nte_type
operator|=
name|token_type
expr_stmt|;
name|temp
operator|.
name|nte_index
operator|=
name|tindex
expr_stmt|;
name|temp
operator|.
name|nte_link
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|&
name|temp
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NCURSES_XNAMES */
end_comment

begin_comment
comment|/*  *	int  *	_nc_parse_entry(entry, literal, silent)  *  *	Compile one entry.  Doesn't try to resolve use or tc capabilities.  *  *	found-forward-use = FALSE  *	re-initialise internal arrays  *	get_token();  *	if the token was not a name in column 1, complain and die  *	save names in entry's string table  *	while (get_token() is not EOF and not NAMES)  *	        check for existence and type-correctness  *	        enter cap into structure  *	        if STRING  *	            save string in entry's string table  *	push back token  */
end_comment

begin_define
define|#
directive|define
name|BAD_TC_USAGE
value|if (!bad_tc_usage) \  	{ bad_tc_usage = TRUE; \ 	 _nc_warning("Legacy termcap allows only a trailing tc= clause"); }
end_define

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|_nc_parse_entry
argument_list|(
argument|struct entry *entryp
argument_list|,
argument|int literal
argument_list|,
argument|bool silent
argument_list|)
end_macro

begin_block
block|{
name|int
name|token_type
decl_stmt|;
name|struct
name|name_table_entry
specifier|const
modifier|*
name|entry_ptr
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|base
decl_stmt|;
name|bool
name|bad_tc_usage
init|=
name|FALSE
decl_stmt|;
name|token_type
operator|=
name|_nc_get_token
argument_list|(
name|silent
argument_list|)
expr_stmt|;
if|if
condition|(
name|token_type
operator|==
name|EOF
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
if|if
condition|(
name|token_type
operator|!=
name|NAMES
condition|)
name|_nc_err_abort
argument_list|(
literal|"Entry does not start with terminal names in column one"
argument_list|)
expr_stmt|;
name|_nc_init_entry
argument_list|(
operator|&
name|entryp
operator|->
name|tterm
argument_list|)
expr_stmt|;
name|entryp
operator|->
name|cstart
operator|=
name|_nc_comment_start
expr_stmt|;
name|entryp
operator|->
name|cend
operator|=
name|_nc_comment_end
expr_stmt|;
name|entryp
operator|->
name|startline
operator|=
name|_nc_start_line
expr_stmt|;
name|DEBUG
argument_list|(
literal|2
argument_list|,
operator|(
literal|"Comment range is %ld to %ld"
operator|,
name|entryp
operator|->
name|cstart
operator|,
name|entryp
operator|->
name|cend
operator|)
argument_list|)
expr_stmt|;
comment|/*      * Strip off the 2-character termcap name, if present.  Originally termcap      * used that as an indexing aid.  We can retain 2-character terminfo names,      * but note that they would be lost if we translate to/from termcap.  This      * feature is supposedly obsolete since "newer" BSD implementations do not      * use it; however our reference for this feature is SunOS 4.x, which      * implemented it.  Note that the resulting terminal type was never the      * 2-character name, but was instead the first alias after that.      */
name|ptr
operator|=
name|_nc_curr_token
operator|.
name|tk_name
expr_stmt|;
if|if
condition|(
name|_nc_syntax
operator|==
name|SYN_TERMCAP
if|#
directive|if
name|NCURSES_XNAMES
operator|&&
operator|!
name|_nc_user_definable
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
name|ptr
index|[
literal|2
index|]
operator|==
literal|'|'
condition|)
block|{
name|ptr
operator|+=
literal|3
expr_stmt|;
name|_nc_curr_token
operator|.
name|tk_name
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
name|entryp
operator|->
name|tterm
operator|.
name|str_table
operator|=
name|entryp
operator|->
name|tterm
operator|.
name|term_names
operator|=
name|_nc_save_str
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
literal|"Starting '%s'"
operator|,
name|ptr
operator|)
argument_list|)
expr_stmt|;
comment|/*      * We do this because the one-token lookahead in the parse loop      * results in the terminal type getting prematurely set to correspond      * to that of the next entry.      */
name|_nc_set_type
argument_list|(
name|_nc_first_name
argument_list|(
name|entryp
operator|->
name|tterm
operator|.
name|term_names
argument_list|)
argument_list|)
expr_stmt|;
comment|/* check for overly-long names and aliases */
for|for
control|(
name|base
operator|=
name|entryp
operator|->
name|tterm
operator|.
name|term_names
init|;
operator|(
name|ptr
operator|=
name|strchr
argument_list|(
name|base
argument_list|,
literal|'|'
argument_list|)
operator|)
operator|!=
literal|0
condition|;
name|base
operator|=
name|ptr
operator|+
literal|1
control|)
block|{
if|if
condition|(
name|ptr
operator|-
name|base
operator|>
name|MAX_ALIAS
condition|)
block|{
name|_nc_warning
argument_list|(
literal|"%s `%.*s' may be too long"
argument_list|,
operator|(
name|base
operator|==
name|entryp
operator|->
name|tterm
operator|.
name|term_names
operator|)
condition|?
literal|"primary name"
else|:
literal|"alias"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|ptr
operator|-
name|base
argument_list|)
argument_list|,
name|base
argument_list|)
expr_stmt|;
block|}
block|}
name|entryp
operator|->
name|nuses
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|token_type
operator|=
name|_nc_get_token
argument_list|(
name|silent
argument_list|)
init|;
name|token_type
operator|!=
name|EOF
operator|&&
name|token_type
operator|!=
name|NAMES
condition|;
name|token_type
operator|=
name|_nc_get_token
argument_list|(
name|silent
argument_list|)
control|)
block|{
name|bool
name|is_use
init|=
operator|(
name|strcmp
argument_list|(
name|_nc_curr_token
operator|.
name|tk_name
argument_list|,
literal|"use"
argument_list|)
operator|==
literal|0
operator|)
decl_stmt|;
name|bool
name|is_tc
init|=
operator|!
name|is_use
operator|&&
operator|(
name|strcmp
argument_list|(
name|_nc_curr_token
operator|.
name|tk_name
argument_list|,
literal|"tc"
argument_list|)
operator|==
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|is_use
operator|||
name|is_tc
condition|)
block|{
name|entryp
operator|->
name|uses
index|[
name|entryp
operator|->
name|nuses
index|]
operator|.
name|name
operator|=
name|_nc_save_str
argument_list|(
name|_nc_curr_token
operator|.
name|tk_valstring
argument_list|)
expr_stmt|;
name|entryp
operator|->
name|uses
index|[
name|entryp
operator|->
name|nuses
index|]
operator|.
name|line
operator|=
name|_nc_curr_line
expr_stmt|;
name|entryp
operator|->
name|nuses
operator|++
expr_stmt|;
if|if
condition|(
name|entryp
operator|->
name|nuses
operator|>
literal|1
operator|&&
name|is_tc
condition|)
block|{
name|BAD_TC_USAGE
block|}
block|}
else|else
block|{
comment|/* normal token lookup */
name|entry_ptr
operator|=
name|_nc_find_entry
argument_list|(
name|_nc_curr_token
operator|.
name|tk_name
argument_list|,
name|_nc_syntax
condition|?
name|_nc_cap_hash_table
else|:
name|_nc_info_hash_table
argument_list|)
expr_stmt|;
comment|/* 	     * Our kluge to handle aliasing.  The reason it's done 	     * this ugly way, with a linear search, is so the hashing 	     * machinery doesn't have to be made really complicated 	     * (also we get better warnings this way).  No point in 	     * making this case fast, aliased caps aren't common now 	     * and will get rarer. 	     */
if|if
condition|(
name|entry_ptr
operator|==
name|NOTFOUND
condition|)
block|{
specifier|const
name|struct
name|alias
modifier|*
name|ap
decl_stmt|;
if|if
condition|(
name|_nc_syntax
operator|==
name|SYN_TERMCAP
condition|)
block|{
if|if
condition|(
name|entryp
operator|->
name|nuses
operator|!=
literal|0
condition|)
block|{
name|BAD_TC_USAGE
block|}
for|for
control|(
name|ap
operator|=
name|_nc_capalias_table
init|;
name|ap
operator|->
name|from
condition|;
name|ap
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|ap
operator|->
name|from
argument_list|,
name|_nc_curr_token
operator|.
name|tk_name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ap
operator|->
name|to
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
name|_nc_warning
argument_list|(
literal|"%s (%s termcap extension) ignored"
argument_list|,
name|ap
operator|->
name|from
argument_list|,
name|ap
operator|->
name|source
argument_list|)
expr_stmt|;
goto|goto
name|nexttok
goto|;
block|}
name|entry_ptr
operator|=
name|_nc_find_entry
argument_list|(
name|ap
operator|->
name|to
argument_list|,
name|_nc_cap_hash_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry_ptr
operator|&&
operator|!
name|silent
condition|)
name|_nc_warning
argument_list|(
literal|"%s (%s termcap extension) aliased to %s"
argument_list|,
name|ap
operator|->
name|from
argument_list|,
name|ap
operator|->
name|source
argument_list|,
name|ap
operator|->
name|to
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* if (_nc_syntax == SYN_TERMINFO) */
for|for
control|(
name|ap
operator|=
name|_nc_infoalias_table
init|;
name|ap
operator|->
name|from
condition|;
name|ap
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|ap
operator|->
name|from
argument_list|,
name|_nc_curr_token
operator|.
name|tk_name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ap
operator|->
name|to
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
name|_nc_warning
argument_list|(
literal|"%s (%s terminfo extension) ignored"
argument_list|,
name|ap
operator|->
name|from
argument_list|,
name|ap
operator|->
name|source
argument_list|)
expr_stmt|;
goto|goto
name|nexttok
goto|;
block|}
name|entry_ptr
operator|=
name|_nc_find_entry
argument_list|(
name|ap
operator|->
name|to
argument_list|,
name|_nc_info_hash_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry_ptr
operator|&&
operator|!
name|silent
condition|)
name|_nc_warning
argument_list|(
literal|"%s (%s terminfo extension) aliased to %s"
argument_list|,
name|ap
operator|->
name|from
argument_list|,
name|ap
operator|->
name|source
argument_list|,
name|ap
operator|->
name|to
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|entry_ptr
operator|==
name|NOTFOUND
condition|)
block|{
name|entry_ptr
operator|=
name|lookup_fullname
argument_list|(
name|_nc_curr_token
operator|.
name|tk_name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|#
directive|if
name|NCURSES_XNAMES
comment|/* 	     * If we have extended-names active, we will automatically 	     * define a name based on its context. 	     */
if|if
condition|(
name|entry_ptr
operator|==
name|NOTFOUND
operator|&&
name|_nc_user_definable
operator|&&
operator|(
name|entry_ptr
operator|=
name|_nc_extend_names
argument_list|(
name|entryp
argument_list|,
name|_nc_curr_token
operator|.
name|tk_name
argument_list|,
name|token_type
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|_nc_tracing
operator|>=
name|DEBUG_LEVEL
argument_list|(
literal|1
argument_list|)
condition|)
name|_nc_warning
argument_list|(
literal|"extended capability '%s'"
argument_list|,
name|_nc_curr_token
operator|.
name|tk_name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NCURSES_XNAMES */
comment|/* can't find this cap name, not even as an alias */
if|if
condition|(
name|entry_ptr
operator|==
name|NOTFOUND
condition|)
block|{
if|if
condition|(
operator|!
name|silent
condition|)
name|_nc_warning
argument_list|(
literal|"unknown capability '%s'"
argument_list|,
name|_nc_curr_token
operator|.
name|tk_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* deal with bad type/value combinations. */
if|if
condition|(
name|token_type
operator|!=
name|CANCEL
operator|&&
name|entry_ptr
operator|->
name|nte_type
operator|!=
name|token_type
condition|)
block|{
comment|/* 		 * Nasty special cases here handle situations in which type 		 * information can resolve name clashes.  Normal lookup 		 * finds the last instance in the capability table of a 		 * given name, regardless of type.  find_type_entry looks 		 * for a first matching instance with given type.  So as 		 * long as all ambiguous names occur in pairs of distinct 		 * type, this will do the job. 		 */
comment|/* tell max_attributes from arrow_key_map */
if|if
condition|(
name|token_type
operator|==
name|NUMBER
operator|&&
operator|!
name|strcmp
argument_list|(
literal|"ma"
argument_list|,
name|_nc_curr_token
operator|.
name|tk_name
argument_list|)
condition|)
block|{
name|entry_ptr
operator|=
name|_nc_find_type_entry
argument_list|(
literal|"ma"
argument_list|,
name|NUMBER
argument_list|,
name|_nc_get_table
argument_list|(
name|_nc_syntax
operator|!=
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* map terminfo's string MT to MT */
block|}
elseif|else
if|if
condition|(
name|token_type
operator|==
name|STRING
operator|&&
operator|!
name|strcmp
argument_list|(
literal|"MT"
argument_list|,
name|_nc_curr_token
operator|.
name|tk_name
argument_list|)
condition|)
block|{
name|entry_ptr
operator|=
name|_nc_find_type_entry
argument_list|(
literal|"MT"
argument_list|,
name|STRING
argument_list|,
name|_nc_get_table
argument_list|(
name|_nc_syntax
operator|!=
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* treat strings without following "=" as empty strings */
block|}
elseif|else
if|if
condition|(
name|token_type
operator|==
name|BOOLEAN
operator|&&
name|entry_ptr
operator|->
name|nte_type
operator|==
name|STRING
condition|)
block|{
name|token_type
operator|=
name|STRING
expr_stmt|;
comment|/* we couldn't recover; skip this token */
block|}
else|else
block|{
if|if
condition|(
operator|!
name|silent
condition|)
block|{
specifier|const
name|char
modifier|*
name|type_name
decl_stmt|;
switch|switch
condition|(
name|entry_ptr
operator|->
name|nte_type
condition|)
block|{
case|case
name|BOOLEAN
case|:
name|type_name
operator|=
literal|"boolean"
expr_stmt|;
break|break;
case|case
name|STRING
case|:
name|type_name
operator|=
literal|"string"
expr_stmt|;
break|break;
case|case
name|NUMBER
case|:
name|type_name
operator|=
literal|"numeric"
expr_stmt|;
break|break;
default|default:
name|type_name
operator|=
literal|"unknown"
expr_stmt|;
break|break;
block|}
name|_nc_warning
argument_list|(
literal|"wrong type used for %s capability '%s'"
argument_list|,
name|type_name
argument_list|,
name|_nc_curr_token
operator|.
name|tk_name
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
block|}
comment|/* now we know that the type/value combination is OK */
switch|switch
condition|(
name|token_type
condition|)
block|{
case|case
name|CANCEL
case|:
switch|switch
condition|(
name|entry_ptr
operator|->
name|nte_type
condition|)
block|{
case|case
name|BOOLEAN
case|:
name|entryp
operator|->
name|tterm
operator|.
name|Booleans
index|[
name|entry_ptr
operator|->
name|nte_index
index|]
operator|=
name|CANCELLED_BOOLEAN
expr_stmt|;
break|break;
case|case
name|NUMBER
case|:
name|entryp
operator|->
name|tterm
operator|.
name|Numbers
index|[
name|entry_ptr
operator|->
name|nte_index
index|]
operator|=
name|CANCELLED_NUMERIC
expr_stmt|;
break|break;
case|case
name|STRING
case|:
name|entryp
operator|->
name|tterm
operator|.
name|Strings
index|[
name|entry_ptr
operator|->
name|nte_index
index|]
operator|=
name|CANCELLED_STRING
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|BOOLEAN
case|:
name|entryp
operator|->
name|tterm
operator|.
name|Booleans
index|[
name|entry_ptr
operator|->
name|nte_index
index|]
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|NUMBER
case|:
name|entryp
operator|->
name|tterm
operator|.
name|Numbers
index|[
name|entry_ptr
operator|->
name|nte_index
index|]
operator|=
name|_nc_curr_token
operator|.
name|tk_valnumber
expr_stmt|;
break|break;
case|case
name|STRING
case|:
name|ptr
operator|=
name|_nc_curr_token
operator|.
name|tk_valstring
expr_stmt|;
if|if
condition|(
name|_nc_syntax
operator|==
name|SYN_TERMCAP
condition|)
name|ptr
operator|=
name|_nc_captoinfo
argument_list|(
name|_nc_curr_token
operator|.
name|tk_name
argument_list|,
name|ptr
argument_list|,
name|parametrized
index|[
name|entry_ptr
operator|->
name|nte_index
index|]
argument_list|)
expr_stmt|;
name|entryp
operator|->
name|tterm
operator|.
name|Strings
index|[
name|entry_ptr
operator|->
name|nte_index
index|]
operator|=
name|_nc_save_str
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|silent
condition|)
name|_nc_warning
argument_list|(
literal|"unknown token type"
argument_list|)
expr_stmt|;
name|_nc_panic_mode
argument_list|(
operator|(
name|_nc_syntax
operator|==
name|SYN_TERMCAP
operator|)
condition|?
literal|':'
else|:
literal|','
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* end else cur_token.name != "use" */
name|nexttok
label|:
continue|continue;
comment|/* cannot have a label w/o statement */
block|}
comment|/* endwhile (not EOF and not NAMES) */
name|_nc_push_token
argument_list|(
name|token_type
argument_list|)
expr_stmt|;
name|_nc_set_type
argument_list|(
name|_nc_first_name
argument_list|(
name|entryp
operator|->
name|tterm
operator|.
name|term_names
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Try to deduce as much as possible from extension capabilities      * (this includes obsolete BSD capabilities).  Sigh...it would be more      * space-efficient to call this after use resolution, but it has      * to be done before entry allocation is wrapped up.      */
if|if
condition|(
operator|!
name|literal
condition|)
block|{
if|if
condition|(
name|_nc_syntax
operator|==
name|SYN_TERMCAP
condition|)
block|{
name|bool
name|has_base_entry
init|=
name|FALSE
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	     * Don't insert defaults if this is a `+' entry meant only 	     * for inclusion in other entries (not sure termcap ever 	     * had these, actually). 	     */
if|if
condition|(
name|strchr
argument_list|(
name|entryp
operator|->
name|tterm
operator|.
name|term_names
argument_list|,
literal|'+'
argument_list|)
condition|)
name|has_base_entry
operator|=
name|TRUE
expr_stmt|;
else|else
comment|/* 		 * Otherwise, look for a base entry that will already 		 * have picked up defaults via translation. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entryp
operator|->
name|nuses
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strchr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|entryp
operator|->
name|uses
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|'+'
argument_list|)
condition|)
name|has_base_entry
operator|=
name|TRUE
expr_stmt|;
name|postprocess_termcap
argument_list|(
operator|&
name|entryp
operator|->
name|tterm
argument_list|,
name|has_base_entry
argument_list|)
expr_stmt|;
block|}
else|else
name|postprocess_terminfo
argument_list|(
operator|&
name|entryp
operator|->
name|tterm
argument_list|)
expr_stmt|;
block|}
name|_nc_wrap_entry
argument_list|(
name|entryp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
block|}
end_block

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|_nc_capcmp
argument_list|(
argument|const char *s
argument_list|,
argument|const char *t
argument_list|)
end_macro

begin_comment
comment|/* compare two string capabilities, stripping out padding */
end_comment

begin_block
block|{
if|if
condition|(
operator|!
name|s
operator|&&
operator|!
name|t
condition|)
return|return
operator|(
literal|0
operator|)
return|;
elseif|else
if|if
condition|(
operator|!
name|s
operator|||
operator|!
name|t
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'$'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'<'
condition|)
block|{
for|for
control|(
name|s
operator|+=
literal|2
init|;
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|isdigit
argument_list|(
name|UChar
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|'.'
operator|||
operator|*
name|s
operator|==
literal|'*'
operator|||
operator|*
name|s
operator|==
literal|'/'
operator|||
operator|*
name|s
operator|==
literal|'>'
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|t
index|[
literal|0
index|]
operator|==
literal|'$'
operator|&&
name|t
index|[
literal|1
index|]
operator|==
literal|'<'
condition|)
block|{
for|for
control|(
name|t
operator|+=
literal|2
init|;
condition|;
name|t
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|isdigit
argument_list|(
name|UChar
argument_list|(
operator|*
name|t
argument_list|)
argument_list|)
operator|||
operator|*
name|t
operator|==
literal|'.'
operator|||
operator|*
name|t
operator|==
literal|'*'
operator|||
operator|*
name|t
operator|==
literal|'/'
operator|||
operator|*
name|t
operator|==
literal|'>'
operator|)
condition|)
break|break;
block|}
comment|/* we've now pushed s and t past any padding they were pointing at */
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
operator|&&
operator|*
name|t
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|*
name|s
operator|!=
operator|*
name|t
condition|)
return|return
operator|(
operator|*
name|t
operator|-
operator|*
name|s
operator|)
return|;
comment|/* else *s == *t but one is not NUL, so continue */
name|s
operator|++
operator|,
name|t
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_function
specifier|static
name|void
name|append_acs0
parameter_list|(
name|string_desc
modifier|*
name|dst
parameter_list|,
name|int
name|code
parameter_list|,
name|int
name|src
parameter_list|)
block|{
if|if
condition|(
name|src
operator|!=
literal|0
condition|)
block|{
name|char
name|temp
index|[
literal|3
index|]
decl_stmt|;
name|temp
index|[
literal|0
index|]
operator|=
name|code
expr_stmt|;
name|temp
index|[
literal|1
index|]
operator|=
name|src
expr_stmt|;
name|temp
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|_nc_safe_strcat
argument_list|(
name|dst
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|append_acs
parameter_list|(
name|string_desc
modifier|*
name|dst
parameter_list|,
name|int
name|code
parameter_list|,
name|char
modifier|*
name|src
parameter_list|)
block|{
if|if
condition|(
name|src
operator|!=
literal|0
operator|&&
name|strlen
argument_list|(
name|src
argument_list|)
operator|==
literal|1
condition|)
block|{
name|append_acs0
argument_list|(
name|dst
argument_list|,
name|code
argument_list|,
operator|*
name|src
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * The ko capability, if present, consists of a comma-separated capability  * list.  For each capability, we may assume there is a keycap that sends the  * string which is the value of that capability.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|char
modifier|*
name|from
decl_stmt|;
specifier|const
name|char
modifier|*
name|to
decl_stmt|;
block|}
name|assoc
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|assoc
specifier|const
name|ko_xlate
index|[]
init|=
block|{
block|{
literal|"al"
block|,
literal|"kil1"
block|}
block|,
comment|/* insert line key  -> KEY_IL    */
block|{
literal|"bt"
block|,
literal|"kcbt"
block|}
block|,
comment|/* back tab         -> KEY_BTAB  */
block|{
literal|"cd"
block|,
literal|"ked"
block|}
block|,
comment|/* clear-to-eos key -> KEY_EOL   */
block|{
literal|"ce"
block|,
literal|"kel"
block|}
block|,
comment|/* clear-to-eol key -> KEY_EOS   */
block|{
literal|"cl"
block|,
literal|"kclr"
block|}
block|,
comment|/* clear key        -> KEY_CLEAR */
block|{
literal|"ct"
block|,
literal|"tbc"
block|}
block|,
comment|/* clear all tabs   -> KEY_CATAB */
block|{
literal|"dc"
block|,
literal|"kdch1"
block|}
block|,
comment|/* delete char      -> KEY_DC    */
block|{
literal|"dl"
block|,
literal|"kdl1"
block|}
block|,
comment|/* delete line      -> KEY_DL    */
block|{
literal|"do"
block|,
literal|"kcud1"
block|}
block|,
comment|/* down key         -> KEY_DOWN  */
block|{
literal|"ei"
block|,
literal|"krmir"
block|}
block|,
comment|/* exit insert key  -> KEY_EIC   */
block|{
literal|"ho"
block|,
literal|"khome"
block|}
block|,
comment|/* home key         -> KEY_HOME  */
block|{
literal|"ic"
block|,
literal|"kich1"
block|}
block|,
comment|/* insert char key  -> KEY_IC    */
block|{
literal|"im"
block|,
literal|"kIC"
block|}
block|,
comment|/* insert-mode key  -> KEY_SIC   */
block|{
literal|"le"
block|,
literal|"kcub1"
block|}
block|,
comment|/* le key           -> KEY_LEFT  */
block|{
literal|"nd"
block|,
literal|"kcuf1"
block|}
block|,
comment|/* nd key           -> KEY_RIGHT */
block|{
literal|"nl"
block|,
literal|"kent"
block|}
block|,
comment|/* new line key     -> KEY_ENTER */
block|{
literal|"st"
block|,
literal|"khts"
block|}
block|,
comment|/* set-tab key      -> KEY_STAB  */
block|{
literal|"ta"
block|,
name|CANCELLED_STRING
block|}
block|,
block|{
literal|"up"
block|,
literal|"kcuu1"
block|}
block|,
comment|/* up-arrow key     -> KEY_UP    */
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|,
operator|(
name|char
operator|*
operator|)
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This routine fills in string caps that either had defaults under  * termcap or can be manufactured from obsolete termcap capabilities.  * It was lifted from Ross Ridge's mytinfo package.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|C_CR
index|[]
init|=
literal|"\r"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|C_LF
index|[]
init|=
literal|"\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|C_BS
index|[]
init|=
literal|"\b"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|C_HT
index|[]
init|=
literal|"\t"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Note that WANTED and PRESENT are not simple inverses!  If a capability  * has been explicitly cancelled, it's not considered WANTED.  */
end_comment

begin_define
define|#
directive|define
name|WANTED
parameter_list|(
name|s
parameter_list|)
value|((s) == ABSENT_STRING)
end_define

begin_define
define|#
directive|define
name|PRESENT
parameter_list|(
name|s
parameter_list|)
value|(((s) != ABSENT_STRING)&& ((s) != CANCELLED_STRING))
end_define

begin_comment
comment|/*  * This bit of legerdemain turns all the terminfo variable names into  * references to locations in the arrays Booleans, Numbers, and Strings ---  * precisely what's needed.  */
end_comment

begin_undef
undef|#
directive|undef
name|CUR
end_undef

begin_define
define|#
directive|define
name|CUR
value|tp->
end_define

begin_function
specifier|static
name|void
name|postprocess_termcap
parameter_list|(
name|TERMTYPE
modifier|*
name|tp
parameter_list|,
name|bool
name|has_base
parameter_list|)
block|{
name|char
name|buf
index|[
name|MAX_LINE
operator|*
literal|2
operator|+
literal|2
index|]
decl_stmt|;
name|string_desc
name|result
decl_stmt|;
comment|/*      * TERMCAP DEFAULTS AND OBSOLETE-CAPABILITY TRANSLATIONS      *      * This first part of the code is the functional inverse of the      * fragment in capdefaults.c.      * ----------------------------------------------------------------------      */
comment|/* if there was a tc entry, assume we picked up defaults via that */
if|if
condition|(
operator|!
name|has_base
condition|)
block|{
if|if
condition|(
name|WANTED
argument_list|(
name|init_3string
argument_list|)
operator|&&
name|termcap_init2
condition|)
name|init_3string
operator|=
name|_nc_save_str
argument_list|(
name|termcap_init2
argument_list|)
expr_stmt|;
if|if
condition|(
name|WANTED
argument_list|(
name|reset_2string
argument_list|)
operator|&&
name|termcap_reset
condition|)
name|reset_2string
operator|=
name|_nc_save_str
argument_list|(
name|termcap_reset
argument_list|)
expr_stmt|;
if|if
condition|(
name|WANTED
argument_list|(
name|carriage_return
argument_list|)
condition|)
block|{
if|if
condition|(
name|carriage_return_delay
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s$<%d>"
argument_list|,
name|C_CR
argument_list|,
name|carriage_return_delay
argument_list|)
expr_stmt|;
name|carriage_return
operator|=
name|_nc_save_str
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
name|carriage_return
operator|=
name|_nc_save_str
argument_list|(
name|C_CR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|WANTED
argument_list|(
name|cursor_left
argument_list|)
condition|)
block|{
if|if
condition|(
name|backspace_delay
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s$<%d>"
argument_list|,
name|C_BS
argument_list|,
name|backspace_delay
argument_list|)
expr_stmt|;
name|cursor_left
operator|=
name|_nc_save_str
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|backspaces_with_bs
operator|==
literal|1
condition|)
name|cursor_left
operator|=
name|_nc_save_str
argument_list|(
name|C_BS
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|PRESENT
argument_list|(
name|backspace_if_not_bs
argument_list|)
condition|)
name|cursor_left
operator|=
name|backspace_if_not_bs
expr_stmt|;
block|}
comment|/* vi doesn't use "do", but it does seems to use nl (or '\n') instead */
if|if
condition|(
name|WANTED
argument_list|(
name|cursor_down
argument_list|)
condition|)
block|{
if|if
condition|(
name|PRESENT
argument_list|(
name|linefeed_if_not_lf
argument_list|)
condition|)
name|cursor_down
operator|=
name|linefeed_if_not_lf
expr_stmt|;
elseif|else
if|if
condition|(
name|linefeed_is_newline
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|new_line_delay
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s$<%d>"
argument_list|,
name|C_LF
argument_list|,
name|new_line_delay
argument_list|)
expr_stmt|;
name|cursor_down
operator|=
name|_nc_save_str
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
name|cursor_down
operator|=
name|_nc_save_str
argument_list|(
name|C_LF
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|WANTED
argument_list|(
name|scroll_forward
argument_list|)
operator|&&
name|crt_no_scrolling
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|PRESENT
argument_list|(
name|linefeed_if_not_lf
argument_list|)
condition|)
name|cursor_down
operator|=
name|linefeed_if_not_lf
expr_stmt|;
elseif|else
if|if
condition|(
name|linefeed_is_newline
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|new_line_delay
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s$<%d>"
argument_list|,
name|C_LF
argument_list|,
name|new_line_delay
argument_list|)
expr_stmt|;
name|scroll_forward
operator|=
name|_nc_save_str
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
name|scroll_forward
operator|=
name|_nc_save_str
argument_list|(
name|C_LF
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|WANTED
argument_list|(
name|newline
argument_list|)
condition|)
block|{
if|if
condition|(
name|linefeed_is_newline
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|new_line_delay
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s$<%d>"
argument_list|,
name|C_LF
argument_list|,
name|new_line_delay
argument_list|)
expr_stmt|;
name|newline
operator|=
name|_nc_save_str
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
name|newline
operator|=
name|_nc_save_str
argument_list|(
name|C_LF
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PRESENT
argument_list|(
name|carriage_return
argument_list|)
operator|&&
name|PRESENT
argument_list|(
name|scroll_forward
argument_list|)
condition|)
block|{
name|_nc_str_init
argument_list|(
operator|&
name|result
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|_nc_safe_strcat
argument_list|(
operator|&
name|result
argument_list|,
name|carriage_return
argument_list|)
operator|&&
name|_nc_safe_strcat
argument_list|(
operator|&
name|result
argument_list|,
name|scroll_forward
argument_list|)
condition|)
name|newline
operator|=
name|_nc_save_str
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PRESENT
argument_list|(
name|carriage_return
argument_list|)
operator|&&
name|PRESENT
argument_list|(
name|cursor_down
argument_list|)
condition|)
block|{
name|_nc_str_init
argument_list|(
operator|&
name|result
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|_nc_safe_strcat
argument_list|(
operator|&
name|result
argument_list|,
name|carriage_return
argument_list|)
operator|&&
name|_nc_safe_strcat
argument_list|(
operator|&
name|result
argument_list|,
name|cursor_down
argument_list|)
condition|)
name|newline
operator|=
name|_nc_save_str
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*      * Inverse of capdefaults.c code ends here.      * ----------------------------------------------------------------------      *      * TERMCAP-TO TERMINFO MAPPINGS FOR SOURCE TRANSLATION      *      * These translations will *not* be inverted by tgetent().      */
if|if
condition|(
operator|!
name|has_base
condition|)
block|{
comment|/* 	 * We wait until now to decide if we've got a working cr because even 	 * one that doesn't work can be used for newline. Unfortunately the 	 * space allocated for it is wasted. 	 */
if|if
condition|(
name|return_does_clr_eol
operator|==
literal|1
operator|||
name|no_correctly_working_cr
operator|==
literal|1
condition|)
name|carriage_return
operator|=
name|ABSENT_STRING
expr_stmt|;
comment|/* 	 * Supposedly most termcap entries have ta now and '\t' is no longer a 	 * default, but it doesn't seem to be true... 	 */
if|if
condition|(
name|WANTED
argument_list|(
name|tab
argument_list|)
condition|)
block|{
if|if
condition|(
name|horizontal_tab_delay
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s$<%d>"
argument_list|,
name|C_HT
argument_list|,
name|horizontal_tab_delay
argument_list|)
expr_stmt|;
name|tab
operator|=
name|_nc_save_str
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
name|tab
operator|=
name|_nc_save_str
argument_list|(
name|C_HT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|init_tabs
operator|==
name|ABSENT_NUMERIC
operator|&&
name|has_hardware_tabs
operator|==
name|TRUE
condition|)
name|init_tabs
operator|=
literal|8
expr_stmt|;
comment|/* 	 * Assume we can beep with ^G unless we're given bl@. 	 */
if|if
condition|(
name|WANTED
argument_list|(
name|bell
argument_list|)
condition|)
name|bell
operator|=
name|_nc_save_str
argument_list|(
literal|"\007"
argument_list|)
expr_stmt|;
block|}
comment|/*      * Translate the old termcap :pt: capability to it#8 + ht=\t      */
if|if
condition|(
name|has_hardware_tabs
operator|==
name|TRUE
condition|)
block|{
if|if
condition|(
name|init_tabs
operator|!=
literal|8
operator|&&
name|init_tabs
operator|!=
name|ABSENT_NUMERIC
condition|)
name|_nc_warning
argument_list|(
literal|"hardware tabs with a width other than 8: %d"
argument_list|,
name|init_tabs
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|tab
operator|&&
name|_nc_capcmp
argument_list|(
name|tab
argument_list|,
name|C_HT
argument_list|)
condition|)
name|_nc_warning
argument_list|(
literal|"hardware tabs with a non-^I tab string %s"
argument_list|,
name|_nc_visbuf
argument_list|(
name|tab
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|WANTED
argument_list|(
name|tab
argument_list|)
condition|)
name|tab
operator|=
name|_nc_save_str
argument_list|(
name|C_HT
argument_list|)
expr_stmt|;
name|init_tabs
operator|=
literal|8
expr_stmt|;
block|}
block|}
block|}
comment|/*      * Now translate the ko capability, if there is one.  This      * isn't from mytinfo...      */
if|if
condition|(
name|PRESENT
argument_list|(
name|other_non_function_keys
argument_list|)
condition|)
block|{
name|char
modifier|*
name|base
init|=
name|other_non_function_keys
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|struct
name|name_table_entry
specifier|const
modifier|*
name|from_ptr
decl_stmt|;
name|struct
name|name_table_entry
specifier|const
modifier|*
name|to_ptr
decl_stmt|;
name|assoc
specifier|const
modifier|*
name|ap
decl_stmt|;
name|char
name|buf2
index|[
name|MAX_TERMINFO_LENGTH
index|]
decl_stmt|;
name|bool
name|foundim
decl_stmt|;
comment|/* we're going to use this for a special case later */
name|dp
operator|=
name|strchr
argument_list|(
name|other_non_function_keys
argument_list|,
literal|'i'
argument_list|)
expr_stmt|;
name|foundim
operator|=
operator|(
name|dp
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|dp
index|[
literal|1
index|]
operator|==
literal|'m'
operator|)
expr_stmt|;
comment|/* look at each comma-separated capability in the ko string... */
for|for
control|(
name|base
operator|=
name|other_non_function_keys
init|;
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|base
argument_list|,
literal|','
argument_list|)
operator|)
operator|!=
literal|0
condition|;
name|base
operator|=
name|cp
operator|+
literal|1
control|)
block|{
name|size_t
name|len
init|=
name|cp
operator|-
name|base
decl_stmt|;
for|for
control|(
name|ap
operator|=
name|ko_xlate
init|;
name|ap
operator|->
name|from
condition|;
name|ap
operator|++
control|)
if|if
condition|(
name|len
operator|==
name|strlen
argument_list|(
name|ap
operator|->
name|from
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|ap
operator|->
name|from
argument_list|,
name|base
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|ap
operator|->
name|to
condition|)
block|{
name|_nc_warning
argument_list|(
literal|"unknown capability `%.*s' in ko string"
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|,
name|base
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|ap
operator|->
name|to
operator|==
name|CANCELLED_STRING
condition|)
comment|/* ignore it */
continue|continue;
comment|/* now we know we found a match in ko_table, so... */
name|from_ptr
operator|=
name|_nc_find_entry
argument_list|(
name|ap
operator|->
name|from
argument_list|,
name|_nc_cap_hash_table
argument_list|)
expr_stmt|;
name|to_ptr
operator|=
name|_nc_find_entry
argument_list|(
name|ap
operator|->
name|to
argument_list|,
name|_nc_info_hash_table
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|from_ptr
operator|||
operator|!
name|to_ptr
condition|)
comment|/* should never happen! */
name|_nc_err_abort
argument_list|(
literal|"ko translation table is invalid, I give up"
argument_list|)
expr_stmt|;
if|if
condition|(
name|WANTED
argument_list|(
name|tp
operator|->
name|Strings
index|[
name|from_ptr
operator|->
name|nte_index
index|]
argument_list|)
condition|)
block|{
name|_nc_warning
argument_list|(
literal|"no value for ko capability %s"
argument_list|,
name|ap
operator|->
name|from
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|tp
operator|->
name|Strings
index|[
name|to_ptr
operator|->
name|nte_index
index|]
condition|)
block|{
comment|/* There's no point in warning about it if it's the same 		 * string; that's just an inefficiency. 		 */
if|if
condition|(
name|strcmp
argument_list|(
name|tp
operator|->
name|Strings
index|[
name|from_ptr
operator|->
name|nte_index
index|]
argument_list|,
name|tp
operator|->
name|Strings
index|[
name|to_ptr
operator|->
name|nte_index
index|]
argument_list|)
operator|!=
literal|0
condition|)
name|_nc_warning
argument_list|(
literal|"%s (%s) already has an explicit value %s, ignoring ko"
argument_list|,
name|ap
operator|->
name|to
argument_list|,
name|ap
operator|->
name|from
argument_list|,
name|_nc_visbuf
argument_list|(
name|tp
operator|->
name|Strings
index|[
name|to_ptr
operator|->
name|nte_index
index|]
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 	     * The magic moment -- copy the mapped key string over, 	     * stripping out padding. 	     */
for|for
control|(
name|dp
operator|=
name|buf2
operator|,
name|bp
operator|=
name|tp
operator|->
name|Strings
index|[
name|from_ptr
operator|->
name|nte_index
index|]
init|;
operator|*
name|bp
condition|;
name|bp
operator|++
control|)
block|{
if|if
condition|(
name|bp
index|[
literal|0
index|]
operator|==
literal|'$'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'<'
condition|)
block|{
while|while
condition|(
operator|*
name|bp
operator|&&
operator|*
name|bp
operator|!=
literal|'>'
condition|)
block|{
operator|++
name|bp
expr_stmt|;
block|}
block|}
else|else
operator|*
name|dp
operator|++
operator|=
operator|*
name|bp
expr_stmt|;
block|}
operator|*
name|dp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|tp
operator|->
name|Strings
index|[
name|to_ptr
operator|->
name|nte_index
index|]
operator|=
name|_nc_save_str
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Note: ko=im and ko=ic both want to grab the `Insert' 	 * keycap.  There's a kich1 but no ksmir, so the ic capability 	 * got mapped to kich1 and im to kIC to avoid a collision. 	 * If the description has im but not ic, hack kIC back to kich1. 	 */
if|if
condition|(
name|foundim
operator|&&
name|WANTED
argument_list|(
name|key_ic
argument_list|)
operator|&&
name|key_sic
condition|)
block|{
name|key_ic
operator|=
name|key_sic
expr_stmt|;
name|key_sic
operator|=
name|ABSENT_STRING
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|has_base
condition|)
block|{
if|if
condition|(
operator|!
name|hard_copy
condition|)
block|{
if|if
condition|(
name|WANTED
argument_list|(
name|key_backspace
argument_list|)
condition|)
name|key_backspace
operator|=
name|_nc_save_str
argument_list|(
name|C_BS
argument_list|)
expr_stmt|;
if|if
condition|(
name|WANTED
argument_list|(
name|key_left
argument_list|)
condition|)
name|key_left
operator|=
name|_nc_save_str
argument_list|(
name|C_BS
argument_list|)
expr_stmt|;
if|if
condition|(
name|WANTED
argument_list|(
name|key_down
argument_list|)
condition|)
name|key_down
operator|=
name|_nc_save_str
argument_list|(
name|C_LF
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Translate XENIX forms characters.      */
if|if
condition|(
name|PRESENT
argument_list|(
name|acs_ulcorner
argument_list|)
operator|||
name|PRESENT
argument_list|(
name|acs_llcorner
argument_list|)
operator|||
name|PRESENT
argument_list|(
name|acs_urcorner
argument_list|)
operator|||
name|PRESENT
argument_list|(
name|acs_lrcorner
argument_list|)
operator|||
name|PRESENT
argument_list|(
name|acs_ltee
argument_list|)
operator|||
name|PRESENT
argument_list|(
name|acs_rtee
argument_list|)
operator|||
name|PRESENT
argument_list|(
name|acs_btee
argument_list|)
operator|||
name|PRESENT
argument_list|(
name|acs_ttee
argument_list|)
operator|||
name|PRESENT
argument_list|(
name|acs_hline
argument_list|)
operator|||
name|PRESENT
argument_list|(
name|acs_vline
argument_list|)
operator|||
name|PRESENT
argument_list|(
name|acs_plus
argument_list|)
condition|)
block|{
name|char
name|buf2
index|[
name|MAX_TERMCAP_LENGTH
index|]
decl_stmt|;
name|_nc_str_init
argument_list|(
operator|&
name|result
argument_list|,
name|buf2
argument_list|,
sizeof|sizeof
argument_list|(
name|buf2
argument_list|)
argument_list|)
expr_stmt|;
name|_nc_safe_strcat
argument_list|(
operator|&
name|result
argument_list|,
name|acs_chars
argument_list|)
expr_stmt|;
name|append_acs
argument_list|(
operator|&
name|result
argument_list|,
literal|'j'
argument_list|,
name|acs_lrcorner
argument_list|)
expr_stmt|;
name|append_acs
argument_list|(
operator|&
name|result
argument_list|,
literal|'k'
argument_list|,
name|acs_urcorner
argument_list|)
expr_stmt|;
name|append_acs
argument_list|(
operator|&
name|result
argument_list|,
literal|'l'
argument_list|,
name|acs_ulcorner
argument_list|)
expr_stmt|;
name|append_acs
argument_list|(
operator|&
name|result
argument_list|,
literal|'m'
argument_list|,
name|acs_llcorner
argument_list|)
expr_stmt|;
name|append_acs
argument_list|(
operator|&
name|result
argument_list|,
literal|'n'
argument_list|,
name|acs_plus
argument_list|)
expr_stmt|;
name|append_acs
argument_list|(
operator|&
name|result
argument_list|,
literal|'q'
argument_list|,
name|acs_hline
argument_list|)
expr_stmt|;
name|append_acs
argument_list|(
operator|&
name|result
argument_list|,
literal|'t'
argument_list|,
name|acs_ltee
argument_list|)
expr_stmt|;
name|append_acs
argument_list|(
operator|&
name|result
argument_list|,
literal|'u'
argument_list|,
name|acs_rtee
argument_list|)
expr_stmt|;
name|append_acs
argument_list|(
operator|&
name|result
argument_list|,
literal|'v'
argument_list|,
name|acs_btee
argument_list|)
expr_stmt|;
name|append_acs
argument_list|(
operator|&
name|result
argument_list|,
literal|'w'
argument_list|,
name|acs_ttee
argument_list|)
expr_stmt|;
name|append_acs
argument_list|(
operator|&
name|result
argument_list|,
literal|'x'
argument_list|,
name|acs_vline
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf2
index|[
literal|0
index|]
condition|)
block|{
name|acs_chars
operator|=
name|_nc_save_str
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
name|_nc_warning
argument_list|(
literal|"acsc string synthesized from XENIX capabilities"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|acs_chars
operator|==
literal|0
operator|&&
name|enter_alt_charset_mode
operator|!=
literal|0
operator|&&
name|exit_alt_charset_mode
operator|!=
literal|0
condition|)
block|{
name|acs_chars
operator|=
name|_nc_save_str
argument_list|(
name|VT_ACSC
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|postprocess_terminfo
parameter_list|(
name|TERMTYPE
modifier|*
name|tp
parameter_list|)
block|{
comment|/*      * TERMINFO-TO-TERMINFO MAPPINGS FOR SOURCE TRANSLATION      * ----------------------------------------------------------------------      */
comment|/*      * Translate AIX forms characters.      */
if|if
condition|(
name|PRESENT
argument_list|(
name|box_chars_1
argument_list|)
condition|)
block|{
name|char
name|buf2
index|[
name|MAX_TERMCAP_LENGTH
index|]
decl_stmt|;
name|string_desc
name|result
decl_stmt|;
name|_nc_str_init
argument_list|(
operator|&
name|result
argument_list|,
name|buf2
argument_list|,
sizeof|sizeof
argument_list|(
name|buf2
argument_list|)
argument_list|)
expr_stmt|;
name|_nc_safe_strcat
argument_list|(
operator|&
name|result
argument_list|,
name|acs_chars
argument_list|)
expr_stmt|;
name|append_acs0
argument_list|(
operator|&
name|result
argument_list|,
literal|'l'
argument_list|,
name|box_chars_1
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* ACS_ULCORNER */
name|append_acs0
argument_list|(
operator|&
name|result
argument_list|,
literal|'q'
argument_list|,
name|box_chars_1
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* ACS_HLINE */
name|append_acs0
argument_list|(
operator|&
name|result
argument_list|,
literal|'k'
argument_list|,
name|box_chars_1
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* ACS_URCORNER */
name|append_acs0
argument_list|(
operator|&
name|result
argument_list|,
literal|'x'
argument_list|,
name|box_chars_1
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* ACS_VLINE */
name|append_acs0
argument_list|(
operator|&
name|result
argument_list|,
literal|'j'
argument_list|,
name|box_chars_1
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
comment|/* ACS_LRCORNER */
name|append_acs0
argument_list|(
operator|&
name|result
argument_list|,
literal|'m'
argument_list|,
name|box_chars_1
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
comment|/* ACS_LLCORNER */
name|append_acs0
argument_list|(
operator|&
name|result
argument_list|,
literal|'w'
argument_list|,
name|box_chars_1
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
comment|/* ACS_TTEE */
name|append_acs0
argument_list|(
operator|&
name|result
argument_list|,
literal|'u'
argument_list|,
name|box_chars_1
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
comment|/* ACS_RTEE */
name|append_acs0
argument_list|(
operator|&
name|result
argument_list|,
literal|'v'
argument_list|,
name|box_chars_1
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
comment|/* ACS_BTEE */
name|append_acs0
argument_list|(
operator|&
name|result
argument_list|,
literal|'t'
argument_list|,
name|box_chars_1
index|[
literal|9
index|]
argument_list|)
expr_stmt|;
comment|/* ACS_LTEE */
name|append_acs0
argument_list|(
operator|&
name|result
argument_list|,
literal|'n'
argument_list|,
name|box_chars_1
index|[
literal|10
index|]
argument_list|)
expr_stmt|;
comment|/* ACS_PLUS */
if|if
condition|(
name|buf2
index|[
literal|0
index|]
condition|)
block|{
name|acs_chars
operator|=
name|_nc_save_str
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
name|_nc_warning
argument_list|(
literal|"acsc string synthesized from AIX capabilities"
argument_list|)
expr_stmt|;
name|box_chars_1
operator|=
name|ABSENT_STRING
expr_stmt|;
block|}
block|}
comment|/*      * ----------------------------------------------------------------------      */
block|}
end_function

begin_comment
comment|/*  * Do a linear search through the terminfo tables to find a given full-name.  * We don't expect to do this often, so there's no hashing function.  *  * In effect, this scans through the 3 lists of full-names, and looks them  * up in _nc_info_table, which is organized so that the nte_index fields are  * sorted, but the nte_type fields are not necessarily grouped together.  */
end_comment

begin_function
specifier|static
name|struct
name|name_table_entry
specifier|const
modifier|*
name|lookup_fullname
parameter_list|(
specifier|const
name|char
modifier|*
name|find
parameter_list|)
block|{
name|int
name|state
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|NCURSES_CONST
name|char
modifier|*
specifier|const
modifier|*
name|names
decl_stmt|;
switch|switch
condition|(
operator|++
name|state
condition|)
block|{
case|case
name|BOOLEAN
case|:
name|names
operator|=
name|boolfnames
expr_stmt|;
break|break;
case|case
name|STRING
case|:
name|names
operator|=
name|strfnames
expr_stmt|;
break|break;
case|case
name|NUMBER
case|:
name|names
operator|=
name|numfnames
expr_stmt|;
break|break;
default|default:
return|return
name|NOTFOUND
return|;
block|}
for|for
control|(
name|count
operator|=
literal|0
init|;
name|names
index|[
name|count
index|]
operator|!=
literal|0
condition|;
name|count
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|names
index|[
name|count
index|]
argument_list|,
name|find
argument_list|)
condition|)
block|{
name|struct
name|name_table_entry
specifier|const
modifier|*
name|entry_ptr
init|=
name|_nc_get_table
argument_list|(
name|FALSE
argument_list|)
decl_stmt|;
while|while
condition|(
name|entry_ptr
operator|->
name|nte_type
operator|!=
name|state
operator|||
name|entry_ptr
operator|->
name|nte_index
operator|!=
name|count
condition|)
name|entry_ptr
operator|++
expr_stmt|;
return|return
name|entry_ptr
return|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* parse_entry.c ends here */
end_comment

end_unit

