begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************************  * Copyright (c) 1998-2005,2006 Free Software Foundation, Inc.              *  *                                                                          *  * Permission is hereby granted, free of charge, to any person obtaining a  *  * copy of this software and associated documentation files (the            *  * "Software"), to deal in the Software without restriction, including      *  * without limitation the rights to use, copy, modify, merge, publish,      *  * distribute, distribute with modifications, sublicense, and/or sell       *  * copies of the Software, and to permit persons to whom the Software is    *  * furnished to do so, subject to the following conditions:                 *  *                                                                          *  * The above copyright notice and this permission notice shall be included  *  * in all copies or substantial portions of the Software.                   *  *                                                                          *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *  * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *  * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *  *                                                                          *  * Except as contained in this notice, the name(s) of the above copyright   *  * holders shall not be used in advertising or otherwise to promote the     *  * sale, use or other dealings in this Software without prior written       *  * authorization.                                                           *  ****************************************************************************/
end_comment

begin_comment
comment|/****************************************************************************  *  Author: Zeyd M. Ben-Halim<zmbenhal@netcom.com> 1992,1995               *  *     and: Eric S. Raymond<esr@snark.thyrsus.com>                         *  *     and: Thomas E. Dickey, 1996 on                                       *  ****************************************************************************/
end_comment

begin_comment
comment|/*  *	tparm.c  *  */
end_comment

begin_include
include|#
directive|include
file|<curses.priv.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<term.h>
end_include

begin_include
include|#
directive|include
file|<tic.h>
end_include

begin_macro
name|MODULE_ID
argument_list|(
literal|"$Id: lib_tparm.c,v 1.71 2006/11/26 01:12:56 tom Exp $"
argument_list|)
end_macro

begin_comment
comment|/*  *	char *  *	tparm(string, ...)  *  *	Substitute the given parameters into the given string by the following  *	rules (taken from terminfo(5)):  *  *	     Cursor addressing and other strings  requiring  parame-  *	ters in the terminal are described by a parameterized string  *	capability, with like escapes %x in  it.   For  example,  to  *	address  the  cursor, the cup capability is given, using two  *	parameters: the row and column to  address  to.   (Rows  and  *	columns  are  numbered  from  zero and refer to the physical  *	screen visible to the user, not to any  unseen  memory.)  If  *	the terminal has memory relative cursor addressing, that can  *	be indicated by  *  *	     The parameter mechanism uses  a  stack  and  special  %  *	codes  to manipulate it.  Typically a sequence will push one  *	of the parameters onto the stack and then print it  in  some  *	format.  Often more complex operations are necessary.  *  *	     The % encodings have the following meanings:  *  *	     %%        outputs `%'  *	     %c        print pop() like %c in printf()  *	     %s        print pop() like %s in printf()  *           %[[:]flags][width[.precision]][doxXs]  *                     as in printf, flags are [-+#] and space  *                     The ':' is used to avoid making %+ or %-  *                     patterns (see below).  *  *	     %p[1-9]   push ith parm  *	     %P[a-z]   set dynamic variable [a-z] to pop()  *	     %g[a-z]   get dynamic variable [a-z] and push it  *	     %P[A-Z]   set static variable [A-Z] to pop()  *	     %g[A-Z]   get static variable [A-Z] and push it  *	     %l        push strlen(pop)  *	     %'c'      push char constant c  *	     %{nn}     push integer constant nn  *  *	     %+ %- %* %/ %m  *	               arithmetic (%m is mod): push(pop() op pop())  *	     %& %| %^  bit operations: push(pop() op pop())  *	     %= %> %<  logical operations: push(pop() op pop())  *	     %A %O     logical and& or operations for conditionals  *	     %! %~     unary operations push(op pop())  *	     %i        add 1 to first two parms (for ANSI terminals)  *  *	     %? expr %t thenpart %e elsepart %;  *	               if-then-else, %e elsepart is optional.  *	               else-if's are possible ala Algol 68:  *	               %? c1 %t b1 %e c2 %t b2 %e c3 %t b3 %e c4 %t b4 %e b5 %;  *  *	For those of the above operators which are binary and not commutative,  *	the stack works in the usual way, with  *			%gx %gy %m  *	resulting in x mod y, not the reverse.  */
end_comment

begin_define
define|#
directive|define
name|STACKSIZE
value|20
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
union|union
block|{
name|int
name|num
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
block|}
name|data
union|;
name|bool
name|num_type
decl_stmt|;
block|}
name|stack_frame
typedef|;
end_typedef

begin_macro
name|NCURSES_EXPORT_VAR
argument_list|(
argument|int
argument_list|)
end_macro

begin_expr_stmt
name|_nc_tparm_err
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|stack_frame
name|stack
index|[
name|STACKSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stack_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|tparam_base
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TRACE
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|tname
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TRACE */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|out_buff
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|out_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|out_used
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|fmt_buff
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|fmt_size
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|NO_LEAKS
end_if

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|_nc_free_tparm
argument_list|(
argument|void
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|out_buff
operator|!=
literal|0
condition|)
block|{
name|FreeAndNull
argument_list|(
name|out_buff
argument_list|)
expr_stmt|;
name|out_size
operator|=
literal|0
expr_stmt|;
name|out_used
operator|=
literal|0
expr_stmt|;
name|FreeAndNull
argument_list|(
name|fmt_buff
argument_list|)
expr_stmt|;
name|fmt_size
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|NCURSES_INLINE
name|void
name|get_space
parameter_list|(
name|size_t
name|need
parameter_list|)
block|{
name|need
operator|+=
name|out_used
expr_stmt|;
if|if
condition|(
name|need
operator|>
name|out_size
condition|)
block|{
name|out_size
operator|=
name|need
operator|*
literal|2
expr_stmt|;
name|out_buff
operator|=
name|typeRealloc
argument_list|(
name|char
argument_list|,
name|out_size
argument_list|,
name|out_buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_buff
operator|==
literal|0
condition|)
name|_nc_err_abort
argument_list|(
name|MSG_NO_MEMORY
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|NCURSES_INLINE
name|void
name|save_text
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|size_t
name|s_len
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>
operator|(
name|int
operator|)
name|s_len
condition|)
name|s_len
operator|=
name|len
expr_stmt|;
name|get_space
argument_list|(
name|s_len
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|out_buff
operator|+
name|out_used
argument_list|,
name|fmt
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|out_used
operator|+=
name|strlen
argument_list|(
name|out_buff
operator|+
name|out_used
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|NCURSES_INLINE
name|void
name|save_number
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|int
name|number
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|<
literal|30
condition|)
name|len
operator|=
literal|30
expr_stmt|;
comment|/* actually log10(MAX_INT)+1 */
name|get_space
argument_list|(
operator|(
name|unsigned
operator|)
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|out_buff
operator|+
name|out_used
argument_list|,
name|fmt
argument_list|,
name|number
argument_list|)
expr_stmt|;
name|out_used
operator|+=
name|strlen
argument_list|(
name|out_buff
operator|+
name|out_used
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|NCURSES_INLINE
name|void
name|save_char
parameter_list|(
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|==
literal|0
condition|)
name|c
operator|=
literal|0200
expr_stmt|;
name|get_space
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out_buff
index|[
name|out_used
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|NCURSES_INLINE
name|void
name|npush
parameter_list|(
name|int
name|x
parameter_list|)
block|{
if|if
condition|(
name|stack_ptr
operator|<
name|STACKSIZE
condition|)
block|{
name|stack
index|[
name|stack_ptr
index|]
operator|.
name|num_type
operator|=
name|TRUE
expr_stmt|;
name|stack
index|[
name|stack_ptr
index|]
operator|.
name|data
operator|.
name|num
operator|=
name|x
expr_stmt|;
name|stack_ptr
operator|++
expr_stmt|;
block|}
else|else
block|{
name|DEBUG
argument_list|(
literal|2
argument_list|,
operator|(
literal|"npush: stack overflow: %s"
operator|,
name|_nc_visbuf
argument_list|(
name|tparam_base
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|_nc_tparm_err
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|NCURSES_INLINE
name|int
name|npop
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|stack_ptr
operator|>
literal|0
condition|)
block|{
name|stack_ptr
operator|--
expr_stmt|;
if|if
condition|(
name|stack
index|[
name|stack_ptr
index|]
operator|.
name|num_type
condition|)
name|result
operator|=
name|stack
index|[
name|stack_ptr
index|]
operator|.
name|data
operator|.
name|num
expr_stmt|;
block|}
else|else
block|{
name|DEBUG
argument_list|(
literal|2
argument_list|,
operator|(
literal|"npop: stack underflow: %s"
operator|,
name|_nc_visbuf
argument_list|(
name|tparam_base
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|_nc_tparm_err
operator|++
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|NCURSES_INLINE
name|void
name|spush
parameter_list|(
name|char
modifier|*
name|x
parameter_list|)
block|{
if|if
condition|(
name|stack_ptr
operator|<
name|STACKSIZE
condition|)
block|{
name|stack
index|[
name|stack_ptr
index|]
operator|.
name|num_type
operator|=
name|FALSE
expr_stmt|;
name|stack
index|[
name|stack_ptr
index|]
operator|.
name|data
operator|.
name|str
operator|=
name|x
expr_stmt|;
name|stack_ptr
operator|++
expr_stmt|;
block|}
else|else
block|{
name|DEBUG
argument_list|(
literal|2
argument_list|,
operator|(
literal|"spush: stack overflow: %s"
operator|,
name|_nc_visbuf
argument_list|(
name|tparam_base
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|_nc_tparm_err
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|NCURSES_INLINE
name|char
modifier|*
name|spop
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|char
name|dummy
index|[]
init|=
literal|""
decl_stmt|;
comment|/* avoid const-cast */
name|char
modifier|*
name|result
init|=
name|dummy
decl_stmt|;
if|if
condition|(
name|stack_ptr
operator|>
literal|0
condition|)
block|{
name|stack_ptr
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|stack
index|[
name|stack_ptr
index|]
operator|.
name|num_type
operator|&&
name|stack
index|[
name|stack_ptr
index|]
operator|.
name|data
operator|.
name|str
operator|!=
literal|0
condition|)
name|result
operator|=
name|stack
index|[
name|stack_ptr
index|]
operator|.
name|data
operator|.
name|str
expr_stmt|;
block|}
else|else
block|{
name|DEBUG
argument_list|(
literal|2
argument_list|,
operator|(
literal|"spop: stack underflow: %s"
operator|,
name|_nc_visbuf
argument_list|(
name|tparam_base
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|_nc_tparm_err
operator|++
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|NCURSES_INLINE
specifier|const
name|char
modifier|*
name|parse_format
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|char
modifier|*
name|format
parameter_list|,
name|int
modifier|*
name|len
parameter_list|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|format
operator|!=
literal|0
condition|)
block|{
name|bool
name|done
init|=
name|FALSE
decl_stmt|;
name|bool
name|allowminus
init|=
name|FALSE
decl_stmt|;
name|bool
name|dot
init|=
name|FALSE
decl_stmt|;
name|bool
name|err
init|=
name|FALSE
decl_stmt|;
name|char
modifier|*
name|fmt
init|=
name|format
decl_stmt|;
name|int
name|my_width
init|=
literal|0
decl_stmt|;
name|int
name|my_prec
init|=
literal|0
decl_stmt|;
name|int
name|value
init|=
literal|0
decl_stmt|;
operator|*
name|len
operator|=
literal|0
expr_stmt|;
operator|*
name|format
operator|++
operator|=
literal|'%'
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
operator|&&
operator|!
name|done
condition|)
block|{
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'c'
case|:
comment|/* FALLTHRU */
case|case
literal|'d'
case|:
comment|/* FALLTHRU */
case|case
literal|'o'
case|:
comment|/* FALLTHRU */
case|case
literal|'x'
case|:
comment|/* FALLTHRU */
case|case
literal|'X'
case|:
comment|/* FALLTHRU */
case|case
literal|'s'
case|:
operator|*
name|format
operator|++
operator|=
operator|*
name|s
expr_stmt|;
name|done
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
operator|*
name|format
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|dot
condition|)
block|{
name|err
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* value before '.' is the width */
name|dot
operator|=
name|TRUE
expr_stmt|;
name|my_width
operator|=
name|value
expr_stmt|;
block|}
name|value
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
operator|*
name|format
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
break|break;
case|case
literal|' '
case|:
operator|*
name|format
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
break|break;
case|case
literal|':'
case|:
name|s
operator|++
expr_stmt|;
name|allowminus
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
if|if
condition|(
name|allowminus
condition|)
block|{
operator|*
name|format
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
else|else
block|{
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|isdigit
argument_list|(
name|UChar
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
condition|)
block|{
name|value
operator|=
operator|(
name|value
operator|*
literal|10
operator|)
operator|+
operator|(
operator|*
name|s
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
name|value
operator|>
literal|10000
condition|)
name|err
operator|=
name|TRUE
expr_stmt|;
operator|*
name|format
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
else|else
block|{
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * If we found an error, ignore (and remove) the flags. 	 */
if|if
condition|(
name|err
condition|)
block|{
name|my_width
operator|=
name|my_prec
operator|=
name|value
operator|=
literal|0
expr_stmt|;
name|format
operator|=
name|fmt
expr_stmt|;
operator|*
name|format
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|format
operator|++
operator|=
operator|*
name|s
expr_stmt|;
block|}
comment|/* 	 * Any value after '.' is the precision.  If we did not see '.', then 	 * the value is the width. 	 */
if|if
condition|(
name|dot
condition|)
name|my_prec
operator|=
name|value
expr_stmt|;
else|else
name|my_width
operator|=
name|value
expr_stmt|;
operator|*
name|format
operator|=
literal|'\0'
expr_stmt|;
comment|/* return maximum string length in print */
operator|*
name|len
operator|=
operator|(
name|my_width
operator|>
name|my_prec
operator|)
condition|?
name|my_width
else|:
name|my_prec
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_define
define|#
directive|define
name|isUPPER
parameter_list|(
name|c
parameter_list|)
value|((c)>= 'A'&& (c)<= 'Z')
end_define

begin_define
define|#
directive|define
name|isLOWER
parameter_list|(
name|c
parameter_list|)
value|((c)>= 'a'&& (c)<= 'z')
end_define

begin_comment
comment|/*  * Analyze the string to see how many parameters we need from the varargs list,  * and what their types are.  We will only accept string parameters if they  * appear as a %l or %s format following an explicit parameter reference (e.g.,  * %p2%s).  All other parameters are numbers.  *  * 'number' counts coarsely the number of pop's we see in the string, and  * 'popcount' shows the highest parameter number in the string.  We would like  * to simply use the latter count, but if we are reading termcap strings, there  * may be cases that we cannot see the explicit parameter numbers.  */
end_comment

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|_nc_tparm_analyze
argument_list|(
argument|const char *string
argument_list|,
argument|char *p_is_s[NUM_PARM]
argument_list|,
argument|int *popcount
argument_list|)
end_macro

begin_block
block|{
name|size_t
name|len2
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|lastpop
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|number
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
init|=
name|string
decl_stmt|;
specifier|static
name|char
name|dummy
index|[]
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|len2
operator|=
name|strlen
argument_list|(
name|cp
argument_list|)
operator|)
operator|>
name|fmt_size
condition|)
block|{
name|fmt_size
operator|=
name|len2
operator|+
name|fmt_size
operator|+
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|fmt_buff
operator|=
name|typeRealloc
argument_list|(
name|char
argument_list|,
name|fmt_size
argument_list|,
name|fmt_buff
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
name|memset
argument_list|(
name|p_is_s
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|p_is_s
index|[
literal|0
index|]
argument_list|)
operator|*
name|NUM_PARM
argument_list|)
expr_stmt|;
operator|*
name|popcount
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|cp
operator|-
name|string
operator|)
operator|<
operator|(
name|int
operator|)
name|len2
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'%'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
name|cp
operator|=
name|parse_format
argument_list|(
name|cp
argument_list|,
name|fmt_buff
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
default|default:
break|break;
case|case
literal|'d'
case|:
comment|/* FALLTHRU */
case|case
literal|'o'
case|:
comment|/* FALLTHRU */
case|case
literal|'x'
case|:
comment|/* FALLTHRU */
case|case
literal|'X'
case|:
comment|/* FALLTHRU */
case|case
literal|'c'
case|:
comment|/* FALLTHRU */
if|if
condition|(
name|lastpop
operator|<=
literal|0
condition|)
name|number
operator|++
expr_stmt|;
name|lastpop
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
case|case
literal|'s'
case|:
if|if
condition|(
name|lastpop
operator|>
literal|0
condition|)
name|p_is_s
index|[
name|lastpop
operator|-
literal|1
index|]
operator|=
name|dummy
expr_stmt|;
operator|++
name|number
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|cp
operator|++
expr_stmt|;
name|i
operator|=
operator|(
name|UChar
argument_list|(
operator|*
name|cp
argument_list|)
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<=
name|NUM_PARM
condition|)
block|{
name|lastpop
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|lastpop
operator|>
operator|*
name|popcount
condition|)
operator|*
name|popcount
operator|=
name|lastpop
expr_stmt|;
block|}
break|break;
case|case
literal|'P'
case|:
operator|++
name|number
expr_stmt|;
operator|++
name|cp
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|cp
operator|++
expr_stmt|;
break|break;
case|case
name|S_QUOTE
case|:
name|cp
operator|+=
literal|2
expr_stmt|;
name|lastpop
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|L_BRACE
case|:
name|cp
operator|++
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
name|UChar
argument_list|(
operator|*
name|cp
argument_list|)
argument_list|)
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'+'
case|:
case|case
literal|'-'
case|:
case|case
literal|'*'
case|:
case|case
literal|'/'
case|:
case|case
literal|'m'
case|:
case|case
literal|'A'
case|:
case|case
literal|'O'
case|:
case|case
literal|'&'
case|:
case|case
literal|'|'
case|:
case|case
literal|'^'
case|:
case|case
literal|'='
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
name|lastpop
operator|=
operator|-
literal|1
expr_stmt|;
name|number
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
case|case
literal|'~'
case|:
name|lastpop
operator|=
operator|-
literal|1
expr_stmt|;
operator|++
name|number
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* will add 1 to first (usually two) parameters */
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
name|cp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|number
operator|>
name|NUM_PARM
condition|)
name|number
operator|=
name|NUM_PARM
expr_stmt|;
return|return
name|number
return|;
block|}
end_block

begin_function
specifier|static
name|NCURSES_INLINE
name|char
modifier|*
name|tparam_internal
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
define|#
directive|define
name|NUM_VARS
value|26
name|char
modifier|*
name|p_is_s
index|[
name|NUM_PARM
index|]
decl_stmt|;
name|TPARM_ARG
name|param
index|[
name|NUM_PARM
index|]
decl_stmt|;
name|int
name|popcount
decl_stmt|;
name|int
name|number
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|level
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
init|=
name|string
decl_stmt|;
name|size_t
name|len2
decl_stmt|;
specifier|static
name|int
name|dynamic_var
index|[
name|NUM_VARS
index|]
decl_stmt|;
specifier|static
name|int
name|static_vars
index|[
name|NUM_VARS
index|]
decl_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|out_used
operator|=
literal|0
expr_stmt|;
name|len2
operator|=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/*      * Find the highest parameter-number referred to in the format string.      * Use this value to limit the number of arguments copied from the      * variable-length argument list.      */
name|number
operator|=
name|_nc_tparm_analyze
argument_list|(
name|cp
argument_list|,
name|p_is_s
argument_list|,
operator|&
name|popcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt_buff
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
argument_list|(
name|popcount
argument_list|,
name|number
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* 	 * A few caps (such as plab_norm) have string-valued parms. 	 * We'll have to assume that the caller knows the difference, since 	 * a char* and an int may not be the same size on the stack.  The 	 * normal prototype for this uses 9 long's, which is consistent with 	 * our va_arg() usage. 	 */
if|if
condition|(
name|p_is_s
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|p_is_s
index|[
name|i
index|]
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|param
index|[
name|i
index|]
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|TPARM_ARG
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * This is a termcap compatibility hack.  If there are no explicit pop      * operations in the string, load the stack in such a way that      * successive pops will grab successive parameters.  That will make      * the expansion of (for example) \E[%d;%dH work correctly in termcap      * style, which means tparam() will expand termcap strings OK.      */
name|stack_ptr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|popcount
operator|==
literal|0
condition|)
block|{
name|popcount
operator|=
name|number
expr_stmt|;
for|for
control|(
name|i
operator|=
name|number
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|npush
argument_list|(
name|param
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|_nc_tracing
operator|&
name|TRACE_CALLS
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|popcount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p_is_s
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|save_text
argument_list|(
literal|", %s"
argument_list|,
name|_nc_visbuf
argument_list|(
name|p_is_s
index|[
name|i
index|]
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|save_number
argument_list|(
literal|", %d"
argument_list|,
name|param
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|_tracef
argument_list|(
name|T_CALLED
argument_list|(
literal|"%s(%s%s)"
argument_list|)
argument_list|,
name|tname
argument_list|,
name|_nc_visbuf
argument_list|(
name|cp
argument_list|)
argument_list|,
name|out_buff
argument_list|)
expr_stmt|;
name|out_used
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TRACE */
while|while
condition|(
operator|(
name|cp
operator|-
name|string
operator|)
operator|<
operator|(
name|int
operator|)
name|len2
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'%'
condition|)
block|{
name|save_char
argument_list|(
name|UChar
argument_list|(
operator|*
name|cp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tparam_base
operator|=
name|cp
operator|++
expr_stmt|;
name|cp
operator|=
name|parse_format
argument_list|(
name|cp
argument_list|,
name|fmt_buff
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
default|default:
break|break;
case|case
literal|'%'
case|:
name|save_char
argument_list|(
literal|'%'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* FALLTHRU */
case|case
literal|'o'
case|:
comment|/* FALLTHRU */
case|case
literal|'x'
case|:
comment|/* FALLTHRU */
case|case
literal|'X'
case|:
comment|/* FALLTHRU */
name|save_number
argument_list|(
name|fmt_buff
argument_list|,
name|npop
argument_list|()
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* FALLTHRU */
name|save_char
argument_list|(
name|npop
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|save_number
argument_list|(
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|spop
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|save_text
argument_list|(
name|fmt_buff
argument_list|,
name|spop
argument_list|()
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|cp
operator|++
expr_stmt|;
name|i
operator|=
operator|(
name|UChar
argument_list|(
operator|*
name|cp
argument_list|)
operator|-
literal|'1'
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
name|NUM_PARM
condition|)
block|{
if|if
condition|(
name|p_is_s
index|[
name|i
index|]
condition|)
name|spush
argument_list|(
name|p_is_s
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|npush
argument_list|(
name|param
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'P'
case|:
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|isUPPER
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
name|i
operator|=
operator|(
name|UChar
argument_list|(
operator|*
name|cp
argument_list|)
operator|-
literal|'A'
operator|)
expr_stmt|;
name|static_vars
index|[
name|i
index|]
operator|=
name|npop
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isLOWER
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
name|i
operator|=
operator|(
name|UChar
argument_list|(
operator|*
name|cp
argument_list|)
operator|-
literal|'a'
operator|)
expr_stmt|;
name|dynamic_var
index|[
name|i
index|]
operator|=
name|npop
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'g'
case|:
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|isUPPER
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
name|i
operator|=
operator|(
name|UChar
argument_list|(
operator|*
name|cp
argument_list|)
operator|-
literal|'A'
operator|)
expr_stmt|;
name|npush
argument_list|(
name|static_vars
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isLOWER
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
name|i
operator|=
operator|(
name|UChar
argument_list|(
operator|*
name|cp
argument_list|)
operator|-
literal|'a'
operator|)
expr_stmt|;
name|npush
argument_list|(
name|dynamic_var
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|S_QUOTE
case|:
name|cp
operator|++
expr_stmt|;
name|npush
argument_list|(
name|UChar
argument_list|(
operator|*
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
break|break;
case|case
name|L_BRACE
case|:
name|number
operator|=
literal|0
expr_stmt|;
name|cp
operator|++
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
name|UChar
argument_list|(
operator|*
name|cp
argument_list|)
argument_list|)
condition|)
block|{
name|number
operator|=
operator|(
name|number
operator|*
literal|10
operator|)
operator|+
operator|(
name|UChar
argument_list|(
operator|*
name|cp
argument_list|)
operator|-
literal|'0'
operator|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
name|npush
argument_list|(
name|number
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|npush
argument_list|(
name|npop
argument_list|()
operator|+
name|npop
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|y
operator|=
name|npop
argument_list|()
expr_stmt|;
name|x
operator|=
name|npop
argument_list|()
expr_stmt|;
name|npush
argument_list|(
name|x
operator|-
name|y
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
name|npush
argument_list|(
name|npop
argument_list|()
operator|*
name|npop
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
name|y
operator|=
name|npop
argument_list|()
expr_stmt|;
name|x
operator|=
name|npop
argument_list|()
expr_stmt|;
name|npush
argument_list|(
name|y
condition|?
operator|(
name|x
operator|/
name|y
operator|)
else|:
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|y
operator|=
name|npop
argument_list|()
expr_stmt|;
name|x
operator|=
name|npop
argument_list|()
expr_stmt|;
name|npush
argument_list|(
name|y
condition|?
operator|(
name|x
operator|%
name|y
operator|)
else|:
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|npush
argument_list|(
name|npop
argument_list|()
operator|&&
name|npop
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|npush
argument_list|(
name|npop
argument_list|()
operator|||
name|npop
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
name|npush
argument_list|(
name|npop
argument_list|()
operator|&
name|npop
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
name|npush
argument_list|(
name|npop
argument_list|()
operator||
name|npop
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
name|npush
argument_list|(
name|npop
argument_list|()
operator|^
name|npop
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'='
case|:
name|y
operator|=
name|npop
argument_list|()
expr_stmt|;
name|x
operator|=
name|npop
argument_list|()
expr_stmt|;
name|npush
argument_list|(
name|x
operator|==
name|y
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|y
operator|=
name|npop
argument_list|()
expr_stmt|;
name|x
operator|=
name|npop
argument_list|()
expr_stmt|;
name|npush
argument_list|(
name|x
operator|<
name|y
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|y
operator|=
name|npop
argument_list|()
expr_stmt|;
name|x
operator|=
name|npop
argument_list|()
expr_stmt|;
name|npush
argument_list|(
name|x
operator|>
name|y
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
name|npush
argument_list|(
operator|!
name|npop
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'~'
case|:
name|npush
argument_list|(
operator|~
name|npop
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|p_is_s
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|param
index|[
literal|0
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|p_is_s
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|param
index|[
literal|1
index|]
operator|++
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
break|break;
case|case
literal|'t'
case|:
name|x
operator|=
name|npop
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
block|{
comment|/* scan forward for %e or %; at level zero */
name|cp
operator|++
expr_stmt|;
name|level
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'%'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'?'
condition|)
name|level
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|';'
condition|)
block|{
if|if
condition|(
name|level
operator|>
literal|0
condition|)
name|level
operator|--
expr_stmt|;
else|else
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'e'
operator|&&
name|level
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
operator|*
name|cp
condition|)
name|cp
operator|++
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'e'
case|:
comment|/* scan forward for a %; at level zero */
name|cp
operator|++
expr_stmt|;
name|level
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'%'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'?'
condition|)
name|level
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|';'
condition|)
block|{
if|if
condition|(
name|level
operator|>
literal|0
condition|)
name|level
operator|--
expr_stmt|;
else|else
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|cp
condition|)
name|cp
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|';'
case|:
break|break;
block|}
comment|/* endswitch (*cp) */
block|}
comment|/* endelse (*cp == '%') */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
break|break;
name|cp
operator|++
expr_stmt|;
block|}
comment|/* endwhile (*cp) */
name|get_space
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|out_buff
index|[
name|out_used
index|]
operator|=
literal|'\0'
expr_stmt|;
name|T
argument_list|(
operator|(
name|T_RETURN
argument_list|(
literal|"%s"
argument_list|)
operator|,
name|_nc_visbuf
argument_list|(
name|out_buff
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|out_buff
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|NCURSES_TPARM_VARARGS
end_if

begin_define
define|#
directive|define
name|tparm_varargs
value|tparm
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|tparm_proto
value|tparm
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|char *
argument_list|)
end_macro

begin_macro
name|tparm_varargs
argument_list|(
argument|NCURSES_CONST char *string
argument_list|,
argument|...
argument_list|)
end_macro

begin_block
block|{
name|va_list
name|ap
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|_nc_tparm_err
operator|=
literal|0
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|string
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TRACE
name|tname
operator|=
literal|"tparm"
expr_stmt|;
endif|#
directive|endif
comment|/* TRACE */
name|result
operator|=
name|tparam_internal
argument_list|(
name|string
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_if
if|#
directive|if
operator|!
name|NCURSES_TPARM_VARARGS
end_if

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|char *
argument_list|)
end_macro

begin_macro
name|tparm_proto
argument_list|(
argument|NCURSES_CONST char *string
argument_list|,
argument|TPARM_ARG a1
argument_list|,
argument|TPARM_ARG a2
argument_list|,
argument|TPARM_ARG a3
argument_list|,
argument|TPARM_ARG a4
argument_list|,
argument|TPARM_ARG a5
argument_list|,
argument|TPARM_ARG a6
argument_list|,
argument|TPARM_ARG a7
argument_list|,
argument|TPARM_ARG a8
argument_list|,
argument|TPARM_ARG a9
argument_list|)
end_macro

begin_block
block|{
return|return
name|tparm_varargs
argument_list|(
name|string
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|,
name|a8
argument_list|,
name|a9
argument_list|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NCURSES_TPARM_VARARGS */
end_comment

end_unit

