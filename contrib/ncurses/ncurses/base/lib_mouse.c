begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************************  * Copyright (c) 1998,1999,2000 Free Software Foundation, Inc.              *  *                                                                          *  * Permission is hereby granted, free of charge, to any person obtaining a  *  * copy of this software and associated documentation files (the            *  * "Software"), to deal in the Software without restriction, including      *  * without limitation the rights to use, copy, modify, merge, publish,      *  * distribute, distribute with modifications, sublicense, and/or sell       *  * copies of the Software, and to permit persons to whom the Software is    *  * furnished to do so, subject to the following conditions:                 *  *                                                                          *  * The above copyright notice and this permission notice shall be included  *  * in all copies or substantial portions of the Software.                   *  *                                                                          *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *  * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *  * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *  *                                                                          *  * Except as contained in this notice, the name(s) of the above copyright   *  * holders shall not be used in advertising or otherwise to promote the     *  * sale, use or other dealings in this Software without prior written       *  * authorization.                                                           *  ****************************************************************************/
end_comment

begin_comment
comment|/****************************************************************************  *  Author: Zeyd M. Ben-Halim<zmbenhal@netcom.com> 1992,1995               *  *     and: Eric S. Raymond<esr@snark.thyrsus.com>                         *  ****************************************************************************/
end_comment

begin_comment
comment|/*  * This module is intended to encapsulate ncurses's interface to pointing  * devices.  *  * The first method used is xterm's internal mouse-tracking facility.  * The second is Alessandro Rubini's GPM server.  *  * Notes for implementors of new mouse-interface methods:  *  * The code is logically split into a lower level that accepts event reports  * in a device-dependent format and an upper level that parses mouse gestures  * and filters events.  The mediating data structure is a circular queue of  * MEVENT structures.  *  * Functionally, the lower level's job is to pick up primitive events and  * put them on the circular queue.  This can happen in one of two ways:  * either (a) _nc_mouse_event() detects a series of incoming mouse reports  * and queues them, or (b) code in lib_getch.c detects the kmous prefix in  * the keyboard input stream and calls _nc_mouse_inline to queue up a series  * of adjacent mouse reports.  *  * In either case, _nc_mouse_parse() should be called after the series is  * accepted to parse the digested mouse reports (low-level MEVENTs) into  * a gesture (a high-level or composite MEVENT).  *  * Don't be too shy about adding new event types or modifiers, if you can find  * room for them in the 32-bit mask.  The API is written so that users get  * feedback on which theoretical event types they won't see when they call  * mousemask. There's one bit per button (the RESERVED_EVENT bit) not being  * used yet, and a couple of bits open at the high end.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__EMX__
end_ifdef

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_define
define|#
directive|define
name|INCL_DOS
end_define

begin_define
define|#
directive|define
name|INCL_VIO
end_define

begin_define
define|#
directive|define
name|INCL_KBD
end_define

begin_define
define|#
directive|define
name|INCL_MOU
end_define

begin_define
define|#
directive|define
name|INCL_DOSPROCESS
end_define

begin_include
include|#
directive|include
file|<os2.h>
end_include

begin_comment
comment|/* Need to include before the others */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<curses.priv.h>
end_include

begin_include
include|#
directive|include
file|<term.h>
end_include

begin_if
if|#
directive|if
name|USE_GPM_SUPPORT
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|LINT
end_ifndef

begin_comment
comment|/* don't need this for llib-lncurses */
end_comment

begin_undef
undef|#
directive|undef
name|buttons
end_undef

begin_comment
comment|/* term.h defines this, and gpm uses it! */
end_comment

begin_include
include|#
directive|include
file|<gpm.h>
end_include

begin_include
include|#
directive|include
file|<linux/keyboard.h>
end_include

begin_comment
comment|/* defines KG_* macros */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|MODULE_ID
argument_list|(
literal|"$Id: lib_mouse.c,v 1.55 2000/10/10 00:07:28 Ilya.Zakharevich Exp $"
argument_list|)
end_macro

begin_define
define|#
directive|define
name|MY_TRACE
value|TRACE_ICALLS|TRACE_IEVENT
end_define

begin_define
define|#
directive|define
name|INVALID_EVENT
value|-1
end_define

begin_decl_stmt
specifier|static
name|int
name|mousetype
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|M_XTERM
value|-1
end_define

begin_comment
comment|/* use xterm's mouse tracking? */
end_comment

begin_define
define|#
directive|define
name|M_NONE
value|0
end_define

begin_comment
comment|/* no mouse device */
end_comment

begin_define
define|#
directive|define
name|M_GPM
value|1
end_define

begin_comment
comment|/* use GPM */
end_comment

begin_define
define|#
directive|define
name|M_QNX
value|2
end_define

begin_comment
comment|/* QNX mouse on console */
end_comment

begin_define
define|#
directive|define
name|M_QNX_TERM
value|3
end_define

begin_comment
comment|/* QNX mouse on pterm/xterm (using qansi-m) */
end_comment

begin_if
if|#
directive|if
name|USE_GPM_SUPPORT
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|LINT
end_ifndef

begin_decl_stmt
specifier|static
name|Gpm_Connect
name|gpm_connect
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|mmask_t
name|eventmask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current event mask */
end_comment

begin_function_decl
specifier|static
name|bool
name|_nc_mouse_parse
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_nc_mouse_resume
parameter_list|(
name|SCREEN
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_nc_mouse_wrap
parameter_list|(
name|SCREEN
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* maintain a circular list of mouse events */
end_comment

begin_comment
comment|/* The definition of the circular list size (EV_MAX), is in curses.priv.h, so  * wgetch() may refer to the size and call _nc_mouse_parse() before circular  * list overflow.  */
end_comment

begin_decl_stmt
specifier|static
name|MEVENT
name|events
index|[
name|EV_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hold the last mouse event seen */
end_comment

begin_decl_stmt
specifier|static
name|MEVENT
modifier|*
name|eventp
init|=
name|events
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* next free slot in event queue */
end_comment

begin_define
define|#
directive|define
name|NEXT
parameter_list|(
name|ep
parameter_list|)
value|((ep == events + EV_MAX - 1) ? events : ep + 1)
end_define

begin_define
define|#
directive|define
name|PREV
parameter_list|(
name|ep
parameter_list|)
value|((ep == events) ? events + EV_MAX - 1 : ep - 1)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|TRACE
end_ifdef

begin_function
specifier|static
name|void
name|_trace_slot
parameter_list|(
specifier|const
name|char
modifier|*
name|tag
parameter_list|)
block|{
name|MEVENT
modifier|*
name|ep
decl_stmt|;
name|_tracef
argument_list|(
name|tag
argument_list|)
expr_stmt|;
for|for
control|(
name|ep
operator|=
name|events
init|;
name|ep
operator|<
name|events
operator|+
name|EV_MAX
condition|;
name|ep
operator|++
control|)
name|_tracef
argument_list|(
literal|"mouse event queue slot %ld = %s"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|ep
operator|-
name|events
argument_list|)
argument_list|,
name|_tracemouse
argument_list|(
name|ep
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USE_EMX_MOUSE
end_ifdef

begin_define
define|#
directive|define
name|TOP_ROW
value|0
end_define

begin_define
define|#
directive|define
name|LEFT_COL
value|0
end_define

begin_decl_stmt
specifier|static
name|int
name|mouse_wfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mouse_thread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mouse_activated
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|mouse_buttons
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|2
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|M_FD
parameter_list|(
name|sp
parameter_list|)
value|sp->_mouse_fd
end_define

begin_function
specifier|static
name|void
name|write_event
parameter_list|(
name|int
name|down
parameter_list|,
name|int
name|button
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
name|char
name|buf
index|[
literal|6
index|]
decl_stmt|;
name|unsigned
name|long
name|ignore
decl_stmt|;
name|strncpy
argument_list|(
name|buf
argument_list|,
name|key_mouse
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* should be "\033[M" */
name|buf
index|[
literal|3
index|]
operator|=
literal|' '
operator|+
operator|(
name|button
operator|-
literal|1
operator|)
operator|+
operator|(
name|down
condition|?
literal|0
else|:
literal|0x40
operator|)
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
literal|' '
operator|+
name|x
operator|-
name|LEFT_COL
operator|+
literal|1
expr_stmt|;
name|buf
index|[
literal|5
index|]
operator|=
literal|' '
operator|+
name|y
operator|-
name|TOP_ROW
operator|+
literal|1
expr_stmt|;
name|DosWrite
argument_list|(
name|mouse_wfd
argument_list|,
name|buf
argument_list|,
literal|6
argument_list|,
operator|&
name|ignore
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mouse_server
parameter_list|(
name|unsigned
name|long
name|ignored
name|GCC_UNUSED
parameter_list|)
block|{
name|unsigned
name|short
name|fWait
init|=
name|MOU_WAIT
decl_stmt|;
comment|/* NOPTRRECT mourt = { 0,0,24,79 }; */
name|MOUEVENTINFO
name|mouev
decl_stmt|;
name|HMOU
name|hmou
decl_stmt|;
name|unsigned
name|short
name|mask
init|=
name|MOUSE_BN1_DOWN
operator||
name|MOUSE_BN2_DOWN
operator||
name|MOUSE_BN3_DOWN
decl_stmt|;
name|int
name|nbuttons
init|=
literal|3
decl_stmt|;
name|int
name|oldstate
init|=
literal|0
decl_stmt|;
name|char
name|err
index|[
literal|80
index|]
decl_stmt|;
name|unsigned
name|long
name|rc
decl_stmt|;
comment|/* open the handle for the mouse */
if|if
condition|(
name|MouOpen
argument_list|(
name|NULL
argument_list|,
operator|&
name|hmou
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rc
operator|=
name|MouSetEventMask
argument_list|(
operator|&
name|mask
argument_list|,
name|hmou
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
comment|/* retry with 2 buttons */
name|mask
operator|=
name|MOUSE_BN1_DOWN
operator||
name|MOUSE_BN2_DOWN
expr_stmt|;
name|rc
operator|=
name|MouSetEventMask
argument_list|(
operator|&
name|mask
argument_list|,
name|hmou
argument_list|)
expr_stmt|;
name|nbuttons
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|==
literal|0
operator|&&
name|MouDrawPtr
argument_list|(
name|hmou
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* sit and wait on the event queue */
name|rc
operator|=
name|MouReadEventQue
argument_list|(
operator|&
name|mouev
argument_list|,
operator|&
name|fWait
argument_list|,
name|hmou
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|sprintf
argument_list|(
name|err
argument_list|,
literal|"Error reading mouse queue, rc=%lu.\r\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|mouse_activated
condition|)
goto|goto
name|finish
goto|;
comment|/* 		 * OS/2 numbers a 3-button mouse inconsistently from other 		 * platforms: 		 *      1 = left 		 *      2 = right 		 *      3 = middle. 		 */
if|if
condition|(
operator|(
name|mouev
operator|.
name|fs
operator|^
name|oldstate
operator|)
operator|&
name|MOUSE_BN1_DOWN
condition|)
name|write_event
argument_list|(
name|mouev
operator|.
name|fs
operator|&
name|MOUSE_BN1_DOWN
argument_list|,
name|mouse_buttons
index|[
literal|1
index|]
argument_list|,
name|mouev
operator|.
name|col
argument_list|,
name|mouev
operator|.
name|row
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mouev
operator|.
name|fs
operator|^
name|oldstate
operator|)
operator|&
name|MOUSE_BN2_DOWN
condition|)
name|write_event
argument_list|(
name|mouev
operator|.
name|fs
operator|&
name|MOUSE_BN2_DOWN
argument_list|,
name|mouse_buttons
index|[
literal|3
index|]
argument_list|,
name|mouev
operator|.
name|col
argument_list|,
name|mouev
operator|.
name|row
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mouev
operator|.
name|fs
operator|^
name|oldstate
operator|)
operator|&
name|MOUSE_BN3_DOWN
condition|)
name|write_event
argument_list|(
name|mouev
operator|.
name|fs
operator|&
name|MOUSE_BN3_DOWN
argument_list|,
name|mouse_buttons
index|[
literal|2
index|]
argument_list|,
name|mouev
operator|.
name|col
argument_list|,
name|mouev
operator|.
name|row
argument_list|)
expr_stmt|;
name|finish
label|:
name|oldstate
operator|=
name|mouev
operator|.
name|fs
expr_stmt|;
block|}
block|}
else|else
name|sprintf
argument_list|(
name|err
argument_list|,
literal|"Error setting event mask, buttons=%d, rc=%lu.\r\n"
argument_list|,
name|nbuttons
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|DosWrite
argument_list|(
literal|2
argument_list|,
name|err
argument_list|,
name|strlen
argument_list|(
name|err
argument_list|)
argument_list|,
operator|&
name|rc
argument_list|)
expr_stmt|;
name|MouClose
argument_list|(
name|hmou
argument_list|)
expr_stmt|;
block|}
name|DosExit
argument_list|(
name|EXIT_THREAD
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|server_state
parameter_list|(
specifier|const
name|int
name|state
parameter_list|)
block|{
comment|/* It would be nice to implement pointer-off and stop looping... */
name|mouse_activated
operator|=
name|state
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|initialized
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|initialize_mousetype
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|xterm_kmous
init|=
literal|"\033[M"
decl_stmt|;
comment|/* Try gpm first, because gpm may be configured to run in xterm */
if|#
directive|if
name|USE_GPM_SUPPORT
comment|/* GPM: initialize connection to gpm server */
name|gpm_connect
operator|.
name|eventMask
operator|=
name|GPM_DOWN
operator||
name|GPM_UP
expr_stmt|;
name|gpm_connect
operator|.
name|defaultMask
operator|=
operator|~
operator|(
name|gpm_connect
operator|.
name|eventMask
operator||
name|GPM_HARD
operator|)
expr_stmt|;
name|gpm_connect
operator|.
name|minMod
operator|=
literal|0
expr_stmt|;
name|gpm_connect
operator|.
name|maxMod
operator|=
operator|~
operator|(
operator|(
literal|1
operator|<<
name|KG_SHIFT
operator|)
operator||
operator|(
literal|1
operator|<<
name|KG_SHIFTL
operator|)
operator||
operator|(
literal|1
operator|<<
name|KG_SHIFTR
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|Gpm_Open
argument_list|(
operator|&
name|gpm_connect
argument_list|,
literal|0
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* returns the file-descriptor */
name|mousetype
operator|=
name|M_GPM
expr_stmt|;
name|SP
operator|->
name|_mouse_fd
operator|=
name|gpm_fd
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* OS/2 VIO */
ifdef|#
directive|ifdef
name|USE_EMX_MOUSE
if|if
condition|(
operator|!
name|mouse_thread
operator|&&
name|strstr
argument_list|(
name|cur_term
operator|->
name|type
operator|.
name|term_names
argument_list|,
literal|"xterm"
argument_list|)
operator|==
literal|0
operator|&&
name|key_mouse
condition|)
block|{
name|int
name|handles
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|handles
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"mouse pipe error"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|int
name|rc
decl_stmt|;
if|if
condition|(
operator|!
name|mouse_buttons
index|[
literal|0
index|]
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|getenv
argument_list|(
literal|"MOUSE_BUTTONS_123"
argument_list|)
decl_stmt|;
name|mouse_buttons
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|s
operator|&&
name|strlen
argument_list|(
name|s
argument_list|)
operator|>=
literal|3
condition|)
block|{
name|mouse_buttons
index|[
literal|1
index|]
operator|=
name|s
index|[
literal|0
index|]
operator|-
literal|'0'
expr_stmt|;
name|mouse_buttons
index|[
literal|2
index|]
operator|=
name|s
index|[
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
name|mouse_buttons
index|[
literal|3
index|]
operator|=
name|s
index|[
literal|2
index|]
operator|-
literal|'0'
expr_stmt|;
block|}
block|}
name|mouse_wfd
operator|=
name|handles
index|[
literal|1
index|]
expr_stmt|;
name|M_FD
argument_list|(
name|SP
argument_list|)
operator|=
name|handles
index|[
literal|0
index|]
expr_stmt|;
comment|/* Needed? */
name|setmode
argument_list|(
name|handles
index|[
literal|0
index|]
argument_list|,
name|O_BINARY
argument_list|)
expr_stmt|;
name|setmode
argument_list|(
name|handles
index|[
literal|1
index|]
argument_list|,
name|O_BINARY
argument_list|)
expr_stmt|;
comment|/* Do not use CRT functions, we may single-threaded. */
name|rc
operator|=
name|DosCreateThread
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|&
name|mouse_thread
argument_list|,
name|mouse_server
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8192
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|printf
argument_list|(
literal|"mouse thread error %d=%#x"
argument_list|,
name|rc
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|mousetype
operator|=
name|M_XTERM
expr_stmt|;
return|return;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* we know how to recognize mouse events under "xterm" */
if|if
condition|(
name|key_mouse
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|key_mouse
argument_list|,
name|xterm_kmous
argument_list|)
condition|)
block|{
name|mousetype
operator|=
name|M_XTERM
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|cur_term
operator|->
name|type
operator|.
name|term_names
argument_list|,
literal|"xterm"
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|_nc_add_to_try
argument_list|(
operator|&
operator|(
name|SP
operator|->
name|_keytry
operator|)
argument_list|,
name|xterm_kmous
argument_list|,
name|KEY_MOUSE
argument_list|)
expr_stmt|;
name|mousetype
operator|=
name|M_XTERM
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|_nc_mouse_init
parameter_list|(
name|void
parameter_list|)
comment|/* initialize the mouse */
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|initialized
operator|=
name|TRUE
expr_stmt|;
name|TR
argument_list|(
name|MY_TRACE
argument_list|,
operator|(
literal|"_nc_mouse_init() called"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EV_MAX
condition|;
name|i
operator|++
control|)
name|events
index|[
name|i
index|]
operator|.
name|id
operator|=
name|INVALID_EVENT
expr_stmt|;
name|initialize_mousetype
argument_list|()
expr_stmt|;
name|T
argument_list|(
operator|(
literal|"_nc_mouse_init() set mousetype to %d"
operator|,
name|mousetype
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|_nc_mouse_event
parameter_list|(
name|SCREEN
modifier|*
name|sp
name|GCC_UNUSED
parameter_list|)
comment|/* query to see if there is a pending mouse event */
block|{
if|#
directive|if
name|USE_GPM_SUPPORT
comment|/* GPM: query server for event, return TRUE if we find one */
name|Gpm_Event
name|ev
decl_stmt|;
if|if
condition|(
name|gpm_fd
operator|>=
literal|0
operator|&&
operator|(
name|_nc_timed_wait
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|&
literal|2
operator|)
operator|!=
literal|0
operator|&&
name|Gpm_GetEvent
argument_list|(
operator|&
name|ev
argument_list|)
operator|==
literal|1
condition|)
block|{
name|eventp
operator|->
name|id
operator|=
literal|0
expr_stmt|;
comment|/* there's only one mouse... */
name|eventp
operator|->
name|bstate
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|ev
operator|.
name|type
operator|&
literal|0x0f
condition|)
block|{
case|case
operator|(
name|GPM_DOWN
operator|)
case|:
if|if
condition|(
name|ev
operator|.
name|buttons
operator|&
name|GPM_B_LEFT
condition|)
name|eventp
operator|->
name|bstate
operator||=
name|BUTTON1_PRESSED
expr_stmt|;
if|if
condition|(
name|ev
operator|.
name|buttons
operator|&
name|GPM_B_MIDDLE
condition|)
name|eventp
operator|->
name|bstate
operator||=
name|BUTTON2_PRESSED
expr_stmt|;
if|if
condition|(
name|ev
operator|.
name|buttons
operator|&
name|GPM_B_RIGHT
condition|)
name|eventp
operator|->
name|bstate
operator||=
name|BUTTON3_PRESSED
expr_stmt|;
break|break;
case|case
operator|(
name|GPM_UP
operator|)
case|:
if|if
condition|(
name|ev
operator|.
name|buttons
operator|&
name|GPM_B_LEFT
condition|)
name|eventp
operator|->
name|bstate
operator||=
name|BUTTON1_RELEASED
expr_stmt|;
if|if
condition|(
name|ev
operator|.
name|buttons
operator|&
name|GPM_B_MIDDLE
condition|)
name|eventp
operator|->
name|bstate
operator||=
name|BUTTON2_RELEASED
expr_stmt|;
if|if
condition|(
name|ev
operator|.
name|buttons
operator|&
name|GPM_B_RIGHT
condition|)
name|eventp
operator|->
name|bstate
operator||=
name|BUTTON3_RELEASED
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|eventp
operator|->
name|x
operator|=
name|ev
operator|.
name|x
operator|-
literal|1
expr_stmt|;
name|eventp
operator|->
name|y
operator|=
name|ev
operator|.
name|y
operator|-
literal|1
expr_stmt|;
name|eventp
operator|->
name|z
operator|=
literal|0
expr_stmt|;
comment|/* bump the next-free pointer into the circular list */
name|eventp
operator|=
name|NEXT
argument_list|(
name|eventp
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_EMX_MOUSE
if|if
condition|(
name|SP
operator|->
name|_mouse_fd
operator|>=
literal|0
operator|&&
operator|(
name|_nc_timed_wait
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|&
literal|2
operator|)
operator|!=
literal|0
condition|)
block|{
name|char
name|kbuf
index|[
literal|3
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|res
init|=
name|read
argument_list|(
name|M_FD
argument_list|(
name|sp
argument_list|)
argument_list|,
operator|&
name|kbuf
argument_list|,
literal|3
argument_list|)
decl_stmt|;
comment|/* Eat the prefix */
if|if
condition|(
name|res
operator|!=
literal|3
condition|)
name|printf
argument_list|(
literal|"Got %d chars instead of 3 for prefix.\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|res
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|kbuf
index|[
name|i
index|]
operator|!=
name|key_mouse
index|[
name|i
index|]
condition|)
name|printf
argument_list|(
literal|"Got char %d instead of %d for prefix.\n"
argument_list|,
operator|(
name|int
operator|)
name|kbuf
index|[
name|i
index|]
argument_list|,
operator|(
name|int
operator|)
name|key_mouse
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
endif|#
directive|endif
comment|/* USE_EMX_MOUSE */
comment|/* xterm: never have to query, mouse events are in the keyboard stream */
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* no event waiting */
block|}
end_function

begin_function
specifier|static
name|bool
name|_nc_mouse_inline
parameter_list|(
name|SCREEN
modifier|*
name|sp
parameter_list|)
comment|/* mouse report received in the keyboard stream -- parse its info */
block|{
name|TR
argument_list|(
name|MY_TRACE
argument_list|,
operator|(
literal|"_nc_mouse_inline() called"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mousetype
operator|==
name|M_XTERM
condition|)
block|{
name|unsigned
name|char
name|kbuf
index|[
literal|4
index|]
decl_stmt|;
name|MEVENT
modifier|*
name|prev
decl_stmt|;
name|size_t
name|grabbed
decl_stmt|;
name|int
name|res
decl_stmt|;
comment|/* This code requires that your xterm entry contain the kmous 	 * capability and that it be set to the \E[M documented in the 	 * Xterm Control Sequences reference.  This is how we 	 * arrange for mouse events to be reported via a KEY_MOUSE 	 * return value from wgetch().  After this value is received, 	 * _nc_mouse_inline() gets called and is immediately 	 * responsible for parsing the mouse status information 	 * following the prefix. 	 * 	 * The following quotes from the ctrlseqs.ms document in the 	 * X distribution, describing the X mouse tracking feature: 	 * 	 * Parameters for all mouse tracking escape sequences 	 * generated by xterm encode numeric parameters in a single 	 * character as value+040.  For example, !  is 1. 	 * 	 * On button press or release, xterm sends ESC [ M CbCxCy. 	 * The low two bits of Cb encode button information: 0=MB1 	 * pressed, 1=MB2 pressed, 2=MB3 pressed, 3=release.  The 	 * upper bits encode what modifiers were down when the 	 * button was pressed and are added together.  4=Shift, 	 * 8=Meta, 16=Control.  Cx and Cy are the x and y coordinates 	 * of the mouse event.  The upper left corner is (1,1). 	 * 	 * (End quote)  By the time we get here, we've eaten the 	 * key prefix.  FYI, the loop below is necessary because 	 * mouse click info isn't guaranteed to present as a 	 * single clist item.  It always does under Linux but often 	 * fails to under Solaris. 	 */
for|for
control|(
name|grabbed
operator|=
literal|0
init|;
name|grabbed
operator|<
literal|3
condition|;
name|grabbed
operator|+=
name|res
control|)
block|{
comment|/* For VIO mouse we add extra bit 64 to disambiguate button-up. */
ifdef|#
directive|ifdef
name|USE_EMX_MOUSE
name|res
operator|=
name|read
argument_list|(
name|M_FD
argument_list|(
name|sp
argument_list|)
operator|>=
literal|0
condition|?
name|M_FD
argument_list|(
name|sp
argument_list|)
else|:
name|sp
operator|->
name|_ifd
argument_list|,
operator|&
name|kbuf
argument_list|,
literal|3
argument_list|)
expr_stmt|;
else|#
directive|else
name|res
operator|=
name|read
argument_list|(
name|sp
operator|->
name|_ifd
argument_list|,
name|kbuf
operator|+
name|grabbed
argument_list|,
literal|3
operator|-
name|grabbed
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|res
operator|==
operator|-
literal|1
condition|)
break|break;
block|}
name|kbuf
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|TR
argument_list|(
name|TRACE_IEVENT
argument_list|,
operator|(
literal|"_nc_mouse_inline sees the following xterm data: '%s'"
operator|,
name|kbuf
operator|)
argument_list|)
expr_stmt|;
name|eventp
operator|->
name|id
operator|=
literal|0
expr_stmt|;
comment|/* there's only one mouse... */
comment|/* processing code goes here */
name|eventp
operator|->
name|bstate
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|kbuf
index|[
literal|0
index|]
operator|&
literal|0x3
condition|)
block|{
case|case
literal|0x0
case|:
name|eventp
operator|->
name|bstate
operator|=
name|BUTTON1_PRESSED
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_EMX_MOUSE
if|if
condition|(
name|kbuf
index|[
literal|0
index|]
operator|&
literal|0x40
condition|)
name|eventp
operator|->
name|bstate
operator|=
name|BUTTON1_RELEASED
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|0x1
case|:
name|eventp
operator|->
name|bstate
operator|=
name|BUTTON2_PRESSED
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_EMX_MOUSE
if|if
condition|(
name|kbuf
index|[
literal|0
index|]
operator|&
literal|0x40
condition|)
name|eventp
operator|->
name|bstate
operator|=
name|BUTTON2_RELEASED
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|0x2
case|:
name|eventp
operator|->
name|bstate
operator|=
name|BUTTON3_PRESSED
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_EMX_MOUSE
if|if
condition|(
name|kbuf
index|[
literal|0
index|]
operator|&
literal|0x40
condition|)
name|eventp
operator|->
name|bstate
operator|=
name|BUTTON3_RELEASED
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|0x3
case|:
comment|/* 	     * Release events aren't reported for individual buttons, 	     * just for the button set as a whole... 	     */
name|eventp
operator|->
name|bstate
operator|=
operator|(
name|BUTTON1_RELEASED
operator||
name|BUTTON2_RELEASED
operator||
name|BUTTON3_RELEASED
operator|)
expr_stmt|;
comment|/* 	     * ...however, because there are no kinds of mouse events under 	     * xterm that can intervene between press and release, we can 	     * deduce which buttons were actually released by looking at the 	     * previous event. 	     */
name|prev
operator|=
name|PREV
argument_list|(
name|eventp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|prev
operator|->
name|bstate
operator|&
name|BUTTON1_PRESSED
operator|)
condition|)
name|eventp
operator|->
name|bstate
operator|&=
operator|~
name|BUTTON1_RELEASED
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|prev
operator|->
name|bstate
operator|&
name|BUTTON2_PRESSED
operator|)
condition|)
name|eventp
operator|->
name|bstate
operator|&=
operator|~
name|BUTTON2_RELEASED
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|prev
operator|->
name|bstate
operator|&
name|BUTTON3_PRESSED
operator|)
condition|)
name|eventp
operator|->
name|bstate
operator|&=
operator|~
name|BUTTON3_RELEASED
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|kbuf
index|[
literal|0
index|]
operator|&
literal|4
condition|)
block|{
name|eventp
operator|->
name|bstate
operator||=
name|BUTTON_SHIFT
expr_stmt|;
block|}
if|if
condition|(
name|kbuf
index|[
literal|0
index|]
operator|&
literal|8
condition|)
block|{
name|eventp
operator|->
name|bstate
operator||=
name|BUTTON_ALT
expr_stmt|;
block|}
if|if
condition|(
name|kbuf
index|[
literal|0
index|]
operator|&
literal|16
condition|)
block|{
name|eventp
operator|->
name|bstate
operator||=
name|BUTTON_CTRL
expr_stmt|;
block|}
name|eventp
operator|->
name|x
operator|=
operator|(
name|kbuf
index|[
literal|1
index|]
operator|-
literal|' '
operator|)
operator|-
literal|1
expr_stmt|;
name|eventp
operator|->
name|y
operator|=
operator|(
name|kbuf
index|[
literal|2
index|]
operator|-
literal|' '
operator|)
operator|-
literal|1
expr_stmt|;
name|TR
argument_list|(
name|MY_TRACE
argument_list|,
operator|(
literal|"_nc_mouse_inline: primitive mouse-event %s has slot %ld"
operator|,
name|_tracemouse
argument_list|(
name|eventp
argument_list|)
operator|,
call|(
name|long
call|)
argument_list|(
name|eventp
operator|-
name|events
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* bump the next-free pointer into the circular list */
name|eventp
operator|=
name|NEXT
argument_list|(
name|eventp
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* this return would be needed for QNX's mods to lib_getch.c */
block|return (TRUE);
endif|#
directive|endif
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mouse_activate
parameter_list|(
name|bool
name|on
parameter_list|)
block|{
if|if
condition|(
operator|!
name|on
operator|&&
operator|!
name|initialized
condition|)
return|return;
name|_nc_mouse_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|on
condition|)
block|{
switch|switch
condition|(
name|mousetype
condition|)
block|{
case|case
name|M_XTERM
case|:
if|#
directive|if
name|NCURSES_EXT_FUNCS
name|keyok
argument_list|(
name|KEY_MOUSE
argument_list|,
name|on
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TPUTS_TRACE
argument_list|(
literal|"xterm mouse initialization"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_EMX_MOUSE
name|server_state
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|putp
argument_list|(
literal|"\033[?1000h"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
if|#
directive|if
name|USE_GPM_SUPPORT
case|case
name|M_GPM
case|:
name|SP
operator|->
name|_mouse_fd
operator|=
name|gpm_fd
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
comment|/* Make runtime binding to cut down on object size of applications that 	 * do not use the mouse (e.g., 'clear'). 	 */
name|SP
operator|->
name|_mouse_event
operator|=
name|_nc_mouse_event
expr_stmt|;
name|SP
operator|->
name|_mouse_inline
operator|=
name|_nc_mouse_inline
expr_stmt|;
name|SP
operator|->
name|_mouse_parse
operator|=
name|_nc_mouse_parse
expr_stmt|;
name|SP
operator|->
name|_mouse_resume
operator|=
name|_nc_mouse_resume
expr_stmt|;
name|SP
operator|->
name|_mouse_wrap
operator|=
name|_nc_mouse_wrap
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|mousetype
condition|)
block|{
case|case
name|M_XTERM
case|:
name|TPUTS_TRACE
argument_list|(
literal|"xterm mouse deinitialization"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_EMX_MOUSE
name|server_state
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|putp
argument_list|(
literal|"\033[?1000l"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
if|#
directive|if
name|USE_GPM_SUPPORT
case|case
name|M_GPM
case|:
break|break;
endif|#
directive|endif
block|}
block|}
name|_nc_flush
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************************  *  * Device-independent code  *  **************************************************************************/
end_comment

begin_function
specifier|static
name|bool
name|_nc_mouse_parse
parameter_list|(
name|int
name|runcount
parameter_list|)
comment|/* parse a run of atomic mouse events into a gesture */
block|{
name|MEVENT
modifier|*
name|ep
decl_stmt|,
modifier|*
name|runp
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
init|=
name|PREV
argument_list|(
name|eventp
argument_list|)
decl_stmt|;
name|int
name|n
decl_stmt|;
name|bool
name|merge
decl_stmt|;
name|TR
argument_list|(
name|MY_TRACE
argument_list|,
operator|(
literal|"_nc_mouse_parse(%d) called"
operator|,
name|runcount
operator|)
argument_list|)
expr_stmt|;
comment|/*      * When we enter this routine, the event list next-free pointer      * points just past a run of mouse events that we know were separated      * in time by less than the critical click interval. The job of this      * routine is to collaps this run into a single higher-level event      * or gesture.      *      * We accomplish this in two passes.  The first pass merges press/release      * pairs into click events.  The second merges runs of click events into      * double or triple-click events.      *      * It's possible that the run may not resolve to a single event (for      * example, if the user quadruple-clicks).  If so, leading events      * in the run are ignored.      *      * Note that this routine is independent of the format of the specific      * format of the pointing-device's reports.  We can use it to parse      * gestures on anything that reports press/release events on a per-      * button basis, as long as the device-dependent mouse code puts stuff      * on the queue in MEVENT format.      */
if|if
condition|(
name|runcount
operator|==
literal|1
condition|)
block|{
name|TR
argument_list|(
name|MY_TRACE
argument_list|,
operator|(
literal|"_nc_mouse_parse: returning simple mouse event %s at slot %ld"
operator|,
name|_tracemouse
argument_list|(
name|prev
argument_list|)
operator|,
call|(
name|long
call|)
argument_list|(
name|prev
operator|-
name|events
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|prev
operator|->
name|id
operator|>=
literal|0
operator|)
condition|?
operator|(
operator|(
name|prev
operator|->
name|bstate
operator|&
name|eventmask
operator|)
condition|?
name|TRUE
else|:
name|FALSE
operator|)
else|:
name|FALSE
return|;
block|}
comment|/* find the start of the run */
name|runp
operator|=
name|eventp
expr_stmt|;
for|for
control|(
name|n
operator|=
name|runcount
init|;
name|n
operator|>
literal|0
condition|;
name|n
operator|--
control|)
block|{
name|runp
operator|=
name|PREV
argument_list|(
name|runp
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|_nc_tracing
operator|&
name|TRACE_IEVENT
condition|)
block|{
name|_trace_slot
argument_list|(
literal|"before mouse press/release merge:"
argument_list|)
expr_stmt|;
name|_tracef
argument_list|(
literal|"_nc_mouse_parse: run starts at %ld, ends at %ld, count %d"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|runp
operator|-
name|events
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|(
name|eventp
operator|-
name|events
operator|)
operator|+
operator|(
name|EV_MAX
operator|-
literal|1
operator|)
argument_list|)
operator|%
name|EV_MAX
argument_list|,
name|runcount
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TRACE */
comment|/* first pass; merge press/release pairs */
do|do
block|{
name|merge
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|ep
operator|=
name|runp
init|;
name|next
operator|=
name|NEXT
argument_list|(
name|ep
argument_list|)
operator|,
name|next
operator|!=
name|eventp
condition|;
name|ep
operator|=
name|next
control|)
block|{
if|if
condition|(
name|ep
operator|->
name|x
operator|==
name|next
operator|->
name|x
operator|&&
name|ep
operator|->
name|y
operator|==
name|next
operator|->
name|y
operator|&&
operator|(
name|ep
operator|->
name|bstate
operator|&
operator|(
name|BUTTON1_PRESSED
operator||
name|BUTTON2_PRESSED
operator||
name|BUTTON3_PRESSED
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|ep
operator|->
name|bstate
operator|&
name|BUTTON1_PRESSED
operator|)
operator|==
operator|!
operator|(
name|next
operator|->
name|bstate
operator|&
name|BUTTON1_RELEASED
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|ep
operator|->
name|bstate
operator|&
name|BUTTON2_PRESSED
operator|)
operator|==
operator|!
operator|(
name|next
operator|->
name|bstate
operator|&
name|BUTTON2_RELEASED
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|ep
operator|->
name|bstate
operator|&
name|BUTTON3_PRESSED
operator|)
operator|==
operator|!
operator|(
name|next
operator|->
name|bstate
operator|&
name|BUTTON3_RELEASED
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|eventmask
operator|&
name|BUTTON1_CLICKED
operator|)
operator|&&
operator|(
name|ep
operator|->
name|bstate
operator|&
name|BUTTON1_PRESSED
operator|)
condition|)
block|{
name|ep
operator|->
name|bstate
operator|&=
operator|~
name|BUTTON1_PRESSED
expr_stmt|;
name|ep
operator|->
name|bstate
operator||=
name|BUTTON1_CLICKED
expr_stmt|;
name|merge
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|eventmask
operator|&
name|BUTTON2_CLICKED
operator|)
operator|&&
operator|(
name|ep
operator|->
name|bstate
operator|&
name|BUTTON2_PRESSED
operator|)
condition|)
block|{
name|ep
operator|->
name|bstate
operator|&=
operator|~
name|BUTTON2_PRESSED
expr_stmt|;
name|ep
operator|->
name|bstate
operator||=
name|BUTTON2_CLICKED
expr_stmt|;
name|merge
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|eventmask
operator|&
name|BUTTON3_CLICKED
operator|)
operator|&&
operator|(
name|ep
operator|->
name|bstate
operator|&
name|BUTTON3_PRESSED
operator|)
condition|)
block|{
name|ep
operator|->
name|bstate
operator|&=
operator|~
name|BUTTON3_PRESSED
expr_stmt|;
name|ep
operator|->
name|bstate
operator||=
name|BUTTON3_CLICKED
expr_stmt|;
name|merge
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|merge
condition|)
name|next
operator|->
name|id
operator|=
name|INVALID_EVENT
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|merge
condition|)
do|;
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|_nc_tracing
operator|&
name|TRACE_IEVENT
condition|)
block|{
name|_trace_slot
argument_list|(
literal|"before mouse click merge:"
argument_list|)
expr_stmt|;
name|_tracef
argument_list|(
literal|"_nc_mouse_parse: run starts at %ld, ends at %ld, count %d"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|runp
operator|-
name|events
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|(
name|eventp
operator|-
name|events
operator|)
operator|+
operator|(
name|EV_MAX
operator|-
literal|1
operator|)
argument_list|)
operator|%
name|EV_MAX
argument_list|,
name|runcount
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TRACE */
comment|/*      * Second pass; merge click runs.  At this point, click events are      * each followed by one invalid event. We merge click events      * forward in the queue.      *      * NOTE: There is a problem with this design!  If the application      * allows enough click events to pile up in the circular queue so      * they wrap around, it will cheerfully merge the newest forward      * into the oldest, creating a bogus doubleclick and confusing      * the queue-traversal logic rather badly.  Generally this won't      * happen, because calling getmouse() marks old events invalid and      * ineligible for merges.  The true solution to this problem would      * be to timestamp each MEVENT and perform the obvious sanity check,      * but the timer element would have to have sub-second resolution,      * which would get us into portability trouble.      */
do|do
block|{
name|MEVENT
modifier|*
name|follower
decl_stmt|;
name|merge
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|ep
operator|=
name|runp
init|;
name|next
operator|=
name|NEXT
argument_list|(
name|ep
argument_list|)
operator|,
name|next
operator|!=
name|eventp
condition|;
name|ep
operator|=
name|next
control|)
if|if
condition|(
name|ep
operator|->
name|id
operator|!=
name|INVALID_EVENT
condition|)
block|{
if|if
condition|(
name|next
operator|->
name|id
operator|!=
name|INVALID_EVENT
condition|)
continue|continue;
name|follower
operator|=
name|NEXT
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|follower
operator|->
name|id
operator|==
name|INVALID_EVENT
condition|)
continue|continue;
comment|/* merge click events forward */
if|if
condition|(
operator|(
name|ep
operator|->
name|bstate
operator|&
operator|(
name|BUTTON1_CLICKED
operator||
name|BUTTON2_CLICKED
operator||
name|BUTTON3_CLICKED
operator|)
operator|)
operator|&&
operator|(
name|follower
operator|->
name|bstate
operator|&
operator|(
name|BUTTON1_CLICKED
operator||
name|BUTTON2_CLICKED
operator||
name|BUTTON3_CLICKED
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|eventmask
operator|&
name|BUTTON1_DOUBLE_CLICKED
operator|)
operator|&&
operator|(
name|follower
operator|->
name|bstate
operator|&
name|BUTTON1_CLICKED
operator|)
condition|)
block|{
name|follower
operator|->
name|bstate
operator|&=
operator|~
name|BUTTON1_CLICKED
expr_stmt|;
name|follower
operator|->
name|bstate
operator||=
name|BUTTON1_DOUBLE_CLICKED
expr_stmt|;
name|merge
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|eventmask
operator|&
name|BUTTON2_DOUBLE_CLICKED
operator|)
operator|&&
operator|(
name|follower
operator|->
name|bstate
operator|&
name|BUTTON2_CLICKED
operator|)
condition|)
block|{
name|follower
operator|->
name|bstate
operator|&=
operator|~
name|BUTTON2_CLICKED
expr_stmt|;
name|follower
operator|->
name|bstate
operator||=
name|BUTTON2_DOUBLE_CLICKED
expr_stmt|;
name|merge
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|eventmask
operator|&
name|BUTTON3_DOUBLE_CLICKED
operator|)
operator|&&
operator|(
name|follower
operator|->
name|bstate
operator|&
name|BUTTON3_CLICKED
operator|)
condition|)
block|{
name|follower
operator|->
name|bstate
operator|&=
operator|~
name|BUTTON3_CLICKED
expr_stmt|;
name|follower
operator|->
name|bstate
operator||=
name|BUTTON3_DOUBLE_CLICKED
expr_stmt|;
name|merge
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|merge
condition|)
name|ep
operator|->
name|id
operator|=
name|INVALID_EVENT
expr_stmt|;
block|}
comment|/* merge double-click events forward */
if|if
condition|(
operator|(
name|ep
operator|->
name|bstate
operator|&
operator|(
name|BUTTON1_DOUBLE_CLICKED
operator||
name|BUTTON2_DOUBLE_CLICKED
operator||
name|BUTTON3_DOUBLE_CLICKED
operator|)
operator|)
operator|&&
operator|(
name|follower
operator|->
name|bstate
operator|&
operator|(
name|BUTTON1_CLICKED
operator||
name|BUTTON2_CLICKED
operator||
name|BUTTON3_CLICKED
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|eventmask
operator|&
name|BUTTON1_TRIPLE_CLICKED
operator|)
operator|&&
operator|(
name|follower
operator|->
name|bstate
operator|&
name|BUTTON1_CLICKED
operator|)
condition|)
block|{
name|follower
operator|->
name|bstate
operator|&=
operator|~
name|BUTTON1_CLICKED
expr_stmt|;
name|follower
operator|->
name|bstate
operator||=
name|BUTTON1_TRIPLE_CLICKED
expr_stmt|;
name|merge
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|eventmask
operator|&
name|BUTTON2_TRIPLE_CLICKED
operator|)
operator|&&
operator|(
name|follower
operator|->
name|bstate
operator|&
name|BUTTON2_CLICKED
operator|)
condition|)
block|{
name|follower
operator|->
name|bstate
operator|&=
operator|~
name|BUTTON2_CLICKED
expr_stmt|;
name|follower
operator|->
name|bstate
operator||=
name|BUTTON2_TRIPLE_CLICKED
expr_stmt|;
name|merge
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|eventmask
operator|&
name|BUTTON3_TRIPLE_CLICKED
operator|)
operator|&&
operator|(
name|follower
operator|->
name|bstate
operator|&
name|BUTTON3_CLICKED
operator|)
condition|)
block|{
name|follower
operator|->
name|bstate
operator|&=
operator|~
name|BUTTON3_CLICKED
expr_stmt|;
name|follower
operator|->
name|bstate
operator||=
name|BUTTON3_TRIPLE_CLICKED
expr_stmt|;
name|merge
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|merge
condition|)
name|ep
operator|->
name|id
operator|=
name|INVALID_EVENT
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|merge
condition|)
do|;
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|_nc_tracing
operator|&
name|TRACE_IEVENT
condition|)
block|{
name|_trace_slot
argument_list|(
literal|"before mouse event queue compaction:"
argument_list|)
expr_stmt|;
name|_tracef
argument_list|(
literal|"_nc_mouse_parse: run starts at %ld, ends at %ld, count %d"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|runp
operator|-
name|events
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|(
name|eventp
operator|-
name|events
operator|)
operator|+
operator|(
name|EV_MAX
operator|-
literal|1
operator|)
argument_list|)
operator|%
name|EV_MAX
argument_list|,
name|runcount
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TRACE */
comment|/*      * Now try to throw away trailing events flagged invalid, or that      * don't match the current event mask.      */
for|for
control|(
init|;
name|runcount
condition|;
name|prev
operator|=
name|PREV
argument_list|(
name|eventp
argument_list|)
operator|,
name|runcount
operator|--
control|)
if|if
condition|(
name|prev
operator|->
name|id
operator|==
name|INVALID_EVENT
operator|||
operator|!
operator|(
name|prev
operator|->
name|bstate
operator|&
name|eventmask
operator|)
condition|)
block|{
name|eventp
operator|=
name|prev
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|_nc_tracing
operator|&
name|TRACE_IEVENT
condition|)
block|{
name|_trace_slot
argument_list|(
literal|"after mouse event queue compaction:"
argument_list|)
expr_stmt|;
name|_tracef
argument_list|(
literal|"_nc_mouse_parse: run starts at %ld, ends at %ld, count %d"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|runp
operator|-
name|events
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|(
name|eventp
operator|-
name|events
operator|)
operator|+
operator|(
name|EV_MAX
operator|-
literal|1
operator|)
argument_list|)
operator|%
name|EV_MAX
argument_list|,
name|runcount
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ep
operator|=
name|runp
init|;
name|ep
operator|!=
name|eventp
condition|;
name|ep
operator|=
name|NEXT
argument_list|(
name|ep
argument_list|)
control|)
if|if
condition|(
name|ep
operator|->
name|id
operator|!=
name|INVALID_EVENT
condition|)
name|TR
argument_list|(
name|MY_TRACE
argument_list|,
operator|(
literal|"_nc_mouse_parse: returning composite mouse event %s at slot %ld"
operator|,
name|_tracemouse
argument_list|(
name|ep
argument_list|)
operator|,
call|(
name|long
call|)
argument_list|(
name|ep
operator|-
name|events
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TRACE */
comment|/* after all this, do we have a valid event? */
return|return
operator|(
name|PREV
argument_list|(
name|eventp
argument_list|)
operator|->
name|id
operator|!=
name|INVALID_EVENT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_nc_mouse_wrap
parameter_list|(
name|SCREEN
modifier|*
name|sp
name|GCC_UNUSED
parameter_list|)
comment|/* release mouse -- called by endwin() before shellout/exit */
block|{
name|TR
argument_list|(
name|MY_TRACE
argument_list|,
operator|(
literal|"_nc_mouse_wrap() called"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mousetype
condition|)
block|{
case|case
name|M_XTERM
case|:
if|if
condition|(
name|eventmask
condition|)
name|mouse_activate
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|USE_GPM_SUPPORT
comment|/* GPM: pass all mouse events to next client */
case|case
name|M_GPM
case|:
break|break;
endif|#
directive|endif
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|_nc_mouse_resume
parameter_list|(
name|SCREEN
modifier|*
name|sp
name|GCC_UNUSED
parameter_list|)
comment|/* re-connect to mouse -- called by doupdate() after shellout */
block|{
name|TR
argument_list|(
name|MY_TRACE
argument_list|,
operator|(
literal|"_nc_mouse_resume() called"
operator|)
argument_list|)
expr_stmt|;
comment|/* xterm: re-enable reporting */
if|if
condition|(
name|mousetype
operator|==
name|M_XTERM
operator|&&
name|eventmask
condition|)
name|mouse_activate
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
comment|/* GPM: reclaim our event set */
block|}
end_function

begin_comment
comment|/**************************************************************************  *  * Mouse interface entry points for the API  *  **************************************************************************/
end_comment

begin_function
name|int
name|getmouse
parameter_list|(
name|MEVENT
modifier|*
name|aevent
parameter_list|)
comment|/* grab a copy of the current mouse event */
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"getmouse(%p)"
argument_list|)
operator|,
name|aevent
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|aevent
operator|&&
operator|(
name|mousetype
operator|!=
name|M_NONE
operator|)
condition|)
block|{
comment|/* compute the current-event pointer */
name|MEVENT
modifier|*
name|prev
init|=
name|PREV
argument_list|(
name|eventp
argument_list|)
decl_stmt|;
comment|/* copy the event we find there */
operator|*
name|aevent
operator|=
operator|*
name|prev
expr_stmt|;
name|TR
argument_list|(
name|TRACE_IEVENT
argument_list|,
operator|(
literal|"getmouse: returning event %s from slot %ld"
operator|,
name|_tracemouse
argument_list|(
name|prev
argument_list|)
operator|,
call|(
name|long
call|)
argument_list|(
name|prev
operator|-
name|events
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|prev
operator|->
name|id
operator|=
name|INVALID_EVENT
expr_stmt|;
comment|/* so the queue slot becomes free */
name|returnCode
argument_list|(
name|OK
argument_list|)
expr_stmt|;
block|}
name|returnCode
argument_list|(
name|ERR
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ungetmouse
parameter_list|(
name|MEVENT
modifier|*
name|aevent
parameter_list|)
comment|/* enqueue a synthesized mouse event to be seen by the next wgetch() */
block|{
comment|/* stick the given event in the next-free slot */
operator|*
name|eventp
operator|=
operator|*
name|aevent
expr_stmt|;
comment|/* bump the next-free pointer into the circular list */
name|eventp
operator|=
name|NEXT
argument_list|(
name|eventp
argument_list|)
expr_stmt|;
comment|/* push back the notification event on the keyboard queue */
return|return
name|ungetch
argument_list|(
name|KEY_MOUSE
argument_list|)
return|;
block|}
end_function

begin_function
name|mmask_t
name|mousemask
parameter_list|(
name|mmask_t
name|newmask
parameter_list|,
name|mmask_t
modifier|*
name|oldmask
parameter_list|)
comment|/* set the mouse event mask */
block|{
name|mmask_t
name|result
init|=
literal|0
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"mousemask(%#lx,%p)"
argument_list|)
operator|,
name|newmask
operator|,
name|oldmask
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldmask
condition|)
operator|*
name|oldmask
operator|=
name|eventmask
expr_stmt|;
if|if
condition|(
operator|!
name|newmask
operator|&&
operator|!
name|initialized
condition|)
name|returnCode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|_nc_mouse_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|mousetype
operator|!=
name|M_NONE
condition|)
block|{
name|eventmask
operator|=
name|newmask
operator|&
operator|(
name|BUTTON_ALT
operator||
name|BUTTON_CTRL
operator||
name|BUTTON_SHIFT
operator||
name|BUTTON1_PRESSED
operator||
name|BUTTON1_RELEASED
operator||
name|BUTTON1_CLICKED
operator||
name|BUTTON1_DOUBLE_CLICKED
operator||
name|BUTTON1_TRIPLE_CLICKED
operator||
name|BUTTON2_PRESSED
operator||
name|BUTTON2_RELEASED
operator||
name|BUTTON2_CLICKED
operator||
name|BUTTON2_DOUBLE_CLICKED
operator||
name|BUTTON2_TRIPLE_CLICKED
operator||
name|BUTTON3_PRESSED
operator||
name|BUTTON3_RELEASED
operator||
name|BUTTON3_CLICKED
operator||
name|BUTTON3_DOUBLE_CLICKED
operator||
name|BUTTON3_TRIPLE_CLICKED
operator|)
expr_stmt|;
name|mouse_activate
argument_list|(
name|eventmask
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|result
operator|=
name|eventmask
expr_stmt|;
block|}
name|returnCode
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|wenclose
parameter_list|(
specifier|const
name|WINDOW
modifier|*
name|win
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|x
parameter_list|)
comment|/* check to see if given window encloses given screen location */
block|{
if|if
condition|(
name|win
condition|)
block|{
name|y
operator|-=
name|win
operator|->
name|_yoffset
expr_stmt|;
return|return
operator|(
operator|(
name|win
operator|->
name|_begy
operator|<=
name|y
operator|&&
name|win
operator|->
name|_begx
operator|<=
name|x
operator|&&
operator|(
name|win
operator|->
name|_begx
operator|+
name|win
operator|->
name|_maxx
operator|)
operator|>=
name|x
operator|&&
operator|(
name|win
operator|->
name|_begy
operator|+
name|win
operator|->
name|_maxy
operator|)
operator|>=
name|y
operator|)
condition|?
name|TRUE
else|:
name|FALSE
operator|)
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|int
name|mouseinterval
parameter_list|(
name|int
name|maxclick
parameter_list|)
comment|/* set the maximum mouse interval within which to recognize a click */
block|{
name|int
name|oldval
decl_stmt|;
if|if
condition|(
name|SP
operator|!=
literal|0
condition|)
block|{
name|oldval
operator|=
name|SP
operator|->
name|_maxclick
expr_stmt|;
if|if
condition|(
name|maxclick
operator|>=
literal|0
condition|)
name|SP
operator|->
name|_maxclick
operator|=
name|maxclick
expr_stmt|;
block|}
else|else
block|{
name|oldval
operator|=
name|DEFAULT_MAXCLICK
expr_stmt|;
block|}
return|return
operator|(
name|oldval
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This may be used by other routines to ask for the existence of mouse    support */
end_comment

begin_function
name|int
name|_nc_has_mouse
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|mousetype
operator|==
name|M_NONE
condition|?
literal|0
else|:
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|wmouse_trafo
parameter_list|(
specifier|const
name|WINDOW
modifier|*
name|win
parameter_list|,
name|int
modifier|*
name|pY
parameter_list|,
name|int
modifier|*
name|pX
parameter_list|,
name|bool
name|to_screen
parameter_list|)
block|{
name|bool
name|result
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|win
operator|&&
name|pY
operator|&&
name|pX
condition|)
block|{
name|int
name|y
init|=
operator|*
name|pY
decl_stmt|;
name|int
name|x
init|=
operator|*
name|pX
decl_stmt|;
if|if
condition|(
name|to_screen
condition|)
block|{
name|y
operator|+=
name|win
operator|->
name|_begy
operator|+
name|win
operator|->
name|_yoffset
expr_stmt|;
name|x
operator|+=
name|win
operator|->
name|_begx
expr_stmt|;
if|if
condition|(
name|wenclose
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
condition|)
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|wenclose
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
condition|)
block|{
name|y
operator|-=
operator|(
name|win
operator|->
name|_begy
operator|+
name|win
operator|->
name|_yoffset
operator|)
expr_stmt|;
name|x
operator|-=
name|win
operator|->
name|_begx
expr_stmt|;
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|result
condition|)
block|{
operator|*
name|pX
operator|=
name|x
expr_stmt|;
operator|*
name|pY
operator|=
name|y
expr_stmt|;
block|}
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* lib_mouse.c ends here */
end_comment

end_unit

