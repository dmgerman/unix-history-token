begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************************  * Copyright (c) 1998-2005,2006 Free Software Foundation, Inc.              *  *                                                                          *  * Permission is hereby granted, free of charge, to any person obtaining a  *  * copy of this software and associated documentation files (the            *  * "Software"), to deal in the Software without restriction, including      *  * without limitation the rights to use, copy, modify, merge, publish,      *  * distribute, distribute with modifications, sublicense, and/or sell       *  * copies of the Software, and to permit persons to whom the Software is    *  * furnished to do so, subject to the following conditions:                 *  *                                                                          *  * The above copyright notice and this permission notice shall be included  *  * in all copies or substantial portions of the Software.                   *  *                                                                          *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *  * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *  * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *  *                                                                          *  * Except as contained in this notice, the name(s) of the above copyright   *  * holders shall not be used in advertising or otherwise to promote the     *  * sale, use or other dealings in this Software without prior written       *  * authorization.                                                           *  ****************************************************************************/
end_comment

begin_comment
comment|/****************************************************************************  *  Author: Zeyd M. Ben-Halim<zmbenhal@netcom.com> 1992,1995               *  *     and: Eric S. Raymond<esr@snark.thyrsus.com>                         *  *     and: Thomas E. Dickey                        1996-on                 *  ****************************************************************************/
end_comment

begin_comment
comment|/*  * This module is intended to encapsulate ncurses's interface to pointing  * devices.  *  * The primary method used is xterm's internal mouse-tracking facility.  * Additional methods depend on the platform:  *	Alessandro Rubini's GPM server (Linux)  *	sysmouse (FreeBSD)  *	special-purpose mouse interface for OS/2 EMX.  *  * Notes for implementors of new mouse-interface methods:  *  * The code is logically split into a lower level that accepts event reports  * in a device-dependent format and an upper level that parses mouse gestures  * and filters events.  The mediating data structure is a circular queue of  * MEVENT structures.  *  * Functionally, the lower level's job is to pick up primitive events and  * put them on the circular queue.  This can happen in one of two ways:  * either (a) _nc_mouse_event() detects a series of incoming mouse reports  * and queues them, or (b) code in lib_getch.c detects the kmous prefix in  * the keyboard input stream and calls _nc_mouse_inline to queue up a series  * of adjacent mouse reports.  *  * In either case, _nc_mouse_parse() should be called after the series is  * accepted to parse the digested mouse reports (low-level MEVENTs) into  * a gesture (a high-level or composite MEVENT).  *  * Don't be too shy about adding new event types or modifiers, if you can find  * room for them in the 32-bit mask.  The API is written so that users get  * feedback on which theoretical event types they won't see when they call  * mousemask. There's one bit per button (the RESERVED_EVENT bit) not being  * used yet, and a couple of bits open at the high end.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__EMX__
end_ifdef

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_define
define|#
directive|define
name|INCL_DOS
end_define

begin_define
define|#
directive|define
name|INCL_VIO
end_define

begin_define
define|#
directive|define
name|INCL_KBD
end_define

begin_define
define|#
directive|define
name|INCL_MOU
end_define

begin_define
define|#
directive|define
name|INCL_DOSPROCESS
end_define

begin_include
include|#
directive|include
file|<os2.h>
end_include

begin_comment
comment|/* Need to include before the others */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<curses.priv.h>
end_include

begin_macro
name|MODULE_ID
argument_list|(
literal|"$Id: lib_mouse.c,v 1.85 2006/11/25 22:30:28 tom Exp $"
argument_list|)
end_macro

begin_include
include|#
directive|include
file|<term.h>
end_include

begin_include
include|#
directive|include
file|<tic.h>
end_include

begin_if
if|#
directive|if
name|USE_GPM_SUPPORT
end_if

begin_include
include|#
directive|include
file|<linux/keyboard.h>
end_include

begin_comment
comment|/* defines KG_* macros */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIBDL
end_ifdef

begin_comment
comment|/* use dynamic loader to avoid linkage dependency */
end_comment

begin_include
include|#
directive|include
file|<dlfcn.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|RTLD_NOW
end_ifdef

begin_define
define|#
directive|define
name|my_RTLD
value|RTLD_NOW
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|RTLD_LAZY
end_ifdef

begin_define
define|#
directive|define
name|my_RTLD
value|RTLD_LAZY
end_define

begin_else
else|#
directive|else
end_else

begin_function_decl
name|make
name|an
name|error
endif|#
directive|endif
endif|#
directive|endif
comment|/* RTLD_NOW */
endif|#
directive|endif
comment|/* HAVE_LIBDL */
endif|#
directive|endif
comment|/* USE_GPM_SUPPORT */
if|#
directive|if
name|USE_SYSMOUSE
undef|#
directive|undef
name|buttons
comment|/* symbol conflict in consio.h */
undef|#
directive|undef
name|mouse_info
comment|/* symbol conflict in consio.h */
include|#
directive|include
file|<osreldate.h>
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|400017
operator|)
include|#
directive|include
file|<sys/consio.h>
include|#
directive|include
file|<sys/fbio.h>
else|#
directive|else
include|#
directive|include
file|<machine/console.h>
endif|#
directive|endif
endif|#
directive|endif
comment|/* use_SYSMOUSE */
define|#
directive|define
name|MY_TRACE
value|TRACE_ICALLS|TRACE_IEVENT
define|#
directive|define
name|MASK_RELEASE
parameter_list|(
name|x
parameter_list|)
value|NCURSES_MOUSE_MASK(x, 001)
define|#
directive|define
name|MASK_PRESS
parameter_list|(
name|x
parameter_list|)
value|NCURSES_MOUSE_MASK(x, 002)
define|#
directive|define
name|MASK_CLICK
parameter_list|(
name|x
parameter_list|)
value|NCURSES_MOUSE_MASK(x, 004)
define|#
directive|define
name|MASK_DOUBLE_CLICK
parameter_list|(
name|x
parameter_list|)
value|NCURSES_MOUSE_MASK(x, 010)
define|#
directive|define
name|MASK_TRIPLE_CLICK
parameter_list|(
name|x
parameter_list|)
value|NCURSES_MOUSE_MASK(x, 020)
define|#
directive|define
name|MASK_RESERVED_EVENT
parameter_list|(
name|x
parameter_list|)
value|NCURSES_MOUSE_MASK(x, 040)
if|#
directive|if
name|NCURSES_MOUSE_VERSION
operator|==
literal|1
define|#
directive|define
name|BUTTON_CLICKED
value|(BUTTON1_CLICKED        | BUTTON2_CLICKED        | BUTTON3_CLICKED        | BUTTON4_CLICKED)
define|#
directive|define
name|BUTTON_PRESSED
value|(BUTTON1_PRESSED        | BUTTON2_PRESSED        | BUTTON3_PRESSED        | BUTTON4_PRESSED)
define|#
directive|define
name|BUTTON_RELEASED
value|(BUTTON1_RELEASED       | BUTTON2_RELEASED       | BUTTON3_RELEASED       | BUTTON4_RELEASED)
define|#
directive|define
name|BUTTON_DOUBLE_CLICKED
value|(BUTTON1_DOUBLE_CLICKED | BUTTON2_DOUBLE_CLICKED | BUTTON3_DOUBLE_CLICKED | BUTTON4_DOUBLE_CLICKED)
define|#
directive|define
name|BUTTON_TRIPLE_CLICKED
value|(BUTTON1_TRIPLE_CLICKED | BUTTON2_TRIPLE_CLICKED | BUTTON3_TRIPLE_CLICKED | BUTTON4_TRIPLE_CLICKED)
define|#
directive|define
name|MAX_BUTTONS
value|4
else|#
directive|else
define|#
directive|define
name|BUTTON_CLICKED
value|(BUTTON1_CLICKED        | BUTTON2_CLICKED        | BUTTON3_CLICKED        | BUTTON4_CLICKED        | BUTTON5_CLICKED)
define|#
directive|define
name|BUTTON_PRESSED
value|(BUTTON1_PRESSED        | BUTTON2_PRESSED        | BUTTON3_PRESSED        | BUTTON4_PRESSED        | BUTTON5_PRESSED)
define|#
directive|define
name|BUTTON_RELEASED
value|(BUTTON1_RELEASED       | BUTTON2_RELEASED       | BUTTON3_RELEASED       | BUTTON4_RELEASED       | BUTTON5_RELEASED)
define|#
directive|define
name|BUTTON_DOUBLE_CLICKED
value|(BUTTON1_DOUBLE_CLICKED | BUTTON2_DOUBLE_CLICKED | BUTTON3_DOUBLE_CLICKED | BUTTON4_DOUBLE_CLICKED | BUTTON5_DOUBLE_CLICKED)
define|#
directive|define
name|BUTTON_TRIPLE_CLICKED
value|(BUTTON1_TRIPLE_CLICKED | BUTTON2_TRIPLE_CLICKED | BUTTON3_TRIPLE_CLICKED | BUTTON4_TRIPLE_CLICKED | BUTTON5_TRIPLE_CLICKED)
define|#
directive|define
name|MAX_BUTTONS
value|5
endif|#
directive|endif
define|#
directive|define
name|INVALID_EVENT
value|-1
define|#
directive|define
name|NORMAL_EVENT
value|0
if|#
directive|if
name|USE_GPM_SUPPORT
ifndef|#
directive|ifndef
name|LIBGPM_SONAME
define|#
directive|define
name|LIBGPM_SONAME
value|"libgpm.so"
endif|#
directive|endif
define|#
directive|define
name|GET_DLSYM
parameter_list|(
name|name
parameter_list|)
value|(my_##name = (TYPE_##name) dlsym(obj, #name))
endif|#
directive|endif
comment|/* USE_GPM_SUPPORT */
specifier|static
name|bool
name|_nc_mouse_parse
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_nc_mouse_resume
parameter_list|(
name|SCREEN
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_nc_mouse_wrap
parameter_list|(
name|SCREEN
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* maintain a circular list of mouse events */
end_comment

begin_undef
undef|#
directive|undef
name|NEXT
end_undef

begin_define
define|#
directive|define
name|NEXT
parameter_list|(
name|ep
parameter_list|)
value|((ep == SP->_mouse_events + EV_MAX - 1) \ 			 ? SP->_mouse_events \ 			 : ep + 1)
end_define

begin_undef
undef|#
directive|undef
name|PREV
end_undef

begin_define
define|#
directive|define
name|PREV
parameter_list|(
name|ep
parameter_list|)
value|((ep == SP->_mouse_events) \ 			 ? SP->_mouse_events + EV_MAX - 1 \ 			 : ep - 1)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|TRACE
end_ifdef

begin_function
specifier|static
name|void
name|_trace_slot
parameter_list|(
specifier|const
name|char
modifier|*
name|tag
parameter_list|)
block|{
name|MEVENT
modifier|*
name|ep
decl_stmt|;
name|_tracef
argument_list|(
name|tag
argument_list|)
expr_stmt|;
for|for
control|(
name|ep
operator|=
name|SP
operator|->
name|_mouse_events
init|;
name|ep
operator|<
name|SP
operator|->
name|_mouse_events
operator|+
name|EV_MAX
condition|;
name|ep
operator|++
control|)
name|_tracef
argument_list|(
literal|"mouse event queue slot %ld = %s"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|ep
operator|-
name|SP
operator|->
name|_mouse_events
argument_list|)
argument_list|,
name|_tracemouse
argument_list|(
name|ep
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|USE_EMX_MOUSE
end_if

begin_define
define|#
directive|define
name|TOP_ROW
value|0
end_define

begin_define
define|#
directive|define
name|LEFT_COL
value|0
end_define

begin_define
define|#
directive|define
name|M_FD
parameter_list|(
name|sp
parameter_list|)
value|sp->_mouse_fd
end_define

begin_function
specifier|static
name|void
name|write_event
parameter_list|(
name|int
name|down
parameter_list|,
name|int
name|button
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
name|char
name|buf
index|[
literal|6
index|]
decl_stmt|;
name|unsigned
name|long
name|ignore
decl_stmt|;
name|strncpy
argument_list|(
name|buf
argument_list|,
name|key_mouse
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* should be "\033[M" */
name|buf
index|[
literal|3
index|]
operator|=
literal|' '
operator|+
operator|(
name|button
operator|-
literal|1
operator|)
operator|+
operator|(
name|down
condition|?
literal|0
else|:
literal|0x40
operator|)
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
literal|' '
operator|+
name|x
operator|-
name|LEFT_COL
operator|+
literal|1
expr_stmt|;
name|buf
index|[
literal|5
index|]
operator|=
literal|' '
operator|+
name|y
operator|-
name|TOP_ROW
operator|+
literal|1
expr_stmt|;
name|DosWrite
argument_list|(
name|SP
operator|->
name|_emxmouse_wfd
argument_list|,
name|buf
argument_list|,
literal|6
argument_list|,
operator|&
name|ignore
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mouse_server
parameter_list|(
name|unsigned
name|long
name|ignored
name|GCC_UNUSED
parameter_list|)
block|{
name|unsigned
name|short
name|fWait
init|=
name|MOU_WAIT
decl_stmt|;
comment|/* NOPTRRECT mourt = { 0,0,24,79 }; */
name|MOUEVENTINFO
name|mouev
decl_stmt|;
name|HMOU
name|hmou
decl_stmt|;
name|unsigned
name|short
name|mask
init|=
name|MOUSE_BN1_DOWN
operator||
name|MOUSE_BN2_DOWN
operator||
name|MOUSE_BN3_DOWN
decl_stmt|;
name|int
name|nbuttons
init|=
literal|3
decl_stmt|;
name|int
name|oldstate
init|=
literal|0
decl_stmt|;
name|char
name|err
index|[
literal|80
index|]
decl_stmt|;
name|unsigned
name|long
name|rc
decl_stmt|;
comment|/* open the handle for the mouse */
if|if
condition|(
name|MouOpen
argument_list|(
name|NULL
argument_list|,
operator|&
name|hmou
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rc
operator|=
name|MouSetEventMask
argument_list|(
operator|&
name|mask
argument_list|,
name|hmou
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
comment|/* retry with 2 buttons */
name|mask
operator|=
name|MOUSE_BN1_DOWN
operator||
name|MOUSE_BN2_DOWN
expr_stmt|;
name|rc
operator|=
name|MouSetEventMask
argument_list|(
operator|&
name|mask
argument_list|,
name|hmou
argument_list|)
expr_stmt|;
name|nbuttons
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|==
literal|0
operator|&&
name|MouDrawPtr
argument_list|(
name|hmou
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* sit and wait on the event queue */
name|rc
operator|=
name|MouReadEventQue
argument_list|(
operator|&
name|mouev
argument_list|,
operator|&
name|fWait
argument_list|,
name|hmou
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|sprintf
argument_list|(
name|err
argument_list|,
literal|"Error reading mouse queue, rc=%lu.\r\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|SP
operator|->
name|_emxmouse_activated
condition|)
goto|goto
name|finish
goto|;
comment|/* 		 * OS/2 numbers a 3-button mouse inconsistently from other 		 * platforms: 		 *      1 = left 		 *      2 = right 		 *      3 = middle. 		 */
if|if
condition|(
operator|(
name|mouev
operator|.
name|fs
operator|^
name|oldstate
operator|)
operator|&
name|MOUSE_BN1_DOWN
condition|)
name|write_event
argument_list|(
name|mouev
operator|.
name|fs
operator|&
name|MOUSE_BN1_DOWN
argument_list|,
name|SP
operator|->
name|_emxmouse_buttons
index|[
literal|1
index|]
argument_list|,
name|mouev
operator|.
name|col
argument_list|,
name|mouev
operator|.
name|row
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mouev
operator|.
name|fs
operator|^
name|oldstate
operator|)
operator|&
name|MOUSE_BN2_DOWN
condition|)
name|write_event
argument_list|(
name|mouev
operator|.
name|fs
operator|&
name|MOUSE_BN2_DOWN
argument_list|,
name|SP
operator|->
name|_emxmouse_buttons
index|[
literal|3
index|]
argument_list|,
name|mouev
operator|.
name|col
argument_list|,
name|mouev
operator|.
name|row
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mouev
operator|.
name|fs
operator|^
name|oldstate
operator|)
operator|&
name|MOUSE_BN3_DOWN
condition|)
name|write_event
argument_list|(
name|mouev
operator|.
name|fs
operator|&
name|MOUSE_BN3_DOWN
argument_list|,
name|SP
operator|->
name|_emxmouse_buttons
index|[
literal|2
index|]
argument_list|,
name|mouev
operator|.
name|col
argument_list|,
name|mouev
operator|.
name|row
argument_list|)
expr_stmt|;
name|finish
label|:
name|oldstate
operator|=
name|mouev
operator|.
name|fs
expr_stmt|;
block|}
block|}
else|else
name|sprintf
argument_list|(
name|err
argument_list|,
literal|"Error setting event mask, buttons=%d, rc=%lu.\r\n"
argument_list|,
name|nbuttons
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|DosWrite
argument_list|(
literal|2
argument_list|,
name|err
argument_list|,
name|strlen
argument_list|(
name|err
argument_list|)
argument_list|,
operator|&
name|rc
argument_list|)
expr_stmt|;
name|MouClose
argument_list|(
name|hmou
argument_list|)
expr_stmt|;
block|}
name|DosExit
argument_list|(
name|EXIT_THREAD
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_EMX_MOUSE */
end_comment

begin_if
if|#
directive|if
name|USE_SYSMOUSE
end_if

begin_function
specifier|static
name|void
name|handle_sysmouse
parameter_list|(
name|int
name|sig
name|GCC_UNUSED
parameter_list|)
block|{
name|struct
name|mouse_info
name|the_mouse
decl_stmt|;
name|MEVENT
modifier|*
name|work
decl_stmt|;
name|the_mouse
operator|.
name|operation
operator|=
name|MOUSE_GETINFO
expr_stmt|;
if|if
condition|(
name|SP
operator|!=
literal|0
operator|&&
name|SP
operator|->
name|_mouse_fd
operator|>=
literal|0
operator|&&
name|SP
operator|->
name|_sysmouse_tail
operator|<
name|FIFO_SIZE
operator|&&
name|ioctl
argument_list|(
name|SP
operator|->
name|_mouse_fd
argument_list|,
name|CONS_MOUSECTL
argument_list|,
operator|&
name|the_mouse
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|SP
operator|->
name|_sysmouse_head
operator|>
name|SP
operator|->
name|_sysmouse_tail
condition|)
block|{
name|SP
operator|->
name|_sysmouse_tail
operator|=
literal|0
expr_stmt|;
name|SP
operator|->
name|_sysmouse_head
operator|=
literal|0
expr_stmt|;
block|}
name|work
operator|=
operator|&
operator|(
name|SP
operator|->
name|_sysmouse_fifo
index|[
name|SP
operator|->
name|_sysmouse_tail
index|]
operator|)
expr_stmt|;
name|memset
argument_list|(
name|work
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|work
argument_list|)
argument_list|)
expr_stmt|;
name|work
operator|->
name|id
operator|=
name|NORMAL_EVENT
expr_stmt|;
comment|/* there's only one mouse... */
name|SP
operator|->
name|_sysmouse_old_buttons
operator|=
name|SP
operator|->
name|_sysmouse_new_buttons
expr_stmt|;
name|SP
operator|->
name|_sysmouse_new_buttons
operator|=
name|the_mouse
operator|.
name|u
operator|.
name|data
operator|.
name|buttons
operator|&
literal|0x7
expr_stmt|;
if|if
condition|(
name|SP
operator|->
name|_sysmouse_new_buttons
condition|)
block|{
if|if
condition|(
name|SP
operator|->
name|_sysmouse_new_buttons
operator|&
literal|1
condition|)
name|work
operator|->
name|bstate
operator||=
name|BUTTON1_PRESSED
expr_stmt|;
if|if
condition|(
name|SP
operator|->
name|_sysmouse_new_buttons
operator|&
literal|2
condition|)
name|work
operator|->
name|bstate
operator||=
name|BUTTON2_PRESSED
expr_stmt|;
if|if
condition|(
name|SP
operator|->
name|_sysmouse_new_buttons
operator|&
literal|4
condition|)
name|work
operator|->
name|bstate
operator||=
name|BUTTON3_PRESSED
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|SP
operator|->
name|_sysmouse_old_buttons
operator|&
literal|1
condition|)
name|work
operator|->
name|bstate
operator||=
name|BUTTON1_RELEASED
expr_stmt|;
if|if
condition|(
name|SP
operator|->
name|_sysmouse_old_buttons
operator|&
literal|2
condition|)
name|work
operator|->
name|bstate
operator||=
name|BUTTON2_RELEASED
expr_stmt|;
if|if
condition|(
name|SP
operator|->
name|_sysmouse_old_buttons
operator|&
literal|4
condition|)
name|work
operator|->
name|bstate
operator||=
name|BUTTON3_RELEASED
expr_stmt|;
block|}
comment|/* for cosmetic bug in syscons.c on FreeBSD 3.[34] */
name|the_mouse
operator|.
name|operation
operator|=
name|MOUSE_HIDE
expr_stmt|;
name|ioctl
argument_list|(
name|SP
operator|->
name|_mouse_fd
argument_list|,
name|CONS_MOUSECTL
argument_list|,
operator|&
name|the_mouse
argument_list|)
expr_stmt|;
name|the_mouse
operator|.
name|operation
operator|=
name|MOUSE_SHOW
expr_stmt|;
name|ioctl
argument_list|(
name|SP
operator|->
name|_mouse_fd
argument_list|,
name|CONS_MOUSECTL
argument_list|,
operator|&
name|the_mouse
argument_list|)
expr_stmt|;
comment|/* 	 * We're only interested if the button is pressed or released. 	 * FIXME: implement continuous event-tracking. 	 */
if|if
condition|(
name|SP
operator|->
name|_sysmouse_new_buttons
operator|!=
name|SP
operator|->
name|_sysmouse_old_buttons
condition|)
block|{
name|SP
operator|->
name|_sysmouse_tail
operator|+=
literal|1
expr_stmt|;
block|}
name|work
operator|->
name|x
operator|=
name|the_mouse
operator|.
name|u
operator|.
name|data
operator|.
name|x
operator|/
name|SP
operator|->
name|_sysmouse_char_width
expr_stmt|;
name|work
operator|->
name|y
operator|=
name|the_mouse
operator|.
name|u
operator|.
name|data
operator|.
name|y
operator|/
name|SP
operator|->
name|_sysmouse_char_height
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_SYSMOUSE */
end_comment

begin_function
specifier|static
name|void
name|init_xterm_mouse
parameter_list|(
name|void
parameter_list|)
block|{
name|SP
operator|->
name|_mouse_type
operator|=
name|M_XTERM
expr_stmt|;
name|SP
operator|->
name|_mouse_xtermcap
operator|=
name|tigetstr
argument_list|(
literal|"XM"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|VALID_STRING
argument_list|(
name|SP
operator|->
name|_mouse_xtermcap
argument_list|)
condition|)
name|SP
operator|->
name|_mouse_xtermcap
operator|=
literal|"\033[?1000%?%p1%{1}%=%th%el%;"
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|enable_xterm_mouse
parameter_list|(
name|int
name|enable
parameter_list|)
block|{
if|#
directive|if
name|USE_EMX_MOUSE
name|SP
operator|->
name|_emxmouse_activated
operator|=
name|enable
expr_stmt|;
else|#
directive|else
name|putp
argument_list|(
name|TPARM_1
argument_list|(
name|SP
operator|->
name|_mouse_xtermcap
argument_list|,
name|enable
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SP
operator|->
name|_mouse_active
operator|=
name|enable
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|USE_GPM_SUPPORT
end_if

begin_function
specifier|static
name|int
name|allow_gpm_mouse
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* GPM does printf's without checking if stdout is a terminal */
if|if
condition|(
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
condition|)
block|{
name|char
modifier|*
name|env
init|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
decl_stmt|;
comment|/* GPM checks the beginning of the $TERM variable to decide if 	 * it should pass xterm events through.  There is no real advantage 	 * in allowing GPM to do this. 	 */
if|if
condition|(
name|env
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|env
argument_list|,
literal|"xterm"
argument_list|,
literal|5
argument_list|)
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|enable_gpm_mouse
parameter_list|(
name|int
name|enable
parameter_list|)
block|{
name|bool
name|result
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"enable_gpm_mouse(%d)"
argument_list|)
operator|,
name|enable
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
operator|&&
operator|!
name|SP
operator|->
name|_mouse_active
condition|)
block|{
comment|/* GPM: initialize connection to gpm server */
name|SP
operator|->
name|_mouse_gpm_connect
operator|.
name|eventMask
operator|=
name|GPM_DOWN
operator||
name|GPM_UP
expr_stmt|;
name|SP
operator|->
name|_mouse_gpm_connect
operator|.
name|defaultMask
operator|=
operator|~
operator|(
name|SP
operator|->
name|_mouse_gpm_connect
operator|.
name|eventMask
operator||
name|GPM_HARD
operator|)
expr_stmt|;
name|SP
operator|->
name|_mouse_gpm_connect
operator|.
name|minMod
operator|=
literal|0
expr_stmt|;
name|SP
operator|->
name|_mouse_gpm_connect
operator|.
name|maxMod
operator|=
call|(
name|unsigned
name|short
call|)
argument_list|(
operator|~
operator|(
operator|(
literal|1
operator|<<
name|KG_SHIFT
operator|)
operator||
operator|(
literal|1
operator|<<
name|KG_SHIFTL
operator|)
operator||
operator|(
literal|1
operator|<<
name|KG_SHIFTR
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Note: GPM hardcodes \E[?1001s and \E[?1000h during its open. 	 * The former is recognized by wscons (SunOS), and the latter by 	 * xterm.  Those will not show up in ncurses' traces. 	 */
name|result
operator|=
operator|(
name|my_Gpm_Open
argument_list|(
operator|&
name|SP
operator|->
name|_mouse_gpm_connect
argument_list|,
literal|0
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
name|SP
operator|->
name|_mouse_active
operator|=
name|result
expr_stmt|;
name|T
argument_list|(
operator|(
literal|"GPM open %s"
operator|,
name|result
condition|?
literal|"succeeded"
else|:
literal|"failed"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|enable
operator|&&
name|SP
operator|->
name|_mouse_active
condition|)
block|{
comment|/* GPM: close connection to gpm server */
name|my_Gpm_Close
argument_list|()
expr_stmt|;
name|SP
operator|->
name|_mouse_active
operator|=
name|FALSE
expr_stmt|;
name|T
argument_list|(
operator|(
literal|"GPM closed"
operator|)
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|FALSE
expr_stmt|;
block|}
name|returnBool
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_GPM_SUPPORT */
end_comment

begin_function
specifier|static
name|void
name|initialize_mousetype
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|xterm_kmous
init|=
literal|"\033[M"
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"initialize_mousetype()"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Try gpm first, because gpm may be configured to run in xterm */
if|#
directive|if
name|USE_GPM_SUPPORT
if|if
condition|(
name|allow_gpm_mouse
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|SP
operator|->
name|_mouse_gpm_loaded
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_LIBDL
name|void
modifier|*
name|obj
decl_stmt|;
if|if
condition|(
operator|(
name|obj
operator|=
name|dlopen
argument_list|(
name|LIBGPM_SONAME
argument_list|,
name|my_RTLD
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|GET_DLSYM
argument_list|(
name|gpm_fd
argument_list|)
operator|==
literal|0
operator|||
name|GET_DLSYM
argument_list|(
name|Gpm_Open
argument_list|)
operator|==
literal|0
operator|||
name|GET_DLSYM
argument_list|(
name|Gpm_Close
argument_list|)
operator|==
literal|0
operator|||
name|GET_DLSYM
argument_list|(
name|Gpm_GetEvent
argument_list|)
operator|==
literal|0
condition|)
block|{
name|T
argument_list|(
operator|(
literal|"GPM initialization failed: %s"
operator|,
name|dlerror
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|dlclose
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SP
operator|->
name|_mouse_gpm_found
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* !HAVE_LIBDL */
name|SP
operator|->
name|_mouse_gpm_found
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
name|SP
operator|->
name|_mouse_gpm_loaded
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* 	 * The gpm_fd file-descriptor may be negative (xterm).  So we have to 	 * maintain our notion of whether the mouse connection is active 	 * without testing the file-descriptor. 	 */
if|if
condition|(
name|SP
operator|->
name|_mouse_gpm_found
operator|&&
name|enable_gpm_mouse
argument_list|(
name|TRUE
argument_list|)
condition|)
block|{
name|SP
operator|->
name|_mouse_type
operator|=
name|M_GPM
expr_stmt|;
name|SP
operator|->
name|_mouse_fd
operator|=
operator|*
operator|(
name|my_gpm_fd
operator|)
expr_stmt|;
name|T
argument_list|(
operator|(
literal|"GPM mouse_fd %d"
operator|,
name|SP
operator|->
name|_mouse_fd
operator|)
argument_list|)
expr_stmt|;
name|returnVoid
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* USE_GPM_SUPPORT */
comment|/* OS/2 VIO */
if|#
directive|if
name|USE_EMX_MOUSE
if|if
condition|(
operator|!
name|SP
operator|->
name|_emxmouse_thread
operator|&&
name|strstr
argument_list|(
name|cur_term
operator|->
name|type
operator|.
name|term_names
argument_list|,
literal|"xterm"
argument_list|)
operator|==
literal|0
operator|&&
name|key_mouse
condition|)
block|{
name|int
name|handles
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|handles
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"mouse pipe error"
argument_list|)
expr_stmt|;
name|returnVoid
expr_stmt|;
block|}
else|else
block|{
name|int
name|rc
decl_stmt|;
if|if
condition|(
operator|!
name|SP
operator|->
name|_emxmouse_buttons
index|[
literal|0
index|]
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|getenv
argument_list|(
literal|"MOUSE_BUTTONS_123"
argument_list|)
decl_stmt|;
name|SP
operator|->
name|_emxmouse_buttons
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|s
operator|&&
name|strlen
argument_list|(
name|s
argument_list|)
operator|>=
literal|3
condition|)
block|{
name|SP
operator|->
name|_emxmouse_buttons
index|[
literal|1
index|]
operator|=
name|s
index|[
literal|0
index|]
operator|-
literal|'0'
expr_stmt|;
name|SP
operator|->
name|_emxmouse_buttons
index|[
literal|2
index|]
operator|=
name|s
index|[
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
name|SP
operator|->
name|_emxmouse_buttons
index|[
literal|3
index|]
operator|=
name|s
index|[
literal|2
index|]
operator|-
literal|'0'
expr_stmt|;
block|}
else|else
block|{
name|SP
operator|->
name|_emxmouse_buttons
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|SP
operator|->
name|_emxmouse_buttons
index|[
literal|2
index|]
operator|=
literal|3
expr_stmt|;
name|SP
operator|->
name|_emxmouse_buttons
index|[
literal|3
index|]
operator|=
literal|2
expr_stmt|;
block|}
block|}
name|SP
operator|->
name|_emxmouse_wfd
operator|=
name|handles
index|[
literal|1
index|]
expr_stmt|;
name|M_FD
argument_list|(
name|SP
argument_list|)
operator|=
name|handles
index|[
literal|0
index|]
expr_stmt|;
comment|/* Needed? */
name|setmode
argument_list|(
name|handles
index|[
literal|0
index|]
argument_list|,
name|O_BINARY
argument_list|)
expr_stmt|;
name|setmode
argument_list|(
name|handles
index|[
literal|1
index|]
argument_list|,
name|O_BINARY
argument_list|)
expr_stmt|;
comment|/* Do not use CRT functions, we may single-threaded. */
name|rc
operator|=
name|DosCreateThread
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|&
name|SP
operator|->
name|_emxmouse_thread
argument_list|,
name|mouse_server
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8192
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|printf
argument_list|(
literal|"mouse thread error %d=%#x"
argument_list|,
name|rc
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SP
operator|->
name|_mouse_type
operator|=
name|M_XTERM
expr_stmt|;
block|}
name|returnVoid
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* USE_EMX_MOUSE */
if|#
directive|if
name|USE_SYSMOUSE
block|{
name|struct
name|mouse_info
name|the_mouse
decl_stmt|;
name|char
modifier|*
name|the_device
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|isatty
argument_list|(
name|SP
operator|->
name|_ifd
argument_list|)
condition|)
name|the_device
operator|=
name|ttyname
argument_list|(
name|SP
operator|->
name|_ifd
argument_list|)
expr_stmt|;
if|if
condition|(
name|the_device
operator|==
literal|0
condition|)
name|the_device
operator|=
literal|"/dev/tty"
expr_stmt|;
name|SP
operator|->
name|_mouse_fd
operator|=
name|open
argument_list|(
name|the_device
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|SP
operator|->
name|_mouse_fd
operator|>=
literal|0
condition|)
block|{
comment|/* 	     * sysmouse does not have a usable user interface for obtaining 	     * mouse events.  The logical way to proceed (reading data on a 	     * stream) only works if one opens the device as root.  Even in 	     * that mode, careful examination shows we lose events 	     * occasionally.  The interface provided for user programs is to 	     * establish a signal handler.  really. 	     * 	     * Take over SIGUSR2 for this purpose since SIGUSR1 is more 	     * likely to be used by an application.  getch() will have to 	     * handle the misleading EINTR's. 	     */
name|signal
argument_list|(
name|SIGUSR2
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|the_mouse
operator|.
name|operation
operator|=
name|MOUSE_MODE
expr_stmt|;
name|the_mouse
operator|.
name|u
operator|.
name|mode
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
name|the_mouse
operator|.
name|u
operator|.
name|mode
operator|.
name|signal
operator|=
name|SIGUSR2
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|SP
operator|->
name|_mouse_fd
argument_list|,
name|CONS_MOUSECTL
argument_list|,
operator|&
name|the_mouse
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|signal
argument_list|(
name|SIGUSR2
argument_list|,
name|handle_sysmouse
argument_list|)
expr_stmt|;
name|the_mouse
operator|.
name|operation
operator|=
name|MOUSE_SHOW
expr_stmt|;
name|ioctl
argument_list|(
name|SP
operator|->
name|_mouse_fd
argument_list|,
name|CONS_MOUSECTL
argument_list|,
operator|&
name|the_mouse
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|FBIO_MODEINFO
argument_list|)
operator|||
name|defined
argument_list|(
name|CONS_MODEINFO
argument_list|)
comment|/* FreeBSD> 2.x */
block|{
ifndef|#
directive|ifndef
name|FBIO_GETMODE
comment|/* FreeBSD 3.x */
define|#
directive|define
name|FBIO_GETMODE
value|CONS_GET
define|#
directive|define
name|FBIO_MODEINFO
value|CONS_MODEINFO
endif|#
directive|endif
comment|/* FBIO_GETMODE */
name|video_info_t
name|the_video
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|SP
operator|->
name|_mouse_fd
argument_list|,
name|FBIO_GETMODE
argument_list|,
operator|&
name|the_video
operator|.
name|vi_mode
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
name|ioctl
argument_list|(
name|SP
operator|->
name|_mouse_fd
argument_list|,
name|FBIO_MODEINFO
argument_list|,
operator|&
name|the_video
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|SP
operator|->
name|_sysmouse_char_width
operator|=
name|the_video
operator|.
name|vi_cwidth
expr_stmt|;
name|SP
operator|->
name|_sysmouse_char_height
operator|=
name|the_video
operator|.
name|vi_cheight
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* defined(FBIO_MODEINFO) || defined(CONS_MODEINFO) */
if|if
condition|(
name|SP
operator|->
name|_sysmouse_char_width
operator|<=
literal|0
condition|)
name|SP
operator|->
name|_sysmouse_char_width
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|SP
operator|->
name|_sysmouse_char_height
operator|<=
literal|0
condition|)
name|SP
operator|->
name|_sysmouse_char_height
operator|=
literal|16
expr_stmt|;
name|SP
operator|->
name|_mouse_type
operator|=
name|M_SYSMOUSE
expr_stmt|;
name|returnVoid
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* USE_SYSMOUSE */
comment|/* we know how to recognize mouse events under "xterm" */
if|if
condition|(
name|key_mouse
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|key_mouse
argument_list|,
name|xterm_kmous
argument_list|)
operator|||
name|strstr
argument_list|(
name|cur_term
operator|->
name|type
operator|.
name|term_names
argument_list|,
literal|"xterm"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|init_xterm_mouse
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|cur_term
operator|->
name|type
operator|.
name|term_names
argument_list|,
literal|"xterm"
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|_nc_add_to_try
argument_list|(
operator|&
operator|(
name|SP
operator|->
name|_keytry
operator|)
argument_list|,
name|xterm_kmous
argument_list|,
name|KEY_MOUSE
argument_list|)
expr_stmt|;
name|init_xterm_mouse
argument_list|()
expr_stmt|;
block|}
name|returnVoid
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|_nc_mouse_init
parameter_list|(
name|void
parameter_list|)
comment|/* initialize the mouse */
block|{
name|bool
name|result
init|=
name|FALSE
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|SP
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|SP
operator|->
name|_mouse_initialized
condition|)
block|{
name|SP
operator|->
name|_mouse_initialized
operator|=
name|TRUE
expr_stmt|;
name|TR
argument_list|(
name|MY_TRACE
argument_list|,
operator|(
literal|"_nc_mouse_init() called"
operator|)
argument_list|)
expr_stmt|;
name|SP
operator|->
name|_mouse_eventp
operator|=
name|SP
operator|->
name|_mouse_events
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EV_MAX
condition|;
name|i
operator|++
control|)
name|SP
operator|->
name|_mouse_events
index|[
name|i
index|]
operator|.
name|id
operator|=
name|INVALID_EVENT
expr_stmt|;
name|initialize_mousetype
argument_list|()
expr_stmt|;
name|T
argument_list|(
operator|(
literal|"_nc_mouse_init() set mousetype to %d"
operator|,
name|SP
operator|->
name|_mouse_type
operator|)
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|SP
operator|->
name|_mouse_initialized
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Query to see if there is a pending mouse event.  This is called from  * fifo_push() in lib_getch.c  */
end_comment

begin_function
specifier|static
name|bool
name|_nc_mouse_event
parameter_list|(
name|SCREEN
modifier|*
name|sp
name|GCC_UNUSED
parameter_list|)
block|{
name|MEVENT
modifier|*
name|eventp
init|=
name|SP
operator|->
name|_mouse_eventp
decl_stmt|;
name|bool
name|result
init|=
name|FALSE
decl_stmt|;
operator|(
name|void
operator|)
name|eventp
expr_stmt|;
switch|switch
condition|(
name|SP
operator|->
name|_mouse_type
condition|)
block|{
case|case
name|M_XTERM
case|:
comment|/* xterm: never have to query, mouse events are in the keyboard stream */
if|#
directive|if
name|USE_EMX_MOUSE
block|{
name|char
name|kbuf
index|[
literal|3
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|res
init|=
name|read
argument_list|(
name|M_FD
argument_list|(
name|sp
argument_list|)
argument_list|,
operator|&
name|kbuf
argument_list|,
literal|3
argument_list|)
decl_stmt|;
comment|/* Eat the prefix */
if|if
condition|(
name|res
operator|!=
literal|3
condition|)
name|printf
argument_list|(
literal|"Got %d chars instead of 3 for prefix.\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|res
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|kbuf
index|[
name|i
index|]
operator|!=
name|key_mouse
index|[
name|i
index|]
condition|)
name|printf
argument_list|(
literal|"Got char %d instead of %d for prefix.\n"
argument_list|,
operator|(
name|int
operator|)
name|kbuf
index|[
name|i
index|]
argument_list|,
operator|(
name|int
operator|)
name|key_mouse
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USE_EMX_MOUSE */
break|break;
if|#
directive|if
name|USE_GPM_SUPPORT
case|case
name|M_GPM
case|:
block|{
comment|/* query server for event, return TRUE if we find one */
name|Gpm_Event
name|ev
decl_stmt|;
if|if
condition|(
name|my_Gpm_GetEvent
argument_list|(
operator|&
name|ev
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* there's only one mouse... */
name|eventp
operator|->
name|id
operator|=
name|NORMAL_EVENT
expr_stmt|;
name|eventp
operator|->
name|bstate
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|ev
operator|.
name|type
operator|&
literal|0x0f
condition|)
block|{
case|case
operator|(
name|GPM_DOWN
operator|)
case|:
if|if
condition|(
name|ev
operator|.
name|buttons
operator|&
name|GPM_B_LEFT
condition|)
name|eventp
operator|->
name|bstate
operator||=
name|BUTTON1_PRESSED
expr_stmt|;
if|if
condition|(
name|ev
operator|.
name|buttons
operator|&
name|GPM_B_MIDDLE
condition|)
name|eventp
operator|->
name|bstate
operator||=
name|BUTTON2_PRESSED
expr_stmt|;
if|if
condition|(
name|ev
operator|.
name|buttons
operator|&
name|GPM_B_RIGHT
condition|)
name|eventp
operator|->
name|bstate
operator||=
name|BUTTON3_PRESSED
expr_stmt|;
break|break;
case|case
operator|(
name|GPM_UP
operator|)
case|:
if|if
condition|(
name|ev
operator|.
name|buttons
operator|&
name|GPM_B_LEFT
condition|)
name|eventp
operator|->
name|bstate
operator||=
name|BUTTON1_RELEASED
expr_stmt|;
if|if
condition|(
name|ev
operator|.
name|buttons
operator|&
name|GPM_B_MIDDLE
condition|)
name|eventp
operator|->
name|bstate
operator||=
name|BUTTON2_RELEASED
expr_stmt|;
if|if
condition|(
name|ev
operator|.
name|buttons
operator|&
name|GPM_B_RIGHT
condition|)
name|eventp
operator|->
name|bstate
operator||=
name|BUTTON3_RELEASED
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|eventp
operator|->
name|x
operator|=
name|ev
operator|.
name|x
operator|-
literal|1
expr_stmt|;
name|eventp
operator|->
name|y
operator|=
name|ev
operator|.
name|y
operator|-
literal|1
expr_stmt|;
name|eventp
operator|->
name|z
operator|=
literal|0
expr_stmt|;
comment|/* bump the next-free pointer into the circular list */
name|SP
operator|->
name|_mouse_eventp
operator|=
name|eventp
operator|=
name|NEXT
argument_list|(
name|eventp
argument_list|)
expr_stmt|;
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
break|break;
endif|#
directive|endif
if|#
directive|if
name|USE_SYSMOUSE
case|case
name|M_SYSMOUSE
case|:
if|if
condition|(
name|SP
operator|->
name|_sysmouse_head
operator|<
name|SP
operator|->
name|_sysmouse_tail
condition|)
block|{
operator|*
name|eventp
operator|=
name|SP
operator|->
name|_sysmouse_fifo
index|[
name|SP
operator|->
name|_sysmouse_head
index|]
expr_stmt|;
comment|/* 	     * Point the fifo-head to the next possible location.  If there 	     * are none, reset the indices.  This may be interrupted by the 	     * signal handler, doing essentially the same reset. 	     */
name|SP
operator|->
name|_sysmouse_head
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|SP
operator|->
name|_sysmouse_head
operator|==
name|SP
operator|->
name|_sysmouse_tail
condition|)
block|{
name|SP
operator|->
name|_sysmouse_tail
operator|=
literal|0
expr_stmt|;
name|SP
operator|->
name|_sysmouse_head
operator|=
literal|0
expr_stmt|;
block|}
comment|/* bump the next-free pointer into the circular list */
name|SP
operator|->
name|_mouse_eventp
operator|=
name|eventp
operator|=
name|NEXT
argument_list|(
name|eventp
argument_list|)
expr_stmt|;
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* USE_SYSMOUSE */
case|case
name|M_NONE
case|:
break|break;
block|}
return|return
name|result
return|;
comment|/* true if we found an event */
block|}
end_function

begin_function
specifier|static
name|bool
name|_nc_mouse_inline
parameter_list|(
name|SCREEN
modifier|*
name|sp
parameter_list|)
comment|/* mouse report received in the keyboard stream -- parse its info */
block|{
name|int
name|b
decl_stmt|;
name|bool
name|result
init|=
name|FALSE
decl_stmt|;
name|MEVENT
modifier|*
name|eventp
init|=
name|SP
operator|->
name|_mouse_eventp
decl_stmt|;
name|TR
argument_list|(
name|MY_TRACE
argument_list|,
operator|(
literal|"_nc_mouse_inline() called"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SP
operator|->
name|_mouse_type
operator|==
name|M_XTERM
condition|)
block|{
name|unsigned
name|char
name|kbuf
index|[
literal|4
index|]
decl_stmt|;
name|mmask_t
name|prev
decl_stmt|;
name|size_t
name|grabbed
decl_stmt|;
name|int
name|res
decl_stmt|;
comment|/* This code requires that your xterm entry contain the kmous 	 * capability and that it be set to the \E[M documented in the 	 * Xterm Control Sequences reference.  This is how we 	 * arrange for mouse events to be reported via a KEY_MOUSE 	 * return value from wgetch().  After this value is received, 	 * _nc_mouse_inline() gets called and is immediately 	 * responsible for parsing the mouse status information 	 * following the prefix. 	 * 	 * The following quotes from the ctrlseqs.ms document in the 	 * X distribution, describing the X mouse tracking feature: 	 * 	 * Parameters for all mouse tracking escape sequences 	 * generated by xterm encode numeric parameters in a single 	 * character as value+040.  For example, !  is 1. 	 * 	 * On button press or release, xterm sends ESC [ M CbCxCy. 	 * The low two bits of Cb encode button information: 0=MB1 	 * pressed, 1=MB2 pressed, 2=MB3 pressed, 3=release.  The 	 * upper bits encode what modifiers were down when the 	 * button was pressed and are added together.  4=Shift, 	 * 8=Meta, 16=Control.  Cx and Cy are the x and y coordinates 	 * of the mouse event.  The upper left corner is (1,1). 	 * 	 * (End quote)  By the time we get here, we've eaten the 	 * key prefix.  FYI, the loop below is necessary because 	 * mouse click info isn't guaranteed to present as a 	 * single clist item. 	 * 	 * Wheel mice may return buttons 4 and 5 when the wheel is turned. 	 * We encode those as button presses. 	 */
for|for
control|(
name|grabbed
operator|=
literal|0
init|;
name|grabbed
operator|<
literal|3
condition|;
name|grabbed
operator|+=
name|res
control|)
block|{
comment|/* For VIO mouse we add extra bit 64 to disambiguate button-up. */
if|#
directive|if
name|USE_EMX_MOUSE
name|res
operator|=
name|read
argument_list|(
name|M_FD
argument_list|(
name|sp
argument_list|)
operator|>=
literal|0
condition|?
name|M_FD
argument_list|(
name|sp
argument_list|)
else|:
name|sp
operator|->
name|_ifd
argument_list|,
operator|&
name|kbuf
argument_list|,
literal|3
argument_list|)
expr_stmt|;
else|#
directive|else
name|res
operator|=
name|read
argument_list|(
name|sp
operator|->
name|_ifd
argument_list|,
name|kbuf
operator|+
name|grabbed
argument_list|,
literal|3
operator|-
name|grabbed
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|res
operator|==
operator|-
literal|1
condition|)
break|break;
block|}
name|kbuf
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|TR
argument_list|(
name|TRACE_IEVENT
argument_list|,
operator|(
literal|"_nc_mouse_inline sees the following xterm data: '%s'"
operator|,
name|kbuf
operator|)
argument_list|)
expr_stmt|;
comment|/* there's only one mouse... */
name|eventp
operator|->
name|id
operator|=
name|NORMAL_EVENT
expr_stmt|;
comment|/* processing code goes here */
name|eventp
operator|->
name|bstate
operator|=
literal|0
expr_stmt|;
name|prev
operator|=
name|PREV
argument_list|(
name|eventp
argument_list|)
operator|->
name|bstate
expr_stmt|;
if|#
directive|if
name|USE_EMX_MOUSE
define|#
directive|define
name|PRESS_POSITION
parameter_list|(
name|n
parameter_list|)
define|\
value|eventp->bstate = MASK_PRESS(n); \ 	if (kbuf[0]& 0x40) \ 	    eventp->bstate = MASK_RELEASE(n)
else|#
directive|else
define|#
directive|define
name|PRESS_POSITION
parameter_list|(
name|n
parameter_list|)
define|\
value|eventp->bstate = (prev& MASK_PRESS(n) \ 			? REPORT_MOUSE_POSITION \ 			: MASK_PRESS(n))
endif|#
directive|endif
switch|switch
condition|(
name|kbuf
index|[
literal|0
index|]
operator|&
literal|0x3
condition|)
block|{
case|case
literal|0x0
case|:
if|if
condition|(
name|kbuf
index|[
literal|0
index|]
operator|&
literal|64
condition|)
name|eventp
operator|->
name|bstate
operator|=
name|MASK_PRESS
argument_list|(
literal|4
argument_list|)
expr_stmt|;
else|else
name|PRESS_POSITION
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x1
case|:
if|#
directive|if
name|NCURSES_MOUSE_VERSION
operator|==
literal|2
if|if
condition|(
name|kbuf
index|[
literal|0
index|]
operator|&
literal|64
condition|)
name|eventp
operator|->
name|bstate
operator|=
name|MASK_PRESS
argument_list|(
literal|5
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|PRESS_POSITION
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x2
case|:
name|PRESS_POSITION
argument_list|(
literal|3
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x3
case|:
comment|/* 	     * Release events aren't reported for individual buttons, just for 	     * the button set as a whole.  However, because there are normally 	     * no mouse events under xterm that intervene between press and 	     * release, we can infer the button actually released by looking at 	     * the previous event. 	     */
if|if
condition|(
name|prev
operator|&
operator|(
name|BUTTON_PRESSED
operator||
name|BUTTON_RELEASED
operator|)
condition|)
block|{
name|eventp
operator|->
name|bstate
operator|=
name|BUTTON_RELEASED
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|1
init|;
name|b
operator|<=
name|MAX_BUTTONS
condition|;
operator|++
name|b
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|prev
operator|&
name|MASK_PRESS
argument_list|(
name|b
argument_list|)
operator|)
condition|)
name|eventp
operator|->
name|bstate
operator|&=
operator|~
name|MASK_RELEASE
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * XFree86 xterm will return a stream of release-events to 		 * let the application know where the mouse is going, if the 		 * private mode 1002 or 1003 is enabled. 		 */
name|eventp
operator|->
name|bstate
operator|=
name|REPORT_MOUSE_POSITION
expr_stmt|;
block|}
break|break;
block|}
name|result
operator|=
operator|(
name|eventp
operator|->
name|bstate
operator|&
name|REPORT_MOUSE_POSITION
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
if|if
condition|(
name|kbuf
index|[
literal|0
index|]
operator|&
literal|4
condition|)
block|{
name|eventp
operator|->
name|bstate
operator||=
name|BUTTON_SHIFT
expr_stmt|;
block|}
if|if
condition|(
name|kbuf
index|[
literal|0
index|]
operator|&
literal|8
condition|)
block|{
name|eventp
operator|->
name|bstate
operator||=
name|BUTTON_ALT
expr_stmt|;
block|}
if|if
condition|(
name|kbuf
index|[
literal|0
index|]
operator|&
literal|16
condition|)
block|{
name|eventp
operator|->
name|bstate
operator||=
name|BUTTON_CTRL
expr_stmt|;
block|}
name|eventp
operator|->
name|x
operator|=
operator|(
name|kbuf
index|[
literal|1
index|]
operator|-
literal|' '
operator|)
operator|-
literal|1
expr_stmt|;
name|eventp
operator|->
name|y
operator|=
operator|(
name|kbuf
index|[
literal|2
index|]
operator|-
literal|' '
operator|)
operator|-
literal|1
expr_stmt|;
name|TR
argument_list|(
name|MY_TRACE
argument_list|,
operator|(
literal|"_nc_mouse_inline: primitive mouse-event %s has slot %ld"
operator|,
name|_tracemouse
argument_list|(
name|eventp
argument_list|)
operator|,
call|(
name|long
call|)
argument_list|(
name|eventp
operator|-
name|SP
operator|->
name|_mouse_events
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* bump the next-free pointer into the circular list */
name|SP
operator|->
name|_mouse_eventp
operator|=
name|NEXT
argument_list|(
name|eventp
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* this return would be needed for QNX's mods to lib_getch.c */
block|return (TRUE);
endif|#
directive|endif
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mouse_activate
parameter_list|(
name|bool
name|on
parameter_list|)
block|{
if|if
condition|(
operator|!
name|on
operator|&&
operator|!
name|SP
operator|->
name|_mouse_initialized
condition|)
return|return;
if|if
condition|(
operator|!
name|_nc_mouse_init
argument_list|()
condition|)
return|return;
if|if
condition|(
name|on
condition|)
block|{
switch|switch
condition|(
name|SP
operator|->
name|_mouse_type
condition|)
block|{
case|case
name|M_XTERM
case|:
if|#
directive|if
name|NCURSES_EXT_FUNCS
name|keyok
argument_list|(
name|KEY_MOUSE
argument_list|,
name|on
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TPUTS_TRACE
argument_list|(
literal|"xterm mouse initialization"
argument_list|)
expr_stmt|;
name|enable_xterm_mouse
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|USE_GPM_SUPPORT
case|case
name|M_GPM
case|:
if|if
condition|(
name|enable_gpm_mouse
argument_list|(
literal|1
argument_list|)
condition|)
block|{
name|SP
operator|->
name|_mouse_fd
operator|=
operator|*
operator|(
name|my_gpm_fd
operator|)
expr_stmt|;
name|T
argument_list|(
operator|(
literal|"GPM mouse_fd %d"
operator|,
name|SP
operator|->
name|_mouse_fd
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
if|#
directive|if
name|USE_SYSMOUSE
case|case
name|M_SYSMOUSE
case|:
name|signal
argument_list|(
name|SIGUSR2
argument_list|,
name|handle_sysmouse
argument_list|)
expr_stmt|;
name|SP
operator|->
name|_mouse_active
operator|=
name|TRUE
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|M_NONE
case|:
return|return;
block|}
comment|/* Make runtime binding to cut down on object size of applications that 	 * do not use the mouse (e.g., 'clear'). 	 */
name|SP
operator|->
name|_mouse_event
operator|=
name|_nc_mouse_event
expr_stmt|;
name|SP
operator|->
name|_mouse_inline
operator|=
name|_nc_mouse_inline
expr_stmt|;
name|SP
operator|->
name|_mouse_parse
operator|=
name|_nc_mouse_parse
expr_stmt|;
name|SP
operator|->
name|_mouse_resume
operator|=
name|_nc_mouse_resume
expr_stmt|;
name|SP
operator|->
name|_mouse_wrap
operator|=
name|_nc_mouse_wrap
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|SP
operator|->
name|_mouse_type
condition|)
block|{
case|case
name|M_XTERM
case|:
name|TPUTS_TRACE
argument_list|(
literal|"xterm mouse deinitialization"
argument_list|)
expr_stmt|;
name|enable_xterm_mouse
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|USE_GPM_SUPPORT
case|case
name|M_GPM
case|:
name|enable_gpm_mouse
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|USE_SYSMOUSE
case|case
name|M_SYSMOUSE
case|:
name|signal
argument_list|(
name|SIGUSR2
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|SP
operator|->
name|_mouse_active
operator|=
name|FALSE
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|M_NONE
case|:
return|return;
block|}
block|}
name|_nc_flush
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************************  *  * Device-independent code  *  **************************************************************************/
end_comment

begin_function
specifier|static
name|bool
name|_nc_mouse_parse
parameter_list|(
name|int
name|runcount
parameter_list|)
comment|/* parse a run of atomic mouse events into a gesture */
block|{
name|MEVENT
modifier|*
name|eventp
init|=
name|SP
operator|->
name|_mouse_eventp
decl_stmt|;
name|MEVENT
modifier|*
name|ep
decl_stmt|,
modifier|*
name|runp
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
init|=
name|PREV
argument_list|(
name|eventp
argument_list|)
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|b
decl_stmt|;
name|bool
name|merge
decl_stmt|;
name|TR
argument_list|(
name|MY_TRACE
argument_list|,
operator|(
literal|"_nc_mouse_parse(%d) called"
operator|,
name|runcount
operator|)
argument_list|)
expr_stmt|;
comment|/*      * When we enter this routine, the event list next-free pointer      * points just past a run of mouse events that we know were separated      * in time by less than the critical click interval. The job of this      * routine is to collapse this run into a single higher-level event      * or gesture.      *      * We accomplish this in two passes.  The first pass merges press/release      * pairs into click events.  The second merges runs of click events into      * double or triple-click events.      *      * It's possible that the run may not resolve to a single event (for      * example, if the user quadruple-clicks).  If so, leading events      * in the run are ignored.      *      * Note that this routine is independent of the format of the specific      * format of the pointing-device's reports.  We can use it to parse      * gestures on anything that reports press/release events on a per-      * button basis, as long as the device-dependent mouse code puts stuff      * on the queue in MEVENT format.      */
if|if
condition|(
name|runcount
operator|==
literal|1
condition|)
block|{
name|TR
argument_list|(
name|MY_TRACE
argument_list|,
operator|(
literal|"_nc_mouse_parse: returning simple mouse event %s at slot %ld"
operator|,
name|_tracemouse
argument_list|(
name|prev
argument_list|)
operator|,
call|(
name|long
call|)
argument_list|(
name|prev
operator|-
name|SP
operator|->
name|_mouse_events
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|prev
operator|->
name|id
operator|>=
name|NORMAL_EVENT
operator|)
condition|?
operator|(
operator|(
name|prev
operator|->
name|bstate
operator|&
name|SP
operator|->
name|_mouse_mask
operator|)
condition|?
name|TRUE
else|:
name|FALSE
operator|)
else|:
name|FALSE
return|;
block|}
comment|/* find the start of the run */
name|runp
operator|=
name|eventp
expr_stmt|;
for|for
control|(
name|n
operator|=
name|runcount
init|;
name|n
operator|>
literal|0
condition|;
name|n
operator|--
control|)
block|{
name|runp
operator|=
name|PREV
argument_list|(
name|runp
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|_nc_tracing
operator|&
name|TRACE_IEVENT
condition|)
block|{
name|_trace_slot
argument_list|(
literal|"before mouse press/release merge:"
argument_list|)
expr_stmt|;
name|_tracef
argument_list|(
literal|"_nc_mouse_parse: run starts at %ld, ends at %ld, count %d"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|runp
operator|-
name|SP
operator|->
name|_mouse_events
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|(
name|eventp
operator|-
name|SP
operator|->
name|_mouse_events
operator|)
operator|+
operator|(
name|EV_MAX
operator|-
literal|1
operator|)
argument_list|)
operator|%
name|EV_MAX
argument_list|,
name|runcount
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TRACE */
comment|/* first pass; merge press/release pairs */
do|do
block|{
name|merge
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|ep
operator|=
name|runp
init|;
operator|(
name|next
operator|=
name|NEXT
argument_list|(
name|ep
argument_list|)
operator|)
operator|!=
name|eventp
condition|;
name|ep
operator|=
name|next
control|)
block|{
define|#
directive|define
name|MASK_CHANGED
parameter_list|(
name|x
parameter_list|)
value|(!(ep->bstate& MASK_PRESS(x)) \ 		      == !(next->bstate& MASK_RELEASE(x)))
if|if
condition|(
name|ep
operator|->
name|x
operator|==
name|next
operator|->
name|x
operator|&&
name|ep
operator|->
name|y
operator|==
name|next
operator|->
name|y
operator|&&
operator|(
name|ep
operator|->
name|bstate
operator|&
name|BUTTON_PRESSED
operator|)
operator|&&
name|MASK_CHANGED
argument_list|(
literal|1
argument_list|)
operator|&&
name|MASK_CHANGED
argument_list|(
literal|2
argument_list|)
operator|&&
name|MASK_CHANGED
argument_list|(
literal|3
argument_list|)
operator|&&
name|MASK_CHANGED
argument_list|(
literal|4
argument_list|)
if|#
directive|if
name|NCURSES_MOUSE_VERSION
operator|==
literal|2
operator|&&
name|MASK_CHANGED
argument_list|(
literal|5
argument_list|)
endif|#
directive|endif
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|1
init|;
name|b
operator|<=
name|MAX_BUTTONS
condition|;
operator|++
name|b
control|)
block|{
if|if
condition|(
operator|(
name|SP
operator|->
name|_mouse_mask
operator|&
name|MASK_CLICK
argument_list|(
name|b
argument_list|)
operator|)
operator|&&
operator|(
name|ep
operator|->
name|bstate
operator|&
name|MASK_PRESS
argument_list|(
name|b
argument_list|)
operator|)
condition|)
block|{
name|ep
operator|->
name|bstate
operator|&=
operator|~
name|MASK_PRESS
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|ep
operator|->
name|bstate
operator||=
name|MASK_CLICK
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|merge
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|merge
condition|)
name|next
operator|->
name|id
operator|=
name|INVALID_EVENT
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|merge
condition|)
do|;
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|_nc_tracing
operator|&
name|TRACE_IEVENT
condition|)
block|{
name|_trace_slot
argument_list|(
literal|"before mouse click merge:"
argument_list|)
expr_stmt|;
name|_tracef
argument_list|(
literal|"_nc_mouse_parse: run starts at %ld, ends at %ld, count %d"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|runp
operator|-
name|SP
operator|->
name|_mouse_events
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|(
name|eventp
operator|-
name|SP
operator|->
name|_mouse_events
operator|)
operator|+
operator|(
name|EV_MAX
operator|-
literal|1
operator|)
argument_list|)
operator|%
name|EV_MAX
argument_list|,
name|runcount
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TRACE */
comment|/*      * Second pass; merge click runs.  At this point, click events are      * each followed by one invalid event. We merge click events      * forward in the queue.      *      * NOTE: There is a problem with this design!  If the application      * allows enough click events to pile up in the circular queue so      * they wrap around, it will cheerfully merge the newest forward      * into the oldest, creating a bogus doubleclick and confusing      * the queue-traversal logic rather badly.  Generally this won't      * happen, because calling getmouse() marks old events invalid and      * ineligible for merges.  The true solution to this problem would      * be to timestamp each MEVENT and perform the obvious sanity check,      * but the timer element would have to have sub-second resolution,      * which would get us into portability trouble.      */
do|do
block|{
name|MEVENT
modifier|*
name|follower
decl_stmt|;
name|merge
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|ep
operator|=
name|runp
init|;
operator|(
name|next
operator|=
name|NEXT
argument_list|(
name|ep
argument_list|)
operator|)
operator|!=
name|eventp
condition|;
name|ep
operator|=
name|next
control|)
if|if
condition|(
name|ep
operator|->
name|id
operator|!=
name|INVALID_EVENT
condition|)
block|{
if|if
condition|(
name|next
operator|->
name|id
operator|!=
name|INVALID_EVENT
condition|)
continue|continue;
name|follower
operator|=
name|NEXT
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|follower
operator|->
name|id
operator|==
name|INVALID_EVENT
condition|)
continue|continue;
comment|/* merge click events forward */
if|if
condition|(
operator|(
name|ep
operator|->
name|bstate
operator|&
name|BUTTON_CLICKED
operator|)
operator|&&
operator|(
name|follower
operator|->
name|bstate
operator|&
name|BUTTON_CLICKED
operator|)
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|1
init|;
name|b
operator|<=
name|MAX_BUTTONS
condition|;
operator|++
name|b
control|)
block|{
if|if
condition|(
operator|(
name|SP
operator|->
name|_mouse_mask
operator|&
name|MASK_DOUBLE_CLICK
argument_list|(
name|b
argument_list|)
operator|)
operator|&&
operator|(
name|follower
operator|->
name|bstate
operator|&
name|MASK_CLICK
argument_list|(
name|b
argument_list|)
operator|)
condition|)
block|{
name|follower
operator|->
name|bstate
operator|&=
operator|~
name|MASK_CLICK
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|follower
operator|->
name|bstate
operator||=
name|MASK_DOUBLE_CLICK
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|merge
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|merge
condition|)
name|ep
operator|->
name|id
operator|=
name|INVALID_EVENT
expr_stmt|;
block|}
comment|/* merge double-click events forward */
if|if
condition|(
operator|(
name|ep
operator|->
name|bstate
operator|&
name|BUTTON_DOUBLE_CLICKED
operator|)
operator|&&
operator|(
name|follower
operator|->
name|bstate
operator|&
name|BUTTON_CLICKED
operator|)
condition|)
block|{
for|for
control|(
name|b
operator|=
literal|1
init|;
name|b
operator|<=
name|MAX_BUTTONS
condition|;
operator|++
name|b
control|)
block|{
if|if
condition|(
operator|(
name|SP
operator|->
name|_mouse_mask
operator|&
name|MASK_TRIPLE_CLICK
argument_list|(
name|b
argument_list|)
operator|)
operator|&&
operator|(
name|follower
operator|->
name|bstate
operator|&
name|MASK_CLICK
argument_list|(
name|b
argument_list|)
operator|)
condition|)
block|{
name|follower
operator|->
name|bstate
operator|&=
operator|~
name|MASK_CLICK
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|follower
operator|->
name|bstate
operator||=
name|MASK_TRIPLE_CLICK
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|merge
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|merge
condition|)
name|ep
operator|->
name|id
operator|=
name|INVALID_EVENT
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|merge
condition|)
do|;
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|_nc_tracing
operator|&
name|TRACE_IEVENT
condition|)
block|{
name|_trace_slot
argument_list|(
literal|"before mouse event queue compaction:"
argument_list|)
expr_stmt|;
name|_tracef
argument_list|(
literal|"_nc_mouse_parse: run starts at %ld, ends at %ld, count %d"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|runp
operator|-
name|SP
operator|->
name|_mouse_events
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|(
name|eventp
operator|-
name|SP
operator|->
name|_mouse_events
operator|)
operator|+
operator|(
name|EV_MAX
operator|-
literal|1
operator|)
argument_list|)
operator|%
name|EV_MAX
argument_list|,
name|runcount
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TRACE */
comment|/*      * Now try to throw away trailing events flagged invalid, or that      * don't match the current event mask.      */
for|for
control|(
init|;
name|runcount
condition|;
name|prev
operator|=
name|PREV
argument_list|(
name|eventp
argument_list|)
operator|,
name|runcount
operator|--
control|)
if|if
condition|(
name|prev
operator|->
name|id
operator|==
name|INVALID_EVENT
operator|||
operator|!
operator|(
name|prev
operator|->
name|bstate
operator|&
name|SP
operator|->
name|_mouse_mask
operator|)
condition|)
block|{
name|SP
operator|->
name|_mouse_eventp
operator|=
name|eventp
operator|=
name|prev
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|_nc_tracing
operator|&
name|TRACE_IEVENT
condition|)
block|{
name|_trace_slot
argument_list|(
literal|"after mouse event queue compaction:"
argument_list|)
expr_stmt|;
name|_tracef
argument_list|(
literal|"_nc_mouse_parse: run starts at %ld, ends at %ld, count %d"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|runp
operator|-
name|SP
operator|->
name|_mouse_events
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|(
name|eventp
operator|-
name|SP
operator|->
name|_mouse_events
operator|)
operator|+
operator|(
name|EV_MAX
operator|-
literal|1
operator|)
argument_list|)
operator|%
name|EV_MAX
argument_list|,
name|runcount
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ep
operator|=
name|runp
init|;
name|ep
operator|!=
name|eventp
condition|;
name|ep
operator|=
name|NEXT
argument_list|(
name|ep
argument_list|)
control|)
if|if
condition|(
name|ep
operator|->
name|id
operator|!=
name|INVALID_EVENT
condition|)
name|TR
argument_list|(
name|MY_TRACE
argument_list|,
operator|(
literal|"_nc_mouse_parse: returning composite mouse event %s at slot %ld"
operator|,
name|_tracemouse
argument_list|(
name|ep
argument_list|)
operator|,
call|(
name|long
call|)
argument_list|(
name|ep
operator|-
name|SP
operator|->
name|_mouse_events
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TRACE */
comment|/* after all this, do we have a valid event? */
return|return
operator|(
name|PREV
argument_list|(
name|eventp
argument_list|)
operator|->
name|id
operator|!=
name|INVALID_EVENT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_nc_mouse_wrap
parameter_list|(
name|SCREEN
modifier|*
name|sp
name|GCC_UNUSED
parameter_list|)
comment|/* release mouse -- called by endwin() before shellout/exit */
block|{
name|TR
argument_list|(
name|MY_TRACE
argument_list|,
operator|(
literal|"_nc_mouse_wrap() called"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SP
operator|->
name|_mouse_type
condition|)
block|{
case|case
name|M_XTERM
case|:
if|if
condition|(
name|SP
operator|->
name|_mouse_mask
condition|)
name|mouse_activate
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|USE_GPM_SUPPORT
comment|/* GPM: pass all mouse events to next client */
case|case
name|M_GPM
case|:
if|if
condition|(
name|SP
operator|->
name|_mouse_mask
condition|)
name|mouse_activate
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|USE_SYSMOUSE
case|case
name|M_SYSMOUSE
case|:
name|mouse_activate
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|M_NONE
case|:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|_nc_mouse_resume
parameter_list|(
name|SCREEN
modifier|*
name|sp
name|GCC_UNUSED
parameter_list|)
comment|/* re-connect to mouse -- called by doupdate() after shellout */
block|{
name|TR
argument_list|(
name|MY_TRACE
argument_list|,
operator|(
literal|"_nc_mouse_resume() called"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SP
operator|->
name|_mouse_type
condition|)
block|{
case|case
name|M_XTERM
case|:
comment|/* xterm: re-enable reporting */
if|if
condition|(
name|SP
operator|->
name|_mouse_mask
condition|)
name|mouse_activate
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|USE_GPM_SUPPORT
case|case
name|M_GPM
case|:
comment|/* GPM: reclaim our event set */
if|if
condition|(
name|SP
operator|->
name|_mouse_mask
condition|)
name|mouse_activate
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|USE_SYSMOUSE
case|case
name|M_SYSMOUSE
case|:
name|mouse_activate
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|M_NONE
case|:
break|break;
block|}
block|}
end_function

begin_comment
comment|/**************************************************************************  *  * Mouse interface entry points for the API  *  **************************************************************************/
end_comment

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|getmouse
argument_list|(
argument|MEVENT * aevent
argument_list|)
end_macro

begin_comment
comment|/* grab a copy of the current mouse event */
end_comment

begin_block
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"getmouse(%p)"
argument_list|)
operator|,
name|aevent
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|aevent
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|SP
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|SP
operator|->
name|_mouse_type
operator|!=
name|M_NONE
operator|)
condition|)
block|{
name|MEVENT
modifier|*
name|eventp
init|=
name|SP
operator|->
name|_mouse_eventp
decl_stmt|;
comment|/* compute the current-event pointer */
name|MEVENT
modifier|*
name|prev
init|=
name|PREV
argument_list|(
name|eventp
argument_list|)
decl_stmt|;
comment|/* copy the event we find there */
operator|*
name|aevent
operator|=
operator|*
name|prev
expr_stmt|;
name|TR
argument_list|(
name|TRACE_IEVENT
argument_list|,
operator|(
literal|"getmouse: returning event %s from slot %ld"
operator|,
name|_tracemouse
argument_list|(
name|prev
argument_list|)
operator|,
call|(
name|long
call|)
argument_list|(
name|prev
operator|-
name|SP
operator|->
name|_mouse_events
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|prev
operator|->
name|id
operator|=
name|INVALID_EVENT
expr_stmt|;
comment|/* so the queue slot becomes free */
name|returnCode
argument_list|(
name|OK
argument_list|)
expr_stmt|;
block|}
name|returnCode
argument_list|(
name|ERR
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|ungetmouse
argument_list|(
argument|MEVENT * aevent
argument_list|)
end_macro

begin_comment
comment|/* enqueue a synthesized mouse event to be seen by the next wgetch() */
end_comment

begin_block
block|{
name|int
name|result
init|=
name|ERR
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"ungetmouse(%p)"
argument_list|)
operator|,
name|aevent
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|aevent
operator|!=
literal|0
operator|&&
name|SP
operator|!=
literal|0
condition|)
block|{
name|MEVENT
modifier|*
name|eventp
init|=
name|SP
operator|->
name|_mouse_eventp
decl_stmt|;
comment|/* stick the given event in the next-free slot */
operator|*
name|eventp
operator|=
operator|*
name|aevent
expr_stmt|;
comment|/* bump the next-free pointer into the circular list */
name|SP
operator|->
name|_mouse_eventp
operator|=
name|NEXT
argument_list|(
name|eventp
argument_list|)
expr_stmt|;
comment|/* push back the notification event on the keyboard queue */
name|result
operator|=
name|ungetch
argument_list|(
name|KEY_MOUSE
argument_list|)
expr_stmt|;
block|}
name|returnCode
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|mmask_t
argument_list|)
end_macro

begin_macro
name|mousemask
argument_list|(
argument|mmask_t newmask
argument_list|,
argument|mmask_t * oldmask
argument_list|)
end_macro

begin_comment
comment|/* set the mouse event mask */
end_comment

begin_block
block|{
name|mmask_t
name|result
init|=
literal|0
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"mousemask(%#lx,%p)"
argument_list|)
operator|,
operator|(
name|unsigned
name|long
operator|)
name|newmask
operator|,
name|oldmask
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SP
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|oldmask
condition|)
operator|*
name|oldmask
operator|=
name|SP
operator|->
name|_mouse_mask
expr_stmt|;
if|if
condition|(
name|newmask
operator|||
name|SP
operator|->
name|_mouse_initialized
condition|)
block|{
name|_nc_mouse_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|SP
operator|->
name|_mouse_type
operator|!=
name|M_NONE
condition|)
block|{
name|result
operator|=
name|newmask
operator|&
operator|(
name|REPORT_MOUSE_POSITION
operator||
name|BUTTON_ALT
operator||
name|BUTTON_CTRL
operator||
name|BUTTON_SHIFT
operator||
name|BUTTON_PRESSED
operator||
name|BUTTON_RELEASED
operator||
name|BUTTON_CLICKED
operator||
name|BUTTON_DOUBLE_CLICKED
operator||
name|BUTTON_TRIPLE_CLICKED
operator|)
expr_stmt|;
name|mouse_activate
argument_list|(
call|(
name|bool
call|)
argument_list|(
name|result
operator|!=
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|SP
operator|->
name|_mouse_mask
operator|=
name|result
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|oldmask
condition|)
operator|*
name|oldmask
operator|=
name|SP
operator|->
name|_mouse_mask
expr_stmt|;
block|}
name|returnBits
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|bool
argument_list|)
end_macro

begin_macro
name|wenclose
argument_list|(
argument|const WINDOW *win
argument_list|,
argument|int y
argument_list|,
argument|int x
argument_list|)
end_macro

begin_comment
comment|/* check to see if given window encloses given screen location */
end_comment

begin_block
block|{
name|bool
name|result
init|=
name|FALSE
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"wenclose(%p,%d,%d)"
argument_list|)
operator|,
name|win
operator|,
name|y
operator|,
name|x
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|win
operator|!=
literal|0
condition|)
block|{
name|y
operator|-=
name|win
operator|->
name|_yoffset
expr_stmt|;
name|result
operator|=
operator|(
operator|(
name|win
operator|->
name|_begy
operator|<=
name|y
operator|&&
name|win
operator|->
name|_begx
operator|<=
name|x
operator|&&
operator|(
name|win
operator|->
name|_begx
operator|+
name|win
operator|->
name|_maxx
operator|)
operator|>=
name|x
operator|&&
operator|(
name|win
operator|->
name|_begy
operator|+
name|win
operator|->
name|_maxy
operator|)
operator|>=
name|y
operator|)
condition|?
name|TRUE
else|:
name|FALSE
operator|)
expr_stmt|;
block|}
name|returnBool
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|mouseinterval
argument_list|(
argument|int maxclick
argument_list|)
end_macro

begin_comment
comment|/* set the maximum mouse interval within which to recognize a click */
end_comment

begin_block
block|{
name|int
name|oldval
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"mouseinterval(%d)"
argument_list|)
operator|,
name|maxclick
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SP
operator|!=
literal|0
condition|)
block|{
name|oldval
operator|=
name|SP
operator|->
name|_maxclick
expr_stmt|;
if|if
condition|(
name|maxclick
operator|>=
literal|0
condition|)
name|SP
operator|->
name|_maxclick
operator|=
name|maxclick
expr_stmt|;
block|}
else|else
block|{
name|oldval
operator|=
name|DEFAULT_MAXCLICK
expr_stmt|;
block|}
name|returnCode
argument_list|(
name|oldval
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* This may be used by other routines to ask for the existence of mouse    support */
end_comment

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|_nc_has_mouse
argument_list|(
argument|void
argument_list|)
end_macro

begin_block
block|{
return|return
operator|(
name|SP
operator|->
name|_mouse_type
operator|==
name|M_NONE
condition|?
literal|0
else|:
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|bool
argument_list|)
end_macro

begin_macro
name|wmouse_trafo
argument_list|(
argument|const WINDOW *win
argument_list|,
argument|int *pY
argument_list|,
argument|int *pX
argument_list|,
argument|bool to_screen
argument_list|)
end_macro

begin_block
block|{
name|bool
name|result
init|=
name|FALSE
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"wmouse_trafo(%p,%p,%p,%d)"
argument_list|)
operator|,
name|win
operator|,
name|pY
operator|,
name|pX
operator|,
name|to_screen
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|win
operator|&&
name|pY
operator|&&
name|pX
condition|)
block|{
name|int
name|y
init|=
operator|*
name|pY
decl_stmt|;
name|int
name|x
init|=
operator|*
name|pX
decl_stmt|;
if|if
condition|(
name|to_screen
condition|)
block|{
name|y
operator|+=
name|win
operator|->
name|_begy
operator|+
name|win
operator|->
name|_yoffset
expr_stmt|;
name|x
operator|+=
name|win
operator|->
name|_begx
expr_stmt|;
if|if
condition|(
name|wenclose
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
condition|)
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|wenclose
argument_list|(
name|win
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
condition|)
block|{
name|y
operator|-=
operator|(
name|win
operator|->
name|_begy
operator|+
name|win
operator|->
name|_yoffset
operator|)
expr_stmt|;
name|x
operator|-=
name|win
operator|->
name|_begx
expr_stmt|;
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|result
condition|)
block|{
operator|*
name|pX
operator|=
name|x
expr_stmt|;
operator|*
name|pY
operator|=
name|y
expr_stmt|;
block|}
block|}
name|returnBool
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

