begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mpz_probab_prime_p --    An implementation of the probabilistic primality test found in Knuth's    Seminumerical Algorithms book.  If the function mpz_probab_prime_p()    returns 0 then n is not prime.  If it returns 1, then n is 'probably'    prime.  The probability of a false positive is (1/4)**reps, where    reps is the number of internal passes of the probabilistic algorithm.    Knuth indicates that 25 passes are reasonable.  Copyright (C) 1991, 1993, 1994 Free Software Foundation, Inc. Contributed by John Amanatides.  This file is part of the GNU MP Library.  The GNU MP Library is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  The GNU MP Library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with the GNU MP Library; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_include
include|#
directive|include
file|"gmp.h"
end_include

begin_function
specifier|static
name|int
name|possibly_prime
parameter_list|(
name|n
parameter_list|,
name|n_minus_1
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|q
parameter_list|,
name|k
parameter_list|)
name|mpz_srcptr
name|n
decl_stmt|;
name|mpz_srcptr
name|n_minus_1
decl_stmt|;
name|mpz_ptr
name|x
decl_stmt|;
name|mpz_ptr
name|y
decl_stmt|;
name|mpz_srcptr
name|q
decl_stmt|;
name|unsigned
name|long
name|int
name|k
decl_stmt|;
block|{
name|unsigned
name|long
name|int
name|i
decl_stmt|;
comment|/* find random x s.t. 1< x< n */
do|do
block|{
name|mpz_random
argument_list|(
name|x
argument_list|,
name|mpz_size
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|mpz_mmod
argument_list|(
name|x
argument_list|,
name|x
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|mpz_cmp_ui
argument_list|(
name|x
argument_list|,
literal|1L
argument_list|)
operator|<=
literal|0
condition|)
do|;
name|mpz_powm
argument_list|(
name|y
argument_list|,
name|x
argument_list|,
name|q
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpz_cmp_ui
argument_list|(
name|y
argument_list|,
literal|1L
argument_list|)
operator|==
literal|0
operator|||
name|mpz_cmp
argument_list|(
name|y
argument_list|,
name|n_minus_1
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|k
condition|;
name|i
operator|++
control|)
block|{
name|mpz_powm_ui
argument_list|(
name|y
argument_list|,
name|y
argument_list|,
literal|2L
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpz_cmp
argument_list|(
name|y
argument_list|,
name|n_minus_1
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|mpz_cmp_ui
argument_list|(
name|y
argument_list|,
literal|1L
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
if|#
directive|if
name|__STDC__
name|mpz_probab_prime_p
parameter_list|(
name|mpz_srcptr
name|m
parameter_list|,
name|int
name|reps
parameter_list|)
else|#
directive|else
function|mpz_probab_prime_p
parameter_list|(
name|m
parameter_list|,
name|reps
parameter_list|)
name|mpz_srcptr
name|m
decl_stmt|;
name|int
name|reps
decl_stmt|;
endif|#
directive|endif
block|{
name|mpz_t
name|n
decl_stmt|,
name|n_minus_1
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|,
name|q
decl_stmt|;
name|int
name|i
decl_stmt|,
name|is_prime
decl_stmt|;
name|unsigned
name|long
name|int
name|k
decl_stmt|;
name|mpz_init
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* Take the absolute value of M, to handle positive and negative primes.  */
name|mpz_abs
argument_list|(
name|n
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpz_cmp_ui
argument_list|(
name|n
argument_list|,
literal|3L
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|mpz_clear
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
name|mpz_cmp_ui
argument_list|(
name|n
argument_list|,
literal|1L
argument_list|)
operator|>
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|mpz_get_ui
argument_list|(
name|n
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|mpz_clear
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* even */
block|}
name|mpz_init
argument_list|(
name|n_minus_1
argument_list|)
expr_stmt|;
name|mpz_sub_ui
argument_list|(
name|n_minus_1
argument_list|,
name|n
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|mpz_init
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|mpz_init
argument_list|(
name|y
argument_list|)
expr_stmt|;
comment|/* find q and k, s.t.  n = 1 + 2**k * q */
name|mpz_init_set
argument_list|(
name|q
argument_list|,
name|n_minus_1
argument_list|)
expr_stmt|;
name|k
operator|=
name|mpz_scan1
argument_list|(
name|q
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mpz_tdiv_q_2exp
argument_list|(
name|q
argument_list|,
name|q
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|is_prime
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reps
operator|&&
name|is_prime
condition|;
name|i
operator|++
control|)
name|is_prime
operator|&=
name|possibly_prime
argument_list|(
name|n
argument_list|,
name|n_minus_1
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|q
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|mpz_clear
argument_list|(
name|n_minus_1
argument_list|)
expr_stmt|;
name|mpz_clear
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|mpz_clear
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|mpz_clear
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|mpz_clear
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return
name|is_prime
return|;
block|}
end_function

end_unit

