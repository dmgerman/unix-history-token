begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mpz_set_str(mp_dest, string, base) -- Convert the \0-terminated    string STRING in base BASE to multiple precision integer in    MP_DEST.  Allow white space in the string.  If BASE == 0 determine    the base in the C standard way, i.e.  0xhh...h means base 16,    0oo...o means base 8, otherwise assume base 10.  Copyright (C) 1991, 1993, 1994, Free Software Foundation, Inc.  This file is part of the GNU MP Library.  The GNU MP Library is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  The GNU MP Library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with the GNU MP Library; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"gmp.h"
end_include

begin_include
include|#
directive|include
file|"gmp-impl.h"
end_include

begin_include
include|#
directive|include
file|"longlong.h"
end_include

begin_function
specifier|static
name|int
name|digit_value_in_base
parameter_list|(
name|c
parameter_list|,
name|base
parameter_list|)
name|int
name|c
decl_stmt|;
name|int
name|base
decl_stmt|;
block|{
name|int
name|digit
decl_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
name|digit
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|islower
argument_list|(
name|c
argument_list|)
condition|)
name|digit
operator|=
name|c
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
name|digit
operator|=
name|c
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
else|else
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|digit
operator|<
name|base
condition|)
return|return
name|digit
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
if|#
directive|if
name|__STDC__
name|mpz_set_str
parameter_list|(
name|mpz_ptr
name|x
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|base
parameter_list|)
else|#
directive|else
function|mpz_set_str
parameter_list|(
name|x
parameter_list|,
name|str
parameter_list|,
name|base
parameter_list|)
name|mpz_ptr
name|x
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|base
decl_stmt|;
endif|#
directive|endif
block|{
name|size_t
name|str_size
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|begs
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|mp_size_t
name|xsize
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|negative
decl_stmt|;
name|TMP_DECL
argument_list|(
name|marker
argument_list|)
expr_stmt|;
comment|/* Skip whitespace.  */
do|do
name|c
operator|=
operator|*
name|str
operator|++
expr_stmt|;
do|while
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
do|;
name|negative
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
block|{
name|negative
operator|=
literal|1
expr_stmt|;
name|c
operator|=
operator|*
name|str
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|digit_value_in_base
argument_list|(
name|c
argument_list|,
name|base
operator|==
literal|0
condition|?
literal|10
else|:
name|base
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* error if no digits */
comment|/* If BASE is 0, try to find out the base by looking at the initial      characters.  */
if|if
condition|(
name|base
operator|==
literal|0
condition|)
block|{
name|base
operator|=
literal|10
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'0'
condition|)
block|{
name|base
operator|=
literal|8
expr_stmt|;
name|c
operator|=
operator|*
name|str
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'x'
operator|||
name|c
operator|==
literal|'X'
condition|)
block|{
name|base
operator|=
literal|16
expr_stmt|;
name|c
operator|=
operator|*
name|str
operator|++
expr_stmt|;
block|}
block|}
block|}
name|TMP_MARK
argument_list|(
name|marker
argument_list|)
expr_stmt|;
name|str_size
operator|=
name|strlen
argument_list|(
name|str
operator|-
literal|1
argument_list|)
expr_stmt|;
name|s
operator|=
name|begs
operator|=
operator|(
name|char
operator|*
operator|)
name|TMP_ALLOC
argument_list|(
name|str_size
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|str_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|int
name|dig
init|=
name|digit_value_in_base
argument_list|(
name|c
argument_list|,
name|base
argument_list|)
decl_stmt|;
if|if
condition|(
name|dig
operator|<
literal|0
condition|)
block|{
name|TMP_FREE
argument_list|(
name|marker
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
operator|*
name|s
operator|++
operator|=
name|dig
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|str
operator|++
expr_stmt|;
block|}
name|str_size
operator|=
name|s
operator|-
name|begs
expr_stmt|;
name|xsize
operator|=
name|str_size
operator|/
name|__mp_bases
index|[
name|base
index|]
operator|.
name|chars_per_limb
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|_mp_alloc
operator|<
name|xsize
condition|)
name|_mpz_realloc
argument_list|(
name|x
argument_list|,
name|xsize
argument_list|)
expr_stmt|;
name|xsize
operator|=
name|mpn_set_str
argument_list|(
name|x
operator|->
name|_mp_d
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|begs
argument_list|,
name|str_size
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|x
operator|->
name|_mp_size
operator|=
name|negative
condition|?
operator|-
name|xsize
else|:
name|xsize
expr_stmt|;
name|TMP_FREE
argument_list|(
name|marker
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

