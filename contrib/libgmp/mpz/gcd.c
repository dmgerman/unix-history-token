begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mpz/gcd.c:   Calculate the greatest common divisor of two integers.  Copyright (C) 1991, 1993, 1994, 1996 Free Software Foundation, Inc.  This file is part of the GNU MP Library.  The GNU MP Library is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  The GNU MP Library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with the GNU MP Library; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_include
include|#
directive|include
file|"gmp.h"
end_include

begin_include
include|#
directive|include
file|"gmp-impl.h"
end_include

begin_include
include|#
directive|include
file|"longlong.h"
end_include

begin_function_decl
name|void
modifier|*
name|_mpz_realloc
parameter_list|()
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|BERKELEY_MP
end_ifndef

begin_decl_stmt
name|void
if|#
directive|if
name|__STDC__
name|mpz_gcd
argument_list|(
name|mpz_ptr
name|g
argument_list|,
name|mpz_srcptr
name|u
argument_list|,
name|mpz_srcptr
name|v
argument_list|)
else|#
directive|else
name|mpz_gcd
argument_list|(
name|g
argument_list|,
name|u
argument_list|,
name|v
argument_list|)
name|mpz_ptr
name|g
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|mpz_srcptr
name|u
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|mpz_srcptr
name|v
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* BERKELEY_MP */
end_comment

begin_function
name|void
if|#
directive|if
name|__STDC__
name|gcd
parameter_list|(
name|mpz_srcptr
name|u
parameter_list|,
name|mpz_srcptr
name|v
parameter_list|,
name|mpz_ptr
name|g
parameter_list|)
else|#
directive|else
function|gcd
parameter_list|(
name|u
parameter_list|,
name|v
parameter_list|,
name|g
parameter_list|)
name|mpz_ptr
name|g
decl_stmt|;
name|mpz_srcptr
name|u
decl_stmt|;
name|mpz_srcptr
name|v
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* BERKELEY_MP */
block|{
name|unsigned
name|long
name|int
name|g_zero_bits
decl_stmt|,
name|u_zero_bits
decl_stmt|,
name|v_zero_bits
decl_stmt|;
name|mp_size_t
name|g_zero_limbs
decl_stmt|,
name|u_zero_limbs
decl_stmt|,
name|v_zero_limbs
decl_stmt|;
name|mp_ptr
name|tp
decl_stmt|;
name|mp_ptr
name|up
init|=
name|u
operator|->
name|_mp_d
decl_stmt|;
name|mp_size_t
name|usize
init|=
name|ABS
argument_list|(
name|u
operator|->
name|_mp_size
argument_list|)
decl_stmt|;
name|mp_ptr
name|vp
init|=
name|v
operator|->
name|_mp_d
decl_stmt|;
name|mp_size_t
name|vsize
init|=
name|ABS
argument_list|(
name|v
operator|->
name|_mp_size
argument_list|)
decl_stmt|;
name|mp_size_t
name|gsize
decl_stmt|;
name|TMP_DECL
argument_list|(
name|marker
argument_list|)
expr_stmt|;
comment|/* GCD(0, V) == V.  */
if|if
condition|(
name|usize
operator|==
literal|0
condition|)
block|{
name|g
operator|->
name|_mp_size
operator|=
name|vsize
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|v
condition|)
return|return;
if|if
condition|(
name|g
operator|->
name|_mp_alloc
operator|<
name|vsize
condition|)
name|_mpz_realloc
argument_list|(
name|g
argument_list|,
name|vsize
argument_list|)
expr_stmt|;
name|MPN_COPY
argument_list|(
name|g
operator|->
name|_mp_d
argument_list|,
name|vp
argument_list|,
name|vsize
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* GCD(U, 0) == U.  */
if|if
condition|(
name|vsize
operator|==
literal|0
condition|)
block|{
name|g
operator|->
name|_mp_size
operator|=
name|usize
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|u
condition|)
return|return;
if|if
condition|(
name|g
operator|->
name|_mp_alloc
operator|<
name|usize
condition|)
name|_mpz_realloc
argument_list|(
name|g
argument_list|,
name|usize
argument_list|)
expr_stmt|;
name|MPN_COPY
argument_list|(
name|g
operator|->
name|_mp_d
argument_list|,
name|up
argument_list|,
name|usize
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|usize
operator|==
literal|1
condition|)
block|{
name|g
operator|->
name|_mp_size
operator|=
literal|1
expr_stmt|;
name|g
operator|->
name|_mp_d
index|[
literal|0
index|]
operator|=
name|mpn_gcd_1
argument_list|(
name|vp
argument_list|,
name|vsize
argument_list|,
name|up
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|vsize
operator|==
literal|1
condition|)
block|{
name|g
operator|->
name|_mp_size
operator|=
literal|1
expr_stmt|;
name|g
operator|->
name|_mp_d
index|[
literal|0
index|]
operator|=
name|mpn_gcd_1
argument_list|(
name|up
argument_list|,
name|usize
argument_list|,
name|vp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|TMP_MARK
argument_list|(
name|marker
argument_list|)
expr_stmt|;
comment|/*  Eliminate low zero bits from U and V and move to temporary storage.  */
while|while
condition|(
operator|*
name|up
operator|==
literal|0
condition|)
name|up
operator|++
expr_stmt|;
name|u_zero_limbs
operator|=
name|up
operator|-
name|u
operator|->
name|_mp_d
expr_stmt|;
name|usize
operator|-=
name|u_zero_limbs
expr_stmt|;
name|count_trailing_zeros
argument_list|(
name|u_zero_bits
argument_list|,
operator|*
name|up
argument_list|)
expr_stmt|;
name|tp
operator|=
name|up
expr_stmt|;
name|up
operator|=
operator|(
name|mp_ptr
operator|)
name|TMP_ALLOC
argument_list|(
name|usize
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
if|if
condition|(
name|u_zero_bits
operator|!=
literal|0
condition|)
block|{
name|mpn_rshift
argument_list|(
name|up
argument_list|,
name|tp
argument_list|,
name|usize
argument_list|,
name|u_zero_bits
argument_list|)
expr_stmt|;
name|usize
operator|-=
name|up
index|[
name|usize
operator|-
literal|1
index|]
operator|==
literal|0
expr_stmt|;
block|}
else|else
name|MPN_COPY
argument_list|(
name|up
argument_list|,
name|tp
argument_list|,
name|usize
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|vp
operator|==
literal|0
condition|)
name|vp
operator|++
expr_stmt|;
name|v_zero_limbs
operator|=
name|vp
operator|-
name|v
operator|->
name|_mp_d
expr_stmt|;
name|vsize
operator|-=
name|v_zero_limbs
expr_stmt|;
name|count_trailing_zeros
argument_list|(
name|v_zero_bits
argument_list|,
operator|*
name|vp
argument_list|)
expr_stmt|;
name|tp
operator|=
name|vp
expr_stmt|;
name|vp
operator|=
operator|(
name|mp_ptr
operator|)
name|TMP_ALLOC
argument_list|(
name|vsize
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
if|if
condition|(
name|v_zero_bits
operator|!=
literal|0
condition|)
block|{
name|mpn_rshift
argument_list|(
name|vp
argument_list|,
name|tp
argument_list|,
name|vsize
argument_list|,
name|v_zero_bits
argument_list|)
expr_stmt|;
name|vsize
operator|-=
name|vp
index|[
name|vsize
operator|-
literal|1
index|]
operator|==
literal|0
expr_stmt|;
block|}
else|else
name|MPN_COPY
argument_list|(
name|vp
argument_list|,
name|tp
argument_list|,
name|vsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|u_zero_limbs
operator|>
name|v_zero_limbs
condition|)
block|{
name|g_zero_limbs
operator|=
name|v_zero_limbs
expr_stmt|;
name|g_zero_bits
operator|=
name|v_zero_bits
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u_zero_limbs
operator|<
name|v_zero_limbs
condition|)
block|{
name|g_zero_limbs
operator|=
name|u_zero_limbs
expr_stmt|;
name|g_zero_bits
operator|=
name|u_zero_bits
expr_stmt|;
block|}
else|else
comment|/*  Equal.  */
block|{
name|g_zero_limbs
operator|=
name|u_zero_limbs
expr_stmt|;
name|g_zero_bits
operator|=
name|MIN
argument_list|(
name|u_zero_bits
argument_list|,
name|v_zero_bits
argument_list|)
expr_stmt|;
block|}
comment|/*  Call mpn_gcd.  The 1st argument must not have more bits than the 2nd.  */
name|vsize
operator|=
operator|(
name|usize
operator|<
name|vsize
operator|||
operator|(
name|usize
operator|==
name|vsize
operator|&&
name|up
index|[
name|usize
operator|-
literal|1
index|]
operator|<
name|vp
index|[
name|vsize
operator|-
literal|1
index|]
operator|)
operator|)
condition|?
name|mpn_gcd
argument_list|(
name|vp
argument_list|,
name|up
argument_list|,
name|usize
argument_list|,
name|vp
argument_list|,
name|vsize
argument_list|)
else|:
name|mpn_gcd
argument_list|(
name|vp
argument_list|,
name|vp
argument_list|,
name|vsize
argument_list|,
name|up
argument_list|,
name|usize
argument_list|)
expr_stmt|;
comment|/*  Here G<-- V<< (g_zero_limbs*BITS_PER_MP_LIMB + g_zero_bits).  */
name|gsize
operator|=
name|vsize
operator|+
name|g_zero_limbs
expr_stmt|;
if|if
condition|(
name|g_zero_bits
operator|!=
literal|0
condition|)
block|{
name|mp_limb_t
name|cy_limb
decl_stmt|;
name|gsize
operator|+=
operator|(
name|vp
index|[
name|vsize
operator|-
literal|1
index|]
operator|>>
operator|(
name|BITS_PER_MP_LIMB
operator|-
name|g_zero_bits
operator|)
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|_mp_alloc
operator|<
name|gsize
condition|)
name|_mpz_realloc
argument_list|(
name|g
argument_list|,
name|gsize
argument_list|)
expr_stmt|;
name|MPN_ZERO
argument_list|(
name|g
operator|->
name|_mp_d
argument_list|,
name|g_zero_limbs
argument_list|)
expr_stmt|;
name|tp
operator|=
name|g
operator|->
name|_mp_d
operator|+
name|g_zero_limbs
expr_stmt|;
name|cy_limb
operator|=
name|mpn_lshift
argument_list|(
name|tp
argument_list|,
name|vp
argument_list|,
name|vsize
argument_list|,
name|g_zero_bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|cy_limb
operator|!=
literal|0
condition|)
name|tp
index|[
name|vsize
index|]
operator|=
name|cy_limb
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|g
operator|->
name|_mp_alloc
operator|<
name|gsize
condition|)
name|_mpz_realloc
argument_list|(
name|g
argument_list|,
name|gsize
argument_list|)
expr_stmt|;
name|MPN_ZERO
argument_list|(
name|g
operator|->
name|_mp_d
argument_list|,
name|g_zero_limbs
argument_list|)
expr_stmt|;
name|MPN_COPY
argument_list|(
name|g
operator|->
name|_mp_d
operator|+
name|g_zero_limbs
argument_list|,
name|vp
argument_list|,
name|vsize
argument_list|)
expr_stmt|;
block|}
name|g
operator|->
name|_mp_size
operator|=
name|gsize
expr_stmt|;
name|TMP_FREE
argument_list|(
name|marker
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

