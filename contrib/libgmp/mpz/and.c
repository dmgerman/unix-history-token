begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mpz_and -- Logical and.  Copyright (C) 1991, 1993, 1994, 1996 Free Software Foundation, Inc.  This file is part of the GNU MP Library.  The GNU MP Library is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  The GNU MP Library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with the GNU MP Library; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_include
include|#
directive|include
file|"gmp.h"
end_include

begin_include
include|#
directive|include
file|"gmp-impl.h"
end_include

begin_function
name|void
if|#
directive|if
name|__STDC__
name|mpz_and
parameter_list|(
name|mpz_ptr
name|res
parameter_list|,
name|mpz_srcptr
name|op1
parameter_list|,
name|mpz_srcptr
name|op2
parameter_list|)
else|#
directive|else
function|mpz_and
parameter_list|(
name|res
parameter_list|,
name|op1
parameter_list|,
name|op2
parameter_list|)
name|mpz_ptr
name|res
decl_stmt|;
name|mpz_srcptr
name|op1
decl_stmt|;
name|mpz_srcptr
name|op2
decl_stmt|;
endif|#
directive|endif
block|{
name|mp_srcptr
name|op1_ptr
decl_stmt|,
name|op2_ptr
decl_stmt|;
name|mp_size_t
name|op1_size
decl_stmt|,
name|op2_size
decl_stmt|;
name|mp_ptr
name|res_ptr
decl_stmt|;
name|mp_size_t
name|res_size
decl_stmt|;
name|mp_size_t
name|i
decl_stmt|;
name|TMP_DECL
argument_list|(
name|marker
argument_list|)
expr_stmt|;
name|TMP_MARK
argument_list|(
name|marker
argument_list|)
expr_stmt|;
name|op1_size
operator|=
name|op1
operator|->
name|_mp_size
expr_stmt|;
name|op2_size
operator|=
name|op2
operator|->
name|_mp_size
expr_stmt|;
name|op1_ptr
operator|=
name|op1
operator|->
name|_mp_d
expr_stmt|;
name|op2_ptr
operator|=
name|op2
operator|->
name|_mp_d
expr_stmt|;
name|res_ptr
operator|=
name|res
operator|->
name|_mp_d
expr_stmt|;
if|if
condition|(
name|op1_size
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|op2_size
operator|>=
literal|0
condition|)
block|{
name|res_size
operator|=
name|MIN
argument_list|(
name|op1_size
argument_list|,
name|op2_size
argument_list|)
expr_stmt|;
comment|/* First loop finds the size of the result.  */
for|for
control|(
name|i
operator|=
name|res_size
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|(
name|op1_ptr
index|[
name|i
index|]
operator|&
name|op2_ptr
index|[
name|i
index|]
operator|)
operator|!=
literal|0
condition|)
break|break;
name|res_size
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|/* Handle allocation, now then we know exactly how much space is 	     needed for the result.  */
if|if
condition|(
name|res
operator|->
name|_mp_alloc
operator|<
name|res_size
condition|)
block|{
name|_mpz_realloc
argument_list|(
name|res
argument_list|,
name|res_size
argument_list|)
expr_stmt|;
name|op1_ptr
operator|=
name|op1
operator|->
name|_mp_d
expr_stmt|;
name|op2_ptr
operator|=
name|op2
operator|->
name|_mp_d
expr_stmt|;
name|res_ptr
operator|=
name|res
operator|->
name|_mp_d
expr_stmt|;
block|}
comment|/* Second loop computes the real result.  */
for|for
control|(
name|i
operator|=
name|res_size
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|res_ptr
index|[
name|i
index|]
operator|=
name|op1_ptr
index|[
name|i
index|]
operator|&
name|op2_ptr
index|[
name|i
index|]
expr_stmt|;
name|res
operator|->
name|_mp_size
operator|=
name|res_size
expr_stmt|;
return|return;
block|}
else|else
comment|/* op2_size< 0 */
block|{
comment|/* Fall through to the code at the end of the function.  */
block|}
block|}
else|else
block|{
if|if
condition|(
name|op2_size
operator|<
literal|0
condition|)
block|{
name|mp_ptr
name|opx
decl_stmt|;
name|mp_limb_t
name|cy
decl_stmt|;
name|mp_size_t
name|res_alloc
decl_stmt|;
comment|/* Both operands are negative, so will be the result. 	     -((-OP1)& (-OP2)) = -(~(OP1 - 1)& ~(OP2 - 1)) = 	     = ~(~(OP1 - 1)& ~(OP2 - 1)) + 1 = 	     = ((OP1 - 1) | (OP2 - 1)) + 1      */
comment|/* It might seem as we could end up with an (invalid) result with 	     a leading zero-limb here when one of the operands is of the 	     type 1,,0,,..,,.0.  But some analysis shows that we surely 	     would get carry into the zero-limb in this situation...  */
name|op1_size
operator|=
operator|-
name|op1_size
expr_stmt|;
name|op2_size
operator|=
operator|-
name|op2_size
expr_stmt|;
name|res_alloc
operator|=
literal|1
operator|+
name|MAX
argument_list|(
name|op1_size
argument_list|,
name|op2_size
argument_list|)
expr_stmt|;
name|opx
operator|=
operator|(
name|mp_ptr
operator|)
name|TMP_ALLOC
argument_list|(
name|op1_size
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
name|mpn_sub_1
argument_list|(
name|opx
argument_list|,
name|op1_ptr
argument_list|,
name|op1_size
argument_list|,
operator|(
name|mp_limb_t
operator|)
literal|1
argument_list|)
expr_stmt|;
name|op1_ptr
operator|=
name|opx
expr_stmt|;
name|opx
operator|=
operator|(
name|mp_ptr
operator|)
name|TMP_ALLOC
argument_list|(
name|op2_size
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
name|mpn_sub_1
argument_list|(
name|opx
argument_list|,
name|op2_ptr
argument_list|,
name|op2_size
argument_list|,
operator|(
name|mp_limb_t
operator|)
literal|1
argument_list|)
expr_stmt|;
name|op2_ptr
operator|=
name|opx
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|_mp_alloc
operator|<
name|res_alloc
condition|)
block|{
name|_mpz_realloc
argument_list|(
name|res
argument_list|,
name|res_alloc
argument_list|)
expr_stmt|;
name|res_ptr
operator|=
name|res
operator|->
name|_mp_d
expr_stmt|;
comment|/* Don't re-read OP1_PTR and OP2_PTR.  They point to 		 temporary space--never to the space RES->_mp_D used 		 to point to before reallocation.  */
block|}
if|if
condition|(
name|op1_size
operator|>=
name|op2_size
condition|)
block|{
name|MPN_COPY
argument_list|(
name|res_ptr
operator|+
name|op2_size
argument_list|,
name|op1_ptr
operator|+
name|op2_size
argument_list|,
name|op1_size
operator|-
name|op2_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|op2_size
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|res_ptr
index|[
name|i
index|]
operator|=
name|op1_ptr
index|[
name|i
index|]
operator||
name|op2_ptr
index|[
name|i
index|]
expr_stmt|;
name|res_size
operator|=
name|op1_size
expr_stmt|;
block|}
else|else
block|{
name|MPN_COPY
argument_list|(
name|res_ptr
operator|+
name|op1_size
argument_list|,
name|op2_ptr
operator|+
name|op1_size
argument_list|,
name|op2_size
operator|-
name|op1_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|op1_size
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|res_ptr
index|[
name|i
index|]
operator|=
name|op1_ptr
index|[
name|i
index|]
operator||
name|op2_ptr
index|[
name|i
index|]
expr_stmt|;
name|res_size
operator|=
name|op2_size
expr_stmt|;
block|}
name|cy
operator|=
name|mpn_add_1
argument_list|(
name|res_ptr
argument_list|,
name|res_ptr
argument_list|,
name|res_size
argument_list|,
operator|(
name|mp_limb_t
operator|)
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cy
condition|)
block|{
name|res_ptr
index|[
name|res_size
index|]
operator|=
name|cy
expr_stmt|;
name|res_size
operator|++
expr_stmt|;
block|}
name|res
operator|->
name|_mp_size
operator|=
operator|-
name|res_size
expr_stmt|;
name|TMP_FREE
argument_list|(
name|marker
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* We should compute -OP1& OP2.  Swap OP1 and OP2 and fall 	     through to the code that handles OP1& -OP2.  */
block|{
name|mpz_srcptr
name|t
init|=
name|op1
decl_stmt|;
name|op1
operator|=
name|op2
expr_stmt|;
name|op2
operator|=
name|t
expr_stmt|;
block|}
block|{
name|mp_srcptr
name|t
init|=
name|op1_ptr
decl_stmt|;
name|op1_ptr
operator|=
name|op2_ptr
expr_stmt|;
name|op2_ptr
operator|=
name|t
expr_stmt|;
block|}
block|{
name|mp_size_t
name|t
init|=
name|op1_size
decl_stmt|;
name|op1_size
operator|=
name|op2_size
expr_stmt|;
name|op2_size
operator|=
name|t
expr_stmt|;
block|}
block|}
block|}
block|{
if|#
directive|if
name|ANDNEW
name|mp_size_t
name|op2_lim
decl_stmt|;
name|mp_size_t
name|count
decl_stmt|;
comment|/* OP2 must be negated as with infinite precision.         Scan from the low end for a non-zero limb.  The first non-zero        limb is simply negated (two's complement).  Any subsequent        limbs are one's complemented.  Of course, we don't need to        handle more limbs than there are limbs in the other, positive        operand as the result for those limbs is going to become zero        anyway.  */
comment|/* Scan for the least significant. non-zero OP2 limb, and zero the        result meanwhile for those limb positions.  (We will surely        find a non-zero limb, so we can write the loop with one        termination condition only.)  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|op2_ptr
index|[
name|i
index|]
operator|==
literal|0
condition|;
name|i
operator|++
control|)
name|res_ptr
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|op2_lim
operator|=
name|i
expr_stmt|;
name|op2_size
operator|=
operator|-
name|op2_size
expr_stmt|;
if|if
condition|(
name|op1_size
operator|<=
name|op2_size
condition|)
block|{
comment|/* The ones-extended OP2 is>= than the zero-extended OP1. 	   RES_SIZE<= OP1_SIZE.  Find the exact size.  */
for|for
control|(
name|i
operator|=
name|op1_size
operator|-
literal|1
init|;
name|i
operator|>
name|op2_lim
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|(
name|op1_ptr
index|[
name|i
index|]
operator|&
operator|~
name|op2_ptr
index|[
name|i
index|]
operator|)
operator|!=
literal|0
condition|)
break|break;
name|res_size
operator|=
name|i
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|res_size
operator|-
literal|1
init|;
name|i
operator|>
name|op2_lim
condition|;
name|i
operator|--
control|)
name|res_ptr
index|[
name|i
index|]
operator|=
name|op1_ptr
index|[
name|i
index|]
operator|&
operator|~
name|op2_ptr
index|[
name|i
index|]
expr_stmt|;
name|res_ptr
index|[
name|op2_lim
index|]
operator|=
name|op1_ptr
index|[
name|op2_lim
index|]
operator|&
operator|-
name|op2_ptr
index|[
name|op2_lim
index|]
expr_stmt|;
comment|/* Yes, this *can* happen!  */
name|MPN_NORMALIZE
argument_list|(
name|res_ptr
argument_list|,
name|res_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The ones-extended OP2 is< than the zero-extended OP1. 	   RES_SIZE == OP1_SIZE, since OP1 is normalized.  */
name|res_size
operator|=
name|op1_size
expr_stmt|;
name|MPN_COPY
argument_list|(
name|res_ptr
operator|+
name|op2_size
argument_list|,
name|op1_ptr
operator|+
name|op2_size
argument_list|,
name|op1_size
operator|-
name|op2_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|op2_size
operator|-
literal|1
init|;
name|i
operator|>
name|op2_lim
condition|;
name|i
operator|--
control|)
name|res_ptr
index|[
name|i
index|]
operator|=
name|op1_ptr
index|[
name|i
index|]
operator|&
operator|~
name|op2_ptr
index|[
name|i
index|]
expr_stmt|;
name|res_ptr
index|[
name|op2_lim
index|]
operator|=
name|op1_ptr
index|[
name|op2_lim
index|]
operator|&
operator|-
name|op2_ptr
index|[
name|op2_lim
index|]
expr_stmt|;
block|}
name|res
operator|->
name|_mp_size
operator|=
name|res_size
expr_stmt|;
else|#
directive|else
comment|/* OP1 is positive and zero-extended,        OP2 is negative and ones-extended.        The result will be positive.        OP1& -OP2 = OP1& ~(OP2 - 1).  */
name|mp_ptr
name|opx
decl_stmt|;
name|op2_size
operator|=
operator|-
name|op2_size
expr_stmt|;
name|opx
operator|=
operator|(
name|mp_ptr
operator|)
name|TMP_ALLOC
argument_list|(
name|op2_size
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
name|mpn_sub_1
argument_list|(
name|opx
argument_list|,
name|op2_ptr
argument_list|,
name|op2_size
argument_list|,
operator|(
name|mp_limb_t
operator|)
literal|1
argument_list|)
expr_stmt|;
name|op2_ptr
operator|=
name|opx
expr_stmt|;
if|if
condition|(
name|op1_size
operator|>
name|op2_size
condition|)
block|{
comment|/* The result has the same size as OP1, since OP1 is normalized 	   and longer than the ones-extended OP2.  */
name|res_size
operator|=
name|op1_size
expr_stmt|;
comment|/* Handle allocation, now then we know exactly how much space is 	   needed for the result.  */
if|if
condition|(
name|res
operator|->
name|_mp_alloc
operator|<
name|res_size
condition|)
block|{
name|_mpz_realloc
argument_list|(
name|res
argument_list|,
name|res_size
argument_list|)
expr_stmt|;
name|res_ptr
operator|=
name|res
operator|->
name|_mp_d
expr_stmt|;
name|op1_ptr
operator|=
name|op1
operator|->
name|_mp_d
expr_stmt|;
comment|/* Don't re-read OP2_PTR.  It points to temporary space--never 	       to the space RES->_mp_D used to point to before reallocation.  */
block|}
name|MPN_COPY
argument_list|(
name|res_ptr
operator|+
name|op2_size
argument_list|,
name|op1_ptr
operator|+
name|op2_size
argument_list|,
name|res_size
operator|-
name|op2_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|op2_size
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|res_ptr
index|[
name|i
index|]
operator|=
name|op1_ptr
index|[
name|i
index|]
operator|&
operator|~
name|op2_ptr
index|[
name|i
index|]
expr_stmt|;
name|res
operator|->
name|_mp_size
operator|=
name|res_size
expr_stmt|;
block|}
else|else
block|{
comment|/* Find out the exact result size.  Ignore the high limbs of OP2, 	   OP1 is zero-extended and would make the result zero.  */
for|for
control|(
name|i
operator|=
name|op1_size
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|(
name|op1_ptr
index|[
name|i
index|]
operator|&
operator|~
name|op2_ptr
index|[
name|i
index|]
operator|)
operator|!=
literal|0
condition|)
break|break;
name|res_size
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|/* Handle allocation, now then we know exactly how much space is 	   needed for the result.  */
if|if
condition|(
name|res
operator|->
name|_mp_alloc
operator|<
name|res_size
condition|)
block|{
name|_mpz_realloc
argument_list|(
name|res
argument_list|,
name|res_size
argument_list|)
expr_stmt|;
name|res_ptr
operator|=
name|res
operator|->
name|_mp_d
expr_stmt|;
name|op1_ptr
operator|=
name|op1
operator|->
name|_mp_d
expr_stmt|;
comment|/* Don't re-read OP2_PTR.  It points to temporary space--never 	       to the space RES->_mp_D used to point to before reallocation.  */
block|}
for|for
control|(
name|i
operator|=
name|res_size
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|res_ptr
index|[
name|i
index|]
operator|=
name|op1_ptr
index|[
name|i
index|]
operator|&
operator|~
name|op2_ptr
index|[
name|i
index|]
expr_stmt|;
name|res
operator|->
name|_mp_size
operator|=
name|res_size
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|TMP_FREE
argument_list|(
name|marker
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

