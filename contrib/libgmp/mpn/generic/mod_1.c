begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mpn_mod_1(dividend_ptr, dividend_size, divisor_limb) --    Divide (DIVIDEND_PTR,,DIVIDEND_SIZE) by DIVISOR_LIMB.    Return the single-limb remainder.    There are no constraints on the value of the divisor.  Copyright (C) 1991, 1993, 1994, Free Software Foundation, Inc.  This file is part of the GNU MP Library.  The GNU MP Library is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  The GNU MP Library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with the GNU MP Library; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_include
include|#
directive|include
file|"gmp.h"
end_include

begin_include
include|#
directive|include
file|"gmp-impl.h"
end_include

begin_include
include|#
directive|include
file|"longlong.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|UMUL_TIME
end_ifndef

begin_define
define|#
directive|define
name|UMUL_TIME
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|UDIV_TIME
end_ifndef

begin_define
define|#
directive|define
name|UDIV_TIME
value|UMUL_TIME
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FIXME: We should be using invert_limb (or invert_normalized_limb)    here (not udiv_qrnnd).  */
end_comment

begin_function
name|mp_limb_t
if|#
directive|if
name|__STDC__
name|mpn_mod_1
parameter_list|(
name|mp_srcptr
name|dividend_ptr
parameter_list|,
name|mp_size_t
name|dividend_size
parameter_list|,
name|mp_limb_t
name|divisor_limb
parameter_list|)
else|#
directive|else
function|mpn_mod_1
parameter_list|(
name|dividend_ptr
parameter_list|,
name|dividend_size
parameter_list|,
name|divisor_limb
parameter_list|)
name|mp_srcptr
name|dividend_ptr
decl_stmt|;
name|mp_size_t
name|dividend_size
decl_stmt|;
name|mp_limb_t
name|divisor_limb
decl_stmt|;
endif|#
directive|endif
block|{
name|mp_size_t
name|i
decl_stmt|;
name|mp_limb_t
name|n1
decl_stmt|,
name|n0
decl_stmt|,
name|r
decl_stmt|;
name|int
name|dummy
decl_stmt|;
comment|/* Botch: Should this be handled at all?  Rely on callers?  */
if|if
condition|(
name|dividend_size
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If multiplication is much faster than division, and the      dividend is large, pre-invert the divisor, and use      only multiplications in the inner loop.  */
comment|/* This test should be read:        Does it ever help to use udiv_qrnnd_preinv?&& Does what we save compensate for the inversion overhead?  */
if|if
condition|(
name|UDIV_TIME
operator|>
operator|(
literal|2
operator|*
name|UMUL_TIME
operator|+
literal|6
operator|)
operator|&&
operator|(
name|UDIV_TIME
operator|-
operator|(
literal|2
operator|*
name|UMUL_TIME
operator|+
literal|6
operator|)
operator|)
operator|*
name|dividend_size
operator|>
name|UDIV_TIME
condition|)
block|{
name|int
name|normalization_steps
decl_stmt|;
name|count_leading_zeros
argument_list|(
name|normalization_steps
argument_list|,
name|divisor_limb
argument_list|)
expr_stmt|;
if|if
condition|(
name|normalization_steps
operator|!=
literal|0
condition|)
block|{
name|mp_limb_t
name|divisor_limb_inverted
decl_stmt|;
name|divisor_limb
operator|<<=
name|normalization_steps
expr_stmt|;
comment|/* Compute (2**2N - 2**N * DIVISOR_LIMB) / DIVISOR_LIMB.  The 	     result is a (N+1)-bit approximation to 1/DIVISOR_LIMB, with the 	     most significant bit (with weight 2**N) implicit.  */
comment|/* Special case for DIVISOR_LIMB == 100...000.  */
if|if
condition|(
name|divisor_limb
operator|<<
literal|1
operator|==
literal|0
condition|)
name|divisor_limb_inverted
operator|=
operator|~
operator|(
name|mp_limb_t
operator|)
literal|0
expr_stmt|;
else|else
name|udiv_qrnnd
argument_list|(
name|divisor_limb_inverted
argument_list|,
name|dummy
argument_list|,
operator|-
name|divisor_limb
argument_list|,
literal|0
argument_list|,
name|divisor_limb
argument_list|)
expr_stmt|;
name|n1
operator|=
name|dividend_ptr
index|[
name|dividend_size
operator|-
literal|1
index|]
expr_stmt|;
name|r
operator|=
name|n1
operator|>>
operator|(
name|BITS_PER_MP_LIMB
operator|-
name|normalization_steps
operator|)
expr_stmt|;
comment|/* Possible optimization: 	     if (r == 0&& divisor_limb> ((n1<< normalization_steps) 			     | (dividend_ptr[dividend_size - 2]>> ...))) 	     ...one division less... */
for|for
control|(
name|i
operator|=
name|dividend_size
operator|-
literal|2
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|n0
operator|=
name|dividend_ptr
index|[
name|i
index|]
expr_stmt|;
name|udiv_qrnnd_preinv
argument_list|(
name|dummy
argument_list|,
name|r
argument_list|,
name|r
argument_list|,
operator|(
operator|(
name|n1
operator|<<
name|normalization_steps
operator|)
operator||
operator|(
name|n0
operator|>>
operator|(
name|BITS_PER_MP_LIMB
operator|-
name|normalization_steps
operator|)
operator|)
operator|)
argument_list|,
name|divisor_limb
argument_list|,
name|divisor_limb_inverted
argument_list|)
expr_stmt|;
name|n1
operator|=
name|n0
expr_stmt|;
block|}
name|udiv_qrnnd_preinv
argument_list|(
name|dummy
argument_list|,
name|r
argument_list|,
name|r
argument_list|,
name|n1
operator|<<
name|normalization_steps
argument_list|,
name|divisor_limb
argument_list|,
name|divisor_limb_inverted
argument_list|)
expr_stmt|;
return|return
name|r
operator|>>
name|normalization_steps
return|;
block|}
else|else
block|{
name|mp_limb_t
name|divisor_limb_inverted
decl_stmt|;
comment|/* Compute (2**2N - 2**N * DIVISOR_LIMB) / DIVISOR_LIMB.  The 	     result is a (N+1)-bit approximation to 1/DIVISOR_LIMB, with the 	     most significant bit (with weight 2**N) implicit.  */
comment|/* Special case for DIVISOR_LIMB == 100...000.  */
if|if
condition|(
name|divisor_limb
operator|<<
literal|1
operator|==
literal|0
condition|)
name|divisor_limb_inverted
operator|=
operator|~
operator|(
name|mp_limb_t
operator|)
literal|0
expr_stmt|;
else|else
name|udiv_qrnnd
argument_list|(
name|divisor_limb_inverted
argument_list|,
name|dummy
argument_list|,
operator|-
name|divisor_limb
argument_list|,
literal|0
argument_list|,
name|divisor_limb
argument_list|)
expr_stmt|;
name|i
operator|=
name|dividend_size
operator|-
literal|1
expr_stmt|;
name|r
operator|=
name|dividend_ptr
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|r
operator|>=
name|divisor_limb
condition|)
name|r
operator|=
literal|0
expr_stmt|;
else|else
name|i
operator|--
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|n0
operator|=
name|dividend_ptr
index|[
name|i
index|]
expr_stmt|;
name|udiv_qrnnd_preinv
argument_list|(
name|dummy
argument_list|,
name|r
argument_list|,
name|r
argument_list|,
name|n0
argument_list|,
name|divisor_limb
argument_list|,
name|divisor_limb_inverted
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|UDIV_NEEDS_NORMALIZATION
condition|)
block|{
name|int
name|normalization_steps
decl_stmt|;
name|count_leading_zeros
argument_list|(
name|normalization_steps
argument_list|,
name|divisor_limb
argument_list|)
expr_stmt|;
if|if
condition|(
name|normalization_steps
operator|!=
literal|0
condition|)
block|{
name|divisor_limb
operator|<<=
name|normalization_steps
expr_stmt|;
name|n1
operator|=
name|dividend_ptr
index|[
name|dividend_size
operator|-
literal|1
index|]
expr_stmt|;
name|r
operator|=
name|n1
operator|>>
operator|(
name|BITS_PER_MP_LIMB
operator|-
name|normalization_steps
operator|)
expr_stmt|;
comment|/* Possible optimization: 		 if (r == 0&& divisor_limb> ((n1<< normalization_steps) 				 | (dividend_ptr[dividend_size - 2]>> ...))) 		 ...one division less... */
for|for
control|(
name|i
operator|=
name|dividend_size
operator|-
literal|2
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|n0
operator|=
name|dividend_ptr
index|[
name|i
index|]
expr_stmt|;
name|udiv_qrnnd
argument_list|(
name|dummy
argument_list|,
name|r
argument_list|,
name|r
argument_list|,
operator|(
operator|(
name|n1
operator|<<
name|normalization_steps
operator|)
operator||
operator|(
name|n0
operator|>>
operator|(
name|BITS_PER_MP_LIMB
operator|-
name|normalization_steps
operator|)
operator|)
operator|)
argument_list|,
name|divisor_limb
argument_list|)
expr_stmt|;
name|n1
operator|=
name|n0
expr_stmt|;
block|}
name|udiv_qrnnd
argument_list|(
name|dummy
argument_list|,
name|r
argument_list|,
name|r
argument_list|,
name|n1
operator|<<
name|normalization_steps
argument_list|,
name|divisor_limb
argument_list|)
expr_stmt|;
return|return
name|r
operator|>>
name|normalization_steps
return|;
block|}
block|}
comment|/* No normalization needed, either because udiv_qrnnd doesn't require 	 it, or because DIVISOR_LIMB is already normalized.  */
name|i
operator|=
name|dividend_size
operator|-
literal|1
expr_stmt|;
name|r
operator|=
name|dividend_ptr
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|r
operator|>=
name|divisor_limb
condition|)
name|r
operator|=
literal|0
expr_stmt|;
else|else
name|i
operator|--
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|n0
operator|=
name|dividend_ptr
index|[
name|i
index|]
expr_stmt|;
name|udiv_qrnnd
argument_list|(
name|dummy
argument_list|,
name|r
argument_list|,
name|r
argument_list|,
name|n0
argument_list|,
name|divisor_limb
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
block|}
end_function

end_unit

