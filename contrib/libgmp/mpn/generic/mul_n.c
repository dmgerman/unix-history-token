begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mpn_mul_n -- Multiply two natural numbers of length n.  Copyright (C) 1991, 1992, 1993, 1994, 1996 Free Software Foundation, Inc.  This file is part of the GNU MP Library.  The GNU MP Library is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  The GNU MP Library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with the GNU MP Library; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_include
include|#
directive|include
file|"gmp.h"
end_include

begin_include
include|#
directive|include
file|"gmp-impl.h"
end_include

begin_comment
comment|/* Multiply the natural numbers u (pointed to by UP) and v (pointed to by VP),    both with SIZE limbs, and store the result at PRODP.  2 * SIZE limbs are    always stored.  Return the most significant limb.     Argument constraints:    1. PRODP != UP and PRODP != VP, i.e. the destination       must be distinct from the multiplier and the multiplicand.  */
end_comment

begin_comment
comment|/* If KARATSUBA_THRESHOLD is not already defined, define it to a    value which is good on most machines.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|KARATSUBA_THRESHOLD
end_ifndef

begin_define
define|#
directive|define
name|KARATSUBA_THRESHOLD
value|32
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The code can't handle KARATSUBA_THRESHOLD smaller than 2.  */
end_comment

begin_if
if|#
directive|if
name|KARATSUBA_THRESHOLD
operator|<
literal|2
end_if

begin_undef
undef|#
directive|undef
name|KARATSUBA_THRESHOLD
end_undef

begin_define
define|#
directive|define
name|KARATSUBA_THRESHOLD
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Handle simple cases with traditional multiplication.     This is the most critical code of multiplication.  All multiplies rely    on this, both small and huge.  Small ones arrive here immediately.  Huge    ones arrive here as this is the base case for Karatsuba's recursive    algorithm below.  */
end_comment

begin_function
name|void
if|#
directive|if
name|__STDC__
name|impn_mul_n_basecase
parameter_list|(
name|mp_ptr
name|prodp
parameter_list|,
name|mp_srcptr
name|up
parameter_list|,
name|mp_srcptr
name|vp
parameter_list|,
name|mp_size_t
name|size
parameter_list|)
else|#
directive|else
function|impn_mul_n_basecase
parameter_list|(
name|prodp
parameter_list|,
name|up
parameter_list|,
name|vp
parameter_list|,
name|size
parameter_list|)
name|mp_ptr
name|prodp
decl_stmt|;
name|mp_srcptr
name|up
decl_stmt|;
name|mp_srcptr
name|vp
decl_stmt|;
name|mp_size_t
name|size
decl_stmt|;
endif|#
directive|endif
block|{
name|mp_size_t
name|i
decl_stmt|;
name|mp_limb_t
name|cy_limb
decl_stmt|;
name|mp_limb_t
name|v_limb
decl_stmt|;
comment|/* Multiply by the first limb in V separately, as the result can be      stored (not added) to PROD.  We also avoid a loop for zeroing.  */
name|v_limb
operator|=
name|vp
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|v_limb
operator|<=
literal|1
condition|)
block|{
if|if
condition|(
name|v_limb
operator|==
literal|1
condition|)
name|MPN_COPY
argument_list|(
name|prodp
argument_list|,
name|up
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|MPN_ZERO
argument_list|(
name|prodp
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|cy_limb
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|cy_limb
operator|=
name|mpn_mul_1
argument_list|(
name|prodp
argument_list|,
name|up
argument_list|,
name|size
argument_list|,
name|v_limb
argument_list|)
expr_stmt|;
name|prodp
index|[
name|size
index|]
operator|=
name|cy_limb
expr_stmt|;
name|prodp
operator|++
expr_stmt|;
comment|/* For each iteration in the outer loop, multiply one limb from      U with one limb from V, and add it to PROD.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|v_limb
operator|=
name|vp
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|v_limb
operator|<=
literal|1
condition|)
block|{
name|cy_limb
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|v_limb
operator|==
literal|1
condition|)
name|cy_limb
operator|=
name|mpn_add_n
argument_list|(
name|prodp
argument_list|,
name|prodp
argument_list|,
name|up
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
name|cy_limb
operator|=
name|mpn_addmul_1
argument_list|(
name|prodp
argument_list|,
name|up
argument_list|,
name|size
argument_list|,
name|v_limb
argument_list|)
expr_stmt|;
name|prodp
index|[
name|size
index|]
operator|=
name|cy_limb
expr_stmt|;
name|prodp
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
if|#
directive|if
name|__STDC__
name|impn_mul_n
parameter_list|(
name|mp_ptr
name|prodp
parameter_list|,
name|mp_srcptr
name|up
parameter_list|,
name|mp_srcptr
name|vp
parameter_list|,
name|mp_size_t
name|size
parameter_list|,
name|mp_ptr
name|tspace
parameter_list|)
else|#
directive|else
function|impn_mul_n
parameter_list|(
name|prodp
parameter_list|,
name|up
parameter_list|,
name|vp
parameter_list|,
name|size
parameter_list|,
name|tspace
parameter_list|)
name|mp_ptr
name|prodp
decl_stmt|;
name|mp_srcptr
name|up
decl_stmt|;
name|mp_srcptr
name|vp
decl_stmt|;
name|mp_size_t
name|size
decl_stmt|;
name|mp_ptr
name|tspace
decl_stmt|;
endif|#
directive|endif
block|{
if|if
condition|(
operator|(
name|size
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* The size is odd, the code code below doesn't handle that. 	 Multiply the least significant (size - 1) limbs with a recursive 	 call, and handle the most significant limb of S1 and S2 	 separately.  */
comment|/* A slightly faster way to do this would be to make the Karatsuba 	 code below behave as if the size were even, and let it check for 	 odd size in the end.  I.e., in essence move this code to the end. 	 Doing so would save us a recursive call, and potentially make the 	 stack grow a lot less.  */
name|mp_size_t
name|esize
init|=
name|size
operator|-
literal|1
decl_stmt|;
comment|/* even size */
name|mp_limb_t
name|cy_limb
decl_stmt|;
name|MPN_MUL_N_RECURSE
argument_list|(
name|prodp
argument_list|,
name|up
argument_list|,
name|vp
argument_list|,
name|esize
argument_list|,
name|tspace
argument_list|)
expr_stmt|;
name|cy_limb
operator|=
name|mpn_addmul_1
argument_list|(
name|prodp
operator|+
name|esize
argument_list|,
name|up
argument_list|,
name|esize
argument_list|,
name|vp
index|[
name|esize
index|]
argument_list|)
expr_stmt|;
name|prodp
index|[
name|esize
operator|+
name|esize
index|]
operator|=
name|cy_limb
expr_stmt|;
name|cy_limb
operator|=
name|mpn_addmul_1
argument_list|(
name|prodp
operator|+
name|esize
argument_list|,
name|vp
argument_list|,
name|size
argument_list|,
name|up
index|[
name|esize
index|]
argument_list|)
expr_stmt|;
name|prodp
index|[
name|esize
operator|+
name|size
index|]
operator|=
name|cy_limb
expr_stmt|;
block|}
else|else
block|{
comment|/* Anatolij Alekseevich Karatsuba's divide-and-conquer algorithm.  	 Split U in two pieces, U1 and U0, such that 	 U = U0 + U1*(B**n), 	 and V in V1 and V0, such that 	 V = V0 + V1*(B**n).  	 UV is then computed recursively using the identity  		2n   n          n                     n 	 UV = (B  + B )U V  +  B (U -U )(V -V )  +  (B + 1)U V 			1 1        1  0   0  1              0 0  	 Where B = 2**BITS_PER_MP_LIMB.  */
name|mp_size_t
name|hsize
init|=
name|size
operator|>>
literal|1
decl_stmt|;
name|mp_limb_t
name|cy
decl_stmt|;
name|int
name|negflg
decl_stmt|;
comment|/*** Product H.	 ________________  ________________ 			|_____U1 x V1____||____U0 x V0_____|  */
comment|/* Put result in upper part of PROD and pass low part of TSPACE 	 as new TSPACE.  */
name|MPN_MUL_N_RECURSE
argument_list|(
name|prodp
operator|+
name|size
argument_list|,
name|up
operator|+
name|hsize
argument_list|,
name|vp
operator|+
name|hsize
argument_list|,
name|hsize
argument_list|,
name|tspace
argument_list|)
expr_stmt|;
comment|/*** Product M.	 ________________ 			|_(U1-U0)(V0-V1)_|  */
if|if
condition|(
name|mpn_cmp
argument_list|(
name|up
operator|+
name|hsize
argument_list|,
name|up
argument_list|,
name|hsize
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|mpn_sub_n
argument_list|(
name|prodp
argument_list|,
name|up
operator|+
name|hsize
argument_list|,
name|up
argument_list|,
name|hsize
argument_list|)
expr_stmt|;
name|negflg
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|mpn_sub_n
argument_list|(
name|prodp
argument_list|,
name|up
argument_list|,
name|up
operator|+
name|hsize
argument_list|,
name|hsize
argument_list|)
expr_stmt|;
name|negflg
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mpn_cmp
argument_list|(
name|vp
operator|+
name|hsize
argument_list|,
name|vp
argument_list|,
name|hsize
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|mpn_sub_n
argument_list|(
name|prodp
operator|+
name|hsize
argument_list|,
name|vp
operator|+
name|hsize
argument_list|,
name|vp
argument_list|,
name|hsize
argument_list|)
expr_stmt|;
name|negflg
operator|^=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|mpn_sub_n
argument_list|(
name|prodp
operator|+
name|hsize
argument_list|,
name|vp
argument_list|,
name|vp
operator|+
name|hsize
argument_list|,
name|hsize
argument_list|)
expr_stmt|;
comment|/* No change of NEGFLG.  */
block|}
comment|/* Read temporary operands from low part of PROD. 	 Put result in low part of TSPACE using upper part of TSPACE 	 as new TSPACE.  */
name|MPN_MUL_N_RECURSE
argument_list|(
name|tspace
argument_list|,
name|prodp
argument_list|,
name|prodp
operator|+
name|hsize
argument_list|,
name|hsize
argument_list|,
name|tspace
operator|+
name|size
argument_list|)
expr_stmt|;
comment|/*** Add/copy product H.  */
name|MPN_COPY
argument_list|(
name|prodp
operator|+
name|hsize
argument_list|,
name|prodp
operator|+
name|size
argument_list|,
name|hsize
argument_list|)
expr_stmt|;
name|cy
operator|=
name|mpn_add_n
argument_list|(
name|prodp
operator|+
name|size
argument_list|,
name|prodp
operator|+
name|size
argument_list|,
name|prodp
operator|+
name|size
operator|+
name|hsize
argument_list|,
name|hsize
argument_list|)
expr_stmt|;
comment|/*** Add product M (if NEGFLG M is a negative number).  */
if|if
condition|(
name|negflg
condition|)
name|cy
operator|-=
name|mpn_sub_n
argument_list|(
name|prodp
operator|+
name|hsize
argument_list|,
name|prodp
operator|+
name|hsize
argument_list|,
name|tspace
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|cy
operator|+=
name|mpn_add_n
argument_list|(
name|prodp
operator|+
name|hsize
argument_list|,
name|prodp
operator|+
name|hsize
argument_list|,
name|tspace
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/*** Product L.	 ________________  ________________ 			|________________||____U0 x V0_____|  */
comment|/* Read temporary operands from low part of PROD. 	 Put result in low part of TSPACE using upper part of TSPACE 	 as new TSPACE.  */
name|MPN_MUL_N_RECURSE
argument_list|(
name|tspace
argument_list|,
name|up
argument_list|,
name|vp
argument_list|,
name|hsize
argument_list|,
name|tspace
operator|+
name|size
argument_list|)
expr_stmt|;
comment|/*** Add/copy Product L (twice).  */
name|cy
operator|+=
name|mpn_add_n
argument_list|(
name|prodp
operator|+
name|hsize
argument_list|,
name|prodp
operator|+
name|hsize
argument_list|,
name|tspace
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|cy
condition|)
name|mpn_add_1
argument_list|(
name|prodp
operator|+
name|hsize
operator|+
name|size
argument_list|,
name|prodp
operator|+
name|hsize
operator|+
name|size
argument_list|,
name|hsize
argument_list|,
name|cy
argument_list|)
expr_stmt|;
name|MPN_COPY
argument_list|(
name|prodp
argument_list|,
name|tspace
argument_list|,
name|hsize
argument_list|)
expr_stmt|;
name|cy
operator|=
name|mpn_add_n
argument_list|(
name|prodp
operator|+
name|hsize
argument_list|,
name|prodp
operator|+
name|hsize
argument_list|,
name|tspace
operator|+
name|hsize
argument_list|,
name|hsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|cy
condition|)
name|mpn_add_1
argument_list|(
name|prodp
operator|+
name|size
argument_list|,
name|prodp
operator|+
name|size
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
if|#
directive|if
name|__STDC__
name|impn_sqr_n_basecase
parameter_list|(
name|mp_ptr
name|prodp
parameter_list|,
name|mp_srcptr
name|up
parameter_list|,
name|mp_size_t
name|size
parameter_list|)
else|#
directive|else
function|impn_sqr_n_basecase
parameter_list|(
name|prodp
parameter_list|,
name|up
parameter_list|,
name|size
parameter_list|)
name|mp_ptr
name|prodp
decl_stmt|;
name|mp_srcptr
name|up
decl_stmt|;
name|mp_size_t
name|size
decl_stmt|;
endif|#
directive|endif
block|{
name|mp_size_t
name|i
decl_stmt|;
name|mp_limb_t
name|cy_limb
decl_stmt|;
name|mp_limb_t
name|v_limb
decl_stmt|;
comment|/* Multiply by the first limb in V separately, as the result can be      stored (not added) to PROD.  We also avoid a loop for zeroing.  */
name|v_limb
operator|=
name|up
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|v_limb
operator|<=
literal|1
condition|)
block|{
if|if
condition|(
name|v_limb
operator|==
literal|1
condition|)
name|MPN_COPY
argument_list|(
name|prodp
argument_list|,
name|up
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|MPN_ZERO
argument_list|(
name|prodp
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|cy_limb
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|cy_limb
operator|=
name|mpn_mul_1
argument_list|(
name|prodp
argument_list|,
name|up
argument_list|,
name|size
argument_list|,
name|v_limb
argument_list|)
expr_stmt|;
name|prodp
index|[
name|size
index|]
operator|=
name|cy_limb
expr_stmt|;
name|prodp
operator|++
expr_stmt|;
comment|/* For each iteration in the outer loop, multiply one limb from      U with one limb from V, and add it to PROD.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|v_limb
operator|=
name|up
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|v_limb
operator|<=
literal|1
condition|)
block|{
name|cy_limb
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|v_limb
operator|==
literal|1
condition|)
name|cy_limb
operator|=
name|mpn_add_n
argument_list|(
name|prodp
argument_list|,
name|prodp
argument_list|,
name|up
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
name|cy_limb
operator|=
name|mpn_addmul_1
argument_list|(
name|prodp
argument_list|,
name|up
argument_list|,
name|size
argument_list|,
name|v_limb
argument_list|)
expr_stmt|;
name|prodp
index|[
name|size
index|]
operator|=
name|cy_limb
expr_stmt|;
name|prodp
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
if|#
directive|if
name|__STDC__
name|impn_sqr_n
parameter_list|(
name|mp_ptr
name|prodp
parameter_list|,
name|mp_srcptr
name|up
parameter_list|,
name|mp_size_t
name|size
parameter_list|,
name|mp_ptr
name|tspace
parameter_list|)
else|#
directive|else
function|impn_sqr_n
parameter_list|(
name|prodp
parameter_list|,
name|up
parameter_list|,
name|size
parameter_list|,
name|tspace
parameter_list|)
name|mp_ptr
name|prodp
decl_stmt|;
name|mp_srcptr
name|up
decl_stmt|;
name|mp_size_t
name|size
decl_stmt|;
name|mp_ptr
name|tspace
decl_stmt|;
endif|#
directive|endif
block|{
if|if
condition|(
operator|(
name|size
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* The size is odd, the code code below doesn't handle that. 	 Multiply the least significant (size - 1) limbs with a recursive 	 call, and handle the most significant limb of S1 and S2 	 separately.  */
comment|/* A slightly faster way to do this would be to make the Karatsuba 	 code below behave as if the size were even, and let it check for 	 odd size in the end.  I.e., in essence move this code to the end. 	 Doing so would save us a recursive call, and potentially make the 	 stack grow a lot less.  */
name|mp_size_t
name|esize
init|=
name|size
operator|-
literal|1
decl_stmt|;
comment|/* even size */
name|mp_limb_t
name|cy_limb
decl_stmt|;
name|MPN_SQR_N_RECURSE
argument_list|(
name|prodp
argument_list|,
name|up
argument_list|,
name|esize
argument_list|,
name|tspace
argument_list|)
expr_stmt|;
name|cy_limb
operator|=
name|mpn_addmul_1
argument_list|(
name|prodp
operator|+
name|esize
argument_list|,
name|up
argument_list|,
name|esize
argument_list|,
name|up
index|[
name|esize
index|]
argument_list|)
expr_stmt|;
name|prodp
index|[
name|esize
operator|+
name|esize
index|]
operator|=
name|cy_limb
expr_stmt|;
name|cy_limb
operator|=
name|mpn_addmul_1
argument_list|(
name|prodp
operator|+
name|esize
argument_list|,
name|up
argument_list|,
name|size
argument_list|,
name|up
index|[
name|esize
index|]
argument_list|)
expr_stmt|;
name|prodp
index|[
name|esize
operator|+
name|size
index|]
operator|=
name|cy_limb
expr_stmt|;
block|}
else|else
block|{
name|mp_size_t
name|hsize
init|=
name|size
operator|>>
literal|1
decl_stmt|;
name|mp_limb_t
name|cy
decl_stmt|;
comment|/*** Product H.	 ________________  ________________ 			|_____U1 x U1____||____U0 x U0_____|  */
comment|/* Put result in upper part of PROD and pass low part of TSPACE 	 as new TSPACE.  */
name|MPN_SQR_N_RECURSE
argument_list|(
name|prodp
operator|+
name|size
argument_list|,
name|up
operator|+
name|hsize
argument_list|,
name|hsize
argument_list|,
name|tspace
argument_list|)
expr_stmt|;
comment|/*** Product M.	 ________________ 			|_(U1-U0)(U0-U1)_|  */
if|if
condition|(
name|mpn_cmp
argument_list|(
name|up
operator|+
name|hsize
argument_list|,
name|up
argument_list|,
name|hsize
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|mpn_sub_n
argument_list|(
name|prodp
argument_list|,
name|up
operator|+
name|hsize
argument_list|,
name|up
argument_list|,
name|hsize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mpn_sub_n
argument_list|(
name|prodp
argument_list|,
name|up
argument_list|,
name|up
operator|+
name|hsize
argument_list|,
name|hsize
argument_list|)
expr_stmt|;
block|}
comment|/* Read temporary operands from low part of PROD. 	 Put result in low part of TSPACE using upper part of TSPACE 	 as new TSPACE.  */
name|MPN_SQR_N_RECURSE
argument_list|(
name|tspace
argument_list|,
name|prodp
argument_list|,
name|hsize
argument_list|,
name|tspace
operator|+
name|size
argument_list|)
expr_stmt|;
comment|/*** Add/copy product H.  */
name|MPN_COPY
argument_list|(
name|prodp
operator|+
name|hsize
argument_list|,
name|prodp
operator|+
name|size
argument_list|,
name|hsize
argument_list|)
expr_stmt|;
name|cy
operator|=
name|mpn_add_n
argument_list|(
name|prodp
operator|+
name|size
argument_list|,
name|prodp
operator|+
name|size
argument_list|,
name|prodp
operator|+
name|size
operator|+
name|hsize
argument_list|,
name|hsize
argument_list|)
expr_stmt|;
comment|/*** Add product M (if NEGFLG M is a negative number).  */
name|cy
operator|-=
name|mpn_sub_n
argument_list|(
name|prodp
operator|+
name|hsize
argument_list|,
name|prodp
operator|+
name|hsize
argument_list|,
name|tspace
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/*** Product L.	 ________________  ________________ 			|________________||____U0 x U0_____|  */
comment|/* Read temporary operands from low part of PROD. 	 Put result in low part of TSPACE using upper part of TSPACE 	 as new TSPACE.  */
name|MPN_SQR_N_RECURSE
argument_list|(
name|tspace
argument_list|,
name|up
argument_list|,
name|hsize
argument_list|,
name|tspace
operator|+
name|size
argument_list|)
expr_stmt|;
comment|/*** Add/copy Product L (twice).  */
name|cy
operator|+=
name|mpn_add_n
argument_list|(
name|prodp
operator|+
name|hsize
argument_list|,
name|prodp
operator|+
name|hsize
argument_list|,
name|tspace
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|cy
condition|)
name|mpn_add_1
argument_list|(
name|prodp
operator|+
name|hsize
operator|+
name|size
argument_list|,
name|prodp
operator|+
name|hsize
operator|+
name|size
argument_list|,
name|hsize
argument_list|,
name|cy
argument_list|)
expr_stmt|;
name|MPN_COPY
argument_list|(
name|prodp
argument_list|,
name|tspace
argument_list|,
name|hsize
argument_list|)
expr_stmt|;
name|cy
operator|=
name|mpn_add_n
argument_list|(
name|prodp
operator|+
name|hsize
argument_list|,
name|prodp
operator|+
name|hsize
argument_list|,
name|tspace
operator|+
name|hsize
argument_list|,
name|hsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|cy
condition|)
name|mpn_add_1
argument_list|(
name|prodp
operator|+
name|size
argument_list|,
name|prodp
operator|+
name|size
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This should be made into an inline function in gmp.h.  */
end_comment

begin_function
specifier|inline
name|void
if|#
directive|if
name|__STDC__
name|mpn_mul_n
parameter_list|(
name|mp_ptr
name|prodp
parameter_list|,
name|mp_srcptr
name|up
parameter_list|,
name|mp_srcptr
name|vp
parameter_list|,
name|mp_size_t
name|size
parameter_list|)
else|#
directive|else
function|mpn_mul_n
parameter_list|(
name|prodp
parameter_list|,
name|up
parameter_list|,
name|vp
parameter_list|,
name|size
parameter_list|)
name|mp_ptr
name|prodp
decl_stmt|;
name|mp_srcptr
name|up
decl_stmt|;
name|mp_srcptr
name|vp
decl_stmt|;
name|mp_size_t
name|size
decl_stmt|;
endif|#
directive|endif
block|{
name|TMP_DECL
argument_list|(
name|marker
argument_list|)
expr_stmt|;
name|TMP_MARK
argument_list|(
name|marker
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|==
name|vp
condition|)
block|{
if|if
condition|(
name|size
operator|<
name|KARATSUBA_THRESHOLD
condition|)
block|{
name|impn_sqr_n_basecase
argument_list|(
name|prodp
argument_list|,
name|up
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mp_ptr
name|tspace
decl_stmt|;
name|tspace
operator|=
operator|(
name|mp_ptr
operator|)
name|TMP_ALLOC
argument_list|(
literal|2
operator|*
name|size
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
name|impn_sqr_n
argument_list|(
name|prodp
argument_list|,
name|up
argument_list|,
name|size
argument_list|,
name|tspace
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|size
operator|<
name|KARATSUBA_THRESHOLD
condition|)
block|{
name|impn_mul_n_basecase
argument_list|(
name|prodp
argument_list|,
name|up
argument_list|,
name|vp
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mp_ptr
name|tspace
decl_stmt|;
name|tspace
operator|=
operator|(
name|mp_ptr
operator|)
name|TMP_ALLOC
argument_list|(
literal|2
operator|*
name|size
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
name|impn_mul_n
argument_list|(
name|prodp
argument_list|,
name|up
argument_list|,
name|vp
argument_list|,
name|size
argument_list|,
name|tspace
argument_list|)
expr_stmt|;
block|}
block|}
name|TMP_FREE
argument_list|(
name|marker
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

