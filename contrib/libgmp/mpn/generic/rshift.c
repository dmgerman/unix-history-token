begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mpn_rshift -- Shift right a low-level natural-number integer.  Copyright (C) 1991, 1993, 1994, 1996 Free Software Foundation, Inc.  This file is part of the GNU MP Library.  The GNU MP Library is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  The GNU MP Library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with the GNU MP Library; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_include
include|#
directive|include
file|"gmp.h"
end_include

begin_include
include|#
directive|include
file|"gmp-impl.h"
end_include

begin_comment
comment|/* Shift U (pointed to by UP and USIZE limbs long) CNT bits to the right    and store the USIZE least significant limbs of the result at WP.    The bits shifted out to the right are returned.     Argument constraints:    1. 0< CNT< BITS_PER_MP_LIMB    2. If the result is to be written over the input, WP must be<= UP. */
end_comment

begin_function
name|mp_limb_t
if|#
directive|if
name|__STDC__
name|mpn_rshift
parameter_list|(
specifier|register
name|mp_ptr
name|wp
parameter_list|,
specifier|register
name|mp_srcptr
name|up
parameter_list|,
name|mp_size_t
name|usize
parameter_list|,
specifier|register
name|unsigned
name|int
name|cnt
parameter_list|)
else|#
directive|else
function|mpn_rshift
parameter_list|(
name|wp
parameter_list|,
name|up
parameter_list|,
name|usize
parameter_list|,
name|cnt
parameter_list|)
specifier|register
name|mp_ptr
name|wp
decl_stmt|;
specifier|register
name|mp_srcptr
name|up
decl_stmt|;
name|mp_size_t
name|usize
decl_stmt|;
specifier|register
name|unsigned
name|int
name|cnt
decl_stmt|;
endif|#
directive|endif
block|{
specifier|register
name|mp_limb_t
name|high_limb
decl_stmt|,
name|low_limb
decl_stmt|;
specifier|register
name|unsigned
name|sh_1
decl_stmt|,
name|sh_2
decl_stmt|;
specifier|register
name|mp_size_t
name|i
decl_stmt|;
name|mp_limb_t
name|retval
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|usize
operator|==
literal|0
operator|||
name|cnt
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|sh_1
operator|=
name|cnt
expr_stmt|;
if|#
directive|if
literal|0
block|if (sh_1 == 0)     {       if (wp != up) 	{
comment|/* Copy from low end to high end, to allow specified input/output 	     overlapping.  */
block|for (i = 0; i< usize; i++) 	    wp[i] = up[i]; 	}       return usize;     }
endif|#
directive|endif
name|wp
operator|-=
literal|1
expr_stmt|;
name|sh_2
operator|=
name|BITS_PER_MP_LIMB
operator|-
name|sh_1
expr_stmt|;
name|high_limb
operator|=
name|up
index|[
literal|0
index|]
expr_stmt|;
name|retval
operator|=
name|high_limb
operator|<<
name|sh_2
expr_stmt|;
name|low_limb
operator|=
name|high_limb
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|usize
condition|;
name|i
operator|++
control|)
block|{
name|high_limb
operator|=
name|up
index|[
name|i
index|]
expr_stmt|;
name|wp
index|[
name|i
index|]
operator|=
operator|(
name|low_limb
operator|>>
name|sh_1
operator|)
operator||
operator|(
name|high_limb
operator|<<
name|sh_2
operator|)
expr_stmt|;
name|low_limb
operator|=
name|high_limb
expr_stmt|;
block|}
name|wp
index|[
name|i
index|]
operator|=
name|low_limb
operator|>>
name|sh_1
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

end_unit

