begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mpn/gcd.c: mpn_gcd for gcd of two odd integers.  Copyright (C) 1991, 1993, 1994, 1995, 1996 Free Software Foundation, Inc.  This file is part of the GNU MP Library.  The GNU MP Library is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  The GNU MP Library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with the GNU MP Library; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_comment
comment|/* Integer greatest common divisor of two unsigned integers, using    the accelerated algorithm (see reference below).     mp_size_t mpn_gcd (vp, vsize, up, usize).     Preconditions [U = (up, usize) and V = (vp, vsize)]:     1.  V is odd.    2.  numbits(U)>= numbits(V).     Both U and V are destroyed by the operation.  The result is left at vp,    and its size is returned.     Ken Weber (kweber@mat.ufrgs.br, kweber@mcs.kent.edu)     Funding for this work has been partially provided by Conselho Nacional    de Desenvolvimento Cienti'fico e Tecnolo'gico (CNPq) do Brazil, Grant    301314194-2, and was done while I was a visiting reseacher in the Instituto    de Matema'tica at Universidade Federal do Rio Grande do Sul (UFRGS).     Refer to 	K. Weber, The accelerated integer GCD algorithm, ACM Transactions on 	Mathematical Software, v. 21 (March), 1995, pp. 111-122.  */
end_comment

begin_include
include|#
directive|include
file|"gmp.h"
end_include

begin_include
include|#
directive|include
file|"gmp-impl.h"
end_include

begin_include
include|#
directive|include
file|"longlong.h"
end_include

begin_comment
comment|/* If MIN (usize, vsize)> ACCEL_THRESHOLD, then the accelerated algorithm is    used, otherwise the binary algorithm is used.  This may be adjusted for    different architectures.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ACCEL_THRESHOLD
end_ifndef

begin_define
define|#
directive|define
name|ACCEL_THRESHOLD
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* When U and V differ in size by more than BMOD_THRESHOLD, the accelerated    algorithm reduces using the bmod operation.  Otherwise, the k-ary reduction    is used.  0<= BMOD_THRESHOLD< BITS_PER_MP_LIMB.  */
end_comment

begin_enum
enum|enum
block|{
name|BMOD_THRESHOLD
init|=
name|BITS_PER_MP_LIMB
operator|/
literal|2
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|SIGN_BIT
value|(~(~(mp_limb_t)0>> 1))
end_define

begin_define
define|#
directive|define
name|SWAP_LIMB
parameter_list|(
name|UL
parameter_list|,
name|VL
parameter_list|)
value|do{mp_limb_t __l=(UL);(UL)=(VL);(VL)=__l;}while(0)
end_define

begin_define
define|#
directive|define
name|SWAP_PTR
parameter_list|(
name|UP
parameter_list|,
name|VP
parameter_list|)
value|do{mp_ptr __p=(UP);(UP)=(VP);(VP)=__p;}while(0)
end_define

begin_define
define|#
directive|define
name|SWAP_SZ
parameter_list|(
name|US
parameter_list|,
name|VS
parameter_list|)
value|do{mp_size_t __s=(US);(US)=(VS);(VS)=__s;}while(0)
end_define

begin_define
define|#
directive|define
name|SWAP_MPN
parameter_list|(
name|UP
parameter_list|,
name|US
parameter_list|,
name|VP
parameter_list|,
name|VS
parameter_list|)
value|do{SWAP_PTR(UP,VP);SWAP_SZ(US,VS);}while(0)
end_define

begin_comment
comment|/* Use binary algorithm to compute V<-- GCD (V, U) for usize, vsize == 2.    Both U and V must be odd.  */
end_comment

begin_function
specifier|static
name|__gmp_inline
name|mp_size_t
if|#
directive|if
name|__STDC__
name|gcd_2
parameter_list|(
name|mp_ptr
name|vp
parameter_list|,
name|mp_srcptr
name|up
parameter_list|)
else|#
directive|else
function|gcd_2
parameter_list|(
name|vp
parameter_list|,
name|up
parameter_list|)
name|mp_ptr
name|vp
decl_stmt|;
name|mp_srcptr
name|up
decl_stmt|;
endif|#
directive|endif
block|{
name|mp_limb_t
name|u0
decl_stmt|,
name|u1
decl_stmt|,
name|v0
decl_stmt|,
name|v1
decl_stmt|;
name|mp_size_t
name|vsize
decl_stmt|;
name|u0
operator|=
name|up
index|[
literal|0
index|]
operator|,
name|u1
operator|=
name|up
index|[
literal|1
index|]
operator|,
name|v0
operator|=
name|vp
index|[
literal|0
index|]
operator|,
name|v1
operator|=
name|vp
index|[
literal|1
index|]
expr_stmt|;
while|while
condition|(
name|u1
operator|!=
name|v1
operator|&&
name|u0
operator|!=
name|v0
condition|)
block|{
name|unsigned
name|long
name|int
name|r
decl_stmt|;
if|if
condition|(
name|u1
operator|>
name|v1
condition|)
block|{
name|u1
operator|-=
name|v1
operator|+
operator|(
name|u0
operator|<
name|v0
operator|)
operator|,
name|u0
operator|-=
name|v0
expr_stmt|;
name|count_trailing_zeros
argument_list|(
name|r
argument_list|,
name|u0
argument_list|)
expr_stmt|;
name|u0
operator|=
name|u1
operator|<<
operator|(
name|BITS_PER_MP_LIMB
operator|-
name|r
operator|)
operator||
name|u0
operator|>>
name|r
expr_stmt|;
name|u1
operator|>>=
name|r
expr_stmt|;
block|}
else|else
comment|/* u1< v1.  */
block|{
name|v1
operator|-=
name|u1
operator|+
operator|(
name|v0
operator|<
name|u0
operator|)
operator|,
name|v0
operator|-=
name|u0
expr_stmt|;
name|count_trailing_zeros
argument_list|(
name|r
argument_list|,
name|v0
argument_list|)
expr_stmt|;
name|v0
operator|=
name|v1
operator|<<
operator|(
name|BITS_PER_MP_LIMB
operator|-
name|r
operator|)
operator||
name|v0
operator|>>
name|r
expr_stmt|;
name|v1
operator|>>=
name|r
expr_stmt|;
block|}
block|}
name|vp
index|[
literal|0
index|]
operator|=
name|v0
operator|,
name|vp
index|[
literal|1
index|]
operator|=
name|v1
operator|,
name|vsize
operator|=
literal|1
operator|+
operator|(
name|v1
operator|!=
literal|0
operator|)
expr_stmt|;
comment|/* If U == V == GCD, done.  Otherwise, compute GCD (V, |U - V|).  */
if|if
condition|(
name|u1
operator|==
name|v1
operator|&&
name|u0
operator|==
name|v0
condition|)
return|return
name|vsize
return|;
name|v0
operator|=
operator|(
name|u0
operator|==
name|v0
operator|)
condition|?
operator|(
name|u1
operator|>
name|v1
operator|)
condition|?
name|u1
operator|-
name|v1
else|:
name|v1
operator|-
name|u1
else|:
operator|(
name|u0
operator|>
name|v0
operator|)
condition|?
name|u0
operator|-
name|v0
else|:
name|v0
operator|-
name|u0
expr_stmt|;
name|vp
index|[
literal|0
index|]
operator|=
name|mpn_gcd_1
argument_list|(
name|vp
argument_list|,
name|vsize
argument_list|,
name|v0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* The function find_a finds 0< N< 2^BITS_PER_MP_LIMB such that there exists    0< |D|< 2^BITS_PER_MP_LIMB, and N == D * C mod 2^(2*BITS_PER_MP_LIMB).    In the reference article, D was computed along with N, but it is better to    compute D separately as D<-- N / C mod 2^(BITS_PER_MP_LIMB + 1), treating    the result as a twos' complement signed integer.     Initialize N1 to C mod 2^(2*BITS_PER_MP_LIMB).  According to the reference    article, N2 should be initialized to 2^(2*BITS_PER_MP_LIMB), but we use    2^(2*BITS_PER_MP_LIMB) - N1 to start the calculations within double    precision.  If N2> N1 initially, the first iteration of the while loop    will swap them.  In all other situations, N1>= N2 is maintained.  */
end_comment

begin_function
specifier|static
name|__gmp_inline
name|mp_limb_t
if|#
directive|if
name|__STDC__
name|find_a
parameter_list|(
name|mp_srcptr
name|cp
parameter_list|)
else|#
directive|else
function|find_a
parameter_list|(
name|cp
parameter_list|)
name|mp_srcptr
name|cp
decl_stmt|;
endif|#
directive|endif
block|{
name|unsigned
name|long
name|int
name|leading_zero_bits
init|=
literal|0
decl_stmt|;
name|mp_limb_t
name|n1_l
init|=
name|cp
index|[
literal|0
index|]
decl_stmt|;
comment|/* N1 == n1_h * 2^BITS_PER_MP_LIMB + n1_l.  */
name|mp_limb_t
name|n1_h
init|=
name|cp
index|[
literal|1
index|]
decl_stmt|;
name|mp_limb_t
name|n2_l
init|=
operator|-
name|n1_l
decl_stmt|;
comment|/* N2 == n2_h * 2^BITS_PER_MP_LIMB + n2_l.  */
name|mp_limb_t
name|n2_h
init|=
operator|~
name|n1_h
decl_stmt|;
comment|/* Main loop.  */
while|while
condition|(
name|n2_h
condition|)
comment|/* While N2>= 2^BITS_PER_MP_LIMB.  */
block|{
comment|/* N1<-- N1 % N2.  */
if|if
condition|(
operator|(
name|SIGN_BIT
operator|>>
name|leading_zero_bits
operator|&
name|n2_h
operator|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|long
name|int
name|i
decl_stmt|;
name|count_leading_zeros
argument_list|(
name|i
argument_list|,
name|n2_h
argument_list|)
expr_stmt|;
name|i
operator|-=
name|leading_zero_bits
operator|,
name|leading_zero_bits
operator|+=
name|i
expr_stmt|;
name|n2_h
operator|=
name|n2_h
operator|<<
name|i
operator||
name|n2_l
operator|>>
operator|(
name|BITS_PER_MP_LIMB
operator|-
name|i
operator|)
operator|,
name|n2_l
operator|<<=
name|i
expr_stmt|;
do|do
block|{
if|if
condition|(
name|n1_h
operator|>
name|n2_h
operator|||
operator|(
name|n1_h
operator|==
name|n2_h
operator|&&
name|n1_l
operator|>=
name|n2_l
operator|)
condition|)
name|n1_h
operator|-=
name|n2_h
operator|+
operator|(
name|n1_l
operator|<
name|n2_l
operator|)
operator|,
name|n1_l
operator|-=
name|n2_l
expr_stmt|;
name|n2_l
operator|=
name|n2_l
operator|>>
literal|1
operator||
name|n2_h
operator|<<
operator|(
name|BITS_PER_MP_LIMB
operator|-
literal|1
operator|)
operator|,
name|n2_h
operator|>>=
literal|1
expr_stmt|;
name|i
operator|-=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|i
condition|)
do|;
block|}
if|if
condition|(
name|n1_h
operator|>
name|n2_h
operator|||
operator|(
name|n1_h
operator|==
name|n2_h
operator|&&
name|n1_l
operator|>=
name|n2_l
operator|)
condition|)
name|n1_h
operator|-=
name|n2_h
operator|+
operator|(
name|n1_l
operator|<
name|n2_l
operator|)
operator|,
name|n1_l
operator|-=
name|n2_l
expr_stmt|;
name|SWAP_LIMB
argument_list|(
name|n1_h
argument_list|,
name|n2_h
argument_list|)
expr_stmt|;
name|SWAP_LIMB
argument_list|(
name|n1_l
argument_list|,
name|n2_l
argument_list|)
expr_stmt|;
block|}
return|return
name|n2_l
return|;
block|}
end_function

begin_function
name|mp_size_t
if|#
directive|if
name|__STDC__
name|mpn_gcd
parameter_list|(
name|mp_ptr
name|gp
parameter_list|,
name|mp_ptr
name|vp
parameter_list|,
name|mp_size_t
name|vsize
parameter_list|,
name|mp_ptr
name|up
parameter_list|,
name|mp_size_t
name|usize
parameter_list|)
else|#
directive|else
function|mpn_gcd
parameter_list|(
name|gp
parameter_list|,
name|vp
parameter_list|,
name|vsize
parameter_list|,
name|up
parameter_list|,
name|usize
parameter_list|)
name|mp_ptr
name|gp
decl_stmt|;
name|mp_ptr
name|vp
decl_stmt|;
name|mp_size_t
name|vsize
decl_stmt|;
name|mp_ptr
name|up
decl_stmt|;
name|mp_size_t
name|usize
decl_stmt|;
endif|#
directive|endif
block|{
name|mp_ptr
name|orig_vp
init|=
name|vp
decl_stmt|;
name|mp_size_t
name|orig_vsize
init|=
name|vsize
decl_stmt|;
name|int
name|binary_gcd_ctr
decl_stmt|;
comment|/* Number of times binary gcd will execute.  */
name|TMP_DECL
argument_list|(
name|marker
argument_list|)
expr_stmt|;
name|TMP_MARK
argument_list|(
name|marker
argument_list|)
expr_stmt|;
comment|/* Use accelerated algorithm if vsize is over ACCEL_THRESHOLD.      Two EXTRA limbs for U and V are required for kary reduction.  */
if|if
condition|(
name|vsize
operator|>
name|ACCEL_THRESHOLD
condition|)
block|{
name|unsigned
name|long
name|int
name|vbitsize
decl_stmt|,
name|d
decl_stmt|;
name|mp_ptr
name|orig_up
init|=
name|up
decl_stmt|;
name|mp_size_t
name|orig_usize
init|=
name|usize
decl_stmt|;
name|mp_ptr
name|anchor_up
init|=
operator|(
name|mp_ptr
operator|)
name|TMP_ALLOC
argument_list|(
operator|(
name|usize
operator|+
literal|2
operator|)
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
decl_stmt|;
name|MPN_COPY
argument_list|(
name|anchor_up
argument_list|,
name|orig_up
argument_list|,
name|usize
argument_list|)
expr_stmt|;
name|up
operator|=
name|anchor_up
expr_stmt|;
name|count_leading_zeros
argument_list|(
name|d
argument_list|,
name|up
index|[
name|usize
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|d
operator|=
name|usize
operator|*
name|BITS_PER_MP_LIMB
operator|-
name|d
expr_stmt|;
name|count_leading_zeros
argument_list|(
name|vbitsize
argument_list|,
name|vp
index|[
name|vsize
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|vbitsize
operator|=
name|vsize
operator|*
name|BITS_PER_MP_LIMB
operator|-
name|vbitsize
expr_stmt|;
name|d
operator|=
name|d
operator|-
name|vbitsize
operator|+
literal|1
expr_stmt|;
comment|/* Use bmod reduction to quickly discover whether V divides U.  */
name|up
index|[
name|usize
operator|++
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Insert leading zero.  */
name|mpn_bdivmod
argument_list|(
name|up
argument_list|,
name|up
argument_list|,
name|usize
argument_list|,
name|vp
argument_list|,
name|vsize
argument_list|,
name|d
argument_list|)
expr_stmt|;
comment|/* Now skip U/V mod 2^d and any low zero limbs.  */
name|d
operator|/=
name|BITS_PER_MP_LIMB
operator|,
name|up
operator|+=
name|d
operator|,
name|usize
operator|-=
name|d
expr_stmt|;
while|while
condition|(
name|usize
operator|!=
literal|0
operator|&&
name|up
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|up
operator|++
operator|,
name|usize
operator|--
expr_stmt|;
if|if
condition|(
name|usize
operator|==
literal|0
condition|)
comment|/* GCD == ORIG_V.  */
goto|goto
name|done
goto|;
name|vp
operator|=
operator|(
name|mp_ptr
operator|)
name|TMP_ALLOC
argument_list|(
operator|(
name|vsize
operator|+
literal|2
operator|)
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
name|MPN_COPY
argument_list|(
name|vp
argument_list|,
name|orig_vp
argument_list|,
name|vsize
argument_list|)
expr_stmt|;
do|do
comment|/* Main loop.  */
block|{
if|if
condition|(
name|up
index|[
name|usize
operator|-
literal|1
index|]
operator|&
name|SIGN_BIT
condition|)
comment|/* U< 0; take twos' compl. */
block|{
name|mp_size_t
name|i
decl_stmt|;
name|anchor_up
index|[
literal|0
index|]
operator|=
operator|-
name|up
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|usize
condition|;
name|i
operator|++
control|)
name|anchor_up
index|[
name|i
index|]
operator|=
operator|~
name|up
index|[
name|i
index|]
expr_stmt|;
name|up
operator|=
name|anchor_up
expr_stmt|;
block|}
name|MPN_NORMALIZE_NOT_ZERO
argument_list|(
name|up
argument_list|,
name|usize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|up
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
comment|/* Result even; remove twos. */
block|{
name|unsigned
name|long
name|int
name|r
decl_stmt|;
name|count_trailing_zeros
argument_list|(
name|r
argument_list|,
name|up
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|mpn_rshift
argument_list|(
name|anchor_up
argument_list|,
name|up
argument_list|,
name|usize
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|usize
operator|-=
operator|(
name|anchor_up
index|[
name|usize
operator|-
literal|1
index|]
operator|==
literal|0
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|anchor_up
operator|!=
name|up
condition|)
name|MPN_COPY
argument_list|(
name|anchor_up
argument_list|,
name|up
argument_list|,
name|usize
argument_list|)
expr_stmt|;
name|SWAP_MPN
argument_list|(
name|anchor_up
argument_list|,
name|usize
argument_list|,
name|vp
argument_list|,
name|vsize
argument_list|)
expr_stmt|;
name|up
operator|=
name|anchor_up
expr_stmt|;
if|if
condition|(
name|vsize
operator|<=
literal|2
condition|)
comment|/* Kary can't handle< 2 limbs and  */
break|break;
comment|/* isn't efficient for == 2 limbs.  */
name|d
operator|=
name|vbitsize
expr_stmt|;
name|count_leading_zeros
argument_list|(
name|vbitsize
argument_list|,
name|vp
index|[
name|vsize
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|vbitsize
operator|=
name|vsize
operator|*
name|BITS_PER_MP_LIMB
operator|-
name|vbitsize
expr_stmt|;
name|d
operator|=
name|d
operator|-
name|vbitsize
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|d
operator|>
name|BMOD_THRESHOLD
condition|)
comment|/* Bmod reduction.  */
block|{
name|up
index|[
name|usize
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|mpn_bdivmod
argument_list|(
name|up
argument_list|,
name|up
argument_list|,
name|usize
argument_list|,
name|vp
argument_list|,
name|vsize
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|d
operator|/=
name|BITS_PER_MP_LIMB
operator|,
name|up
operator|+=
name|d
operator|,
name|usize
operator|-=
name|d
expr_stmt|;
block|}
else|else
comment|/* Kary reduction.  */
block|{
name|mp_limb_t
name|bp
index|[
literal|2
index|]
decl_stmt|,
name|cp
index|[
literal|2
index|]
decl_stmt|;
comment|/* C<-- V/U mod 2^(2*BITS_PER_MP_LIMB).  */
name|cp
index|[
literal|0
index|]
operator|=
name|vp
index|[
literal|0
index|]
operator|,
name|cp
index|[
literal|1
index|]
operator|=
name|vp
index|[
literal|1
index|]
expr_stmt|;
name|mpn_bdivmod
argument_list|(
name|cp
argument_list|,
name|cp
argument_list|,
literal|2
argument_list|,
name|up
argument_list|,
literal|2
argument_list|,
literal|2
operator|*
name|BITS_PER_MP_LIMB
argument_list|)
expr_stmt|;
comment|/* U<-- find_a (C)  *  U.  */
name|up
index|[
name|usize
index|]
operator|=
name|mpn_mul_1
argument_list|(
name|up
argument_list|,
name|up
argument_list|,
name|usize
argument_list|,
name|find_a
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|usize
operator|++
expr_stmt|;
comment|/* B<-- A/C == U/V mod 2^(BITS_PER_MP_LIMB + 1). 		  bp[0]<-- U/V mod 2^BITS_PER_MP_LIMB and 		  bp[1]<-- ( (U - bp[0] * V)/2^BITS_PER_MP_LIMB ) / V mod 2 */
name|bp
index|[
literal|0
index|]
operator|=
name|up
index|[
literal|0
index|]
operator|,
name|bp
index|[
literal|1
index|]
operator|=
name|up
index|[
literal|1
index|]
expr_stmt|;
name|mpn_bdivmod
argument_list|(
name|bp
argument_list|,
name|bp
argument_list|,
literal|2
argument_list|,
name|vp
argument_list|,
literal|2
argument_list|,
name|BITS_PER_MP_LIMB
argument_list|)
expr_stmt|;
name|bp
index|[
literal|1
index|]
operator|&=
literal|1
expr_stmt|;
comment|/* Since V is odd, division is unnecessary.  */
name|up
index|[
name|usize
operator|++
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bp
index|[
literal|1
index|]
condition|)
comment|/* B< 0: U<-- U + (-B)  * V.  */
block|{
name|mp_limb_t
name|c
init|=
name|mpn_addmul_1
argument_list|(
name|up
argument_list|,
name|vp
argument_list|,
name|vsize
argument_list|,
operator|-
name|bp
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|mpn_add_1
argument_list|(
name|up
operator|+
name|vsize
argument_list|,
name|up
operator|+
name|vsize
argument_list|,
name|usize
operator|-
name|vsize
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* B>= 0:  U<-- U - B * V.  */
block|{
name|mp_limb_t
name|b
init|=
name|mpn_submul_1
argument_list|(
name|up
argument_list|,
name|vp
argument_list|,
name|vsize
argument_list|,
name|bp
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|mpn_sub_1
argument_list|(
name|up
operator|+
name|vsize
argument_list|,
name|up
operator|+
name|vsize
argument_list|,
name|usize
operator|-
name|vsize
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
name|up
operator|+=
literal|2
operator|,
name|usize
operator|-=
literal|2
expr_stmt|;
comment|/* At least two low limbs are zero.  */
block|}
comment|/* Must remove low zero limbs before complementing.  */
while|while
condition|(
name|usize
operator|!=
literal|0
operator|&&
name|up
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|up
operator|++
operator|,
name|usize
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|usize
condition|)
do|;
comment|/* Compute GCD (ORIG_V, GCD (ORIG_U, V)).  Binary will execute twice.  */
name|up
operator|=
name|orig_up
operator|,
name|usize
operator|=
name|orig_usize
expr_stmt|;
name|binary_gcd_ctr
operator|=
literal|2
expr_stmt|;
block|}
else|else
name|binary_gcd_ctr
operator|=
literal|1
expr_stmt|;
comment|/* Finish up with the binary algorithm.  Executes once or twice.  */
for|for
control|(
init|;
name|binary_gcd_ctr
operator|--
condition|;
name|up
operator|=
name|orig_vp
operator|,
name|usize
operator|=
name|orig_vsize
control|)
block|{
if|if
condition|(
name|usize
operator|>
literal|2
condition|)
comment|/* First make U close to V in size.  */
block|{
name|unsigned
name|long
name|int
name|vbitsize
decl_stmt|,
name|d
decl_stmt|;
name|count_leading_zeros
argument_list|(
name|d
argument_list|,
name|up
index|[
name|usize
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|d
operator|=
name|usize
operator|*
name|BITS_PER_MP_LIMB
operator|-
name|d
expr_stmt|;
name|count_leading_zeros
argument_list|(
name|vbitsize
argument_list|,
name|vp
index|[
name|vsize
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|vbitsize
operator|=
name|vsize
operator|*
name|BITS_PER_MP_LIMB
operator|-
name|vbitsize
expr_stmt|;
name|d
operator|=
name|d
operator|-
name|vbitsize
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|d
operator|!=
operator|-
operator|(
name|unsigned
name|long
name|int
operator|)
literal|1
operator|&&
name|d
operator|>
literal|2
condition|)
block|{
name|mpn_bdivmod
argument_list|(
name|up
argument_list|,
name|up
argument_list|,
name|usize
argument_list|,
name|vp
argument_list|,
name|vsize
argument_list|,
name|d
argument_list|)
expr_stmt|;
comment|/* Result> 0.  */
name|d
operator|/=
operator|(
name|unsigned
name|long
name|int
operator|)
name|BITS_PER_MP_LIMB
operator|,
name|up
operator|+=
name|d
operator|,
name|usize
operator|-=
name|d
expr_stmt|;
block|}
block|}
comment|/* Start binary GCD.  */
do|do
block|{
name|mp_size_t
name|zeros
decl_stmt|;
comment|/* Make sure U is odd.  */
name|MPN_NORMALIZE
argument_list|(
name|up
argument_list|,
name|usize
argument_list|)
expr_stmt|;
while|while
condition|(
name|up
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|up
operator|+=
literal|1
operator|,
name|usize
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|up
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|long
name|int
name|r
decl_stmt|;
name|count_trailing_zeros
argument_list|(
name|r
argument_list|,
name|up
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|mpn_rshift
argument_list|(
name|up
argument_list|,
name|up
argument_list|,
name|usize
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|usize
operator|-=
operator|(
name|up
index|[
name|usize
operator|-
literal|1
index|]
operator|==
literal|0
operator|)
expr_stmt|;
block|}
comment|/* Keep usize>= vsize.  */
if|if
condition|(
name|usize
operator|<
name|vsize
condition|)
name|SWAP_MPN
argument_list|(
name|up
argument_list|,
name|usize
argument_list|,
name|vp
argument_list|,
name|vsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|usize
operator|<=
literal|2
condition|)
comment|/* Double precision. */
block|{
if|if
condition|(
name|vsize
operator|==
literal|1
condition|)
name|vp
index|[
literal|0
index|]
operator|=
name|mpn_gcd_1
argument_list|(
name|up
argument_list|,
name|usize
argument_list|,
name|vp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|vsize
operator|=
name|gcd_2
argument_list|(
name|vp
argument_list|,
name|up
argument_list|)
expr_stmt|;
break|break;
comment|/* Binary GCD done.  */
block|}
comment|/* Count number of low zero limbs of U - V.  */
for|for
control|(
name|zeros
operator|=
literal|0
init|;
name|up
index|[
name|zeros
index|]
operator|==
name|vp
index|[
name|zeros
index|]
operator|&&
operator|++
name|zeros
operator|!=
name|vsize
condition|;
control|)
continue|continue;
comment|/* If U< V, swap U and V; in any case, subtract V from U.  */
if|if
condition|(
name|zeros
operator|==
name|vsize
condition|)
comment|/* Subtract done.  */
name|up
operator|+=
name|zeros
operator|,
name|usize
operator|-=
name|zeros
expr_stmt|;
elseif|else
if|if
condition|(
name|usize
operator|==
name|vsize
condition|)
block|{
name|mp_size_t
name|size
init|=
name|vsize
decl_stmt|;
do|do
name|size
operator|--
expr_stmt|;
do|while
condition|(
name|up
index|[
name|size
index|]
operator|==
name|vp
index|[
name|size
index|]
condition|)
do|;
if|if
condition|(
name|up
index|[
name|size
index|]
operator|<
name|vp
index|[
name|size
index|]
condition|)
comment|/* usize == vsize.  */
name|SWAP_PTR
argument_list|(
name|up
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|up
operator|+=
name|zeros
operator|,
name|usize
operator|=
name|size
operator|+
literal|1
operator|-
name|zeros
expr_stmt|;
name|mpn_sub_n
argument_list|(
name|up
argument_list|,
name|up
argument_list|,
name|vp
operator|+
name|zeros
argument_list|,
name|usize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mp_size_t
name|size
init|=
name|vsize
operator|-
name|zeros
decl_stmt|;
name|up
operator|+=
name|zeros
operator|,
name|usize
operator|-=
name|zeros
expr_stmt|;
if|if
condition|(
name|mpn_sub_n
argument_list|(
name|up
argument_list|,
name|up
argument_list|,
name|vp
operator|+
name|zeros
argument_list|,
name|size
argument_list|)
condition|)
block|{
while|while
condition|(
name|up
index|[
name|size
index|]
operator|==
literal|0
condition|)
comment|/* Propagate borrow. */
name|up
index|[
name|size
operator|++
index|]
operator|=
operator|-
operator|(
name|mp_limb_t
operator|)
literal|1
expr_stmt|;
name|up
index|[
name|size
index|]
operator|-=
literal|1
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|usize
condition|)
do|;
comment|/* End binary GCD.  */
block|}
name|done
label|:
if|if
condition|(
name|vp
operator|!=
name|gp
condition|)
name|MPN_COPY
argument_list|(
name|gp
argument_list|,
name|vp
argument_list|,
name|vsize
argument_list|)
expr_stmt|;
name|TMP_FREE
argument_list|(
name|marker
argument_list|)
expr_stmt|;
return|return
name|vsize
return|;
block|}
end_function

end_unit

