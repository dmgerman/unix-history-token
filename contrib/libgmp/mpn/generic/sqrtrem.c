begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mpn_sqrtrem (root_ptr, rem_ptr, op_ptr, op_size)     Write the square root of {OP_PTR, OP_SIZE} at ROOT_PTR.    Write the remainder at REM_PTR, if REM_PTR != NULL.    Return the size of the remainder.    (The size of the root is always half of the size of the operand.)     OP_PTR and ROOT_PTR may not point to the same object.    OP_PTR and REM_PTR may point to the same object.     If REM_PTR is NULL, only the root is computed and the return value of    the function is 0 if OP is a perfect square, and *any* non-zero number    otherwise.  Copyright (C) 1993, 1994, 1996 Free Software Foundation, Inc.  This file is part of the GNU MP Library.  The GNU MP Library is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  The GNU MP Library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with the GNU MP Library; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_comment
comment|/* This code is just correct if "unsigned char" has at least 8 bits.  It    doesn't help to use CHAR_BIT from limits.h, as the real problem is    the static arrays.  */
end_comment

begin_include
include|#
directive|include
file|"gmp.h"
end_include

begin_include
include|#
directive|include
file|"gmp-impl.h"
end_include

begin_include
include|#
directive|include
file|"longlong.h"
end_include

begin_comment
comment|/* Square root algorithm:     1. Shift OP (the input) to the left an even number of bits s.t. there       are an even number of words and either (or both) of the most       significant bits are set.  This way, sqrt(OP) has exactly half as       many words as OP, and has its most significant bit set.     2. Get a 9-bit approximation to sqrt(OP) using the pre-computed tables.       This approximation is used for the first single-precision       iterations of Newton's method, yielding a full-word approximation       to sqrt(OP).     3. Perform multiple-precision Newton iteration until we have the       exact result.  Only about half of the input operand is used in       this calculation, as the square root is perfectly determinable       from just the higher half of a number.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Define this macro for IEEE P854 machines with a fast sqrt instruction.  */
end_comment

begin_if
if|#
directive|if
name|defined
name|__GNUC__
operator|&&
operator|!
name|defined
name|__SOFT_FLOAT
end_if

begin_if
if|#
directive|if
name|defined
name|__sparc__
end_if

begin_define
define|#
directive|define
name|SQRT
parameter_list|(
name|a
parameter_list|)
define|\
value|({									\     double __sqrt_res;							\     asm ("fsqrtd %1,%0" : "=f" (__sqrt_res) : "f" (a));			\     __sqrt_res;								\   })
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
name|__HAVE_68881__
end_if

begin_define
define|#
directive|define
name|SQRT
parameter_list|(
name|a
parameter_list|)
define|\
value|({									\     double __sqrt_res;							\     asm ("fsqrtx %1,%0" : "=f" (__sqrt_res) : "f" (a));			\     __sqrt_res;								\   })
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
name|__hppa
end_if

begin_define
define|#
directive|define
name|SQRT
parameter_list|(
name|a
parameter_list|)
define|\
value|({									\     double __sqrt_res;							\     asm ("fsqrt,dbl %1,%0" : "=fx" (__sqrt_res) : "fx" (a));		\     __sqrt_res;								\   })
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
name|_ARCH_PWR2
end_if

begin_define
define|#
directive|define
name|SQRT
parameter_list|(
name|a
parameter_list|)
define|\
value|({									\     double __sqrt_res;							\     asm ("fsqrt %0,%1" : "=f" (__sqrt_res) : "f" (a));			\     __sqrt_res;								\   })
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SQRT
end_ifndef

begin_comment
comment|/* Tables for initial approximation of the square root.  These are    indexed with bits 1-8 of the operand for which the square root is    calculated, where bit 0 is the most significant non-zero bit.  I.e.    the most significant one-bit is not used, since that per definition    is one.  Likewise, the tables don't return the highest bit of the    result.  That bit must be inserted by or:ing the returned value with    0x100.  This way, we get a 9-bit approximation from 8-bit tables!  */
end_comment

begin_comment
comment|/* Table to be used for operands with an even total number of bits.    (Exactly as in the decimal system there are similarities between the    square root of numbers with the same initial digits and an even    difference in the total number of digits.  Consider the square root    of 1, 10, 100, 1000, ...)  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|even_approx_tab
index|[
literal|256
index|]
init|=
block|{
literal|0x6a
block|,
literal|0x6a
block|,
literal|0x6b
block|,
literal|0x6c
block|,
literal|0x6c
block|,
literal|0x6d
block|,
literal|0x6e
block|,
literal|0x6e
block|,
literal|0x6f
block|,
literal|0x70
block|,
literal|0x71
block|,
literal|0x71
block|,
literal|0x72
block|,
literal|0x73
block|,
literal|0x73
block|,
literal|0x74
block|,
literal|0x75
block|,
literal|0x75
block|,
literal|0x76
block|,
literal|0x77
block|,
literal|0x77
block|,
literal|0x78
block|,
literal|0x79
block|,
literal|0x79
block|,
literal|0x7a
block|,
literal|0x7b
block|,
literal|0x7b
block|,
literal|0x7c
block|,
literal|0x7d
block|,
literal|0x7d
block|,
literal|0x7e
block|,
literal|0x7f
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x81
block|,
literal|0x81
block|,
literal|0x82
block|,
literal|0x83
block|,
literal|0x83
block|,
literal|0x84
block|,
literal|0x85
block|,
literal|0x85
block|,
literal|0x86
block|,
literal|0x87
block|,
literal|0x87
block|,
literal|0x88
block|,
literal|0x89
block|,
literal|0x89
block|,
literal|0x8a
block|,
literal|0x8b
block|,
literal|0x8b
block|,
literal|0x8c
block|,
literal|0x8d
block|,
literal|0x8d
block|,
literal|0x8e
block|,
literal|0x8f
block|,
literal|0x8f
block|,
literal|0x90
block|,
literal|0x90
block|,
literal|0x91
block|,
literal|0x92
block|,
literal|0x92
block|,
literal|0x93
block|,
literal|0x94
block|,
literal|0x94
block|,
literal|0x95
block|,
literal|0x96
block|,
literal|0x96
block|,
literal|0x97
block|,
literal|0x97
block|,
literal|0x98
block|,
literal|0x99
block|,
literal|0x99
block|,
literal|0x9a
block|,
literal|0x9b
block|,
literal|0x9b
block|,
literal|0x9c
block|,
literal|0x9c
block|,
literal|0x9d
block|,
literal|0x9e
block|,
literal|0x9e
block|,
literal|0x9f
block|,
literal|0xa0
block|,
literal|0xa0
block|,
literal|0xa1
block|,
literal|0xa1
block|,
literal|0xa2
block|,
literal|0xa3
block|,
literal|0xa3
block|,
literal|0xa4
block|,
literal|0xa4
block|,
literal|0xa5
block|,
literal|0xa6
block|,
literal|0xa6
block|,
literal|0xa7
block|,
literal|0xa7
block|,
literal|0xa8
block|,
literal|0xa9
block|,
literal|0xa9
block|,
literal|0xaa
block|,
literal|0xaa
block|,
literal|0xab
block|,
literal|0xac
block|,
literal|0xac
block|,
literal|0xad
block|,
literal|0xad
block|,
literal|0xae
block|,
literal|0xaf
block|,
literal|0xaf
block|,
literal|0xb0
block|,
literal|0xb0
block|,
literal|0xb1
block|,
literal|0xb2
block|,
literal|0xb2
block|,
literal|0xb3
block|,
literal|0xb3
block|,
literal|0xb4
block|,
literal|0xb5
block|,
literal|0xb5
block|,
literal|0xb6
block|,
literal|0xb6
block|,
literal|0xb7
block|,
literal|0xb7
block|,
literal|0xb8
block|,
literal|0xb9
block|,
literal|0xb9
block|,
literal|0xba
block|,
literal|0xba
block|,
literal|0xbb
block|,
literal|0xbb
block|,
literal|0xbc
block|,
literal|0xbd
block|,
literal|0xbd
block|,
literal|0xbe
block|,
literal|0xbe
block|,
literal|0xbf
block|,
literal|0xc0
block|,
literal|0xc0
block|,
literal|0xc1
block|,
literal|0xc1
block|,
literal|0xc2
block|,
literal|0xc2
block|,
literal|0xc3
block|,
literal|0xc3
block|,
literal|0xc4
block|,
literal|0xc5
block|,
literal|0xc5
block|,
literal|0xc6
block|,
literal|0xc6
block|,
literal|0xc7
block|,
literal|0xc7
block|,
literal|0xc8
block|,
literal|0xc9
block|,
literal|0xc9
block|,
literal|0xca
block|,
literal|0xca
block|,
literal|0xcb
block|,
literal|0xcb
block|,
literal|0xcc
block|,
literal|0xcc
block|,
literal|0xcd
block|,
literal|0xce
block|,
literal|0xce
block|,
literal|0xcf
block|,
literal|0xcf
block|,
literal|0xd0
block|,
literal|0xd0
block|,
literal|0xd1
block|,
literal|0xd1
block|,
literal|0xd2
block|,
literal|0xd3
block|,
literal|0xd3
block|,
literal|0xd4
block|,
literal|0xd4
block|,
literal|0xd5
block|,
literal|0xd5
block|,
literal|0xd6
block|,
literal|0xd6
block|,
literal|0xd7
block|,
literal|0xd7
block|,
literal|0xd8
block|,
literal|0xd9
block|,
literal|0xd9
block|,
literal|0xda
block|,
literal|0xda
block|,
literal|0xdb
block|,
literal|0xdb
block|,
literal|0xdc
block|,
literal|0xdc
block|,
literal|0xdd
block|,
literal|0xdd
block|,
literal|0xde
block|,
literal|0xde
block|,
literal|0xdf
block|,
literal|0xe0
block|,
literal|0xe0
block|,
literal|0xe1
block|,
literal|0xe1
block|,
literal|0xe2
block|,
literal|0xe2
block|,
literal|0xe3
block|,
literal|0xe3
block|,
literal|0xe4
block|,
literal|0xe4
block|,
literal|0xe5
block|,
literal|0xe5
block|,
literal|0xe6
block|,
literal|0xe6
block|,
literal|0xe7
block|,
literal|0xe7
block|,
literal|0xe8
block|,
literal|0xe8
block|,
literal|0xe9
block|,
literal|0xea
block|,
literal|0xea
block|,
literal|0xeb
block|,
literal|0xeb
block|,
literal|0xec
block|,
literal|0xec
block|,
literal|0xed
block|,
literal|0xed
block|,
literal|0xee
block|,
literal|0xee
block|,
literal|0xef
block|,
literal|0xef
block|,
literal|0xf0
block|,
literal|0xf0
block|,
literal|0xf1
block|,
literal|0xf1
block|,
literal|0xf2
block|,
literal|0xf2
block|,
literal|0xf3
block|,
literal|0xf3
block|,
literal|0xf4
block|,
literal|0xf4
block|,
literal|0xf5
block|,
literal|0xf5
block|,
literal|0xf6
block|,
literal|0xf6
block|,
literal|0xf7
block|,
literal|0xf7
block|,
literal|0xf8
block|,
literal|0xf8
block|,
literal|0xf9
block|,
literal|0xf9
block|,
literal|0xfa
block|,
literal|0xfa
block|,
literal|0xfb
block|,
literal|0xfb
block|,
literal|0xfc
block|,
literal|0xfc
block|,
literal|0xfd
block|,
literal|0xfd
block|,
literal|0xfe
block|,
literal|0xfe
block|,
literal|0xff
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table to be used for operands with an odd total number of bits.    (Further comments before previous table.)  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|odd_approx_tab
index|[
literal|256
index|]
init|=
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x02
block|,
literal|0x02
block|,
literal|0x03
block|,
literal|0x03
block|,
literal|0x04
block|,
literal|0x04
block|,
literal|0x05
block|,
literal|0x05
block|,
literal|0x06
block|,
literal|0x06
block|,
literal|0x07
block|,
literal|0x07
block|,
literal|0x08
block|,
literal|0x08
block|,
literal|0x09
block|,
literal|0x09
block|,
literal|0x0a
block|,
literal|0x0a
block|,
literal|0x0b
block|,
literal|0x0b
block|,
literal|0x0c
block|,
literal|0x0c
block|,
literal|0x0d
block|,
literal|0x0d
block|,
literal|0x0e
block|,
literal|0x0e
block|,
literal|0x0f
block|,
literal|0x0f
block|,
literal|0x10
block|,
literal|0x10
block|,
literal|0x10
block|,
literal|0x11
block|,
literal|0x11
block|,
literal|0x12
block|,
literal|0x12
block|,
literal|0x13
block|,
literal|0x13
block|,
literal|0x14
block|,
literal|0x14
block|,
literal|0x15
block|,
literal|0x15
block|,
literal|0x16
block|,
literal|0x16
block|,
literal|0x16
block|,
literal|0x17
block|,
literal|0x17
block|,
literal|0x18
block|,
literal|0x18
block|,
literal|0x19
block|,
literal|0x19
block|,
literal|0x1a
block|,
literal|0x1a
block|,
literal|0x1b
block|,
literal|0x1b
block|,
literal|0x1b
block|,
literal|0x1c
block|,
literal|0x1c
block|,
literal|0x1d
block|,
literal|0x1d
block|,
literal|0x1e
block|,
literal|0x1e
block|,
literal|0x1f
block|,
literal|0x1f
block|,
literal|0x20
block|,
literal|0x20
block|,
literal|0x20
block|,
literal|0x21
block|,
literal|0x21
block|,
literal|0x22
block|,
literal|0x22
block|,
literal|0x23
block|,
literal|0x23
block|,
literal|0x23
block|,
literal|0x24
block|,
literal|0x24
block|,
literal|0x25
block|,
literal|0x25
block|,
literal|0x26
block|,
literal|0x26
block|,
literal|0x27
block|,
literal|0x27
block|,
literal|0x27
block|,
literal|0x28
block|,
literal|0x28
block|,
literal|0x29
block|,
literal|0x29
block|,
literal|0x2a
block|,
literal|0x2a
block|,
literal|0x2a
block|,
literal|0x2b
block|,
literal|0x2b
block|,
literal|0x2c
block|,
literal|0x2c
block|,
literal|0x2d
block|,
literal|0x2d
block|,
literal|0x2d
block|,
literal|0x2e
block|,
literal|0x2e
block|,
literal|0x2f
block|,
literal|0x2f
block|,
literal|0x30
block|,
literal|0x30
block|,
literal|0x30
block|,
literal|0x31
block|,
literal|0x31
block|,
literal|0x32
block|,
literal|0x32
block|,
literal|0x32
block|,
literal|0x33
block|,
literal|0x33
block|,
literal|0x34
block|,
literal|0x34
block|,
literal|0x35
block|,
literal|0x35
block|,
literal|0x35
block|,
literal|0x36
block|,
literal|0x36
block|,
literal|0x37
block|,
literal|0x37
block|,
literal|0x37
block|,
literal|0x38
block|,
literal|0x38
block|,
literal|0x39
block|,
literal|0x39
block|,
literal|0x39
block|,
literal|0x3a
block|,
literal|0x3a
block|,
literal|0x3b
block|,
literal|0x3b
block|,
literal|0x3b
block|,
literal|0x3c
block|,
literal|0x3c
block|,
literal|0x3d
block|,
literal|0x3d
block|,
literal|0x3d
block|,
literal|0x3e
block|,
literal|0x3e
block|,
literal|0x3f
block|,
literal|0x3f
block|,
literal|0x40
block|,
literal|0x40
block|,
literal|0x40
block|,
literal|0x41
block|,
literal|0x41
block|,
literal|0x41
block|,
literal|0x42
block|,
literal|0x42
block|,
literal|0x43
block|,
literal|0x43
block|,
literal|0x43
block|,
literal|0x44
block|,
literal|0x44
block|,
literal|0x45
block|,
literal|0x45
block|,
literal|0x45
block|,
literal|0x46
block|,
literal|0x46
block|,
literal|0x47
block|,
literal|0x47
block|,
literal|0x47
block|,
literal|0x48
block|,
literal|0x48
block|,
literal|0x49
block|,
literal|0x49
block|,
literal|0x49
block|,
literal|0x4a
block|,
literal|0x4a
block|,
literal|0x4b
block|,
literal|0x4b
block|,
literal|0x4b
block|,
literal|0x4c
block|,
literal|0x4c
block|,
literal|0x4c
block|,
literal|0x4d
block|,
literal|0x4d
block|,
literal|0x4e
block|,
literal|0x4e
block|,
literal|0x4e
block|,
literal|0x4f
block|,
literal|0x4f
block|,
literal|0x50
block|,
literal|0x50
block|,
literal|0x50
block|,
literal|0x51
block|,
literal|0x51
block|,
literal|0x51
block|,
literal|0x52
block|,
literal|0x52
block|,
literal|0x53
block|,
literal|0x53
block|,
literal|0x53
block|,
literal|0x54
block|,
literal|0x54
block|,
literal|0x54
block|,
literal|0x55
block|,
literal|0x55
block|,
literal|0x56
block|,
literal|0x56
block|,
literal|0x56
block|,
literal|0x57
block|,
literal|0x57
block|,
literal|0x57
block|,
literal|0x58
block|,
literal|0x58
block|,
literal|0x59
block|,
literal|0x59
block|,
literal|0x59
block|,
literal|0x5a
block|,
literal|0x5a
block|,
literal|0x5a
block|,
literal|0x5b
block|,
literal|0x5b
block|,
literal|0x5b
block|,
literal|0x5c
block|,
literal|0x5c
block|,
literal|0x5d
block|,
literal|0x5d
block|,
literal|0x5d
block|,
literal|0x5e
block|,
literal|0x5e
block|,
literal|0x5e
block|,
literal|0x5f
block|,
literal|0x5f
block|,
literal|0x60
block|,
literal|0x60
block|,
literal|0x60
block|,
literal|0x61
block|,
literal|0x61
block|,
literal|0x61
block|,
literal|0x62
block|,
literal|0x62
block|,
literal|0x62
block|,
literal|0x63
block|,
literal|0x63
block|,
literal|0x63
block|,
literal|0x64
block|,
literal|0x64
block|,
literal|0x65
block|,
literal|0x65
block|,
literal|0x65
block|,
literal|0x66
block|,
literal|0x66
block|,
literal|0x66
block|,
literal|0x67
block|,
literal|0x67
block|,
literal|0x67
block|,
literal|0x68
block|,
literal|0x68
block|,
literal|0x68
block|,
literal|0x69
block|,
literal|0x69
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_function
name|mp_size_t
if|#
directive|if
name|__STDC__
name|mpn_sqrtrem
parameter_list|(
name|mp_ptr
name|root_ptr
parameter_list|,
name|mp_ptr
name|rem_ptr
parameter_list|,
name|mp_srcptr
name|op_ptr
parameter_list|,
name|mp_size_t
name|op_size
parameter_list|)
else|#
directive|else
function|mpn_sqrtrem
parameter_list|(
name|root_ptr
parameter_list|,
name|rem_ptr
parameter_list|,
name|op_ptr
parameter_list|,
name|op_size
parameter_list|)
name|mp_ptr
name|root_ptr
decl_stmt|;
name|mp_ptr
name|rem_ptr
decl_stmt|;
name|mp_srcptr
name|op_ptr
decl_stmt|;
name|mp_size_t
name|op_size
decl_stmt|;
endif|#
directive|endif
block|{
comment|/* R (root result) */
name|mp_ptr
name|rp
decl_stmt|;
comment|/* Pointer to least significant word */
name|mp_size_t
name|rsize
decl_stmt|;
comment|/* The size in words */
comment|/* T (OP shifted to the left a.k.a. normalized) */
name|mp_ptr
name|tp
decl_stmt|;
comment|/* Pointer to least significant word */
name|mp_size_t
name|tsize
decl_stmt|;
comment|/* The size in words */
name|mp_ptr
name|t_end_ptr
decl_stmt|;
comment|/* Pointer right beyond most sign. word */
name|mp_limb_t
name|t_high0
decl_stmt|,
name|t_high1
decl_stmt|;
comment|/* The two most significant words */
comment|/* TT (temporary for numerator/remainder) */
name|mp_ptr
name|ttp
decl_stmt|;
comment|/* Pointer to least significant word */
comment|/* X (temporary for quotient in main loop) */
name|mp_ptr
name|xp
decl_stmt|;
comment|/* Pointer to least significant word */
name|mp_size_t
name|xsize
decl_stmt|;
comment|/* The size in words */
name|unsigned
name|cnt
decl_stmt|;
name|mp_limb_t
name|initial_approx
decl_stmt|;
comment|/* Initially made approximation */
name|mp_size_t
name|tsizes
index|[
name|BITS_PER_MP_LIMB
index|]
decl_stmt|;
comment|/* Successive calculation precisions */
name|mp_size_t
name|tmp
decl_stmt|;
name|mp_size_t
name|i
decl_stmt|;
name|mp_limb_t
name|cy_limb
decl_stmt|;
name|TMP_DECL
argument_list|(
name|marker
argument_list|)
expr_stmt|;
comment|/* If OP is zero, both results are zero.  */
if|if
condition|(
name|op_size
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|count_leading_zeros
argument_list|(
name|cnt
argument_list|,
name|op_ptr
index|[
name|op_size
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|tsize
operator|=
name|op_size
expr_stmt|;
if|if
condition|(
operator|(
name|tsize
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|cnt
operator|+=
name|BITS_PER_MP_LIMB
expr_stmt|;
name|tsize
operator|++
expr_stmt|;
block|}
name|rsize
operator|=
name|tsize
operator|/
literal|2
expr_stmt|;
name|rp
operator|=
name|root_ptr
expr_stmt|;
name|TMP_MARK
argument_list|(
name|marker
argument_list|)
expr_stmt|;
comment|/* Shift OP an even number of bits into T, such that either the most or      the second most significant bit is set, and such that the number of      words in T becomes even.  This way, the number of words in R=sqrt(OP)      is exactly half as many as in OP, and the most significant bit of R      is set.       Also, the initial approximation is simplified by this up-shifted OP.       Finally, the Newtonian iteration which is the main part of this      program performs division by R.  The fast division routine expects      the divisor to be "normalized" in exactly the sense of having the      most significant bit set.  */
name|tp
operator|=
operator|(
name|mp_ptr
operator|)
name|TMP_ALLOC
argument_list|(
name|tsize
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cnt
operator|&
operator|~
literal|1
operator|)
operator|%
name|BITS_PER_MP_LIMB
operator|!=
literal|0
condition|)
name|t_high0
operator|=
name|mpn_lshift
argument_list|(
name|tp
operator|+
name|cnt
operator|/
name|BITS_PER_MP_LIMB
argument_list|,
name|op_ptr
argument_list|,
name|op_size
argument_list|,
operator|(
name|cnt
operator|&
operator|~
literal|1
operator|)
operator|%
name|BITS_PER_MP_LIMB
argument_list|)
expr_stmt|;
else|else
name|MPN_COPY
argument_list|(
name|tp
operator|+
name|cnt
operator|/
name|BITS_PER_MP_LIMB
argument_list|,
name|op_ptr
argument_list|,
name|op_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|>=
name|BITS_PER_MP_LIMB
condition|)
name|tp
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|t_high0
operator|=
name|tp
index|[
name|tsize
operator|-
literal|1
index|]
expr_stmt|;
name|t_high1
operator|=
name|tp
index|[
name|tsize
operator|-
literal|2
index|]
expr_stmt|;
comment|/* Never stray.  TSIZE is>= 2.  */
comment|/* Is there a fast sqrt instruction defined for this machine?  */
ifdef|#
directive|ifdef
name|SQRT
block|{
name|initial_approx
operator|=
name|SQRT
argument_list|(
name|t_high0
operator|*
literal|2.0
operator|*
operator|(
operator|(
name|mp_limb_t
operator|)
literal|1
operator|<<
operator|(
name|BITS_PER_MP_LIMB
operator|-
literal|1
operator|)
operator|)
operator|+
name|t_high1
argument_list|)
expr_stmt|;
comment|/* If t_high0,,t_high1 is big, the result in INITIAL_APPROX might have        become incorrect due to overflow in the conversion from double to        mp_limb_t above.  It will typically be zero in that case, but might be        a small number on some machines.  The most significant bit of        INITIAL_APPROX should be set, so that bit is a good overflow        indication.  */
if|if
condition|(
operator|(
name|mp_limb_signed_t
operator|)
name|initial_approx
operator|>=
literal|0
condition|)
name|initial_approx
operator|=
operator|~
operator|(
name|mp_limb_t
operator|)
literal|0
expr_stmt|;
block|}
else|#
directive|else
comment|/* Get a 9 bit approximation from the tables.  The tables expect to      be indexed with the 8 high bits right below the highest bit.      Also, the highest result bit is not returned by the tables, and      must be or:ed into the result.  The scheme gives 9 bits of start      approximation with just 256-entry 8 bit tables.  */
if|if
condition|(
operator|(
name|cnt
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* The most sign bit of t_high0 is set.  */
name|initial_approx
operator|=
name|t_high0
operator|>>
operator|(
name|BITS_PER_MP_LIMB
operator|-
literal|8
operator|-
literal|1
operator|)
expr_stmt|;
name|initial_approx
operator|&=
literal|0xff
expr_stmt|;
name|initial_approx
operator|=
name|even_approx_tab
index|[
name|initial_approx
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* The most significant bit of T_HIGH0 is unset, 	 the second most significant is set.  */
name|initial_approx
operator|=
name|t_high0
operator|>>
operator|(
name|BITS_PER_MP_LIMB
operator|-
literal|8
operator|-
literal|2
operator|)
expr_stmt|;
name|initial_approx
operator|&=
literal|0xff
expr_stmt|;
name|initial_approx
operator|=
name|odd_approx_tab
index|[
name|initial_approx
index|]
expr_stmt|;
block|}
name|initial_approx
operator||=
literal|0x100
expr_stmt|;
name|initial_approx
operator|<<=
name|BITS_PER_MP_LIMB
operator|-
literal|8
operator|-
literal|1
expr_stmt|;
comment|/* Perform small precision Newtonian iterations to get a full word      approximation.  For small operands, these iteration will make the      entire job.  */
if|if
condition|(
name|t_high0
operator|==
operator|~
operator|(
name|mp_limb_t
operator|)
literal|0
condition|)
name|initial_approx
operator|=
name|t_high0
expr_stmt|;
else|else
block|{
name|mp_limb_t
name|quot
decl_stmt|;
if|if
condition|(
name|t_high0
operator|>=
name|initial_approx
condition|)
name|initial_approx
operator|=
name|t_high0
operator|+
literal|1
expr_stmt|;
comment|/* First get about 18 bits with pure C arithmetics.  */
name|quot
operator|=
name|t_high0
operator|/
operator|(
name|initial_approx
operator|>>
name|BITS_PER_MP_LIMB
operator|/
literal|2
operator|)
operator|<<
name|BITS_PER_MP_LIMB
operator|/
literal|2
expr_stmt|;
name|initial_approx
operator|=
operator|(
name|initial_approx
operator|+
name|quot
operator|)
operator|/
literal|2
expr_stmt|;
name|initial_approx
operator||=
operator|(
name|mp_limb_t
operator|)
literal|1
operator|<<
operator|(
name|BITS_PER_MP_LIMB
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Now get a full word by one (or for> 36 bit machines) several 	 iterations.  */
for|for
control|(
name|i
operator|=
literal|16
init|;
name|i
operator|<
name|BITS_PER_MP_LIMB
condition|;
name|i
operator|<<=
literal|1
control|)
block|{
name|mp_limb_t
name|ignored_remainder
decl_stmt|;
name|udiv_qrnnd
argument_list|(
name|quot
argument_list|,
name|ignored_remainder
argument_list|,
name|t_high0
argument_list|,
name|t_high1
argument_list|,
name|initial_approx
argument_list|)
expr_stmt|;
name|initial_approx
operator|=
operator|(
name|initial_approx
operator|+
name|quot
operator|)
operator|/
literal|2
expr_stmt|;
name|initial_approx
operator||=
operator|(
name|mp_limb_t
operator|)
literal|1
operator|<<
operator|(
name|BITS_PER_MP_LIMB
operator|-
literal|1
operator|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|rp
index|[
literal|0
index|]
operator|=
name|initial_approx
expr_stmt|;
name|rsize
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"\n\nT = "
argument_list|)
expr_stmt|;
name|mpn_dump
argument_list|(
name|tp
argument_list|,
name|tsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tsize
operator|>
literal|2
condition|)
block|{
comment|/* Determine the successive precisions to use in the iteration.  We 	 minimize the precisions, beginning with the highest (i.e. last 	 iteration) to the lowest (i.e. first iteration).  */
name|xp
operator|=
operator|(
name|mp_ptr
operator|)
name|TMP_ALLOC
argument_list|(
name|tsize
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
name|ttp
operator|=
operator|(
name|mp_ptr
operator|)
name|TMP_ALLOC
argument_list|(
name|tsize
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
name|t_end_ptr
operator|=
name|tp
operator|+
name|tsize
expr_stmt|;
name|tmp
operator|=
name|tsize
operator|/
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
name|tsize
operator|=
operator|(
name|tmp
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|tsize
condition|)
break|break;
name|tsizes
index|[
name|i
index|]
operator|=
name|tsize
operator|+
name|tmp
expr_stmt|;
name|tmp
operator|=
name|tsize
expr_stmt|;
block|}
comment|/* Main Newton iteration loop.  For big arguments, most of the 	 time is spent here.  */
comment|/* It is possible to do a great optimization here.  The successive 	 divisors in the mpn_divmod call below has more and more leading 	 words equal to its predecessor.  Therefore the beginning of 	 each division will repeat the same work as did the last 	 division.  If we could guarantee that the leading words of two 	 consecutive divisors are the same (i.e. in this case, a later 	 divisor has just more digits at the end) it would be a simple 	 matter of just using the old remainder of the last division in 	 a subsequent division, to take care of this optimization.  This 	 idea would surely make a difference even for small arguments.  */
comment|/* Loop invariants:  	 R<= shiftdown_to_same_size(floor(sqrt(OP)))< R + 1. 	 X - 1< shiftdown_to_same_size(floor(sqrt(OP)))<= X. 	 R<= shiftdown_to_same_size(X).  */
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
block|{
name|mp_limb_t
name|cy
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|mp_limb_t
name|old_least_sign_r
init|=
name|rp
index|[
literal|0
index|]
decl_stmt|;
name|mp_size_t
name|old_rsize
init|=
name|rsize
decl_stmt|;
name|printf
argument_list|(
literal|"R = "
argument_list|)
expr_stmt|;
name|mpn_dump
argument_list|(
name|rp
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tsize
operator|=
name|tsizes
index|[
name|i
index|]
expr_stmt|;
comment|/* Need to copy the numerator into temporary space, as 	     mpn_divmod overwrites its numerator argument with the 	     remainder (which we currently ignore).  */
name|MPN_COPY
argument_list|(
name|ttp
argument_list|,
name|t_end_ptr
operator|-
name|tsize
argument_list|,
name|tsize
argument_list|)
expr_stmt|;
name|cy
operator|=
name|mpn_divmod
argument_list|(
name|xp
argument_list|,
name|ttp
argument_list|,
name|tsize
argument_list|,
name|rp
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|xsize
operator|=
name|tsize
operator|-
name|rsize
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"X =%d "
argument_list|,
name|cy
argument_list|)
expr_stmt|;
name|mpn_dump
argument_list|(
name|xp
argument_list|,
name|xsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Add X and R with the most significant limbs aligned, 	     temporarily ignoring at least one limb at the low end of X.  */
name|tmp
operator|=
name|xsize
operator|-
name|rsize
expr_stmt|;
name|cy
operator|+=
name|mpn_add_n
argument_list|(
name|xp
operator|+
name|tmp
argument_list|,
name|rp
argument_list|,
name|xp
operator|+
name|tmp
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
comment|/* If T begins with more than 2 x BITS_PER_MP_LIMB of ones, we get 	     intermediate roots that'd need an extra bit.  We don't want to 	     handle that since it would make the subsequent divisor 	     non-normalized, so round such roots down to be only ones in the 	     current precision.  */
if|if
condition|(
name|cy
operator|==
literal|2
condition|)
block|{
name|mp_size_t
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|xsize
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|xp
index|[
name|j
index|]
operator|=
operator|~
operator|(
name|mp_limb_t
operator|)
literal|0
expr_stmt|;
block|}
comment|/* Divide X by 2 and put the result in R.  This is the new 	     approximation.  Shift in the carry from the addition.  */
name|mpn_rshift
argument_list|(
name|rp
argument_list|,
name|xp
argument_list|,
name|xsize
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rp
index|[
name|xsize
operator|-
literal|1
index|]
operator||=
operator|(
operator|(
name|mp_limb_t
operator|)
literal|1
operator|<<
operator|(
name|BITS_PER_MP_LIMB
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|rsize
operator|=
name|xsize
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|old_least_sign_r
operator|!=
name|rp
index|[
name|rsize
operator|-
name|old_rsize
index|]
condition|)
name|printf
argument_list|(
literal|">>>>>>>> %d: %0*lX, %0*lX<<<<<<<<\n"
argument_list|,
name|i
argument_list|,
literal|2
operator|*
name|BYTES_PER_MP_LIMB
argument_list|,
name|old_least_sign_r
argument_list|,
literal|2
operator|*
name|BYTES_PER_MP_LIMB
argument_list|,
name|rp
index|[
name|rsize
operator|-
name|old_rsize
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"(final) R = "
argument_list|)
expr_stmt|;
name|mpn_dump
argument_list|(
name|rp
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* We computed the square root of OP * 2**(2*floor(cnt/2)).      This has resulted in R being 2**floor(cnt/2) to large.      Shift it down here to fix that.  */
if|if
condition|(
name|cnt
operator|/
literal|2
operator|!=
literal|0
condition|)
block|{
name|mpn_rshift
argument_list|(
name|rp
argument_list|,
name|rp
argument_list|,
name|rsize
argument_list|,
name|cnt
operator|/
literal|2
argument_list|)
expr_stmt|;
name|rsize
operator|-=
name|rp
index|[
name|rsize
operator|-
literal|1
index|]
operator|==
literal|0
expr_stmt|;
block|}
comment|/* Calculate the remainder.  */
name|mpn_mul_n
argument_list|(
name|tp
argument_list|,
name|rp
argument_list|,
name|rp
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|tsize
operator|=
name|rsize
operator|+
name|rsize
expr_stmt|;
name|tsize
operator|-=
name|tp
index|[
name|tsize
operator|-
literal|1
index|]
operator|==
literal|0
expr_stmt|;
if|if
condition|(
name|op_size
operator|<
name|tsize
operator|||
operator|(
name|op_size
operator|==
name|tsize
operator|&&
name|mpn_cmp
argument_list|(
name|op_ptr
argument_list|,
name|tp
argument_list|,
name|op_size
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
comment|/* R is too large.  Decrement it.  */
comment|/* These operations can't overflow.  */
name|cy_limb
operator|=
name|mpn_sub_n
argument_list|(
name|tp
argument_list|,
name|tp
argument_list|,
name|rp
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|cy_limb
operator|+=
name|mpn_sub_n
argument_list|(
name|tp
argument_list|,
name|tp
argument_list|,
name|rp
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|mpn_sub_1
argument_list|(
name|tp
operator|+
name|rsize
argument_list|,
name|tp
operator|+
name|rsize
argument_list|,
name|tsize
operator|-
name|rsize
argument_list|,
name|cy_limb
argument_list|)
expr_stmt|;
name|mpn_add_1
argument_list|(
name|tp
argument_list|,
name|tp
argument_list|,
name|tsize
argument_list|,
operator|(
name|mp_limb_t
operator|)
literal|1
argument_list|)
expr_stmt|;
name|mpn_sub_1
argument_list|(
name|rp
argument_list|,
name|rp
argument_list|,
name|rsize
argument_list|,
operator|(
name|mp_limb_t
operator|)
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"(adjusted) R = "
argument_list|)
expr_stmt|;
name|mpn_dump
argument_list|(
name|rp
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|rem_ptr
operator|!=
name|NULL
condition|)
block|{
name|cy_limb
operator|=
name|mpn_sub
argument_list|(
name|rem_ptr
argument_list|,
name|op_ptr
argument_list|,
name|op_size
argument_list|,
name|tp
argument_list|,
name|tsize
argument_list|)
expr_stmt|;
name|MPN_NORMALIZE
argument_list|(
name|rem_ptr
argument_list|,
name|op_size
argument_list|)
expr_stmt|;
name|TMP_FREE
argument_list|(
name|marker
argument_list|)
expr_stmt|;
return|return
name|op_size
return|;
block|}
else|else
block|{
name|int
name|res
decl_stmt|;
name|res
operator|=
name|op_size
operator|!=
name|tsize
operator|||
name|mpn_cmp
argument_list|(
name|op_ptr
argument_list|,
name|tp
argument_list|,
name|op_size
argument_list|)
expr_stmt|;
name|TMP_FREE
argument_list|(
name|marker
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
block|}
end_function

end_unit

