begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mpn_mul -- Multiply two natural numbers.  Copyright (C) 1991, 1993, 1994, 1996 Free Software Foundation, Inc.  This file is part of the GNU MP Library.  The GNU MP Library is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  The GNU MP Library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with the GNU MP Library; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_include
include|#
directive|include
file|"gmp.h"
end_include

begin_include
include|#
directive|include
file|"gmp-impl.h"
end_include

begin_comment
comment|/* Multiply the natural numbers u (pointed to by UP, with USIZE limbs)    and v (pointed to by VP, with VSIZE limbs), and store the result at    PRODP.  USIZE + VSIZE limbs are always stored, but if the input    operands are normalized.  Return the most significant limb of the    result.     NOTE: The space pointed to by PRODP is overwritten before finished    with U and V, so overlap is an error.     Argument constraints:    1. USIZE>= VSIZE.    2. PRODP != UP and PRODP != VP, i.e. the destination       must be distinct from the multiplier and the multiplicand.  */
end_comment

begin_comment
comment|/* If KARATSUBA_THRESHOLD is not already defined, define it to a    value which is good on most machines.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|KARATSUBA_THRESHOLD
end_ifndef

begin_define
define|#
directive|define
name|KARATSUBA_THRESHOLD
value|32
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|mp_limb_t
if|#
directive|if
name|__STDC__
name|mpn_mul
parameter_list|(
name|mp_ptr
name|prodp
parameter_list|,
name|mp_srcptr
name|up
parameter_list|,
name|mp_size_t
name|usize
parameter_list|,
name|mp_srcptr
name|vp
parameter_list|,
name|mp_size_t
name|vsize
parameter_list|)
else|#
directive|else
function|mpn_mul
parameter_list|(
name|prodp
parameter_list|,
name|up
parameter_list|,
name|usize
parameter_list|,
name|vp
parameter_list|,
name|vsize
parameter_list|)
name|mp_ptr
name|prodp
decl_stmt|;
name|mp_srcptr
name|up
decl_stmt|;
name|mp_size_t
name|usize
decl_stmt|;
name|mp_srcptr
name|vp
decl_stmt|;
name|mp_size_t
name|vsize
decl_stmt|;
endif|#
directive|endif
block|{
name|mp_ptr
name|prod_endp
init|=
name|prodp
operator|+
name|usize
operator|+
name|vsize
operator|-
literal|1
decl_stmt|;
name|mp_limb_t
name|cy
decl_stmt|;
name|mp_ptr
name|tspace
decl_stmt|;
name|TMP_DECL
argument_list|(
name|marker
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsize
operator|<
name|KARATSUBA_THRESHOLD
condition|)
block|{
comment|/* Handle simple cases with traditional multiplication.  	 This is the most critical code of the entire function.  All 	 multiplies rely on this, both small and huge.  Small ones arrive 	 here immediately.  Huge ones arrive here as this is the base case 	 for Karatsuba's recursive algorithm below.  */
name|mp_size_t
name|i
decl_stmt|;
name|mp_limb_t
name|cy_limb
decl_stmt|;
name|mp_limb_t
name|v_limb
decl_stmt|;
if|if
condition|(
name|vsize
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Multiply by the first limb in V separately, as the result can be 	 stored (not added) to PROD.  We also avoid a loop for zeroing.  */
name|v_limb
operator|=
name|vp
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|v_limb
operator|<=
literal|1
condition|)
block|{
if|if
condition|(
name|v_limb
operator|==
literal|1
condition|)
name|MPN_COPY
argument_list|(
name|prodp
argument_list|,
name|up
argument_list|,
name|usize
argument_list|)
expr_stmt|;
else|else
name|MPN_ZERO
argument_list|(
name|prodp
argument_list|,
name|usize
argument_list|)
expr_stmt|;
name|cy_limb
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|cy_limb
operator|=
name|mpn_mul_1
argument_list|(
name|prodp
argument_list|,
name|up
argument_list|,
name|usize
argument_list|,
name|v_limb
argument_list|)
expr_stmt|;
name|prodp
index|[
name|usize
index|]
operator|=
name|cy_limb
expr_stmt|;
name|prodp
operator|++
expr_stmt|;
comment|/* For each iteration in the outer loop, multiply one limb from 	 U with one limb from V, and add it to PROD.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|vsize
condition|;
name|i
operator|++
control|)
block|{
name|v_limb
operator|=
name|vp
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|v_limb
operator|<=
literal|1
condition|)
block|{
name|cy_limb
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|v_limb
operator|==
literal|1
condition|)
name|cy_limb
operator|=
name|mpn_add_n
argument_list|(
name|prodp
argument_list|,
name|prodp
argument_list|,
name|up
argument_list|,
name|usize
argument_list|)
expr_stmt|;
block|}
else|else
name|cy_limb
operator|=
name|mpn_addmul_1
argument_list|(
name|prodp
argument_list|,
name|up
argument_list|,
name|usize
argument_list|,
name|v_limb
argument_list|)
expr_stmt|;
name|prodp
index|[
name|usize
index|]
operator|=
name|cy_limb
expr_stmt|;
name|prodp
operator|++
expr_stmt|;
block|}
return|return
name|cy_limb
return|;
block|}
name|TMP_MARK
argument_list|(
name|marker
argument_list|)
expr_stmt|;
name|tspace
operator|=
operator|(
name|mp_ptr
operator|)
name|TMP_ALLOC
argument_list|(
literal|2
operator|*
name|vsize
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
name|MPN_MUL_N_RECURSE
argument_list|(
name|prodp
argument_list|,
name|up
argument_list|,
name|vp
argument_list|,
name|vsize
argument_list|,
name|tspace
argument_list|)
expr_stmt|;
name|prodp
operator|+=
name|vsize
expr_stmt|;
name|up
operator|+=
name|vsize
expr_stmt|;
name|usize
operator|-=
name|vsize
expr_stmt|;
if|if
condition|(
name|usize
operator|>=
name|vsize
condition|)
block|{
name|mp_ptr
name|tp
init|=
operator|(
name|mp_ptr
operator|)
name|TMP_ALLOC
argument_list|(
literal|2
operator|*
name|vsize
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
decl_stmt|;
do|do
block|{
name|MPN_MUL_N_RECURSE
argument_list|(
name|tp
argument_list|,
name|up
argument_list|,
name|vp
argument_list|,
name|vsize
argument_list|,
name|tspace
argument_list|)
expr_stmt|;
name|cy
operator|=
name|mpn_add_n
argument_list|(
name|prodp
argument_list|,
name|prodp
argument_list|,
name|tp
argument_list|,
name|vsize
argument_list|)
expr_stmt|;
name|mpn_add_1
argument_list|(
name|prodp
operator|+
name|vsize
argument_list|,
name|tp
operator|+
name|vsize
argument_list|,
name|vsize
argument_list|,
name|cy
argument_list|)
expr_stmt|;
name|prodp
operator|+=
name|vsize
expr_stmt|;
name|up
operator|+=
name|vsize
expr_stmt|;
name|usize
operator|-=
name|vsize
expr_stmt|;
block|}
do|while
condition|(
name|usize
operator|>=
name|vsize
condition|)
do|;
block|}
comment|/* True: usize< vsize.  */
comment|/* Make life simple: Recurse.  */
if|if
condition|(
name|usize
operator|!=
literal|0
condition|)
block|{
name|mpn_mul
argument_list|(
name|tspace
argument_list|,
name|vp
argument_list|,
name|vsize
argument_list|,
name|up
argument_list|,
name|usize
argument_list|)
expr_stmt|;
name|cy
operator|=
name|mpn_add_n
argument_list|(
name|prodp
argument_list|,
name|prodp
argument_list|,
name|tspace
argument_list|,
name|vsize
argument_list|)
expr_stmt|;
name|mpn_add_1
argument_list|(
name|prodp
operator|+
name|vsize
argument_list|,
name|tspace
operator|+
name|vsize
argument_list|,
name|usize
argument_list|,
name|cy
argument_list|)
expr_stmt|;
block|}
name|TMP_FREE
argument_list|(
name|marker
argument_list|)
expr_stmt|;
return|return
operator|*
name|prod_endp
return|;
block|}
end_function

end_unit

