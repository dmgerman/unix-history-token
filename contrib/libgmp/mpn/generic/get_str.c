begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mpn_get_str -- Convert a MSIZE long limb vector pointed to by MPTR    to a printable string in STR in base BASE.  Copyright (C) 1991, 1992, 1993, 1994, 1996 Free Software Foundation, Inc.  This file is part of the GNU MP Library.  The GNU MP Library is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  The GNU MP Library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with the GNU MP Library; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_include
include|#
directive|include
file|"gmp.h"
end_include

begin_include
include|#
directive|include
file|"gmp-impl.h"
end_include

begin_include
include|#
directive|include
file|"longlong.h"
end_include

begin_comment
comment|/* Convert the limb vector pointed to by MPTR and MSIZE long to a    char array, using base BASE for the result array.  Store the    result in the character array STR.  STR must point to an array with    space for the largest possible number represented by a MSIZE long    limb vector + 1 extra character.     The result is NOT in Ascii, to convert it to printable format, add    '0' or 'A' depending on the base and range.     Return the number of digits in the result string.    This may include some leading zeros.     The limb vector pointed to by MPTR is clobbered.  */
end_comment

begin_function
name|size_t
name|mpn_get_str
parameter_list|(
name|str
parameter_list|,
name|base
parameter_list|,
name|mptr
parameter_list|,
name|msize
parameter_list|)
name|unsigned
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|base
decl_stmt|;
name|mp_ptr
name|mptr
decl_stmt|;
name|mp_size_t
name|msize
decl_stmt|;
block|{
name|mp_limb_t
name|big_base
decl_stmt|;
if|#
directive|if
name|UDIV_NEEDS_NORMALIZATION
operator|||
name|UDIV_TIME
operator|>
literal|2
operator|*
name|UMUL_TIME
name|int
name|normalization_steps
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|UDIV_TIME
operator|>
literal|2
operator|*
name|UMUL_TIME
name|mp_limb_t
name|big_base_inverted
decl_stmt|;
endif|#
directive|endif
name|unsigned
name|int
name|dig_per_u
decl_stmt|;
name|mp_size_t
name|out_len
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
name|big_base
operator|=
name|__mp_bases
index|[
name|base
index|]
operator|.
name|big_base
expr_stmt|;
name|s
operator|=
name|str
expr_stmt|;
comment|/* Special case zero, as the code below doesn't handle it.  */
if|if
condition|(
name|msize
operator|==
literal|0
condition|)
block|{
name|s
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|base
operator|&
operator|(
name|base
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* The base is a power of 2.  Make conversion from most 	 significant side.  */
name|mp_limb_t
name|n1
decl_stmt|,
name|n0
decl_stmt|;
specifier|register
name|int
name|bits_per_digit
init|=
name|big_base
decl_stmt|;
specifier|register
name|int
name|x
decl_stmt|;
specifier|register
name|int
name|bit_pos
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|n1
operator|=
name|mptr
index|[
name|msize
operator|-
literal|1
index|]
expr_stmt|;
name|count_leading_zeros
argument_list|(
name|x
argument_list|,
name|n1
argument_list|)
expr_stmt|;
comment|/* BIT_POS should be R when input ends in least sign. nibble, 	   R + bits_per_digit * n when input ends in n:th least significant 	   nibble. */
block|{
name|int
name|bits
decl_stmt|;
name|bits
operator|=
name|BITS_PER_MP_LIMB
operator|*
name|msize
operator|-
name|x
expr_stmt|;
name|x
operator|=
name|bits
operator|%
name|bits_per_digit
expr_stmt|;
if|if
condition|(
name|x
operator|!=
literal|0
condition|)
name|bits
operator|+=
name|bits_per_digit
operator|-
name|x
expr_stmt|;
name|bit_pos
operator|=
name|bits
operator|-
operator|(
name|msize
operator|-
literal|1
operator|)
operator|*
name|BITS_PER_MP_LIMB
expr_stmt|;
block|}
comment|/* Fast loop for bit output.  */
name|i
operator|=
name|msize
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bit_pos
operator|-=
name|bits_per_digit
expr_stmt|;
while|while
condition|(
name|bit_pos
operator|>=
literal|0
condition|)
block|{
operator|*
name|s
operator|++
operator|=
operator|(
name|n1
operator|>>
name|bit_pos
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|bits_per_digit
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|bit_pos
operator|-=
name|bits_per_digit
expr_stmt|;
block|}
name|i
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
break|break;
name|n0
operator|=
operator|(
name|n1
operator|<<
operator|-
name|bit_pos
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|bits_per_digit
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|n1
operator|=
name|mptr
index|[
name|i
index|]
expr_stmt|;
name|bit_pos
operator|+=
name|BITS_PER_MP_LIMB
expr_stmt|;
operator|*
name|s
operator|++
operator|=
name|n0
operator||
operator|(
name|n1
operator|>>
name|bit_pos
operator|)
expr_stmt|;
block|}
operator|*
name|s
operator|=
literal|0
expr_stmt|;
return|return
name|s
operator|-
name|str
return|;
block|}
else|else
block|{
comment|/* General case.  The base is not a power of 2.  Make conversion 	 from least significant end.  */
comment|/* If udiv_qrnnd only handles divisors with the most significant bit 	 set, prepare BIG_BASE for being a divisor by shifting it to the 	 left exactly enough to set the most significant bit.  */
if|#
directive|if
name|UDIV_NEEDS_NORMALIZATION
operator|||
name|UDIV_TIME
operator|>
literal|2
operator|*
name|UMUL_TIME
name|count_leading_zeros
argument_list|(
name|normalization_steps
argument_list|,
name|big_base
argument_list|)
expr_stmt|;
name|big_base
operator|<<=
name|normalization_steps
expr_stmt|;
if|#
directive|if
name|UDIV_TIME
operator|>
literal|2
operator|*
name|UMUL_TIME
comment|/* Get the fixed-point approximation to 1/(BIG_BASE<< NORMALIZATION_STEPS).  */
name|big_base_inverted
operator|=
name|__mp_bases
index|[
name|base
index|]
operator|.
name|big_base_inverted
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|dig_per_u
operator|=
name|__mp_bases
index|[
name|base
index|]
operator|.
name|chars_per_limb
expr_stmt|;
name|out_len
operator|=
operator|(
operator|(
name|size_t
operator|)
name|msize
operator|*
name|BITS_PER_MP_LIMB
operator|*
name|__mp_bases
index|[
name|base
index|]
operator|.
name|chars_per_bit_exactly
operator|)
operator|+
literal|1
expr_stmt|;
name|s
operator|+=
name|out_len
expr_stmt|;
while|while
condition|(
name|msize
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|mp_limb_t
name|n0
decl_stmt|,
name|n1
decl_stmt|;
if|#
directive|if
name|UDIV_NEEDS_NORMALIZATION
operator|||
name|UDIV_TIME
operator|>
literal|2
operator|*
name|UMUL_TIME
comment|/* If we shifted BIG_BASE above, shift the dividend too, to get 	     the right quotient.  We need to do this every loop, 	     since the intermediate quotients are OK, but the quotient from 	     one turn in the loop is going to be the dividend in the 	     next turn, and the dividend needs to be up-shifted.  */
if|if
condition|(
name|normalization_steps
operator|!=
literal|0
condition|)
block|{
name|n0
operator|=
name|mpn_lshift
argument_list|(
name|mptr
argument_list|,
name|mptr
argument_list|,
name|msize
argument_list|,
name|normalization_steps
argument_list|)
expr_stmt|;
comment|/* If the shifting gave a carry out limb, store it and 		 increase the length.  */
if|if
condition|(
name|n0
operator|!=
literal|0
condition|)
block|{
name|mptr
index|[
name|msize
index|]
operator|=
name|n0
expr_stmt|;
name|msize
operator|++
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* Divide the number at TP with BIG_BASE to get a quotient and a 	     remainder.  The remainder is our new digit in base BIG_BASE.  */
name|i
operator|=
name|msize
operator|-
literal|1
expr_stmt|;
name|n1
operator|=
name|mptr
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|n1
operator|>=
name|big_base
condition|)
name|n1
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|msize
operator|--
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|n0
operator|=
name|mptr
index|[
name|i
index|]
expr_stmt|;
if|#
directive|if
name|UDIV_TIME
operator|>
literal|2
operator|*
name|UMUL_TIME
name|udiv_qrnnd_preinv
argument_list|(
name|mptr
index|[
name|i
index|]
argument_list|,
name|n1
argument_list|,
name|n1
argument_list|,
name|n0
argument_list|,
name|big_base
argument_list|,
name|big_base_inverted
argument_list|)
expr_stmt|;
else|#
directive|else
name|udiv_qrnnd
argument_list|(
name|mptr
index|[
name|i
index|]
argument_list|,
name|n1
argument_list|,
name|n1
argument_list|,
name|n0
argument_list|,
name|big_base
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
name|UDIV_NEEDS_NORMALIZATION
operator|||
name|UDIV_TIME
operator|>
literal|2
operator|*
name|UMUL_TIME
comment|/* If we shifted above (at previous UDIV_NEEDS_NORMALIZATION tests) 	     the remainder will be up-shifted here.  Compensate.  */
name|n1
operator|>>=
name|normalization_steps
expr_stmt|;
endif|#
directive|endif
comment|/* Convert N1 from BIG_BASE to a string of digits in BASE 	     using single precision operations.  */
for|for
control|(
name|i
operator|=
name|dig_per_u
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
operator|*
operator|--
name|s
operator|=
name|n1
operator|%
name|base
expr_stmt|;
name|n1
operator|/=
name|base
expr_stmt|;
if|if
condition|(
name|n1
operator|==
literal|0
operator|&&
name|msize
operator|==
literal|0
condition|)
break|break;
block|}
block|}
while|while
condition|(
name|s
operator|!=
name|str
condition|)
operator|*
operator|--
name|s
operator|=
literal|0
expr_stmt|;
return|return
name|out_len
return|;
block|}
block|}
end_function

end_unit

