begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mpn_gcdext -- Extended Greatest Common Divisor.  Copyright (C) 1996 Free Software Foundation, Inc.  This file is part of the GNU MP Library.  The GNU MP Library is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  The GNU MP Library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with the GNU MP Library; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_include
include|#
directive|include
file|"gmp.h"
end_include

begin_include
include|#
directive|include
file|"gmp-impl.h"
end_include

begin_include
include|#
directive|include
file|"longlong.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|EXTEND
end_ifndef

begin_define
define|#
directive|define
name|EXTEND
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|STAT
end_if

begin_decl_stmt
name|int
name|arr
index|[
name|BITS_PER_MP_LIMB
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SGN
parameter_list|(
name|A
parameter_list|)
value|(((A)< 0) ? -1 : ((A)> 0))
end_define

begin_comment
comment|/* Idea 1: After we have performed a full division, don't shift operands back, 	   but instead account for the extra factors-of-2 thus introduced.    Idea 2: Simple generalization to use divide-and-conquer would give us an 	   algorithm that runs faster than O(n^2).    Idea 3: The input numbers need less space as the computation progresses, 	   while the s0 and s1 variables need more space.  To save space, we 	   could make them share space, and have the latter variables grow 	   into the former.  */
end_comment

begin_comment
comment|/* Precondition: U>= V.  */
end_comment

begin_function
name|mp_size_t
if|#
directive|if
name|EXTEND
if|#
directive|if
name|__STDC__
name|mpn_gcdext
parameter_list|(
name|mp_ptr
name|gp
parameter_list|,
name|mp_ptr
name|s0p
parameter_list|,
name|mp_ptr
name|up
parameter_list|,
name|mp_size_t
name|size
parameter_list|,
name|mp_ptr
name|vp
parameter_list|,
name|mp_size_t
name|vsize
parameter_list|)
else|#
directive|else
function|mpn_gcdext
parameter_list|(
name|gp
parameter_list|,
name|s0p
parameter_list|,
name|up
parameter_list|,
name|size
parameter_list|,
name|vp
parameter_list|,
name|vsize
parameter_list|)
name|mp_ptr
name|gp
decl_stmt|;
name|mp_ptr
name|s0p
decl_stmt|;
name|mp_ptr
name|up
decl_stmt|;
name|mp_size_t
name|size
decl_stmt|;
name|mp_ptr
name|vp
decl_stmt|;
name|mp_size_t
name|vsize
decl_stmt|;
endif|#
directive|endif
else|#
directive|else
if|#
directive|if
name|__STDC__
function|mpn_gcd
parameter_list|(
name|mp_ptr
name|gp
parameter_list|,
name|mp_ptr
name|up
parameter_list|,
name|mp_size_t
name|size
parameter_list|,
name|mp_ptr
name|vp
parameter_list|,
name|mp_size_t
name|vsize
parameter_list|)
else|#
directive|else
function|mpn_gcd
parameter_list|(
name|gp
parameter_list|,
name|up
parameter_list|,
name|size
parameter_list|,
name|vp
parameter_list|,
name|vsize
parameter_list|)
name|mp_ptr
name|gp
decl_stmt|;
name|mp_ptr
name|up
decl_stmt|;
name|mp_size_t
name|size
decl_stmt|;
name|mp_ptr
name|vp
decl_stmt|;
name|mp_size_t
name|vsize
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|{
name|mp_limb_t
name|uh
decl_stmt|,
name|vh
decl_stmt|;
name|mp_limb_signed_t
name|A
decl_stmt|,
name|B
decl_stmt|,
name|C
decl_stmt|,
name|D
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|mp_ptr
name|tp
decl_stmt|,
name|wp
decl_stmt|;
if|#
directive|if
name|RECORD
name|mp_limb_signed_t
name|min
init|=
literal|0
decl_stmt|,
name|max
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|EXTEND
name|mp_ptr
name|s1p
decl_stmt|;
name|mp_ptr
name|orig_s0p
init|=
name|s0p
decl_stmt|;
name|mp_size_t
name|ssize
decl_stmt|,
name|orig_size
init|=
name|size
decl_stmt|;
name|TMP_DECL
argument_list|(
name|mark
argument_list|)
expr_stmt|;
name|TMP_MARK
argument_list|(
name|mark
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|(
name|mp_ptr
operator|)
name|TMP_ALLOC
argument_list|(
operator|(
name|size
operator|+
literal|1
operator|)
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
name|wp
operator|=
operator|(
name|mp_ptr
operator|)
name|TMP_ALLOC
argument_list|(
operator|(
name|size
operator|+
literal|1
operator|)
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
name|s1p
operator|=
operator|(
name|mp_ptr
operator|)
name|TMP_ALLOC
argument_list|(
name|size
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
name|MPN_ZERO
argument_list|(
name|s0p
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|MPN_ZERO
argument_list|(
name|s1p
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|s0p
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|s1p
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|ssize
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|size
operator|>
name|vsize
condition|)
block|{
comment|/* Normalize V (and shift up U the same amount).  */
name|count_leading_zeros
argument_list|(
name|cnt
argument_list|,
name|vp
index|[
name|vsize
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|!=
literal|0
condition|)
block|{
name|mp_limb_t
name|cy
decl_stmt|;
name|mpn_lshift
argument_list|(
name|vp
argument_list|,
name|vp
argument_list|,
name|vsize
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|cy
operator|=
name|mpn_lshift
argument_list|(
name|up
argument_list|,
name|up
argument_list|,
name|size
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|up
index|[
name|size
index|]
operator|=
name|cy
expr_stmt|;
name|size
operator|+=
name|cy
operator|!=
literal|0
expr_stmt|;
block|}
name|mpn_divmod
argument_list|(
name|up
operator|+
name|vsize
argument_list|,
name|up
argument_list|,
name|size
argument_list|,
name|vp
argument_list|,
name|vsize
argument_list|)
expr_stmt|;
if|#
directive|if
name|EXTEND
comment|/* This is really what it boils down to in this case... */
name|s0p
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|s1p
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|size
operator|=
name|vsize
expr_stmt|;
if|if
condition|(
name|cnt
operator|!=
literal|0
condition|)
block|{
name|mpn_rshift
argument_list|(
name|up
argument_list|,
name|up
argument_list|,
name|size
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|mpn_rshift
argument_list|(
name|vp
argument_list|,
name|vp
argument_list|,
name|size
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
block|{
name|mp_ptr
name|xp
decl_stmt|;
name|xp
operator|=
name|up
expr_stmt|;
name|up
operator|=
name|vp
expr_stmt|;
name|vp
operator|=
name|xp
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Figure out exact size of V.  */
name|vsize
operator|=
name|size
expr_stmt|;
name|MPN_NORMALIZE
argument_list|(
name|vp
argument_list|,
name|vsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsize
operator|<=
literal|1
condition|)
break|break;
comment|/* Make UH be the most significant limb of U, and make VH be 	 corresponding bits from V.  */
name|uh
operator|=
name|up
index|[
name|size
operator|-
literal|1
index|]
expr_stmt|;
name|vh
operator|=
name|vp
index|[
name|size
operator|-
literal|1
index|]
expr_stmt|;
name|count_leading_zeros
argument_list|(
name|cnt
argument_list|,
name|uh
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|!=
literal|0
condition|)
block|{
name|uh
operator|=
operator|(
name|uh
operator|<<
name|cnt
operator|)
operator||
operator|(
name|up
index|[
name|size
operator|-
literal|2
index|]
operator|>>
operator|(
name|BITS_PER_MP_LIMB
operator|-
name|cnt
operator|)
operator|)
expr_stmt|;
name|vh
operator|=
operator|(
name|vh
operator|<<
name|cnt
operator|)
operator||
operator|(
name|vp
index|[
name|size
operator|-
literal|2
index|]
operator|>>
operator|(
name|BITS_PER_MP_LIMB
operator|-
name|cnt
operator|)
operator|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* For now, only handle BITS_PER_MP_LIMB-1 bits.  This makes 	 room for sign bit.  */
block|uh>>= 1;       vh>>= 1;
endif|#
directive|endif
name|A
operator|=
literal|1
expr_stmt|;
name|B
operator|=
literal|0
expr_stmt|;
name|C
operator|=
literal|0
expr_stmt|;
name|D
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|mp_limb_signed_t
name|q
decl_stmt|,
name|T
decl_stmt|;
if|if
condition|(
name|vh
operator|+
name|C
operator|==
literal|0
operator|||
name|vh
operator|+
name|D
operator|==
literal|0
condition|)
break|break;
name|q
operator|=
operator|(
name|uh
operator|+
name|A
operator|)
operator|/
operator|(
name|vh
operator|+
name|C
operator|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
operator|(
name|uh
operator|+
name|B
operator|)
operator|/
operator|(
name|vh
operator|+
name|D
operator|)
condition|)
break|break;
name|T
operator|=
name|A
operator|-
name|q
operator|*
name|C
expr_stmt|;
name|A
operator|=
name|C
expr_stmt|;
name|C
operator|=
name|T
expr_stmt|;
name|T
operator|=
name|B
operator|-
name|q
operator|*
name|D
expr_stmt|;
name|B
operator|=
name|D
expr_stmt|;
name|D
operator|=
name|T
expr_stmt|;
name|T
operator|=
name|uh
operator|-
name|q
operator|*
name|vh
expr_stmt|;
name|uh
operator|=
name|vh
expr_stmt|;
name|vh
operator|=
name|T
expr_stmt|;
block|}
if|#
directive|if
name|RECORD
name|min
operator|=
name|MIN
argument_list|(
name|A
argument_list|,
name|min
argument_list|)
expr_stmt|;
name|min
operator|=
name|MIN
argument_list|(
name|B
argument_list|,
name|min
argument_list|)
expr_stmt|;
name|min
operator|=
name|MIN
argument_list|(
name|C
argument_list|,
name|min
argument_list|)
expr_stmt|;
name|min
operator|=
name|MIN
argument_list|(
name|D
argument_list|,
name|min
argument_list|)
expr_stmt|;
name|max
operator|=
name|MAX
argument_list|(
name|A
argument_list|,
name|max
argument_list|)
expr_stmt|;
name|max
operator|=
name|MAX
argument_list|(
name|B
argument_list|,
name|max
argument_list|)
expr_stmt|;
name|max
operator|=
name|MAX
argument_list|(
name|C
argument_list|,
name|max
argument_list|)
expr_stmt|;
name|max
operator|=
name|MAX
argument_list|(
name|D
argument_list|,
name|max
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|B
operator|==
literal|0
condition|)
block|{
name|mp_limb_t
name|qh
decl_stmt|;
name|mp_size_t
name|i
decl_stmt|;
comment|/* This is quite rare.  I.e., optimize something else!  */
comment|/* Normalize V (and shift up U the same amount).  */
name|count_leading_zeros
argument_list|(
name|cnt
argument_list|,
name|vp
index|[
name|vsize
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|!=
literal|0
condition|)
block|{
name|mp_limb_t
name|cy
decl_stmt|;
name|mpn_lshift
argument_list|(
name|vp
argument_list|,
name|vp
argument_list|,
name|vsize
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|cy
operator|=
name|mpn_lshift
argument_list|(
name|up
argument_list|,
name|up
argument_list|,
name|size
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|up
index|[
name|size
index|]
operator|=
name|cy
expr_stmt|;
name|size
operator|+=
name|cy
operator|!=
literal|0
expr_stmt|;
block|}
name|qh
operator|=
name|mpn_divmod
argument_list|(
name|up
operator|+
name|vsize
argument_list|,
name|up
argument_list|,
name|size
argument_list|,
name|vp
argument_list|,
name|vsize
argument_list|)
expr_stmt|;
if|#
directive|if
name|EXTEND
name|MPN_COPY
argument_list|(
name|tp
argument_list|,
name|s0p
argument_list|,
name|ssize
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
operator|-
name|vsize
condition|;
name|i
operator|++
control|)
block|{
name|mp_limb_t
name|cy
decl_stmt|;
name|cy
operator|=
name|mpn_addmul_1
argument_list|(
name|tp
operator|+
name|i
argument_list|,
name|s1p
argument_list|,
name|ssize
argument_list|,
name|up
index|[
name|vsize
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cy
operator|!=
literal|0
condition|)
name|tp
index|[
name|ssize
operator|++
index|]
operator|=
name|cy
expr_stmt|;
block|}
if|if
condition|(
name|qh
operator|!=
literal|0
condition|)
block|{
name|mp_limb_t
name|cy
decl_stmt|;
name|abort
argument_list|()
expr_stmt|;
comment|/* XXX since qh == 1, mpn_addmul_1 is overkill */
name|cy
operator|=
name|mpn_addmul_1
argument_list|(
name|tp
operator|+
name|size
operator|-
name|vsize
argument_list|,
name|s1p
argument_list|,
name|ssize
argument_list|,
name|qh
argument_list|)
expr_stmt|;
if|if
condition|(
name|cy
operator|!=
literal|0
condition|)
name|tp
index|[
name|ssize
operator|++
index|]
operator|=
name|cy
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|MPN_COPY (s0p, s1p, ssize);
comment|/* should be old ssize, kind of */
block|MPN_COPY (s1p, tp, ssize);
else|#
directive|else
block|{
name|mp_ptr
name|xp
decl_stmt|;
name|xp
operator|=
name|s0p
expr_stmt|;
name|s0p
operator|=
name|s1p
expr_stmt|;
name|s1p
operator|=
name|xp
expr_stmt|;
name|xp
operator|=
name|s1p
expr_stmt|;
name|s1p
operator|=
name|tp
expr_stmt|;
name|tp
operator|=
name|xp
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
name|size
operator|=
name|vsize
expr_stmt|;
if|if
condition|(
name|cnt
operator|!=
literal|0
condition|)
block|{
name|mpn_rshift
argument_list|(
name|up
argument_list|,
name|up
argument_list|,
name|size
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|mpn_rshift
argument_list|(
name|vp
argument_list|,
name|vp
argument_list|,
name|size
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
block|{
name|mp_ptr
name|xp
decl_stmt|;
name|xp
operator|=
name|up
expr_stmt|;
name|up
operator|=
name|vp
expr_stmt|;
name|vp
operator|=
name|xp
expr_stmt|;
block|}
name|MPN_NORMALIZE
argument_list|(
name|up
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* T = U*A + V*B 	     W = U*C + V*D 	     U = T 	     V = W	   */
if|if
condition|(
name|SGN
argument_list|(
name|A
argument_list|)
operator|==
name|SGN
argument_list|(
name|B
argument_list|)
condition|)
comment|/* should be different sign */
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|SGN
argument_list|(
name|C
argument_list|)
operator|==
name|SGN
argument_list|(
name|D
argument_list|)
condition|)
comment|/* should be different sign */
name|abort
argument_list|()
expr_stmt|;
if|#
directive|if
name|STAT
block|{
name|mp_limb_t
name|x
decl_stmt|;
name|x
operator|=
name|ABS
argument_list|(
name|A
argument_list|)
operator||
name|ABS
argument_list|(
name|B
argument_list|)
operator||
name|ABS
argument_list|(
name|C
argument_list|)
operator||
name|ABS
argument_list|(
name|D
argument_list|)
expr_stmt|;
name|count_leading_zeros
argument_list|(
name|cnt
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|arr
index|[
name|BITS_PER_MP_LIMB
operator|-
name|cnt
index|]
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|A
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|B
operator|!=
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|MPN_COPY
argument_list|(
name|tp
argument_list|,
name|vp
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|A
operator|<
literal|0
condition|)
block|{
name|mpn_mul_1
argument_list|(
name|tp
argument_list|,
name|vp
argument_list|,
name|size
argument_list|,
name|B
argument_list|)
expr_stmt|;
name|mpn_submul_1
argument_list|(
name|tp
argument_list|,
name|up
argument_list|,
name|size
argument_list|,
operator|-
name|A
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mpn_mul_1
argument_list|(
name|tp
argument_list|,
name|up
argument_list|,
name|size
argument_list|,
name|A
argument_list|)
expr_stmt|;
name|mpn_submul_1
argument_list|(
name|tp
argument_list|,
name|vp
argument_list|,
name|size
argument_list|,
operator|-
name|B
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|C
operator|<
literal|0
condition|)
block|{
name|mpn_mul_1
argument_list|(
name|wp
argument_list|,
name|vp
argument_list|,
name|size
argument_list|,
name|D
argument_list|)
expr_stmt|;
name|mpn_submul_1
argument_list|(
name|wp
argument_list|,
name|up
argument_list|,
name|size
argument_list|,
operator|-
name|C
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mpn_mul_1
argument_list|(
name|wp
argument_list|,
name|up
argument_list|,
name|size
argument_list|,
name|C
argument_list|)
expr_stmt|;
name|mpn_submul_1
argument_list|(
name|wp
argument_list|,
name|vp
argument_list|,
name|size
argument_list|,
operator|-
name|D
argument_list|)
expr_stmt|;
block|}
block|{
name|mp_ptr
name|xp
decl_stmt|;
name|xp
operator|=
name|tp
expr_stmt|;
name|tp
operator|=
name|up
expr_stmt|;
name|up
operator|=
name|xp
expr_stmt|;
name|xp
operator|=
name|wp
expr_stmt|;
name|wp
operator|=
name|vp
expr_stmt|;
name|vp
operator|=
name|xp
expr_stmt|;
block|}
if|#
directive|if
name|EXTEND
block|{
name|mp_limb_t
name|cy
decl_stmt|;
name|MPN_ZERO
argument_list|(
name|tp
argument_list|,
name|orig_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|A
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|B
operator|!=
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|MPN_COPY
argument_list|(
name|tp
argument_list|,
name|s1p
argument_list|,
name|ssize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|A
operator|<
literal|0
condition|)
block|{
name|cy
operator|=
name|mpn_mul_1
argument_list|(
name|tp
argument_list|,
name|s1p
argument_list|,
name|ssize
argument_list|,
name|B
argument_list|)
expr_stmt|;
name|cy
operator|+=
name|mpn_addmul_1
argument_list|(
name|tp
argument_list|,
name|s0p
argument_list|,
name|ssize
argument_list|,
operator|-
name|A
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cy
operator|=
name|mpn_mul_1
argument_list|(
name|tp
argument_list|,
name|s0p
argument_list|,
name|ssize
argument_list|,
name|A
argument_list|)
expr_stmt|;
name|cy
operator|+=
name|mpn_addmul_1
argument_list|(
name|tp
argument_list|,
name|s1p
argument_list|,
name|ssize
argument_list|,
operator|-
name|B
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cy
operator|!=
literal|0
condition|)
name|tp
index|[
name|ssize
operator|++
index|]
operator|=
name|cy
expr_stmt|;
block|}
name|MPN_ZERO
argument_list|(
name|wp
argument_list|,
name|orig_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|C
operator|<
literal|0
condition|)
block|{
name|cy
operator|=
name|mpn_mul_1
argument_list|(
name|wp
argument_list|,
name|s1p
argument_list|,
name|ssize
argument_list|,
name|D
argument_list|)
expr_stmt|;
name|cy
operator|+=
name|mpn_addmul_1
argument_list|(
name|wp
argument_list|,
name|s0p
argument_list|,
name|ssize
argument_list|,
operator|-
name|C
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cy
operator|=
name|mpn_mul_1
argument_list|(
name|wp
argument_list|,
name|s0p
argument_list|,
name|ssize
argument_list|,
name|C
argument_list|)
expr_stmt|;
name|cy
operator|+=
name|mpn_addmul_1
argument_list|(
name|wp
argument_list|,
name|s1p
argument_list|,
name|ssize
argument_list|,
operator|-
name|D
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cy
operator|!=
literal|0
condition|)
name|wp
index|[
name|ssize
operator|++
index|]
operator|=
name|cy
expr_stmt|;
block|}
block|{
name|mp_ptr
name|xp
decl_stmt|;
name|xp
operator|=
name|tp
expr_stmt|;
name|tp
operator|=
name|s0p
expr_stmt|;
name|s0p
operator|=
name|xp
expr_stmt|;
name|xp
operator|=
name|wp
expr_stmt|;
name|wp
operator|=
name|s1p
expr_stmt|;
name|s1p
operator|=
name|xp
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* Is it a win to remove multiple zeros here? */
block|MPN_NORMALIZE (up, size);
else|#
directive|else
if|if
condition|(
name|up
index|[
name|size
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
name|size
operator|--
expr_stmt|;
endif|#
directive|endif
block|}
block|}
if|#
directive|if
name|RECORD
name|printf
argument_list|(
literal|"min: %ld\n"
argument_list|,
name|min
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"max: %ld\n"
argument_list|,
name|max
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|vsize
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|gp
operator|!=
name|up
condition|)
name|MPN_COPY
argument_list|(
name|gp
argument_list|,
name|up
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|#
directive|if
name|EXTEND
if|if
condition|(
name|orig_s0p
operator|!=
name|s0p
condition|)
name|MPN_COPY
argument_list|(
name|orig_s0p
argument_list|,
name|s0p
argument_list|,
name|ssize
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TMP_FREE
argument_list|(
name|mark
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
else|else
block|{
name|mp_limb_t
name|vl
decl_stmt|,
name|ul
decl_stmt|,
name|t
decl_stmt|;
if|#
directive|if
name|EXTEND
name|mp_limb_t
name|cy
decl_stmt|;
name|mp_size_t
name|i
decl_stmt|;
endif|#
directive|endif
name|vl
operator|=
name|vp
index|[
literal|0
index|]
expr_stmt|;
if|#
directive|if
name|EXTEND
name|t
operator|=
name|mpn_divmod_1
argument_list|(
name|wp
argument_list|,
name|up
argument_list|,
name|size
argument_list|,
name|vl
argument_list|)
expr_stmt|;
name|MPN_COPY
argument_list|(
name|tp
argument_list|,
name|s0p
argument_list|,
name|ssize
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|cy
operator|=
name|mpn_addmul_1
argument_list|(
name|tp
operator|+
name|i
argument_list|,
name|s1p
argument_list|,
name|ssize
argument_list|,
name|wp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cy
operator|!=
literal|0
condition|)
name|tp
index|[
name|ssize
operator|++
index|]
operator|=
name|cy
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|MPN_COPY (s0p, s1p, ssize);       MPN_COPY (s1p, tp, ssize);
else|#
directive|else
block|{
name|mp_ptr
name|xp
decl_stmt|;
name|xp
operator|=
name|s0p
expr_stmt|;
name|s0p
operator|=
name|s1p
expr_stmt|;
name|s1p
operator|=
name|xp
expr_stmt|;
name|xp
operator|=
name|s1p
expr_stmt|;
name|s1p
operator|=
name|tp
expr_stmt|;
name|tp
operator|=
name|xp
expr_stmt|;
block|}
endif|#
directive|endif
else|#
directive|else
name|t
operator|=
name|mpn_mod_1
argument_list|(
name|up
argument_list|,
name|size
argument_list|,
name|vl
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ul
operator|=
name|vl
expr_stmt|;
name|vl
operator|=
name|t
expr_stmt|;
while|while
condition|(
name|vl
operator|!=
literal|0
condition|)
block|{
name|mp_limb_t
name|t
decl_stmt|;
if|#
directive|if
name|EXTEND
name|mp_limb_t
name|q
decl_stmt|,
name|cy
decl_stmt|;
name|q
operator|=
name|ul
operator|/
name|vl
expr_stmt|;
name|t
operator|=
name|ul
operator|-
name|q
operator|*
name|vl
expr_stmt|;
name|MPN_COPY
argument_list|(
name|tp
argument_list|,
name|s0p
argument_list|,
name|ssize
argument_list|)
expr_stmt|;
name|cy
operator|=
name|mpn_addmul_1
argument_list|(
name|tp
argument_list|,
name|s1p
argument_list|,
name|ssize
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|cy
operator|!=
literal|0
condition|)
name|tp
index|[
name|ssize
operator|++
index|]
operator|=
name|cy
expr_stmt|;
if|#
directive|if
literal|0
block|MPN_COPY (s0p, s1p, ssize); 	  MPN_COPY (s1p, tp, ssize);
else|#
directive|else
block|{
name|mp_ptr
name|xp
decl_stmt|;
name|xp
operator|=
name|s0p
expr_stmt|;
name|s0p
operator|=
name|s1p
expr_stmt|;
name|s1p
operator|=
name|xp
expr_stmt|;
name|xp
operator|=
name|s1p
expr_stmt|;
name|s1p
operator|=
name|tp
expr_stmt|;
name|tp
operator|=
name|xp
expr_stmt|;
block|}
endif|#
directive|endif
else|#
directive|else
name|t
operator|=
name|ul
operator|%
name|vl
expr_stmt|;
endif|#
directive|endif
name|ul
operator|=
name|vl
expr_stmt|;
name|vl
operator|=
name|t
expr_stmt|;
block|}
name|gp
index|[
literal|0
index|]
operator|=
name|ul
expr_stmt|;
if|#
directive|if
name|EXTEND
if|if
condition|(
name|orig_s0p
operator|!=
name|s0p
condition|)
name|MPN_COPY
argument_list|(
name|orig_s0p
argument_list|,
name|s0p
argument_list|,
name|ssize
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TMP_FREE
argument_list|(
name|mark
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

end_unit

