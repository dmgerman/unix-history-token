begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mpn_random2 -- Generate random numbers with relatively long strings    of ones and zeroes.  Suitable for border testing.  Copyright (C) 1992, 1993, 1994, 1996 Free Software Foundation, Inc.  This file is part of the GNU MP Library.  The GNU MP Library is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  The GNU MP Library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with the GNU MP Library; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_include
include|#
directive|include
file|"gmp.h"
end_include

begin_include
include|#
directive|include
file|"gmp-impl.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__hpux
argument_list|)
operator|||
name|defined
argument_list|(
name|alpha__
argument_list|)
operator|||
name|defined
argument_list|(
name|__svr4__
argument_list|)
operator|||
name|defined
argument_list|(
name|__SVR4
argument_list|)
end_if

begin_comment
comment|/* HPUX lacks random().  DEC OSF/1 1.2 random() returns a double.  */
end_comment

begin_function_decl
name|long
name|mrand48
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
specifier|inline
name|long
name|random
parameter_list|()
block|{
return|return
name|mrand48
argument_list|()
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function_decl
name|long
name|random
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* It's a bit tricky to get this right, so please test the code well    if you hack with it.  Some early versions of the function produced    random numbers with the leading limb == 0, and some versions never    made the most significant bit set.  */
end_comment

begin_function
name|void
name|mpn_random2
parameter_list|(
name|res_ptr
parameter_list|,
name|size
parameter_list|)
name|mp_ptr
name|res_ptr
decl_stmt|;
name|mp_size_t
name|size
decl_stmt|;
block|{
name|int
name|n_bits
decl_stmt|;
name|int
name|bit_pos
decl_stmt|;
name|mp_size_t
name|limb_pos
decl_stmt|;
name|unsigned
name|int
name|ran
decl_stmt|;
name|mp_limb_t
name|limb
decl_stmt|;
name|limb
operator|=
literal|0
expr_stmt|;
comment|/* Start off in a random bit position in the most significant limb.  */
name|bit_pos
operator|=
name|random
argument_list|()
operator|&
operator|(
name|BITS_PER_MP_LIMB
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Least significant bit of RAN chooses string of ones/string of zeroes.      Make most significant limb be non-zero by setting bit 0 of RAN.  */
name|ran
operator|=
name|random
argument_list|()
operator||
literal|1
expr_stmt|;
for|for
control|(
name|limb_pos
operator|=
name|size
operator|-
literal|1
init|;
name|limb_pos
operator|>=
literal|0
condition|;
control|)
block|{
name|n_bits
operator|=
operator|(
name|ran
operator|>>
literal|1
operator|)
operator|%
name|BITS_PER_MP_LIMB
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|ran
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Generate a string of ones.  */
if|if
condition|(
name|n_bits
operator|>=
name|bit_pos
condition|)
block|{
name|res_ptr
index|[
name|limb_pos
operator|--
index|]
operator|=
name|limb
operator||
operator|(
operator|(
operator|(
operator|(
name|mp_limb_t
operator|)
literal|2
operator|)
operator|<<
name|bit_pos
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|bit_pos
operator|+=
name|BITS_PER_MP_LIMB
expr_stmt|;
name|limb
operator|=
operator|(
operator|~
operator|(
name|mp_limb_t
operator|)
literal|0
operator|)
operator|<<
operator|(
name|bit_pos
operator|-
name|n_bits
operator|)
expr_stmt|;
block|}
else|else
block|{
name|limb
operator||=
operator|(
operator|(
operator|(
operator|(
name|mp_limb_t
operator|)
literal|1
operator|)
operator|<<
name|n_bits
operator|)
operator|-
literal|1
operator|)
operator|<<
operator|(
name|bit_pos
operator|-
name|n_bits
operator|+
literal|1
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Generate a string of zeroes.  */
if|if
condition|(
name|n_bits
operator|>=
name|bit_pos
condition|)
block|{
name|res_ptr
index|[
name|limb_pos
operator|--
index|]
operator|=
name|limb
expr_stmt|;
name|limb
operator|=
literal|0
expr_stmt|;
name|bit_pos
operator|+=
name|BITS_PER_MP_LIMB
expr_stmt|;
block|}
block|}
name|bit_pos
operator|-=
name|n_bits
expr_stmt|;
name|ran
operator|=
name|random
argument_list|()
expr_stmt|;
block|}
block|}
end_function

end_unit

