begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mpn_divrem -- Divide natural numbers, producing both remainder and    quotient.  Copyright (C) 1993, 1994, 1995, 1996 Free Software Foundation, Inc.  This file is part of the GNU MP Library.  The GNU MP Library is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  The GNU MP Library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with the GNU MP Library; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_include
include|#
directive|include
file|"gmp.h"
end_include

begin_include
include|#
directive|include
file|"gmp-impl.h"
end_include

begin_include
include|#
directive|include
file|"longlong.h"
end_include

begin_comment
comment|/* Divide num (NP/NSIZE) by den (DP/DSIZE) and write    the NSIZE-DSIZE least significant quotient limbs at QP    and the DSIZE long remainder at NP.  If QEXTRA_LIMBS is    non-zero, generate that many fraction bits and append them after the    other quotient limbs.    Return the most significant limb of the quotient, this is always 0 or 1.     Preconditions:    0. NSIZE>= DSIZE.    1. The most significant bit of the divisor must be set.    2. QP must either not overlap with the input operands at all, or       QP + DSIZE>= NP must hold true.  (This means that it's       possible to put the quotient in the high part of NUM, right after the       remainder in NUM.    3. NSIZE>= DSIZE, even if QEXTRA_LIMBS is non-zero.  */
end_comment

begin_function
name|mp_limb_t
if|#
directive|if
name|__STDC__
name|mpn_divrem
parameter_list|(
name|mp_ptr
name|qp
parameter_list|,
name|mp_size_t
name|qextra_limbs
parameter_list|,
name|mp_ptr
name|np
parameter_list|,
name|mp_size_t
name|nsize
parameter_list|,
name|mp_srcptr
name|dp
parameter_list|,
name|mp_size_t
name|dsize
parameter_list|)
else|#
directive|else
function|mpn_divrem
parameter_list|(
name|qp
parameter_list|,
name|qextra_limbs
parameter_list|,
name|np
parameter_list|,
name|nsize
parameter_list|,
name|dp
parameter_list|,
name|dsize
parameter_list|)
name|mp_ptr
name|qp
decl_stmt|;
name|mp_size_t
name|qextra_limbs
decl_stmt|;
name|mp_ptr
name|np
decl_stmt|;
name|mp_size_t
name|nsize
decl_stmt|;
name|mp_srcptr
name|dp
decl_stmt|;
name|mp_size_t
name|dsize
decl_stmt|;
endif|#
directive|endif
block|{
name|mp_limb_t
name|most_significant_q_limb
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|dsize
condition|)
block|{
case|case
literal|0
case|:
comment|/* We are asked to divide by zero, so go ahead and do it!  (To make 	 the compiler not remove this statement, return the value.)  */
return|return
literal|1
operator|/
name|dsize
return|;
case|case
literal|1
case|:
block|{
name|mp_size_t
name|i
decl_stmt|;
name|mp_limb_t
name|n1
decl_stmt|;
name|mp_limb_t
name|d
decl_stmt|;
name|d
operator|=
name|dp
index|[
literal|0
index|]
expr_stmt|;
name|n1
operator|=
name|np
index|[
name|nsize
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|n1
operator|>=
name|d
condition|)
block|{
name|n1
operator|-=
name|d
expr_stmt|;
name|most_significant_q_limb
operator|=
literal|1
expr_stmt|;
block|}
name|qp
operator|+=
name|qextra_limbs
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nsize
operator|-
literal|2
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|udiv_qrnnd
argument_list|(
name|qp
index|[
name|i
index|]
argument_list|,
name|n1
argument_list|,
name|n1
argument_list|,
name|np
index|[
name|i
index|]
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|qp
operator|-=
name|qextra_limbs
expr_stmt|;
for|for
control|(
name|i
operator|=
name|qextra_limbs
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|udiv_qrnnd
argument_list|(
name|qp
index|[
name|i
index|]
argument_list|,
name|n1
argument_list|,
name|n1
argument_list|,
literal|0
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|np
index|[
literal|0
index|]
operator|=
name|n1
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
block|{
name|mp_size_t
name|i
decl_stmt|;
name|mp_limb_t
name|n1
decl_stmt|,
name|n0
decl_stmt|,
name|n2
decl_stmt|;
name|mp_limb_t
name|d1
decl_stmt|,
name|d0
decl_stmt|;
name|np
operator|+=
name|nsize
operator|-
literal|2
expr_stmt|;
name|d1
operator|=
name|dp
index|[
literal|1
index|]
expr_stmt|;
name|d0
operator|=
name|dp
index|[
literal|0
index|]
expr_stmt|;
name|n1
operator|=
name|np
index|[
literal|1
index|]
expr_stmt|;
name|n0
operator|=
name|np
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n1
operator|>=
name|d1
operator|&&
operator|(
name|n1
operator|>
name|d1
operator|||
name|n0
operator|>=
name|d0
operator|)
condition|)
block|{
name|sub_ddmmss
argument_list|(
name|n1
argument_list|,
name|n0
argument_list|,
name|n1
argument_list|,
name|n0
argument_list|,
name|d1
argument_list|,
name|d0
argument_list|)
expr_stmt|;
name|most_significant_q_limb
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|qextra_limbs
operator|+
name|nsize
operator|-
literal|2
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|mp_limb_t
name|q
decl_stmt|;
name|mp_limb_t
name|r
decl_stmt|;
if|if
condition|(
name|i
operator|>=
name|qextra_limbs
condition|)
name|np
operator|--
expr_stmt|;
else|else
name|np
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|n1
operator|==
name|d1
condition|)
block|{
comment|/* Q should be either 111..111 or 111..110.  Need special 		   treatment of this rare case as normal division would 		   give overflow.  */
name|q
operator|=
operator|~
operator|(
name|mp_limb_t
operator|)
literal|0
expr_stmt|;
name|r
operator|=
name|n0
operator|+
name|d1
expr_stmt|;
if|if
condition|(
name|r
operator|<
name|d1
condition|)
comment|/* Carry in the addition? */
block|{
name|add_ssaaaa
argument_list|(
name|n1
argument_list|,
name|n0
argument_list|,
name|r
operator|-
name|d0
argument_list|,
name|np
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
name|d0
argument_list|)
expr_stmt|;
name|qp
index|[
name|i
index|]
operator|=
name|q
expr_stmt|;
continue|continue;
block|}
name|n1
operator|=
name|d0
operator|-
operator|(
name|d0
operator|!=
literal|0
operator|)
expr_stmt|;
name|n0
operator|=
operator|-
name|d0
expr_stmt|;
block|}
else|else
block|{
name|udiv_qrnnd
argument_list|(
name|q
argument_list|,
name|r
argument_list|,
name|n1
argument_list|,
name|n0
argument_list|,
name|d1
argument_list|)
expr_stmt|;
name|umul_ppmm
argument_list|(
name|n1
argument_list|,
name|n0
argument_list|,
name|d0
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
name|n2
operator|=
name|np
index|[
literal|0
index|]
expr_stmt|;
name|q_test
label|:
if|if
condition|(
name|n1
operator|>
name|r
operator|||
operator|(
name|n1
operator|==
name|r
operator|&&
name|n0
operator|>
name|n2
operator|)
condition|)
block|{
comment|/* The estimated Q was too large.  */
name|q
operator|--
expr_stmt|;
name|sub_ddmmss
argument_list|(
name|n1
argument_list|,
name|n0
argument_list|,
name|n1
argument_list|,
name|n0
argument_list|,
literal|0
argument_list|,
name|d0
argument_list|)
expr_stmt|;
name|r
operator|+=
name|d1
expr_stmt|;
if|if
condition|(
name|r
operator|>=
name|d1
condition|)
comment|/* If not carry, test Q again.  */
goto|goto
name|q_test
goto|;
block|}
name|qp
index|[
name|i
index|]
operator|=
name|q
expr_stmt|;
name|sub_ddmmss
argument_list|(
name|n1
argument_list|,
name|n0
argument_list|,
name|r
argument_list|,
name|n2
argument_list|,
name|n1
argument_list|,
name|n0
argument_list|)
expr_stmt|;
block|}
name|np
index|[
literal|1
index|]
operator|=
name|n1
expr_stmt|;
name|np
index|[
literal|0
index|]
operator|=
name|n0
expr_stmt|;
block|}
break|break;
default|default:
block|{
name|mp_size_t
name|i
decl_stmt|;
name|mp_limb_t
name|dX
decl_stmt|,
name|d1
decl_stmt|,
name|n0
decl_stmt|;
name|np
operator|+=
name|nsize
operator|-
name|dsize
expr_stmt|;
name|dX
operator|=
name|dp
index|[
name|dsize
operator|-
literal|1
index|]
expr_stmt|;
name|d1
operator|=
name|dp
index|[
name|dsize
operator|-
literal|2
index|]
expr_stmt|;
name|n0
operator|=
name|np
index|[
name|dsize
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|n0
operator|>=
name|dX
condition|)
block|{
if|if
condition|(
name|n0
operator|>
name|dX
operator|||
name|mpn_cmp
argument_list|(
name|np
argument_list|,
name|dp
argument_list|,
name|dsize
operator|-
literal|1
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|mpn_sub_n
argument_list|(
name|np
argument_list|,
name|np
argument_list|,
name|dp
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
name|n0
operator|=
name|np
index|[
name|dsize
operator|-
literal|1
index|]
expr_stmt|;
name|most_significant_q_limb
operator|=
literal|1
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
name|qextra_limbs
operator|+
name|nsize
operator|-
name|dsize
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|mp_limb_t
name|q
decl_stmt|;
name|mp_limb_t
name|n1
decl_stmt|,
name|n2
decl_stmt|;
name|mp_limb_t
name|cy_limb
decl_stmt|;
if|if
condition|(
name|i
operator|>=
name|qextra_limbs
condition|)
block|{
name|np
operator|--
expr_stmt|;
name|n2
operator|=
name|np
index|[
name|dsize
index|]
expr_stmt|;
block|}
else|else
block|{
name|n2
operator|=
name|np
index|[
name|dsize
operator|-
literal|1
index|]
expr_stmt|;
name|MPN_COPY_DECR
argument_list|(
name|np
operator|+
literal|1
argument_list|,
name|np
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
name|np
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|n0
operator|==
name|dX
condition|)
comment|/* This might over-estimate q, but it's probably not worth 		 the extra code here to find out.  */
name|q
operator|=
operator|~
operator|(
name|mp_limb_t
operator|)
literal|0
expr_stmt|;
else|else
block|{
name|mp_limb_t
name|r
decl_stmt|;
name|udiv_qrnnd
argument_list|(
name|q
argument_list|,
name|r
argument_list|,
name|n0
argument_list|,
name|np
index|[
name|dsize
operator|-
literal|1
index|]
argument_list|,
name|dX
argument_list|)
expr_stmt|;
name|umul_ppmm
argument_list|(
name|n1
argument_list|,
name|n0
argument_list|,
name|d1
argument_list|,
name|q
argument_list|)
expr_stmt|;
while|while
condition|(
name|n1
operator|>
name|r
operator|||
operator|(
name|n1
operator|==
name|r
operator|&&
name|n0
operator|>
name|np
index|[
name|dsize
operator|-
literal|2
index|]
operator|)
condition|)
block|{
name|q
operator|--
expr_stmt|;
name|r
operator|+=
name|dX
expr_stmt|;
if|if
condition|(
name|r
operator|<
name|dX
condition|)
comment|/* I.e. "carry in previous addition?"  */
break|break;
name|n1
operator|-=
name|n0
operator|<
name|d1
expr_stmt|;
name|n0
operator|-=
name|d1
expr_stmt|;
block|}
block|}
comment|/* Possible optimization: We already have (q * n0) and (1 * n1) 	       after the calculation of q.  Taking advantage of that, we 	       could make this loop make two iterations less.  */
name|cy_limb
operator|=
name|mpn_submul_1
argument_list|(
name|np
argument_list|,
name|dp
argument_list|,
name|dsize
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|n2
operator|!=
name|cy_limb
condition|)
block|{
name|mpn_add_n
argument_list|(
name|np
argument_list|,
name|np
argument_list|,
name|dp
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
name|q
operator|--
expr_stmt|;
block|}
name|qp
index|[
name|i
index|]
operator|=
name|q
expr_stmt|;
name|n0
operator|=
name|np
index|[
name|dsize
operator|-
literal|1
index|]
expr_stmt|;
block|}
block|}
block|}
return|return
name|most_significant_q_limb
return|;
block|}
end_function

end_unit

