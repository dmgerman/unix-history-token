begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"gmp.h"
end_include

begin_include
include|#
directive|include
file|"gmp-impl.h"
end_include

begin_include
include|#
directive|include
file|"longlong.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|USG
end_ifndef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_function
name|unsigned
name|long
name|cputime
parameter_list|()
block|{
name|struct
name|rusage
name|rus
decl_stmt|;
name|getrusage
argument_list|(
literal|0
argument_list|,
operator|&
name|rus
argument_list|)
expr_stmt|;
return|return
name|rus
operator|.
name|ru_utime
operator|.
name|tv_sec
operator|*
literal|1000
operator|+
name|rus
operator|.
name|ru_utime
operator|.
name|tv_usec
operator|/
literal|1000
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|CLOCKS_PER_SEC
end_ifndef

begin_define
define|#
directive|define
name|CLOCKS_PER_SEC
value|1000000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CLOCKS_PER_SEC
operator|>=
literal|10000
end_if

begin_define
define|#
directive|define
name|CLOCK_TO_MILLISEC
parameter_list|(
name|cl
parameter_list|)
value|((cl) / (CLOCKS_PER_SEC / 1000))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CLOCK_TO_MILLISEC
parameter_list|(
name|cl
parameter_list|)
value|((cl) * 1000 / CLOCKS_PER_SEC)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|unsigned
name|long
name|cputime
parameter_list|()
block|{
return|return
name|CLOCK_TO_MILLISEC
argument_list|(
name|clock
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|M
value|* 1000000
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|CLOCK
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__m88k__
argument_list|)
end_if

begin_define
define|#
directive|define
name|CLOCK
value|20 M
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__i386__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|CLOCK
value|(16.666667 M)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__m68k__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|CLOCK
value|(20 M)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|_IBMR2
argument_list|)
end_elif

begin_define
define|#
directive|define
name|CLOCK
value|(25 M)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__sparc__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|CLOCK
value|(20 M)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__sun__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|CLOCK
value|(20 M)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__mips
argument_list|)
end_elif

begin_define
define|#
directive|define
name|CLOCK
value|(40 M)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__hppa__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|CLOCK
value|(50 M)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__alpha
argument_list|)
end_elif

begin_define
define|#
directive|define
name|CLOCK
value|(133 M)
end_define

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
literal|"Don't know CLOCK of your machine"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|OPS
end_ifndef

begin_define
define|#
directive|define
name|OPS
value|10000000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SIZE
end_ifndef

begin_define
define|#
directive|define
name|SIZE
value|496
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TIMES
end_ifndef

begin_define
define|#
directive|define
name|TIMES
value|OPS/SIZE
end_define

begin_else
else|#
directive|else
end_else

begin_undef
undef|#
directive|undef
name|OPS
end_undef

begin_define
define|#
directive|define
name|OPS
value|(SIZE*TIMES)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|mp_limb_t
name|refmpn_lshift
parameter_list|(
name|wp
parameter_list|,
name|up
parameter_list|,
name|usize
parameter_list|,
name|cnt
parameter_list|)
specifier|register
name|mp_ptr
name|wp
decl_stmt|;
specifier|register
name|mp_srcptr
name|up
decl_stmt|;
name|mp_size_t
name|usize
decl_stmt|;
specifier|register
name|unsigned
name|int
name|cnt
decl_stmt|;
block|{
specifier|register
name|mp_limb_t
name|high_limb
decl_stmt|,
name|low_limb
decl_stmt|;
specifier|register
name|unsigned
name|sh_1
decl_stmt|,
name|sh_2
decl_stmt|;
specifier|register
name|mp_size_t
name|i
decl_stmt|;
name|mp_limb_t
name|retval
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|usize
operator|==
literal|0
operator|||
name|cnt
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|sh_1
operator|=
name|cnt
expr_stmt|;
if|#
directive|if
literal|0
block|if (sh_1 == 0)     {       if (wp != up) 	{
comment|/* Copy from high end to low end, to allow specified input/output 	     overlapping.  */
block|for (i = usize - 1; i>= 0; i--) 	    wp[i] = up[i]; 	}       return 0;     }
endif|#
directive|endif
name|wp
operator|+=
literal|1
expr_stmt|;
name|sh_2
operator|=
name|BITS_PER_MP_LIMB
operator|-
name|sh_1
expr_stmt|;
name|i
operator|=
name|usize
operator|-
literal|1
expr_stmt|;
name|low_limb
operator|=
name|up
index|[
name|i
index|]
expr_stmt|;
name|retval
operator|=
name|low_limb
operator|>>
name|sh_2
expr_stmt|;
name|high_limb
operator|=
name|low_limb
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
block|{
name|low_limb
operator|=
name|up
index|[
name|i
index|]
expr_stmt|;
name|wp
index|[
name|i
index|]
operator|=
operator|(
name|high_limb
operator|<<
name|sh_1
operator|)
operator||
operator|(
name|low_limb
operator|>>
name|sh_2
operator|)
expr_stmt|;
name|high_limb
operator|=
name|low_limb
expr_stmt|;
block|}
name|wp
index|[
name|i
index|]
operator|=
name|high_limb
operator|<<
name|sh_1
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|CNT
end_ifndef

begin_define
define|#
directive|define
name|CNT
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|mp_limb_t
name|s1
index|[
name|SIZE
index|]
decl_stmt|;
name|mp_limb_t
name|dx
index|[
name|SIZE
operator|+
literal|2
index|]
decl_stmt|;
name|mp_limb_t
name|dy
index|[
name|SIZE
operator|+
literal|2
index|]
decl_stmt|;
name|mp_limb_t
name|cyx
decl_stmt|,
name|cyy
decl_stmt|;
name|int
name|i
decl_stmt|;
name|long
name|t0
decl_stmt|,
name|t
decl_stmt|;
name|int
name|test
decl_stmt|;
name|int
name|cnt
init|=
name|CNT
decl_stmt|;
name|mp_size_t
name|size
decl_stmt|;
for|for
control|(
name|test
operator|=
literal|0
init|;
condition|;
name|test
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|RANDOM
name|size
operator|=
operator|(
name|random
argument_list|()
operator|%
name|SIZE
operator|+
literal|1
operator|)
expr_stmt|;
else|#
directive|else
name|size
operator|=
name|SIZE
expr_stmt|;
endif|#
directive|endif
name|mpn_random2
argument_list|(
name|s1
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|dx
index|[
name|size
operator|+
literal|1
index|]
operator|=
literal|0x12345678
expr_stmt|;
name|dy
index|[
name|size
operator|+
literal|1
index|]
operator|=
literal|0x12345678
expr_stmt|;
name|dx
index|[
literal|0
index|]
operator|=
literal|0x87654321
expr_stmt|;
name|dy
index|[
literal|0
index|]
operator|=
literal|0x87654321
expr_stmt|;
ifdef|#
directive|ifdef
name|PRINT
name|mpn_print
argument_list|(
name|s1
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|t0
operator|=
name|cputime
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TIMES
condition|;
name|i
operator|++
control|)
name|cyx
operator|=
name|refmpn_lshift
argument_list|(
name|dx
operator|+
literal|1
argument_list|,
name|s1
argument_list|,
name|size
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|t
operator|=
name|cputime
argument_list|()
operator|-
name|t0
expr_stmt|;
if|#
directive|if
name|TIMES
operator|!=
literal|1
name|printf
argument_list|(
literal|"refmpn_lshift: %5ldms (%.2f cycles/limb)\n"
argument_list|,
name|t
argument_list|,
operator|(
operator|(
name|double
operator|)
name|t
operator|*
name|CLOCK
operator|)
operator|/
operator|(
name|OPS
operator|*
literal|1000.0
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PRINT
name|printf
argument_list|(
literal|"%*lX "
argument_list|,
call|(
name|int
call|)
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|mp_limb_t
argument_list|)
argument_list|)
argument_list|,
name|cyx
argument_list|)
expr_stmt|;
name|mpn_print
argument_list|(
name|dx
operator|+
literal|1
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|t0
operator|=
name|cputime
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TIMES
condition|;
name|i
operator|++
control|)
name|cyy
operator|=
name|mpn_lshift
argument_list|(
name|dx
operator|+
literal|1
argument_list|,
name|s1
argument_list|,
name|size
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|t
operator|=
name|cputime
argument_list|()
operator|-
name|t0
expr_stmt|;
if|#
directive|if
name|TIMES
operator|!=
literal|1
name|printf
argument_list|(
literal|"mpn_lshift:  %5ldms (%.2f cycles/limb)\n"
argument_list|,
name|t
argument_list|,
operator|(
operator|(
name|double
operator|)
name|t
operator|*
name|CLOCK
operator|)
operator|/
operator|(
name|OPS
operator|*
literal|1000.0
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PRINT
name|printf
argument_list|(
literal|"%*lX "
argument_list|,
call|(
name|int
call|)
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|mp_limb_t
argument_list|)
argument_list|)
argument_list|,
name|cyy
argument_list|)
expr_stmt|;
name|mpn_print
argument_list|(
name|dx
operator|+
literal|1
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NOCHECK
comment|/* Put garbage in the destination.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|size
condition|;
name|i
operator|++
control|)
block|{
name|dx
index|[
name|i
index|]
operator|=
literal|0x7654321
expr_stmt|;
name|dy
index|[
name|i
index|]
operator|=
literal|0x1234567
expr_stmt|;
block|}
name|cyx
operator|=
name|refmpn_lshift
argument_list|(
name|dx
operator|+
literal|1
argument_list|,
name|s1
argument_list|,
name|size
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|cyy
operator|=
name|mpn_lshift
argument_list|(
name|dy
operator|+
literal|1
argument_list|,
name|s1
argument_list|,
name|size
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|cyx
operator|!=
name|cyy
operator|||
name|mpn_cmp
argument_list|(
name|dx
argument_list|,
name|dy
argument_list|,
name|size
operator|+
literal|2
argument_list|)
operator|!=
literal|0
operator|||
name|dx
index|[
name|size
operator|+
literal|1
index|]
operator|!=
literal|0x12345678
operator|||
name|dx
index|[
literal|0
index|]
operator|!=
literal|0x87654321
condition|)
block|{
ifndef|#
directive|ifndef
name|PRINT
name|printf
argument_list|(
literal|"%*lX "
argument_list|,
call|(
name|int
call|)
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|mp_limb_t
argument_list|)
argument_list|)
argument_list|,
name|cyx
argument_list|)
expr_stmt|;
name|mpn_print
argument_list|(
name|dx
operator|+
literal|1
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*lX "
argument_list|,
call|(
name|int
call|)
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|mp_limb_t
argument_list|)
argument_list|)
argument_list|,
name|cyy
argument_list|)
expr_stmt|;
name|mpn_print
argument_list|(
name|dy
operator|+
literal|1
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
end_function

begin_macro
name|mpn_print
argument_list|(
argument|mp_ptr p
argument_list|,
argument|mp_size_t size
argument_list|)
end_macro

begin_block
block|{
name|mp_size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|size
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|printf
argument_list|(
literal|"%0*lX"
argument_list|,
call|(
name|int
call|)
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|mp_limb_t
argument_list|)
argument_list|)
argument_list|,
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SPACE
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|puts
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

