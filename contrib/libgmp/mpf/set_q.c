begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mpf_set_q (mpf_t rop, mpq_t op) -- Convert the rational op to the float rop.  Copyright (C) 1996 Free Software Foundation, Inc.  This file is part of the GNU MP Library.  The GNU MP Library is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  The GNU MP Library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with the GNU MP Library; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_include
include|#
directive|include
file|"gmp.h"
end_include

begin_include
include|#
directive|include
file|"gmp-impl.h"
end_include

begin_include
include|#
directive|include
file|"longlong.h"
end_include

begin_comment
comment|/* Algorithm:    1. Develop>= n bits of src.num / src.den, where n is the number of bits       in a double.  This (partial) division will use all bits from the       denominator.    2. Use the remainder to determine how to round the result.    3. Assign the integral result to a temporary double.    4. Scale the temporary double, and return the result.     An alternative algorithm, that would be faster:    0. Let n be somewhat larger than the number of significant bits in a double.    1. Extract the most significant n bits of the denominator, and an equal       number of bits from the numerator.    2. Interpret the extracted numbers as integers, call them a and b       respectively, and develop n bits of the fractions ((a + 1) / b) and       (a / (b + 1)) using mpn_divrem.    3. If the computed values are identical UP TO THE POSITION WE CARE ABOUT,       we are done.  If they are different, repeat the algorithm from step 1,       but first let n = n * 2.    4. If we end up using all bits from the numerator and denominator, fall       back to the first algorithm above.    5. Just to make life harder, The computation of a + 1 and b + 1 above       might give carry-out...  Needs special handling.  It might work to       subtract 1 in both cases instead. */
end_comment

begin_function
name|void
if|#
directive|if
name|__STDC__
name|mpf_set_q
parameter_list|(
name|mpf_t
name|r
parameter_list|,
name|mpq_srcptr
name|q
parameter_list|)
else|#
directive|else
function|mpf_set_q
parameter_list|(
name|r
parameter_list|,
name|q
parameter_list|)
name|mpf_t
name|r
decl_stmt|;
name|mpq_srcptr
name|q
decl_stmt|;
endif|#
directive|endif
block|{
name|mp_ptr
name|np
decl_stmt|,
name|dp
decl_stmt|;
name|mp_ptr
name|rp
decl_stmt|;
name|mp_size_t
name|nsize
decl_stmt|,
name|dsize
decl_stmt|;
name|mp_size_t
name|qsize
decl_stmt|,
name|rsize
decl_stmt|;
name|mp_size_t
name|sign_quotient
decl_stmt|;
name|unsigned
name|normalization_steps
decl_stmt|;
name|mp_limb_t
name|qlimb
decl_stmt|;
name|mp_ptr
name|qp
decl_stmt|;
name|mp_size_t
name|prec
decl_stmt|;
name|mp_exp_t
name|exp
decl_stmt|;
name|TMP_DECL
argument_list|(
name|marker
argument_list|)
expr_stmt|;
name|nsize
operator|=
name|SIZ
argument_list|(
operator|&
name|q
operator|->
name|_mp_num
argument_list|)
expr_stmt|;
name|dsize
operator|=
name|SIZ
argument_list|(
operator|&
name|q
operator|->
name|_mp_den
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsize
operator|==
literal|0
condition|)
block|{
name|SIZ
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|EXP
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|prec
operator|=
name|PREC
argument_list|(
name|r
argument_list|)
operator|+
literal|1
expr_stmt|;
name|TMP_MARK
argument_list|(
name|marker
argument_list|)
expr_stmt|;
name|qp
operator|=
name|PTR
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|sign_quotient
operator|=
name|nsize
operator|^
name|dsize
expr_stmt|;
name|nsize
operator|=
name|ABS
argument_list|(
name|nsize
argument_list|)
expr_stmt|;
name|dsize
operator|=
name|ABS
argument_list|(
name|dsize
argument_list|)
expr_stmt|;
name|np
operator|=
name|PTR
argument_list|(
operator|&
name|q
operator|->
name|_mp_num
argument_list|)
expr_stmt|;
name|dp
operator|=
name|PTR
argument_list|(
operator|&
name|q
operator|->
name|_mp_den
argument_list|)
expr_stmt|;
name|exp
operator|=
name|nsize
operator|-
name|dsize
expr_stmt|;
if|if
condition|(
name|nsize
operator|>
name|prec
condition|)
block|{
name|np
operator|+=
name|nsize
operator|-
name|prec
expr_stmt|;
name|nsize
operator|=
name|prec
expr_stmt|;
block|}
if|if
condition|(
name|dsize
operator|>
name|prec
condition|)
block|{
name|dp
operator|+=
name|dsize
operator|-
name|prec
expr_stmt|;
name|dsize
operator|=
name|prec
expr_stmt|;
block|}
name|rsize
operator|=
name|MAX
argument_list|(
name|nsize
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
name|rp
operator|=
operator|(
name|mp_ptr
operator|)
name|TMP_ALLOC
argument_list|(
operator|(
name|rsize
operator|+
literal|1
operator|)
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
name|count_leading_zeros
argument_list|(
name|normalization_steps
argument_list|,
name|dp
index|[
name|dsize
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Normalize the denominator, i.e. make its most significant bit set by      shifting it NORMALIZATION_STEPS bits to the left.  Also shift the      numerator the same number of steps (to keep the quotient the same!).  */
if|if
condition|(
name|normalization_steps
operator|!=
literal|0
condition|)
block|{
name|mp_ptr
name|tp
decl_stmt|;
name|mp_limb_t
name|nlimb
decl_stmt|;
comment|/* Shift up the denominator setting the most significant bit of 	 the most significant limb.  Use temporary storage not to clobber 	 the original contents of the denominator.  */
name|tp
operator|=
operator|(
name|mp_ptr
operator|)
name|TMP_ALLOC
argument_list|(
name|dsize
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
name|mpn_lshift
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|dsize
argument_list|,
name|normalization_steps
argument_list|)
expr_stmt|;
name|dp
operator|=
name|tp
expr_stmt|;
if|if
condition|(
name|rsize
operator|!=
name|nsize
condition|)
block|{
name|MPN_ZERO
argument_list|(
name|rp
argument_list|,
name|rsize
operator|-
name|nsize
argument_list|)
expr_stmt|;
name|nlimb
operator|=
name|mpn_lshift
argument_list|(
name|rp
operator|+
operator|(
name|rsize
operator|-
name|nsize
operator|)
argument_list|,
name|np
argument_list|,
name|nsize
argument_list|,
name|normalization_steps
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nlimb
operator|=
name|mpn_lshift
argument_list|(
name|rp
argument_list|,
name|np
argument_list|,
name|nsize
argument_list|,
name|normalization_steps
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nlimb
operator|!=
literal|0
condition|)
block|{
name|rp
index|[
name|rsize
index|]
operator|=
name|nlimb
expr_stmt|;
name|rsize
operator|++
expr_stmt|;
name|exp
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|rsize
operator|!=
name|nsize
condition|)
block|{
name|MPN_ZERO
argument_list|(
name|rp
argument_list|,
name|rsize
operator|-
name|nsize
argument_list|)
expr_stmt|;
name|MPN_COPY
argument_list|(
name|rp
operator|+
operator|(
name|rsize
operator|-
name|nsize
operator|)
argument_list|,
name|np
argument_list|,
name|nsize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MPN_COPY
argument_list|(
name|rp
argument_list|,
name|np
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
block|}
block|}
name|qlimb
operator|=
name|mpn_divrem
argument_list|(
name|qp
argument_list|,
name|prec
operator|-
literal|1
operator|-
operator|(
name|rsize
operator|-
name|dsize
operator|)
argument_list|,
name|rp
argument_list|,
name|rsize
argument_list|,
name|dp
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
name|qsize
operator|=
name|prec
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|qlimb
condition|)
block|{
name|qp
index|[
name|qsize
index|]
operator|=
name|qlimb
expr_stmt|;
name|qsize
operator|++
expr_stmt|;
name|exp
operator|++
expr_stmt|;
block|}
name|EXP
argument_list|(
name|r
argument_list|)
operator|=
name|exp
expr_stmt|;
name|SIZ
argument_list|(
name|r
argument_list|)
operator|=
name|qsize
expr_stmt|;
name|TMP_FREE
argument_list|(
name|marker
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

