begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mpf_ui_sub -- Subtract a float from an unsigned long int.  Copyright (C) 1993, 1994, 1995, 1996 Free Software Foundation, Inc.  This file is part of the GNU MP Library.  The GNU MP Library is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  The GNU MP Library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with the GNU MP Library; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_include
include|#
directive|include
file|"gmp.h"
end_include

begin_include
include|#
directive|include
file|"gmp-impl.h"
end_include

begin_function
name|void
if|#
directive|if
name|__STDC__
name|mpf_ui_sub
parameter_list|(
name|mpf_ptr
name|r
parameter_list|,
name|unsigned
name|long
name|int
name|u
parameter_list|,
name|mpf_srcptr
name|v
parameter_list|)
else|#
directive|else
function|mpf_ui_sub
parameter_list|(
name|r
parameter_list|,
name|u
parameter_list|,
name|v
parameter_list|)
name|mpf_ptr
name|r
decl_stmt|;
name|unsigned
name|long
name|int
name|u
decl_stmt|;
name|mpf_srcptr
name|v
decl_stmt|;
endif|#
directive|endif
block|{
name|mp_srcptr
name|up
decl_stmt|,
name|vp
decl_stmt|;
name|mp_ptr
name|rp
decl_stmt|,
name|tp
decl_stmt|;
name|mp_size_t
name|usize
decl_stmt|,
name|vsize
decl_stmt|,
name|rsize
decl_stmt|;
name|mp_size_t
name|prec
decl_stmt|;
name|mp_exp_t
name|uexp
decl_stmt|;
name|mp_size_t
name|ediff
decl_stmt|;
name|int
name|negate
decl_stmt|;
name|mp_limb_t
name|ulimb
decl_stmt|;
name|TMP_DECL
argument_list|(
name|marker
argument_list|)
expr_stmt|;
name|vsize
operator|=
name|v
operator|->
name|_mp_size
expr_stmt|;
comment|/* Handle special cases that don't work in generic code below.  */
if|if
condition|(
name|u
operator|==
literal|0
condition|)
block|{
name|mpf_neg
argument_list|(
name|r
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|vsize
operator|==
literal|0
condition|)
block|{
name|mpf_set_ui
argument_list|(
name|r
argument_list|,
name|u
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If signs of U and V are different, perform addition.  */
if|if
condition|(
name|vsize
operator|<
literal|0
condition|)
block|{
name|__mpf_struct
name|v_negated
decl_stmt|;
name|v_negated
operator|.
name|_mp_size
operator|=
operator|-
name|vsize
expr_stmt|;
name|v_negated
operator|.
name|_mp_exp
operator|=
name|v
operator|->
name|_mp_exp
expr_stmt|;
name|v_negated
operator|.
name|_mp_d
operator|=
name|v
operator|->
name|_mp_d
expr_stmt|;
name|mpf_add_ui
argument_list|(
name|r
argument_list|,
operator|&
name|v_negated
argument_list|,
name|u
argument_list|)
expr_stmt|;
return|return;
block|}
name|TMP_MARK
argument_list|(
name|marker
argument_list|)
expr_stmt|;
comment|/* Signs are now known to be the same.  */
name|ulimb
operator|=
name|u
expr_stmt|;
comment|/* Make U be the operand with the largest exponent.  */
if|if
condition|(
literal|1
operator|<
name|v
operator|->
name|_mp_exp
condition|)
block|{
name|negate
operator|=
literal|1
expr_stmt|;
name|usize
operator|=
name|ABS
argument_list|(
name|vsize
argument_list|)
expr_stmt|;
name|vsize
operator|=
literal|1
expr_stmt|;
name|up
operator|=
name|v
operator|->
name|_mp_d
expr_stmt|;
name|vp
operator|=
operator|&
name|ulimb
expr_stmt|;
name|rp
operator|=
name|r
operator|->
name|_mp_d
expr_stmt|;
name|prec
operator|=
name|r
operator|->
name|_mp_prec
operator|+
literal|1
expr_stmt|;
name|uexp
operator|=
name|v
operator|->
name|_mp_exp
expr_stmt|;
name|ediff
operator|=
name|uexp
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|negate
operator|=
literal|0
expr_stmt|;
name|usize
operator|=
literal|1
expr_stmt|;
name|vsize
operator|=
name|ABS
argument_list|(
name|vsize
argument_list|)
expr_stmt|;
name|up
operator|=
operator|&
name|ulimb
expr_stmt|;
name|vp
operator|=
name|v
operator|->
name|_mp_d
expr_stmt|;
name|rp
operator|=
name|r
operator|->
name|_mp_d
expr_stmt|;
name|prec
operator|=
name|r
operator|->
name|_mp_prec
expr_stmt|;
name|uexp
operator|=
literal|1
expr_stmt|;
name|ediff
operator|=
literal|1
operator|-
name|v
operator|->
name|_mp_exp
expr_stmt|;
block|}
comment|/* Ignore leading limbs in U and V that are equal.  Doing      this helps increase the precision of the result.  */
if|if
condition|(
name|ediff
operator|==
literal|0
condition|)
block|{
comment|/* This loop normally exits immediately.  Optimize for that.  */
for|for
control|(
init|;
condition|;
control|)
block|{
name|usize
operator|--
expr_stmt|;
name|vsize
operator|--
expr_stmt|;
if|if
condition|(
name|up
index|[
name|usize
index|]
operator|!=
name|vp
index|[
name|vsize
index|]
condition|)
break|break;
name|uexp
operator|--
expr_stmt|;
if|if
condition|(
name|usize
operator|==
literal|0
condition|)
goto|goto
name|Lu0
goto|;
if|if
condition|(
name|vsize
operator|==
literal|0
condition|)
goto|goto
name|Lv0
goto|;
block|}
name|usize
operator|++
expr_stmt|;
name|vsize
operator|++
expr_stmt|;
comment|/* Note that either operand (but not both operands) might now have 	 leading zero limbs.  It matters only that U is unnormalized if 	 vsize is now zero, and vice versa.  And it is only in that case 	 that we have to adjust uexp.  */
if|if
condition|(
name|vsize
operator|==
literal|0
condition|)
name|Lv0
label|:
while|while
condition|(
name|usize
operator|!=
literal|0
operator|&&
name|up
index|[
name|usize
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
name|usize
operator|--
operator|,
name|uexp
operator|--
expr_stmt|;
if|if
condition|(
name|usize
operator|==
literal|0
condition|)
name|Lu0
label|:
while|while
condition|(
name|vsize
operator|!=
literal|0
operator|&&
name|vp
index|[
name|vsize
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
name|vsize
operator|--
operator|,
name|uexp
operator|--
expr_stmt|;
block|}
comment|/* If U extends beyond PREC, ignore the part that does.  */
if|if
condition|(
name|usize
operator|>
name|prec
condition|)
block|{
name|up
operator|+=
name|usize
operator|-
name|prec
expr_stmt|;
name|usize
operator|=
name|prec
expr_stmt|;
block|}
comment|/* If V extends beyond PREC, ignore the part that does.      Note that this may make vsize negative.  */
if|if
condition|(
name|vsize
operator|+
name|ediff
operator|>
name|prec
condition|)
block|{
name|vp
operator|+=
name|vsize
operator|+
name|ediff
operator|-
name|prec
expr_stmt|;
name|vsize
operator|=
name|prec
operator|-
name|ediff
expr_stmt|;
block|}
comment|/* Allocate temp space for the result.  Allocate      just vsize + ediff later???  */
name|tp
operator|=
operator|(
name|mp_ptr
operator|)
name|TMP_ALLOC
argument_list|(
name|prec
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
if|if
condition|(
name|ediff
operator|>=
name|prec
condition|)
block|{
comment|/* V completely cancelled.  */
if|if
condition|(
name|tp
operator|!=
name|up
condition|)
name|MPN_COPY
argument_list|(
name|rp
argument_list|,
name|up
argument_list|,
name|usize
argument_list|)
expr_stmt|;
name|rsize
operator|=
name|usize
expr_stmt|;
block|}
else|else
block|{
comment|/* Locate the least significant non-zero limb in (the needed 	 parts of) U and V, to simplify the code below.  */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|vsize
operator|==
literal|0
condition|)
block|{
name|MPN_COPY
argument_list|(
name|rp
argument_list|,
name|up
argument_list|,
name|usize
argument_list|)
expr_stmt|;
name|rsize
operator|=
name|usize
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|vp
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
break|break;
name|vp
operator|++
operator|,
name|vsize
operator|--
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|usize
operator|==
literal|0
condition|)
block|{
name|MPN_COPY
argument_list|(
name|rp
argument_list|,
name|vp
argument_list|,
name|vsize
argument_list|)
expr_stmt|;
name|rsize
operator|=
name|vsize
expr_stmt|;
name|negate
operator|^=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|up
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
break|break;
name|up
operator|++
operator|,
name|usize
operator|--
expr_stmt|;
block|}
comment|/* uuuu     |  uuuu     |  uuuu     |  uuuu     |  uuuu    */
comment|/* vvvvvvv  |  vv       |    vvvvv  |    v      |       vv */
if|if
condition|(
name|usize
operator|>
name|ediff
condition|)
block|{
comment|/* U and V partially overlaps.  */
if|if
condition|(
name|ediff
operator|==
literal|0
condition|)
block|{
comment|/* Have to compare the leading limbs of u and v 		 to determine whether to compute u - v or v - u.  */
if|if
condition|(
name|usize
operator|>
name|vsize
condition|)
block|{
comment|/* uuuu     */
comment|/* vv       */
name|int
name|cmp
decl_stmt|;
name|cmp
operator|=
name|mpn_cmp
argument_list|(
name|up
operator|+
name|usize
operator|-
name|vsize
argument_list|,
name|vp
argument_list|,
name|vsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|>=
literal|0
condition|)
block|{
name|mp_size_t
name|size
decl_stmt|;
name|size
operator|=
name|usize
operator|-
name|vsize
expr_stmt|;
name|MPN_COPY
argument_list|(
name|tp
argument_list|,
name|up
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|mpn_sub_n
argument_list|(
name|tp
operator|+
name|size
argument_list|,
name|up
operator|+
name|size
argument_list|,
name|vp
argument_list|,
name|vsize
argument_list|)
expr_stmt|;
name|rsize
operator|=
name|usize
expr_stmt|;
block|}
else|else
block|{
comment|/* vv       */
comment|/* Swap U and V. */
comment|/* uuuu     */
name|mp_size_t
name|size
decl_stmt|,
name|i
decl_stmt|;
name|size
operator|=
name|usize
operator|-
name|vsize
expr_stmt|;
name|tp
index|[
literal|0
index|]
operator|=
operator|-
name|up
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|tp
index|[
name|i
index|]
operator|=
operator|~
name|up
index|[
name|i
index|]
expr_stmt|;
name|mpn_sub_n
argument_list|(
name|tp
operator|+
name|size
argument_list|,
name|vp
argument_list|,
name|up
operator|+
name|size
argument_list|,
name|vsize
argument_list|)
expr_stmt|;
name|mpn_sub_1
argument_list|(
name|tp
operator|+
name|size
argument_list|,
name|tp
operator|+
name|size
argument_list|,
name|vsize
argument_list|,
operator|(
name|mp_limb_t
operator|)
literal|1
argument_list|)
expr_stmt|;
name|negate
operator|^=
literal|1
expr_stmt|;
name|rsize
operator|=
name|usize
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|usize
operator|<
name|vsize
condition|)
block|{
comment|/* uuuu     */
comment|/* vvvvvvv  */
name|int
name|cmp
decl_stmt|;
name|cmp
operator|=
name|mpn_cmp
argument_list|(
name|up
argument_list|,
name|vp
operator|+
name|vsize
operator|-
name|usize
argument_list|,
name|usize
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
name|mp_size_t
name|size
decl_stmt|,
name|i
decl_stmt|;
name|size
operator|=
name|vsize
operator|-
name|usize
expr_stmt|;
name|tp
index|[
literal|0
index|]
operator|=
operator|-
name|vp
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|tp
index|[
name|i
index|]
operator|=
operator|~
name|vp
index|[
name|i
index|]
expr_stmt|;
name|mpn_sub_n
argument_list|(
name|tp
operator|+
name|size
argument_list|,
name|up
argument_list|,
name|vp
operator|+
name|size
argument_list|,
name|usize
argument_list|)
expr_stmt|;
name|mpn_sub_1
argument_list|(
name|tp
operator|+
name|size
argument_list|,
name|tp
operator|+
name|size
argument_list|,
name|usize
argument_list|,
operator|(
name|mp_limb_t
operator|)
literal|1
argument_list|)
expr_stmt|;
name|rsize
operator|=
name|vsize
expr_stmt|;
block|}
else|else
block|{
comment|/* vvvvvvv  */
comment|/* Swap U and V. */
comment|/* uuuu     */
comment|/* This is the only place we can get 0.0.  */
name|mp_size_t
name|size
decl_stmt|;
name|size
operator|=
name|vsize
operator|-
name|usize
expr_stmt|;
name|MPN_COPY
argument_list|(
name|tp
argument_list|,
name|vp
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|mpn_sub_n
argument_list|(
name|tp
operator|+
name|size
argument_list|,
name|vp
operator|+
name|size
argument_list|,
name|up
argument_list|,
name|usize
argument_list|)
expr_stmt|;
name|negate
operator|^=
literal|1
expr_stmt|;
name|rsize
operator|=
name|vsize
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* uuuu     */
comment|/* vvvv     */
name|int
name|cmp
decl_stmt|;
name|cmp
operator|=
name|mpn_cmp
argument_list|(
name|up
argument_list|,
name|vp
operator|+
name|vsize
operator|-
name|usize
argument_list|,
name|usize
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
name|mpn_sub_n
argument_list|(
name|tp
argument_list|,
name|up
argument_list|,
name|vp
argument_list|,
name|usize
argument_list|)
expr_stmt|;
name|rsize
operator|=
name|usize
expr_stmt|;
block|}
else|else
block|{
name|mpn_sub_n
argument_list|(
name|tp
argument_list|,
name|vp
argument_list|,
name|up
argument_list|,
name|usize
argument_list|)
expr_stmt|;
name|negate
operator|^=
literal|1
expr_stmt|;
name|rsize
operator|=
name|usize
expr_stmt|;
comment|/* can give zero */
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|vsize
operator|+
name|ediff
operator|<=
name|usize
condition|)
block|{
comment|/* uuuu     */
comment|/*   v      */
name|mp_size_t
name|size
decl_stmt|;
name|size
operator|=
name|usize
operator|-
name|ediff
operator|-
name|vsize
expr_stmt|;
name|MPN_COPY
argument_list|(
name|tp
argument_list|,
name|up
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|mpn_sub
argument_list|(
name|tp
operator|+
name|size
argument_list|,
name|up
operator|+
name|size
argument_list|,
name|usize
operator|-
name|size
argument_list|,
name|vp
argument_list|,
name|vsize
argument_list|)
expr_stmt|;
name|rsize
operator|=
name|usize
expr_stmt|;
block|}
else|else
block|{
comment|/* uuuu     */
comment|/*   vvvvv  */
name|mp_size_t
name|size
decl_stmt|,
name|i
decl_stmt|;
name|size
operator|=
name|vsize
operator|+
name|ediff
operator|-
name|usize
expr_stmt|;
name|tp
index|[
literal|0
index|]
operator|=
operator|-
name|vp
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|tp
index|[
name|i
index|]
operator|=
operator|~
name|vp
index|[
name|i
index|]
expr_stmt|;
name|mpn_sub
argument_list|(
name|tp
operator|+
name|size
argument_list|,
name|up
argument_list|,
name|usize
argument_list|,
name|vp
operator|+
name|size
argument_list|,
name|usize
operator|-
name|ediff
argument_list|)
expr_stmt|;
name|mpn_sub_1
argument_list|(
name|tp
operator|+
name|size
argument_list|,
name|tp
operator|+
name|size
argument_list|,
name|usize
argument_list|,
operator|(
name|mp_limb_t
operator|)
literal|1
argument_list|)
expr_stmt|;
name|rsize
operator|=
name|vsize
operator|+
name|ediff
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* uuuu     */
comment|/*      vv  */
name|mp_size_t
name|size
decl_stmt|,
name|i
decl_stmt|;
name|size
operator|=
name|vsize
operator|+
name|ediff
operator|-
name|usize
expr_stmt|;
name|tp
index|[
literal|0
index|]
operator|=
operator|-
name|vp
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|vsize
condition|;
name|i
operator|++
control|)
name|tp
index|[
name|i
index|]
operator|=
operator|~
name|vp
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|vsize
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|tp
index|[
name|i
index|]
operator|=
operator|~
operator|(
name|mp_limb_t
operator|)
literal|0
expr_stmt|;
name|mpn_sub_1
argument_list|(
name|tp
operator|+
name|size
argument_list|,
name|up
argument_list|,
name|usize
argument_list|,
operator|(
name|mp_limb_t
operator|)
literal|1
argument_list|)
expr_stmt|;
name|rsize
operator|=
name|size
operator|+
name|usize
expr_stmt|;
block|}
comment|/* Full normalize.  Optimize later.  */
while|while
condition|(
name|rsize
operator|!=
literal|0
operator|&&
name|tp
index|[
name|rsize
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
block|{
name|rsize
operator|--
expr_stmt|;
name|uexp
operator|--
expr_stmt|;
block|}
name|MPN_COPY
argument_list|(
name|rp
argument_list|,
name|tp
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|r
operator|->
name|_mp_size
operator|=
name|negate
condition|?
operator|-
name|rsize
else|:
name|rsize
expr_stmt|;
name|r
operator|->
name|_mp_exp
operator|=
name|uexp
expr_stmt|;
name|TMP_FREE
argument_list|(
name|marker
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

