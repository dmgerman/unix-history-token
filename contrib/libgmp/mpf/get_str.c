begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mpf_get_str (digit_ptr, exp, base, n_digits, a) -- Convert the floating   point number A to a base BASE number and store N_DIGITS raw digits at   DIGIT_PTR, and the base BASE exponent in the word pointed to by EXP.  For   example, the number 3.1416 would be returned as "31416" in DIGIT_PTR and   1 in EXP.  Copyright (C) 1993, 1994, 1995, 1996 Free Software Foundation, Inc.  This file is part of the GNU MP Library.  The GNU MP Library is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  The GNU MP Library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with the GNU MP Library; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_include
include|#
directive|include
file|"gmp.h"
end_include

begin_include
include|#
directive|include
file|"gmp-impl.h"
end_include

begin_include
include|#
directive|include
file|"longlong.h"
end_include

begin_comment
comment|/*    New algorithm for converting fractions (951019):    0. Call the fraction to convert F.    1. Compute [exp * log(2^BITS_PER_MP_LIMB)/log(B)], i.e.,       [exp * BITS_PER_MP_LIMB * __mp_bases[B].chars_per_bit_exactly].  Exp is       the number of limbs between the limb point and the most significant       non-zero limb.  Call this result n.    2. Compute B^n.    3. F*B^n will now be just below 1, which can be converted easily.  (Just       multiply by B repeatedly, and see the digits fall out as integers.)    We should interrupt the conversion process of F*B^n as soon as the number    of digits requested have been generated.     New algorithm for converting integers (951019):    0. Call the integer to convert I.    1. Compute [exp * log(2^BITS_PER_MP_LIMB)/log(B)], i.e.,       [exp BITS_PER_MP_LIMB * __mp_bases[B].chars_per_bit_exactly].  Exp is       the number of limbs between the limb point and the least significant       non-zero limb.  Call this result n.    2. Compute B^n.    3. I/B^n can be converted easily.  (Just divide by B repeatedly.  In GMP,       this is best done by calling mpn_get_str.)    Note that converting I/B^n could yield more digits than requested.  For    efficiency, the variable n above should be set larger in such cases, to    kill all undesired digits in the division in step 3. */
end_comment

begin_function
name|char
modifier|*
if|#
directive|if
name|__STDC__
name|mpf_get_str
parameter_list|(
name|char
modifier|*
name|digit_ptr
parameter_list|,
name|mp_exp_t
modifier|*
name|exp
parameter_list|,
name|int
name|base
parameter_list|,
name|size_t
name|n_digits
parameter_list|,
name|mpf_srcptr
name|u
parameter_list|)
else|#
directive|else
function|mpf_get_str
parameter_list|(
name|digit_ptr
parameter_list|,
name|exp
parameter_list|,
name|base
parameter_list|,
name|n_digits
parameter_list|,
name|u
parameter_list|)
name|char
modifier|*
name|digit_ptr
decl_stmt|;
name|mp_exp_t
modifier|*
name|exp
decl_stmt|;
name|int
name|base
decl_stmt|;
name|size_t
name|n_digits
decl_stmt|;
name|mpf_srcptr
name|u
decl_stmt|;
endif|#
directive|endif
block|{
name|mp_size_t
name|usize
decl_stmt|;
name|mp_exp_t
name|uexp
decl_stmt|;
name|unsigned
name|char
modifier|*
name|str
decl_stmt|;
name|size_t
name|str_size
decl_stmt|;
name|char
modifier|*
name|num_to_text
decl_stmt|;
name|long
name|i
decl_stmt|;
comment|/* should be size_t */
name|mp_ptr
name|rp
decl_stmt|;
name|mp_limb_t
name|big_base
decl_stmt|;
name|size_t
name|digits_computed_so_far
decl_stmt|;
name|int
name|dig_per_u
decl_stmt|;
name|mp_srcptr
name|up
decl_stmt|;
name|unsigned
name|char
modifier|*
name|tstr
decl_stmt|;
name|mp_exp_t
name|exp_in_base
decl_stmt|;
name|TMP_DECL
argument_list|(
name|marker
argument_list|)
expr_stmt|;
name|TMP_MARK
argument_list|(
name|marker
argument_list|)
expr_stmt|;
name|usize
operator|=
name|u
operator|->
name|_mp_size
expr_stmt|;
name|uexp
operator|=
name|u
operator|->
name|_mp_exp
expr_stmt|;
if|if
condition|(
name|base
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|base
operator|==
literal|0
condition|)
name|base
operator|=
literal|10
expr_stmt|;
name|num_to_text
operator|=
literal|"0123456789abcdefghijklmnopqrstuvwxyz"
expr_stmt|;
block|}
else|else
block|{
name|base
operator|=
operator|-
name|base
expr_stmt|;
name|num_to_text
operator|=
literal|"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
expr_stmt|;
block|}
comment|/* Don't compute more digits than U can accurately represent.      Also, if 0 digits were requested, give *exactly* as many digits      as can be accurately represented.  */
block|{
name|size_t
name|max_digits
init|=
operator|(
operator|(
operator|(
name|u
operator|->
name|_mp_prec
operator|-
literal|1
operator|)
operator|*
name|BITS_PER_MP_LIMB
operator|)
operator|*
name|__mp_bases
index|[
name|base
index|]
operator|.
name|chars_per_bit_exactly
operator|)
decl_stmt|;
if|if
condition|(
name|n_digits
operator|==
literal|0
operator|||
name|n_digits
operator|>
name|max_digits
condition|)
name|n_digits
operator|=
name|max_digits
expr_stmt|;
block|}
if|if
condition|(
name|digit_ptr
operator|==
literal|0
condition|)
block|{
comment|/* We didn't get a string from the user.  Allocate one (and return 	 a pointer to it) with space for `-' and terminating null.  */
name|digit_ptr
operator|=
operator|(
name|char
operator|*
operator|)
call|(
modifier|*
name|_mp_allocate_func
call|)
argument_list|(
name|n_digits
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|usize
operator|==
literal|0
condition|)
block|{
operator|*
name|exp
operator|=
literal|0
expr_stmt|;
operator|*
name|digit_ptr
operator|=
literal|0
expr_stmt|;
return|return
name|digit_ptr
return|;
block|}
name|str
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|digit_ptr
expr_stmt|;
comment|/* Allocate temporary digit space.  We can't put digits directly in the user      area, since we almost always generate more digits than requested.  */
name|tstr
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|TMP_ALLOC
argument_list|(
name|n_digits
operator|+
literal|3
operator|*
name|BITS_PER_MP_LIMB
argument_list|)
expr_stmt|;
if|if
condition|(
name|usize
operator|<
literal|0
condition|)
block|{
operator|*
name|digit_ptr
operator|=
literal|'-'
expr_stmt|;
name|str
operator|++
expr_stmt|;
name|usize
operator|=
operator|-
name|usize
expr_stmt|;
block|}
name|digits_computed_so_far
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|uexp
operator|>
name|usize
condition|)
block|{
comment|/* The number has just an integral part.  */
name|mp_size_t
name|rsize
decl_stmt|;
name|mp_size_t
name|exp_in_limbs
decl_stmt|;
name|mp_size_t
name|msize
decl_stmt|;
name|mp_ptr
name|tp
decl_stmt|,
name|xp
decl_stmt|,
name|mp
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|mp_limb_t
name|cy
decl_stmt|;
name|mp_size_t
name|start_str
decl_stmt|;
name|mp_size_t
name|n_limbs
decl_stmt|;
name|n_limbs
operator|=
literal|2
operator|+
operator|(
call|(
name|mp_size_t
call|)
argument_list|(
name|n_digits
operator|/
name|__mp_bases
index|[
name|base
index|]
operator|.
name|chars_per_bit_exactly
argument_list|)
operator|/
name|BITS_PER_MP_LIMB
operator|)
expr_stmt|;
comment|/* Compute n such that [u/B^n] contains (somewhat) more than n_digits 	 digits.  (We compute less than that only if that is an exact number, 	 i.e., exp is small enough.)  */
name|exp_in_limbs
operator|=
name|uexp
expr_stmt|;
if|if
condition|(
name|n_limbs
operator|>=
name|exp_in_limbs
condition|)
block|{
comment|/* The number is so small that we convert the entire number.  */
name|exp_in_base
operator|=
literal|0
expr_stmt|;
name|rp
operator|=
operator|(
name|mp_ptr
operator|)
name|TMP_ALLOC
argument_list|(
name|exp_in_limbs
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
name|MPN_ZERO
argument_list|(
name|rp
argument_list|,
name|exp_in_limbs
operator|-
name|usize
argument_list|)
expr_stmt|;
name|MPN_COPY
argument_list|(
name|rp
operator|+
operator|(
name|exp_in_limbs
operator|-
name|usize
operator|)
argument_list|,
name|u
operator|->
name|_mp_d
argument_list|,
name|usize
argument_list|)
expr_stmt|;
name|rsize
operator|=
name|exp_in_limbs
expr_stmt|;
block|}
else|else
block|{
name|exp_in_limbs
operator|-=
name|n_limbs
expr_stmt|;
name|exp_in_base
operator|=
operator|(
operator|(
operator|(
name|exp_in_limbs
operator|*
name|BITS_PER_MP_LIMB
operator|-
literal|1
operator|)
operator|)
operator|*
name|__mp_bases
index|[
name|base
index|]
operator|.
name|chars_per_bit_exactly
operator|)
expr_stmt|;
name|rsize
operator|=
name|exp_in_limbs
operator|+
literal|1
expr_stmt|;
name|rp
operator|=
operator|(
name|mp_ptr
operator|)
name|TMP_ALLOC
argument_list|(
name|rsize
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|(
name|mp_ptr
operator|)
name|TMP_ALLOC
argument_list|(
name|rsize
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
name|rp
index|[
literal|0
index|]
operator|=
name|base
expr_stmt|;
name|rsize
operator|=
literal|1
expr_stmt|;
name|count_leading_zeros
argument_list|(
name|cnt
argument_list|,
name|exp_in_base
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|BITS_PER_MP_LIMB
operator|-
name|cnt
operator|-
literal|2
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|mpn_mul_n
argument_list|(
name|tp
argument_list|,
name|rp
argument_list|,
name|rp
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|rsize
operator|=
literal|2
operator|*
name|rsize
expr_stmt|;
name|rsize
operator|-=
name|tp
index|[
name|rsize
operator|-
literal|1
index|]
operator|==
literal|0
expr_stmt|;
name|xp
operator|=
name|tp
expr_stmt|;
name|tp
operator|=
name|rp
expr_stmt|;
name|rp
operator|=
name|xp
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|exp_in_base
operator|>>
name|i
operator|)
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|cy
operator|=
name|mpn_mul_1
argument_list|(
name|rp
argument_list|,
name|rp
argument_list|,
name|rsize
argument_list|,
operator|(
name|mp_limb_t
operator|)
name|base
argument_list|)
expr_stmt|;
name|rp
index|[
name|rsize
index|]
operator|=
name|cy
expr_stmt|;
name|rsize
operator|+=
name|cy
operator|!=
literal|0
expr_stmt|;
block|}
block|}
name|mp
operator|=
name|u
operator|->
name|_mp_d
expr_stmt|;
name|msize
operator|=
name|usize
expr_stmt|;
block|{
name|mp_ptr
name|qp
decl_stmt|;
name|mp_limb_t
name|qflag
decl_stmt|;
name|mp_size_t
name|xtra
decl_stmt|;
if|if
condition|(
name|msize
operator|<
name|rsize
condition|)
block|{
name|mp_ptr
name|tmp
init|=
operator|(
name|mp_ptr
operator|)
name|TMP_ALLOC
argument_list|(
operator|(
name|rsize
operator|+
literal|1
operator|)
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
decl_stmt|;
name|MPN_ZERO
argument_list|(
name|tmp
argument_list|,
name|rsize
operator|-
name|msize
argument_list|)
expr_stmt|;
name|MPN_COPY
argument_list|(
name|tmp
operator|+
name|rsize
operator|-
name|msize
argument_list|,
name|mp
argument_list|,
name|msize
argument_list|)
expr_stmt|;
name|mp
operator|=
name|tmp
expr_stmt|;
name|msize
operator|=
name|rsize
expr_stmt|;
block|}
else|else
block|{
name|mp_ptr
name|tmp
init|=
operator|(
name|mp_ptr
operator|)
name|TMP_ALLOC
argument_list|(
operator|(
name|msize
operator|+
literal|1
operator|)
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
decl_stmt|;
name|MPN_COPY
argument_list|(
name|tmp
argument_list|,
name|mp
argument_list|,
name|msize
argument_list|)
expr_stmt|;
name|mp
operator|=
name|tmp
expr_stmt|;
block|}
name|count_leading_zeros
argument_list|(
name|cnt
argument_list|,
name|rp
index|[
name|rsize
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|cy
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cnt
operator|!=
literal|0
condition|)
block|{
name|mpn_lshift
argument_list|(
name|rp
argument_list|,
name|rp
argument_list|,
name|rsize
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|cy
operator|=
name|mpn_lshift
argument_list|(
name|mp
argument_list|,
name|mp
argument_list|,
name|msize
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|cy
condition|)
name|mp
index|[
name|msize
operator|++
index|]
operator|=
name|cy
expr_stmt|;
block|}
block|{
name|mp_size_t
name|qsize
init|=
name|n_limbs
operator|+
operator|(
name|cy
operator|!=
literal|0
operator|)
decl_stmt|;
name|qp
operator|=
operator|(
name|mp_ptr
operator|)
name|TMP_ALLOC
argument_list|(
operator|(
name|qsize
operator|+
literal|1
operator|)
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
name|xtra
operator|=
name|qsize
operator|-
operator|(
name|msize
operator|-
name|rsize
operator|)
expr_stmt|;
name|qflag
operator|=
name|mpn_divrem
argument_list|(
name|qp
argument_list|,
name|xtra
argument_list|,
name|mp
argument_list|,
name|msize
argument_list|,
name|rp
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|qp
index|[
name|qsize
index|]
operator|=
name|qflag
expr_stmt|;
name|rsize
operator|=
name|qsize
operator|+
name|qflag
expr_stmt|;
name|rp
operator|=
name|qp
expr_stmt|;
block|}
block|}
block|}
name|str_size
operator|=
name|mpn_get_str
argument_list|(
name|tstr
argument_list|,
name|base
argument_list|,
name|rp
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|str_size
operator|>
name|n_digits
operator|+
literal|3
operator|*
name|BITS_PER_MP_LIMB
condition|)
name|abort
argument_list|()
expr_stmt|;
name|start_str
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|tstr
index|[
name|start_str
index|]
operator|==
literal|0
condition|)
name|start_str
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start_str
init|;
name|i
operator|<
name|str_size
condition|;
name|i
operator|++
control|)
block|{
name|tstr
index|[
name|digits_computed_so_far
operator|++
index|]
operator|=
name|tstr
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|digits_computed_so_far
operator|>
name|n_digits
condition|)
break|break;
block|}
name|exp_in_base
operator|=
name|exp_in_base
operator|+
name|str_size
operator|-
name|start_str
expr_stmt|;
goto|goto
name|finish_up
goto|;
block|}
name|exp_in_base
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|uexp
operator|>
literal|0
condition|)
block|{
comment|/* The number has an integral part, convert that first. 	 If there is a fractional part too, it will be handled later.  */
name|mp_size_t
name|start_str
decl_stmt|;
name|rp
operator|=
operator|(
name|mp_ptr
operator|)
name|TMP_ALLOC
argument_list|(
name|uexp
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
name|up
operator|=
name|u
operator|->
name|_mp_d
operator|+
name|usize
operator|-
name|uexp
expr_stmt|;
name|MPN_COPY
argument_list|(
name|rp
argument_list|,
name|up
argument_list|,
name|uexp
argument_list|)
expr_stmt|;
name|str_size
operator|=
name|mpn_get_str
argument_list|(
name|tstr
argument_list|,
name|base
argument_list|,
name|rp
argument_list|,
name|uexp
argument_list|)
expr_stmt|;
name|start_str
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|tstr
index|[
name|start_str
index|]
operator|==
literal|0
condition|)
name|start_str
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start_str
init|;
name|i
operator|<
name|str_size
condition|;
name|i
operator|++
control|)
block|{
name|tstr
index|[
name|digits_computed_so_far
operator|++
index|]
operator|=
name|tstr
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|digits_computed_so_far
operator|>
name|n_digits
condition|)
block|{
name|exp_in_base
operator|=
name|str_size
operator|-
name|start_str
expr_stmt|;
goto|goto
name|finish_up
goto|;
block|}
block|}
name|exp_in_base
operator|=
name|str_size
operator|-
name|start_str
expr_stmt|;
comment|/* Modify somewhat and fall out to convert fraction... */
name|usize
operator|-=
name|uexp
expr_stmt|;
name|uexp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|usize
operator|<=
literal|0
condition|)
goto|goto
name|finish_up
goto|;
comment|/* Convert the fraction.  */
block|{
name|mp_size_t
name|rsize
decl_stmt|,
name|msize
decl_stmt|;
name|mp_ptr
name|rp
decl_stmt|,
name|tp
decl_stmt|,
name|xp
decl_stmt|,
name|mp
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|mp_limb_t
name|cy
decl_stmt|;
name|mp_exp_t
name|nexp
decl_stmt|;
name|big_base
operator|=
name|__mp_bases
index|[
name|base
index|]
operator|.
name|big_base
expr_stmt|;
name|dig_per_u
operator|=
name|__mp_bases
index|[
name|base
index|]
operator|.
name|chars_per_limb
expr_stmt|;
comment|/* Hack for correctly (although not efficiently) converting to bases that        are powers of 2.  If we deem it important, we could handle powers of 2        by shifting and masking (just like mpn_get_str).  */
if|if
condition|(
name|big_base
operator|<
literal|10
condition|)
comment|/* logarithm of base when power of two */
block|{
name|int
name|logbase
init|=
name|big_base
decl_stmt|;
if|if
condition|(
name|dig_per_u
operator|*
name|logbase
operator|==
name|BITS_PER_MP_LIMB
condition|)
name|dig_per_u
operator|--
expr_stmt|;
name|big_base
operator|=
operator|(
name|mp_limb_t
operator|)
literal|1
operator|<<
operator|(
name|dig_per_u
operator|*
name|logbase
operator|)
expr_stmt|;
comment|/* fall out to general code... */
block|}
if|#
directive|if
literal|0
block|if (0&& uexp == 0)       { 	rp = (mp_ptr) TMP_ALLOC (usize * BYTES_PER_MP_LIMB); 	up = u->_mp_d; 	MPN_COPY (rp, up, usize); 	rsize = usize; 	nexp = 0;       }     else       {}
endif|#
directive|endif
name|uexp
operator|=
operator|-
name|uexp
expr_stmt|;
if|if
condition|(
name|u
operator|->
name|_mp_d
index|[
name|usize
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
name|cnt
operator|=
literal|0
expr_stmt|;
else|else
name|count_leading_zeros
argument_list|(
name|cnt
argument_list|,
name|u
operator|->
name|_mp_d
index|[
name|usize
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|nexp
operator|=
operator|(
operator|(
name|uexp
operator|*
name|BITS_PER_MP_LIMB
operator|)
operator|+
name|cnt
operator|)
operator|*
name|__mp_bases
index|[
name|base
index|]
operator|.
name|chars_per_bit_exactly
expr_stmt|;
if|if
condition|(
name|nexp
operator|==
literal|0
condition|)
block|{
name|rp
operator|=
operator|(
name|mp_ptr
operator|)
name|TMP_ALLOC
argument_list|(
name|usize
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
name|up
operator|=
name|u
operator|->
name|_mp_d
expr_stmt|;
name|MPN_COPY
argument_list|(
name|rp
argument_list|,
name|up
argument_list|,
name|usize
argument_list|)
expr_stmt|;
name|rsize
operator|=
name|usize
expr_stmt|;
block|}
else|else
block|{
name|rsize
operator|=
name|uexp
operator|+
literal|2
expr_stmt|;
name|rp
operator|=
operator|(
name|mp_ptr
operator|)
name|TMP_ALLOC
argument_list|(
name|rsize
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|(
name|mp_ptr
operator|)
name|TMP_ALLOC
argument_list|(
name|rsize
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
name|rp
index|[
literal|0
index|]
operator|=
name|base
expr_stmt|;
name|rsize
operator|=
literal|1
expr_stmt|;
name|count_leading_zeros
argument_list|(
name|cnt
argument_list|,
name|nexp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|BITS_PER_MP_LIMB
operator|-
name|cnt
operator|-
literal|2
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|mpn_mul_n
argument_list|(
name|tp
argument_list|,
name|rp
argument_list|,
name|rp
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|rsize
operator|=
literal|2
operator|*
name|rsize
expr_stmt|;
name|rsize
operator|-=
name|tp
index|[
name|rsize
operator|-
literal|1
index|]
operator|==
literal|0
expr_stmt|;
name|xp
operator|=
name|tp
expr_stmt|;
name|tp
operator|=
name|rp
expr_stmt|;
name|rp
operator|=
name|xp
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|nexp
operator|>>
name|i
operator|)
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|cy
operator|=
name|mpn_mul_1
argument_list|(
name|rp
argument_list|,
name|rp
argument_list|,
name|rsize
argument_list|,
operator|(
name|mp_limb_t
operator|)
name|base
argument_list|)
expr_stmt|;
name|rp
index|[
name|rsize
index|]
operator|=
name|cy
expr_stmt|;
name|rsize
operator|+=
name|cy
operator|!=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Did our multiplier (base^nexp) cancel with uexp?  */
if|#
directive|if
literal|0
block|if (uexp != rsize) 	  { 	    do 	      { 		cy = mpn_mul_1 (rp, rp, rsize, big_base); 		nexp += dig_per_u; 	      } 	    while (cy == 0); 	    rp[rsize++] = cy; 	  }
endif|#
directive|endif
name|mp
operator|=
name|u
operator|->
name|_mp_d
expr_stmt|;
name|msize
operator|=
name|usize
expr_stmt|;
name|tp
operator|=
operator|(
name|mp_ptr
operator|)
name|TMP_ALLOC
argument_list|(
operator|(
name|rsize
operator|+
name|msize
operator|)
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsize
operator|>
name|msize
condition|)
name|cy
operator|=
name|mpn_mul
argument_list|(
name|tp
argument_list|,
name|rp
argument_list|,
name|rsize
argument_list|,
name|mp
argument_list|,
name|msize
argument_list|)
expr_stmt|;
else|else
name|cy
operator|=
name|mpn_mul
argument_list|(
name|tp
argument_list|,
name|mp
argument_list|,
name|msize
argument_list|,
name|rp
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|rsize
operator|+=
name|msize
expr_stmt|;
name|rsize
operator|-=
name|cy
operator|==
literal|0
expr_stmt|;
name|rp
operator|=
name|tp
expr_stmt|;
comment|/* If we already output digits (for an integral part) pad 	   leading zeros.  */
if|if
condition|(
name|digits_computed_so_far
operator|!=
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nexp
condition|;
name|i
operator|++
control|)
name|tstr
index|[
name|digits_computed_so_far
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|digits_computed_so_far
operator|<=
name|n_digits
condition|)
block|{
comment|/* For speed: skip trailing zeroes.  */
if|if
condition|(
name|rp
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|rp
operator|++
expr_stmt|;
name|rsize
operator|--
expr_stmt|;
if|if
condition|(
name|rsize
operator|==
literal|0
condition|)
block|{
name|n_digits
operator|=
name|digits_computed_so_far
expr_stmt|;
break|break;
block|}
block|}
name|cy
operator|=
name|mpn_mul_1
argument_list|(
name|rp
argument_list|,
name|rp
argument_list|,
name|rsize
argument_list|,
name|big_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|digits_computed_so_far
operator|==
literal|0
operator|&&
name|cy
operator|==
literal|0
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
name|nexp
operator|+=
name|dig_per_u
expr_stmt|;
continue|continue;
block|}
comment|/* Convert N1 from BIG_BASE to a string of digits in BASE 	   using single precision operations.  */
block|{
name|unsigned
name|char
modifier|*
name|s
init|=
name|tstr
operator|+
name|digits_computed_so_far
operator|+
name|dig_per_u
decl_stmt|;
for|for
control|(
name|i
operator|=
name|dig_per_u
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
operator|*
operator|--
name|s
operator|=
name|cy
operator|%
name|base
expr_stmt|;
name|cy
operator|/=
name|base
expr_stmt|;
block|}
block|}
name|digits_computed_so_far
operator|+=
name|dig_per_u
expr_stmt|;
block|}
if|if
condition|(
name|exp_in_base
operator|==
literal|0
condition|)
name|exp_in_base
operator|=
operator|-
name|nexp
expr_stmt|;
block|}
name|finish_up
label|:
comment|/* We can have at most one leading 0.  Remove it.  */
if|if
condition|(
name|tstr
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|tstr
operator|++
expr_stmt|;
name|digits_computed_so_far
operator|--
expr_stmt|;
name|exp_in_base
operator|--
expr_stmt|;
block|}
comment|/* We should normally have computed too many digits.  Round the result      at the point indicated by n_digits.  */
if|if
condition|(
name|digits_computed_so_far
operator|>
name|n_digits
condition|)
block|{
comment|/* Round the result.  */
if|if
condition|(
name|tstr
index|[
name|n_digits
index|]
operator|*
literal|2
operator|>=
name|base
condition|)
block|{
name|digits_computed_so_far
operator|=
name|n_digits
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n_digits
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|unsigned
name|int
name|x
decl_stmt|;
name|x
operator|=
operator|++
operator|(
name|tstr
index|[
name|i
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
name|base
condition|)
goto|goto
name|rounded_ok
goto|;
name|digits_computed_so_far
operator|--
expr_stmt|;
block|}
name|tstr
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|digits_computed_so_far
operator|=
literal|1
expr_stmt|;
name|exp_in_base
operator|++
expr_stmt|;
name|rounded_ok
label|:
empty_stmt|;
block|}
block|}
comment|/* We might have fewer digits than requested as a result of rounding above,      (i.e. 0.999999 => 1.0) or because we have a number that simply doesn't      need many digits in this base (i.e., 0.125 in base 10).  */
if|if
condition|(
name|n_digits
operator|>
name|digits_computed_so_far
condition|)
name|n_digits
operator|=
name|digits_computed_so_far
expr_stmt|;
comment|/* Remove trailing 0.  There can be many zeros. */
while|while
condition|(
name|n_digits
operator|!=
literal|0
operator|&&
name|tstr
index|[
name|n_digits
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
name|n_digits
operator|--
expr_stmt|;
comment|/* Translate to ascii and null-terminate.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_digits
condition|;
name|i
operator|++
control|)
operator|*
name|str
operator|++
operator|=
name|num_to_text
index|[
name|tstr
index|[
name|i
index|]
index|]
expr_stmt|;
operator|*
name|str
operator|=
literal|0
expr_stmt|;
operator|*
name|exp
operator|=
name|exp_in_base
expr_stmt|;
name|TMP_FREE
argument_list|(
name|marker
argument_list|)
expr_stmt|;
return|return
name|digit_ptr
return|;
block|}
end_function

begin_if
if|#
directive|if
name|COPY_THIS_TO_OTHER_PLACES
end_if

begin_comment
comment|/* Use this expression in lots of places in the library instead of the 	 count_leading_zeros+expression that is used currently.  This expression 	 is much more accurate and will save odles of memory.  */
end_comment

begin_expr_stmt
name|rsize
operator|=
operator|(
call|(
name|mp_size_t
call|)
argument_list|(
name|exp_in_base
operator|/
name|__mp_bases
index|[
name|base
index|]
operator|.
name|chars_per_bit_exactly
argument_list|)
operator|+
name|BITS_PER_MP_LIMB
operator|)
operator|/
name|BITS_PER_MP_LIMB
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

