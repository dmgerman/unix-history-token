begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mpf_set_str (dest, string, base) -- Convert the string STRING    in base BASE to a float in dest.  If BASE is zero, the leading characters    of STRING is used to figure out the base.  Copyright (C) 1993, 1994, 1995, 1996 Free Software Foundation, Inc.  This file is part of the GNU MP Library.  The GNU MP Library is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  The GNU MP Library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with the GNU MP Library; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"gmp.h"
end_include

begin_include
include|#
directive|include
file|"gmp-impl.h"
end_include

begin_include
include|#
directive|include
file|"longlong.h"
end_include

begin_decl_stmt
name|long
name|int
name|strtol
name|_PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|char
operator|*
operator|*
name|ptr
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|digit_value_in_base
parameter_list|(
name|c
parameter_list|,
name|base
parameter_list|)
name|int
name|c
decl_stmt|;
name|int
name|base
decl_stmt|;
block|{
name|int
name|digit
decl_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
name|digit
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|islower
argument_list|(
name|c
argument_list|)
condition|)
name|digit
operator|=
name|c
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
name|digit
operator|=
name|c
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
else|else
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|digit
operator|<
name|base
condition|)
return|return
name|digit
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
if|#
directive|if
name|__STDC__
name|mpf_set_str
parameter_list|(
name|mpf_ptr
name|x
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|base
parameter_list|)
else|#
directive|else
function|mpf_set_str
parameter_list|(
name|x
parameter_list|,
name|str
parameter_list|,
name|base
parameter_list|)
name|mpf_ptr
name|x
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|base
decl_stmt|;
endif|#
directive|endif
block|{
name|size_t
name|str_size
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|begs
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|mp_size_t
name|xsize
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|negative
decl_stmt|;
name|char
modifier|*
name|dotpos
init|=
literal|0
decl_stmt|;
name|int
name|expflag
decl_stmt|;
name|int
name|decimal_exponent_flag
decl_stmt|;
name|TMP_DECL
argument_list|(
name|marker
argument_list|)
expr_stmt|;
name|TMP_MARK
argument_list|(
name|marker
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|str
expr_stmt|;
comment|/* Skip whitespace.  */
while|while
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
operator|*
operator|++
name|str
expr_stmt|;
name|negative
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
block|{
name|negative
operator|=
literal|1
expr_stmt|;
name|c
operator|=
operator|*
operator|++
name|str
expr_stmt|;
block|}
name|decimal_exponent_flag
operator|=
name|base
operator|<
literal|0
expr_stmt|;
name|base
operator|=
name|ABS
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|digit_value_in_base
argument_list|(
name|c
argument_list|,
name|base
operator|==
literal|0
condition|?
literal|10
else|:
name|base
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* error if no digits */
comment|/* If BASE is 0, try to find out the base by looking at the initial      characters.  */
if|if
condition|(
name|base
operator|==
literal|0
condition|)
block|{
name|base
operator|=
literal|10
expr_stmt|;
if|#
directive|if
literal|0
block|if (c == '0') 	{ 	  base = 8; 	  c = *++str; 	  if (c == 'x' || c == 'X') 	    base = 16; 	}
endif|#
directive|endif
block|}
name|expflag
operator|=
literal|0
expr_stmt|;
name|str_size
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|str_size
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|str
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'@'
operator|||
operator|(
name|base
operator|<=
literal|10
operator|&&
operator|(
name|c
operator|==
literal|'e'
operator|||
name|c
operator|==
literal|'E'
operator|)
operator|)
condition|)
block|{
name|expflag
operator|=
literal|1
expr_stmt|;
name|str_size
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
name|s
operator|=
name|begs
operator|=
operator|(
name|char
operator|*
operator|)
name|TMP_ALLOC
argument_list|(
name|str_size
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|str_size
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|*
name|str
expr_stmt|;
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|int
name|dig
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|dotpos
operator|!=
literal|0
condition|)
block|{
name|TMP_FREE
argument_list|(
name|marker
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|dotpos
operator|=
name|s
expr_stmt|;
block|}
else|else
block|{
name|dig
operator|=
name|digit_value_in_base
argument_list|(
name|c
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|dig
operator|<
literal|0
condition|)
block|{
name|TMP_FREE
argument_list|(
name|marker
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
operator|*
name|s
operator|++
operator|=
name|dig
expr_stmt|;
block|}
block|}
name|c
operator|=
operator|*
operator|++
name|str
expr_stmt|;
block|}
name|str_size
operator|=
name|s
operator|-
name|begs
expr_stmt|;
name|xsize
operator|=
name|str_size
operator|/
name|__mp_bases
index|[
name|base
index|]
operator|.
name|chars_per_limb
operator|+
literal|2
expr_stmt|;
block|{
name|long
name|exp_in_base
decl_stmt|;
name|mp_size_t
name|rsize
decl_stmt|,
name|msize
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|i
decl_stmt|;
name|mp_ptr
name|mp
decl_stmt|,
name|xp
decl_stmt|,
name|tp
decl_stmt|,
name|rp
decl_stmt|;
name|mp_limb_t
name|cy
decl_stmt|;
name|mp_exp_t
name|exp_in_limbs
decl_stmt|;
name|mp_size_t
name|prec
init|=
name|x
operator|->
name|_mp_prec
decl_stmt|;
name|int
name|divflag
decl_stmt|;
name|mp_size_t
name|xxx
init|=
literal|0
decl_stmt|;
name|mp
operator|=
operator|(
name|mp_ptr
operator|)
name|TMP_ALLOC
argument_list|(
name|xsize
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
name|msize
operator|=
name|mpn_set_str
argument_list|(
name|mp
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|begs
argument_list|,
name|str_size
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|msize
operator|==
literal|0
condition|)
block|{
name|x
operator|->
name|_mp_size
operator|=
literal|0
expr_stmt|;
name|x
operator|->
name|_mp_exp
operator|=
literal|0
expr_stmt|;
name|TMP_FREE
argument_list|(
name|marker
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|expflag
operator|!=
literal|0
condition|)
name|exp_in_base
operator|=
name|strtol
argument_list|(
name|str
operator|+
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
literal|0
argument_list|,
name|decimal_exponent_flag
condition|?
literal|10
else|:
name|base
argument_list|)
expr_stmt|;
else|else
name|exp_in_base
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dotpos
operator|!=
literal|0
condition|)
name|exp_in_base
operator|-=
name|s
operator|-
name|dotpos
expr_stmt|;
name|divflag
operator|=
name|exp_in_base
operator|<
literal|0
expr_stmt|;
name|exp_in_base
operator|=
name|ABS
argument_list|(
name|exp_in_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp_in_base
operator|==
literal|0
condition|)
block|{
name|MPN_COPY
argument_list|(
name|x
operator|->
name|_mp_d
argument_list|,
name|mp
argument_list|,
name|msize
argument_list|)
expr_stmt|;
name|x
operator|->
name|_mp_size
operator|=
name|negative
condition|?
operator|-
name|msize
else|:
name|msize
expr_stmt|;
name|x
operator|->
name|_mp_exp
operator|=
name|msize
expr_stmt|;
name|TMP_FREE
argument_list|(
name|marker
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|#
directive|if
literal|1
name|rsize
operator|=
operator|(
operator|(
call|(
name|mp_size_t
call|)
argument_list|(
name|exp_in_base
operator|/
name|__mp_bases
index|[
name|base
index|]
operator|.
name|chars_per_bit_exactly
argument_list|)
operator|)
operator|/
name|BITS_PER_MP_LIMB
operator|+
literal|3
operator|)
expr_stmt|;
else|#
directive|else
name|count_leading_zeros
argument_list|(
name|cnt
argument_list|,
operator|(
name|mp_limb_t
operator|)
name|base
argument_list|)
expr_stmt|;
name|rsize
operator|=
name|exp_in_base
operator|-
name|cnt
operator|*
name|exp_in_base
operator|/
name|BITS_PER_MP_LIMB
operator|+
literal|1
expr_stmt|;
endif|#
directive|endif
name|rp
operator|=
operator|(
name|mp_ptr
operator|)
name|TMP_ALLOC
argument_list|(
name|rsize
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|(
name|mp_ptr
operator|)
name|TMP_ALLOC
argument_list|(
name|rsize
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
name|rp
index|[
literal|0
index|]
operator|=
name|base
expr_stmt|;
name|rsize
operator|=
literal|1
expr_stmt|;
name|count_leading_zeros
argument_list|(
name|cnt
argument_list|,
name|exp_in_base
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|BITS_PER_MP_LIMB
operator|-
name|cnt
operator|-
literal|2
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|mpn_mul_n
argument_list|(
name|tp
argument_list|,
name|rp
argument_list|,
name|rp
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|rsize
operator|=
literal|2
operator|*
name|rsize
expr_stmt|;
name|rsize
operator|-=
name|tp
index|[
name|rsize
operator|-
literal|1
index|]
operator|==
literal|0
expr_stmt|;
name|xp
operator|=
name|tp
expr_stmt|;
name|tp
operator|=
name|rp
expr_stmt|;
name|rp
operator|=
name|xp
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|exp_in_base
operator|>>
name|i
operator|)
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|cy
operator|=
name|mpn_mul_1
argument_list|(
name|rp
argument_list|,
name|rp
argument_list|,
name|rsize
argument_list|,
operator|(
name|mp_limb_t
operator|)
name|base
argument_list|)
expr_stmt|;
name|rp
index|[
name|rsize
index|]
operator|=
name|cy
expr_stmt|;
name|rsize
operator|+=
name|cy
operator|!=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rsize
operator|>
name|prec
condition|)
block|{
name|xxx
operator|+=
name|rsize
operator|-
name|prec
expr_stmt|;
name|rp
operator|+=
name|rsize
operator|-
name|prec
expr_stmt|;
name|rsize
operator|=
name|prec
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|if (msize> prec)       { 	xxx -= msize - prec; 	mp += msize - prec; 	msize = prec;       }
endif|#
directive|endif
if|if
condition|(
name|divflag
condition|)
block|{
name|mp_ptr
name|qp
decl_stmt|;
name|mp_limb_t
name|qflag
decl_stmt|;
name|mp_size_t
name|xtra
decl_stmt|;
if|if
condition|(
name|msize
operator|<=
name|rsize
condition|)
block|{
comment|/* Allocate extra limb for current divrem sematics. */
name|mp_ptr
name|tmp
init|=
operator|(
name|mp_ptr
operator|)
name|TMP_ALLOC
argument_list|(
operator|(
name|rsize
operator|+
literal|1
operator|)
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
decl_stmt|;
name|MPN_ZERO
argument_list|(
name|tmp
argument_list|,
name|rsize
operator|-
name|msize
argument_list|)
expr_stmt|;
name|MPN_COPY
argument_list|(
name|tmp
operator|+
name|rsize
operator|-
name|msize
argument_list|,
name|mp
argument_list|,
name|msize
argument_list|)
expr_stmt|;
name|mp
operator|=
name|tmp
expr_stmt|;
name|xxx
operator|+=
name|rsize
operator|-
name|msize
expr_stmt|;
name|msize
operator|=
name|rsize
expr_stmt|;
block|}
name|count_leading_zeros
argument_list|(
name|cnt
argument_list|,
name|rp
index|[
name|rsize
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|!=
literal|0
condition|)
block|{
name|mpn_lshift
argument_list|(
name|rp
argument_list|,
name|rp
argument_list|,
name|rsize
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|cy
operator|=
name|mpn_lshift
argument_list|(
name|mp
argument_list|,
name|mp
argument_list|,
name|msize
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|cy
condition|)
name|mp
index|[
name|msize
operator|++
index|]
operator|=
name|cy
expr_stmt|;
block|}
name|qp
operator|=
operator|(
name|mp_ptr
operator|)
name|TMP_ALLOC
argument_list|(
operator|(
name|prec
operator|+
literal|1
operator|)
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
name|xtra
operator|=
name|prec
operator|-
operator|(
name|msize
operator|-
name|rsize
operator|)
expr_stmt|;
name|qflag
operator|=
name|mpn_divrem
argument_list|(
name|qp
argument_list|,
name|xtra
argument_list|,
name|mp
argument_list|,
name|msize
argument_list|,
name|rp
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|qp
index|[
name|prec
index|]
operator|=
name|qflag
expr_stmt|;
name|tp
operator|=
name|qp
expr_stmt|;
name|rsize
operator|=
name|prec
operator|+
name|qflag
expr_stmt|;
name|exp_in_limbs
operator|=
name|rsize
operator|-
name|xtra
operator|-
name|xxx
expr_stmt|;
block|}
else|else
block|{
name|tp
operator|=
operator|(
name|mp_ptr
operator|)
name|TMP_ALLOC
argument_list|(
operator|(
name|rsize
operator|+
name|msize
operator|)
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsize
operator|>
name|msize
condition|)
name|mpn_mul
argument_list|(
name|tp
argument_list|,
name|rp
argument_list|,
name|rsize
argument_list|,
name|mp
argument_list|,
name|msize
argument_list|)
expr_stmt|;
else|else
name|mpn_mul
argument_list|(
name|tp
argument_list|,
name|mp
argument_list|,
name|msize
argument_list|,
name|rp
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|rsize
operator|+=
name|msize
expr_stmt|;
name|rsize
operator|-=
name|tp
index|[
name|rsize
operator|-
literal|1
index|]
operator|==
literal|0
expr_stmt|;
name|exp_in_limbs
operator|=
name|rsize
operator|+
name|xxx
expr_stmt|;
if|if
condition|(
name|rsize
operator|>
name|prec
condition|)
block|{
name|xxx
operator|=
name|rsize
operator|-
name|prec
expr_stmt|;
name|tp
operator|+=
name|rsize
operator|-
name|prec
expr_stmt|;
name|rsize
operator|=
name|prec
expr_stmt|;
name|exp_in_limbs
operator|+=
literal|0
expr_stmt|;
block|}
block|}
name|MPN_COPY
argument_list|(
name|x
operator|->
name|_mp_d
argument_list|,
name|tp
argument_list|,
name|rsize
argument_list|)
expr_stmt|;
name|x
operator|->
name|_mp_size
operator|=
name|negative
condition|?
operator|-
name|rsize
else|:
name|rsize
expr_stmt|;
name|x
operator|->
name|_mp_exp
operator|=
name|exp_in_limbs
expr_stmt|;
name|TMP_FREE
argument_list|(
name|marker
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

end_unit

