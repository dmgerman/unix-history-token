begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* mtox -- Convert OPERAND to hexadecimal and return a malloc'ed string    with the result of the conversion.  Copyright (C) 1991, 1994 Free Software Foundation, Inc.  This file is part of the GNU MP Library.  The GNU MP Library is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  The GNU MP Library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with the GNU MP Library; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_include
include|#
directive|include
file|"mp.h"
end_include

begin_include
include|#
directive|include
file|"gmp.h"
end_include

begin_include
include|#
directive|include
file|"gmp-impl.h"
end_include

begin_function
name|char
modifier|*
if|#
directive|if
name|__STDC__
name|mtox
parameter_list|(
specifier|const
name|MINT
modifier|*
name|x
parameter_list|)
else|#
directive|else
function|mtox
parameter_list|(
name|x
parameter_list|)
specifier|const
name|MINT
modifier|*
name|x
decl_stmt|;
endif|#
directive|endif
block|{
name|mp_ptr
name|xp
decl_stmt|;
name|mp_size_t
name|xsize
init|=
name|x
operator|->
name|_mp_size
decl_stmt|;
name|mp_size_t
name|xsign
decl_stmt|;
name|unsigned
name|char
modifier|*
name|str
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|size_t
name|str_size
decl_stmt|,
name|i
decl_stmt|;
name|int
name|zeros
decl_stmt|;
name|char
modifier|*
name|num_to_text
decl_stmt|;
name|TMP_DECL
argument_list|(
name|marker
argument_list|)
expr_stmt|;
if|if
condition|(
name|xsize
operator|==
literal|0
condition|)
block|{
name|str
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
call|(
modifier|*
name|_mp_allocate_func
call|)
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|str
index|[
literal|0
index|]
operator|=
literal|'0'
expr_stmt|;
name|str
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|str
return|;
block|}
name|xsign
operator|=
name|xsize
expr_stmt|;
if|if
condition|(
name|xsize
operator|<
literal|0
condition|)
name|xsize
operator|=
operator|-
name|xsize
expr_stmt|;
name|TMP_MARK
argument_list|(
name|marker
argument_list|)
expr_stmt|;
name|str_size
operator|=
operator|(
call|(
name|size_t
call|)
argument_list|(
name|xsize
operator|*
name|BITS_PER_MP_LIMB
operator|*
name|__mp_bases
index|[
literal|16
index|]
operator|.
name|chars_per_bit_exactly
argument_list|)
operator|)
operator|+
literal|3
expr_stmt|;
name|str
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
call|(
modifier|*
name|_mp_allocate_func
call|)
argument_list|(
name|str_size
argument_list|)
expr_stmt|;
name|s
operator|=
name|str
expr_stmt|;
if|if
condition|(
name|xsign
operator|<
literal|0
condition|)
operator|*
name|s
operator|++
operator|=
literal|'-'
expr_stmt|;
comment|/* Move the number to convert into temporary space, since mpn_get_str      clobbers its argument + needs one extra high limb....  */
name|xp
operator|=
operator|(
name|mp_ptr
operator|)
name|TMP_ALLOC
argument_list|(
operator|(
name|xsize
operator|+
literal|1
operator|)
operator|*
name|BYTES_PER_MP_LIMB
argument_list|)
expr_stmt|;
name|MPN_COPY
argument_list|(
name|xp
argument_list|,
name|x
operator|->
name|_mp_d
argument_list|,
name|xsize
argument_list|)
expr_stmt|;
name|str_size
operator|=
name|mpn_get_str
argument_list|(
name|s
argument_list|,
literal|16
argument_list|,
name|xp
argument_list|,
name|xsize
argument_list|)
expr_stmt|;
comment|/* mpn_get_str might make some leading zeros.  Skip them.  */
for|for
control|(
name|zeros
operator|=
literal|0
init|;
name|s
index|[
name|zeros
index|]
operator|==
literal|0
condition|;
name|zeros
operator|++
control|)
name|str_size
operator|--
expr_stmt|;
comment|/* Translate to printable chars and move string down.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|str_size
condition|;
name|i
operator|++
control|)
name|s
index|[
name|i
index|]
operator|=
literal|"0123456789abcdef"
index|[
name|s
index|[
name|zeros
operator|+
name|i
index|]
index|]
expr_stmt|;
name|s
index|[
name|str_size
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

end_unit

