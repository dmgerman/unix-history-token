begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * (Free/Net/386)BSD ST01/02, Future Domain TMC-885, TMC-950 SCSI driver for  * Julians SCSI-code  *  * Copyright 1994, Kent Palmkvist (kentp@isy.liu.se)  * Copyright 1994, Robert Knier (rknier@qgraph.com)   * Copyright 1992, 1994 Drew Eckhardt (drew@colorado.edu)  * Copyright 1994, Julian Elischer (julian@tfs.com)  *  * Others that has contributed by example code is  * 		Glen Overby (overby@cray.com)  *		Tatu Yllnen  *		Brian E Litzinger  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE DEVELOPERS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE DEVELOPERS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *    $Id$  *  */
end_comment

begin_comment
comment|/*  *  * kentp  940307 alpha version based on newscsi-03 version of Julians SCSI-code  * kentp  940314 Added possibility to not use messages  * rknier 940331 Added fast transfer code   * rknier 940407 Added assembler coded data transfers   *  */
end_comment

begin_comment
comment|/*  * What should really be done:  *   * Add missing tests for timeouts  * Restructure interrupt enable/disable code (runs to long with int disabled)  * Find bug? giving problem with tape status  * Add code to handle Future Domain 840, 841, 880 and 881  * adjust timeouts (startup is very slow)  * add code to use tagged commands in SCSI2  * Add code to handle slow devices better (sleep if device not disconnecting)  * Fix unnecessary interrupts  */
end_comment

begin_comment
comment|/* Note to users trying to share a disk between DOS and unix:  * The ST01/02 is a translating host-adapter. It is not giving DOS  * the same number of heads/tracks/sectors as specified by the disk.  * It is therefore important to look at what numbers DOS thinks the  * disk has. Use these to disklabel your disk in an appropriate manner  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL
end_ifdef

begin_comment
comment|/* don't laugh.. look for main() */
end_comment

begin_include
include|#
directive|include
file|<sea.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KERNEL */
end_comment

begin_include
include|#
directive|include
file|<scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsiconf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL
end_ifdef

begin_include
include|#
directive|include
file|"ddb.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* KERNEL */
end_comment

begin_define
define|#
directive|define
name|NSEA
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KERNEL */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|hz
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SEA_SCB_MAX
value|8
end_define

begin_comment
comment|/* allow maximally 8 scsi control blocks */
end_comment

begin_define
define|#
directive|define
name|SCB_TABLE_SIZE
value|8
end_define

begin_comment
comment|/* start with 8 scb entries in table */
end_comment

begin_define
define|#
directive|define
name|BLOCK_SIZE
value|512
end_define

begin_comment
comment|/* size of READ/WRITE areas on SCSI card */
end_comment

begin_comment
comment|/*  * defining PARITY causes parity data to be checked  */
end_comment

begin_define
define|#
directive|define
name|PARITY
value|1
end_define

begin_comment
comment|/*  * defining SEA_BLINDTRANSFER will make DATA IN and DATA OUT to be done with  * blind transfers, i.e. no check is done for scsi phase changes. This will  * result in data loss if the scsi device does not send its data using  * BLOCK_SIZE bytes at a time.  * If SEA_BLINDTRANSFER defined and SEA_ASSEMBLER also defined will result in  * the use of blind transfers coded in assembler. SEA_ASSEMBLER is no good  * without SEA_BLINDTRANSFER defined.  */
end_comment

begin_define
define|#
directive|define
name|SEA_BLINDTRANSFER
value|1
end_define

begin_comment
comment|/* do blind transfers */
end_comment

begin_define
define|#
directive|define
name|SEA_ASSEMBLER
value|1
end_define

begin_comment
comment|/* Use assembly code for fast transfers */
end_comment

begin_comment
comment|/*  * defining SEANOMSGS causes messages not to be used (thereby disabling  * disconnects)  */
end_comment

begin_comment
comment|/* #define SEANOMSGS 1 */
end_comment

begin_comment
comment|/*  * defining SEA_NODATAOUT makes dataout phase being aborted  */
end_comment

begin_comment
comment|/* #define SEA_NODATAOUT	1 */
end_comment

begin_comment
comment|/*  * defining SEA_SENSEFIRST make REQUEST_SENSE opcode to be placed first  */
end_comment

begin_comment
comment|/* #define SEA_SENSEFIRST       1 */
end_comment

begin_define
define|#
directive|define
name|SEA_FREEBSD11
value|1
end_define

begin_comment
comment|/* intermediate def. for FreeBSD 1.1 BETA */
end_comment

begin_comment
comment|/* timeout function has changed */
end_comment

begin_comment
comment|/* Debugging definitions. Should not be used unless you want a lot of    printouts even under normal conditions */
end_comment

begin_comment
comment|/* #define SEADEBUG	1 */
end_comment

begin_comment
comment|/* General info about errors */
end_comment

begin_comment
comment|/* #define SEADEBUG1	1 */
end_comment

begin_comment
comment|/* Info about internal results and errors */
end_comment

begin_comment
comment|/* #define SEADEBUG2	1 */
end_comment

begin_comment
comment|/* Display a lot about timeouts etc */
end_comment

begin_comment
comment|/* #define SEADEBUG3	1 */
end_comment

begin_comment
comment|/* #define SEADEBUG4	1 */
end_comment

begin_comment
comment|/* #define SEADEBUG5	1 */
end_comment

begin_comment
comment|/* #define SEADEBUG6	1 */
end_comment

begin_comment
comment|/* Display info about queue-lengths */
end_comment

begin_comment
comment|/* #define SEADEBUG7	1 */
end_comment

begin_comment
comment|/* Extra check on STATUS before phase check */
end_comment

begin_comment
comment|/* #define SEADEBUG8	1 */
end_comment

begin_comment
comment|/* Disregard non-BSY state in 				   sea_information_transfer */
end_comment

begin_comment
comment|/* #define SEADEBUG9	1 */
end_comment

begin_comment
comment|/* Enable printouts */
end_comment

begin_comment
comment|/* #define SEADEBUG11	1 */
end_comment

begin_comment
comment|/* stop everything except access to scsi id 1 */
end_comment

begin_comment
comment|/* #define SEADEBUG15	1 */
end_comment

begin_comment
comment|/* Display every byte sent/received */
end_comment

begin_define
define|#
directive|define
name|NUM_CONCURRENT
value|1
end_define

begin_comment
comment|/* number of concurrent ops per board */
end_comment

begin_comment
comment|/******************************* board definitions **************************/
end_comment

begin_comment
comment|/*  * CONTROL defines  */
end_comment

begin_define
define|#
directive|define
name|CMD_RST
value|0x01
end_define

begin_comment
comment|/* scsi reset */
end_comment

begin_define
define|#
directive|define
name|CMD_SEL
value|0x02
end_define

begin_comment
comment|/* scsi select */
end_comment

begin_define
define|#
directive|define
name|CMD_BSY
value|0x04
end_define

begin_comment
comment|/* scsi busy */
end_comment

begin_define
define|#
directive|define
name|CMD_ATTN
value|0x08
end_define

begin_comment
comment|/* scsi attention */
end_comment

begin_define
define|#
directive|define
name|CMD_START_ARB
value|0x10
end_define

begin_comment
comment|/* start arbitration bit */
end_comment

begin_define
define|#
directive|define
name|CMD_EN_PARITY
value|0x20
end_define

begin_comment
comment|/* enable scsi parity generation */
end_comment

begin_define
define|#
directive|define
name|CMD_INTR
value|0x40
end_define

begin_comment
comment|/* enable scsi interrupts */
end_comment

begin_define
define|#
directive|define
name|CMD_DRVR_ENABLE
value|0x80
end_define

begin_comment
comment|/* scsi enable */
end_comment

begin_comment
comment|/*  * STATUS  */
end_comment

begin_define
define|#
directive|define
name|STAT_BSY
value|0x01
end_define

begin_comment
comment|/* scsi busy */
end_comment

begin_define
define|#
directive|define
name|STAT_MSG
value|0x02
end_define

begin_comment
comment|/* scsi msg */
end_comment

begin_define
define|#
directive|define
name|STAT_IO
value|0x04
end_define

begin_comment
comment|/* scsi I/O */
end_comment

begin_define
define|#
directive|define
name|STAT_CD
value|0x08
end_define

begin_comment
comment|/* scsi C/D */
end_comment

begin_define
define|#
directive|define
name|STAT_REQ
value|0x10
end_define

begin_comment
comment|/* scsi req */
end_comment

begin_define
define|#
directive|define
name|STAT_SEL
value|0x20
end_define

begin_comment
comment|/* scsi select */
end_comment

begin_define
define|#
directive|define
name|STAT_PARITY
value|0x40
end_define

begin_comment
comment|/* parity error bit */
end_comment

begin_define
define|#
directive|define
name|STAT_ARB_CMPL
value|0x80
end_define

begin_comment
comment|/* arbitration complete bit */
end_comment

begin_comment
comment|/*  * REQUESTS  */
end_comment

begin_define
define|#
directive|define
name|REQ_MASK
value|(STAT_CD | STAT_IO | STAT_MSG)
end_define

begin_define
define|#
directive|define
name|REQ_DATAOUT
value|0
end_define

begin_define
define|#
directive|define
name|REQ_DATAIN
value|STAT_IO
end_define

begin_define
define|#
directive|define
name|REQ_CMDOUT
value|STAT_CD
end_define

begin_define
define|#
directive|define
name|REQ_STATIN
value|(STAT_CD | STAT_IO)
end_define

begin_define
define|#
directive|define
name|REQ_MSGOUT
value|(STAT_MSG | STAT_CD)
end_define

begin_define
define|#
directive|define
name|REQ_MSGIN
value|(STAT_MSG | STAT_CD | STAT_IO)
end_define

begin_define
define|#
directive|define
name|REQ_UNKNOWN
value|0xff
end_define

begin_define
define|#
directive|define
name|SEAGATERAMOFFSET
value|0x00001800
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|PARITY
end_ifdef

begin_define
define|#
directive|define
name|BASE_CMD
value|(CMD_EN_PARITY | CMD_INTR)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BASE_CMD
value|(CMD_INTR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SEAGATE
value|1
end_define

begin_define
define|#
directive|define
name|FD
value|2
end_define

begin_comment
comment|/******************************************************************************  *	This should be placed in a more generic file (presume in /sys/scsi)  *	Message codes:  */
end_comment

begin_define
define|#
directive|define
name|MSG_ABORT
value|0x06
end_define

begin_define
define|#
directive|define
name|MSG_NOP
value|0x08
end_define

begin_define
define|#
directive|define
name|MSG_COMMAND_COMPLETE
value|0x00
end_define

begin_define
define|#
directive|define
name|MSG_DISCONNECT
value|0x04
end_define

begin_define
define|#
directive|define
name|MSG_IDENTIFY
value|0x80
end_define

begin_define
define|#
directive|define
name|MSG_BUS_DEV_RESET
value|0x0c
end_define

begin_define
define|#
directive|define
name|MSG_MESSAGE_REJECT
value|0x07
end_define

begin_define
define|#
directive|define
name|MSG_SAVE_POINTERS
value|0x02
end_define

begin_define
define|#
directive|define
name|MSG_RESTORE_POINTERS
value|0x03
end_define

begin_comment
comment|/******************************************************************************/
end_comment

begin_define
define|#
directive|define
name|IDENTIFY
parameter_list|(
name|can_disconnect
parameter_list|,
name|lun
parameter_list|)
value|(MSG_IDENTIFY | ((can_disconnect) ? \                                                0x40 : 0) | ((lun)& 0x07))
end_define

begin_comment
comment|/* scsi control block used to keep info about a scsi command */
end_comment

begin_struct
struct|struct
name|sea_scb
block|{
name|int
name|flags
decl_stmt|;
comment|/* status of the instruction */
define|#
directive|define
name|SCB_FREE
value|0
define|#
directive|define
name|SCB_ACTIVE
value|1
define|#
directive|define
name|SCB_ABORTED
value|2
define|#
directive|define
name|SCB_TIMEOUT
value|4
define|#
directive|define
name|SCB_ERROR
value|8
define|#
directive|define
name|SCB_TIMECHK
value|16
comment|/* We have set a timeout on this one */
name|struct
name|sea_scb
modifier|*
name|next
decl_stmt|;
comment|/* in free list */
name|struct
name|scsi_xfer
modifier|*
name|xfer
decl_stmt|;
comment|/* the scsi_xfer for this cmd */
name|u_char
modifier|*
name|data
decl_stmt|;
comment|/* position in data buffer so far */
name|int32
name|datalen
decl_stmt|;
comment|/* bytes remaining to transfer */
empty_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * data structure describing current status of the scsi bus. One for each  * controller card.  */
end_comment

begin_struct
struct|struct
name|sea_data
block|{
name|caddr_t
name|basemaddr
decl_stmt|;
comment|/* Base address for card */
name|char
name|ctrl_type
decl_stmt|;
comment|/* FD or SEAGATE */
name|caddr_t
name|st0x_cr_sr
decl_stmt|;
comment|/* Address of control and status register */
name|caddr_t
name|st0x_dr
decl_stmt|;
comment|/* Address of data register */
name|u_short
name|vect
decl_stmt|;
comment|/* interrupt vector for this card */
name|int
name|our_id
decl_stmt|;
comment|/* our scsi id */
name|int
name|numscb
decl_stmt|;
comment|/* number of scsi control blocks */
name|struct
name|scsi_link
name|sc_link
decl_stmt|;
comment|/* struct connecting different data */
name|struct
name|sea_scb
modifier|*
name|connected
decl_stmt|;
comment|/* currently connected command */
name|struct
name|sea_scb
modifier|*
name|issue_queue
decl_stmt|;
comment|/* waiting to be issued */
name|struct
name|sea_scb
modifier|*
name|disconnected_queue
decl_stmt|;
comment|/* waiting to reconnect */
name|struct
name|sea_scb
name|scbs
index|[
name|SCB_TABLE_SIZE
index|]
decl_stmt|;
name|struct
name|sea_scb
modifier|*
name|free_scb
decl_stmt|;
comment|/* free scb list */
specifier|volatile
name|unsigned
name|char
name|busy
index|[
literal|8
index|]
decl_stmt|;
comment|/* index=target, bit=lun, Keep track of 					   busy luns at device target */
block|}
modifier|*
name|seadata
index|[
name|NSEA
index|]
struct|;
end_struct

begin_comment
comment|/* flag showing if main routine is running. */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|main_running
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|STATUS
value|(*(volatile unsigned char *) sea->st0x_cr_sr)
end_define

begin_define
define|#
directive|define
name|CONTROL
value|STATUS
end_define

begin_define
define|#
directive|define
name|DATA
value|(*(volatile unsigned char *) sea->st0x_dr)
end_define

begin_comment
comment|/*  * These are "special" values for the tag parameter passed to sea_select  * Not implemented right now.  */
end_comment

begin_define
define|#
directive|define
name|TAG_NEXT
value|-1
end_define

begin_comment
comment|/* Use next free tag */
end_comment

begin_define
define|#
directive|define
name|TAG_NONE
value|-2
end_define

begin_comment
comment|/* 				 * Establish I_T_L nexus instead of I_T_L_Q 				 * even on SCSI-II devices. 				 */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|signature
decl_stmt|;
name|unsigned
name|offset
decl_stmt|;
name|unsigned
name|length
decl_stmt|;
name|unsigned
name|char
name|type
decl_stmt|;
block|}
name|BiosSignature
typedef|;
end_typedef

begin_comment
comment|/*  * Signatures for automatic recognition of board type  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|BiosSignature
name|signatures
index|[]
init|=
block|{
block|{
literal|"ST01 v1.7  (C) Copyright 1987 Seagate"
block|,
literal|15
block|,
literal|37
block|,
name|SEAGATE
block|}
block|,
block|{
literal|"SCSI BIOS 2.00  (C) Copyright 1987 Seagate"
block|,
literal|15
block|,
literal|40
block|,
name|SEAGATE
block|}
block|,
comment|/*  * The following two lines are NOT mistakes. One detects ROM revision  * 3.0.0, the other 3.2. Since seagate has only one type of SCSI adapter,  * and this is not going to change, the "SEAGATE" and "SCSI" together  * are probably "good enough"  */
block|{
literal|"SEAGATE SCSI BIOS "
block|,
literal|16
block|,
literal|17
block|,
name|SEAGATE
block|}
block|,
block|{
literal|"SEAGATE SCSI BIOS "
block|,
literal|17
block|,
literal|17
block|,
name|SEAGATE
block|}
block|,
comment|/*   * However, future domain makes several incompatible SCSI boards, so specific   * signatures must be used.   */
block|{
literal|"FUTURE DOMAIN CORP. (C) 1986-1989 V5.0C2/14/89"
block|,
literal|5
block|,
literal|45
block|,
name|FD
block|}
block|,
block|{
literal|"FUTURE DOMAIN CORP. (C) 1986-1989 V6.0A7/28/89"
block|,
literal|5
block|,
literal|46
block|,
name|FD
block|}
block|,
block|{
literal|"FUTURE DOMAIN CORP. (C) 1986-1990 V6.0105/31/90"
block|,
literal|5
block|,
literal|47
block|,
name|FD
block|}
block|,
block|{
literal|"FUTURE DOMAIN CORP. (C) 1986-1990 V6.0209/18/90"
block|,
literal|5
block|,
literal|47
block|,
name|FD
block|}
block|,
block|{
literal|"FUTURE DOMAIN CORP. (C) 1986-1990 V7.009/18/90"
block|,
literal|5
block|,
literal|46
block|,
name|FD
block|}
block|,
block|{
literal|"FUTURE DOMAIN CORP. (C) 1992 V8.00.004/02/92"
block|,
literal|5
block|,
literal|44
block|,
name|FD
block|}
block|,
block|{
literal|"FUTURE DOMAIN TMC-950"
block|,
literal|5
block|,
literal|21
block|,
name|FD
block|}
block|,  }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NUM_SIGNATURES
value|(sizeof(signatures) / sizeof(BiosSignature))
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|seagate_bases
index|[]
init|=
block|{
operator|(
name|char
operator|*
operator|)
literal|0xc8000
block|,
operator|(
name|char
operator|*
operator|)
literal|0xca000
block|,
operator|(
name|char
operator|*
operator|)
literal|0xcc000
block|,
operator|(
name|char
operator|*
operator|)
literal|0xce000
block|,
operator|(
name|char
operator|*
operator|)
literal|0xdc000
block|,
operator|(
name|char
operator|*
operator|)
literal|0xde000
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NUM_BASES
value|(sizeof(seagate_bases)/sizeof(char *))
end_define

begin_function_decl
name|int
name|sea_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|sea_attach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|seaintr
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int32
name|sea_scsi_cmd
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
name|xs
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SEA_FREEBSD11
end_ifdef

begin_function_decl
name|void
name|sea_timeout
parameter_list|(
name|caddr_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
name|void
name|sea_timeout
parameter_list|(
name|struct
name|sea_scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|void
name|seaminphys
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|sea_done
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|sea_scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_int32
name|sea_adapter_info
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|sea_scb
modifier|*
name|sea_get_scb
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|sea_free_scb
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|sea_scb
modifier|*
name|scb
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sea_main
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sea_information_transfer
parameter_list|(
name|struct
name|sea_data
modifier|*
name|sea
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|sea_poll
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|scsi_xfer
modifier|*
name|xs
parameter_list|,
name|struct
name|sea_scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|sea_init
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|sea_send_scb
parameter_list|(
name|struct
name|sea_data
modifier|*
name|sea
parameter_list|,
name|struct
name|sea_scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|sea_reselect
parameter_list|(
name|struct
name|sea_data
modifier|*
name|sea
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|sea_select
parameter_list|(
name|struct
name|sea_data
modifier|*
name|sea
parameter_list|,
name|struct
name|sea_scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|sea_transfer_pio
parameter_list|(
name|struct
name|sea_data
modifier|*
name|sea
parameter_list|,
name|u_char
modifier|*
name|phase
parameter_list|,
name|int32
modifier|*
name|count
parameter_list|,
name|u_char
modifier|*
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|sea_abort
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|sea_scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|sea_unit
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|sea_slot
operator|=
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* last found board seagate_bases address index */
end_comment

begin_define
define|#
directive|define
name|FAIL
value|1
end_define

begin_define
define|#
directive|define
name|SUCCESS
value|0
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL
end_ifdef

begin_decl_stmt
name|struct
name|scsi_adapter
name|sea_switch
init|=
block|{
name|sea_scsi_cmd
block|,
name|seaminphys
block|,
literal|0
block|,
literal|0
block|,
name|sea_adapter_info
block|,
literal|"sea"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the below structure is so we have a default dev struct for our link struct */
end_comment

begin_decl_stmt
name|struct
name|scsi_device
name|sea_dev
init|=
block|{
name|NULL
block|,
comment|/* use default error handler */
name|NULL
block|,
comment|/* have a queue, served by this */
name|NULL
block|,
comment|/* have no async handler */
name|NULL
block|,
comment|/* Use default 'done' routine */
literal|"sea"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|isa_driver
name|seadriver
init|=
block|{
name|seaprobe
block|,
name|seaattach
block|,
literal|"sea"
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KERNEL */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SEADEBUG6
end_ifdef

begin_function
name|void
name|sea_queue_length
parameter_list|()
block|{
name|struct
name|sea_scb
modifier|*
name|tmp
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|seadata
index|[
literal|0
index|]
operator|->
name|connected
condition|)
name|length
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|tmp
operator|=
name|seadata
index|[
literal|0
index|]
operator|->
name|issue_queue
init|;
name|tmp
operator|!=
name|NULL
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|next
operator|,
name|length
operator|++
control|)
empty_stmt|;
for|for
control|(
name|tmp
operator|=
name|seadata
index|[
literal|0
index|]
operator|->
name|disconnected_queue
init|;
name|tmp
operator|!=
name|NULL
condition|;
name|tmp
operator|->
name|next
operator|,
name|length
operator|++
control|)
empty_stmt|;
name|printf
argument_list|(
literal|"length:%d "
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/***********************************************************************\ * Check if the device can be found at the port given and if so, detect	* * the type of board. Set it up ready for further work. Takes the	* * isa_dev structure from autoconf as an argument.			* * Returns 1 if card recognized, 0 if errors				* \***********************************************************************/
end_comment

begin_function
name|int
name|sea_probe
parameter_list|(
name|dev
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dev
decl_stmt|;
block|{
name|int
name|j
decl_stmt|;
name|int
name|unit
init|=
name|sea_unit
decl_stmt|;
name|struct
name|sea_data
modifier|*
name|sea
decl_stmt|;
name|dev
operator|->
name|id_unit
operator|=
name|unit
expr_stmt|;
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|"sea_probe "
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* find unit and check we have that many defined */
if|if
condition|(
name|unit
operator|>=
name|NSEA
condition|)
block|{
name|printf
argument_list|(
literal|"sea%d: unit number too high\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dev
operator|->
name|id_unit
operator|=
name|unit
expr_stmt|;
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|"unit: %d\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"dev_addr: 0x%lx\n"
argument_list|,
name|dev
operator|->
name|id_maddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* allocate a storage area for us */
if|if
condition|(
name|seadata
index|[
name|unit
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"sea%d: memory already allocated\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|"Before malloc\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sea
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sea_data
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sea
condition|)
block|{
name|printf
argument_list|(
literal|"sea%d: cannot malloc!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|"after malloc\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|32767
condition|;
name|j
operator|++
control|)
empty_stmt|;
endif|#
directive|endif
name|bzero
argument_list|(
name|sea
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sea_data
argument_list|)
argument_list|)
expr_stmt|;
name|seadata
index|[
name|unit
index|]
operator|=
name|sea
expr_stmt|;
comment|/* check for address if no one specified */
name|sea
operator|->
name|basemaddr
operator|=
name|NULL
expr_stmt|;
comment|/* Could try to find a board by looking through all possible addresses */
comment|/* This is not done the right way now, because I have not found a way  */
comment|/* to get a boards virtual memory address given its physical. There is */
comment|/* a function that returns the physical address for a given virtual    */
comment|/* address, but not the other way around */
if|if
condition|(
name|dev
operator|->
name|id_maddr
operator|==
literal|0
condition|)
block|{
comment|/*     for(sea_slot++;sea_slot<NUM_BASES;sea_slot++)       for(j = 0; !sea->basemaddr&& j< NUM_SIGNATURES; ++j) 	if(!memcmp((void *)(seagate_bases[sea_slot]+signatures[j].offset), 		   (void *) signatures[j].signature, signatures[j].length)) { 	  sea->basemaddr = (void *)seagate_bases[sea_slot]; 	  break; 	} */
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|"id_maddr != 0\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|32767
condition|;
name|j
operator|++
control|)
empty_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|32767
condition|;
name|j
operator|++
control|)
empty_stmt|;
endif|#
directive|endif
comment|/* find sea_slot position for overridden memory address */
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
operator|(
name|char
operator|*
operator|)
name|vtophys
argument_list|(
name|dev
operator|->
name|id_maddr
argument_list|)
operator|!=
name|seagate_bases
index|[
name|j
index|]
operator|)
operator|&&
name|j
operator|<
name|NUM_BASES
condition|;
operator|++
name|j
control|)
empty_stmt|;
if|if
condition|(
name|j
operator|==
name|NUM_BASES
condition|)
block|{
name|printf
argument_list|(
literal|"sea: board not expected at address 0x%lx\n"
argument_list|,
name|dev
operator|->
name|id_maddr
argument_list|)
expr_stmt|;
name|seadata
index|[
name|unit
index|]
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|sea
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|sea_slot
operator|>
name|j
condition|)
block|{
name|printf
argument_list|(
literal|"sea: board address 0x%lx already probed!\n"
argument_list|,
name|dev
operator|->
name|id_maddr
argument_list|)
expr_stmt|;
name|seadata
index|[
name|unit
index|]
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|sea
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|sea
operator|->
name|basemaddr
operator|=
name|dev
operator|->
name|id_maddr
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|"sea->basemaddr = %lx\n"
argument_list|,
name|sea
operator|->
name|basemaddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* check board type */
comment|/* No way to define this through config */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NUM_SIGNATURES
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|memcmp
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|sea
operator|->
name|basemaddr
operator|+
name|signatures
index|[
name|j
index|]
operator|.
name|offset
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|signatures
index|[
name|j
index|]
operator|.
name|signature
argument_list|,
name|signatures
index|[
name|j
index|]
operator|.
name|length
argument_list|)
condition|)
block|{
name|sea
operator|->
name|ctrl_type
operator|=
name|signatures
index|[
name|j
index|]
operator|.
name|type
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|j
operator|==
name|NUM_SIGNATURES
condition|)
block|{
name|printf
argument_list|(
literal|"sea: Board type unknown at address 0x%lx\n"
argument_list|,
name|sea
operator|->
name|basemaddr
argument_list|)
expr_stmt|;
name|seadata
index|[
name|unit
index|]
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|sea
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Find controller and data memory addresses */
name|sea
operator|->
name|st0x_cr_sr
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|sea
operator|->
name|basemaddr
operator|)
operator|+
operator|(
operator|(
name|sea
operator|->
name|ctrl_type
operator|==
name|SEAGATE
operator|)
condition|?
literal|0x1a00
else|:
literal|0x1c00
operator|)
operator|)
expr_stmt|;
name|sea
operator|->
name|st0x_dr
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|sea
operator|->
name|basemaddr
operator|)
operator|+
operator|(
operator|(
name|sea
operator|->
name|ctrl_type
operator|==
name|SEAGATE
operator|)
condition|?
literal|0x1c00
else|:
literal|0x1e00
operator|)
operator|)
expr_stmt|;
comment|/* Test controller RAM (works the same way on future domain cards?) */
operator|*
operator|(
name|sea
operator|->
name|basemaddr
operator|+
name|SEAGATERAMOFFSET
operator|)
operator|=
literal|0xa5
expr_stmt|;
operator|*
operator|(
name|sea
operator|->
name|basemaddr
operator|+
name|SEAGATERAMOFFSET
operator|+
literal|1
operator|)
operator|=
literal|0x5a
expr_stmt|;
if|if
condition|(
operator|(
operator|*
operator|(
name|sea
operator|->
name|basemaddr
operator|+
name|SEAGATERAMOFFSET
operator|)
operator|!=
operator|(
name|char
operator|)
literal|0xa5
operator|)
operator|||
operator|(
operator|*
operator|(
name|sea
operator|->
name|basemaddr
operator|+
name|SEAGATERAMOFFSET
operator|+
literal|1
operator|)
operator|!=
operator|(
name|char
operator|)
literal|0x5a
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"sea%d: Board RAM failure\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sea_init
argument_list|(
name|unit
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|seadata
index|[
name|unit
index|]
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|sea
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* if its there put in it's interrupt vector */
comment|/* (Doesn't use dma, so no drq is set) */
name|sea
operator|->
name|vect
operator|=
name|dev
operator|->
name|id_irq
expr_stmt|;
name|sea_unit
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/***********************************************\ * Attach all sub-devices we can find		* \***********************************************/
end_comment

begin_function
name|int
name|sea_attach
parameter_list|(
name|dev
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dev
decl_stmt|;
block|{
name|int
name|unit
init|=
name|dev
operator|->
name|id_unit
decl_stmt|;
name|struct
name|sea_data
modifier|*
name|sea
init|=
name|seadata
index|[
name|unit
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|"sea_attach called\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* fill in the prototype scsi_link */
name|sea
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|=
name|unit
expr_stmt|;
name|sea
operator|->
name|sc_link
operator|.
name|adapter_targ
operator|=
name|sea
operator|->
name|our_id
expr_stmt|;
name|sea
operator|->
name|sc_link
operator|.
name|adapter
operator|=
operator|&
name|sea_switch
expr_stmt|;
name|sea
operator|->
name|sc_link
operator|.
name|device
operator|=
operator|&
name|sea_dev
expr_stmt|;
comment|/*****************************************************\   * ask the adapter what subunits are present		*   \*****************************************************/
name|scsi_attachdevs
argument_list|(
operator|&
operator|(
name|sea
operator|->
name|sc_link
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/***********************************************\ * Return some information to the caller about	* * the adapter and its capabilities		* \***********************************************/
end_comment

begin_function
name|u_int32
name|sea_adapter_info
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|"sea_adapter_info called\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/***********************************************\ * Catch an interrupt from the adaptor		* \***********************************************/
end_comment

begin_function
name|int
name|seaintr
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|int
name|done
decl_stmt|;
name|struct
name|sea_data
modifier|*
name|sea
init|=
name|seadata
index|[
name|unit
index|]
decl_stmt|;
name|int
name|oldpri
decl_stmt|;
if|#
directive|if
name|SEADEBUG2
name|printf
argument_list|(
literal|";"
argument_list|)
expr_stmt|;
endif|#
directive|endif
do|do
block|{
name|done
operator|=
literal|1
expr_stmt|;
comment|/* dispatch to appropriate routine if found and done=0 */
comment|/* should check to see that this card really caused the interrupt */
if|if
condition|(
operator|(
name|STATUS
operator|&
operator|(
name|STAT_SEL
operator||
name|STAT_IO
operator|)
operator|)
operator|==
operator|(
name|STAT_SEL
operator||
name|STAT_IO
operator|)
condition|)
block|{
comment|/* Reselect interrupt */
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|";2"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|done
operator|=
literal|0
expr_stmt|;
comment|/*      enable_intr(); */
comment|/* ?? How should this be done ?? */
name|sea_reselect
argument_list|(
name|sea
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STATUS
operator|&
name|STAT_PARITY
condition|)
block|{
comment|/* Parity error interrupt */
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|";3"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"sea%d: PARITY interrupt\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|SEADEBUG2
comment|/* 		printf("sea%d: unknown interrupt\n",unit); */
name|printf
argument_list|(
literal|";4%x"
argument_list|,
name|STATUS
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|done
condition|)
block|{
name|oldpri
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* disable_intr(); */
if|if
condition|(
operator|!
name|main_running
condition|)
block|{
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|";5"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|main_running
operator|=
literal|1
expr_stmt|;
name|sea_main
argument_list|()
expr_stmt|;
comment|/* main_running is cleared in sea_main once it can't 	 * do more work, and sea_main exits with interrupts 	 * disabled 	 */
name|splx
argument_list|(
name|oldpri
argument_list|)
expr_stmt|;
comment|/* enable_intr(); */
block|}
else|else
block|{
name|splx
argument_list|(
name|oldpri
argument_list|)
expr_stmt|;
comment|/* enable_intr(); */
block|}
block|}
block|}
do|while
condition|(
operator|!
name|done
condition|)
do|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/***********************************************\ * Setup data structures, and reset the board	* * and the scsi bus				* \***********************************************/
end_comment

begin_function
name|int
name|sea_init
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|long
name|l
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|sea_data
modifier|*
name|sea
init|=
name|seadata
index|[
name|unit
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|"sea_init called\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Reset the scsi bus (I don't know if this is needed */
name|CONTROL
operator|=
name|BASE_CMD
operator||
name|CMD_DRVR_ENABLE
operator||
name|CMD_RST
expr_stmt|;
name|DELAY
argument_list|(
literal|25
argument_list|)
expr_stmt|;
comment|/* hold reset for at least 25 microseconds */
name|CONTROL
operator|=
name|BASE_CMD
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* wait a Bus Clear Delay (800 ns + bus free delay (800 ns) */
comment|/* Set our id (don't know anything about this) */
if|if
condition|(
name|sea
operator|->
name|ctrl_type
operator|==
name|SEAGATE
condition|)
name|sea
operator|->
name|our_id
operator|=
literal|7
expr_stmt|;
else|else
name|sea
operator|->
name|our_id
operator|=
literal|6
expr_stmt|;
comment|/* init fields used by our routines */
name|sea
operator|->
name|connected
operator|=
name|NULL
expr_stmt|;
name|sea
operator|->
name|issue_queue
operator|=
name|NULL
expr_stmt|;
name|sea
operator|->
name|disconnected_queue
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|sea
operator|->
name|busy
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* link up the free list of scbs */
name|sea
operator|->
name|numscb
operator|=
name|SCB_TABLE_SIZE
expr_stmt|;
name|sea
operator|->
name|free_scb
operator|=
operator|(
expr|struct
name|sea_scb
operator|*
operator|)
operator|&
operator|(
name|sea
operator|->
name|scbs
index|[
literal|0
index|]
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|SCB_TABLE_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|sea
operator|->
name|scbs
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|next
operator|=
operator|&
operator|(
name|sea
operator|->
name|scbs
index|[
name|i
index|]
operator|)
expr_stmt|;
block|}
name|sea
operator|->
name|scbs
index|[
name|SCB_TABLE_SIZE
operator|-
literal|1
index|]
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/***********************************************\ *						* \***********************************************/
end_comment

begin_function
name|void
name|seaminphys
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|SEADEBUG2
comment|/*  printf("seaminphys called\n"); */
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/***********************************************\ * start a scsi operation given the command and	* * the data address. Also needs the unit, target	* * and lu					* * get a free scb and set it up			* * call send_scb					* * either start timer or wait until done		* \***********************************************/
end_comment

begin_function
name|int32
name|sea_scsi_cmd
parameter_list|(
name|xs
parameter_list|)
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
block|{
name|struct
name|scsi_sense_data
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|struct
name|sea_scb
modifier|*
name|scb
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|unit
init|=
name|xs
operator|->
name|sc_link
operator|->
name|adapter_unit
decl_stmt|;
name|struct
name|sea_data
modifier|*
name|sea
init|=
name|seadata
index|[
name|unit
index|]
decl_stmt|;
name|int
name|s
decl_stmt|;
name|unsigned
name|int
name|stat
decl_stmt|;
name|int32
name|result
decl_stmt|;
ifdef|#
directive|ifdef
name|SEADEBUG2
comment|/* printf("scsi_cmd\n"); */
name|printf
argument_list|(
literal|"="
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SEADEBUG11
if|if
condition|(
name|xs
operator|->
name|sc_link
operator|->
name|target
operator|!=
literal|1
condition|)
block|{
name|xs
operator|->
name|flags
operator||=
name|ITSDONE
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_TIMEOUT
expr_stmt|;
return|return
operator|(
name|HAD_ERROR
operator|)
return|;
block|}
endif|#
directive|endif
name|flags
operator|=
name|xs
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|bp
condition|)
name|flags
operator||=
operator|(
name|SCSI_NOSLEEP
operator|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ITSDONE
condition|)
block|{
name|printf
argument_list|(
literal|"sea%d: Already done?"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator|&=
operator|~
name|ITSDONE
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|INUSE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"sea%d: Not in use?"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|INUSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|scb
operator|=
name|sea_get_scb
argument_list|(
name|unit
argument_list|,
name|flags
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|"=2"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
return|return
operator|(
name|TRY_AGAIN_LATER
operator|)
return|;
block|}
comment|/*    * Put all the arguments for the xfer in the scb    */
name|scb
operator|->
name|xfer
operator|=
name|xs
expr_stmt|;
name|scb
operator|->
name|datalen
operator|=
name|xs
operator|->
name|datalen
expr_stmt|;
name|scb
operator|->
name|data
operator|=
name|xs
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SCSI_RESET
condition|)
block|{
comment|/* Try to send a reset command to the card. This is done by calling the      * Reset function. Should then return COMPLETE. Need to take care of the      * possible current connected command.      * Not implemented right now.      */
name|printf
argument_list|(
literal|"sea%d: Got a SCSI_RESET!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
comment|/* setup the scb to contain necessary values */
comment|/* The interresting values can be read from the xs that is saved */
comment|/* I therefore think that the structure can be kept very small */
comment|/* the driver doesn't use DMA so the scatter/gather is not needed ? */
ifdef|#
directive|ifdef
name|SEADEBUG6
name|sea_queue_length
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sea_send_scb
argument_list|(
name|sea
argument_list|,
name|scb
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|"=3"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|sea_free_scb
argument_list|(
name|unit
argument_list|,
name|scb
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRY_AGAIN_LATER
operator|)
return|;
block|}
comment|/*    * Usually return SUCCESSFULLY QUEUED    */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
block|{
if|if
condition|(
name|xs
operator|->
name|flags
operator|&
name|ITSDONE
condition|)
block|{
comment|/* timout timer not started, already finished */
comment|/* Tried to return COMPLETE but the machine hanged with this */
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|"=6"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|SUCCESSFULLY_QUEUED
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|SEA_FREEBSD11
name|timeout
argument_list|(
name|sea_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
operator|(
name|xs
operator|->
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
else|#
directive|else
name|timeout
argument_list|(
name|sea_timeout
argument_list|,
name|scb
argument_list|,
operator|(
name|xs
operator|->
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|scb
operator|->
name|flags
operator||=
name|SCB_TIMECHK
expr_stmt|;
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|"=4"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|SUCCESSFULLY_QUEUED
operator|)
return|;
block|}
comment|/*    * If we can't use interrupts, poll on completion    */
name|result
operator|=
name|sea_poll
argument_list|(
name|unit
argument_list|,
name|xs
argument_list|,
name|scb
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|"=5 %lx"
argument_list|,
name|result
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Get a free scb. If there are none, see if we can allocate a new one. If so,  * put it in the hash table too, otherwise return an error or sleep.  */
end_comment

begin_function
name|struct
name|sea_scb
modifier|*
name|sea_get_scb
parameter_list|(
name|unit
parameter_list|,
name|flags
parameter_list|)
name|int
name|unit
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|sea_data
modifier|*
name|sea
init|=
name|seadata
index|[
name|unit
index|]
decl_stmt|;
name|unsigned
name|opri
init|=
literal|0
decl_stmt|;
name|struct
name|sea_scb
modifier|*
name|scbp
decl_stmt|;
name|int
name|hashnum
decl_stmt|;
ifdef|#
directive|ifdef
name|SEADEBUG2
comment|/*  printf("get_scb\n"); */
name|printf
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|opri
operator|=
name|splbio
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SEADEBUG3
name|printf
argument_list|(
literal|"(2 %lx "
argument_list|,
name|sea
operator|->
name|free_scb
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*    * If we can and have to, sleep waiting for one to come free    * but only if we cant allocate a new one.    */
while|while
condition|(
operator|!
operator|(
name|scbp
operator|=
name|sea
operator|->
name|free_scb
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SEADEBUG12
name|printf
argument_list|(
literal|"(3"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sea
operator|->
name|numscb
operator|<
name|SEA_SCB_MAX
condition|)
block|{
name|printf
argument_list|(
literal|"malloced new scbs\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|scbp
operator|=
operator|(
expr|struct
name|sea_scb
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sea_scb
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
condition|)
block|{
name|bzero
argument_list|(
name|scbp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sea_scb
argument_list|)
argument_list|)
expr_stmt|;
name|sea
operator|->
name|numscb
operator|++
expr_stmt|;
name|scbp
operator|->
name|flags
operator|=
name|SCB_ACTIVE
expr_stmt|;
name|scbp
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"sea%d: Can't malloc SCB\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
goto|goto
name|gottit
goto|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|SEADEBUG12
name|printf
argument_list|(
literal|"(4"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOSLEEP
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|"(5"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sleep
argument_list|(
operator|&
name|sea
operator|->
name|free_scb
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|scbp
condition|)
block|{
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|"(6"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Get SCB from free list */
name|sea
operator|->
name|free_scb
operator|=
name|scbp
operator|->
name|next
expr_stmt|;
name|scbp
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|scbp
operator|->
name|flags
operator|=
name|SCB_ACTIVE
expr_stmt|;
block|}
name|gottit
label|:
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
return|return
operator|(
name|scbp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * sea_send_scb  *  * Try to send this command to the board. Because this board does not use any  * mailboxes, this routine simply adds the command to the queue held by the  * sea_data structure.  * A check is done to see if the command contains a REQUEST_SENSE command, and  * if so the command is put first in the queue, otherwise the command is added  * to the end of the queue. ?? Not correct ??  */
end_comment

begin_function
name|int
name|sea_send_scb
parameter_list|(
name|struct
name|sea_data
modifier|*
name|sea
parameter_list|,
name|struct
name|sea_scb
modifier|*
name|scb
parameter_list|)
block|{
name|struct
name|sea_scb
modifier|*
name|tmp
decl_stmt|;
name|int
name|oldpri
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|"+"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|scb
operator|->
name|xfer
operator|->
name|flags
operator|&
name|SCSI_NOSLEEP
operator|)
condition|)
block|{
name|oldpri
operator|=
name|splbio
argument_list|()
expr_stmt|;
block|}
comment|/* add to head of queue if queue empty or command is REQUEST_SENSE */
if|if
condition|(
operator|!
operator|(
name|sea
operator|->
name|issue_queue
operator|)
ifdef|#
directive|ifdef
name|SEA_SENSEFIRST
operator|||
operator|(
name|scb
operator|->
name|xfer
operator|->
name|cmd
operator|->
name|opcode
operator|==
operator|(
name|u_char
operator|)
name|REQUEST_SENSE
operator|)
endif|#
directive|endif
condition|)
block|{
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|"+2"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|scb
operator|->
name|next
operator|=
name|sea
operator|->
name|issue_queue
expr_stmt|;
name|sea
operator|->
name|issue_queue
operator|=
name|scb
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|"+3"
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|tmp
operator|=
name|sea
operator|->
name|issue_queue
init|;
name|tmp
operator|->
name|next
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|next
control|)
empty_stmt|;
name|tmp
operator|->
name|next
operator|=
name|scb
expr_stmt|;
name|scb
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* placed at the end of the queue */
block|}
comment|/* Try to do some work on the card */
if|if
condition|(
operator|!
name|main_running
condition|)
block|{
name|main_running
operator|=
literal|1
expr_stmt|;
name|sea_main
argument_list|()
expr_stmt|;
comment|/* main running is cleared in sea_main once it can't      * do more work, and sea_main exits with interrupts      * disabled      */
block|}
if|if
condition|(
operator|!
operator|(
name|scb
operator|->
name|xfer
operator|->
name|flags
operator|&
name|SCSI_NOSLEEP
operator|)
condition|)
block|{
name|splx
argument_list|(
name|oldpri
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
comment|/* No possible errors right now */
block|}
end_function

begin_comment
comment|/*  * sea_main(void)  *  * corroutine that runs as long as more work can be done on the seagate host  * adapter in a system. Both sea_scsi_cmd and sea_intr will try to start it in  * case it is not running.  */
end_comment

begin_function
specifier|static
name|void
name|sea_main
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|sea_data
modifier|*
name|sea
decl_stmt|;
comment|/* This time we look at all cards */
name|struct
name|sea_scb
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|int
name|done
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|oldpri
decl_stmt|;
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*    * This should not be run with interrupts disabled, but use the splx code    * instead    */
do|do
block|{
name|done
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|sea
operator|=
name|seadata
index|[
name|unit
operator|=
literal|0
index|]
init|;
operator|(
name|unit
operator|<
name|NSEA
operator|)
operator|&&
name|seadata
index|[
name|unit
index|]
condition|;
name|sea
operator|=
name|seadata
index|[
operator|++
name|unit
index|]
control|)
block|{
name|oldpri
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|sea
operator|->
name|connected
condition|)
block|{
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|".2"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Search through the issue_queue for a command destined for a 	 * target that's not busy. 	 */
for|for
control|(
name|tmp
operator|=
name|sea
operator|->
name|issue_queue
operator|,
name|prev
operator|=
name|NULL
init|;
name|tmp
condition|;
name|prev
operator|=
name|tmp
operator|,
name|tmp
operator|=
name|tmp
operator|->
name|next
control|)
comment|/* When we find one, remove it from the issue queue. */
if|if
condition|(
operator|!
operator|(
name|sea
operator|->
name|busy
index|[
name|tmp
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
index|]
operator|&
operator|(
literal|1
operator|<<
name|tmp
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|tmp
operator|->
name|next
expr_stmt|;
else|else
name|sea
operator|->
name|issue_queue
operator|=
name|tmp
operator|->
name|next
expr_stmt|;
name|tmp
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* re-enable interrupts after finding one */
name|splx
argument_list|(
name|oldpri
argument_list|)
expr_stmt|;
comment|/* 	     * Attempt to establish an I_T_L nexus here. 	     * On success, sea->connected is set. 	     * On failure, we must add the command back to 	     * the issue queue so we can keep trying. 	     */
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|".3"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* REQUEST_SENSE commands are issued without tagged 	     * queueing, even on SCSI-II devices because the 	     * contingent alligence condition exists for the 	     * entire unit. 	     */
comment|/* First check that if any device has tried a reconnect while 	     * we have done other things with interrupts disabled 	     */
if|if
condition|(
operator|(
name|STATUS
operator|&
operator|(
name|STAT_SEL
operator||
name|STAT_IO
operator|)
operator|)
operator|==
operator|(
name|STAT_SEL
operator||
name|STAT_IO
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|".7"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sea_reselect
argument_list|(
name|sea
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|sea_select
argument_list|(
name|sea
argument_list|,
name|tmp
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SEADEBUG2
comment|/* printf("Select returned ok\n"); */
name|printf
argument_list|(
literal|".4"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
else|else
block|{
name|oldpri
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|tmp
operator|->
name|next
operator|=
name|sea
operator|->
name|issue_queue
expr_stmt|;
name|sea
operator|->
name|issue_queue
operator|=
name|tmp
expr_stmt|;
name|splx
argument_list|(
name|oldpri
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sea_main: select failed\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* if target/lun is not busy */
block|}
comment|/* if (!sea->connected) */
if|if
condition|(
name|sea
operator|->
name|connected
condition|)
block|{
comment|/* we are connected. Do the task */
name|splx
argument_list|(
name|oldpri
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SEADEBUG2
comment|/*	printf("sea_main: starting information transfer!\n"); */
name|printf
argument_list|(
literal|".5"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sea_information_transfer
argument_list|(
name|sea
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SEADEBUG2
comment|/*	printf("sea_main: sea->connected:%lx\n", sea->connected); */
name|printf
argument_list|(
literal|".6%lx "
argument_list|,
name|sea
operator|->
name|connected
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|done
operator|=
literal|0
expr_stmt|;
block|}
else|else
break|break;
block|}
comment|/* for instance */
block|}
do|while
condition|(
operator|!
name|done
condition|)
do|;
name|main_running
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sea_free_scb
parameter_list|(
name|unit
parameter_list|,
name|scb
parameter_list|,
name|flags
parameter_list|)
name|int
name|unit
decl_stmt|;
name|struct
name|sea_scb
modifier|*
name|scb
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|sea_data
modifier|*
name|sea
init|=
name|seadata
index|[
name|unit
index|]
decl_stmt|;
name|unsigned
name|int
name|opri
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|SEADEBUG2
comment|/*  printf("free_scb\n"); */
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|opri
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|scb
operator|->
name|next
operator|=
name|sea
operator|->
name|free_scb
expr_stmt|;
name|sea
operator|->
name|free_scb
operator|=
name|scb
expr_stmt|;
name|scb
operator|->
name|flags
operator|=
name|SCB_FREE
expr_stmt|;
comment|/*    * If there were none, wake anybody waiting for one to come free,    * starting with queued entries.    */
if|if
condition|(
operator|!
name|scb
operator|->
name|next
condition|)
block|{
ifdef|#
directive|ifdef
name|SEADEBUG2
comment|/*  	printf("free_scb waking up sleep\n"); */
name|printf
argument_list|(
literal|")2"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SEA_FREEBSD11
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|sea
operator|->
name|free_scb
argument_list|)
expr_stmt|;
else|#
directive|else
name|wakeup
argument_list|(
operator|&
name|sea
operator|->
name|free_scb
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SEA_FREEBSD11
end_ifdef

begin_decl_stmt
name|void
name|sea_timeout
argument_list|(
name|caddr_t
name|arg1
argument_list|,
name|int
name|arg2
argument_list|)
else|#
directive|else
name|void
name|sea_timeout
argument_list|(
expr|struct
name|sea_scb
operator|*
name|scb
argument_list|)
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|SEA_FREEBSD11
name|struct
name|sea_scb
modifier|*
name|scb
init|=
operator|(
expr|struct
name|sea_scb
operator|*
operator|)
name|arg1
decl_stmt|;
endif|#
directive|endif
name|int
name|unit
decl_stmt|;
name|struct
name|sea_data
modifier|*
name|sea
decl_stmt|;
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|SEADEBUG2
comment|/*  printf("sea_timeout called\n"); */
name|printf
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|unit
operator|=
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|adapter_unit
expr_stmt|;
name|sea
operator|=
name|seadata
index|[
name|unit
index|]
expr_stmt|;
ifndef|#
directive|ifndef
name|SEADEBUG
comment|/* print message only if not waiting unless debug */
if|if
condition|(
operator|!
operator|(
name|scb
operator|->
name|xfer
operator|->
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
endif|#
directive|endif
name|printf
argument_list|(
literal|"sea%d:%d:%d (%s%d) timed out "
argument_list|,
name|unit
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|device
operator|->
name|name
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|dev_unit
argument_list|)
expr_stmt|;
comment|/*    * If it has been through before, then    * a previous abort has failed, don't    * try abort again    */
if|if
condition|(
comment|/* (sea_abort(unit, scb) != 1) ||*/
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ABORTED
operator|)
condition|)
block|{
comment|/*      * abort timed out      */
ifdef|#
directive|ifdef
name|SEADEBUG2
comment|/*  	printf("sea%d: Abort Operation has timed out\n", unit); */
name|printf
argument_list|(
literal|":2"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|scb
operator|->
name|xfer
operator|->
name|retries
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_ABORTED
expr_stmt|;
name|sea_done
argument_list|(
name|unit
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|SEADEBUG2
comment|/* 	printf("sea%d: Try to abort\n", unit); */
name|printf
argument_list|(
literal|":3"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sea_abort
argument_list|(
name|unit
argument_list|,
name|scb
argument_list|)
expr_stmt|;
comment|/* 	sea_send_scb(sea, ~SCSI_NOMASK, SEA_SCB_ABORT, scb); */
comment|/* 2 seconds for the abort */
ifdef|#
directive|ifdef
name|SEA_FREEBSD11
name|timeout
argument_list|(
name|sea_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
else|#
directive|else
name|timeout
argument_list|(
name|sea_timeout
argument_list|,
name|scb
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|scb
operator|->
name|flags
operator||=
operator|(
name|SCB_ABORTED
operator||
name|SCB_TIMECHK
operator|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
name|int
name|sea_reselect
parameter_list|(
name|sea
parameter_list|)
name|struct
name|sea_data
modifier|*
name|sea
decl_stmt|;
block|{
name|unsigned
name|char
name|target_mask
decl_stmt|;
name|long
name|l
decl_stmt|;
name|unsigned
name|char
name|lun
decl_stmt|,
name|phase
decl_stmt|;
name|unsigned
name|char
name|msg
index|[
literal|3
index|]
decl_stmt|;
name|int32
name|len
decl_stmt|;
name|u_char
modifier|*
name|data
decl_stmt|;
name|struct
name|sea_scb
modifier|*
name|tmp
init|=
literal|0
decl_stmt|,
modifier|*
name|prev
init|=
literal|0
decl_stmt|;
name|int
name|abort
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|SEADEBUG2
comment|/*  printf("sea_reselect called\n"); */
name|printf
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
operator|(
name|target_mask
operator|=
name|STATUS
operator|)
operator|&
name|STAT_SEL
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"sea: wrong state 0x%x\n"
argument_list|,
name|target_mask
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* wait for a device to win the reselection phase */
comment|/* signals this by asserting the I/O signal */
for|for
control|(
name|l
operator|=
literal|10
init|;
name|l
operator|&&
operator|(
name|STATUS
operator|&
operator|(
name|STAT_SEL
operator||
name|STAT_IO
operator||
name|STAT_BSY
operator|)
operator|)
operator|!=
operator|(
name|STAT_SEL
operator||
name|STAT_IO
operator||
literal|0
operator|)
condition|;
name|l
operator|--
control|)
empty_stmt|;
comment|/* !! Check for timeout here */
comment|/* the data bus contains original initiator id ORed with target id */
name|target_mask
operator|=
name|DATA
expr_stmt|;
comment|/* see that we really are the initiator */
if|if
condition|(
operator|!
operator|(
name|target_mask
operator|&
operator|(
operator|(
name|sea
operator|->
name|ctrl_type
operator|==
name|SEAGATE
operator|)
condition|?
literal|0x80
else|:
literal|0x40
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"sea: polled reselection was not for me: %x\n"
argument_list|,
name|target_mask
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* find target who won */
name|target_mask
operator|&=
operator|(
operator|(
name|sea
operator|->
name|ctrl_type
operator|==
name|SEAGATE
operator|)
condition|?
operator|~
literal|0x80
else|:
operator|~
literal|0x40
operator|)
expr_stmt|;
comment|/* host responds by asserting the BSY signal */
name|CONTROL
operator|=
operator|(
name|BASE_CMD
operator||
name|CMD_DRVR_ENABLE
operator||
name|CMD_BSY
operator|)
expr_stmt|;
comment|/* target should respond by deasserting the SEL signal */
for|for
control|(
name|l
operator|=
literal|50000
init|;
name|l
operator|&&
operator|(
name|STATUS
operator|&
name|STAT_SEL
operator|)
condition|;
name|l
operator|++
control|)
empty_stmt|;
comment|/* remove the busy status */
name|CONTROL
operator|=
operator|(
name|BASE_CMD
operator||
name|CMD_DRVR_ENABLE
operator|)
expr_stmt|;
comment|/* we are connected. Now we wait for the MSGIN condition */
for|for
control|(
name|l
operator|=
literal|50000
init|;
name|l
operator|&&
operator|!
operator|(
name|STATUS
operator|&
name|STAT_REQ
operator|)
condition|;
name|l
operator|--
control|)
empty_stmt|;
comment|/* !! Add timeout check here */
comment|/* hope we get an IDENTIFY message */
name|len
operator|=
literal|3
expr_stmt|;
name|data
operator|=
name|msg
expr_stmt|;
name|phase
operator|=
name|REQ_MSGIN
expr_stmt|;
name|sea_transfer_pio
argument_list|(
name|sea
argument_list|,
operator|&
name|phase
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|msg
index|[
literal|0
index|]
operator|&
literal|0x80
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"sea: Expecting IDENTIFY message, got 0x%x\n"
argument_list|,
name|msg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|abort
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|lun
operator|=
operator|(
name|msg
index|[
literal|0
index|]
operator|&
literal|0x07
operator|)
expr_stmt|;
comment|/*      * Find the command corresponding to the I_T_L or I_T_L_Q nexus we      * just restablished, and remove it from the disconnected queue.      */
for|for
control|(
name|tmp
operator|=
name|sea
operator|->
name|disconnected_queue
operator|,
name|prev
operator|=
name|NULL
init|;
name|tmp
condition|;
name|prev
operator|=
name|tmp
operator|,
name|tmp
operator|=
name|tmp
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|target_mask
operator|==
operator|(
literal|1
operator|<<
name|tmp
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
operator|)
operator|)
operator|&&
operator|(
name|lun
operator|==
name|tmp
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
operator|)
condition|)
block|{
if|if
condition|(
name|prev
condition|)
block|{
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|"}2"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|prev
operator|->
name|next
operator|=
name|tmp
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|"}3"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sea
operator|->
name|disconnected_queue
operator|=
name|tmp
operator|->
name|next
expr_stmt|;
block|}
name|tmp
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|tmp
condition|)
block|{
name|printf
argument_list|(
literal|"sea: warning : target %02x lun %d not in disconnect_queue\n"
argument_list|,
name|target_mask
argument_list|,
name|lun
argument_list|)
expr_stmt|;
comment|/*        * Since we have an established nexus that we can't do anything with,        * we must abort it.        */
name|abort
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|abort
condition|)
block|{
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|"}4"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|msg
index|[
literal|0
index|]
operator|=
name|MSG_ABORT
expr_stmt|;
name|len
operator|=
literal|1
expr_stmt|;
name|data
operator|=
name|msg
expr_stmt|;
name|phase
operator|=
name|REQ_MSGOUT
expr_stmt|;
name|CONTROL
operator|=
operator|(
name|BASE_CMD
operator||
name|CMD_ATTN
operator|)
expr_stmt|;
name|sea_transfer_pio
argument_list|(
name|sea
argument_list|,
operator|&
name|phase
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|"}5"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sea
operator|->
name|connected
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* return value not used yet */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Transfer data in given phase using polled I/O */
end_comment

begin_function
name|int
name|sea_transfer_pio
parameter_list|(
name|struct
name|sea_data
modifier|*
name|sea
parameter_list|,
name|u_char
modifier|*
name|phase
parameter_list|,
name|int32
modifier|*
name|count
parameter_list|,
name|u_char
modifier|*
modifier|*
name|data
parameter_list|)
block|{
specifier|register
name|unsigned
name|char
name|p
init|=
operator|*
name|phase
decl_stmt|,
name|tmp
decl_stmt|;
specifier|register
name|int
name|c
init|=
operator|*
name|count
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|d
init|=
operator|*
name|data
decl_stmt|;
name|unsigned
name|long
name|int
name|timeout
decl_stmt|;
if|#
directive|if
name|SEADEBUG2
comment|/*  printf("sea_transfer_pio called: len:%x\n",c); */
name|printf
argument_list|(
literal|"-1 %x %x"
argument_list|,
name|c
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
do|do
block|{
comment|/* wait for assertion of REQ, after which the phase bits will be valid */
for|for
control|(
name|timeout
operator|=
literal|0
init|;
name|timeout
operator|<
literal|5000000L
condition|;
name|timeout
operator|++
control|)
if|if
condition|(
operator|(
name|tmp
operator|=
name|STATUS
operator|)
operator|&
name|STAT_REQ
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|tmp
operator|&
name|STAT_REQ
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"sea_transfer_pio: timeout waiting for STAT_REQ\n"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* check for phase mismatch */
comment|/* Reached if the target decides that it has finished the transfer */
if|if
condition|(
operator|(
name|tmp
operator|&
name|REQ_MASK
operator|)
operator|!=
name|p
condition|)
block|{
ifdef|#
directive|ifdef
name|SEADEBUG1
comment|/*      printf("-2 %x", tmp); */
name|printf
argument_list|(
literal|"sea:pio phase mismatch:%x, want:%x, len:%x\n"
argument_list|,
name|tmp
argument_list|,
name|p
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
comment|/* Do actual transfer from SCSI bus to/from memory */
if|if
condition|(
operator|!
operator|(
name|p
operator|&
name|STAT_IO
operator|)
condition|)
name|DATA
operator|=
operator|*
name|d
expr_stmt|;
else|else
operator|*
name|d
operator|=
name|DATA
expr_stmt|;
ifdef|#
directive|ifdef
name|SEADEBUG15
name|printf
argument_list|(
literal|"-7%x"
argument_list|,
operator|*
name|d
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|++
name|d
expr_stmt|;
comment|/* The SCSI standard suggests that in MSGOUT phase, the initiator      * should drop ATN on the last byte of the message phase      * after REQ has been asserted for the handshake but before      * the initiator raises ACK.      * Don't know how to accomplish this on the ST01/02      */
comment|/* We don't mind right now. */
comment|/* The st01 code doesn't wait for STAT_REQ to be deasserted. Is this ok? */
comment|/*    for(timeout=0;timeout<200000L;timeout++)       if(!(STATUS& STAT_REQ))         break;     if(STATUS& STAT_REQ)       printf("timeout on wait for !STAT_REQ"); */
comment|/*      printf("*"); */
block|}
do|while
condition|(
operator|--
name|c
condition|)
do|;
operator|*
name|count
operator|=
name|c
expr_stmt|;
operator|*
name|data
operator|=
name|d
expr_stmt|;
name|tmp
operator|=
name|STATUS
expr_stmt|;
if|if
condition|(
name|tmp
operator|&
name|STAT_REQ
condition|)
block|{
if|#
directive|if
name|SEADEBUG2
name|printf
argument_list|(
literal|"-3%x"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|phase
operator|=
name|tmp
operator|&
name|REQ_MASK
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|SEADEBUG2
name|printf
argument_list|(
literal|"-4%x"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|phase
operator|=
name|REQ_UNKNOWN
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|c
operator|||
operator|(
operator|*
name|phase
operator|==
name|p
operator|)
condition|)
block|{
if|#
directive|if
name|SEADEBUG2
name|printf
argument_list|(
literal|"-5%x %x"
argument_list|,
name|c
argument_list|,
operator|*
name|phase
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
else|else
block|{
if|#
directive|if
name|SEADEBUG2
name|printf
argument_list|(
literal|"-6"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* sea_select  * establish I_T_L or I_T_L_Q nexus for new or existing command  * including ARBITRATION, SELECTION, and initial message out for IDENTIFY and  * queue messages.  * return -1 if selection could not execute for some reason, 0 if selection  * succeded or failed because the taget did not respond  */
end_comment

begin_function
name|int
name|sea_select
parameter_list|(
name|struct
name|sea_data
modifier|*
name|sea
parameter_list|,
name|struct
name|sea_scb
modifier|*
name|scb
parameter_list|)
block|{
name|unsigned
name|char
name|tmp
index|[
literal|3
index|]
decl_stmt|,
name|phase
decl_stmt|;
name|u_char
modifier|*
name|data
decl_stmt|;
name|int32
name|len
decl_stmt|;
name|unsigned
name|long
name|timeout
decl_stmt|;
ifdef|#
directive|ifdef
name|SEADEBUG2
comment|/*  printf("sea_select called\n"); */
name|printf
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CONTROL
operator|=
name|BASE_CMD
expr_stmt|;
name|DATA
operator|=
operator|(
operator|(
name|sea
operator|->
name|ctrl_type
operator|==
name|SEAGATE
operator|)
condition|?
literal|0x80
else|:
literal|0x40
operator|)
expr_stmt|;
name|CONTROL
operator|=
operator|(
name|BASE_CMD
operator|&
operator|~
name|CMD_INTR
operator|)
operator||
name|CMD_START_ARB
expr_stmt|;
comment|/* wait for arbitration to complete */
for|for
control|(
name|timeout
operator|=
literal|0
init|;
name|timeout
operator|<
literal|3000000L
condition|;
name|timeout
operator|++
control|)
block|{
if|if
condition|(
name|STATUS
operator|&
name|STAT_ARB_CMPL
condition|)
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|STATUS
operator|&
name|STAT_ARB_CMPL
operator|)
condition|)
block|{
if|if
condition|(
name|STATUS
operator|&
name|STAT_SEL
condition|)
block|{
name|printf
argument_list|(
literal|"sea: arbitration lost\n"
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_ERROR
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"sea: arbitration timeout.\n"
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_TIMEOUT
expr_stmt|;
block|}
name|CONTROL
operator|=
name|BASE_CMD
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|#
directive|if
name|SEADEBUG2
comment|/*  printf("after arbitration: STATUS=%x\n", STATUS); */
name|printf
argument_list|(
literal|"{2 %x"
argument_list|,
name|STATUS
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DATA
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
literal|1
operator|<<
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
operator|)
operator||
operator|(
operator|(
name|sea
operator|->
name|ctrl_type
operator|==
name|SEAGATE
operator|)
condition|?
literal|0x80
else|:
literal|0x40
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SEANOMSGS
name|CONTROL
operator|=
operator|(
name|BASE_CMD
operator|&
operator|(
operator|~
name|CMD_INTR
operator|)
operator|)
operator||
name|CMD_DRVR_ENABLE
operator||
name|CMD_SEL
expr_stmt|;
else|#
directive|else
name|CONTROL
operator|=
operator|(
name|BASE_CMD
operator|&
operator|(
operator|~
name|CMD_INTR
operator|)
operator|)
operator||
name|CMD_DRVR_ENABLE
operator||
name|CMD_SEL
operator||
name|CMD_ATTN
expr_stmt|;
endif|#
directive|endif
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* wait for a bsy from target */
for|for
control|(
name|timeout
operator|=
literal|0
init|;
name|timeout
operator|<
literal|2000000L
condition|;
name|timeout
operator|++
control|)
block|{
if|if
condition|(
name|STATUS
operator|&
name|STAT_BSY
condition|)
break|break;
block|}
if|#
directive|if
name|SEADEBUG2
comment|/*  printf("after wait for BSY: STATUS=%x,count=%lx\n", STATUS, timeout); */
name|printf
argument_list|(
literal|"{3 %x %x"
argument_list|,
name|STATUS
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|STATUS
operator|&
name|STAT_BSY
operator|)
condition|)
block|{
comment|/* should return some error to the higher level driver */
name|CONTROL
operator|=
name|BASE_CMD
expr_stmt|;
if|#
directive|if
name|SEADEBUG2
comment|/*  	printf("sea: target did not respond\n"); */
name|printf
argument_list|(
literal|"{4"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|scb
operator|->
name|flags
operator||=
name|SCB_TIMEOUT
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Try to make the target to take a message from us */
ifdef|#
directive|ifdef
name|SEANOMSGS
name|CONTROL
operator|=
operator|(
name|BASE_CMD
operator|&
operator|(
operator|~
name|CMD_INTR
operator|)
operator|)
operator||
name|CMD_DRVR_ENABLE
expr_stmt|;
else|#
directive|else
name|CONTROL
operator|=
operator|(
name|BASE_CMD
operator|&
operator|(
operator|~
name|CMD_INTR
operator|)
operator|)
operator||
name|CMD_DRVR_ENABLE
operator||
name|CMD_ATTN
expr_stmt|;
endif|#
directive|endif
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* should start a msg_out phase */
for|for
control|(
name|timeout
operator|=
literal|0
init|;
name|timeout
operator|<
literal|2000000L
condition|;
name|timeout
operator|++
control|)
block|{
if|if
condition|(
name|STATUS
operator|&
name|STAT_REQ
condition|)
break|break;
block|}
name|CONTROL
operator|=
name|BASE_CMD
operator||
name|CMD_DRVR_ENABLE
expr_stmt|;
if|#
directive|if
name|SEADEBUG2
operator|||
name|SEADEBUG9
comment|/*  printf("after wait for STAT_REQ: STATUS=%x,count=%lx\n", STATUS, timeout);   printf("2:nd try after wait for STAT_REQ: STATUS=%x\n", STATUS); */
name|printf
argument_list|(
literal|"{5%x"
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|STATUS
operator|&
name|STAT_REQ
operator|)
condition|)
block|{
comment|/* This should not be taken as an error, but more like an unsupported      * feature!      * Should set a flag indicating that the target don't support messages, and      * continue without failure. (THIS IS NOT AN ERROR!)      */
if|#
directive|if
name|SEADEBUG
comment|/*    printf("{6"); */
name|printf
argument_list|(
literal|"sea: WARNING: target %x don't support messages?\n"
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|tmp
index|[
literal|0
index|]
operator|=
name|IDENTIFY
argument_list|(
literal|1
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
argument_list|)
expr_stmt|;
comment|/* allow disconnects */
name|len
operator|=
literal|1
expr_stmt|;
name|data
operator|=
name|tmp
expr_stmt|;
name|phase
operator|=
name|REQ_MSGOUT
expr_stmt|;
comment|/* Should do test on result of sea_transfer_pio */
if|#
directive|if
name|SEADEBUG2
comment|/*      printf("Trying a msg out phase\n"); */
name|printf
argument_list|(
literal|"{7"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sea_transfer_pio
argument_list|(
name|sea
argument_list|,
operator|&
name|phase
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|STATUS
operator|&
name|STAT_BSY
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"sea: after successful arbitrate: No STAT_BSY!\n"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|SEADEBUG2
name|printf
argument_list|(
literal|"{8"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sea
operator|->
name|connected
operator|=
name|scb
expr_stmt|;
name|sea
operator|->
name|busy
index|[
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
index|]
operator||=
operator|(
literal|1
operator|<<
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
operator|)
expr_stmt|;
comment|/* this assignment should depend on possibility to send a message to target */
name|CONTROL
operator|=
name|BASE_CMD
operator||
name|CMD_DRVR_ENABLE
expr_stmt|;
comment|/* reset pointer in command ??? */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* sea_abort    send an abort to the target    return 1 success, 0 on failure  */
end_comment

begin_function
name|int
name|sea_abort
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|sea_scb
modifier|*
name|scb
parameter_list|)
block|{
name|struct
name|sea_data
modifier|*
name|sea
init|=
name|seadata
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|sea_scb
modifier|*
name|tmp
decl_stmt|,
modifier|*
modifier|*
name|prev
decl_stmt|;
name|unsigned
name|char
name|msg
decl_stmt|,
name|phase
decl_stmt|,
modifier|*
name|msgptr
decl_stmt|;
name|int32
name|len
decl_stmt|;
name|int
name|oldpri
decl_stmt|;
ifdef|#
directive|ifdef
name|SEADEBUG2
comment|/*	printf("sea_abort called\n"); */
name|printf
argument_list|(
literal|"\\"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|oldpri
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* If the command hasn't been issued yet, we simply remove it from the    * issue queue    */
for|for
control|(
name|prev
operator|=
operator|(
expr|struct
name|sea_scb
operator|*
operator|*
operator|)
operator|&
operator|(
name|sea
operator|->
name|issue_queue
operator|)
operator|,
name|tmp
operator|=
name|sea
operator|->
name|issue_queue
init|;
name|tmp
condition|;
name|prev
operator|=
operator|(
expr|struct
name|sea_scb
operator|*
operator|*
operator|)
operator|&
operator|(
name|tmp
operator|->
name|next
operator|)
operator|,
name|tmp
operator|=
name|tmp
operator|->
name|next
control|)
if|if
condition|(
name|scb
operator|==
name|tmp
condition|)
block|{
operator|(
operator|*
name|prev
operator|)
operator|=
name|tmp
operator|->
name|next
expr_stmt|;
name|tmp
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* set some type of error result for this operation */
name|splx
argument_list|(
name|oldpri
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|"\\2"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
comment|/* If any commands are connected, we're going to fail the abort    * and let the high level SCSI driver retry at a later time or issue a    * reset    */
if|if
condition|(
name|sea
operator|->
name|connected
condition|)
block|{
name|splx
argument_list|(
name|oldpri
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SEADEBUG2
comment|/*		printf("sea:abort error connected\n"); */
name|printf
argument_list|(
literal|"\\3"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
comment|/* If the command is currently disconnected from the bus, and there are    * no connected commands, we reconnect the I_T_L or I_T_L_Q nexus    * associated with it, go into message out, and send an abort message.    */
for|for
control|(
name|tmp
operator|=
name|sea
operator|->
name|disconnected_queue
init|;
name|tmp
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|next
control|)
if|if
condition|(
name|scb
operator|==
name|tmp
condition|)
block|{
name|splx
argument_list|(
name|oldpri
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|"\\4"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sea_select
argument_list|(
name|sea
argument_list|,
name|scb
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|"\\5"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
name|msg
operator|=
name|MSG_ABORT
expr_stmt|;
name|msgptr
operator|=
operator|&
name|msg
expr_stmt|;
name|len
operator|=
literal|1
expr_stmt|;
name|phase
operator|=
name|REQ_MSGOUT
expr_stmt|;
name|CONTROL
operator|=
name|BASE_CMD
operator||
name|CMD_ATTN
expr_stmt|;
name|sea_transfer_pio
argument_list|(
name|sea
argument_list|,
operator|&
name|phase
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|msgptr
argument_list|)
expr_stmt|;
name|oldpri
operator|=
name|splbio
argument_list|()
expr_stmt|;
for|for
control|(
name|prev
operator|=
operator|(
expr|struct
name|sea_scb
operator|*
operator|*
operator|)
operator|&
operator|(
name|sea
operator|->
name|disconnected_queue
operator|)
operator|,
name|tmp
operator|=
name|sea
operator|->
name|disconnected_queue
init|;
name|tmp
condition|;
name|prev
operator|=
operator|(
expr|struct
name|sea_scb
operator|*
operator|*
operator|)
operator|&
operator|(
name|tmp
operator|->
name|next
operator|)
operator|,
name|tmp
operator|=
name|tmp
operator|->
name|next
control|)
if|if
condition|(
name|scb
operator|==
name|tmp
condition|)
block|{
operator|*
name|prev
operator|=
name|tmp
operator|->
name|next
expr_stmt|;
name|tmp
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* set some type of error result for the operation */
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|"\\6"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|splx
argument_list|(
name|oldpri
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* command not found in any queue, race condition in the code ? */
name|splx
argument_list|(
name|oldpri
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SEADEBUG2
comment|/*	printf("sea: WARNING: SCSI command probably completed successfully\n" 	       "              before abortion\n"); */
name|printf
argument_list|(
literal|"\\7"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|sea_done
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|sea_scb
modifier|*
name|scb
parameter_list|)
block|{
name|struct
name|sea_data
modifier|*
name|sea
init|=
name|seadata
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|scsi_xfer
modifier|*
name|xs
init|=
name|scb
operator|->
name|xfer
decl_stmt|;
ifdef|#
directive|ifdef
name|SEADEBUG2
comment|/*	printf("sea_done called\n"); */
name|printf
argument_list|(
literal|"&"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_TIMECHK
condition|)
block|{
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|"&2"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SEA_FREEBSD11
name|untimeout
argument_list|(
name|sea_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|)
expr_stmt|;
else|#
directive|else
name|untimeout
argument_list|(
name|sea_timeout
argument_list|,
name|scb
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|xs
operator|->
name|resid
operator|=
name|scb
operator|->
name|datalen
expr_stmt|;
comment|/* How much of the buffer was not touched */
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|==
name|SCB_ACTIVE
operator|)
operator|||
operator|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_ERR_OK
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SEADEBUG2
comment|/*		printf("sea_done:Report no err in xs\n"); */
name|printf
argument_list|(
literal|"&3"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*    xs->resid = 0; */
comment|/*		xs->error = 0; */
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|scb
operator|->
name|flags
operator|==
name|SCB_ACTIVE
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_TIMEOUT
operator|)
operator|||
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ABORTED
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|"&6"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xs
operator|->
name|error
operator|=
name|XS_TIMEOUT
expr_stmt|;
block|}
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ERROR
condition|)
block|{
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|"&7"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* !!! Add code to check for target status */
comment|/* say all error now */
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|"&4"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|xs
operator|->
name|flags
operator||=
name|ITSDONE
expr_stmt|;
name|sea_free_scb
argument_list|(
name|unit
argument_list|,
name|scb
argument_list|,
name|xs
operator|->
name|flags
argument_list|)
expr_stmt|;
name|scsi_done
argument_list|(
name|xs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SEADEBUG2
comment|/*	printf("Leaving sea_done\n"); */
name|printf
argument_list|(
literal|"&5"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* wait for completion of command in polled mode */
end_comment

begin_function
name|int
name|sea_poll
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|scsi_xfer
modifier|*
name|xs
parameter_list|,
name|struct
name|sea_scb
modifier|*
name|scb
parameter_list|)
block|{
name|int
name|count
init|=
literal|500
decl_stmt|;
comment|/* xs->timeout; */
name|int
name|oldpri
decl_stmt|;
ifdef|#
directive|ifdef
name|SEADEBUG2
comment|/*	printf("sea_poll called\n"); */
name|printf
argument_list|(
literal|"?"
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|count
condition|)
block|{
comment|/* try to do something */
name|oldpri
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|main_running
condition|)
block|{
name|main_running
operator|=
literal|1
expr_stmt|;
name|sea_main
argument_list|()
expr_stmt|;
comment|/* main_running is cleared in sea_main once it can't        * do more work, and sea_main exits with interrupts        * disabled        */
name|splx
argument_list|(
name|oldpri
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|splx
argument_list|(
name|oldpri
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xs
operator|->
name|flags
operator|&
name|ITSDONE
condition|)
block|{
break|break;
block|}
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|"?2 %x "
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/*	printf("sea_poll: count:%x\n",count); */
endif|#
directive|endif
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
comment|/* we timed out, so call the timeout handler manually,      * accounting for the fact that the clock is not running yet      * by taking out the clock queue entry it makes.      */
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|"?3"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SEA_FREEBSD11
name|sea_timeout
argument_list|(
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|sea_timeout
argument_list|(
name|scb
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* because we are polling, take out the timeout entry      * sea_timeout made      */
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|"?4"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SEA_FREEBSD11
name|untimeout
argument_list|(
name|sea_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|)
expr_stmt|;
else|#
directive|else
name|untimeout
argument_list|(
name|sea_timeout
argument_list|,
name|scb
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|count
operator|=
literal|50
expr_stmt|;
while|while
condition|(
name|count
condition|)
block|{
comment|/* once again, wait for the int bit */
name|oldpri
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|main_running
condition|)
block|{
name|main_running
operator|=
literal|1
expr_stmt|;
name|sea_main
argument_list|()
expr_stmt|;
comment|/* main_running is cleared by sea_main once it can't 	 * do more work, and sea_main exits with interrupts 	 * disabled 	 */
name|splx
argument_list|(
name|oldpri
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|splx
argument_list|(
name|oldpri
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xs
operator|->
name|flags
operator|&
name|ITSDONE
condition|)
block|{
break|break;
block|}
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
comment|/* we timed out again... This is bad. Notice that        * this time there is no clock queue entry to remove        */
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|"?5"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SEA_FREEBSD11
name|sea_timeout
argument_list|(
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|sea_timeout
argument_list|(
name|scb
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
ifdef|#
directive|ifdef
name|SEADEBUG2
comment|/*  printf("sea_poll: xs->error:%x\n",xs->error); */
name|printf
argument_list|(
literal|"?6%x"
argument_list|,
name|xs
operator|->
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|xs
operator|->
name|error
condition|)
block|{
ifdef|#
directive|ifdef
name|SEADEBUG2
comment|/*    printf("done return error\n"); */
name|printf
argument_list|(
literal|"?7"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|HAD_ERROR
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|SEADEBUG2
comment|/*  printf("done return complete\n"); */
name|printf
argument_list|(
literal|"?8"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|COMPLETE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * sea_information_transfer  * Do the transfer. We know we are connected. Update the flags,  * call sea_done when task accomplished. Dialog controlled by the  * target  */
end_comment

begin_function
specifier|static
name|void
name|sea_information_transfer
parameter_list|(
name|struct
name|sea_data
modifier|*
name|sea
parameter_list|)
block|{
name|long
name|int
name|timeout
decl_stmt|;
name|int
name|unit
init|=
name|sea
operator|->
name|sc_link
operator|.
name|adapter_unit
decl_stmt|;
name|unsigned
name|char
name|msgout
init|=
name|MSG_NOP
decl_stmt|;
name|int32
name|len
decl_stmt|;
name|int
name|oldpri
decl_stmt|;
name|u_char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|char
name|phase
decl_stmt|,
name|tmp
decl_stmt|,
name|old_phase
init|=
name|REQ_UNKNOWN
decl_stmt|;
name|struct
name|sea_scb
modifier|*
name|scb
init|=
name|sea
operator|->
name|connected
decl_stmt|;
name|int
name|loop
decl_stmt|;
if|#
directive|if
name|SEADEBUG2
comment|/*	printf("sea_information_transfer called\n"); */
name|printf
argument_list|(
literal|"!"
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|timeout
operator|=
literal|0
init|;
name|timeout
operator|<
literal|10000000L
condition|;
name|timeout
operator|++
control|)
block|{
name|tmp
operator|=
name|STATUS
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tmp
operator|&
name|STAT_BSY
operator|)
condition|)
block|{
comment|/*      for(loop=0;loop< 20 ; loop++) {         if((tmp=STATUS)& STAT_BSY)           break;       } */
ifndef|#
directive|ifndef
name|SEADEBUG8
if|if
condition|(
operator|!
operator|(
name|tmp
operator|&
name|STAT_BSY
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"sea: !STAT_BSY unit in data transfer!\n"
argument_list|)
expr_stmt|;
name|oldpri
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|sea
operator|->
name|connected
operator|=
name|NULL
expr_stmt|;
name|scb
operator|->
name|flags
operator|=
name|SCB_ERROR
expr_stmt|;
name|splx
argument_list|(
name|oldpri
argument_list|)
expr_stmt|;
name|sea_done
argument_list|(
name|unit
argument_list|,
name|scb
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
block|}
comment|/* we only have a valid SCSI phase when REQ is asserted */
if|if
condition|(
name|tmp
operator|&
name|STAT_REQ
condition|)
block|{
name|phase
operator|=
operator|(
name|tmp
operator|&
name|REQ_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|phase
operator|!=
name|old_phase
condition|)
block|{
name|old_phase
operator|=
name|phase
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SEADEBUG7
name|printf
argument_list|(
literal|"!2%x"
argument_list|,
name|phase
argument_list|)
expr_stmt|;
for|for
control|(
name|loop
operator|=
literal|0
init|;
name|loop
operator|<
literal|20
condition|;
name|loop
operator|++
control|)
block|{
name|phase
operator|=
name|STATUS
expr_stmt|;
name|printf
argument_list|(
literal|"!6%x"
argument_list|,
name|phase
argument_list|)
expr_stmt|;
name|phase
operator|=
name|phase
operator|&
name|REQ_MASK
expr_stmt|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|phase
condition|)
block|{
case|case
name|REQ_DATAOUT
case|:
ifdef|#
directive|ifdef
name|SEA_NODATAOUT
name|printf
argument_list|(
literal|"sea: SEA_NODATAOUT set, attempted DATAOUT aborted\n"
argument_list|)
expr_stmt|;
name|msgout
operator|=
name|MSG_ABORT
expr_stmt|;
name|CONTROL
operator|=
name|BASE_CMD
operator||
name|CMD_ATTN
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|REQ_DATAIN
case|:
comment|/*        data = scb->xfer->data;         len = scb->xfer->datalen; */
if|if
condition|(
operator|!
operator|(
name|scb
operator|->
name|data
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"no data address!\n"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SEA_BLINDTRANSFER
if|if
condition|(
name|scb
operator|->
name|datalen
operator|&&
operator|!
operator|(
name|scb
operator|->
name|datalen
operator|%
name|BLOCK_SIZE
operator|)
condition|)
block|{
while|while
condition|(
name|scb
operator|->
name|datalen
condition|)
block|{
for|for
control|(
name|timeout
operator|=
literal|0
init|;
name|timeout
operator|<
literal|5000000L
condition|;
name|timeout
operator|++
control|)
if|if
condition|(
operator|(
name|tmp
operator|=
name|STATUS
operator|)
operator|&
name|STAT_REQ
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|tmp
operator|&
name|STAT_REQ
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"sea_transfer_pio: timeout waiting for STAT_REQ\n"
argument_list|)
expr_stmt|;
comment|/* getchar(); */
block|}
if|if
condition|(
operator|(
name|tmp
operator|&
name|REQ_MASK
operator|)
operator|!=
name|phase
condition|)
block|{
ifdef|#
directive|ifdef
name|SEADEBUG1
name|printf
argument_list|(
literal|"sea:infotransfer phase mismatch:%x, want:%x, len:%x\n"
argument_list|,
name|tmp
argument_list|,
name|phase
argument_list|,
name|scb
operator|->
name|datalen
argument_list|)
expr_stmt|;
comment|/* getchar(); */
endif|#
directive|endif
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|phase
operator|&
name|STAT_IO
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SEA_ASSEMBLER
asm|asm(" 		shr $2, %%ecx; 		cld; 		rep; 		movsl; " : : 		"D" (sea->st0x_dr), "S" (scb->data), "c" (BLOCK_SIZE) : 		"cx", "si", "di" );
name|scb
operator|->
name|data
operator|+=
name|BLOCK_SIZE
expr_stmt|;
else|#
directive|else
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|BLOCK_SIZE
condition|;
name|count
operator|++
control|)
block|{
name|DATA
operator|=
operator|*
operator|(
name|scb
operator|->
name|data
operator|)
expr_stmt|;
name|scb
operator|->
name|data
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|SEA_ASSEMBLER
asm|asm(" 		shr $2, %%ecx; 		cld; 		rep; 		movsl; " : : 		"S" (sea->st0x_dr), "D" (scb->data), "c" (BLOCK_SIZE) : 		"cx", "si", "di" );
name|scb
operator|->
name|data
operator|+=
name|BLOCK_SIZE
expr_stmt|;
else|#
directive|else
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|BLOCK_SIZE
condition|;
name|count
operator|++
control|)
block|{
operator|*
name|scb
operator|->
name|data
operator|=
name|DATA
expr_stmt|;
name|scb
operator|->
name|data
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|scb
operator|->
name|datalen
operator|-=
name|BLOCK_SIZE
expr_stmt|;
block|}
block|}
comment|/* save current position into the command structure */
comment|/*	scb->xfer->data = data; 	scb->xfer->datalen = len; */
endif|#
directive|endif
name|sea_transfer_pio
argument_list|(
name|sea
argument_list|,
operator|&
name|phase
argument_list|,
operator|&
operator|(
name|scb
operator|->
name|datalen
operator|)
argument_list|,
operator|&
operator|(
name|scb
operator|->
name|data
operator|)
argument_list|)
expr_stmt|;
comment|/*        scb->xfer->data = data; 	scb->xfer->datalen = len; */
break|break;
case|case
name|REQ_MSGIN
case|:
comment|/* don't handle multi-byte messages here, because they 	 * should not be present here 	 */
name|len
operator|=
literal|1
expr_stmt|;
name|data
operator|=
operator|&
name|tmp
expr_stmt|;
name|sea_transfer_pio
argument_list|(
name|sea
argument_list|,
operator|&
name|phase
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
comment|/* scb->MessageIn = tmp; */
switch|switch
condition|(
name|tmp
condition|)
block|{
case|case
name|MSG_ABORT
case|:
name|scb
operator|->
name|flags
operator|=
name|SCB_ABORTED
expr_stmt|;
name|printf
argument_list|(
literal|"sea:Command aborted by target\n"
argument_list|)
expr_stmt|;
name|CONTROL
operator|=
name|BASE_CMD
expr_stmt|;
name|sea_done
argument_list|(
name|unit
argument_list|,
name|scb
argument_list|)
expr_stmt|;
return|return;
case|case
name|MSG_COMMAND_COMPLETE
case|:
name|oldpri
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|sea
operator|->
name|connected
operator|=
name|NULL
expr_stmt|;
name|splx
argument_list|(
name|oldpri
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SEADEBUG2
name|printf
argument_list|(
literal|"!3"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sea
operator|->
name|busy
index|[
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
operator|)
expr_stmt|;
name|CONTROL
operator|=
name|BASE_CMD
expr_stmt|;
name|sea_done
argument_list|(
name|unit
argument_list|,
name|scb
argument_list|)
expr_stmt|;
return|return;
case|case
name|MSG_MESSAGE_REJECT
case|:
comment|/*	printf("sea: message_reject recieved\n"); */
name|printf
argument_list|(
literal|"!4"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_DISCONNECT
case|:
name|oldpri
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|scb
operator|->
name|next
operator|=
name|sea
operator|->
name|disconnected_queue
expr_stmt|;
name|sea
operator|->
name|disconnected_queue
operator|=
name|scb
expr_stmt|;
name|sea
operator|->
name|connected
operator|=
name|NULL
expr_stmt|;
name|CONTROL
operator|=
name|BASE_CMD
expr_stmt|;
name|splx
argument_list|(
name|oldpri
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SEADEBUG2
comment|/*					printf("msg_disconnect\n"); */
name|printf
argument_list|(
literal|"!5"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
comment|/* save/restore of pointers are ignored */
case|case
name|MSG_SAVE_POINTERS
case|:
case|case
name|MSG_RESTORE_POINTERS
case|:
if|#
directive|if
name|SEADEBUG2
name|printf
argument_list|(
literal|"sea: rec save/restore ptrs\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
comment|/* this should be handled in the pio data transfer phase, as the 	   * ATN should be raised before ACK goes false when rejecting a message 	   */
ifdef|#
directive|ifdef
name|SEADEBUG
name|printf
argument_list|(
literal|"sea: Unknown message in:%x\n"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
comment|/* switch (tmp) */
break|break;
case|case
name|REQ_MSGOUT
case|:
name|len
operator|=
literal|1
expr_stmt|;
name|data
operator|=
operator|&
name|msgout
expr_stmt|;
comment|/* sea->last_message = msgout; */
name|sea_transfer_pio
argument_list|(
name|sea
argument_list|,
operator|&
name|phase
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|msgout
operator|==
name|MSG_ABORT
condition|)
block|{
name|printf
argument_list|(
literal|"sea: sent message abort to target\n"
argument_list|)
expr_stmt|;
name|oldpri
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|sea
operator|->
name|busy
index|[
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
operator|)
expr_stmt|;
name|sea
operator|->
name|connected
operator|=
name|NULL
expr_stmt|;
name|scb
operator|->
name|flags
operator|=
name|SCB_ABORTED
expr_stmt|;
name|splx
argument_list|(
name|oldpri
argument_list|)
expr_stmt|;
comment|/* enable interrupt from scsi */
name|sea_done
argument_list|(
name|unit
argument_list|,
name|scb
argument_list|)
expr_stmt|;
return|return;
block|}
name|msgout
operator|=
name|MSG_NOP
expr_stmt|;
break|break;
case|case
name|REQ_CMDOUT
case|:
name|len
operator|=
name|scb
operator|->
name|xfer
operator|->
name|cmdlen
expr_stmt|;
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|scb
operator|->
name|xfer
operator|->
name|cmd
expr_stmt|;
name|sea_transfer_pio
argument_list|(
name|sea
argument_list|,
operator|&
name|phase
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|REQ_STATIN
case|:
name|len
operator|=
literal|1
expr_stmt|;
name|data
operator|=
operator|&
name|tmp
expr_stmt|;
name|sea_transfer_pio
argument_list|(
name|sea
argument_list|,
operator|&
name|phase
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|scb
operator|->
name|xfer
operator|->
name|status
operator|=
name|tmp
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"sea: unknown phase\n"
argument_list|)
expr_stmt|;
block|}
comment|/* switch (phase) */
block|}
comment|/* if (tmp& STAT_REQ) */
block|}
comment|/* for (...) */
comment|/* if we get here we have got a timeout!  */
name|printf
argument_list|(
literal|"sea: Timeout in data transfer\n"
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator|=
name|SCB_TIMEOUT
expr_stmt|;
comment|/* should I clear scsi-bus state? */
name|sea_done
argument_list|(
name|unit
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

