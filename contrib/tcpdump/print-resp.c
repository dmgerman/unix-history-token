begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2015 The TCPDUMP project  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE  * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  * Initial contribution by Andrew Darqui (andrew.darqui@gmail.com).  */
end_comment

begin_comment
comment|/* \summary: REdis Serialization Protocol (RESP) printer */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netdissect-stdinc.h>
end_include

begin_include
include|#
directive|include
file|"netdissect.h"
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"extract.h"
end_include

begin_decl_stmt
specifier|static
specifier|const
name|char
name|tstr
index|[]
init|=
literal|" [|RESP]"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * For information regarding RESP, see: http://redis.io/topics/protocol  */
end_comment

begin_define
define|#
directive|define
name|RESP_SIMPLE_STRING
value|'+'
end_define

begin_define
define|#
directive|define
name|RESP_ERROR
value|'-'
end_define

begin_define
define|#
directive|define
name|RESP_INTEGER
value|':'
end_define

begin_define
define|#
directive|define
name|RESP_BULK_STRING
value|'$'
end_define

begin_define
define|#
directive|define
name|RESP_ARRAY
value|'*'
end_define

begin_define
define|#
directive|define
name|resp_print_empty
parameter_list|(
name|ndo
parameter_list|)
value|ND_PRINT((ndo, " empty"))
end_define

begin_define
define|#
directive|define
name|resp_print_null
parameter_list|(
name|ndo
parameter_list|)
value|ND_PRINT((ndo, " null"))
end_define

begin_define
define|#
directive|define
name|resp_print_length_too_large
parameter_list|(
name|ndo
parameter_list|)
value|ND_PRINT((ndo, " length too large"))
end_define

begin_define
define|#
directive|define
name|resp_print_length_negative
parameter_list|(
name|ndo
parameter_list|)
value|ND_PRINT((ndo, " length negative and not -1"))
end_define

begin_define
define|#
directive|define
name|resp_print_invalid
parameter_list|(
name|ndo
parameter_list|)
value|ND_PRINT((ndo, " invalid"))
end_define

begin_function_decl
name|void
name|resp_print
parameter_list|(
name|netdissect_options
modifier|*
parameter_list|,
specifier|const
name|u_char
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|resp_parse
parameter_list|(
name|netdissect_options
modifier|*
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|resp_print_string_error_integer
parameter_list|(
name|netdissect_options
modifier|*
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|resp_print_simple_string
parameter_list|(
name|netdissect_options
modifier|*
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|resp_print_integer
parameter_list|(
name|netdissect_options
modifier|*
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|resp_print_error
parameter_list|(
name|netdissect_options
modifier|*
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|resp_print_bulk_string
parameter_list|(
name|netdissect_options
modifier|*
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|resp_print_bulk_array
parameter_list|(
name|netdissect_options
modifier|*
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|resp_print_inline
parameter_list|(
name|netdissect_options
modifier|*
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|resp_get_length
parameter_list|(
name|netdissect_options
modifier|*
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|u_char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|LCHECK2
parameter_list|(
name|_tot_len
parameter_list|,
name|_len
parameter_list|)
define|\
value|{                           \         if (_tot_len< _len)    \             goto trunc;         \     }
end_define

begin_define
define|#
directive|define
name|LCHECK
parameter_list|(
name|_tot_len
parameter_list|)
value|LCHECK2(_tot_len, 1)
end_define

begin_comment
comment|/*  * FIND_CRLF:  * Attempts to move our 'ptr' forward until a \r\n is found,  * while also making sure we don't exceed the buffer '_len'  * or go past the end of the captured data.  * If we exceed or go past the end of the captured data,  * jump to trunc.  */
end_comment

begin_define
define|#
directive|define
name|FIND_CRLF
parameter_list|(
name|_ptr
parameter_list|,
name|_len
parameter_list|)
define|\
value|for (;;) {                                  \         LCHECK2(_len, 2);                       \         ND_TCHECK2(*_ptr, 2);                   \         if (*_ptr == '\r'&& *(_ptr+1) == '\n') \             break;                              \         _ptr++;                                 \         _len--;                                 \     }
end_define

begin_comment
comment|/*  * CONSUME_CRLF  * Consume a CRLF that we've just found.  */
end_comment

begin_define
define|#
directive|define
name|CONSUME_CRLF
parameter_list|(
name|_ptr
parameter_list|,
name|_len
parameter_list|)
define|\
value|_ptr += 2;                   \     _len -= 2;
end_define

begin_comment
comment|/*  * FIND_CR_OR_LF  * Attempts to move our '_ptr' forward until a \r or \n is found,  * while also making sure we don't exceed the buffer '_len'  * or go past the end of the captured data.  * If we exceed or go past the end of the captured data,  * jump to trunc.  */
end_comment

begin_define
define|#
directive|define
name|FIND_CR_OR_LF
parameter_list|(
name|_ptr
parameter_list|,
name|_len
parameter_list|)
define|\
value|for (;;) {                              \         LCHECK(_len);                       \         ND_TCHECK(*_ptr);                   \         if (*_ptr == '\r' || *_ptr == '\n') \             break;                          \         _ptr++;                             \         _len--;                             \     }
end_define

begin_comment
comment|/*  * CONSUME_CR_OR_LF  * Consume all consecutive \r and \n bytes.  * If we exceed '_len' or go past the end of the captured data,  * jump to trunc.  */
end_comment

begin_define
define|#
directive|define
name|CONSUME_CR_OR_LF
parameter_list|(
name|_ptr
parameter_list|,
name|_len
parameter_list|)
define|\
value|{                                            \         int _found_cr_or_lf = 0;                 \         for (;;) {                               \
comment|/*                                   \              * Have we hit the end of data?      \              */
value|\             if (_len == 0 || !ND_TTEST(*_ptr)) { \
comment|/*                               \                  * Yes.  Have we seen a \r       \                  * or \n?                        \                  */
value|\                 if (_found_cr_or_lf) {           \
comment|/*                           \                      * Yes.  Just stop.          \                      */
value|\                     break;                       \                 }                                \
comment|/*                               \                  * No.  We ran out of packet.    \                  */
value|\                 goto trunc;                      \             }                                    \             if (*_ptr != '\r'&& *_ptr != '\n')  \                 break;                           \             _found_cr_or_lf = 1;                 \             _ptr++;                              \             _len--;                              \         }                                        \     }
end_define

begin_comment
comment|/*  * SKIP_OPCODE  * Skip over the opcode character.  * The opcode has already been fetched, so we know it's there, and don't  * need to do any checks.  */
end_comment

begin_define
define|#
directive|define
name|SKIP_OPCODE
parameter_list|(
name|_ptr
parameter_list|,
name|_tot_len
parameter_list|)
define|\
value|_ptr++;                         \     _tot_len--;
end_define

begin_comment
comment|/*  * GET_LENGTH  * Get a bulk string or array length.  */
end_comment

begin_define
define|#
directive|define
name|GET_LENGTH
parameter_list|(
name|_ndo
parameter_list|,
name|_tot_len
parameter_list|,
name|_ptr
parameter_list|,
name|_len
parameter_list|)
define|\
value|{                                                         \         const u_char *_endp;                                  \         _len = resp_get_length(_ndo, _ptr, _tot_len,&_endp); \         _tot_len -= (_endp - _ptr);                           \         _ptr = _endp;                                         \     }
end_define

begin_comment
comment|/*  * TEST_RET_LEN  * If ret_len is< 0, jump to the trunc tag which returns (-1)  * and 'bubbles up' to printing tstr. Otherwise, return ret_len.  */
end_comment

begin_define
define|#
directive|define
name|TEST_RET_LEN
parameter_list|(
name|rl
parameter_list|)
define|\
value|if (rl< 0) { goto trunc; } else { return rl; }
end_define

begin_comment
comment|/*  * TEST_RET_LEN_NORETURN  * If ret_len is< 0, jump to the trunc tag which returns (-1)  * and 'bubbles up' to printing tstr. Otherwise, continue onward.  */
end_comment

begin_define
define|#
directive|define
name|TEST_RET_LEN_NORETURN
parameter_list|(
name|rl
parameter_list|)
define|\
value|if (rl< 0) { goto trunc; }
end_define

begin_comment
comment|/*  * RESP_PRINT_SEGMENT  * Prints a segment in the form of: ' "<stuff>"\n"  * Assumes the data has already been verified as present.  */
end_comment

begin_define
define|#
directive|define
name|RESP_PRINT_SEGMENT
parameter_list|(
name|_ndo
parameter_list|,
name|_bp
parameter_list|,
name|_len
parameter_list|)
define|\
value|ND_PRINT((_ndo, " \""));                           \     if (fn_printn(_ndo, _bp, _len, _ndo->ndo_snapend)) \         goto trunc;                                    \     fn_print_char(_ndo, '"');
end_define

begin_function
name|void
name|resp_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|const
name|u_char
modifier|*
name|bp
parameter_list|,
name|u_int
name|length
parameter_list|)
block|{
name|int
name|ret_len
init|=
literal|0
decl_stmt|,
name|length_cur
init|=
name|length
decl_stmt|;
if|if
condition|(
operator|!
name|bp
operator|||
name|length
operator|<=
literal|0
condition|)
return|return;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|": RESP"
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|length_cur
operator|>
literal|0
condition|)
block|{
comment|/*          * This block supports redis pipelining.          * For example, multiple operations can be pipelined within the same string:          * "*2\r\n\$4\r\nINCR\r\n\$1\r\nz\r\n*2\r\n\$4\r\nINCR\r\n\$1\r\nz\r\n*2\r\n\$4\r\nINCR\r\n\$1\r\nz\r\n"          * or          * "PING\r\nPING\r\nPING\r\n"          * In order to handle this case, we must try and parse 'bp' until          * 'length' bytes have been processed or we reach a trunc condition.          */
name|ret_len
operator|=
name|resp_parse
argument_list|(
name|ndo
argument_list|,
name|bp
argument_list|,
name|length_cur
argument_list|)
expr_stmt|;
name|TEST_RET_LEN_NORETURN
argument_list|(
name|ret_len
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|ret_len
expr_stmt|;
name|length_cur
operator|-=
name|ret_len
expr_stmt|;
block|}
return|return;
name|trunc
label|:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s"
operator|,
name|tstr
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|resp_parse
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|bp
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|u_char
name|op
decl_stmt|;
name|int
name|ret_len
decl_stmt|;
name|LCHECK2
argument_list|(
name|length
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ND_TCHECK
argument_list|(
operator|*
name|bp
argument_list|)
expr_stmt|;
name|op
operator|=
operator|*
name|bp
expr_stmt|;
comment|/* bp now points to the op, so these routines must skip it */
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|RESP_SIMPLE_STRING
case|:
name|ret_len
operator|=
name|resp_print_simple_string
argument_list|(
name|ndo
argument_list|,
name|bp
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|RESP_INTEGER
case|:
name|ret_len
operator|=
name|resp_print_integer
argument_list|(
name|ndo
argument_list|,
name|bp
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|RESP_ERROR
case|:
name|ret_len
operator|=
name|resp_print_error
argument_list|(
name|ndo
argument_list|,
name|bp
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|RESP_BULK_STRING
case|:
name|ret_len
operator|=
name|resp_print_bulk_string
argument_list|(
name|ndo
argument_list|,
name|bp
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|RESP_ARRAY
case|:
name|ret_len
operator|=
name|resp_print_bulk_array
argument_list|(
name|ndo
argument_list|,
name|bp
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret_len
operator|=
name|resp_print_inline
argument_list|(
name|ndo
argument_list|,
name|bp
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*      * This gives up with a "truncated" indicator for all errors,      * including invalid packet errors; that's what we want, as      * we have to give up on further parsing in that case.      */
name|TEST_RET_LEN
argument_list|(
name|ret_len
argument_list|)
expr_stmt|;
name|trunc
label|:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|resp_print_simple_string
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|bp
parameter_list|,
name|int
name|length
parameter_list|)
block|{
return|return
name|resp_print_string_error_integer
argument_list|(
name|ndo
argument_list|,
name|bp
argument_list|,
name|length
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|resp_print_integer
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|bp
parameter_list|,
name|int
name|length
parameter_list|)
block|{
return|return
name|resp_print_string_error_integer
argument_list|(
name|ndo
argument_list|,
name|bp
argument_list|,
name|length
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|resp_print_error
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|bp
parameter_list|,
name|int
name|length
parameter_list|)
block|{
return|return
name|resp_print_string_error_integer
argument_list|(
name|ndo
argument_list|,
name|bp
argument_list|,
name|length
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|resp_print_string_error_integer
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|bp
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|length_cur
init|=
name|length
decl_stmt|,
name|len
decl_stmt|,
name|ret_len
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|bp_ptr
decl_stmt|;
comment|/* bp points to the op; skip it */
name|SKIP_OPCODE
argument_list|(
name|bp
argument_list|,
name|length_cur
argument_list|)
expr_stmt|;
name|bp_ptr
operator|=
name|bp
expr_stmt|;
comment|/*      * bp now prints past the (+-;) opcode, so it's pointing to the first      * character of the string (which could be numeric).      * +OK\r\n      * -ERR ...\r\n      * :02912309\r\n      *      * Find the \r\n with FIND_CRLF().      */
name|FIND_CRLF
argument_list|(
name|bp_ptr
argument_list|,
name|length_cur
argument_list|)
expr_stmt|;
comment|/*      * bp_ptr points to the \r\n, so bp_ptr - bp is the length of text      * preceding the \r\n.  That includes the opcode, so don't print      * that.      */
name|len
operator|=
operator|(
name|bp_ptr
operator|-
name|bp
operator|)
expr_stmt|;
name|RESP_PRINT_SEGMENT
argument_list|(
name|ndo
argument_list|,
name|bp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ret_len
operator|=
literal|1
comment|/*<opcode>*/
operator|+
name|len
comment|/*<string>*/
operator|+
literal|2
comment|/*<CRLF>*/
expr_stmt|;
name|TEST_RET_LEN
argument_list|(
name|ret_len
argument_list|)
expr_stmt|;
name|trunc
label|:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|resp_print_bulk_string
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|bp
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|length_cur
init|=
name|length
decl_stmt|,
name|string_len
decl_stmt|;
comment|/* bp points to the op; skip it */
name|SKIP_OPCODE
argument_list|(
name|bp
argument_list|,
name|length_cur
argument_list|)
expr_stmt|;
comment|/*<length>\r\n */
name|GET_LENGTH
argument_list|(
name|ndo
argument_list|,
name|length_cur
argument_list|,
name|bp
argument_list|,
name|string_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|string_len
operator|>=
literal|0
condition|)
block|{
comment|/* Byte string of length string_len, starting at bp */
if|if
condition|(
name|string_len
operator|==
literal|0
condition|)
name|resp_print_empty
argument_list|(
name|ndo
argument_list|)
expr_stmt|;
else|else
block|{
name|LCHECK2
argument_list|(
name|length_cur
argument_list|,
name|string_len
argument_list|)
expr_stmt|;
name|ND_TCHECK2
argument_list|(
operator|*
name|bp
argument_list|,
name|string_len
argument_list|)
expr_stmt|;
name|RESP_PRINT_SEGMENT
argument_list|(
name|ndo
argument_list|,
name|bp
argument_list|,
name|string_len
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|string_len
expr_stmt|;
name|length_cur
operator|-=
name|string_len
expr_stmt|;
block|}
comment|/*          * Find the \r\n at the end of the string and skip past it.          * XXX - report an error if the \r\n isn't immediately after          * the item?          */
name|FIND_CRLF
argument_list|(
name|bp
argument_list|,
name|length_cur
argument_list|)
expr_stmt|;
name|CONSUME_CRLF
argument_list|(
name|bp
argument_list|,
name|length_cur
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* null, truncated, or invalid for some reason */
switch|switch
condition|(
name|string_len
condition|)
block|{
case|case
operator|(
operator|-
literal|1
operator|)
case|:
name|resp_print_null
argument_list|(
name|ndo
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
operator|-
literal|2
operator|)
case|:
goto|goto
name|trunc
goto|;
case|case
operator|(
operator|-
literal|3
operator|)
case|:
name|resp_print_length_too_large
argument_list|(
name|ndo
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
operator|-
literal|4
operator|)
case|:
name|resp_print_length_negative
argument_list|(
name|ndo
argument_list|)
expr_stmt|;
break|break;
default|default:
name|resp_print_invalid
argument_list|(
name|ndo
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|length
operator|-
name|length_cur
operator|)
return|;
name|trunc
label|:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|resp_print_bulk_array
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|bp
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|u_int
name|length_cur
init|=
name|length
decl_stmt|;
name|int
name|array_len
decl_stmt|,
name|i
decl_stmt|,
name|ret_len
decl_stmt|;
comment|/* bp points to the op; skip it */
name|SKIP_OPCODE
argument_list|(
name|bp
argument_list|,
name|length_cur
argument_list|)
expr_stmt|;
comment|/*<array_length>\r\n */
name|GET_LENGTH
argument_list|(
name|ndo
argument_list|,
name|length_cur
argument_list|,
name|bp
argument_list|,
name|array_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|array_len
operator|>
literal|0
condition|)
block|{
comment|/* non empty array */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|array_len
condition|;
name|i
operator|++
control|)
block|{
name|ret_len
operator|=
name|resp_parse
argument_list|(
name|ndo
argument_list|,
name|bp
argument_list|,
name|length_cur
argument_list|)
expr_stmt|;
name|TEST_RET_LEN_NORETURN
argument_list|(
name|ret_len
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|ret_len
expr_stmt|;
name|length_cur
operator|-=
name|ret_len
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* empty, null, truncated, or invalid */
switch|switch
condition|(
name|array_len
condition|)
block|{
case|case
literal|0
case|:
name|resp_print_empty
argument_list|(
name|ndo
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
operator|-
literal|1
operator|)
case|:
name|resp_print_null
argument_list|(
name|ndo
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
operator|-
literal|2
operator|)
case|:
goto|goto
name|trunc
goto|;
case|case
operator|(
operator|-
literal|3
operator|)
case|:
name|resp_print_length_too_large
argument_list|(
name|ndo
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
operator|-
literal|4
operator|)
case|:
name|resp_print_length_negative
argument_list|(
name|ndo
argument_list|)
expr_stmt|;
break|break;
default|default:
name|resp_print_invalid
argument_list|(
name|ndo
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|length
operator|-
name|length_cur
operator|)
return|;
name|trunc
label|:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|resp_print_inline
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|bp
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|length_cur
init|=
name|length
decl_stmt|;
name|int
name|len
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|bp_ptr
decl_stmt|;
comment|/*      * Inline commands are simply 'strings' followed by \r or \n or both.      * Redis will do its best to split/parse these strings.      * This feature of redis is implemented to support the ability of      * command parsing from telnet/nc sessions etc.      *      *<string><\r||\n||\r\n...>      */
comment|/*      * Skip forward past any leading \r, \n, or \r\n.      */
name|CONSUME_CR_OR_LF
argument_list|(
name|bp
argument_list|,
name|length_cur
argument_list|)
expr_stmt|;
name|bp_ptr
operator|=
name|bp
expr_stmt|;
comment|/*      * Scan forward looking for \r or \n.      */
name|FIND_CR_OR_LF
argument_list|(
name|bp_ptr
argument_list|,
name|length_cur
argument_list|)
expr_stmt|;
comment|/*      * Found it; bp_ptr points to the \r or \n, so bp_ptr - bp is the      * Length of the line text that preceeds it.  Print it.      */
name|len
operator|=
operator|(
name|bp_ptr
operator|-
name|bp
operator|)
expr_stmt|;
name|RESP_PRINT_SEGMENT
argument_list|(
name|ndo
argument_list|,
name|bp
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/*      * Skip forward past the \r, \n, or \r\n.      */
name|CONSUME_CR_OR_LF
argument_list|(
name|bp_ptr
argument_list|,
name|length_cur
argument_list|)
expr_stmt|;
comment|/*      * Return the number of bytes we processed.      */
return|return
operator|(
name|length
operator|-
name|length_cur
operator|)
return|;
name|trunc
label|:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|resp_get_length
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|bp
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|u_char
modifier|*
modifier|*
name|endp
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
name|u_char
name|c
decl_stmt|;
name|int
name|saw_digit
decl_stmt|;
name|int
name|neg
decl_stmt|;
name|int
name|too_large
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
goto|goto
name|trunc
goto|;
name|ND_TCHECK
argument_list|(
operator|*
name|bp
argument_list|)
expr_stmt|;
name|too_large
operator|=
literal|0
expr_stmt|;
name|neg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'-'
condition|)
block|{
name|neg
operator|=
literal|1
expr_stmt|;
name|bp
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
name|result
operator|=
literal|0
expr_stmt|;
name|saw_digit
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
goto|goto
name|trunc
goto|;
name|ND_TCHECK
argument_list|(
operator|*
name|bp
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|bp
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|saw_digit
condition|)
goto|goto
name|invalid
goto|;
break|break;
block|}
name|c
operator|-=
literal|'0'
expr_stmt|;
if|if
condition|(
name|result
operator|>
operator|(
name|INT_MAX
operator|/
literal|10
operator|)
condition|)
block|{
comment|/* This will overflow an int when we multiply it by 10. */
name|too_large
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result
operator|*=
literal|10
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|INT_MAX
operator|&&
name|c
operator|>
operator|(
name|INT_MAX
operator|%
literal|10
operator|)
condition|)
block|{
comment|/* This will overflow an int when we add c */
name|too_large
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|result
operator|+=
name|c
expr_stmt|;
block|}
name|bp
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
name|saw_digit
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|saw_digit
condition|)
goto|goto
name|invalid
goto|;
comment|/*      * OK, the next thing should be \r\n.      */
if|if
condition|(
name|len
operator|==
literal|0
condition|)
goto|goto
name|trunc
goto|;
name|ND_TCHECK
argument_list|(
operator|*
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|!=
literal|'\r'
condition|)
goto|goto
name|invalid
goto|;
name|bp
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
goto|goto
name|trunc
goto|;
name|ND_TCHECK
argument_list|(
operator|*
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|!=
literal|'\n'
condition|)
goto|goto
name|invalid
goto|;
name|bp
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
operator|*
name|endp
operator|=
name|bp
expr_stmt|;
if|if
condition|(
name|neg
condition|)
block|{
comment|/* -1 means "null", anything else is invalid */
if|if
condition|(
name|too_large
operator|||
name|result
operator|!=
literal|1
condition|)
return|return
operator|(
operator|-
literal|4
operator|)
return|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|too_large
condition|?
operator|-
literal|3
else|:
name|result
operator|)
return|;
name|trunc
label|:
return|return
operator|(
operator|-
literal|2
operator|)
return|;
name|invalid
label|:
return|return
operator|(
operator|-
literal|5
operator|)
return|;
block|}
end_function

end_unit

