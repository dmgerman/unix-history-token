begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, 1993, 1994, 1995, 1996, 1997  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that: (1) source code distributions  * retain the above copyright notice and this paragraph in its entirety, (2)  * distributions including binary code include the above copyright notice and  * this paragraph in its entirety in the documentation or other materials  * provided with the distribution, and (3) all advertising materials mentioning  * features or use of this software display the following acknowledgement:  * ``This product includes software developed by the University of California,  * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of  * the University nor the names of its contributors may be used to endorse  * or promote products derived from this software without specific prior  * written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * Code by Matt Thomas, Digital Equipment Corporation  *	with an awful lot of hacking by Jeffrey Mogul, DECWRL  *  * $FreeBSD$  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
name|_U_
init|=
literal|"@(#) $Header: /tcpdump/master/tcpdump/print-llc.c,v 1.61.2.5 2005/09/29 07:40:13 hannes Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<tcpdump-stdinc.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"interface.h"
end_include

begin_include
include|#
directive|include
file|"addrtoname.h"
end_include

begin_include
include|#
directive|include
file|"extract.h"
end_include

begin_comment
comment|/* must come after interface.h */
end_comment

begin_include
include|#
directive|include
file|"llc.h"
end_include

begin_include
include|#
directive|include
file|"ethertype.h"
end_include

begin_include
include|#
directive|include
file|"oui.h"
end_include

begin_decl_stmt
specifier|static
name|struct
name|tok
name|llc_values
index|[]
init|=
block|{
block|{
name|LLCSAP_NULL
block|,
literal|"Null"
block|}
block|,
block|{
name|LLCSAP_GLOBAL
block|,
literal|"Global"
block|}
block|,
block|{
name|LLCSAP_8021B_I
block|,
literal|"802.1B I"
block|}
block|,
block|{
name|LLCSAP_8021B_G
block|,
literal|"802.1B G"
block|}
block|,
block|{
name|LLCSAP_IP
block|,
literal|"IP"
block|}
block|,
block|{
name|LLCSAP_SNA
block|,
literal|"SNA"
block|}
block|,
block|{
name|LLCSAP_PROWAYNM
block|,
literal|"ProWay NM"
block|}
block|,
block|{
name|LLCSAP_8021D
block|,
literal|"STP"
block|}
block|,
block|{
name|LLCSAP_RS511
block|,
literal|"RS511"
block|}
block|,
block|{
name|LLCSAP_ISO8208
block|,
literal|"ISO8208"
block|}
block|,
block|{
name|LLCSAP_PROWAY
block|,
literal|"ProWay"
block|}
block|,
block|{
name|LLCSAP_SNAP
block|,
literal|"SNAP"
block|}
block|,
block|{
name|LLCSAP_IPX
block|,
literal|"IPX"
block|}
block|,
block|{
name|LLCSAP_NETBEUI
block|,
literal|"NetBeui"
block|}
block|,
block|{
name|LLCSAP_ISONS
block|,
literal|"OSI"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|tok
name|llc_cmd_values
index|[]
init|=
block|{
block|{
name|LLC_UI
block|,
literal|"ui"
block|}
block|,
block|{
name|LLC_TEST
block|,
literal|"test"
block|}
block|,
block|{
name|LLC_XID
block|,
literal|"xid"
block|}
block|,
block|{
name|LLC_UA
block|,
literal|"ua"
block|}
block|,
block|{
name|LLC_DISC
block|,
literal|"disc"
block|}
block|,
block|{
name|LLC_DM
block|,
literal|"dm"
block|}
block|,
block|{
name|LLC_SABME
block|,
literal|"sabme"
block|}
block|,
block|{
name|LLC_FRMR
block|,
literal|"frmr"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|tok
name|llc_flag_values
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|"Command"
block|}
block|,
block|{
name|LLC_GSAP
block|,
literal|"Response"
block|}
block|,
block|{
name|LLC_U_POLL
block|,
literal|"Poll"
block|}
block|,
block|{
name|LLC_GSAP
operator||
name|LLC_U_POLL
block|,
literal|"Final"
block|}
block|,
block|{
name|LLC_GSAP
operator||
name|LLC_IS_POLL
block|,
literal|"Final"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|tok
name|llc_supervisory_values
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|"Receiver Ready"
block|}
block|,
block|{
literal|1
block|,
literal|"Reject"
block|}
block|,
block|{
literal|2
block|,
literal|"Receiver not Ready"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|tok
name|cisco_values
index|[]
init|=
block|{
block|{
name|PID_CISCO_CDP
block|,
literal|"CDP"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|tok
name|bridged_values
index|[]
init|=
block|{
block|{
name|PID_RFC2684_ETH_FCS
block|,
literal|"Ethernet + FCS"
block|}
block|,
block|{
name|PID_RFC2684_ETH_NOFCS
block|,
literal|"Ethernet w/o FCS"
block|}
block|,
block|{
name|PID_RFC2684_802_4_FCS
block|,
literal|"802.4 + FCS"
block|}
block|,
block|{
name|PID_RFC2684_802_4_NOFCS
block|,
literal|"802.4 w/o FCS"
block|}
block|,
block|{
name|PID_RFC2684_802_5_FCS
block|,
literal|"Token Ring + FCS"
block|}
block|,
block|{
name|PID_RFC2684_802_5_NOFCS
block|,
literal|"Token Ring w/o FCS"
block|}
block|,
block|{
name|PID_RFC2684_FDDI_FCS
block|,
literal|"FDDI + FCS"
block|}
block|,
block|{
name|PID_RFC2684_FDDI_NOFCS
block|,
literal|"FDDI w/o FCS"
block|}
block|,
block|{
name|PID_RFC2684_802_6_FCS
block|,
literal|"802.6 + FCS"
block|}
block|,
block|{
name|PID_RFC2684_802_6_NOFCS
block|,
literal|"802.6 w/o FCS"
block|}
block|,
block|{
name|PID_RFC2684_BPDU
block|,
literal|"BPDU"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|oui_tok
block|{
name|u_int32_t
name|oui
decl_stmt|;
specifier|const
name|struct
name|tok
modifier|*
name|tok
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|oui_tok
name|oui_to_tok
index|[]
init|=
block|{
block|{
name|OUI_ENCAP_ETHER
block|,
name|ethertype_values
block|}
block|,
block|{
name|OUI_CISCO_90
block|,
name|ethertype_values
block|}
block|,
comment|/* uses some Ethertype values */
block|{
name|OUI_APPLETALK
block|,
name|ethertype_values
block|}
block|,
comment|/* uses some Ethertype values */
block|{
name|OUI_CISCO
block|,
name|cisco_values
block|}
block|,
block|{
name|OUI_RFC2684
block|,
name|bridged_values
block|}
block|,
comment|/* bridged, RFC 2427 FR or RFC 2864 ATM */
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Returns non-zero IFF it succeeds in printing the header  */
end_comment

begin_function
name|int
name|llc_print
parameter_list|(
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|u_int
name|length
parameter_list|,
name|u_int
name|caplen
parameter_list|,
specifier|const
name|u_char
modifier|*
name|esrc
parameter_list|,
specifier|const
name|u_char
modifier|*
name|edst
parameter_list|,
name|u_short
modifier|*
name|extracted_ethertype
parameter_list|)
block|{
name|u_int8_t
name|dsap_field
decl_stmt|,
name|dsap
decl_stmt|,
name|ssap_field
decl_stmt|,
name|ssap
decl_stmt|;
name|u_int16_t
name|control
decl_stmt|;
name|int
name|is_u
decl_stmt|;
specifier|register
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|caplen
operator|<
literal|3
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"[|llc]"
argument_list|)
expr_stmt|;
name|default_print
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|p
argument_list|,
name|caplen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dsap_field
operator|=
operator|*
name|p
expr_stmt|;
name|dsap
operator|=
name|dsap_field
operator|&
operator|~
name|LLC_IG
expr_stmt|;
name|ssap_field
operator|=
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
expr_stmt|;
name|ssap
operator|=
name|ssap_field
operator|&
operator|~
name|LLC_GSAP
expr_stmt|;
comment|/* 	 * OK, what type of LLC frame is this?  The length 	 * of the control field depends on that - I frames 	 * have a two-byte control field, and U frames have 	 * a one-byte control field. 	 */
name|control
operator|=
operator|*
operator|(
name|p
operator|+
literal|2
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|control
operator|&
name|LLC_U_FMT
operator|)
operator|==
name|LLC_U_FMT
condition|)
block|{
comment|/* 		 * U frame. 		 */
name|is_u
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The control field in I and S frames is 		 * 2 bytes... 		 */
if|if
condition|(
name|caplen
operator|<
literal|4
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"[|llc]"
argument_list|)
expr_stmt|;
name|default_print
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|p
argument_list|,
name|caplen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * ...and is little-endian. 		 */
name|control
operator|=
name|EXTRACT_LE_16BITS
argument_list|(
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
name|is_u
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ssap
operator|==
name|LLCSAP_GLOBAL
operator|&&
name|dsap
operator|==
name|LLCSAP_GLOBAL
condition|)
block|{
comment|/* 		 * This is an Ethernet_802.3 IPX frame; it has an 		 * 802.3 header (i.e., an Ethernet header where the 		 * type/length field is<= ETHERMTU, i.e. it's a length 		 * field, not a type field), but has no 802.2 header - 		 * the IPX packet starts right after the Ethernet header, 		 * with a signature of two bytes of 0xFF (which is 		 * LLCSAP_GLOBAL). 		 * 		 * (It might also have been an Ethernet_802.3 IPX at 		 * one time, but got bridged onto another network, 		 * such as an 802.11 network; this has appeared in at 		 * least one capture file.) 		 */
if|if
condition|(
name|eflag
condition|)
name|printf
argument_list|(
literal|"IPX 802.3: "
argument_list|)
expr_stmt|;
name|ipx_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|eflag
condition|)
block|{
name|printf
argument_list|(
literal|"LLC, dsap %s (0x%02x), ssap %s (0x%02x)"
argument_list|,
name|tok2str
argument_list|(
name|llc_values
argument_list|,
literal|"Unknown"
argument_list|,
name|dsap
argument_list|)
argument_list|,
name|dsap
argument_list|,
name|tok2str
argument_list|(
name|llc_values
argument_list|,
literal|"Unknown"
argument_list|,
name|ssap
argument_list|)
argument_list|,
name|ssap
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_u
condition|)
block|{
name|printf
argument_list|(
literal|", cmd 0x%02x: "
argument_list|,
name|control
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|", cmd 0x%04x: "
argument_list|,
name|control
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ssap
operator|==
name|LLCSAP_8021D
operator|&&
name|dsap
operator|==
name|LLCSAP_8021D
operator|&&
name|control
operator|==
name|LLC_UI
condition|)
block|{
name|stp_print
argument_list|(
name|p
operator|+
literal|3
argument_list|,
name|length
operator|-
literal|3
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ssap
operator|==
name|LLCSAP_IP
operator|&&
name|dsap
operator|==
name|LLCSAP_IP
operator|&&
name|control
operator|==
name|LLC_UI
condition|)
block|{
name|ip_print
argument_list|(
name|gndo
argument_list|,
name|p
operator|+
literal|4
argument_list|,
name|length
operator|-
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ssap
operator|==
name|LLCSAP_IPX
operator|&&
name|dsap
operator|==
name|LLCSAP_IPX
operator|&&
name|control
operator|==
name|LLC_UI
condition|)
block|{
comment|/* 		 * This is an Ethernet_802.2 IPX frame, with an 802.3 		 * header and an 802.2 LLC header with the source and 		 * destination SAPs being the IPX SAP. 		 * 		 * Skip DSAP, LSAP, and control field. 		 */
if|if
condition|(
name|eflag
condition|)
name|printf
argument_list|(
literal|"IPX 802.2: "
argument_list|)
expr_stmt|;
name|ipx_print
argument_list|(
name|p
operator|+
literal|3
argument_list|,
name|length
operator|-
literal|3
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|TCPDUMP_DO_SMB
if|if
condition|(
name|ssap
operator|==
name|LLCSAP_NETBEUI
operator|&&
name|dsap
operator|==
name|LLCSAP_NETBEUI
operator|&&
operator|(
operator|!
operator|(
name|control
operator|&
name|LLC_S_FMT
operator|)
operator|||
name|control
operator|==
name|LLC_U_FMT
operator|)
condition|)
block|{
comment|/* 		 * we don't actually have a full netbeui parser yet, but the 		 * smb parser can handle many smb-in-netbeui packets, which 		 * is very useful, so we call that 		 * 		 * We don't call it for S frames, however, just I frames 		 * (which are frames that don't have the low-order bit, 		 * LLC_S_FMT, set in the first byte of the control field) 		 * and UI frames (whose control field is just 3, LLC_U_FMT). 		 */
comment|/* 		 * Skip the LLC header. 		 */
if|if
condition|(
name|is_u
condition|)
block|{
name|p
operator|+=
literal|3
expr_stmt|;
name|length
operator|-=
literal|3
expr_stmt|;
name|caplen
operator|-=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|p
operator|+=
literal|4
expr_stmt|;
name|length
operator|-=
literal|4
expr_stmt|;
name|caplen
operator|-=
literal|4
expr_stmt|;
block|}
name|netbeui_print
argument_list|(
name|control
argument_list|,
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|ssap
operator|==
name|LLCSAP_ISONS
operator|&&
name|dsap
operator|==
name|LLCSAP_ISONS
operator|&&
name|control
operator|==
name|LLC_UI
condition|)
block|{
name|isoclns_print
argument_list|(
name|p
operator|+
literal|3
argument_list|,
name|length
operator|-
literal|3
argument_list|,
name|caplen
operator|-
literal|3
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ssap
operator|==
name|LLCSAP_SNAP
operator|&&
name|dsap
operator|==
name|LLCSAP_SNAP
operator|&&
name|control
operator|==
name|LLC_UI
condition|)
block|{
comment|/* 		 * XXX - what *is* the right bridge pad value here? 		 * Does anybody ever bridge one form of LAN traffic 		 * over a networking type that uses 802.2 LLC? 		 */
name|ret
operator|=
name|snap_print
argument_list|(
name|p
operator|+
literal|3
argument_list|,
name|length
operator|-
literal|3
argument_list|,
name|caplen
operator|-
literal|3
argument_list|,
name|extracted_ethertype
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|eflag
condition|)
block|{
if|if
condition|(
name|ssap
operator|==
name|dsap
condition|)
block|{
if|if
condition|(
name|esrc
operator|==
name|NULL
operator|||
name|edst
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|tok2str
argument_list|(
name|llc_values
argument_list|,
literal|"Unknown DSAP 0x%02x"
argument_list|,
name|dsap
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s> %s %s "
argument_list|,
name|etheraddr_string
argument_list|(
name|esrc
argument_list|)
argument_list|,
name|etheraddr_string
argument_list|(
name|edst
argument_list|)
argument_list|,
name|tok2str
argument_list|(
name|llc_values
argument_list|,
literal|"Unknown DSAP 0x%02x"
argument_list|,
name|dsap
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|esrc
operator|==
name|NULL
operator|||
name|edst
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s> %s "
argument_list|,
name|tok2str
argument_list|(
name|llc_values
argument_list|,
literal|"Unknown SSAP 0x%02x"
argument_list|,
name|ssap
argument_list|)
argument_list|,
name|tok2str
argument_list|(
name|llc_values
argument_list|,
literal|"Unknown DSAP 0x%02x"
argument_list|,
name|dsap
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s %s> %s %s "
argument_list|,
name|etheraddr_string
argument_list|(
name|esrc
argument_list|)
argument_list|,
name|tok2str
argument_list|(
name|llc_values
argument_list|,
literal|"Unknown SSAP 0x%02x"
argument_list|,
name|ssap
argument_list|)
argument_list|,
name|etheraddr_string
argument_list|(
name|edst
argument_list|)
argument_list|,
name|tok2str
argument_list|(
name|llc_values
argument_list|,
literal|"Unknown DSAP 0x%02x"
argument_list|,
name|dsap
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|is_u
condition|)
block|{
name|printf
argument_list|(
literal|"Unnumbered, %s, Flags [%s], length %u"
argument_list|,
name|tok2str
argument_list|(
name|llc_cmd_values
argument_list|,
literal|"%02x"
argument_list|,
name|LLC_U_CMD
argument_list|(
name|control
argument_list|)
argument_list|)
argument_list|,
name|bittok2str
argument_list|(
name|llc_flag_values
argument_list|,
literal|"?"
argument_list|,
operator|(
name|ssap
operator|)
operator||
operator|(
name|control
operator|&
name|LLC_U_POLL
operator|)
argument_list|)
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|3
expr_stmt|;
name|length
operator|-=
literal|3
expr_stmt|;
name|caplen
operator|-=
literal|3
expr_stmt|;
if|if
condition|(
operator|(
name|control
operator|&
operator|~
name|LLC_U_POLL
operator|)
operator|==
name|LLC_XID
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
name|LLC_XID_FI
condition|)
block|{
name|printf
argument_list|(
literal|": %02x %02x"
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
name|p
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|3
expr_stmt|;
name|length
operator|-=
literal|3
expr_stmt|;
name|caplen
operator|-=
literal|3
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|control
operator|&
name|LLC_S_FMT
operator|)
operator|==
name|LLC_S_FMT
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Supervisory, %s, rcv seq %u, Flags [%s], length %u"
argument_list|,
name|tok2str
argument_list|(
name|llc_supervisory_values
argument_list|,
literal|"?"
argument_list|,
name|LLC_S_CMD
argument_list|(
name|control
argument_list|)
argument_list|)
argument_list|,
name|LLC_IS_NR
argument_list|(
name|control
argument_list|)
argument_list|,
name|bittok2str
argument_list|(
name|llc_flag_values
argument_list|,
literal|"?"
argument_list|,
operator|(
name|ssap
operator|)
operator||
operator|(
name|control
operator|&
name|LLC_IS_POLL
operator|)
argument_list|)
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Information, send seq %u, rcv seq %u, Flags [%s], length %u"
argument_list|,
name|LLC_I_NS
argument_list|(
name|control
argument_list|)
argument_list|,
name|LLC_IS_NR
argument_list|(
name|control
argument_list|)
argument_list|,
name|bittok2str
argument_list|(
name|llc_flag_values
argument_list|,
literal|"?"
argument_list|,
operator|(
name|ssap
operator|)
operator||
operator|(
name|control
operator|&
name|LLC_IS_POLL
operator|)
argument_list|)
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
name|p
operator|+=
literal|4
expr_stmt|;
name|length
operator|-=
literal|4
expr_stmt|;
name|caplen
operator|-=
literal|4
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|snap_print
parameter_list|(
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|u_int
name|length
parameter_list|,
name|u_int
name|caplen
parameter_list|,
name|u_short
modifier|*
name|extracted_ethertype
parameter_list|,
name|u_int
name|bridge_pad
parameter_list|)
block|{
name|u_int32_t
name|orgcode
decl_stmt|;
specifier|register
name|u_short
name|et
decl_stmt|;
specifier|register
name|int
name|ret
decl_stmt|;
name|TCHECK2
argument_list|(
operator|*
name|p
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|orgcode
operator|=
name|EXTRACT_24BITS
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|et
operator|=
name|EXTRACT_16BITS
argument_list|(
name|p
operator|+
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|eflag
condition|)
block|{
specifier|const
name|struct
name|tok
modifier|*
name|tok
init|=
name|NULL
decl_stmt|;
specifier|const
name|struct
name|oui_tok
modifier|*
name|otp
decl_stmt|;
for|for
control|(
name|otp
operator|=
operator|&
name|oui_to_tok
index|[
literal|0
index|]
init|;
name|otp
operator|->
name|tok
operator|!=
name|NULL
condition|;
name|otp
operator|++
control|)
block|{
if|if
condition|(
name|otp
operator|->
name|oui
operator|==
name|orgcode
condition|)
block|{
name|tok
operator|=
name|otp
operator|->
name|tok
expr_stmt|;
break|break;
block|}
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"oui %s (0x%06x), %s %s (0x%04x): "
argument_list|,
name|tok2str
argument_list|(
name|oui_values
argument_list|,
literal|"Unknown"
argument_list|,
name|orgcode
argument_list|)
argument_list|,
name|orgcode
argument_list|,
operator|(
name|orgcode
operator|==
literal|0x000000
condition|?
literal|"ethertype"
else|:
literal|"pid"
operator|)
argument_list|,
name|tok2str
argument_list|(
name|tok
argument_list|,
literal|"Unknown"
argument_list|,
name|et
argument_list|)
argument_list|,
name|et
argument_list|)
expr_stmt|;
block|}
name|p
operator|+=
literal|5
expr_stmt|;
name|length
operator|-=
literal|5
expr_stmt|;
name|caplen
operator|-=
literal|5
expr_stmt|;
switch|switch
condition|(
name|orgcode
condition|)
block|{
case|case
name|OUI_ENCAP_ETHER
case|:
case|case
name|OUI_CISCO_90
case|:
comment|/* 		 * This is an encapsulated Ethernet packet, 		 * or a packet bridged by some piece of 		 * Cisco hardware; the protocol ID is 		 * an Ethernet protocol type. 		 */
name|ret
operator|=
name|ether_encap_print
argument_list|(
name|et
argument_list|,
name|p
argument_list|,
name|length
argument_list|,
name|caplen
argument_list|,
name|extracted_ethertype
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
operator|(
name|ret
operator|)
return|;
break|break;
case|case
name|OUI_APPLETALK
case|:
if|if
condition|(
name|et
operator|==
name|ETHERTYPE_ATALK
condition|)
block|{
comment|/* 			 * No, I have no idea why Apple used one 			 * of their own OUIs, rather than 			 * 0x000000, and an Ethernet packet 			 * type, for Appletalk data packets, 			 * but used 0x000000 and an Ethernet 			 * packet type for AARP packets. 			 */
name|ret
operator|=
name|ether_encap_print
argument_list|(
name|et
argument_list|,
name|p
argument_list|,
name|length
argument_list|,
name|caplen
argument_list|,
name|extracted_ethertype
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
break|break;
case|case
name|OUI_CISCO
case|:
if|if
condition|(
name|et
operator|==
name|PID_CISCO_CDP
condition|)
block|{
name|cdp_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|,
name|caplen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
name|OUI_RFC2684
case|:
switch|switch
condition|(
name|et
condition|)
block|{
case|case
name|PID_RFC2684_ETH_FCS
case|:
case|case
name|PID_RFC2684_ETH_NOFCS
case|:
comment|/* 			 * XXX - remove the last two bytes for 			 * PID_RFC2684_ETH_FCS? 			 */
comment|/* 			 * Skip the padding. 			 */
name|TCHECK2
argument_list|(
operator|*
name|p
argument_list|,
name|bridge_pad
argument_list|)
expr_stmt|;
name|caplen
operator|-=
name|bridge_pad
expr_stmt|;
name|length
operator|-=
name|bridge_pad
expr_stmt|;
name|p
operator|+=
name|bridge_pad
expr_stmt|;
comment|/* 			 * What remains is an Ethernet packet. 			 */
name|ether_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|,
name|caplen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|PID_RFC2684_802_5_FCS
case|:
case|case
name|PID_RFC2684_802_5_NOFCS
case|:
comment|/* 			 * XXX - remove the last two bytes for 			 * PID_RFC2684_ETH_FCS? 			 */
comment|/* 			 * Skip the padding, but not the Access 			 * Control field. 			 */
name|TCHECK2
argument_list|(
operator|*
name|p
argument_list|,
name|bridge_pad
argument_list|)
expr_stmt|;
name|caplen
operator|-=
name|bridge_pad
expr_stmt|;
name|length
operator|-=
name|bridge_pad
expr_stmt|;
name|p
operator|+=
name|bridge_pad
expr_stmt|;
comment|/* 			 * What remains is an 802.5 Token Ring 			 * packet. 			 */
name|token_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|,
name|caplen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|PID_RFC2684_FDDI_FCS
case|:
case|case
name|PID_RFC2684_FDDI_NOFCS
case|:
comment|/* 			 * XXX - remove the last two bytes for 			 * PID_RFC2684_ETH_FCS? 			 */
comment|/* 			 * Skip the padding. 			 */
name|TCHECK2
argument_list|(
operator|*
name|p
argument_list|,
name|bridge_pad
operator|+
literal|1
argument_list|)
expr_stmt|;
name|caplen
operator|-=
name|bridge_pad
operator|+
literal|1
expr_stmt|;
name|length
operator|-=
name|bridge_pad
operator|+
literal|1
expr_stmt|;
name|p
operator|+=
name|bridge_pad
operator|+
literal|1
expr_stmt|;
comment|/* 			 * What remains is an FDDI packet. 			 */
name|fddi_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|,
name|caplen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|PID_RFC2684_BPDU
case|:
name|stp_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|trunc
label|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"[|snap]"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Local Variables:  * c-style: whitesmith  * c-basic-offset: 8  * End:  */
end_comment

end_unit

