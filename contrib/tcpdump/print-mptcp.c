begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright (c) 2012  *  * Gregory Detal<gregory.detal@uclouvain.be>  * Christoph Paasch<christoph.paasch@uclouvain.be>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * 3. Neither the name of the University nor of the Laboratory may be used  *    to endorse or promote products derived from this software without  *    specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_define
define|#
directive|define
name|NETDISSECT_REWORKED
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<tcpdump-stdinc.h>
end_include

begin_include
include|#
directive|include
file|"interface.h"
end_include

begin_include
include|#
directive|include
file|"extract.h"
end_include

begin_include
include|#
directive|include
file|"addrtoname.h"
end_include

begin_include
include|#
directive|include
file|"tcp.h"
end_include

begin_define
define|#
directive|define
name|MPTCP_SUB_CAPABLE
value|0x0
end_define

begin_define
define|#
directive|define
name|MPTCP_SUB_JOIN
value|0x1
end_define

begin_define
define|#
directive|define
name|MPTCP_SUB_DSS
value|0x2
end_define

begin_define
define|#
directive|define
name|MPTCP_SUB_ADD_ADDR
value|0x3
end_define

begin_define
define|#
directive|define
name|MPTCP_SUB_REMOVE_ADDR
value|0x4
end_define

begin_define
define|#
directive|define
name|MPTCP_SUB_PRIO
value|0x5
end_define

begin_define
define|#
directive|define
name|MPTCP_SUB_FAIL
value|0x6
end_define

begin_define
define|#
directive|define
name|MPTCP_SUB_FCLOSE
value|0x7
end_define

begin_struct
struct|struct
name|mptcp_option
block|{
name|uint8_t
name|kind
decl_stmt|;
name|uint8_t
name|len
decl_stmt|;
name|uint8_t
name|sub_etc
decl_stmt|;
comment|/* subtype upper 4 bits, other stuff lower 4 bits */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MPTCP_OPT_SUBTYPE
parameter_list|(
name|sub_etc
parameter_list|)
value|(((sub_etc)>> 4)& 0xF)
end_define

begin_struct
struct|struct
name|mp_capable
block|{
name|uint8_t
name|kind
decl_stmt|;
name|uint8_t
name|len
decl_stmt|;
name|uint8_t
name|sub_ver
decl_stmt|;
name|uint8_t
name|flags
decl_stmt|;
name|uint8_t
name|sender_key
index|[
literal|8
index|]
decl_stmt|;
name|uint8_t
name|receiver_key
index|[
literal|8
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MP_CAPABLE_OPT_VERSION
parameter_list|(
name|sub_ver
parameter_list|)
value|(((sub_ver)>> 0)& 0xF)
end_define

begin_define
define|#
directive|define
name|MP_CAPABLE_C
value|0x80
end_define

begin_define
define|#
directive|define
name|MP_CAPABLE_S
value|0x01
end_define

begin_struct
struct|struct
name|mp_join
block|{
name|uint8_t
name|kind
decl_stmt|;
name|uint8_t
name|len
decl_stmt|;
name|uint8_t
name|sub_b
decl_stmt|;
name|uint8_t
name|addr_id
decl_stmt|;
union|union
block|{
struct|struct
block|{
name|uint8_t
name|token
index|[
literal|4
index|]
decl_stmt|;
name|uint8_t
name|nonce
index|[
literal|4
index|]
decl_stmt|;
block|}
name|syn
struct|;
struct|struct
block|{
name|uint8_t
name|mac
index|[
literal|8
index|]
decl_stmt|;
name|uint8_t
name|nonce
index|[
literal|4
index|]
decl_stmt|;
block|}
name|synack
struct|;
struct|struct
block|{
name|uint8_t
name|mac
index|[
literal|20
index|]
decl_stmt|;
block|}
name|ack
struct|;
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MP_JOIN_B
value|0x01
end_define

begin_struct
struct|struct
name|mp_dss
block|{
name|uint8_t
name|kind
decl_stmt|;
name|uint8_t
name|len
decl_stmt|;
name|uint8_t
name|sub
decl_stmt|;
name|uint8_t
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MP_DSS_F
value|0x10
end_define

begin_define
define|#
directive|define
name|MP_DSS_m
value|0x08
end_define

begin_define
define|#
directive|define
name|MP_DSS_M
value|0x04
end_define

begin_define
define|#
directive|define
name|MP_DSS_a
value|0x02
end_define

begin_define
define|#
directive|define
name|MP_DSS_A
value|0x01
end_define

begin_struct
struct|struct
name|mp_add_addr
block|{
name|uint8_t
name|kind
decl_stmt|;
name|uint8_t
name|len
decl_stmt|;
name|uint8_t
name|sub_ipver
decl_stmt|;
name|uint8_t
name|addr_id
decl_stmt|;
union|union
block|{
struct|struct
block|{
name|uint8_t
name|addr
index|[
literal|4
index|]
decl_stmt|;
name|uint8_t
name|port
index|[
literal|2
index|]
decl_stmt|;
block|}
name|v4
struct|;
struct|struct
block|{
name|uint8_t
name|addr
index|[
literal|16
index|]
decl_stmt|;
name|uint8_t
name|port
index|[
literal|2
index|]
decl_stmt|;
block|}
name|v6
struct|;
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MP_ADD_ADDR_IPVER
parameter_list|(
name|sub_ipver
parameter_list|)
value|(((sub_ipver)>> 0)& 0xF)
end_define

begin_struct
struct|struct
name|mp_remove_addr
block|{
name|uint8_t
name|kind
decl_stmt|;
name|uint8_t
name|len
decl_stmt|;
name|uint8_t
name|sub
decl_stmt|;
comment|/* list of addr_id */
name|uint8_t
name|addrs_id
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mp_fail
block|{
name|uint8_t
name|kind
decl_stmt|;
name|uint8_t
name|len
decl_stmt|;
name|uint8_t
name|sub
decl_stmt|;
name|uint8_t
name|resv
decl_stmt|;
name|uint8_t
name|data_seq
index|[
literal|8
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mp_close
block|{
name|uint8_t
name|kind
decl_stmt|;
name|uint8_t
name|len
decl_stmt|;
name|uint8_t
name|sub
decl_stmt|;
name|uint8_t
name|rsv
decl_stmt|;
name|uint8_t
name|key
index|[
literal|8
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mp_prio
block|{
name|uint8_t
name|kind
decl_stmt|;
name|uint8_t
name|len
decl_stmt|;
name|uint8_t
name|sub_b
decl_stmt|;
name|uint8_t
name|addr_id
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MP_PRIO_B
value|0x01
end_define

begin_function
specifier|static
name|int
name|dummy_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
name|_U_
parameter_list|,
specifier|const
name|u_char
modifier|*
name|opt
name|_U_
parameter_list|,
name|u_int
name|opt_len
name|_U_
parameter_list|,
name|u_char
name|flags
name|_U_
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mp_capable_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|const
name|u_char
modifier|*
name|opt
parameter_list|,
name|u_int
name|opt_len
parameter_list|,
name|u_char
name|flags
parameter_list|)
block|{
name|struct
name|mp_capable
modifier|*
name|mpc
init|=
operator|(
expr|struct
name|mp_capable
operator|*
operator|)
name|opt
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|opt_len
operator|==
literal|12
operator|&&
name|flags
operator|&
name|TH_SYN
operator|)
operator|&&
operator|!
operator|(
name|opt_len
operator|==
literal|20
operator|&&
operator|(
name|flags
operator|&
operator|(
name|TH_SYN
operator||
name|TH_ACK
operator|)
operator|)
operator|==
name|TH_ACK
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|MP_CAPABLE_OPT_VERSION
argument_list|(
name|mpc
operator|->
name|sub_ver
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" Unknown Version (%d)"
operator|,
name|MP_CAPABLE_OPT_VERSION
argument_list|(
name|mpc
operator|->
name|sub_ver
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|mpc
operator|->
name|flags
operator|&
name|MP_CAPABLE_C
condition|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" csum"
operator|)
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" {0x%"
name|PRIx64
operator|,
name|EXTRACT_64BITS
argument_list|(
name|mpc
operator|->
name|sender_key
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_len
operator|==
literal|20
condition|)
comment|/* ACK */
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|",0x%"
name|PRIx64
operator|,
name|EXTRACT_64BITS
argument_list|(
name|mpc
operator|->
name|receiver_key
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"}"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mp_join_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|const
name|u_char
modifier|*
name|opt
parameter_list|,
name|u_int
name|opt_len
parameter_list|,
name|u_char
name|flags
parameter_list|)
block|{
name|struct
name|mp_join
modifier|*
name|mpj
init|=
operator|(
expr|struct
name|mp_join
operator|*
operator|)
name|opt
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|opt_len
operator|==
literal|12
operator|&&
name|flags
operator|&
name|TH_SYN
operator|)
operator|&&
operator|!
operator|(
name|opt_len
operator|==
literal|16
operator|&&
operator|(
name|flags
operator|&
operator|(
name|TH_SYN
operator||
name|TH_ACK
operator|)
operator|)
operator|==
operator|(
name|TH_SYN
operator||
name|TH_ACK
operator|)
operator|)
operator|&&
operator|!
operator|(
name|opt_len
operator|==
literal|24
operator|&&
name|flags
operator|&
name|TH_ACK
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|opt_len
operator|!=
literal|24
condition|)
block|{
if|if
condition|(
name|mpj
operator|->
name|sub_b
operator|&
name|MP_JOIN_B
condition|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" backup"
operator|)
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" id %u"
operator|,
name|mpj
operator|->
name|addr_id
operator|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|opt_len
condition|)
block|{
case|case
literal|12
case|:
comment|/* SYN */
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" token 0x%x"
literal|" nonce 0x%x"
operator|,
name|EXTRACT_32BITS
argument_list|(
name|mpj
operator|->
name|u
operator|.
name|syn
operator|.
name|token
argument_list|)
operator|,
name|EXTRACT_32BITS
argument_list|(
name|mpj
operator|->
name|u
operator|.
name|syn
operator|.
name|nonce
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
comment|/* SYN/ACK */
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" hmac 0x%"
name|PRIx64
literal|" nonce 0x%x"
operator|,
name|EXTRACT_64BITS
argument_list|(
name|mpj
operator|->
name|u
operator|.
name|synack
operator|.
name|mac
argument_list|)
operator|,
name|EXTRACT_32BITS
argument_list|(
name|mpj
operator|->
name|u
operator|.
name|synack
operator|.
name|nonce
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|24
case|:
block|{
comment|/* ACK */
name|size_t
name|i
decl_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" hmac 0x"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|mpj
operator|->
name|u
operator|.
name|ack
operator|.
name|mac
argument_list|)
condition|;
operator|++
name|i
control|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%02x"
operator|,
name|mpj
operator|->
name|u
operator|.
name|ack
operator|.
name|mac
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
default|default:
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|mp_dss_len
parameter_list|(
name|struct
name|mp_dss
modifier|*
name|m
parameter_list|,
name|int
name|csum
parameter_list|)
block|{
name|u_int
name|len
decl_stmt|;
name|len
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|MP_DSS_A
condition|)
block|{
comment|/* Ack present - 4 or 8 octets */
name|len
operator|+=
operator|(
name|m
operator|->
name|flags
operator|&
name|MP_DSS_a
operator|)
condition|?
literal|8
else|:
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|MP_DSS_M
condition|)
block|{
comment|/*                  * Data Sequence Number (DSN), Subflow Sequence Number (SSN),                  * Data-Level Length present, and Checksum possibly present.                  * All but the Checksum are 10 bytes if the m flag is                  * clear (4-byte DSN) and 14 bytes if the m flag is set                  * (8-byte DSN).                  */
name|len
operator|+=
operator|(
name|m
operator|->
name|flags
operator|&
name|MP_DSS_m
operator|)
condition|?
literal|14
else|:
literal|10
expr_stmt|;
comment|/*                  * The Checksum is present only if negotiated.                  */
if|if
condition|(
name|csum
condition|)
name|len
operator|+=
literal|2
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mp_dss_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|const
name|u_char
modifier|*
name|opt
parameter_list|,
name|u_int
name|opt_len
parameter_list|,
name|u_char
name|flags
parameter_list|)
block|{
name|struct
name|mp_dss
modifier|*
name|mdss
init|=
operator|(
expr|struct
name|mp_dss
operator|*
operator|)
name|opt
decl_stmt|;
if|if
condition|(
operator|(
name|opt_len
operator|!=
name|mp_dss_len
argument_list|(
name|mdss
argument_list|,
literal|1
argument_list|)
operator|&&
name|opt_len
operator|!=
name|mp_dss_len
argument_list|(
name|mdss
argument_list|,
literal|0
argument_list|)
operator|)
operator|||
name|flags
operator|&
name|TH_SYN
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mdss
operator|->
name|flags
operator|&
name|MP_DSS_F
condition|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" fin"
operator|)
argument_list|)
expr_stmt|;
name|opt
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|mdss
operator|->
name|flags
operator|&
name|MP_DSS_A
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" ack "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdss
operator|->
name|flags
operator|&
name|MP_DSS_a
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%"
name|PRIu64
operator|,
name|EXTRACT_64BITS
argument_list|(
name|opt
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|opt
operator|+=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%u"
operator|,
name|EXTRACT_32BITS
argument_list|(
name|opt
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|opt
operator|+=
literal|4
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mdss
operator|->
name|flags
operator|&
name|MP_DSS_M
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" seq "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdss
operator|->
name|flags
operator|&
name|MP_DSS_m
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%"
name|PRIu64
operator|,
name|EXTRACT_64BITS
argument_list|(
name|opt
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|opt
operator|+=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%u"
operator|,
name|EXTRACT_32BITS
argument_list|(
name|opt
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|opt
operator|+=
literal|4
expr_stmt|;
block|}
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" subseq %u"
operator|,
name|EXTRACT_32BITS
argument_list|(
name|opt
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|opt
operator|+=
literal|4
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" len %u"
operator|,
name|EXTRACT_16BITS
argument_list|(
name|opt
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|opt
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|opt_len
operator|==
name|mp_dss_len
argument_list|(
name|mdss
argument_list|,
literal|1
argument_list|)
condition|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" csum 0x%x"
operator|,
name|EXTRACT_16BITS
argument_list|(
name|opt
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|add_addr_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|const
name|u_char
modifier|*
name|opt
parameter_list|,
name|u_int
name|opt_len
parameter_list|,
name|u_char
name|flags
name|_U_
parameter_list|)
block|{
name|struct
name|mp_add_addr
modifier|*
name|add_addr
init|=
operator|(
expr|struct
name|mp_add_addr
operator|*
operator|)
name|opt
decl_stmt|;
name|u_int
name|ipver
init|=
name|MP_ADD_ADDR_IPVER
argument_list|(
name|add_addr
operator|->
name|sub_ipver
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|opt_len
operator|==
literal|8
operator|||
name|opt_len
operator|==
literal|10
operator|)
operator|&&
name|ipver
operator|==
literal|4
operator|)
operator|&&
operator|!
operator|(
operator|(
name|opt_len
operator|==
literal|20
operator|||
name|opt_len
operator|==
literal|22
operator|)
operator|&&
name|ipver
operator|==
literal|6
operator|)
condition|)
return|return
literal|0
return|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" id %u"
operator|,
name|add_addr
operator|->
name|addr_id
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ipver
condition|)
block|{
case|case
literal|4
case|:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" %s"
operator|,
name|ipaddr_string
argument_list|(
name|ndo
argument_list|,
name|add_addr
operator|->
name|u
operator|.
name|v4
operator|.
name|addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_len
operator|==
literal|10
condition|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|":%u"
operator|,
name|EXTRACT_16BITS
argument_list|(
name|add_addr
operator|->
name|u
operator|.
name|v4
operator|.
name|port
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
ifdef|#
directive|ifdef
name|INET6
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" %s"
operator|,
name|ip6addr_string
argument_list|(
name|ndo
argument_list|,
name|add_addr
operator|->
name|u
operator|.
name|v6
operator|.
name|addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|opt_len
operator|==
literal|22
condition|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|":%u"
operator|,
name|EXTRACT_16BITS
argument_list|(
name|add_addr
operator|->
name|u
operator|.
name|v6
operator|.
name|port
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|remove_addr_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|const
name|u_char
modifier|*
name|opt
parameter_list|,
name|u_int
name|opt_len
parameter_list|,
name|u_char
name|flags
name|_U_
parameter_list|)
block|{
name|struct
name|mp_remove_addr
modifier|*
name|remove_addr
init|=
operator|(
expr|struct
name|mp_remove_addr
operator|*
operator|)
name|opt
decl_stmt|;
name|uint8_t
modifier|*
name|addr_id
init|=
operator|&
name|remove_addr
operator|->
name|addrs_id
decl_stmt|;
if|if
condition|(
name|opt_len
operator|<
literal|4
condition|)
return|return
literal|0
return|;
name|opt_len
operator|-=
literal|3
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" id"
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|opt_len
operator|--
condition|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" %u"
operator|,
operator|*
name|addr_id
operator|++
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mp_prio_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|const
name|u_char
modifier|*
name|opt
parameter_list|,
name|u_int
name|opt_len
parameter_list|,
name|u_char
name|flags
name|_U_
parameter_list|)
block|{
name|struct
name|mp_prio
modifier|*
name|mpp
init|=
operator|(
expr|struct
name|mp_prio
operator|*
operator|)
name|opt
decl_stmt|;
if|if
condition|(
name|opt_len
operator|!=
literal|3
operator|&&
name|opt_len
operator|!=
literal|4
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mpp
operator|->
name|sub_b
operator|&
name|MP_PRIO_B
condition|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" backup"
operator|)
argument_list|)
expr_stmt|;
else|else
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" non-backup"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_len
operator|==
literal|4
condition|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" id %u"
operator|,
name|mpp
operator|->
name|addr_id
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mp_fail_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|const
name|u_char
modifier|*
name|opt
parameter_list|,
name|u_int
name|opt_len
parameter_list|,
name|u_char
name|flags
name|_U_
parameter_list|)
block|{
if|if
condition|(
name|opt_len
operator|!=
literal|12
condition|)
return|return
literal|0
return|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" seq %"
name|PRIu64
operator|,
name|EXTRACT_64BITS
argument_list|(
name|opt
operator|+
literal|4
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mp_fast_close_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|const
name|u_char
modifier|*
name|opt
parameter_list|,
name|u_int
name|opt_len
parameter_list|,
name|u_char
name|flags
name|_U_
parameter_list|)
block|{
if|if
condition|(
name|opt_len
operator|!=
literal|12
condition|)
return|return
literal|0
return|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" key 0x%"
name|PRIx64
operator|,
name|EXTRACT_64BITS
argument_list|(
name|opt
operator|+
literal|4
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_struct
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
function_decl|(
modifier|*
name|print
function_decl|)
parameter_list|(
name|netdissect_options
modifier|*
parameter_list|,
specifier|const
name|u_char
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|u_char
parameter_list|)
function_decl|;
block|}
name|mptcp_options
index|[]
init|=
block|{
block|{
literal|"capable"
block|,
name|mp_capable_print
block|}
block|,
block|{
literal|"join"
block|,
name|mp_join_print
block|}
block|,
block|{
literal|"dss"
block|,
name|mp_dss_print
block|}
block|,
block|{
literal|"add-addr"
block|,
name|add_addr_print
block|}
block|,
block|{
literal|"rem-addr"
block|,
name|remove_addr_print
block|}
block|,
block|{
literal|"prio"
block|,
name|mp_prio_print
block|}
block|,
block|{
literal|"fail"
block|,
name|mp_fail_print
block|}
block|,
block|{
literal|"fast-close"
block|,
name|mp_fast_close_print
block|}
block|,
block|{
literal|"unknown"
block|,
name|dummy_print
block|}
block|, }
struct|;
end_struct

begin_function
name|int
name|mptcp_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|const
name|u_char
modifier|*
name|cp
parameter_list|,
name|u_int
name|len
parameter_list|,
name|u_char
name|flags
parameter_list|)
block|{
name|struct
name|mptcp_option
modifier|*
name|opt
decl_stmt|;
name|u_int
name|subtype
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|3
condition|)
return|return
literal|0
return|;
name|opt
operator|=
operator|(
expr|struct
name|mptcp_option
operator|*
operator|)
name|cp
expr_stmt|;
name|subtype
operator|=
name|min
argument_list|(
name|MPTCP_OPT_SUBTYPE
argument_list|(
name|opt
operator|->
name|sub_etc
argument_list|)
argument_list|,
name|MPTCP_SUB_FCLOSE
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" %s"
operator|,
name|mptcp_options
index|[
name|subtype
index|]
operator|.
name|name
operator|)
argument_list|)
expr_stmt|;
return|return
name|mptcp_options
index|[
name|subtype
index|]
operator|.
name|print
argument_list|(
name|ndo
argument_list|,
name|cp
argument_list|,
name|len
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

end_unit

