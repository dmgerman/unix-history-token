begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 2000  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that: (1) source code distributions  * retain the above copyright notice and this paragraph in its entirety, (2)  * distributions including binary code include the above copyright notice and  * this paragraph in its entirety in the documentation or other materials  * provided with the distribution, and (3) all advertising materials mentioning  * features or use of this software display the following acknowledgement:  * ``This product includes software developed by the University of California,  * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of  * the University nor the names of its contributors may be used to endorse  * or promote products derived from this software without specific prior  * written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * Support for splitting captures into multiple files with a maximum  * file size:  *  * Copyright (c) 2001  *	Seth Webster<swebster@sst.ll.mit.edu>  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<netdissect-stdinc.h>
end_include

begin_include
include|#
directive|include
file|"netdissect.h"
end_include

begin_include
include|#
directive|include
file|"addrtoname.h"
end_include

begin_include
include|#
directive|include
file|"print.h"
end_include

begin_struct
struct|struct
name|printer
block|{
name|if_printer
name|f
decl_stmt|;
name|int
name|type
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|printer
name|printers
index|[]
init|=
block|{
block|{
name|ether_if_print
block|,
name|DLT_EN10MB
block|}
block|,
ifdef|#
directive|ifdef
name|DLT_IPNET
block|{
name|ipnet_if_print
block|,
name|DLT_IPNET
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLT_IEEE802_15_4
block|{
name|ieee802_15_4_if_print
block|,
name|DLT_IEEE802_15_4
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLT_IEEE802_15_4_NOFCS
block|{
name|ieee802_15_4_if_print
block|,
name|DLT_IEEE802_15_4_NOFCS
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLT_PPI
block|{
name|ppi_if_print
block|,
name|DLT_PPI
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLT_NETANALYZER
block|{
name|netanalyzer_if_print
block|,
name|DLT_NETANALYZER
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLT_NETANALYZER_TRANSPARENT
block|{
name|netanalyzer_transparent_if_print
block|,
name|DLT_NETANALYZER_TRANSPARENT
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|DLT_NFLOG
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_PCAP_NFLOG_H
argument_list|)
block|{
name|nflog_if_print
block|,
name|DLT_NFLOG
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLT_CIP
block|{
name|cip_if_print
block|,
name|DLT_CIP
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLT_ATM_CLIP
block|{
name|cip_if_print
block|,
name|DLT_ATM_CLIP
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLT_IP_OVER_FC
block|{
name|ipfc_if_print
block|,
name|DLT_IP_OVER_FC
block|}
block|,
endif|#
directive|endif
block|{
name|null_if_print
block|,
name|DLT_NULL
block|}
block|,
ifdef|#
directive|ifdef
name|DLT_LOOP
block|{
name|null_if_print
block|,
name|DLT_LOOP
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLT_APPLE_IP_OVER_IEEE1394
block|{
name|ap1394_if_print
block|,
name|DLT_APPLE_IP_OVER_IEEE1394
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|DLT_BLUETOOTH_HCI_H4_WITH_PHDR
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_PCAP_BLUETOOTH_H
argument_list|)
block|{
name|bt_if_print
block|,
name|DLT_BLUETOOTH_HCI_H4_WITH_PHDR
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLT_LANE8023
block|{
name|lane_if_print
block|,
name|DLT_LANE8023
block|}
block|,
endif|#
directive|endif
block|{
name|arcnet_if_print
block|,
name|DLT_ARCNET
block|}
block|,
ifdef|#
directive|ifdef
name|DLT_ARCNET_LINUX
block|{
name|arcnet_linux_if_print
block|,
name|DLT_ARCNET_LINUX
block|}
block|,
endif|#
directive|endif
block|{
name|raw_if_print
block|,
name|DLT_RAW
block|}
block|,
ifdef|#
directive|ifdef
name|DLT_IPV4
block|{
name|raw_if_print
block|,
name|DLT_IPV4
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLT_IPV6
block|{
name|raw_if_print
block|,
name|DLT_IPV6
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_PCAP_USB_H
ifdef|#
directive|ifdef
name|DLT_USB_LINUX
block|{
name|usb_linux_48_byte_print
block|,
name|DLT_USB_LINUX
block|}
block|,
endif|#
directive|endif
comment|/* DLT_USB_LINUX */
ifdef|#
directive|ifdef
name|DLT_USB_LINUX_MMAPPED
block|{
name|usb_linux_64_byte_print
block|,
name|DLT_USB_LINUX_MMAPPED
block|}
block|,
endif|#
directive|endif
comment|/* DLT_USB_LINUX_MMAPPED */
endif|#
directive|endif
comment|/* HAVE_PCAP_USB_H */
ifdef|#
directive|ifdef
name|DLT_SYMANTEC_FIREWALL
block|{
name|symantec_if_print
block|,
name|DLT_SYMANTEC_FIREWALL
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLT_C_HDLC
block|{
name|chdlc_if_print
block|,
name|DLT_C_HDLC
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLT_HDLC
block|{
name|chdlc_if_print
block|,
name|DLT_HDLC
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLT_PPP_ETHER
block|{
name|pppoe_if_print
block|,
name|DLT_PPP_ETHER
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|DLT_PFLOG
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_NET_IF_PFLOG_H
argument_list|)
block|{
name|pflog_if_print
block|,
name|DLT_PFLOG
block|}
block|,
endif|#
directive|endif
block|{
name|token_if_print
block|,
name|DLT_IEEE802
block|}
block|,
block|{
name|fddi_if_print
block|,
name|DLT_FDDI
block|}
block|,
ifdef|#
directive|ifdef
name|DLT_LINUX_SLL
block|{
name|sll_if_print
block|,
name|DLT_LINUX_SLL
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLT_FR
block|{
name|fr_if_print
block|,
name|DLT_FR
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLT_FRELAY
block|{
name|fr_if_print
block|,
name|DLT_FRELAY
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLT_MFR
block|{
name|mfr_if_print
block|,
name|DLT_MFR
block|}
block|,
endif|#
directive|endif
block|{
name|atm_if_print
block|,
name|DLT_ATM_RFC1483
block|}
block|,
ifdef|#
directive|ifdef
name|DLT_SUNATM
block|{
name|sunatm_if_print
block|,
name|DLT_SUNATM
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLT_ENC
block|{
name|enc_if_print
block|,
name|DLT_ENC
block|}
block|,
endif|#
directive|endif
block|{
name|sl_if_print
block|,
name|DLT_SLIP
block|}
block|,
ifdef|#
directive|ifdef
name|DLT_SLIP_BSDOS
block|{
name|sl_bsdos_if_print
block|,
name|DLT_SLIP_BSDOS
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLT_LTALK
block|{
name|ltalk_if_print
block|,
name|DLT_LTALK
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLT_JUNIPER_ATM1
block|{
name|juniper_atm1_print
block|,
name|DLT_JUNIPER_ATM1
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLT_JUNIPER_ATM2
block|{
name|juniper_atm2_print
block|,
name|DLT_JUNIPER_ATM2
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLT_JUNIPER_MFR
block|{
name|juniper_mfr_print
block|,
name|DLT_JUNIPER_MFR
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLT_JUNIPER_MLFR
block|{
name|juniper_mlfr_print
block|,
name|DLT_JUNIPER_MLFR
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLT_JUNIPER_MLPPP
block|{
name|juniper_mlppp_print
block|,
name|DLT_JUNIPER_MLPPP
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLT_JUNIPER_PPPOE
block|{
name|juniper_pppoe_print
block|,
name|DLT_JUNIPER_PPPOE
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLT_JUNIPER_PPPOE_ATM
block|{
name|juniper_pppoe_atm_print
block|,
name|DLT_JUNIPER_PPPOE_ATM
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLT_JUNIPER_GGSN
block|{
name|juniper_ggsn_print
block|,
name|DLT_JUNIPER_GGSN
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLT_JUNIPER_ES
block|{
name|juniper_es_print
block|,
name|DLT_JUNIPER_ES
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLT_JUNIPER_MONITOR
block|{
name|juniper_monitor_print
block|,
name|DLT_JUNIPER_MONITOR
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLT_JUNIPER_SERVICES
block|{
name|juniper_services_print
block|,
name|DLT_JUNIPER_SERVICES
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLT_JUNIPER_ETHER
block|{
name|juniper_ether_print
block|,
name|DLT_JUNIPER_ETHER
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLT_JUNIPER_PPP
block|{
name|juniper_ppp_print
block|,
name|DLT_JUNIPER_PPP
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLT_JUNIPER_FRELAY
block|{
name|juniper_frelay_print
block|,
name|DLT_JUNIPER_FRELAY
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLT_JUNIPER_CHDLC
block|{
name|juniper_chdlc_print
block|,
name|DLT_JUNIPER_CHDLC
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLT_PKTAP
block|{
name|pktap_if_print
block|,
name|DLT_PKTAP
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLT_IEEE802_11_RADIO
block|{
name|ieee802_11_radio_if_print
block|,
name|DLT_IEEE802_11_RADIO
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLT_IEEE802_11
block|{
name|ieee802_11_if_print
block|,
name|DLT_IEEE802_11
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLT_IEEE802_11_RADIO_AVS
block|{
name|ieee802_11_radio_avs_if_print
block|,
name|DLT_IEEE802_11_RADIO_AVS
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLT_PRISM_HEADER
block|{
name|prism_if_print
block|,
name|DLT_PRISM_HEADER
block|}
block|,
endif|#
directive|endif
block|{
name|ppp_if_print
block|,
name|DLT_PPP
block|}
block|,
ifdef|#
directive|ifdef
name|DLT_PPP_WITHDIRECTION
block|{
name|ppp_if_print
block|,
name|DLT_PPP_WITHDIRECTION
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLT_PPP_BSDOS
block|{
name|ppp_bsdos_if_print
block|,
name|DLT_PPP_BSDOS
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DLT_PPP_SERIAL
block|{
name|ppp_hdlc_if_print
block|,
name|DLT_PPP_SERIAL
block|}
block|,
endif|#
directive|endif
block|{
name|NULL
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|ndo_default_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|const
name|u_char
modifier|*
name|bp
parameter_list|,
name|u_int
name|length
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ndo_error
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(noreturn
end_function_decl

begin_ifdef
unit|))
ifdef|#
directive|ifdef
name|__ATTRIBUTE___FORMAT_OK
end_ifdef

begin_expr_stmt
name|__attribute__
argument_list|(
operator|(
name|format
argument_list|(
name|printf
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
operator|)
argument_list|)
endif|#
directive|endif
comment|/* __ATTRIBUTE___FORMAT_OK */
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|ndo_warning
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
ifdef|#
directive|ifdef
name|__ATTRIBUTE___FORMAT_OK
function_decl|__attribute__
parameter_list|(
function_decl|(format
parameter_list|(
name|printf
parameter_list|,
function_decl|2
operator|,
function_decl|3
end_function_decl

begin_endif
unit|)))
endif|#
directive|endif
end_endif

begin_comment
comment|/* __ATTRIBUTE___FORMAT_OK */
end_comment

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|int
name|ndo_printf
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
ifdef|#
directive|ifdef
name|__ATTRIBUTE___FORMAT_OK
function_decl|__attribute
parameter_list|(
function_decl|(format
parameter_list|(
name|printf
parameter_list|,
function_decl|2
operator|,
function_decl|3
end_function_decl

begin_endif
unit|)))
endif|#
directive|endif
end_endif

begin_comment
comment|/* __ATTRIBUTE___FORMAT_OK */
end_comment

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function
name|void
name|init_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
name|uint32_t
name|localnet
parameter_list|,
name|uint32_t
name|mask
parameter_list|,
name|uint32_t
name|timezone_offset
parameter_list|)
block|{
name|thiszone
operator|=
name|timezone_offset
expr_stmt|;
name|init_addrtoname
argument_list|(
name|ndo
argument_list|,
name|localnet
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|init_checksum
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|if_printer
name|lookup_printer
parameter_list|(
name|int
name|type
parameter_list|)
block|{
specifier|const
name|struct
name|printer
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|printers
init|;
name|p
operator|->
name|f
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|type
operator|==
name|p
operator|->
name|type
condition|)
return|return
name|p
operator|->
name|f
return|;
if|#
directive|if
name|defined
argument_list|(
name|DLT_USER2
argument_list|)
operator|&&
name|defined
argument_list|(
name|DLT_PKTAP
argument_list|)
comment|/* 	 * Apple incorrectly chose to use DLT_USER2 for their PKTAP 	 * header. 	 * 	 * We map DLT_PKTAP, whether it's DLT_USER2 as it is on Darwin- 	 * based OSes or the same value as LINKTYPE_PKTAP as it is on 	 * other OSes, to LINKTYPE_PKTAP, so files written with 	 * this version of libpcap for a DLT_PKTAP capture have a link- 	 * layer header type of LINKTYPE_PKTAP. 	 * 	 * However, files written on OS X Mavericks for a DLT_PKTAP 	 * capture have a link-layer header type of LINKTYPE_USER2. 	 * If we don't have a printer for DLT_USER2, and type is 	 * DLT_USER2, we look up the printer for DLT_PKTAP and use 	 * that. 	 */
if|if
condition|(
name|type
operator|==
name|DLT_USER2
condition|)
block|{
for|for
control|(
name|p
operator|=
name|printers
init|;
name|p
operator|->
name|f
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|DLT_PKTAP
operator|==
name|p
operator|->
name|type
condition|)
return|return
name|p
operator|->
name|f
return|;
block|}
endif|#
directive|endif
return|return
name|NULL
return|;
comment|/* NOTREACHED */
block|}
end_function

begin_function
name|int
name|has_printer
parameter_list|(
name|int
name|type
parameter_list|)
block|{
return|return
operator|(
name|lookup_printer
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|if_printer
name|get_if_printer
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
name|int
name|type
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|dltname
decl_stmt|;
name|if_printer
name|printer
decl_stmt|;
name|printer
operator|=
name|lookup_printer
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|printer
operator|==
name|NULL
condition|)
block|{
name|dltname
operator|=
name|pcap_datalink_val_to_name
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|dltname
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ndo
operator|->
name|ndo_error
call|)
argument_list|(
name|ndo
argument_list|,
literal|"packet printing is not supported for link type %s: use -w"
argument_list|,
name|dltname
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|ndo
operator|->
name|ndo_error
call|)
argument_list|(
name|ndo
argument_list|,
literal|"packet printing is not supported for link type %d: use -w"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
return|return
name|printer
return|;
block|}
end_function

begin_function
name|void
name|pretty_print_packet
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|const
name|struct
name|pcap_pkthdr
modifier|*
name|h
parameter_list|,
specifier|const
name|u_char
modifier|*
name|sp
parameter_list|,
name|u_int
name|packets_captured
parameter_list|)
block|{
name|u_int
name|hdrlen
decl_stmt|;
if|if
condition|(
name|ndo
operator|->
name|ndo_packet_number
condition|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%5u  "
operator|,
name|packets_captured
operator|)
argument_list|)
expr_stmt|;
name|ts_print
argument_list|(
name|ndo
argument_list|,
operator|&
name|h
operator|->
name|ts
argument_list|)
expr_stmt|;
comment|/* 	 * Some printers want to check that they're not walking off the 	 * end of the packet. 	 * Rather than pass it all the way down, we set this member 	 * of the netdissect_options structure. 	 */
name|ndo
operator|->
name|ndo_snapend
operator|=
name|sp
operator|+
name|h
operator|->
name|caplen
expr_stmt|;
name|hdrlen
operator|=
call|(
name|ndo
operator|->
name|ndo_if_printer
call|)
argument_list|(
name|ndo
argument_list|,
name|h
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/* 	 * Restore the original snapend, as a printer might have 	 * changed it. 	 */
name|ndo
operator|->
name|ndo_snapend
operator|=
name|sp
operator|+
name|h
operator|->
name|caplen
expr_stmt|;
if|if
condition|(
name|ndo
operator|->
name|ndo_Xflag
condition|)
block|{
comment|/* 		 * Print the raw packet data in hex and ASCII. 		 */
if|if
condition|(
name|ndo
operator|->
name|ndo_Xflag
operator|>
literal|1
condition|)
block|{
comment|/* 			 * Include the link-layer header. 			 */
name|hex_and_ascii_print
argument_list|(
name|ndo
argument_list|,
literal|"\n\t"
argument_list|,
name|sp
argument_list|,
name|h
operator|->
name|caplen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Don't include the link-layer header - and if 			 * we have nothing past the link-layer header, 			 * print nothing. 			 */
if|if
condition|(
name|h
operator|->
name|caplen
operator|>
name|hdrlen
condition|)
name|hex_and_ascii_print
argument_list|(
name|ndo
argument_list|,
literal|"\n\t"
argument_list|,
name|sp
operator|+
name|hdrlen
argument_list|,
name|h
operator|->
name|caplen
operator|-
name|hdrlen
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ndo
operator|->
name|ndo_xflag
condition|)
block|{
comment|/* 		 * Print the raw packet data in hex. 		 */
if|if
condition|(
name|ndo
operator|->
name|ndo_xflag
operator|>
literal|1
condition|)
block|{
comment|/* 			 * Include the link-layer header. 			 */
name|hex_print
argument_list|(
name|ndo
argument_list|,
literal|"\n\t"
argument_list|,
name|sp
argument_list|,
name|h
operator|->
name|caplen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Don't include the link-layer header - and if 			 * we have nothing past the link-layer header, 			 * print nothing. 			 */
if|if
condition|(
name|h
operator|->
name|caplen
operator|>
name|hdrlen
condition|)
name|hex_print
argument_list|(
name|ndo
argument_list|,
literal|"\n\t"
argument_list|,
name|sp
operator|+
name|hdrlen
argument_list|,
name|h
operator|->
name|caplen
operator|-
name|hdrlen
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ndo
operator|->
name|ndo_Aflag
condition|)
block|{
comment|/* 		 * Print the raw packet data in ASCII. 		 */
if|if
condition|(
name|ndo
operator|->
name|ndo_Aflag
operator|>
literal|1
condition|)
block|{
comment|/* 			 * Include the link-layer header. 			 */
name|ascii_print
argument_list|(
name|ndo
argument_list|,
name|sp
argument_list|,
name|h
operator|->
name|caplen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Don't include the link-layer header - and if 			 * we have nothing past the link-layer header, 			 * print nothing. 			 */
if|if
condition|(
name|h
operator|->
name|caplen
operator|>
name|hdrlen
condition|)
name|ascii_print
argument_list|(
name|ndo
argument_list|,
name|sp
operator|+
name|hdrlen
argument_list|,
name|h
operator|->
name|caplen
operator|-
name|hdrlen
argument_list|)
expr_stmt|;
block|}
block|}
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * By default, print the specified data out in hex and ASCII.  */
end_comment

begin_function
specifier|static
name|void
name|ndo_default_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|const
name|u_char
modifier|*
name|bp
parameter_list|,
name|u_int
name|length
parameter_list|)
block|{
name|hex_and_ascii_print
argument_list|(
name|ndo
argument_list|,
literal|"\n\t"
argument_list|,
name|bp
argument_list|,
name|length
argument_list|)
expr_stmt|;
comment|/* pass on lf and indentation string */
block|}
end_function

begin_comment
comment|/* VARARGS */
end_comment

begin_function
specifier|static
name|void
name|ndo_error
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
name|ndo
operator|->
name|program_name
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|ndo
operator|->
name|program_name
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|fmt
condition|)
block|{
name|fmt
operator|+=
name|strlen
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|nd_cleanup
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/* VARARGS */
end_comment

begin_function
specifier|static
name|void
name|ndo_warning
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
name|ndo
operator|->
name|program_name
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|ndo
operator|->
name|program_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"WARNING: "
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|fmt
condition|)
block|{
name|fmt
operator|+=
name|strlen
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ndo_printf
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|ret
operator|=
name|vfprintf
argument_list|(
name|stdout
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
name|ndo_error
argument_list|(
name|ndo
argument_list|,
literal|"Unable to write output: %s"
argument_list|,
name|pcap_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ndo_set_function_pointers
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|)
block|{
name|ndo
operator|->
name|ndo_default_print
operator|=
name|ndo_default_print
expr_stmt|;
name|ndo
operator|->
name|ndo_printf
operator|=
name|ndo_printf
expr_stmt|;
name|ndo
operator|->
name|ndo_error
operator|=
name|ndo_error
expr_stmt|;
name|ndo
operator|->
name|ndo_warning
operator|=
name|ndo_warning
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Local Variables:  * c-style: whitesmith  * c-basic-offset: 8  * End:  */
end_comment

end_unit

