begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1990, 1991, 1993, 1994, 1995, 1996, 1997  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that: (1) source code distributions  * retain the above copyright notice and this paragraph in its entirety, (2)  * distributions including binary code include the above copyright notice and  * this paragraph in its entirety in the documentation or other materials  * provided with the distribution, and (3) all advertising materials mentioning  * features or use of this software display the following acknowledgement:  * ``This product includes software developed by the University of California,  * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of  * the University nor the names of its contributors may be used to endorse  * or promote products derived from this software without specific prior  * written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * Extensively modified by Motonori Shindo (mshindo@mshindo.net) for more  * complete PPP support.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * TODO:  * o resolve XXX as much as possible  * o MP support  * o BAP support  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"@(#) $Header: /tcpdump/master/tcpdump/print-ppp.c,v 1.58 2000/12/27 11:09:08 itojun Exp $ (LBL)"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__bsdi__
end_ifdef

begin_include
include|#
directive|include
file|<net/slcompress.h>
end_include

begin_include
include|#
directive|include
file|<net/if_ppp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<pcap.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"interface.h"
end_include

begin_include
include|#
directive|include
file|"extract.h"
end_include

begin_include
include|#
directive|include
file|"addrtoname.h"
end_include

begin_include
include|#
directive|include
file|"ppp.h"
end_include

begin_include
include|#
directive|include
file|"chdlc.h"
end_include

begin_include
include|#
directive|include
file|"ethertype.h"
end_include

begin_comment
comment|/*  * The following constatns are defined by IANA. Please refer to  *    http://www.isi.edu/in-notes/iana/assignments/ppp-numbers  * for the up-to-date information.  */
end_comment

begin_comment
comment|/* Control Protocols (LCP/IPCP/CCP etc.) Codes */
end_comment

begin_define
define|#
directive|define
name|CPCODES_VEXT
value|0
end_define

begin_comment
comment|/* Vendor-Specific (RFC2153) */
end_comment

begin_define
define|#
directive|define
name|CPCODES_CONF_REQ
value|1
end_define

begin_comment
comment|/* Configure-Request */
end_comment

begin_define
define|#
directive|define
name|CPCODES_CONF_ACK
value|2
end_define

begin_comment
comment|/* Configure-Ack */
end_comment

begin_define
define|#
directive|define
name|CPCODES_CONF_NAK
value|3
end_define

begin_comment
comment|/* Configure-Nak */
end_comment

begin_define
define|#
directive|define
name|CPCODES_CONF_REJ
value|4
end_define

begin_comment
comment|/* Configure-Reject */
end_comment

begin_define
define|#
directive|define
name|CPCODES_TERM_REQ
value|5
end_define

begin_comment
comment|/* Terminate-Request */
end_comment

begin_define
define|#
directive|define
name|CPCODES_TERM_ACK
value|6
end_define

begin_comment
comment|/* Terminate-Ack */
end_comment

begin_define
define|#
directive|define
name|CPCODES_CODE_REJ
value|7
end_define

begin_comment
comment|/* Code-Reject */
end_comment

begin_define
define|#
directive|define
name|CPCODES_PROT_REJ
value|8
end_define

begin_comment
comment|/* Protocol-Reject (LCP only) */
end_comment

begin_define
define|#
directive|define
name|CPCODES_ECHO_REQ
value|9
end_define

begin_comment
comment|/* Echo-Request (LCP only) */
end_comment

begin_define
define|#
directive|define
name|CPCODES_ECHO_RPL
value|10
end_define

begin_comment
comment|/* Echo-Reply (LCP only) */
end_comment

begin_define
define|#
directive|define
name|CPCODES_DISC_REQ
value|11
end_define

begin_comment
comment|/* Discard-Request (LCP only) */
end_comment

begin_define
define|#
directive|define
name|CPCODES_ID
value|12
end_define

begin_comment
comment|/* Identification (LCP only) */
end_comment

begin_define
define|#
directive|define
name|CPCODES_TIME_REM
value|13
end_define

begin_comment
comment|/* Time-Remaining (LCP only) */
end_comment

begin_define
define|#
directive|define
name|CPCODES_RESET_REQ
value|14
end_define

begin_comment
comment|/* Reset-Request (CCP only) */
end_comment

begin_define
define|#
directive|define
name|CPCODES_RESET_REP
value|15
end_define

begin_comment
comment|/* Reset-Reply (CCP only) */
end_comment

begin_define
define|#
directive|define
name|CPCODES_MIN
value|CPCODES_VEXT
end_define

begin_define
define|#
directive|define
name|CPCODES_MAX
value|CPCODES_RESET_REP
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|cpcodes
index|[]
init|=
block|{
comment|/* 	 * Control Protocol code values (RFC1661) 	 */
literal|"Vend-Ext"
block|,
comment|/* (0) RFC2153 */
literal|"Conf-Req"
block|,
comment|/* (1) */
literal|"Conf-Ack"
block|,
comment|/* (2) */
literal|"Conf-Nak"
block|,
comment|/* (3) */
literal|"Conf-Rej"
block|,
comment|/* (4) */
literal|"Term-Req"
block|,
comment|/* (5) */
literal|"Term-Ack"
block|,
comment|/* (6) */
literal|"Code-Rej"
block|,
comment|/* (7) */
literal|"Prot-Rej"
block|,
comment|/* (8) */
literal|"Echo-Req"
block|,
comment|/* (9) */
literal|"Echo-Rep"
block|,
comment|/* (10) */
literal|"Disc-Req"
block|,
comment|/* (11) */
literal|"Ident"
block|,
comment|/* (12) RFC1570 */
literal|"Time-Rem"
block|,
comment|/* (13) RFC1570 */
literal|"Reset-Req"
block|,
comment|/* (14) RFC1962 */
literal|"Reset-Ack"
block|,
comment|/* (15) RFC1962 */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* LCP Config Options */
end_comment

begin_define
define|#
directive|define
name|LCPOPT_VEXT
value|0
end_define

begin_define
define|#
directive|define
name|LCPOPT_MRU
value|1
end_define

begin_define
define|#
directive|define
name|LCPOPT_ACCM
value|2
end_define

begin_define
define|#
directive|define
name|LCPOPT_AP
value|3
end_define

begin_define
define|#
directive|define
name|LCPOPT_QP
value|4
end_define

begin_define
define|#
directive|define
name|LCPOPT_MN
value|5
end_define

begin_define
define|#
directive|define
name|LCPOPT_DEP6
value|6
end_define

begin_define
define|#
directive|define
name|LCPOPT_PFC
value|7
end_define

begin_define
define|#
directive|define
name|LCPOPT_ACFC
value|8
end_define

begin_define
define|#
directive|define
name|LCPOPT_FCSALT
value|9
end_define

begin_define
define|#
directive|define
name|LCPOPT_SDP
value|10
end_define

begin_define
define|#
directive|define
name|LCPOPT_NUMMODE
value|11
end_define

begin_define
define|#
directive|define
name|LCPOPT_DEP12
value|12
end_define

begin_define
define|#
directive|define
name|LCPOPT_CBACK
value|13
end_define

begin_define
define|#
directive|define
name|LCPOPT_DEP14
value|14
end_define

begin_define
define|#
directive|define
name|LCPOPT_DEP15
value|15
end_define

begin_define
define|#
directive|define
name|LCPOPT_DEP16
value|16
end_define

begin_define
define|#
directive|define
name|LCPOPT_MLMRRU
value|17
end_define

begin_define
define|#
directive|define
name|LCPOPT_MLSSNHF
value|18
end_define

begin_define
define|#
directive|define
name|LCPOPT_MLED
value|19
end_define

begin_define
define|#
directive|define
name|LCPOPT_PROP
value|20
end_define

begin_define
define|#
directive|define
name|LCPOPT_DCEID
value|21
end_define

begin_define
define|#
directive|define
name|LCPOPT_MPP
value|22
end_define

begin_define
define|#
directive|define
name|LCPOPT_LD
value|23
end_define

begin_define
define|#
directive|define
name|LCPOPT_LCPAOPT
value|24
end_define

begin_define
define|#
directive|define
name|LCPOPT_COBS
value|25
end_define

begin_define
define|#
directive|define
name|LCPOPT_PE
value|26
end_define

begin_define
define|#
directive|define
name|LCPOPT_MLHF
value|27
end_define

begin_define
define|#
directive|define
name|LCPOPT_I18N
value|28
end_define

begin_define
define|#
directive|define
name|LCPOPT_SDLOS
value|29
end_define

begin_define
define|#
directive|define
name|LCPOPT_PPPMUX
value|30
end_define

begin_define
define|#
directive|define
name|LCPOPT_MIN
value|LCPOPT_VEXT
end_define

begin_define
define|#
directive|define
name|LCPOPT_MAX
value|LCPOPT_PPPMUX
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|lcpconfopts
index|[]
init|=
block|{
literal|"Vend-Ext"
block|,
comment|/* (0) */
literal|"MRU"
block|,
comment|/* (1) */
literal|"ACCM"
block|,
comment|/* (2) */
literal|"Auth-Prot"
block|,
comment|/* (3) */
literal|"Qual-Prot"
block|,
comment|/* (4) */
literal|"Magic-Num"
block|,
comment|/* (5) */
literal|"deprecated(6)"
block|,
comment|/* used to be a Quality Protocol */
literal|"PFC"
block|,
comment|/* (7) */
literal|"ACFC"
block|,
comment|/* (8) */
literal|"FCS-Alt"
block|,
comment|/* (9) */
literal|"SDP"
block|,
comment|/* (10) */
literal|"Num-Mode"
block|,
comment|/* (11) */
literal|"deprecated(12)"
block|,
comment|/* used to be a Multi-Link-Procedure*/
literal|"Call-Back"
block|,
comment|/* (13) */
literal|"deprecated(14)"
block|,
comment|/* used to be a Connect-Time */
literal|"deprecated(15)"
block|,
comment|/* used to be a Compund-Frames */
literal|"deprecated(16)"
block|,
comment|/* used to be a Nominal-Data-Encap */
literal|"MRRU"
block|,
comment|/* (17) */
literal|"SSNHF"
block|,
comment|/* (18) */
literal|"End-Disc"
block|,
comment|/* (19) */
literal|"Proprietary"
block|,
comment|/* (20) */
literal|"DCE-Id"
block|,
comment|/* (21) */
literal|"MP+"
block|,
comment|/* (22) */
literal|"Link-Disc"
block|,
comment|/* (23) */
literal|"LCP-Auth-Opt"
block|,
comment|/* (24) */
literal|"COBS"
block|,
comment|/* (25) */
literal|"Prefix-elision"
block|,
comment|/* (26) */
literal|"Multilink-header-Form"
block|,
comment|/* (27) */
literal|"I18N"
block|,
comment|/* (28) */
literal|"SDL-over-SONET/SDH"
block|,
comment|/* (29) */
literal|"PPP-Muxing"
block|,
comment|/* (30) */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* IPV6CP - to be supported */
end_comment

begin_comment
comment|/* ECP - to be supported */
end_comment

begin_comment
comment|/* CCP Config Options */
end_comment

begin_define
define|#
directive|define
name|CCPOPT_OUI
value|0
end_define

begin_comment
comment|/* RFC1962 */
end_comment

begin_define
define|#
directive|define
name|CCPOPT_PRED1
value|1
end_define

begin_comment
comment|/* RFC1962 */
end_comment

begin_define
define|#
directive|define
name|CCPOPT_PRED2
value|2
end_define

begin_comment
comment|/* RFC1962 */
end_comment

begin_define
define|#
directive|define
name|CCPOPT_PJUMP
value|3
end_define

begin_comment
comment|/* RFC1962 */
end_comment

begin_comment
comment|/* 4-15 unassigned */
end_comment

begin_define
define|#
directive|define
name|CCPOPT_HPPPC
value|16
end_define

begin_comment
comment|/* RFC1962 */
end_comment

begin_define
define|#
directive|define
name|CCPOPT_STACLZS
value|17
end_define

begin_comment
comment|/* RFC1974 */
end_comment

begin_define
define|#
directive|define
name|CCPOPT_MPPC
value|18
end_define

begin_comment
comment|/* RFC2118 */
end_comment

begin_define
define|#
directive|define
name|CCPOPT_GFZA
value|19
end_define

begin_comment
comment|/* RFC1962 */
end_comment

begin_define
define|#
directive|define
name|CCPOPT_V42BIS
value|20
end_define

begin_comment
comment|/* RFC1962 */
end_comment

begin_define
define|#
directive|define
name|CCPOPT_BSDCOMP
value|21
end_define

begin_comment
comment|/* RFC1977 */
end_comment

begin_comment
comment|/* 22 unassigned */
end_comment

begin_define
define|#
directive|define
name|CCPOPT_LZSDCP
value|23
end_define

begin_comment
comment|/* RFC1967 */
end_comment

begin_define
define|#
directive|define
name|CCPOPT_MVRCA
value|24
end_define

begin_comment
comment|/* RFC1975 */
end_comment

begin_define
define|#
directive|define
name|CCPOPT_DEC
value|25
end_define

begin_comment
comment|/* RFC1976 */
end_comment

begin_define
define|#
directive|define
name|CCPOPT_DEFLATE
value|26
end_define

begin_comment
comment|/* RFC1979 */
end_comment

begin_comment
comment|/* 27-254 unassigned */
end_comment

begin_define
define|#
directive|define
name|CCPOPT_RESV
value|255
end_define

begin_comment
comment|/* RFC1962 */
end_comment

begin_define
define|#
directive|define
name|CCPOPT_MIN
value|CCPOPT_OUI
end_define

begin_define
define|#
directive|define
name|CCPOPT_MAX
value|CCPOPT_DEFLATE
end_define

begin_comment
comment|/* XXX: should be CCPOPT_RESV but... */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ccpconfopts
index|[]
init|=
block|{
literal|"OUI"
block|,
comment|/* (0) */
literal|"Pred-1"
block|,
comment|/* (1) */
literal|"Pred-2"
block|,
comment|/* (2) */
literal|"Puddle"
block|,
comment|/* (3) */
literal|"unassigned(4)"
block|,
comment|/* (4) */
literal|"unassigned(5)"
block|,
comment|/* (5) */
literal|"unassigned(6)"
block|,
comment|/* (6) */
literal|"unassigned(7)"
block|,
comment|/* (7) */
literal|"unassigned(8)"
block|,
comment|/* (8) */
literal|"unassigned(9)"
block|,
comment|/* (9) */
literal|"unassigned(10)"
block|,
comment|/* (10) */
literal|"unassigned(11)"
block|,
comment|/* (11) */
literal|"unassigned(12)"
block|,
comment|/* (12) */
literal|"unassigned(13)"
block|,
comment|/* (13) */
literal|"unassigned(14)"
block|,
comment|/* (14) */
literal|"unassigned(15)"
block|,
comment|/* (15) */
literal|"HP-PPC"
block|,
comment|/* (16) */
literal|"Stac-LZS"
block|,
comment|/* (17) */
literal|"MPPC"
block|,
comment|/* (18) */
literal|"Gand-FZA"
block|,
comment|/* (19) */
literal|"V.42bis"
block|,
comment|/* (20) */
literal|"BSD-Comp"
block|,
comment|/* (21) */
literal|"unassigned(22)"
block|,
comment|/* (22) */
literal|"LZS-DCP"
block|,
comment|/* (23) */
literal|"MVRCA"
block|,
comment|/* (24) */
literal|"DEC"
block|,
comment|/* (25) */
literal|"Deflate"
block|,
comment|/* (26) */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* BACP Config Options */
end_comment

begin_define
define|#
directive|define
name|BACPOPT_FPEER
value|1
end_define

begin_comment
comment|/* RFC2125 */
end_comment

begin_comment
comment|/* SDCP - to be supported */
end_comment

begin_comment
comment|/* IPCP Config Options */
end_comment

begin_define
define|#
directive|define
name|IPCPOPT_2ADDR
value|1
end_define

begin_comment
comment|/* RFC1172, RFC1332 (deprecated) */
end_comment

begin_define
define|#
directive|define
name|IPCPOPT_IPCOMP
value|2
end_define

begin_comment
comment|/* RFC1332 */
end_comment

begin_define
define|#
directive|define
name|IPCPOPT_ADDR
value|3
end_define

begin_comment
comment|/* RFC1332 */
end_comment

begin_define
define|#
directive|define
name|IPCPOPT_MOBILE4
value|4
end_define

begin_comment
comment|/* RFC2290 */
end_comment

begin_define
define|#
directive|define
name|IPCPOPT_PRIDNS
value|129
end_define

begin_comment
comment|/* RFC1877 */
end_comment

begin_define
define|#
directive|define
name|IPCPOPT_PRINBNS
value|130
end_define

begin_comment
comment|/* RFC1877 */
end_comment

begin_define
define|#
directive|define
name|IPCPOPT_SECDNS
value|131
end_define

begin_comment
comment|/* RFC1877 */
end_comment

begin_define
define|#
directive|define
name|IPCPOPT_SECNBNS
value|132
end_define

begin_comment
comment|/* RFC1877 */
end_comment

begin_comment
comment|/* ATCP - to be supported */
end_comment

begin_comment
comment|/* OSINLCP - to be supported */
end_comment

begin_comment
comment|/* BVCP - to be supported */
end_comment

begin_comment
comment|/* BCP - to be supported */
end_comment

begin_comment
comment|/* IPXCP - to be supported */
end_comment

begin_comment
comment|/* Auth Algorithms */
end_comment

begin_comment
comment|/* 0-4 Reserved (RFC1994) */
end_comment

begin_define
define|#
directive|define
name|AUTHALG_CHAPMD5
value|5
end_define

begin_comment
comment|/* RFC1994 */
end_comment

begin_define
define|#
directive|define
name|AUTHALG_MSCHAP1
value|128
end_define

begin_comment
comment|/* RFC2433 */
end_comment

begin_define
define|#
directive|define
name|AUTHALG_MSCHAP2
value|129
end_define

begin_comment
comment|/* RFC2795 */
end_comment

begin_comment
comment|/* FCS Alternatives - to be supported */
end_comment

begin_comment
comment|/* Multilink Endpoint Discriminator (RFC1717) */
end_comment

begin_define
define|#
directive|define
name|MEDCLASS_NULL
value|0
end_define

begin_comment
comment|/* Null Class */
end_comment

begin_define
define|#
directive|define
name|MEDCLASS_LOCAL
value|1
end_define

begin_comment
comment|/* Locally Assigned */
end_comment

begin_define
define|#
directive|define
name|MEDCLASS_IPV4
value|2
end_define

begin_comment
comment|/* Internet Protocol (IPv4) */
end_comment

begin_define
define|#
directive|define
name|MEDCLASS_MAC
value|3
end_define

begin_comment
comment|/* IEEE 802.1 global MAC address */
end_comment

begin_define
define|#
directive|define
name|MEDCLASS_MNB
value|4
end_define

begin_comment
comment|/* PPP Magic Number Block */
end_comment

begin_define
define|#
directive|define
name|MEDCLASS_PSNDN
value|5
end_define

begin_comment
comment|/* Public Switched Network Director Number */
end_comment

begin_comment
comment|/* PPP LCP Callback */
end_comment

begin_define
define|#
directive|define
name|CALLBACK_AUTH
value|0
end_define

begin_comment
comment|/* Location determined by user auth */
end_comment

begin_define
define|#
directive|define
name|CALLBACK_DSTR
value|1
end_define

begin_comment
comment|/* Dialing string */
end_comment

begin_define
define|#
directive|define
name|CALLBACK_LID
value|2
end_define

begin_comment
comment|/* Location identifier */
end_comment

begin_define
define|#
directive|define
name|CALLBACK_E164
value|3
end_define

begin_comment
comment|/* E.164 number */
end_comment

begin_define
define|#
directive|define
name|CALLBACK_X500
value|4
end_define

begin_comment
comment|/* X.500 distinguished name */
end_comment

begin_define
define|#
directive|define
name|CALLBACK_CBCP
value|6
end_define

begin_comment
comment|/* Location is determined during CBCP nego */
end_comment

begin_comment
comment|/* CHAP */
end_comment

begin_define
define|#
directive|define
name|CHAP_CHAL
value|1
end_define

begin_define
define|#
directive|define
name|CHAP_RESP
value|2
end_define

begin_define
define|#
directive|define
name|CHAP_SUCC
value|3
end_define

begin_define
define|#
directive|define
name|CHAP_FAIL
value|4
end_define

begin_define
define|#
directive|define
name|CHAP_CODEMIN
value|CHAP_CHAL
end_define

begin_define
define|#
directive|define
name|CHAP_CODEMAX
value|CHAP_FAIL
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|chapcode
index|[]
init|=
block|{
literal|"Chal"
block|,
comment|/* (1) */
literal|"Resp"
block|,
comment|/* (2) */
literal|"Succ"
block|,
comment|/* (3) */
literal|"Fail"
block|,
comment|/* (4) */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PAP */
end_comment

begin_define
define|#
directive|define
name|PAP_AREQ
value|1
end_define

begin_define
define|#
directive|define
name|PAP_AACK
value|2
end_define

begin_define
define|#
directive|define
name|PAP_ANAK
value|3
end_define

begin_define
define|#
directive|define
name|PAP_CODEMIN
value|PAP_AREQ
end_define

begin_define
define|#
directive|define
name|PAP_CODEMAX
value|PAP_ANAK
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|papcode
index|[]
init|=
block|{
literal|"Auth-Req"
block|,
comment|/* (1) */
literal|"Auth-Ack"
block|,
comment|/* (2) */
literal|"Auth-Nak"
block|,
comment|/* (3) */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* BAP */
end_comment

begin_define
define|#
directive|define
name|BAP_CALLREQ
value|1
end_define

begin_define
define|#
directive|define
name|BAP_CALLRES
value|2
end_define

begin_define
define|#
directive|define
name|BAP_CBREQ
value|3
end_define

begin_define
define|#
directive|define
name|BAP_CBRES
value|4
end_define

begin_define
define|#
directive|define
name|BAP_LDQREQ
value|5
end_define

begin_define
define|#
directive|define
name|BAP_LDQRES
value|6
end_define

begin_define
define|#
directive|define
name|BAP_CSIND
value|7
end_define

begin_define
define|#
directive|define
name|BAP_CSRES
value|8
end_define

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|ppp_protoname
parameter_list|(
name|u_int
name|proto
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_ctrl_proto
parameter_list|(
name|u_int
name|proto
parameter_list|,
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|length
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_chap
parameter_list|(
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|length
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_pap
parameter_list|(
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|length
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_bap
parameter_list|(
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|length
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|print_lcp_config_options
parameter_list|(
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|print_ipcp_config_options
parameter_list|(
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|print_ccp_config_options
parameter_list|(
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|print_bacp_config_options
parameter_list|(
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_ppp
parameter_list|(
name|u_int
name|proto
parameter_list|,
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|length
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ppp_protoname
parameter_list|(
name|u_int
name|proto
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|PPP_IP
case|:
return|return
literal|"IP"
return|;
case|case
name|PPP_IPV6
case|:
return|return
literal|"IPv6"
return|;
ifdef|#
directive|ifdef
name|PPP_XNS
case|case
name|PPP_XNS
case|:
return|return
literal|"XNS"
return|;
endif|#
directive|endif
case|case
name|PPP_IPX
case|:
return|return
literal|"IPX"
return|;
case|case
name|PPP_VJC
case|:
return|return
literal|"VJC"
return|;
case|case
name|PPP_VJNC
case|:
return|return
literal|"VJNC"
return|;
ifdef|#
directive|ifdef
name|PPP_COMP
case|case
name|PPP_COMP
case|:
return|return
literal|"COMP"
return|;
endif|#
directive|endif
case|case
name|PPP_IPCP
case|:
return|return
literal|"IPCP"
return|;
case|case
name|PPP_IPV6CP
case|:
return|return
literal|"IPv6CP"
return|;
case|case
name|PPP_IPXCP
case|:
return|return
literal|"IPXCP"
return|;
case|case
name|PPP_CCP
case|:
return|return
literal|"CCP"
return|;
case|case
name|PPP_LCP
case|:
return|return
literal|"LCP"
return|;
case|case
name|PPP_PAP
case|:
return|return
literal|"PAP"
return|;
ifdef|#
directive|ifdef
name|PPP_LQR
case|case
name|PPP_LQR
case|:
return|return
literal|"LQR"
return|;
endif|#
directive|endif
case|case
name|PPP_CHAP
case|:
return|return
literal|"CHAP"
return|;
case|case
name|PPP_BACP
case|:
return|return
literal|"BACP"
return|;
case|case
name|PPP_BAP
case|:
return|return
literal|"BAP"
return|;
default|default:
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"unknown-0x%04x"
argument_list|,
name|proto
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
block|}
end_function

begin_comment
comment|/* generic Control Protocol (e.g. LCP, IPCP, CCP, etc.) handler */
end_comment

begin_function
specifier|static
name|void
name|handle_ctrl_proto
parameter_list|(
name|u_int
name|proto
parameter_list|,
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|u_int
name|code
decl_stmt|,
name|len
decl_stmt|;
name|int
function_decl|(
modifier|*
name|pfunc
function_decl|)
parameter_list|(
specifier|const
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
name|int
name|x
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"[|%s]"
argument_list|,
name|ppp_protoname
argument_list|(
name|proto
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|length
operator|<
literal|4
condition|)
block|{
name|printf
argument_list|(
literal|"[|%s 0x%02x]"
argument_list|,
name|ppp_protoname
argument_list|(
name|proto
argument_list|)
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
name|code
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|>=
name|CPCODES_MIN
operator|)
operator|&&
operator|(
name|code
operator|<=
name|CPCODES_MAX
operator|)
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|cpcodes
index|[
name|code
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"0x%02x"
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return;
block|}
name|p
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"(%u)"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
comment|/* ID */
name|p
operator|++
expr_stmt|;
name|len
operator|=
name|EXTRACT_16BITS
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|length
operator|<=
literal|4
condition|)
return|return;
comment|/* there may be a NULL confreq etc. */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CPCODES_VEXT
case|:
if|if
condition|(
name|length
operator|<
literal|11
condition|)
break|break;
name|printf
argument_list|(
literal|", Magic-Num=%08x"
argument_list|,
name|EXTRACT_32BITS
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|printf
argument_list|(
literal|" OUI=%02x%02x%02x"
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
name|p
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* XXX: need to decode Kind and Value(s)? */
break|break;
case|case
name|CPCODES_CONF_REQ
case|:
case|case
name|CPCODES_CONF_ACK
case|:
case|case
name|CPCODES_CONF_NAK
case|:
case|case
name|CPCODES_CONF_REJ
case|:
name|x
operator|=
name|len
operator|-
literal|4
expr_stmt|;
comment|/* Code(1), Identifier(1) and Length(2) */
do|do
block|{
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|PPP_LCP
case|:
name|pfunc
operator|=
name|print_lcp_config_options
expr_stmt|;
break|break;
case|case
name|PPP_IPCP
case|:
name|pfunc
operator|=
name|print_ipcp_config_options
expr_stmt|;
break|break;
case|case
name|PPP_CCP
case|:
name|pfunc
operator|=
name|print_ccp_config_options
expr_stmt|;
break|break;
case|case
name|PPP_BACP
case|:
name|pfunc
operator|=
name|print_bacp_config_options
expr_stmt|;
break|break;
default|default:
comment|/* 				 * This should never happen, but we set 				 * "pfunc" to squelch uninitialized 				 * variable warnings from compilers. 				 */
name|pfunc
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|j
operator|=
call|(
modifier|*
name|pfunc
call|)
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
operator|)
operator|==
literal|0
condition|)
break|break;
name|x
operator|-=
name|j
expr_stmt|;
name|p
operator|+=
name|j
expr_stmt|;
block|}
do|while
condition|(
name|x
operator|>
literal|0
condition|)
do|;
break|break;
case|case
name|CPCODES_TERM_REQ
case|:
case|case
name|CPCODES_TERM_ACK
case|:
comment|/* XXX: need to decode Data? */
break|break;
case|case
name|CPCODES_CODE_REJ
case|:
comment|/* XXX: need to decode Rejected-Packet? */
break|break;
case|case
name|CPCODES_PROT_REJ
case|:
if|if
condition|(
name|length
operator|<
literal|6
condition|)
break|break;
name|printf
argument_list|(
literal|", Rejected-Protocol=%04x"
argument_list|,
name|EXTRACT_16BITS
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX: need to decode Rejected-Information? */
break|break;
case|case
name|CPCODES_ECHO_REQ
case|:
case|case
name|CPCODES_ECHO_RPL
case|:
case|case
name|CPCODES_DISC_REQ
case|:
case|case
name|CPCODES_ID
case|:
if|if
condition|(
name|length
operator|<
literal|8
condition|)
break|break;
name|printf
argument_list|(
literal|", Magic-Num=%08x"
argument_list|,
name|EXTRACT_32BITS
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX: need to decode Data? */
break|break;
case|case
name|CPCODES_TIME_REM
case|:
if|if
condition|(
name|length
operator|<
literal|12
condition|)
break|break;
name|printf
argument_list|(
literal|", Magic-Num=%08x"
argument_list|,
name|EXTRACT_32BITS
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Seconds-Remaining=%u"
argument_list|,
name|EXTRACT_32BITS
argument_list|(
name|p
operator|+
literal|4
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX: need to decode Message? */
break|break;
default|default:
name|printf
argument_list|(
literal|", unknown-Codes-0x%02x"
argument_list|,
name|code
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* LCP config options */
end_comment

begin_function
specifier|static
name|int
name|print_lcp_config_options
parameter_list|(
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|opt
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|2
condition|)
return|return
literal|0
return|;
name|len
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|opt
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|length
operator|<
name|len
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|opt
operator|>=
name|LCPOPT_MIN
operator|)
operator|&&
operator|(
name|opt
operator|<=
name|LCPOPT_MAX
operator|)
condition|)
name|printf
argument_list|(
literal|", %s"
argument_list|,
name|lcpconfopts
index|[
name|opt
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|", unknwhown-%d"
argument_list|,
name|opt
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
name|LCPOPT_VEXT
case|:
if|if
condition|(
name|len
operator|>=
literal|6
condition|)
block|{
name|printf
argument_list|(
literal|" OUI=%02x%02x%02x"
argument_list|,
name|p
index|[
literal|2
index|]
argument_list|,
name|p
index|[
literal|3
index|]
argument_list|,
name|p
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf(" kind=%02x", p[5]); 			printf(" val=") 			for (i = 0; i< len - 6; i++) { 				printf("%02x", p[6 + i]); 			}
endif|#
directive|endif
block|}
break|break;
case|case
name|LCPOPT_MRU
case|:
if|if
condition|(
name|len
operator|==
literal|4
condition|)
name|printf
argument_list|(
literal|"=%u"
argument_list|,
name|EXTRACT_16BITS
argument_list|(
name|p
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LCPOPT_ACCM
case|:
if|if
condition|(
name|len
operator|==
literal|6
condition|)
name|printf
argument_list|(
literal|"=%08x"
argument_list|,
name|EXTRACT_32BITS
argument_list|(
name|p
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LCPOPT_AP
case|:
if|if
condition|(
name|len
operator|>=
literal|4
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
literal|0xc0
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|0x23
condition|)
name|printf
argument_list|(
literal|" PAP"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
literal|0xc2
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|0x23
condition|)
block|{
name|printf
argument_list|(
literal|" CHAP/"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p
index|[
literal|4
index|]
condition|)
block|{
default|default:
name|printf
argument_list|(
literal|"unknown-algorithm-%u"
argument_list|,
name|p
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUTHALG_CHAPMD5
case|:
name|printf
argument_list|(
literal|"MD5"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUTHALG_MSCHAP1
case|:
name|printf
argument_list|(
literal|"MSCHAPv1"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUTHALG_MSCHAP2
case|:
name|printf
argument_list|(
literal|"MSCHAPv2"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
literal|0xc2
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|0x27
condition|)
name|printf
argument_list|(
literal|" EAP"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
literal|0xc0
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|0x27
condition|)
name|printf
argument_list|(
literal|" SPAP"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
literal|0xc1
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|0x23
condition|)
name|printf
argument_list|(
literal|" Old-SPAP"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"unknown"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LCPOPT_QP
case|:
if|if
condition|(
name|len
operator|>=
literal|4
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
literal|0xc0
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|0x25
condition|)
name|printf
argument_list|(
literal|" LQR"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" unknown"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LCPOPT_MN
case|:
if|if
condition|(
name|len
operator|==
literal|6
condition|)
name|printf
argument_list|(
literal|"=%08x"
argument_list|,
name|EXTRACT_32BITS
argument_list|(
name|p
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LCPOPT_PFC
case|:
break|break;
case|case
name|LCPOPT_ACFC
case|:
break|break;
case|case
name|LCPOPT_LD
case|:
if|if
condition|(
name|len
operator|==
literal|4
condition|)
name|printf
argument_list|(
literal|"=%04x"
argument_list|,
name|EXTRACT_16BITS
argument_list|(
name|p
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LCPOPT_CBACK
case|:
if|if
condition|(
name|len
operator|<
literal|3
condition|)
break|break;
switch|switch
condition|(
name|p
index|[
literal|2
index|]
condition|)
block|{
comment|/* Operation */
case|case
name|CALLBACK_AUTH
case|:
name|printf
argument_list|(
literal|" UserAuth"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALLBACK_DSTR
case|:
name|printf
argument_list|(
literal|" DialString"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALLBACK_LID
case|:
name|printf
argument_list|(
literal|" LocalID"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALLBACK_E164
case|:
name|printf
argument_list|(
literal|" E.164"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALLBACK_X500
case|:
name|printf
argument_list|(
literal|" X.500"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALLBACK_CBCP
case|:
name|printf
argument_list|(
literal|" CBCP"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|" unknown-operation=%u"
argument_list|,
name|p
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|LCPOPT_MLMRRU
case|:
if|if
condition|(
name|len
operator|==
literal|4
condition|)
name|printf
argument_list|(
literal|"=%u"
argument_list|,
name|EXTRACT_16BITS
argument_list|(
name|p
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LCPOPT_MLED
case|:
if|if
condition|(
name|len
operator|<
literal|3
condition|)
break|break;
switch|switch
condition|(
name|p
index|[
literal|2
index|]
condition|)
block|{
comment|/* class */
case|case
name|MEDCLASS_NULL
case|:
name|printf
argument_list|(
literal|" Null"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEDCLASS_LOCAL
case|:
name|printf
argument_list|(
literal|" Local"
argument_list|)
expr_stmt|;
comment|/* XXX */
break|break;
case|case
name|MEDCLASS_IPV4
case|:
if|if
condition|(
name|len
operator|!=
literal|7
condition|)
break|break;
name|printf
argument_list|(
literal|" IPv4=%s"
argument_list|,
name|ipaddr_string
argument_list|(
name|p
operator|+
literal|3
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEDCLASS_MAC
case|:
if|if
condition|(
name|len
operator|!=
literal|9
condition|)
break|break;
name|printf
argument_list|(
literal|" MAC=%02x:%02x:%02x:%02x:%02x:%02x"
argument_list|,
name|p
index|[
literal|3
index|]
argument_list|,
name|p
index|[
literal|4
index|]
argument_list|,
name|p
index|[
literal|5
index|]
argument_list|,
name|p
index|[
literal|6
index|]
argument_list|,
name|p
index|[
literal|7
index|]
argument_list|,
name|p
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEDCLASS_MNB
case|:
name|printf
argument_list|(
literal|" Magic-Num-Block"
argument_list|)
expr_stmt|;
comment|/* XXX */
break|break;
case|case
name|MEDCLASS_PSNDN
case|:
name|printf
argument_list|(
literal|" PSNDN"
argument_list|)
expr_stmt|;
comment|/* XXX */
break|break;
block|}
break|break;
comment|/* XXX: to be supported */
if|#
directive|if
literal|0
block|case LCPOPT_DEP6: 	case LCPOPT_FCSALT: 	case LCPOPT_SDP: 	case LCPOPT_NUMMODE: 	case LCPOPT_DEP12: 	case LCPOPT_DEP14: 	case LCPOPT_DEP15: 	case LCPOPT_DEP16: 	case LCPOPT_MLSSNHF: 	case LCPOPT_PROP: 	case LCPOPT_DCEID: 	case LCPOPT_MPP: 	case LCPOPT_LCPAOPT: 	case LCPOPT_COBS: 	case LCPOPT_PE: 	case LCPOPT_MLHF: 	case LCPOPT_I18N: 	case LCPOPT_SDLOS: 	case LCPOPT_PPPMUX: 		break;
endif|#
directive|endif
block|}
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* CHAP */
end_comment

begin_function
specifier|static
name|void
name|handle_chap
parameter_list|(
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|u_int
name|code
decl_stmt|,
name|len
decl_stmt|;
name|int
name|val_size
decl_stmt|,
name|name_size
decl_stmt|,
name|msg_size
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|p0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|p0
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"[|chap]"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|length
operator|<
literal|4
condition|)
block|{
name|printf
argument_list|(
literal|"[|chap 0x%02x]"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
name|code
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|>=
name|CHAP_CODEMIN
operator|)
operator|&&
operator|(
name|code
operator|<=
name|CHAP_CODEMAX
operator|)
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|chapcode
index|[
name|code
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"0x%02x"
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return;
block|}
name|p
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"(%u)"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
comment|/* ID */
name|p
operator|++
expr_stmt|;
name|len
operator|=
name|EXTRACT_16BITS
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* 	 * Note that this is a generic CHAP decoding routine. Since we 	 * don't know which flavor of CHAP (i.e. CHAP-MD5, MS-CHAPv1, 	 * MS-CHAPv2) is used at this point, we can't decode packet 	 * specifically to each algorithms. Instead, we simply decode 	 * the GCD (Gratest Common Denominator) for all algorithms. 	 */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CHAP_CHAL
case|:
case|case
name|CHAP_RESP
case|:
if|if
condition|(
name|length
operator|-
operator|(
name|p
operator|-
name|p0
operator|)
operator|<
literal|1
condition|)
return|return;
name|val_size
operator|=
operator|*
name|p
expr_stmt|;
comment|/* value size */
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|length
operator|-
operator|(
name|p
operator|-
name|p0
operator|)
operator|<
name|val_size
condition|)
return|return;
name|printf
argument_list|(
literal|", Value="
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|val_size
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|name_size
operator|=
name|len
operator|-
operator|(
name|p
operator|-
name|p0
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|", Name="
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|name_size
condition|;
name|i
operator|++
control|)
name|safeputchar
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHAP_SUCC
case|:
case|case
name|CHAP_FAIL
case|:
name|msg_size
operator|=
name|len
operator|-
operator|(
name|p
operator|-
name|p0
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|", Msg="
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msg_size
condition|;
name|i
operator|++
control|)
name|safeputchar
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* PAP (see RFC 1334) */
end_comment

begin_function
specifier|static
name|void
name|handle_pap
parameter_list|(
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|u_int
name|code
decl_stmt|,
name|len
decl_stmt|;
name|int
name|peerid_len
decl_stmt|,
name|passwd_len
decl_stmt|,
name|msg_len
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|p0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|p0
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"[|pap]"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|length
operator|<
literal|4
condition|)
block|{
name|printf
argument_list|(
literal|"[|pap 0x%02x]"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
name|code
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|>=
name|PAP_CODEMIN
operator|)
operator|&&
operator|(
name|code
operator|<=
name|PAP_CODEMAX
operator|)
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|papcode
index|[
name|code
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"0x%02x"
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return;
block|}
name|p
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"(%u)"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
comment|/* ID */
name|p
operator|++
expr_stmt|;
name|len
operator|=
name|EXTRACT_16BITS
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PAP_AREQ
case|:
if|if
condition|(
name|length
operator|-
operator|(
name|p
operator|-
name|p0
operator|)
operator|<
literal|1
condition|)
return|return;
name|peerid_len
operator|=
operator|*
name|p
expr_stmt|;
comment|/* Peer-ID Length */
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|length
operator|-
operator|(
name|p
operator|-
name|p0
operator|)
operator|<
name|peerid_len
condition|)
return|return;
name|printf
argument_list|(
literal|", Peer="
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|peerid_len
condition|;
name|i
operator|++
control|)
name|safeputchar
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|-
operator|(
name|p
operator|-
name|p0
operator|)
operator|<
literal|1
condition|)
return|return;
name|passwd_len
operator|=
operator|*
name|p
expr_stmt|;
comment|/* Password Length */
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|length
operator|-
operator|(
name|p
operator|-
name|p0
operator|)
operator|<
name|passwd_len
condition|)
return|return;
name|printf
argument_list|(
literal|", Name="
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|passwd_len
condition|;
name|i
operator|++
control|)
name|safeputchar
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
break|break;
case|case
name|PAP_AACK
case|:
case|case
name|PAP_ANAK
case|:
if|if
condition|(
name|length
operator|-
operator|(
name|p
operator|-
name|p0
operator|)
operator|<
literal|1
condition|)
return|return;
name|msg_len
operator|=
operator|*
name|p
expr_stmt|;
comment|/* Msg-Length */
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|length
operator|-
operator|(
name|p
operator|-
name|p0
operator|)
operator|<
name|msg_len
condition|)
return|return;
name|printf
argument_list|(
literal|", Msg="
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msg_len
condition|;
name|i
operator|++
control|)
name|safeputchar
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* BAP */
end_comment

begin_function
specifier|static
name|void
name|handle_bap
parameter_list|(
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|length
parameter_list|)
block|{
comment|/* XXX: to be supported!! */
block|}
end_function

begin_comment
comment|/* IPCP config options */
end_comment

begin_function
specifier|static
name|int
name|print_ipcp_config_options
parameter_list|(
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|opt
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|2
condition|)
return|return
literal|0
return|;
name|len
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|opt
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|length
operator|<
name|len
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
name|IPCPOPT_2ADDR
case|:
comment|/* deprecated */
if|if
condition|(
name|len
operator|!=
literal|10
condition|)
goto|goto
name|invlen
goto|;
name|printf
argument_list|(
literal|", IP-Addrs src=%s dst=%s"
argument_list|,
name|ipaddr_string
argument_list|(
name|p
operator|+
literal|2
argument_list|)
argument_list|,
name|ipaddr_string
argument_list|(
name|p
operator|+
literal|6
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPCPOPT_IPCOMP
case|:
if|if
condition|(
name|len
operator|<
literal|4
condition|)
goto|goto
name|invlen
goto|;
name|printf
argument_list|(
literal|", IP-Comp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|EXTRACT_16BITS
argument_list|(
name|p
operator|+
literal|2
argument_list|)
operator|==
name|PPP_VJC
condition|)
block|{
name|printf
argument_list|(
literal|" VJ-Comp"
argument_list|)
expr_stmt|;
comment|/* XXX: VJ-Comp parameters should be decoded */
block|}
else|else
name|printf
argument_list|(
literal|" unknown-comp-proto=%04x"
argument_list|,
name|EXTRACT_16BITS
argument_list|(
name|p
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPCPOPT_ADDR
case|:
if|if
condition|(
name|len
operator|!=
literal|6
condition|)
goto|goto
name|invlen
goto|;
name|printf
argument_list|(
literal|", IP-Addr=%s"
argument_list|,
name|ipaddr_string
argument_list|(
name|p
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPCPOPT_MOBILE4
case|:
if|if
condition|(
name|len
operator|!=
literal|6
condition|)
goto|goto
name|invlen
goto|;
name|printf
argument_list|(
literal|", Home-Addr=%s"
argument_list|,
name|ipaddr_string
argument_list|(
name|p
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPCPOPT_PRIDNS
case|:
if|if
condition|(
name|len
operator|!=
literal|6
condition|)
goto|goto
name|invlen
goto|;
name|printf
argument_list|(
literal|", Pri-DNS=%s"
argument_list|,
name|ipaddr_string
argument_list|(
name|p
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPCPOPT_PRINBNS
case|:
if|if
condition|(
name|len
operator|!=
literal|6
condition|)
goto|goto
name|invlen
goto|;
name|printf
argument_list|(
literal|", Pri-NBNS=%s"
argument_list|,
name|ipaddr_string
argument_list|(
name|p
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPCPOPT_SECDNS
case|:
if|if
condition|(
name|len
operator|!=
literal|6
condition|)
goto|goto
name|invlen
goto|;
name|printf
argument_list|(
literal|", Sec-DNS=%s"
argument_list|,
name|ipaddr_string
argument_list|(
name|p
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPCPOPT_SECNBNS
case|:
if|if
condition|(
name|len
operator|!=
literal|6
condition|)
goto|goto
name|invlen
goto|;
name|printf
argument_list|(
literal|", Sec-NBNS=%s"
argument_list|,
name|ipaddr_string
argument_list|(
name|p
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|", unknown-%d"
argument_list|,
name|opt
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|len
return|;
name|invlen
label|:
name|printf
argument_list|(
literal|", invalid-length-%d"
argument_list|,
name|opt
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* CCP config options */
end_comment

begin_function
specifier|static
name|int
name|print_ccp_config_options
parameter_list|(
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|opt
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|2
condition|)
return|return
literal|0
return|;
name|len
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|opt
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|length
operator|<
name|len
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|opt
operator|>=
name|CCPOPT_MIN
operator|)
operator|&&
operator|(
name|opt
operator|<=
name|CCPOPT_MAX
operator|)
condition|)
name|printf
argument_list|(
literal|", %s"
argument_list|,
name|ccpconfopts
index|[
name|opt
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX */
block|switch (opt) { 	case CCPOPT_OUI: 	case CCPOPT_PRED1: 	case CCPOPT_PRED2: 	case CCPOPT_PJUMP: 	case CCPOPT_HPPPC: 	case CCPOPT_STACLZS: 	case CCPOPT_MPPC: 	case CCPOPT_GFZA: 	case CCPOPT_V42BIS: 	case CCPOPT_BSDCOMP: 	case CCPOPT_LZSDCP: 	case CCPOPT_MVRCA: 	case CCPOPT_DEC: 	case CCPOPT_DEFLATE: 	case CCPOPT_RESV: 		break;  	default: 		printf(", unknown-%d", opt); 		break; 	}
endif|#
directive|endif
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* BACP config options */
end_comment

begin_function
specifier|static
name|int
name|print_bacp_config_options
parameter_list|(
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|opt
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|2
condition|)
return|return
literal|0
return|;
name|len
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|opt
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|length
operator|<
name|len
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|opt
operator|==
name|BACPOPT_FPEER
condition|)
block|{
name|printf
argument_list|(
literal|", Favored-Peer"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Magic-Num=%08x"
argument_list|,
name|EXTRACT_32BITS
argument_list|(
name|p
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|", unknown-option-%d"
argument_list|,
name|opt
argument_list|)
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* PPP */
end_comment

begin_function
specifier|static
name|void
name|handle_ppp
parameter_list|(
name|u_int
name|proto
parameter_list|,
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|length
parameter_list|)
block|{
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|PPP_LCP
case|:
case|case
name|PPP_IPCP
case|:
case|case
name|PPP_CCP
case|:
case|case
name|PPP_BACP
case|:
name|handle_ctrl_proto
argument_list|(
name|proto
argument_list|,
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPP_CHAP
case|:
name|handle_chap
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPP_PAP
case|:
name|handle_pap
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPP_BAP
case|:
comment|/* XXX: not yet completed */
name|handle_bap
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|ETHERTYPE_IP
case|:
comment|/*XXX*/
case|case
name|PPP_IP
case|:
name|ip_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|ETHERTYPE_IPV6
case|:
comment|/*XXX*/
case|case
name|PPP_IPV6
case|:
name|ip6_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|ETHERTYPE_IPX
case|:
comment|/*XXX*/
case|case
name|PPP_IPX
case|:
name|ipx_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Standard PPP printer */
end_comment

begin_function
name|void
name|ppp_print
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|u_int
name|length
parameter_list|)
block|{
name|u_int
name|proto
decl_stmt|;
name|u_int
name|full_length
init|=
name|length
decl_stmt|;
comment|/* 	 * Here, we assume that p points to the Address and Control 	 * field (if they present). 	 */
if|if
condition|(
name|length
operator|<
literal|2
condition|)
goto|goto
name|trunc
goto|;
if|if
condition|(
operator|*
name|p
operator|==
name|PPP_ADDRESS
operator|&&
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
name|PPP_CONTROL
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* ACFC not used */
name|length
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|<
literal|2
condition|)
goto|goto
name|trunc
goto|;
if|if
condition|(
operator|*
name|p
operator|%
literal|2
condition|)
block|{
name|proto
operator|=
operator|*
name|p
expr_stmt|;
comment|/* PFC is used */
name|p
operator|++
expr_stmt|;
name|length
operator|--
expr_stmt|;
block|}
else|else
block|{
name|proto
operator|=
name|EXTRACT_16BITS
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
name|length
operator|-=
literal|2
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s %d: "
argument_list|,
name|ppp_protoname
argument_list|(
name|proto
argument_list|)
argument_list|,
name|full_length
argument_list|)
expr_stmt|;
name|handle_ppp
argument_list|(
name|proto
argument_list|,
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
name|trunc
label|:
name|printf
argument_list|(
literal|"[|ppp]"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* PPP I/F printer */
end_comment

begin_function
name|void
name|ppp_if_print
parameter_list|(
name|u_char
modifier|*
name|user
parameter_list|,
specifier|const
name|struct
name|pcap_pkthdr
modifier|*
name|h
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|p
parameter_list|)
block|{
specifier|register
name|u_int
name|length
init|=
name|h
operator|->
name|len
decl_stmt|;
specifier|register
name|u_int
name|caplen
init|=
name|h
operator|->
name|caplen
decl_stmt|;
name|ts_print
argument_list|(
operator|&
name|h
operator|->
name|ts
argument_list|)
expr_stmt|;
if|if
condition|(
name|caplen
operator|<
name|PPP_HDRLEN
condition|)
block|{
name|printf
argument_list|(
literal|"[|ppp]"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Some printers want to get back at the link level addresses, 	 * and/or check that they're not walking off the end of the packet. 	 * Rather than pass them all the way down, we set these globals.  */
name|packetp
operator|=
name|p
expr_stmt|;
name|snapend
operator|=
name|p
operator|+
name|caplen
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * XXX: seems to assume that there are 2 octets prepended to an 	 * actual PPP frame. The 1st octet looks like Input/Output flag 	 * while 2nd octet is unknown, at least to me 	 * (mshindo@mshindo.net). 	 * 	 * That was what the original tcpdump code did. 	 * 	 * FreeBSD's "if_ppp.c" *does* set the first octet to 1 for outbound 	 * packets and 0 for inbound packets - but only if the 	 * protocol field has the 0x8000 bit set (i.e., it's a network 	 * control protocol); it does so before running the packet through 	 * "bpf_filter" to see if it should be discarded, and to see 	 * if we should update the time we sent the most recent packet... 	 * 	 * ...but it puts the original address field back after doing 	 * so. 	 * 	 * NetBSD's "if_ppp.c" doesn't set the first octet in that fashion. 	 * 	 * I don't know if any PPP implementation handed up to a BPF 	 * device packets with the first octet being 1 for outbound and 	 * 0 for inbound packets, so I (guy@alum.mit.edu) don't know 	 * whether that ever needs to be checked or not. 	 * 	 * Note that NetBSD has a DLT_PPP_SERIAL, which it uses for PPP, 	 * and its tcpdump appears to assume that the frame always 	 * begins with an address field and a control field, and that 	 * the address field might be 0x0f or 0x8f, for Cisco 	 * point-to-point with HDLC framing as per section 4.3.1 of RFC 	 * 1547, as well as 0xff, for PPP in HDLC-like framing as per 	 * RFC 1662. 	 * 	 * (Is the Cisco framing in question what DLT_C_HDLC, in 	 * BSD/OS, is?) 	 */
block|if (eflag) 		printf("%c %4d %02x ", p[0] ? 'O' : 'I', length, p[1]);
endif|#
directive|endif
name|ppp_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|xflag
condition|)
name|default_print
argument_list|(
name|p
argument_list|,
name|caplen
argument_list|)
expr_stmt|;
name|out
label|:
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * PPP I/F printer to use if we know that RFC 1662-style PPP in HDLC-like  * framing, or Cisco PPP with HDLC framing as per section 4.3.1 of RFC 1547,  * is being used (i.e., we don't check for PPP_ADDRESS and PPP_CONTROL,  * discard them *if* those are the first two octets, and parse the remaining  * packet as a PPP packet, as "ppp_print()" does).  *  * This handles, for example, DLT_PPP_SERIAL in NetBSD.  */
end_comment

begin_function
name|void
name|ppp_hdlc_if_print
parameter_list|(
name|u_char
modifier|*
name|user
parameter_list|,
specifier|const
name|struct
name|pcap_pkthdr
modifier|*
name|h
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|p
parameter_list|)
block|{
specifier|register
name|u_int
name|length
init|=
name|h
operator|->
name|len
decl_stmt|;
specifier|register
name|u_int
name|caplen
init|=
name|h
operator|->
name|caplen
decl_stmt|;
name|u_int
name|proto
decl_stmt|;
if|if
condition|(
name|caplen
operator|<
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"[|ppp]"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Some printers want to get back at the link level addresses, 	 * and/or check that they're not walking off the end of the packet. 	 * Rather than pass them all the way down, we set these globals. 	 */
name|packetp
operator|=
name|p
expr_stmt|;
name|snapend
operator|=
name|p
operator|+
name|caplen
expr_stmt|;
switch|switch
condition|(
name|p
index|[
literal|0
index|]
condition|)
block|{
case|case
name|PPP_ADDRESS
case|:
if|if
condition|(
name|caplen
operator|<
literal|4
condition|)
block|{
name|printf
argument_list|(
literal|"[|ppp]"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ts_print
argument_list|(
operator|&
name|h
operator|->
name|ts
argument_list|)
expr_stmt|;
if|if
condition|(
name|eflag
condition|)
name|printf
argument_list|(
literal|"%02x %02x %d "
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
name|length
operator|-=
literal|2
expr_stmt|;
name|proto
operator|=
name|EXTRACT_16BITS
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
name|length
operator|-=
literal|2
expr_stmt|;
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|ppp_protoname
argument_list|(
name|proto
argument_list|)
argument_list|)
expr_stmt|;
name|handle_ppp
argument_list|(
name|proto
argument_list|,
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHDLC_UNICAST
case|:
case|case
name|CHDLC_BCAST
case|:
comment|/* 		 * Have the Cisco HDLC print routine do all the work. 		 */
name|chdlc_if_print
argument_list|(
name|user
argument_list|,
name|h
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
default|default:
name|ts_print
argument_list|(
operator|&
name|h
operator|->
name|ts
argument_list|)
expr_stmt|;
if|if
condition|(
name|eflag
condition|)
name|printf
argument_list|(
literal|"%02x %02x %d "
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
name|length
operator|-=
literal|2
expr_stmt|;
comment|/* 		 * XXX - NetBSD's "ppp_netbsd_serial_if_print()" treats 		 * the next two octets as an Ethernet type; does that 		 * ever happen? 		 */
name|printf
argument_list|(
literal|"unknown addr %02x; ctrl %02x"
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|xflag
condition|)
name|default_print
argument_list|(
name|p
argument_list|,
name|caplen
argument_list|)
expr_stmt|;
name|out
label|:
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|tok
name|ppptype2str
index|[]
init|=
block|{
block|{
name|PPP_IP
block|,
literal|"IP"
block|}
block|,
block|{
name|PPP_OSI
block|,
literal|"OSI"
block|}
block|,
block|{
name|PPP_NS
block|,
literal|"NS"
block|}
block|,
block|{
name|PPP_DECNET
block|,
literal|"DECNET"
block|}
block|,
block|{
name|PPP_APPLE
block|,
literal|"APPLE"
block|}
block|,
block|{
name|PPP_IPX
block|,
literal|"IPX"
block|}
block|,
block|{
name|PPP_VJC
block|,
literal|"VJC"
block|}
block|,
block|{
name|PPP_VJNC
block|,
literal|"VJNC"
block|}
block|,
block|{
name|PPP_BRPDU
block|,
literal|"BRPDU"
block|}
block|,
block|{
name|PPP_STII
block|,
literal|"STII"
block|}
block|,
block|{
name|PPP_VINES
block|,
literal|"VINES"
block|}
block|,
block|{
name|PPP_HELLO
block|,
literal|"HELLO"
block|}
block|,
block|{
name|PPP_LUXCOM
block|,
literal|"LUXCOM"
block|}
block|,
block|{
name|PPP_SNS
block|,
literal|"SNS"
block|}
block|,
block|{
name|PPP_IPCP
block|,
literal|"IPCP"
block|}
block|,
block|{
name|PPP_OSICP
block|,
literal|"OSICP"
block|}
block|,
block|{
name|PPP_NSCP
block|,
literal|"NSCP"
block|}
block|,
block|{
name|PPP_DECNETCP
block|,
literal|"DECNETCP"
block|}
block|,
block|{
name|PPP_APPLECP
block|,
literal|"APPLECP"
block|}
block|,
block|{
name|PPP_IPXCP
block|,
literal|"IPXCP"
block|}
block|,
block|{
name|PPP_STIICP
block|,
literal|"STIICP"
block|}
block|,
block|{
name|PPP_VINESCP
block|,
literal|"VINESCP"
block|}
block|,
block|{
name|PPP_LCP
block|,
literal|"LCP"
block|}
block|,
block|{
name|PPP_PAP
block|,
literal|"PAP"
block|}
block|,
block|{
name|PPP_LQM
block|,
literal|"LQM"
block|}
block|,
block|{
name|PPP_CHAP
block|,
literal|"CHAP"
block|}
block|,
block|{
name|PPP_BACP
block|,
literal|"BACP"
block|}
block|,
block|{
name|PPP_BAP
block|,
literal|"BAP"
block|}
block|,
block|{
name|PPP_MP
block|,
literal|"MP"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PPP_BSDI_HDRLEN
value|24
end_define

begin_comment
comment|/* BSD/OS specific PPP printer */
end_comment

begin_function
name|void
name|ppp_bsdos_if_print
parameter_list|(
name|u_char
modifier|*
name|user
parameter_list|,
specifier|const
name|struct
name|pcap_pkthdr
modifier|*
name|h
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|p
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__bsdi__
specifier|register
name|u_int
name|length
init|=
name|h
operator|->
name|len
decl_stmt|;
specifier|register
name|u_int
name|caplen
init|=
name|h
operator|->
name|caplen
decl_stmt|;
specifier|register
name|int
name|hdrlength
decl_stmt|;
name|u_int16_t
name|ptype
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|q
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ts_print
argument_list|(
operator|&
name|h
operator|->
name|ts
argument_list|)
expr_stmt|;
if|if
condition|(
name|caplen
operator|<
name|PPP_BSDI_HDRLEN
condition|)
block|{
name|printf
argument_list|(
literal|"[|ppp]"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Some printers want to get back at the link level addresses, 	 * and/or check that they're not walking off the end of the packet. 	 * Rather than pass them all the way down, we set these globals. 	 */
name|packetp
operator|=
name|p
expr_stmt|;
name|snapend
operator|=
name|p
operator|+
name|caplen
expr_stmt|;
name|hdrlength
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
block|if (p[0] == PPP_ADDRESS&& p[1] == PPP_CONTROL) { 		if (eflag) 			printf("%02x %02x ", p[0], p[1]); 		p += 2; 		hdrlength = 2; 	}  	if (eflag) 		printf("%d ", length);
comment|/* Retrieve the protocol type */
block|if (*p& 01) {
comment|/* Compressed protocol field */
block|ptype = *p; 		if (eflag) 			printf("%02x ", ptype); 		p++; 		hdrlength += 1; 	} else {
comment|/* Un-compressed protocol field */
block|ptype = ntohs(*(u_int16_t *)p); 		if (eflag) 			printf("%04x ", ptype); 		p += 2; 		hdrlength += 2; 	}
else|#
directive|else
name|ptype
operator|=
literal|0
expr_stmt|;
comment|/*XXX*/
if|if
condition|(
name|eflag
condition|)
name|printf
argument_list|(
literal|"%c "
argument_list|,
name|p
index|[
name|SLC_DIR
index|]
condition|?
literal|'O'
else|:
literal|'I'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
name|SLC_LLHL
index|]
condition|)
block|{
comment|/* link level header */
name|struct
name|ppp_header
modifier|*
name|ph
decl_stmt|;
name|q
operator|=
name|p
operator|+
name|SLC_BPFHDRLEN
expr_stmt|;
name|ph
operator|=
operator|(
expr|struct
name|ppp_header
operator|*
operator|)
name|q
expr_stmt|;
if|if
condition|(
name|ph
operator|->
name|phdr_addr
operator|==
name|PPP_ADDRESS
operator|&&
name|ph
operator|->
name|phdr_ctl
operator|==
name|PPP_CONTROL
condition|)
block|{
if|if
condition|(
name|eflag
condition|)
name|printf
argument_list|(
literal|"%02x %02x "
argument_list|,
name|q
index|[
literal|0
index|]
argument_list|,
name|q
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ptype
operator|=
name|ntohs
argument_list|(
name|ph
operator|->
name|phdr_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|eflag
operator|&&
operator|(
name|ptype
operator|==
name|PPP_VJC
operator|||
name|ptype
operator|==
name|PPP_VJNC
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|tok2str
argument_list|(
name|ppptype2str
argument_list|,
literal|"proto-#%d"
argument_list|,
name|ptype
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|eflag
condition|)
block|{
name|printf
argument_list|(
literal|"LLH=["
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
index|[
name|SLC_LLHL
index|]
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|q
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"] "
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|eflag
condition|)
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
name|SLC_CHL
index|]
condition|)
block|{
name|q
operator|=
name|p
operator|+
name|SLC_BPFHDRLEN
operator|+
name|p
index|[
name|SLC_LLHL
index|]
expr_stmt|;
switch|switch
condition|(
name|ptype
condition|)
block|{
case|case
name|PPP_VJC
case|:
name|ptype
operator|=
name|vjc_print
argument_list|(
name|q
argument_list|,
name|length
operator|-
operator|(
name|q
operator|-
name|p
operator|)
argument_list|,
name|ptype
argument_list|)
expr_stmt|;
name|hdrlength
operator|=
name|PPP_BSDI_HDRLEN
expr_stmt|;
name|p
operator|+=
name|hdrlength
expr_stmt|;
switch|switch
condition|(
name|ptype
condition|)
block|{
case|case
name|PPP_IP
case|:
name|ip_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|PPP_IPV6
case|:
name|ip6_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
goto|goto
name|printx
goto|;
case|case
name|PPP_VJNC
case|:
name|ptype
operator|=
name|vjc_print
argument_list|(
name|q
argument_list|,
name|length
operator|-
operator|(
name|q
operator|-
name|p
operator|)
argument_list|,
name|ptype
argument_list|)
expr_stmt|;
name|hdrlength
operator|=
name|PPP_BSDI_HDRLEN
expr_stmt|;
name|p
operator|+=
name|hdrlength
expr_stmt|;
switch|switch
condition|(
name|ptype
condition|)
block|{
case|case
name|PPP_IP
case|:
name|ip_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|PPP_IPV6
case|:
name|ip6_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
goto|goto
name|printx
goto|;
default|default:
if|if
condition|(
name|eflag
condition|)
block|{
name|printf
argument_list|(
literal|"CH=["
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
index|[
name|SLC_LLHL
index|]
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|q
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"] "
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
name|hdrlength
operator|=
name|PPP_BSDI_HDRLEN
expr_stmt|;
endif|#
directive|endif
name|length
operator|-=
name|hdrlength
expr_stmt|;
name|p
operator|+=
name|hdrlength
expr_stmt|;
switch|switch
condition|(
name|ptype
condition|)
block|{
case|case
name|PPP_IP
case|:
name|ip_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|PPP_IPV6
case|:
name|ip6_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|tok2str
argument_list|(
name|ppptype2str
argument_list|,
literal|"proto-#%d"
argument_list|,
name|ptype
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printx
label|:
if|if
condition|(
name|xflag
condition|)
name|default_print
argument_list|(
operator|(
specifier|const
name|u_char
operator|*
operator|)
name|p
argument_list|,
name|caplen
operator|-
name|hdrlength
argument_list|)
expr_stmt|;
name|out
label|:
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __bsdi__ */
block|}
end_function

end_unit

