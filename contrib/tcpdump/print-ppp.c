begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1990, 1991, 1993, 1994, 1995, 1996, 1997  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that: (1) source code distributions  * retain the above copyright notice and this paragraph in its entirety, (2)  * distributions including binary code include the above copyright notice and  * this paragraph in its entirety in the documentation or other materials  * provided with the distribution, and (3) all advertising materials mentioning  * features or use of this software display the following acknowledgement:  * ``This product includes software developed by the University of California,  * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of  * the University nor the names of its contributors may be used to endorse  * or promote products derived from this software without specific prior  * written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * Extensively modified by Motonori Shindo (mshindo@mshindo.net) for more  * complete PPP support.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * TODO:  * o resolve XXX as much as possible  * o MP support  * o BAP support  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
name|_U_
init|=
literal|"@(#) $Header: /tcpdump/master/tcpdump/print-ppp.c,v 1.108.2.4 2005/06/18 23:56:40 guy Exp $ (LBL)"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<tcpdump-stdinc.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__bsdi__
end_ifdef

begin_include
include|#
directive|include
file|<net/slcompress.h>
end_include

begin_include
include|#
directive|include
file|<net/if_ppp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<pcap.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"interface.h"
end_include

begin_include
include|#
directive|include
file|"extract.h"
end_include

begin_include
include|#
directive|include
file|"addrtoname.h"
end_include

begin_include
include|#
directive|include
file|"ppp.h"
end_include

begin_include
include|#
directive|include
file|"chdlc.h"
end_include

begin_include
include|#
directive|include
file|"ethertype.h"
end_include

begin_include
include|#
directive|include
file|"oui.h"
end_include

begin_comment
comment|/*  * The following constatns are defined by IANA. Please refer to  *    http://www.isi.edu/in-notes/iana/assignments/ppp-numbers  * for the up-to-date information.  */
end_comment

begin_comment
comment|/* Protocol Codes defined in ppp.h */
end_comment

begin_decl_stmt
name|struct
name|tok
name|ppptype2str
index|[]
init|=
block|{
block|{
name|PPP_IP
block|,
literal|"IP"
block|}
block|,
block|{
name|PPP_OSI
block|,
literal|"OSI"
block|}
block|,
block|{
name|PPP_NS
block|,
literal|"NS"
block|}
block|,
block|{
name|PPP_DECNET
block|,
literal|"DECNET"
block|}
block|,
block|{
name|PPP_APPLE
block|,
literal|"APPLE"
block|}
block|,
block|{
name|PPP_IPX
block|,
literal|"IPX"
block|}
block|,
block|{
name|PPP_VJC
block|,
literal|"VJC IP"
block|}
block|,
block|{
name|PPP_VJNC
block|,
literal|"VJNC IP"
block|}
block|,
block|{
name|PPP_BRPDU
block|,
literal|"BRPDU"
block|}
block|,
block|{
name|PPP_STII
block|,
literal|"STII"
block|}
block|,
block|{
name|PPP_VINES
block|,
literal|"VINES"
block|}
block|,
block|{
name|PPP_MPLS_UCAST
block|,
literal|"MPLS"
block|}
block|,
block|{
name|PPP_MPLS_MCAST
block|,
literal|"MPLS"
block|}
block|,
block|{
name|PPP_COMP
block|,
literal|"Compressed"
block|}
block|,
block|{
name|PPP_ML
block|,
literal|"MLPPP"
block|}
block|,
block|{
name|PPP_IPV6
block|,
literal|"IP6"
block|}
block|,
block|{
name|PPP_HELLO
block|,
literal|"HELLO"
block|}
block|,
block|{
name|PPP_LUXCOM
block|,
literal|"LUXCOM"
block|}
block|,
block|{
name|PPP_SNS
block|,
literal|"SNS"
block|}
block|,
block|{
name|PPP_IPCP
block|,
literal|"IPCP"
block|}
block|,
block|{
name|PPP_OSICP
block|,
literal|"OSICP"
block|}
block|,
block|{
name|PPP_NSCP
block|,
literal|"NSCP"
block|}
block|,
block|{
name|PPP_DECNETCP
block|,
literal|"DECNETCP"
block|}
block|,
block|{
name|PPP_APPLECP
block|,
literal|"APPLECP"
block|}
block|,
block|{
name|PPP_IPXCP
block|,
literal|"IPXCP"
block|}
block|,
block|{
name|PPP_STIICP
block|,
literal|"STIICP"
block|}
block|,
block|{
name|PPP_VINESCP
block|,
literal|"VINESCP"
block|}
block|,
block|{
name|PPP_IPV6CP
block|,
literal|"IP6CP"
block|}
block|,
block|{
name|PPP_MPLSCP
block|,
literal|"MPLSCP"
block|}
block|,
block|{
name|PPP_LCP
block|,
literal|"LCP"
block|}
block|,
block|{
name|PPP_PAP
block|,
literal|"PAP"
block|}
block|,
block|{
name|PPP_LQM
block|,
literal|"LQM"
block|}
block|,
block|{
name|PPP_CHAP
block|,
literal|"CHAP"
block|}
block|,
block|{
name|PPP_EAP
block|,
literal|"EAP"
block|}
block|,
block|{
name|PPP_SPAP
block|,
literal|"SPAP"
block|}
block|,
block|{
name|PPP_SPAP_OLD
block|,
literal|"Old-SPAP"
block|}
block|,
block|{
name|PPP_BACP
block|,
literal|"BACP"
block|}
block|,
block|{
name|PPP_BAP
block|,
literal|"BAP"
block|}
block|,
block|{
name|PPP_MPCP
block|,
literal|"MLPPP-CP"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Control Protocols (LCP/IPCP/CCP etc.) Codes defined in RFC 1661 */
end_comment

begin_define
define|#
directive|define
name|CPCODES_VEXT
value|0
end_define

begin_comment
comment|/* Vendor-Specific (RFC2153) */
end_comment

begin_define
define|#
directive|define
name|CPCODES_CONF_REQ
value|1
end_define

begin_comment
comment|/* Configure-Request */
end_comment

begin_define
define|#
directive|define
name|CPCODES_CONF_ACK
value|2
end_define

begin_comment
comment|/* Configure-Ack */
end_comment

begin_define
define|#
directive|define
name|CPCODES_CONF_NAK
value|3
end_define

begin_comment
comment|/* Configure-Nak */
end_comment

begin_define
define|#
directive|define
name|CPCODES_CONF_REJ
value|4
end_define

begin_comment
comment|/* Configure-Reject */
end_comment

begin_define
define|#
directive|define
name|CPCODES_TERM_REQ
value|5
end_define

begin_comment
comment|/* Terminate-Request */
end_comment

begin_define
define|#
directive|define
name|CPCODES_TERM_ACK
value|6
end_define

begin_comment
comment|/* Terminate-Ack */
end_comment

begin_define
define|#
directive|define
name|CPCODES_CODE_REJ
value|7
end_define

begin_comment
comment|/* Code-Reject */
end_comment

begin_define
define|#
directive|define
name|CPCODES_PROT_REJ
value|8
end_define

begin_comment
comment|/* Protocol-Reject (LCP only) */
end_comment

begin_define
define|#
directive|define
name|CPCODES_ECHO_REQ
value|9
end_define

begin_comment
comment|/* Echo-Request (LCP only) */
end_comment

begin_define
define|#
directive|define
name|CPCODES_ECHO_RPL
value|10
end_define

begin_comment
comment|/* Echo-Reply (LCP only) */
end_comment

begin_define
define|#
directive|define
name|CPCODES_DISC_REQ
value|11
end_define

begin_comment
comment|/* Discard-Request (LCP only) */
end_comment

begin_define
define|#
directive|define
name|CPCODES_ID
value|12
end_define

begin_comment
comment|/* Identification (LCP only) RFC1570 */
end_comment

begin_define
define|#
directive|define
name|CPCODES_TIME_REM
value|13
end_define

begin_comment
comment|/* Time-Remaining (LCP only) RFC1570 */
end_comment

begin_define
define|#
directive|define
name|CPCODES_RESET_REQ
value|14
end_define

begin_comment
comment|/* Reset-Request (CCP only) RFC1962 */
end_comment

begin_define
define|#
directive|define
name|CPCODES_RESET_REP
value|15
end_define

begin_comment
comment|/* Reset-Reply (CCP only) */
end_comment

begin_decl_stmt
name|struct
name|tok
name|cpcodes
index|[]
init|=
block|{
block|{
name|CPCODES_VEXT
block|,
literal|"Vendor-Extension"
block|}
block|,
comment|/* RFC2153 */
block|{
name|CPCODES_CONF_REQ
block|,
literal|"Conf-Request"
block|}
block|,
block|{
name|CPCODES_CONF_ACK
block|,
literal|"Conf-Ack"
block|}
block|,
block|{
name|CPCODES_CONF_NAK
block|,
literal|"Conf-Nack"
block|}
block|,
block|{
name|CPCODES_CONF_REJ
block|,
literal|"Conf-Reject"
block|}
block|,
block|{
name|CPCODES_TERM_REQ
block|,
literal|"Term-Request"
block|}
block|,
block|{
name|CPCODES_TERM_ACK
block|,
literal|"Term-Ack"
block|}
block|,
block|{
name|CPCODES_CODE_REJ
block|,
literal|"Code-Reject"
block|}
block|,
block|{
name|CPCODES_PROT_REJ
block|,
literal|"Prot-Reject"
block|}
block|,
block|{
name|CPCODES_ECHO_REQ
block|,
literal|"Echo-Request"
block|}
block|,
block|{
name|CPCODES_ECHO_RPL
block|,
literal|"Echo-Reply"
block|}
block|,
block|{
name|CPCODES_DISC_REQ
block|,
literal|"Disc-Req"
block|}
block|,
block|{
name|CPCODES_ID
block|,
literal|"Ident"
block|}
block|,
comment|/* RFC1570 */
block|{
name|CPCODES_TIME_REM
block|,
literal|"Time-Rem"
block|}
block|,
comment|/* RFC1570 */
block|{
name|CPCODES_RESET_REQ
block|,
literal|"Reset-Req"
block|}
block|,
comment|/* RFC1962 */
block|{
name|CPCODES_RESET_REP
block|,
literal|"Reset-Ack"
block|}
block|,
comment|/* RFC1962 */
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* LCP Config Options */
end_comment

begin_define
define|#
directive|define
name|LCPOPT_VEXT
value|0
end_define

begin_define
define|#
directive|define
name|LCPOPT_MRU
value|1
end_define

begin_define
define|#
directive|define
name|LCPOPT_ACCM
value|2
end_define

begin_define
define|#
directive|define
name|LCPOPT_AP
value|3
end_define

begin_define
define|#
directive|define
name|LCPOPT_QP
value|4
end_define

begin_define
define|#
directive|define
name|LCPOPT_MN
value|5
end_define

begin_define
define|#
directive|define
name|LCPOPT_DEP6
value|6
end_define

begin_define
define|#
directive|define
name|LCPOPT_PFC
value|7
end_define

begin_define
define|#
directive|define
name|LCPOPT_ACFC
value|8
end_define

begin_define
define|#
directive|define
name|LCPOPT_FCSALT
value|9
end_define

begin_define
define|#
directive|define
name|LCPOPT_SDP
value|10
end_define

begin_define
define|#
directive|define
name|LCPOPT_NUMMODE
value|11
end_define

begin_define
define|#
directive|define
name|LCPOPT_DEP12
value|12
end_define

begin_define
define|#
directive|define
name|LCPOPT_CBACK
value|13
end_define

begin_define
define|#
directive|define
name|LCPOPT_DEP14
value|14
end_define

begin_define
define|#
directive|define
name|LCPOPT_DEP15
value|15
end_define

begin_define
define|#
directive|define
name|LCPOPT_DEP16
value|16
end_define

begin_define
define|#
directive|define
name|LCPOPT_MLMRRU
value|17
end_define

begin_define
define|#
directive|define
name|LCPOPT_MLSSNHF
value|18
end_define

begin_define
define|#
directive|define
name|LCPOPT_MLED
value|19
end_define

begin_define
define|#
directive|define
name|LCPOPT_PROP
value|20
end_define

begin_define
define|#
directive|define
name|LCPOPT_DCEID
value|21
end_define

begin_define
define|#
directive|define
name|LCPOPT_MPP
value|22
end_define

begin_define
define|#
directive|define
name|LCPOPT_LD
value|23
end_define

begin_define
define|#
directive|define
name|LCPOPT_LCPAOPT
value|24
end_define

begin_define
define|#
directive|define
name|LCPOPT_COBS
value|25
end_define

begin_define
define|#
directive|define
name|LCPOPT_PE
value|26
end_define

begin_define
define|#
directive|define
name|LCPOPT_MLHF
value|27
end_define

begin_define
define|#
directive|define
name|LCPOPT_I18N
value|28
end_define

begin_define
define|#
directive|define
name|LCPOPT_SDLOS
value|29
end_define

begin_define
define|#
directive|define
name|LCPOPT_PPPMUX
value|30
end_define

begin_define
define|#
directive|define
name|LCPOPT_MIN
value|LCPOPT_VEXT
end_define

begin_define
define|#
directive|define
name|LCPOPT_MAX
value|LCPOPT_PPPMUX
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|lcpconfopts
index|[]
init|=
block|{
literal|"Vend-Ext"
block|,
comment|/* (0) */
literal|"MRU"
block|,
comment|/* (1) */
literal|"ACCM"
block|,
comment|/* (2) */
literal|"Auth-Prot"
block|,
comment|/* (3) */
literal|"Qual-Prot"
block|,
comment|/* (4) */
literal|"Magic-Num"
block|,
comment|/* (5) */
literal|"deprecated(6)"
block|,
comment|/* used to be a Quality Protocol */
literal|"PFC"
block|,
comment|/* (7) */
literal|"ACFC"
block|,
comment|/* (8) */
literal|"FCS-Alt"
block|,
comment|/* (9) */
literal|"SDP"
block|,
comment|/* (10) */
literal|"Num-Mode"
block|,
comment|/* (11) */
literal|"deprecated(12)"
block|,
comment|/* used to be a Multi-Link-Procedure*/
literal|"Call-Back"
block|,
comment|/* (13) */
literal|"deprecated(14)"
block|,
comment|/* used to be a Connect-Time */
literal|"deprecated(15)"
block|,
comment|/* used to be a Compund-Frames */
literal|"deprecated(16)"
block|,
comment|/* used to be a Nominal-Data-Encap */
literal|"MRRU"
block|,
comment|/* (17) */
literal|"12-Bit seq #"
block|,
comment|/* (18) */
literal|"End-Disc"
block|,
comment|/* (19) */
literal|"Proprietary"
block|,
comment|/* (20) */
literal|"DCE-Id"
block|,
comment|/* (21) */
literal|"MP+"
block|,
comment|/* (22) */
literal|"Link-Disc"
block|,
comment|/* (23) */
literal|"LCP-Auth-Opt"
block|,
comment|/* (24) */
literal|"COBS"
block|,
comment|/* (25) */
literal|"Prefix-elision"
block|,
comment|/* (26) */
literal|"Multilink-header-Form"
block|,
comment|/* (27) */
literal|"I18N"
block|,
comment|/* (28) */
literal|"SDL-over-SONET/SDH"
block|,
comment|/* (29) */
literal|"PPP-Muxing"
block|,
comment|/* (30) */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ECP - to be supported */
end_comment

begin_comment
comment|/* CCP Config Options */
end_comment

begin_define
define|#
directive|define
name|CCPOPT_OUI
value|0
end_define

begin_comment
comment|/* RFC1962 */
end_comment

begin_define
define|#
directive|define
name|CCPOPT_PRED1
value|1
end_define

begin_comment
comment|/* RFC1962 */
end_comment

begin_define
define|#
directive|define
name|CCPOPT_PRED2
value|2
end_define

begin_comment
comment|/* RFC1962 */
end_comment

begin_define
define|#
directive|define
name|CCPOPT_PJUMP
value|3
end_define

begin_comment
comment|/* RFC1962 */
end_comment

begin_comment
comment|/* 4-15 unassigned */
end_comment

begin_define
define|#
directive|define
name|CCPOPT_HPPPC
value|16
end_define

begin_comment
comment|/* RFC1962 */
end_comment

begin_define
define|#
directive|define
name|CCPOPT_STACLZS
value|17
end_define

begin_comment
comment|/* RFC1974 */
end_comment

begin_define
define|#
directive|define
name|CCPOPT_MPPC
value|18
end_define

begin_comment
comment|/* RFC2118 */
end_comment

begin_define
define|#
directive|define
name|CCPOPT_GFZA
value|19
end_define

begin_comment
comment|/* RFC1962 */
end_comment

begin_define
define|#
directive|define
name|CCPOPT_V42BIS
value|20
end_define

begin_comment
comment|/* RFC1962 */
end_comment

begin_define
define|#
directive|define
name|CCPOPT_BSDCOMP
value|21
end_define

begin_comment
comment|/* RFC1977 */
end_comment

begin_comment
comment|/* 22 unassigned */
end_comment

begin_define
define|#
directive|define
name|CCPOPT_LZSDCP
value|23
end_define

begin_comment
comment|/* RFC1967 */
end_comment

begin_define
define|#
directive|define
name|CCPOPT_MVRCA
value|24
end_define

begin_comment
comment|/* RFC1975 */
end_comment

begin_define
define|#
directive|define
name|CCPOPT_DEC
value|25
end_define

begin_comment
comment|/* RFC1976 */
end_comment

begin_define
define|#
directive|define
name|CCPOPT_DEFLATE
value|26
end_define

begin_comment
comment|/* RFC1979 */
end_comment

begin_comment
comment|/* 27-254 unassigned */
end_comment

begin_define
define|#
directive|define
name|CCPOPT_RESV
value|255
end_define

begin_comment
comment|/* RFC1962 */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|tok
name|ccpconfopts_values
index|[]
init|=
block|{
block|{
name|CCPOPT_OUI
block|,
literal|"OUI"
block|}
block|,
block|{
name|CCPOPT_PRED1
block|,
literal|"Pred-1"
block|}
block|,
block|{
name|CCPOPT_PRED2
block|,
literal|"Pred-2"
block|}
block|,
block|{
name|CCPOPT_PJUMP
block|,
literal|"Puddle"
block|}
block|,
block|{
name|CCPOPT_HPPPC
block|,
literal|"HP-PPC"
block|}
block|,
block|{
name|CCPOPT_STACLZS
block|,
literal|"Stac-LZS"
block|}
block|,
block|{
name|CCPOPT_MPPC
block|,
literal|"MPPC"
block|}
block|,
block|{
name|CCPOPT_GFZA
block|,
literal|"Gand-FZA"
block|}
block|,
block|{
name|CCPOPT_V42BIS
block|,
literal|"V.42bis"
block|}
block|,
block|{
name|CCPOPT_BSDCOMP
block|,
literal|"BSD-Comp"
block|}
block|,
block|{
name|CCPOPT_LZSDCP
block|,
literal|"LZS-DCP"
block|}
block|,
block|{
name|CCPOPT_MVRCA
block|,
literal|"MVRCA"
block|}
block|,
block|{
name|CCPOPT_DEC
block|,
literal|"DEC"
block|}
block|,
block|{
name|CCPOPT_DEFLATE
block|,
literal|"Deflate"
block|}
block|,
block|{
name|CCPOPT_RESV
block|,
literal|"Reserved"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* BACP Config Options */
end_comment

begin_define
define|#
directive|define
name|BACPOPT_FPEER
value|1
end_define

begin_comment
comment|/* RFC2125 */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|tok
name|bacconfopts_values
index|[]
init|=
block|{
block|{
name|BACPOPT_FPEER
block|,
literal|"Favored-Peer"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SDCP - to be supported */
end_comment

begin_comment
comment|/* IPCP Config Options */
end_comment

begin_define
define|#
directive|define
name|IPCPOPT_2ADDR
value|1
end_define

begin_comment
comment|/* RFC1172, RFC1332 (deprecated) */
end_comment

begin_define
define|#
directive|define
name|IPCPOPT_IPCOMP
value|2
end_define

begin_comment
comment|/* RFC1332 */
end_comment

begin_define
define|#
directive|define
name|IPCPOPT_ADDR
value|3
end_define

begin_comment
comment|/* RFC1332 */
end_comment

begin_define
define|#
directive|define
name|IPCPOPT_MOBILE4
value|4
end_define

begin_comment
comment|/* RFC2290 */
end_comment

begin_define
define|#
directive|define
name|IPCPOPT_PRIDNS
value|129
end_define

begin_comment
comment|/* RFC1877 */
end_comment

begin_define
define|#
directive|define
name|IPCPOPT_PRINBNS
value|130
end_define

begin_comment
comment|/* RFC1877 */
end_comment

begin_define
define|#
directive|define
name|IPCPOPT_SECDNS
value|131
end_define

begin_comment
comment|/* RFC1877 */
end_comment

begin_define
define|#
directive|define
name|IPCPOPT_SECNBNS
value|132
end_define

begin_comment
comment|/* RFC1877 */
end_comment

begin_decl_stmt
name|struct
name|tok
name|ipcpopt_values
index|[]
init|=
block|{
block|{
name|IPCPOPT_2ADDR
block|,
literal|"IP-Addrs"
block|}
block|,
block|{
name|IPCPOPT_IPCOMP
block|,
literal|"IP-Comp"
block|}
block|,
block|{
name|IPCPOPT_ADDR
block|,
literal|"IP-Addr"
block|}
block|,
block|{
name|IPCPOPT_MOBILE4
block|,
literal|"Home-Addr"
block|}
block|,
block|{
name|IPCPOPT_PRIDNS
block|,
literal|"Pri-DNS"
block|}
block|,
block|{
name|IPCPOPT_PRINBNS
block|,
literal|"Pri-NBNS"
block|}
block|,
block|{
name|IPCPOPT_SECDNS
block|,
literal|"Sec-DNS"
block|}
block|,
block|{
name|IPCPOPT_SECNBNS
block|,
literal|"Sec-NBNS"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* IP6CP Config Options */
end_comment

begin_define
define|#
directive|define
name|IP6CP_IFID
value|1
end_define

begin_decl_stmt
name|struct
name|tok
name|ip6cpopt_values
index|[]
init|=
block|{
block|{
name|IP6CP_IFID
block|,
literal|"Interface-ID"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ATCP - to be supported */
end_comment

begin_comment
comment|/* OSINLCP - to be supported */
end_comment

begin_comment
comment|/* BVCP - to be supported */
end_comment

begin_comment
comment|/* BCP - to be supported */
end_comment

begin_comment
comment|/* IPXCP - to be supported */
end_comment

begin_comment
comment|/* MPLSCP - to be supported */
end_comment

begin_comment
comment|/* Auth Algorithms */
end_comment

begin_comment
comment|/* 0-4 Reserved (RFC1994) */
end_comment

begin_define
define|#
directive|define
name|AUTHALG_CHAPMD5
value|5
end_define

begin_comment
comment|/* RFC1994 */
end_comment

begin_define
define|#
directive|define
name|AUTHALG_MSCHAP1
value|128
end_define

begin_comment
comment|/* RFC2433 */
end_comment

begin_define
define|#
directive|define
name|AUTHALG_MSCHAP2
value|129
end_define

begin_comment
comment|/* RFC2795 */
end_comment

begin_decl_stmt
name|struct
name|tok
name|authalg_values
index|[]
init|=
block|{
block|{
name|AUTHALG_CHAPMD5
block|,
literal|"MD5"
block|}
block|,
block|{
name|AUTHALG_MSCHAP1
block|,
literal|"MS-CHAPv1"
block|}
block|,
block|{
name|AUTHALG_MSCHAP2
block|,
literal|"MS-CHAPv2"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FCS Alternatives - to be supported */
end_comment

begin_comment
comment|/* Multilink Endpoint Discriminator (RFC1717) */
end_comment

begin_define
define|#
directive|define
name|MEDCLASS_NULL
value|0
end_define

begin_comment
comment|/* Null Class */
end_comment

begin_define
define|#
directive|define
name|MEDCLASS_LOCAL
value|1
end_define

begin_comment
comment|/* Locally Assigned */
end_comment

begin_define
define|#
directive|define
name|MEDCLASS_IPV4
value|2
end_define

begin_comment
comment|/* Internet Protocol (IPv4) */
end_comment

begin_define
define|#
directive|define
name|MEDCLASS_MAC
value|3
end_define

begin_comment
comment|/* IEEE 802.1 global MAC address */
end_comment

begin_define
define|#
directive|define
name|MEDCLASS_MNB
value|4
end_define

begin_comment
comment|/* PPP Magic Number Block */
end_comment

begin_define
define|#
directive|define
name|MEDCLASS_PSNDN
value|5
end_define

begin_comment
comment|/* Public Switched Network Director Number */
end_comment

begin_comment
comment|/* PPP LCP Callback */
end_comment

begin_define
define|#
directive|define
name|CALLBACK_AUTH
value|0
end_define

begin_comment
comment|/* Location determined by user auth */
end_comment

begin_define
define|#
directive|define
name|CALLBACK_DSTR
value|1
end_define

begin_comment
comment|/* Dialing string */
end_comment

begin_define
define|#
directive|define
name|CALLBACK_LID
value|2
end_define

begin_comment
comment|/* Location identifier */
end_comment

begin_define
define|#
directive|define
name|CALLBACK_E164
value|3
end_define

begin_comment
comment|/* E.164 number */
end_comment

begin_define
define|#
directive|define
name|CALLBACK_X500
value|4
end_define

begin_comment
comment|/* X.500 distinguished name */
end_comment

begin_define
define|#
directive|define
name|CALLBACK_CBCP
value|6
end_define

begin_comment
comment|/* Location is determined during CBCP nego */
end_comment

begin_decl_stmt
name|struct
name|tok
name|ppp_callback_values
index|[]
init|=
block|{
block|{
name|CALLBACK_AUTH
block|,
literal|"UserAuth"
block|}
block|,
block|{
name|CALLBACK_DSTR
block|,
literal|"DialString"
block|}
block|,
block|{
name|CALLBACK_LID
block|,
literal|"LocalID"
block|}
block|,
block|{
name|CALLBACK_E164
block|,
literal|"E.164"
block|}
block|,
block|{
name|CALLBACK_X500
block|,
literal|"X.500"
block|}
block|,
block|{
name|CALLBACK_CBCP
block|,
literal|"CBCP"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CHAP */
end_comment

begin_define
define|#
directive|define
name|CHAP_CHAL
value|1
end_define

begin_define
define|#
directive|define
name|CHAP_RESP
value|2
end_define

begin_define
define|#
directive|define
name|CHAP_SUCC
value|3
end_define

begin_define
define|#
directive|define
name|CHAP_FAIL
value|4
end_define

begin_decl_stmt
name|struct
name|tok
name|chapcode_values
index|[]
init|=
block|{
block|{
name|CHAP_CHAL
block|,
literal|"Challenge"
block|}
block|,
block|{
name|CHAP_RESP
block|,
literal|"Response"
block|}
block|,
block|{
name|CHAP_SUCC
block|,
literal|"Success"
block|}
block|,
block|{
name|CHAP_FAIL
block|,
literal|"Fail"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PAP */
end_comment

begin_define
define|#
directive|define
name|PAP_AREQ
value|1
end_define

begin_define
define|#
directive|define
name|PAP_AACK
value|2
end_define

begin_define
define|#
directive|define
name|PAP_ANAK
value|3
end_define

begin_decl_stmt
name|struct
name|tok
name|papcode_values
index|[]
init|=
block|{
block|{
name|PAP_AREQ
block|,
literal|"Auth-Req"
block|}
block|,
block|{
name|PAP_AACK
block|,
literal|"Auth-ACK"
block|}
block|,
block|{
name|PAP_ANAK
block|,
literal|"Auth-NACK"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* BAP */
end_comment

begin_define
define|#
directive|define
name|BAP_CALLREQ
value|1
end_define

begin_define
define|#
directive|define
name|BAP_CALLRES
value|2
end_define

begin_define
define|#
directive|define
name|BAP_CBREQ
value|3
end_define

begin_define
define|#
directive|define
name|BAP_CBRES
value|4
end_define

begin_define
define|#
directive|define
name|BAP_LDQREQ
value|5
end_define

begin_define
define|#
directive|define
name|BAP_LDQRES
value|6
end_define

begin_define
define|#
directive|define
name|BAP_CSIND
value|7
end_define

begin_define
define|#
directive|define
name|BAP_CSRES
value|8
end_define

begin_function_decl
specifier|static
name|void
name|handle_ctrl_proto
parameter_list|(
name|u_int
name|proto
parameter_list|,
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|length
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_chap
parameter_list|(
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|length
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_pap
parameter_list|(
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|length
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_bap
parameter_list|(
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|length
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_mlppp
parameter_list|(
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|length
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|print_lcp_config_options
parameter_list|(
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|print_ipcp_config_options
parameter_list|(
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|print_ip6cp_config_options
parameter_list|(
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|print_ccp_config_options
parameter_list|(
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|print_bacp_config_options
parameter_list|(
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_ppp
parameter_list|(
name|u_int
name|proto
parameter_list|,
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|length
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ppp_hdlc
parameter_list|(
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|length
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* generic Control Protocol (e.g. LCP, IPCP, CCP, etc.) handler */
end_comment

begin_function
specifier|static
name|void
name|handle_ctrl_proto
parameter_list|(
name|u_int
name|proto
parameter_list|,
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
name|int
name|length
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|typestr
decl_stmt|;
name|u_int
name|code
decl_stmt|,
name|len
decl_stmt|;
name|int
function_decl|(
modifier|*
name|pfunc
function_decl|)
parameter_list|(
specifier|const
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
name|int
name|x
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|tptr
decl_stmt|;
name|tptr
operator|=
name|pptr
expr_stmt|;
name|typestr
operator|=
name|tok2str
argument_list|(
name|ppptype2str
argument_list|,
literal|"unknown ctrl-proto (0x%04x)"
argument_list|,
name|proto
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s, "
argument_list|,
name|typestr
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|4
condition|)
comment|/* FIXME weak boundary checking */
goto|goto
name|trunc
goto|;
name|TCHECK2
argument_list|(
operator|*
name|tptr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|code
operator|=
operator|*
name|tptr
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"%s (0x%02x), id %u, length %u"
argument_list|,
name|tok2str
argument_list|(
name|cpcodes
argument_list|,
literal|"Unknown Opcode"
argument_list|,
name|code
argument_list|)
argument_list|,
name|code
argument_list|,
operator|*
name|tptr
operator|++
argument_list|,
comment|/* ID */
name|length
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vflag
condition|)
return|return;
if|if
condition|(
name|length
operator|<=
literal|4
condition|)
return|return;
comment|/* there may be a NULL confreq etc. */
name|TCHECK2
argument_list|(
operator|*
name|tptr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|len
operator|=
name|EXTRACT_16BITS
argument_list|(
name|tptr
argument_list|)
expr_stmt|;
name|tptr
operator|+=
literal|2
expr_stmt|;
name|printf
argument_list|(
literal|"\n\tencoded length %u (=Option(s) length %u)"
argument_list|,
name|len
argument_list|,
name|len
operator|-
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|vflag
operator|>
literal|1
condition|)
name|print_unknown_data
argument_list|(
name|pptr
operator|-
literal|2
argument_list|,
literal|"\n\t"
argument_list|,
literal|6
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CPCODES_VEXT
case|:
if|if
condition|(
name|length
operator|<
literal|11
condition|)
break|break;
name|TCHECK2
argument_list|(
operator|*
name|tptr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\t  Magic-Num 0x%08x"
argument_list|,
name|EXTRACT_32BITS
argument_list|(
name|tptr
argument_list|)
argument_list|)
expr_stmt|;
name|tptr
operator|+=
literal|4
expr_stmt|;
name|TCHECK2
argument_list|(
operator|*
name|tptr
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Vendor: %s (%u)"
argument_list|,
name|tok2str
argument_list|(
name|oui_values
argument_list|,
literal|"Unknown"
argument_list|,
name|EXTRACT_24BITS
argument_list|(
name|tptr
argument_list|)
argument_list|)
argument_list|,
name|EXTRACT_24BITS
argument_list|(
name|tptr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX: need to decode Kind and Value(s)? */
break|break;
case|case
name|CPCODES_CONF_REQ
case|:
case|case
name|CPCODES_CONF_ACK
case|:
case|case
name|CPCODES_CONF_NAK
case|:
case|case
name|CPCODES_CONF_REJ
case|:
name|x
operator|=
name|len
operator|-
literal|4
expr_stmt|;
comment|/* Code(1), Identifier(1) and Length(2) */
do|do
block|{
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|PPP_LCP
case|:
name|pfunc
operator|=
name|print_lcp_config_options
expr_stmt|;
break|break;
case|case
name|PPP_IPCP
case|:
name|pfunc
operator|=
name|print_ipcp_config_options
expr_stmt|;
break|break;
case|case
name|PPP_IPV6CP
case|:
name|pfunc
operator|=
name|print_ip6cp_config_options
expr_stmt|;
break|break;
case|case
name|PPP_CCP
case|:
name|pfunc
operator|=
name|print_ccp_config_options
expr_stmt|;
break|break;
case|case
name|PPP_BACP
case|:
name|pfunc
operator|=
name|print_bacp_config_options
expr_stmt|;
break|break;
default|default:
comment|/* 				 * No print routine for the options for 				 * this protocol. 				 */
name|pfunc
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pfunc
operator|==
name|NULL
condition|)
comment|/* catch the above null pointer if unknown CP */
break|break;
if|if
condition|(
operator|(
name|j
operator|=
call|(
modifier|*
name|pfunc
call|)
argument_list|(
name|tptr
argument_list|,
name|len
argument_list|)
operator|)
operator|==
literal|0
condition|)
break|break;
name|x
operator|-=
name|j
expr_stmt|;
name|tptr
operator|+=
name|j
expr_stmt|;
block|}
do|while
condition|(
name|x
operator|>
literal|0
condition|)
do|;
break|break;
case|case
name|CPCODES_TERM_REQ
case|:
case|case
name|CPCODES_TERM_ACK
case|:
comment|/* XXX: need to decode Data? */
break|break;
case|case
name|CPCODES_CODE_REJ
case|:
comment|/* XXX: need to decode Rejected-Packet? */
break|break;
case|case
name|CPCODES_PROT_REJ
case|:
if|if
condition|(
name|length
operator|<
literal|6
condition|)
break|break;
name|TCHECK2
argument_list|(
operator|*
name|tptr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\t  Rejected %s Protocol (0x%04x)"
argument_list|,
name|tok2str
argument_list|(
name|ppptype2str
argument_list|,
literal|"unknown"
argument_list|,
name|EXTRACT_16BITS
argument_list|(
name|tptr
argument_list|)
argument_list|)
argument_list|,
name|EXTRACT_16BITS
argument_list|(
name|tptr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX: need to decode Rejected-Information? - hexdump for now */
if|if
condition|(
name|len
operator|>
literal|6
condition|)
block|{
name|printf
argument_list|(
literal|"\n\t  Rejected Packet"
argument_list|)
expr_stmt|;
name|print_unknown_data
argument_list|(
name|tptr
operator|+
literal|2
argument_list|,
literal|"\n\t    "
argument_list|,
name|len
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CPCODES_ECHO_REQ
case|:
case|case
name|CPCODES_ECHO_RPL
case|:
case|case
name|CPCODES_DISC_REQ
case|:
if|if
condition|(
name|length
operator|<
literal|8
condition|)
break|break;
name|TCHECK2
argument_list|(
operator|*
name|tptr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\t  Magic-Num 0x%08x"
argument_list|,
name|EXTRACT_32BITS
argument_list|(
name|tptr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX: need to decode Data? - hexdump for now */
if|if
condition|(
name|len
operator|>
literal|8
condition|)
block|{
name|printf
argument_list|(
literal|"\n\t  Data"
argument_list|)
expr_stmt|;
name|print_unknown_data
argument_list|(
name|tptr
operator|+
literal|4
argument_list|,
literal|"\n\t    "
argument_list|,
name|len
operator|-
literal|4
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CPCODES_ID
case|:
if|if
condition|(
name|length
operator|<
literal|8
condition|)
break|break;
name|TCHECK2
argument_list|(
operator|*
name|tptr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\t  Magic-Num 0x%08x"
argument_list|,
name|EXTRACT_32BITS
argument_list|(
name|tptr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* RFC 1661 says this is intended to be human readable */
if|if
condition|(
name|len
operator|>
literal|8
condition|)
block|{
name|printf
argument_list|(
literal|"\n\t  Message\n\t    "
argument_list|)
expr_stmt|;
name|fn_printn
argument_list|(
name|tptr
operator|+
literal|4
argument_list|,
name|len
operator|-
literal|4
argument_list|,
name|snapend
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CPCODES_TIME_REM
case|:
if|if
condition|(
name|length
operator|<
literal|12
condition|)
break|break;
name|TCHECK2
argument_list|(
operator|*
name|tptr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\t  Magic-Num 0x%08x"
argument_list|,
name|EXTRACT_32BITS
argument_list|(
name|tptr
argument_list|)
argument_list|)
expr_stmt|;
name|TCHECK2
argument_list|(
operator|*
operator|(
name|tptr
operator|+
literal|4
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", Seconds-Remaining %us"
argument_list|,
name|EXTRACT_32BITS
argument_list|(
name|tptr
operator|+
literal|4
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX: need to decode Message? */
break|break;
default|default:
comment|/* XXX this is dirty but we do not get the              * original pointer passed to the begin              * the PPP packet */
if|if
condition|(
name|vflag
operator|<=
literal|1
condition|)
name|print_unknown_data
argument_list|(
name|pptr
operator|-
literal|2
argument_list|,
literal|"\n\t  "
argument_list|,
name|length
operator|+
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
name|trunc
label|:
name|printf
argument_list|(
literal|"[|%s]"
argument_list|,
name|typestr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* LCP config options */
end_comment

begin_function
specifier|static
name|int
name|print_lcp_config_options
parameter_list|(
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|opt
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|2
condition|)
return|return
literal|0
return|;
name|TCHECK2
argument_list|(
operator|*
name|p
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|len
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|opt
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|length
operator|<
name|len
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|len
operator|<
literal|2
condition|)
block|{
if|if
condition|(
operator|(
name|opt
operator|>=
name|LCPOPT_MIN
operator|)
operator|&&
operator|(
name|opt
operator|<=
name|LCPOPT_MAX
operator|)
condition|)
name|printf
argument_list|(
literal|"\n\t  %s Option (0x%02x), length %u (bogus, should be>= 2)"
argument_list|,
name|lcpconfopts
index|[
name|opt
index|]
argument_list|,
name|opt
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\n\tunknown LCP option 0x%02x"
argument_list|,
name|opt
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|opt
operator|>=
name|LCPOPT_MIN
operator|)
operator|&&
operator|(
name|opt
operator|<=
name|LCPOPT_MAX
operator|)
condition|)
name|printf
argument_list|(
literal|"\n\t  %s Option (0x%02x), length %u: "
argument_list|,
name|lcpconfopts
index|[
name|opt
index|]
argument_list|,
name|opt
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"\n\tunknown LCP option 0x%02x"
argument_list|,
name|opt
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
name|LCPOPT_VEXT
case|:
if|if
condition|(
name|len
operator|>=
literal|6
condition|)
block|{
name|TCHECK2
argument_list|(
operator|*
operator|(
name|p
operator|+
literal|2
operator|)
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Vendor: %s (%u)"
argument_list|,
name|tok2str
argument_list|(
name|oui_values
argument_list|,
literal|"Unknown"
argument_list|,
name|EXTRACT_24BITS
argument_list|(
name|p
operator|+
literal|2
argument_list|)
argument_list|)
argument_list|,
name|EXTRACT_24BITS
argument_list|(
name|p
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|TCHECK(p[5]); 			printf(", kind: 0x%02x", p[5]); 			printf(", Value: 0x") 			for (i = 0; i< len - 6; i++) { 				TCHECK(p[6 + i]); 				printf("%02x", p[6 + i]); 			}
endif|#
directive|endif
block|}
break|break;
case|case
name|LCPOPT_MRU
case|:
if|if
condition|(
name|len
operator|==
literal|4
condition|)
block|{
name|TCHECK2
argument_list|(
operator|*
operator|(
name|p
operator|+
literal|2
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%u"
argument_list|,
name|EXTRACT_16BITS
argument_list|(
name|p
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LCPOPT_ACCM
case|:
if|if
condition|(
name|len
operator|==
literal|6
condition|)
block|{
name|TCHECK2
argument_list|(
operator|*
operator|(
name|p
operator|+
literal|2
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%08x"
argument_list|,
name|EXTRACT_32BITS
argument_list|(
name|p
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LCPOPT_AP
case|:
if|if
condition|(
name|len
operator|>=
literal|4
condition|)
block|{
name|TCHECK2
argument_list|(
operator|*
operator|(
name|p
operator|+
literal|2
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|tok2str
argument_list|(
name|ppptype2str
argument_list|,
literal|"Unknown Auth Proto (0x04x)"
argument_list|,
name|EXTRACT_16BITS
argument_list|(
name|p
operator|+
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|EXTRACT_16BITS
argument_list|(
name|p
operator|+
literal|2
argument_list|)
condition|)
block|{
case|case
name|PPP_CHAP
case|:
name|TCHECK
argument_list|(
name|p
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", %s"
argument_list|,
name|tok2str
argument_list|(
name|authalg_values
argument_list|,
literal|"Unknown Auth Alg %u"
argument_list|,
name|p
index|[
literal|4
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPP_PAP
case|:
comment|/* fall through */
case|case
name|PPP_EAP
case|:
case|case
name|PPP_SPAP
case|:
case|case
name|PPP_SPAP_OLD
case|:
break|break;
default|default:
name|print_unknown_data
argument_list|(
name|p
argument_list|,
literal|"\n\t"
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|LCPOPT_QP
case|:
if|if
condition|(
name|len
operator|>=
literal|4
condition|)
block|{
name|TCHECK2
argument_list|(
operator|*
operator|(
name|p
operator|+
literal|2
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|EXTRACT_16BITS
argument_list|(
name|p
operator|+
literal|2
argument_list|)
operator|==
name|PPP_LQM
condition|)
name|printf
argument_list|(
literal|" LQR"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" unknown"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LCPOPT_MN
case|:
if|if
condition|(
name|len
operator|==
literal|6
condition|)
block|{
name|TCHECK2
argument_list|(
operator|*
operator|(
name|p
operator|+
literal|2
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%08x"
argument_list|,
name|EXTRACT_32BITS
argument_list|(
name|p
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LCPOPT_PFC
case|:
break|break;
case|case
name|LCPOPT_ACFC
case|:
break|break;
case|case
name|LCPOPT_LD
case|:
if|if
condition|(
name|len
operator|==
literal|4
condition|)
block|{
name|TCHECK2
argument_list|(
operator|*
operator|(
name|p
operator|+
literal|2
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%04x"
argument_list|,
name|EXTRACT_16BITS
argument_list|(
name|p
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LCPOPT_CBACK
case|:
if|if
condition|(
name|len
operator|<
literal|3
condition|)
break|break;
name|TCHECK
argument_list|(
name|p
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Callback Operation %s (%u)"
argument_list|,
name|tok2str
argument_list|(
name|ppp_callback_values
argument_list|,
literal|"Unknown"
argument_list|,
name|p
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|p
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|LCPOPT_MLMRRU
case|:
if|if
condition|(
name|len
operator|==
literal|4
condition|)
block|{
name|TCHECK2
argument_list|(
operator|*
operator|(
name|p
operator|+
literal|2
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%u"
argument_list|,
name|EXTRACT_16BITS
argument_list|(
name|p
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LCPOPT_MLED
case|:
if|if
condition|(
name|len
operator|<
literal|3
condition|)
break|break;
name|TCHECK
argument_list|(
name|p
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p
index|[
literal|2
index|]
condition|)
block|{
comment|/* class */
case|case
name|MEDCLASS_NULL
case|:
name|printf
argument_list|(
literal|"Null"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEDCLASS_LOCAL
case|:
name|printf
argument_list|(
literal|"Local"
argument_list|)
expr_stmt|;
comment|/* XXX */
break|break;
case|case
name|MEDCLASS_IPV4
case|:
if|if
condition|(
name|len
operator|!=
literal|7
condition|)
break|break;
name|TCHECK2
argument_list|(
operator|*
operator|(
name|p
operator|+
literal|3
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"IPv4 %s"
argument_list|,
name|ipaddr_string
argument_list|(
name|p
operator|+
literal|3
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEDCLASS_MAC
case|:
if|if
condition|(
name|len
operator|!=
literal|9
condition|)
break|break;
name|TCHECK
argument_list|(
name|p
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"MAC %02x:%02x:%02x:%02x:%02x:%02x"
argument_list|,
name|p
index|[
literal|3
index|]
argument_list|,
name|p
index|[
literal|4
index|]
argument_list|,
name|p
index|[
literal|5
index|]
argument_list|,
name|p
index|[
literal|6
index|]
argument_list|,
name|p
index|[
literal|7
index|]
argument_list|,
name|p
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEDCLASS_MNB
case|:
name|printf
argument_list|(
literal|"Magic-Num-Block"
argument_list|)
expr_stmt|;
comment|/* XXX */
break|break;
case|case
name|MEDCLASS_PSNDN
case|:
name|printf
argument_list|(
literal|"PSNDN"
argument_list|)
expr_stmt|;
comment|/* XXX */
break|break;
block|}
break|break;
comment|/* XXX: to be supported */
if|#
directive|if
literal|0
block|case LCPOPT_DEP6: 	case LCPOPT_FCSALT: 	case LCPOPT_SDP: 	case LCPOPT_NUMMODE: 	case LCPOPT_DEP12: 	case LCPOPT_DEP14: 	case LCPOPT_DEP15: 	case LCPOPT_DEP16:         case LCPOPT_MLSSNHF: 	case LCPOPT_PROP: 	case LCPOPT_DCEID: 	case LCPOPT_MPP: 	case LCPOPT_LCPAOPT: 	case LCPOPT_COBS: 	case LCPOPT_PE: 	case LCPOPT_MLHF: 	case LCPOPT_I18N: 	case LCPOPT_SDLOS: 	case LCPOPT_PPPMUX: 		break;
endif|#
directive|endif
default|default:
if|if
condition|(
name|vflag
operator|<
literal|2
condition|)
name|print_unknown_data
argument_list|(
operator|&
name|p
index|[
literal|2
index|]
argument_list|,
literal|"\n\t    "
argument_list|,
name|len
operator|-
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|vflag
operator|>
literal|1
condition|)
name|print_unknown_data
argument_list|(
operator|&
name|p
index|[
literal|2
index|]
argument_list|,
literal|"\n\t    "
argument_list|,
name|len
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* exclude TLV header */
return|return
name|len
return|;
name|trunc
label|:
name|printf
argument_list|(
literal|"[|lcp]"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ML-PPP*/
end_comment

begin_decl_stmt
name|struct
name|tok
name|ppp_ml_flag_values
index|[]
init|=
block|{
block|{
literal|0x80
block|,
literal|"begin"
block|}
block|,
block|{
literal|0x40
block|,
literal|"end"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|handle_mlppp
parameter_list|(
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|length
parameter_list|)
block|{
if|if
condition|(
operator|!
name|eflag
condition|)
name|printf
argument_list|(
literal|"MLPPP, "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"seq 0x%03x, Flags [%s], length %u"
argument_list|,
operator|(
name|EXTRACT_16BITS
argument_list|(
name|p
argument_list|)
operator|)
operator|&
literal|0x0fff
argument_list|,
comment|/* only support 12-Bit sequence space for now */
name|bittok2str
argument_list|(
name|ppp_ml_flag_values
argument_list|,
literal|"none"
argument_list|,
operator|*
name|p
operator|&
literal|0xc0
argument_list|)
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* CHAP */
end_comment

begin_function
specifier|static
name|void
name|handle_chap
parameter_list|(
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|u_int
name|code
decl_stmt|,
name|len
decl_stmt|;
name|int
name|val_size
decl_stmt|,
name|name_size
decl_stmt|,
name|msg_size
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|p0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|p0
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"[|chap]"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|length
operator|<
literal|4
condition|)
block|{
name|TCHECK
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"[|chap 0x%02x]"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
name|TCHECK
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|code
operator|=
operator|*
name|p
expr_stmt|;
name|printf
argument_list|(
literal|"CHAP, %s (0x%02x)"
argument_list|,
name|tok2str
argument_list|(
name|chapcode_values
argument_list|,
literal|"unknown"
argument_list|,
name|code
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|TCHECK
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", id %u"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
comment|/* ID */
name|p
operator|++
expr_stmt|;
name|TCHECK2
argument_list|(
operator|*
name|p
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|len
operator|=
name|EXTRACT_16BITS
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* 	 * Note that this is a generic CHAP decoding routine. Since we 	 * don't know which flavor of CHAP (i.e. CHAP-MD5, MS-CHAPv1, 	 * MS-CHAPv2) is used at this point, we can't decode packet 	 * specifically to each algorithms. Instead, we simply decode 	 * the GCD (Gratest Common Denominator) for all algorithms. 	 */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CHAP_CHAL
case|:
case|case
name|CHAP_RESP
case|:
if|if
condition|(
name|length
operator|-
operator|(
name|p
operator|-
name|p0
operator|)
operator|<
literal|1
condition|)
return|return;
name|TCHECK
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|val_size
operator|=
operator|*
name|p
expr_stmt|;
comment|/* value size */
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|length
operator|-
operator|(
name|p
operator|-
name|p0
operator|)
operator|<
name|val_size
condition|)
return|return;
name|printf
argument_list|(
literal|", Value "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|val_size
condition|;
name|i
operator|++
control|)
block|{
name|TCHECK
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%02x"
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
block|}
name|name_size
operator|=
name|len
operator|-
operator|(
name|p
operator|-
name|p0
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|", Name "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|name_size
condition|;
name|i
operator|++
control|)
block|{
name|TCHECK
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|safeputchar
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CHAP_SUCC
case|:
case|case
name|CHAP_FAIL
case|:
name|msg_size
operator|=
name|len
operator|-
operator|(
name|p
operator|-
name|p0
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|", Msg "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msg_size
condition|;
name|i
operator|++
control|)
block|{
name|TCHECK
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|safeputchar
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return;
name|trunc
label|:
name|printf
argument_list|(
literal|"[|chap]"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* PAP (see RFC 1334) */
end_comment

begin_function
specifier|static
name|void
name|handle_pap
parameter_list|(
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|u_int
name|code
decl_stmt|,
name|len
decl_stmt|;
name|int
name|peerid_len
decl_stmt|,
name|passwd_len
decl_stmt|,
name|msg_len
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|p0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|p0
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"[|pap]"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|length
operator|<
literal|4
condition|)
block|{
name|TCHECK
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"[|pap 0x%02x]"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
name|TCHECK
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|code
operator|=
operator|*
name|p
expr_stmt|;
name|printf
argument_list|(
literal|"PAP, %s (0x%02x)"
argument_list|,
name|tok2str
argument_list|(
name|papcode_values
argument_list|,
literal|"unknown"
argument_list|,
name|code
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|TCHECK
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", id %u"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
comment|/* ID */
name|p
operator|++
expr_stmt|;
name|TCHECK2
argument_list|(
operator|*
name|p
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|len
operator|=
name|EXTRACT_16BITS
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|len
operator|>
name|length
condition|)
block|{
name|printf
argument_list|(
literal|", length %u> packet size"
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return;
block|}
name|length
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|length
operator|<
operator|(
name|p
operator|-
name|p0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|", length %u< PAP header length"
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PAP_AREQ
case|:
if|if
condition|(
name|length
operator|-
operator|(
name|p
operator|-
name|p0
operator|)
operator|<
literal|1
condition|)
return|return;
name|TCHECK
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|peerid_len
operator|=
operator|*
name|p
expr_stmt|;
comment|/* Peer-ID Length */
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|length
operator|-
operator|(
name|p
operator|-
name|p0
operator|)
operator|<
name|peerid_len
condition|)
return|return;
name|printf
argument_list|(
literal|", Peer "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|peerid_len
condition|;
name|i
operator|++
control|)
block|{
name|TCHECK
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|safeputchar
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|-
operator|(
name|p
operator|-
name|p0
operator|)
operator|<
literal|1
condition|)
return|return;
name|TCHECK
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|passwd_len
operator|=
operator|*
name|p
expr_stmt|;
comment|/* Password Length */
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|length
operator|-
operator|(
name|p
operator|-
name|p0
operator|)
operator|<
name|passwd_len
condition|)
return|return;
name|printf
argument_list|(
literal|", Name "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|passwd_len
condition|;
name|i
operator|++
control|)
block|{
name|TCHECK
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|safeputchar
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PAP_AACK
case|:
case|case
name|PAP_ANAK
case|:
if|if
condition|(
name|length
operator|-
operator|(
name|p
operator|-
name|p0
operator|)
operator|<
literal|1
condition|)
return|return;
name|TCHECK
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|msg_len
operator|=
operator|*
name|p
expr_stmt|;
comment|/* Msg-Length */
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|length
operator|-
operator|(
name|p
operator|-
name|p0
operator|)
operator|<
name|msg_len
condition|)
return|return;
name|printf
argument_list|(
literal|", Msg "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msg_len
condition|;
name|i
operator|++
control|)
block|{
name|TCHECK
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|safeputchar
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return;
name|trunc
label|:
name|printf
argument_list|(
literal|"[|pap]"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* BAP */
end_comment

begin_function
specifier|static
name|void
name|handle_bap
parameter_list|(
specifier|const
name|u_char
modifier|*
name|p
name|_U_
parameter_list|,
name|int
name|length
name|_U_
parameter_list|)
block|{
comment|/* XXX: to be supported!! */
block|}
end_function

begin_comment
comment|/* IPCP config options */
end_comment

begin_function
specifier|static
name|int
name|print_ipcp_config_options
parameter_list|(
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|opt
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|2
condition|)
return|return
literal|0
return|;
name|TCHECK2
argument_list|(
operator|*
name|p
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|len
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|opt
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|length
operator|<
name|len
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|len
operator|<
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"\n\t  %s Option (0x%02x), length %u (bogus, should be>= 2)"
argument_list|,
name|tok2str
argument_list|(
name|ipcpopt_values
argument_list|,
literal|"unknown"
argument_list|,
name|opt
argument_list|)
argument_list|,
name|opt
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|printf
argument_list|(
literal|"\n\t  %s Option (0x%02x), length %u: "
argument_list|,
name|tok2str
argument_list|(
name|ipcpopt_values
argument_list|,
literal|"unknown"
argument_list|,
name|opt
argument_list|)
argument_list|,
name|opt
argument_list|,
name|len
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
name|IPCPOPT_2ADDR
case|:
comment|/* deprecated */
if|if
condition|(
name|len
operator|!=
literal|10
condition|)
goto|goto
name|invlen
goto|;
name|TCHECK2
argument_list|(
operator|*
operator|(
name|p
operator|+
literal|6
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"src %s, dst %s"
argument_list|,
name|ipaddr_string
argument_list|(
name|p
operator|+
literal|2
argument_list|)
argument_list|,
name|ipaddr_string
argument_list|(
name|p
operator|+
literal|6
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPCPOPT_IPCOMP
case|:
if|if
condition|(
name|len
operator|<
literal|4
condition|)
goto|goto
name|invlen
goto|;
name|TCHECK2
argument_list|(
operator|*
operator|(
name|p
operator|+
literal|2
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|EXTRACT_16BITS
argument_list|(
name|p
operator|+
literal|2
argument_list|)
operator|==
name|PPP_VJC
condition|)
block|{
name|printf
argument_list|(
literal|"VJ-Comp"
argument_list|)
expr_stmt|;
comment|/* XXX: VJ-Comp parameters should be decoded */
block|}
else|else
name|printf
argument_list|(
literal|"unknown-comp-proto %04x"
argument_list|,
name|EXTRACT_16BITS
argument_list|(
name|p
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPCPOPT_ADDR
case|:
comment|/* those options share the same format - fall through */
case|case
name|IPCPOPT_MOBILE4
case|:
case|case
name|IPCPOPT_PRIDNS
case|:
case|case
name|IPCPOPT_PRINBNS
case|:
case|case
name|IPCPOPT_SECDNS
case|:
case|case
name|IPCPOPT_SECNBNS
case|:
if|if
condition|(
name|len
operator|!=
literal|6
condition|)
goto|goto
name|invlen
goto|;
name|TCHECK2
argument_list|(
operator|*
operator|(
name|p
operator|+
literal|2
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|ipaddr_string
argument_list|(
name|p
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|vflag
operator|<
literal|2
condition|)
name|print_unknown_data
argument_list|(
operator|&
name|p
index|[
literal|2
index|]
argument_list|,
literal|"\n\t    "
argument_list|,
name|len
operator|-
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|vflag
operator|>
literal|1
condition|)
name|print_unknown_data
argument_list|(
operator|&
name|p
index|[
literal|2
index|]
argument_list|,
literal|"\n\t    "
argument_list|,
name|len
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* exclude TLV header */
return|return
name|len
return|;
name|invlen
label|:
name|printf
argument_list|(
literal|", invalid-length-%d"
argument_list|,
name|opt
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|trunc
label|:
name|printf
argument_list|(
literal|"[|ipcp]"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* IP6CP config options */
end_comment

begin_function
specifier|static
name|int
name|print_ip6cp_config_options
parameter_list|(
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|opt
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|2
condition|)
return|return
literal|0
return|;
name|TCHECK2
argument_list|(
operator|*
name|p
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|len
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|opt
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|length
operator|<
name|len
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|len
operator|<
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"\n\t  %s Option (0x%02x), length %u (bogus, should be>= 2)"
argument_list|,
name|tok2str
argument_list|(
name|ip6cpopt_values
argument_list|,
literal|"unknown"
argument_list|,
name|opt
argument_list|)
argument_list|,
name|opt
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|printf
argument_list|(
literal|"\n\t  %s Option (0x%02x), length %u: "
argument_list|,
name|tok2str
argument_list|(
name|ip6cpopt_values
argument_list|,
literal|"unknown"
argument_list|,
name|opt
argument_list|)
argument_list|,
name|opt
argument_list|,
name|len
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
name|IP6CP_IFID
case|:
if|if
condition|(
name|len
operator|!=
literal|10
condition|)
goto|goto
name|invlen
goto|;
name|TCHECK2
argument_list|(
operator|*
operator|(
name|p
operator|+
literal|2
operator|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%04x:%04x:%04x:%04x"
argument_list|,
name|EXTRACT_16BITS
argument_list|(
name|p
operator|+
literal|2
argument_list|)
argument_list|,
name|EXTRACT_16BITS
argument_list|(
name|p
operator|+
literal|4
argument_list|)
argument_list|,
name|EXTRACT_16BITS
argument_list|(
name|p
operator|+
literal|6
argument_list|)
argument_list|,
name|EXTRACT_16BITS
argument_list|(
name|p
operator|+
literal|8
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|vflag
operator|<
literal|2
condition|)
name|print_unknown_data
argument_list|(
operator|&
name|p
index|[
literal|2
index|]
argument_list|,
literal|"\n\t    "
argument_list|,
name|len
operator|-
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|vflag
operator|>
literal|1
condition|)
name|print_unknown_data
argument_list|(
operator|&
name|p
index|[
literal|2
index|]
argument_list|,
literal|"\n\t    "
argument_list|,
name|len
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* exclude TLV header */
return|return
name|len
return|;
name|invlen
label|:
name|printf
argument_list|(
literal|", invalid-length-%d"
argument_list|,
name|opt
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|trunc
label|:
name|printf
argument_list|(
literal|"[|ip6cp]"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* CCP config options */
end_comment

begin_function
specifier|static
name|int
name|print_ccp_config_options
parameter_list|(
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|opt
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|2
condition|)
return|return
literal|0
return|;
name|TCHECK2
argument_list|(
operator|*
name|p
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|len
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|opt
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|length
operator|<
name|len
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|len
operator|<
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"\n\t  %s Option (0x%02x), length %u (bogus, should be>= 2)"
argument_list|,
name|tok2str
argument_list|(
name|ccpconfopts_values
argument_list|,
literal|"Unknown"
argument_list|,
name|opt
argument_list|)
argument_list|,
name|opt
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|printf
argument_list|(
literal|"\n\t  %s Option (0x%02x), length %u:"
argument_list|,
name|tok2str
argument_list|(
name|ccpconfopts_values
argument_list|,
literal|"Unknown"
argument_list|,
name|opt
argument_list|)
argument_list|,
name|opt
argument_list|,
name|len
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|opt
condition|)
block|{
comment|/* fall through --> default: nothing supported yet */
case|case
name|CCPOPT_OUI
case|:
case|case
name|CCPOPT_PRED1
case|:
case|case
name|CCPOPT_PRED2
case|:
case|case
name|CCPOPT_PJUMP
case|:
case|case
name|CCPOPT_HPPPC
case|:
case|case
name|CCPOPT_STACLZS
case|:
case|case
name|CCPOPT_MPPC
case|:
case|case
name|CCPOPT_GFZA
case|:
case|case
name|CCPOPT_V42BIS
case|:
case|case
name|CCPOPT_BSDCOMP
case|:
case|case
name|CCPOPT_LZSDCP
case|:
case|case
name|CCPOPT_MVRCA
case|:
case|case
name|CCPOPT_DEC
case|:
case|case
name|CCPOPT_DEFLATE
case|:
case|case
name|CCPOPT_RESV
case|:
default|default:
if|if
condition|(
name|vflag
operator|<
literal|2
condition|)
name|print_unknown_data
argument_list|(
operator|&
name|p
index|[
literal|2
index|]
argument_list|,
literal|"\n\t    "
argument_list|,
name|len
operator|-
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|vflag
operator|>
literal|1
condition|)
name|print_unknown_data
argument_list|(
operator|&
name|p
index|[
literal|2
index|]
argument_list|,
literal|"\n\t    "
argument_list|,
name|len
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* exclude TLV header */
return|return
name|len
return|;
name|trunc
label|:
name|printf
argument_list|(
literal|"[|ccp]"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* BACP config options */
end_comment

begin_function
specifier|static
name|int
name|print_bacp_config_options
parameter_list|(
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|opt
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|2
condition|)
return|return
literal|0
return|;
name|TCHECK2
argument_list|(
operator|*
name|p
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|len
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|opt
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|length
operator|<
name|len
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|len
operator|<
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"\n\t  %s Option (0x%02x), length %u (bogus, should be>= 2)"
argument_list|,
name|tok2str
argument_list|(
name|bacconfopts_values
argument_list|,
literal|"Unknown"
argument_list|,
name|opt
argument_list|)
argument_list|,
name|opt
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|printf
argument_list|(
literal|"\n\t  %s Option (0x%02x), length %u:"
argument_list|,
name|tok2str
argument_list|(
name|bacconfopts_values
argument_list|,
literal|"Unknown"
argument_list|,
name|opt
argument_list|)
argument_list|,
name|opt
argument_list|,
name|len
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
name|BACPOPT_FPEER
case|:
name|TCHECK2
argument_list|(
operator|*
operator|(
name|p
operator|+
literal|2
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", Magic-Num 0x%08x"
argument_list|,
name|EXTRACT_32BITS
argument_list|(
name|p
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|vflag
operator|<
literal|2
condition|)
name|print_unknown_data
argument_list|(
operator|&
name|p
index|[
literal|2
index|]
argument_list|,
literal|"\n\t    "
argument_list|,
name|len
operator|-
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|vflag
operator|>
literal|1
condition|)
name|print_unknown_data
argument_list|(
operator|&
name|p
index|[
literal|2
index|]
argument_list|,
literal|"\n\t    "
argument_list|,
name|len
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* exclude TLV header */
return|return
name|len
return|;
name|trunc
label|:
name|printf
argument_list|(
literal|"[|bacp]"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppp_hdlc
parameter_list|(
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|u_char
modifier|*
name|b
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|,
name|c
decl_stmt|;
name|int
name|i
decl_stmt|,
name|proto
decl_stmt|;
specifier|const
name|void
modifier|*
name|se
decl_stmt|;
name|b
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|malloc
argument_list|(
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Unescape all the data into a temporary, private, buffer. 	 * Do this so that we dont overwrite the original packet 	 * contents. 	 */
for|for
control|(
name|s
operator|=
operator|(
name|u_char
operator|*
operator|)
name|p
operator|,
name|t
operator|=
name|b
operator|,
name|i
operator|=
name|length
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|c
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0x7d
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|1
condition|)
block|{
name|i
operator|--
expr_stmt|;
name|c
operator|=
operator|*
name|s
operator|++
operator|^
literal|0x20
expr_stmt|;
block|}
else|else
continue|continue;
block|}
operator|*
name|t
operator|++
operator|=
name|c
expr_stmt|;
block|}
name|se
operator|=
name|snapend
expr_stmt|;
name|snapend
operator|=
name|t
expr_stmt|;
comment|/* now lets guess about the payload codepoint format */
name|proto
operator|=
operator|*
name|b
expr_stmt|;
comment|/* start with a one-octet codepoint guess */
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|PPP_IP
case|:
name|ip_print
argument_list|(
name|gndo
argument_list|,
name|b
operator|+
literal|1
argument_list|,
name|t
operator|-
name|b
operator|-
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
ifdef|#
directive|ifdef
name|INET6
case|case
name|PPP_IPV6
case|:
name|ip6_print
argument_list|(
name|b
operator|+
literal|1
argument_list|,
name|t
operator|-
name|b
operator|-
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
endif|#
directive|endif
default|default:
comment|/* no luck - try next guess */
break|break;
block|}
name|proto
operator|=
name|EXTRACT_16BITS
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* next guess - load two octets */
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
operator|(
name|PPP_ADDRESS
operator|<<
literal|8
operator||
name|PPP_CONTROL
operator|)
case|:
comment|/* looks like a PPP frame */
name|proto
operator|=
name|EXTRACT_16BITS
argument_list|(
name|b
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* load the PPP proto-id */
name|handle_ppp
argument_list|(
name|proto
argument_list|,
name|b
operator|+
literal|4
argument_list|,
name|t
operator|-
name|b
operator|-
literal|4
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* last guess - proto must be a PPP proto-id */
name|handle_ppp
argument_list|(
name|proto
argument_list|,
name|b
operator|+
literal|2
argument_list|,
name|t
operator|-
name|b
operator|-
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
name|cleanup
label|:
name|snapend
operator|=
name|se
expr_stmt|;
name|free
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* PPP */
end_comment

begin_function
specifier|static
name|void
name|handle_ppp
parameter_list|(
name|u_int
name|proto
parameter_list|,
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|length
parameter_list|)
block|{
if|if
condition|(
operator|(
name|proto
operator|&
literal|0xff00
operator|)
operator|==
literal|0x7e00
condition|)
block|{
comment|/* is this an escape code ? */
name|ppp_hdlc
argument_list|(
name|p
operator|-
literal|1
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|PPP_LCP
case|:
comment|/* fall through */
case|case
name|PPP_IPCP
case|:
case|case
name|PPP_OSICP
case|:
case|case
name|PPP_MPLSCP
case|:
case|case
name|PPP_IPV6CP
case|:
case|case
name|PPP_CCP
case|:
case|case
name|PPP_BACP
case|:
name|handle_ctrl_proto
argument_list|(
name|proto
argument_list|,
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPP_ML
case|:
name|handle_mlppp
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPP_CHAP
case|:
name|handle_chap
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPP_PAP
case|:
name|handle_pap
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPP_BAP
case|:
comment|/* XXX: not yet completed */
name|handle_bap
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|ETHERTYPE_IP
case|:
comment|/*XXX*/
case|case
name|PPP_VJNC
case|:
case|case
name|PPP_IP
case|:
name|ip_print
argument_list|(
name|gndo
argument_list|,
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|ETHERTYPE_IPV6
case|:
comment|/*XXX*/
case|case
name|PPP_IPV6
case|:
name|ip6_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|ETHERTYPE_IPX
case|:
comment|/*XXX*/
case|case
name|PPP_IPX
case|:
name|ipx_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPP_OSI
case|:
name|isoclns_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPP_MPLS_UCAST
case|:
case|case
name|PPP_MPLS_MCAST
case|:
name|mpls_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPP_COMP
case|:
name|printf
argument_list|(
literal|"compressed PPP data"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|tok2str
argument_list|(
name|ppptype2str
argument_list|,
literal|"unknown PPP protocol (0x%04x)"
argument_list|,
name|proto
argument_list|)
argument_list|)
expr_stmt|;
name|print_unknown_data
argument_list|(
name|p
argument_list|,
literal|"\n\t"
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Standard PPP printer */
end_comment

begin_function
name|u_int
name|ppp_print
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|u_int
name|length
parameter_list|)
block|{
name|u_int
name|proto
decl_stmt|,
name|ppp_header
decl_stmt|;
name|u_int
name|olen
init|=
name|length
decl_stmt|;
comment|/* _o_riginal length */
name|u_int
name|hdr_len
init|=
literal|0
decl_stmt|;
comment|/* 	 * Here, we assume that p points to the Address and Control 	 * field (if they present). 	 */
if|if
condition|(
name|length
operator|<
literal|2
condition|)
goto|goto
name|trunc
goto|;
name|TCHECK2
argument_list|(
operator|*
name|p
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ppp_header
operator|=
name|EXTRACT_16BITS
argument_list|(
name|p
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ppp_header
condition|)
block|{
case|case
operator|(
name|PPP_WITHDIRECTION_IN
operator|<<
literal|8
operator||
name|PPP_CONTROL
operator|)
case|:
if|if
condition|(
name|eflag
condition|)
name|printf
argument_list|(
literal|"In  "
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
name|length
operator|-=
literal|2
expr_stmt|;
name|hdr_len
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
operator|(
name|PPP_WITHDIRECTION_OUT
operator|<<
literal|8
operator||
name|PPP_CONTROL
operator|)
case|:
if|if
condition|(
name|eflag
condition|)
name|printf
argument_list|(
literal|"Out "
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
name|length
operator|-=
literal|2
expr_stmt|;
name|hdr_len
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
operator|(
name|PPP_ADDRESS
operator|<<
literal|8
operator||
name|PPP_CONTROL
operator|)
case|:
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* ACFC not used */
name|length
operator|-=
literal|2
expr_stmt|;
name|hdr_len
operator|+=
literal|2
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|length
operator|<
literal|2
condition|)
goto|goto
name|trunc
goto|;
name|TCHECK
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|%
literal|2
condition|)
block|{
name|proto
operator|=
operator|*
name|p
expr_stmt|;
comment|/* PFC is used */
name|p
operator|++
expr_stmt|;
name|length
operator|--
expr_stmt|;
name|hdr_len
operator|++
expr_stmt|;
block|}
else|else
block|{
name|TCHECK2
argument_list|(
operator|*
name|p
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|proto
operator|=
name|EXTRACT_16BITS
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
name|length
operator|-=
literal|2
expr_stmt|;
name|hdr_len
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|eflag
condition|)
name|printf
argument_list|(
literal|"%s (0x%04x), length %u: "
argument_list|,
name|tok2str
argument_list|(
name|ppptype2str
argument_list|,
literal|"unknown"
argument_list|,
name|proto
argument_list|)
argument_list|,
name|proto
argument_list|,
name|olen
argument_list|)
expr_stmt|;
name|handle_ppp
argument_list|(
name|proto
argument_list|,
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
operator|(
name|hdr_len
operator|)
return|;
name|trunc
label|:
name|printf
argument_list|(
literal|"[|ppp]"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* PPP I/F printer */
end_comment

begin_function
name|u_int
name|ppp_if_print
parameter_list|(
specifier|const
name|struct
name|pcap_pkthdr
modifier|*
name|h
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|p
parameter_list|)
block|{
specifier|register
name|u_int
name|length
init|=
name|h
operator|->
name|len
decl_stmt|;
specifier|register
name|u_int
name|caplen
init|=
name|h
operator|->
name|caplen
decl_stmt|;
if|if
condition|(
name|caplen
operator|<
name|PPP_HDRLEN
condition|)
block|{
name|printf
argument_list|(
literal|"[|ppp]"
argument_list|)
expr_stmt|;
return|return
operator|(
name|caplen
operator|)
return|;
block|}
if|#
directive|if
literal|0
comment|/* 	 * XXX: seems to assume that there are 2 octets prepended to an 	 * actual PPP frame. The 1st octet looks like Input/Output flag 	 * while 2nd octet is unknown, at least to me 	 * (mshindo@mshindo.net). 	 * 	 * That was what the original tcpdump code did. 	 * 	 * FreeBSD's "if_ppp.c" *does* set the first octet to 1 for outbound 	 * packets and 0 for inbound packets - but only if the 	 * protocol field has the 0x8000 bit set (i.e., it's a network 	 * control protocol); it does so before running the packet through 	 * "bpf_filter" to see if it should be discarded, and to see 	 * if we should update the time we sent the most recent packet... 	 * 	 * ...but it puts the original address field back after doing 	 * so. 	 * 	 * NetBSD's "if_ppp.c" doesn't set the first octet in that fashion. 	 * 	 * I don't know if any PPP implementation handed up to a BPF 	 * device packets with the first octet being 1 for outbound and 	 * 0 for inbound packets, so I (guy@alum.mit.edu) don't know 	 * whether that ever needs to be checked or not. 	 * 	 * Note that NetBSD has a DLT_PPP_SERIAL, which it uses for PPP, 	 * and its tcpdump appears to assume that the frame always 	 * begins with an address field and a control field, and that 	 * the address field might be 0x0f or 0x8f, for Cisco 	 * point-to-point with HDLC framing as per section 4.3.1 of RFC 	 * 1547, as well as 0xff, for PPP in HDLC-like framing as per 	 * RFC 1662. 	 * 	 * (Is the Cisco framing in question what DLT_C_HDLC, in 	 * BSD/OS, is?) 	 */
block|if (eflag) 		printf("%c %4d %02x ", p[0] ? 'O' : 'I', length, p[1]);
endif|#
directive|endif
name|ppp_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * PPP I/F printer to use if we know that RFC 1662-style PPP in HDLC-like  * framing, or Cisco PPP with HDLC framing as per section 4.3.1 of RFC 1547,  * is being used (i.e., we don't check for PPP_ADDRESS and PPP_CONTROL,  * discard them *if* those are the first two octets, and parse the remaining  * packet as a PPP packet, as "ppp_print()" does).  *  * This handles, for example, DLT_PPP_SERIAL in NetBSD.  */
end_comment

begin_function
name|u_int
name|ppp_hdlc_if_print
parameter_list|(
specifier|const
name|struct
name|pcap_pkthdr
modifier|*
name|h
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|p
parameter_list|)
block|{
specifier|register
name|u_int
name|length
init|=
name|h
operator|->
name|len
decl_stmt|;
specifier|register
name|u_int
name|caplen
init|=
name|h
operator|->
name|caplen
decl_stmt|;
name|u_int
name|proto
decl_stmt|;
name|u_int
name|hdrlen
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|caplen
operator|<
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"[|ppp]"
argument_list|)
expr_stmt|;
return|return
operator|(
name|caplen
operator|)
return|;
block|}
switch|switch
condition|(
name|p
index|[
literal|0
index|]
condition|)
block|{
case|case
name|PPP_ADDRESS
case|:
if|if
condition|(
name|caplen
operator|<
literal|4
condition|)
block|{
name|printf
argument_list|(
literal|"[|ppp]"
argument_list|)
expr_stmt|;
return|return
operator|(
name|caplen
operator|)
return|;
block|}
if|if
condition|(
name|eflag
condition|)
name|printf
argument_list|(
literal|"%02x %02x %d "
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
name|length
operator|-=
literal|2
expr_stmt|;
name|hdrlen
operator|+=
literal|2
expr_stmt|;
name|proto
operator|=
name|EXTRACT_16BITS
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
name|length
operator|-=
literal|2
expr_stmt|;
name|hdrlen
operator|+=
literal|2
expr_stmt|;
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|tok2str
argument_list|(
name|ppptype2str
argument_list|,
literal|"unknown PPP protocol (0x%04x)"
argument_list|,
name|proto
argument_list|)
argument_list|)
expr_stmt|;
name|handle_ppp
argument_list|(
name|proto
argument_list|,
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHDLC_UNICAST
case|:
case|case
name|CHDLC_BCAST
case|:
return|return
operator|(
name|chdlc_if_print
argument_list|(
name|h
argument_list|,
name|p
argument_list|)
operator|)
return|;
default|default:
if|if
condition|(
name|eflag
condition|)
name|printf
argument_list|(
literal|"%02x %02x %d "
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
name|length
operator|-=
literal|2
expr_stmt|;
name|hdrlen
operator|+=
literal|2
expr_stmt|;
comment|/* 		 * XXX - NetBSD's "ppp_netbsd_serial_if_print()" treats 		 * the next two octets as an Ethernet type; does that 		 * ever happen? 		 */
name|printf
argument_list|(
literal|"unknown addr %02x; ctrl %02x"
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|hdrlen
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PPP_BSDI_HDRLEN
value|24
end_define

begin_comment
comment|/* BSD/OS specific PPP printer */
end_comment

begin_function
name|u_int
name|ppp_bsdos_if_print
parameter_list|(
specifier|const
name|struct
name|pcap_pkthdr
modifier|*
name|h
name|_U_
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|p
name|_U_
parameter_list|)
block|{
specifier|register
name|int
name|hdrlength
decl_stmt|;
ifdef|#
directive|ifdef
name|__bsdi__
specifier|register
name|u_int
name|length
init|=
name|h
operator|->
name|len
decl_stmt|;
specifier|register
name|u_int
name|caplen
init|=
name|h
operator|->
name|caplen
decl_stmt|;
name|u_int16_t
name|ptype
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|q
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|caplen
operator|<
name|PPP_BSDI_HDRLEN
condition|)
block|{
name|printf
argument_list|(
literal|"[|ppp]"
argument_list|)
expr_stmt|;
return|return
operator|(
name|caplen
operator|)
block|}
name|hdrlength
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
block|if (p[0] == PPP_ADDRESS&& p[1] == PPP_CONTROL) { 		if (eflag) 			printf("%02x %02x ", p[0], p[1]); 		p += 2; 		hdrlength = 2; 	}  	if (eflag) 		printf("%d ", length);
comment|/* Retrieve the protocol type */
block|if (*p& 01) {
comment|/* Compressed protocol field */
block|ptype = *p; 		if (eflag) 			printf("%02x ", ptype); 		p++; 		hdrlength += 1; 	} else {
comment|/* Un-compressed protocol field */
block|ptype = ntohs(*(u_int16_t *)p); 		if (eflag) 			printf("%04x ", ptype); 		p += 2; 		hdrlength += 2; 	}
else|#
directive|else
name|ptype
operator|=
literal|0
expr_stmt|;
comment|/*XXX*/
if|if
condition|(
name|eflag
condition|)
name|printf
argument_list|(
literal|"%c "
argument_list|,
name|p
index|[
name|SLC_DIR
index|]
condition|?
literal|'O'
else|:
literal|'I'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
name|SLC_LLHL
index|]
condition|)
block|{
comment|/* link level header */
name|struct
name|ppp_header
modifier|*
name|ph
decl_stmt|;
name|q
operator|=
name|p
operator|+
name|SLC_BPFHDRLEN
expr_stmt|;
name|ph
operator|=
operator|(
expr|struct
name|ppp_header
operator|*
operator|)
name|q
expr_stmt|;
if|if
condition|(
name|ph
operator|->
name|phdr_addr
operator|==
name|PPP_ADDRESS
operator|&&
name|ph
operator|->
name|phdr_ctl
operator|==
name|PPP_CONTROL
condition|)
block|{
if|if
condition|(
name|eflag
condition|)
name|printf
argument_list|(
literal|"%02x %02x "
argument_list|,
name|q
index|[
literal|0
index|]
argument_list|,
name|q
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ptype
operator|=
name|ntohs
argument_list|(
name|ph
operator|->
name|phdr_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|eflag
operator|&&
operator|(
name|ptype
operator|==
name|PPP_VJC
operator|||
name|ptype
operator|==
name|PPP_VJNC
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|tok2str
argument_list|(
name|ppptype2str
argument_list|,
literal|"proto-#%d"
argument_list|,
name|ptype
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|eflag
condition|)
block|{
name|printf
argument_list|(
literal|"LLH=["
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
index|[
name|SLC_LLHL
index|]
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|q
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"] "
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|eflag
condition|)
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
name|SLC_CHL
index|]
condition|)
block|{
name|q
operator|=
name|p
operator|+
name|SLC_BPFHDRLEN
operator|+
name|p
index|[
name|SLC_LLHL
index|]
expr_stmt|;
switch|switch
condition|(
name|ptype
condition|)
block|{
case|case
name|PPP_VJC
case|:
name|ptype
operator|=
name|vjc_print
argument_list|(
name|q
argument_list|,
name|ptype
argument_list|)
expr_stmt|;
name|hdrlength
operator|=
name|PPP_BSDI_HDRLEN
expr_stmt|;
name|p
operator|+=
name|hdrlength
expr_stmt|;
switch|switch
condition|(
name|ptype
condition|)
block|{
case|case
name|PPP_IP
case|:
name|ip_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|PPP_IPV6
case|:
name|ip6_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|PPP_MPLS_UCAST
case|:
case|case
name|PPP_MPLS_MCAST
case|:
name|mpls_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|printx
goto|;
case|case
name|PPP_VJNC
case|:
name|ptype
operator|=
name|vjc_print
argument_list|(
name|q
argument_list|,
name|ptype
argument_list|)
expr_stmt|;
name|hdrlength
operator|=
name|PPP_BSDI_HDRLEN
expr_stmt|;
name|p
operator|+=
name|hdrlength
expr_stmt|;
switch|switch
condition|(
name|ptype
condition|)
block|{
case|case
name|PPP_IP
case|:
name|ip_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|PPP_IPV6
case|:
name|ip6_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|PPP_MPLS_UCAST
case|:
case|case
name|PPP_MPLS_MCAST
case|:
name|mpls_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|printx
goto|;
default|default:
if|if
condition|(
name|eflag
condition|)
block|{
name|printf
argument_list|(
literal|"CH=["
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
index|[
name|SLC_LLHL
index|]
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|q
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"] "
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
name|hdrlength
operator|=
name|PPP_BSDI_HDRLEN
expr_stmt|;
endif|#
directive|endif
name|length
operator|-=
name|hdrlength
expr_stmt|;
name|p
operator|+=
name|hdrlength
expr_stmt|;
switch|switch
condition|(
name|ptype
condition|)
block|{
case|case
name|PPP_IP
case|:
name|ip_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|PPP_IPV6
case|:
name|ip6_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|PPP_MPLS_UCAST
case|:
case|case
name|PPP_MPLS_MCAST
case|:
name|mpls_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|tok2str
argument_list|(
name|ppptype2str
argument_list|,
literal|"unknown PPP protocol (0x%04x)"
argument_list|,
name|ptype
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printx
label|:
else|#
directive|else
comment|/* __bsdi */
name|hdrlength
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* __bsdi__ */
return|return
operator|(
name|hdrlength
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Local Variables:  * c-style: whitesmith  * c-basic-offset: 8  * End:  */
end_comment

end_unit

