begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that: (1) source code  * distributions retain the above copyright notice and this paragraph  * in its entirety, and (2) distributions including binary code include  * the above copyright notice and this paragraph in its entirety in  * the documentation or other materials provided with the distribution.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND  * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT  * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS  * FOR A PARTICULAR PURPOSE.  *  * Copyright (c) 2009 Mojatatu Networks, Inc  *  */
end_comment

begin_define
define|#
directive|define
name|NETDISSECT_REWORKED
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<tcpdump-stdinc.h>
end_include

begin_include
include|#
directive|include
file|"interface.h"
end_include

begin_include
include|#
directive|include
file|"extract.h"
end_include

begin_decl_stmt
specifier|static
specifier|const
name|char
name|tstr
index|[]
init|=
literal|"[|forces]"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * RFC5810: Forwarding and Control Element Separation (ForCES) Protocol  */
end_comment

begin_define
define|#
directive|define
name|ForCES_VERS
value|1
end_define

begin_define
define|#
directive|define
name|ForCES_HDRL
value|24
end_define

begin_define
define|#
directive|define
name|ForCES_ALNL
value|4U
end_define

begin_define
define|#
directive|define
name|TLV_HDRL
value|4
end_define

begin_define
define|#
directive|define
name|ILV_HDRL
value|8
end_define

begin_define
define|#
directive|define
name|TOM_RSVD
value|0x0
end_define

begin_define
define|#
directive|define
name|TOM_ASSNSETUP
value|0x1
end_define

begin_define
define|#
directive|define
name|TOM_ASSNTEARD
value|0x2
end_define

begin_define
define|#
directive|define
name|TOM_CONFIG
value|0x3
end_define

begin_define
define|#
directive|define
name|TOM_QUERY
value|0x4
end_define

begin_define
define|#
directive|define
name|TOM_EVENTNOT
value|0x5
end_define

begin_define
define|#
directive|define
name|TOM_PKTREDIR
value|0x6
end_define

begin_define
define|#
directive|define
name|TOM_HEARTBT
value|0x0F
end_define

begin_define
define|#
directive|define
name|TOM_ASSNSETREP
value|0x11
end_define

begin_define
define|#
directive|define
name|TOM_CONFIGREP
value|0x13
end_define

begin_define
define|#
directive|define
name|TOM_QUERYREP
value|0x14
end_define

begin_comment
comment|/*  * tom_h Flags: resv1(8b):maxtlvs(4b):resv2(2b):mintlv(2b) */
end_comment

begin_define
define|#
directive|define
name|ZERO_TTLV
value|0x01
end_define

begin_define
define|#
directive|define
name|ZERO_MORE_TTLV
value|0x02
end_define

begin_define
define|#
directive|define
name|ONE_MORE_TTLV
value|0x04
end_define

begin_define
define|#
directive|define
name|ZERO_TLV
value|0x00
end_define

begin_define
define|#
directive|define
name|ONE_TLV
value|0x10
end_define

begin_define
define|#
directive|define
name|TWO_TLV
value|0x20
end_define

begin_define
define|#
directive|define
name|MAX_TLV
value|0xF0
end_define

begin_define
define|#
directive|define
name|TTLV_T1
value|(ONE_MORE_TTLV|ONE_TLV)
end_define

begin_define
define|#
directive|define
name|TTLV_T2
value|(ONE_MORE_TTLV|MAX_TLV)
end_define

begin_struct
struct|struct
name|tom_h
block|{
name|uint32_t
name|v
decl_stmt|;
name|uint16_t
name|flags
decl_stmt|;
name|uint16_t
name|op_msk
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
function_decl|(
modifier|*
name|print
function_decl|)
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|uint16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_enum
enum|enum
block|{
name|TOM_RSV_I
block|,
name|TOM_ASS_I
block|,
name|TOM_AST_I
block|,
name|TOM_CFG_I
block|,
name|TOM_QRY_I
block|,
name|TOM_EVN_I
block|,
name|TOM_RED_I
block|,
name|TOM_HBT_I
block|,
name|TOM_ASR_I
block|,
name|TOM_CNR_I
block|,
name|TOM_QRR_I
block|,
name|_TOM_RSV_MAX
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|TOM_MAX_IND
value|(_TOM_RSV_MAX - 1)
end_define

begin_function
specifier|static
specifier|inline
name|int
name|tom_valid
parameter_list|(
name|uint8_t
name|tom
parameter_list|)
block|{
if|if
condition|(
name|tom
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|tom
operator|>=
literal|0x7
operator|&&
name|tom
operator|<=
literal|0xe
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|tom
operator|==
literal|0x10
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|tom
operator|>
literal|0x14
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|ForCES_node
parameter_list|(
name|uint32_t
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|<=
literal|0x3FFFFFFF
condition|)
return|return
literal|"FE"
return|;
if|if
condition|(
name|node
operator|>=
literal|0x40000000
operator|&&
name|node
operator|<=
literal|0x7FFFFFFF
condition|)
return|return
literal|"CE"
return|;
if|if
condition|(
name|node
operator|>=
literal|0xC0000000
operator|&&
name|node
operator|<=
literal|0xFFFFFFEF
condition|)
return|return
literal|"AllMulticast"
return|;
if|if
condition|(
name|node
operator|==
literal|0xFFFFFFFD
condition|)
return|return
literal|"AllCEsBroadcast"
return|;
if|if
condition|(
name|node
operator|==
literal|0xFFFFFFFE
condition|)
return|return
literal|"AllFEsBroadcast"
return|;
if|if
condition|(
name|node
operator|==
literal|0xFFFFFFFF
condition|)
return|return
literal|"AllBroadcast"
return|;
return|return
literal|"ForCESreserved"
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|tok
name|ForCES_ACKs
index|[]
init|=
block|{
block|{
literal|0x0
block|,
literal|"NoACK"
block|}
block|,
block|{
literal|0x1
block|,
literal|"SuccessACK"
block|}
block|,
block|{
literal|0x2
block|,
literal|"FailureACK"
block|}
block|,
block|{
literal|0x3
block|,
literal|"AlwaysACK"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|tok
name|ForCES_EMs
index|[]
init|=
block|{
block|{
literal|0x0
block|,
literal|"EMReserved"
block|}
block|,
block|{
literal|0x1
block|,
literal|"execute-all-or-none"
block|}
block|,
block|{
literal|0x2
block|,
literal|"execute-until-failure"
block|}
block|,
block|{
literal|0x3
block|,
literal|"continue-execute-on-failure"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|tok
name|ForCES_ATs
index|[]
init|=
block|{
block|{
literal|0x0
block|,
literal|"Standalone"
block|}
block|,
block|{
literal|0x1
block|,
literal|"2PCtransaction"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|tok
name|ForCES_TPs
index|[]
init|=
block|{
block|{
literal|0x0
block|,
literal|"StartofTransaction"
block|}
block|,
block|{
literal|0x1
block|,
literal|"MiddleofTransaction"
block|}
block|,
block|{
literal|0x2
block|,
literal|"EndofTransaction"
block|}
block|,
block|{
literal|0x3
block|,
literal|"abort"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Structure of forces header, naked of TLVs.  */
end_comment

begin_struct
struct|struct
name|forcesh
block|{
name|uint8_t
name|fm_vrsvd
decl_stmt|;
comment|/* version and reserved */
define|#
directive|define
name|ForCES_V
parameter_list|(
name|forcesh
parameter_list|)
value|((forcesh)->fm_vrsvd>> 4)
name|uint8_t
name|fm_tom
decl_stmt|;
comment|/* type of message */
name|uint16_t
name|fm_len
decl_stmt|;
comment|/* total length * 4 bytes */
define|#
directive|define
name|ForCES_BLN
parameter_list|(
name|forcesh
parameter_list|)
value|((uint32_t)(EXTRACT_16BITS(&(forcesh)->fm_len)<< 2))
name|uint32_t
name|fm_sid
decl_stmt|;
comment|/* Source ID */
define|#
directive|define
name|ForCES_SID
parameter_list|(
name|forcesh
parameter_list|)
value|EXTRACT_32BITS(&(forcesh)->fm_sid)
name|uint32_t
name|fm_did
decl_stmt|;
comment|/* Destination ID */
define|#
directive|define
name|ForCES_DID
parameter_list|(
name|forcesh
parameter_list|)
value|EXTRACT_32BITS(&(forcesh)->fm_did)
name|uint8_t
name|fm_cor
index|[
literal|8
index|]
decl_stmt|;
comment|/* correlator */
name|uint32_t
name|fm_flags
decl_stmt|;
comment|/* flags */
define|#
directive|define
name|ForCES_ACK
parameter_list|(
name|forcesh
parameter_list|)
value|((EXTRACT_32BITS(&(forcesh)->fm_flags)&0xC0000000)>> 30)
define|#
directive|define
name|ForCES_PRI
parameter_list|(
name|forcesh
parameter_list|)
value|((EXTRACT_32BITS(&(forcesh)->fm_flags)&0x38000000)>> 27)
define|#
directive|define
name|ForCES_RS1
parameter_list|(
name|forcesh
parameter_list|)
value|((EXTRACT_32BITS(&(forcesh)->fm_flags)&0x07000000)>> 24)
define|#
directive|define
name|ForCES_EM
parameter_list|(
name|forcesh
parameter_list|)
value|((EXTRACT_32BITS(&(forcesh)->fm_flags)&0x00C00000)>> 22)
define|#
directive|define
name|ForCES_AT
parameter_list|(
name|forcesh
parameter_list|)
value|((EXTRACT_32BITS(&(forcesh)->fm_flags)&0x00200000)>> 21)
define|#
directive|define
name|ForCES_TP
parameter_list|(
name|forcesh
parameter_list|)
value|((EXTRACT_32BITS(&(forcesh)->fm_flags)&0x00180000)>> 19)
define|#
directive|define
name|ForCES_RS2
parameter_list|(
name|forcesh
parameter_list|)
value|((EXTRACT_32BITS(&(forcesh)->fm_flags)&0x0007FFFF)>> 0)
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ForCES_HLN_VALID
parameter_list|(
name|fhl
parameter_list|,
name|tlen
parameter_list|)
value|((tlen)>= ForCES_HDRL&& \ 				   (fhl)>= ForCES_HDRL&& \ 				   (fhl) == (tlen))
end_define

begin_define
define|#
directive|define
name|F_LFB_RSVD
value|0x0
end_define

begin_define
define|#
directive|define
name|F_LFB_FEO
value|0x1
end_define

begin_define
define|#
directive|define
name|F_LFB_FEPO
value|0x2
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|tok
name|ForCES_LFBs
index|[]
init|=
block|{
block|{
name|F_LFB_RSVD
block|,
literal|"Invalid TLV"
block|}
block|,
block|{
name|F_LFB_FEO
block|,
literal|"FEObj LFB"
block|}
block|,
block|{
name|F_LFB_FEPO
block|,
literal|"FEProtoObj LFB"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* this is defined in RFC5810 section A.2 */
end_comment

begin_comment
comment|/*   http://www.iana.org/assignments/forces/forces.xhtml#oper-tlv-types */
end_comment

begin_enum
enum|enum
block|{
name|F_OP_RSV
init|=
literal|0
block|,
name|F_OP_SET
init|=
literal|1
block|,
name|F_OP_SETPROP
init|=
literal|2
block|,
name|F_OP_SETRESP
init|=
literal|3
block|,
name|F_OP_SETPRESP
init|=
literal|4
block|,
name|F_OP_DEL
init|=
literal|5
block|,
name|F_OP_DELRESP
init|=
literal|6
block|,
name|F_OP_GET
init|=
literal|7
block|,
name|F_OP_GETPROP
init|=
literal|8
block|,
name|F_OP_GETRESP
init|=
literal|9
block|,
name|F_OP_GETPRESP
init|=
literal|10
block|,
name|F_OP_REPORT
init|=
literal|11
block|,
name|F_OP_COMMIT
init|=
literal|12
block|,
name|F_OP_RCOMMIT
init|=
literal|13
block|,
name|F_OP_RTRCOMP
init|=
literal|14
block|,
name|_F_OP_MAX
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|F_OP_MAX
value|(_F_OP_MAX - 1)
end_define

begin_enum
enum|enum
block|{
name|B_OP_SET
init|=
literal|1
operator|<<
operator|(
name|F_OP_SET
operator|-
literal|1
operator|)
block|,
name|B_OP_SETPROP
init|=
literal|1
operator|<<
operator|(
name|F_OP_SETPROP
operator|-
literal|1
operator|)
block|,
name|B_OP_SETRESP
init|=
literal|1
operator|<<
operator|(
name|F_OP_SETRESP
operator|-
literal|1
operator|)
block|,
name|B_OP_SETPRESP
init|=
literal|1
operator|<<
operator|(
name|F_OP_SETPRESP
operator|-
literal|1
operator|)
block|,
name|B_OP_DEL
init|=
literal|1
operator|<<
operator|(
name|F_OP_DEL
operator|-
literal|1
operator|)
block|,
name|B_OP_DELRESP
init|=
literal|1
operator|<<
operator|(
name|F_OP_DELRESP
operator|-
literal|1
operator|)
block|,
name|B_OP_GET
init|=
literal|1
operator|<<
operator|(
name|F_OP_GET
operator|-
literal|1
operator|)
block|,
name|B_OP_GETPROP
init|=
literal|1
operator|<<
operator|(
name|F_OP_GETPROP
operator|-
literal|1
operator|)
block|,
name|B_OP_GETRESP
init|=
literal|1
operator|<<
operator|(
name|F_OP_GETRESP
operator|-
literal|1
operator|)
block|,
name|B_OP_GETPRESP
init|=
literal|1
operator|<<
operator|(
name|F_OP_GETPRESP
operator|-
literal|1
operator|)
block|,
name|B_OP_REPORT
init|=
literal|1
operator|<<
operator|(
name|F_OP_REPORT
operator|-
literal|1
operator|)
block|,
name|B_OP_COMMIT
init|=
literal|1
operator|<<
operator|(
name|F_OP_COMMIT
operator|-
literal|1
operator|)
block|,
name|B_OP_RCOMMIT
init|=
literal|1
operator|<<
operator|(
name|F_OP_RCOMMIT
operator|-
literal|1
operator|)
block|,
name|B_OP_RTRCOMP
init|=
literal|1
operator|<<
operator|(
name|F_OP_RTRCOMP
operator|-
literal|1
operator|)
block|, }
enum|;
end_enum

begin_struct
struct|struct
name|optlv_h
block|{
name|uint16_t
name|flags
decl_stmt|;
name|uint16_t
name|op_msk
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
function_decl|(
modifier|*
name|print
function_decl|)
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|uint16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|genoptlv_print
parameter_list|(
name|netdissect_options
modifier|*
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|uint16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|recpdoptlv_print
parameter_list|(
name|netdissect_options
modifier|*
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|uint16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|invoptlv_print
parameter_list|(
name|netdissect_options
modifier|*
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|uint16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|OP_MIN_SIZ
value|8
end_define

begin_struct
struct|struct
name|pathdata_h
block|{
name|uint16_t
name|pflags
decl_stmt|;
name|uint16_t
name|pIDcnt
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|B_FULLD
value|0x1
end_define

begin_define
define|#
directive|define
name|B_SPARD
value|0x2
end_define

begin_define
define|#
directive|define
name|B_RESTV
value|0x4
end_define

begin_define
define|#
directive|define
name|B_KEYIN
value|0x8
end_define

begin_define
define|#
directive|define
name|B_APPND
value|0x10
end_define

begin_define
define|#
directive|define
name|B_TRNG
value|0x20
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|optlv_h
name|OPTLV_msg
index|[
name|F_OP_MAX
operator|+
literal|1
index|]
init|=
block|{
comment|/* F_OP_RSV */
block|{
name|ZERO_TTLV
block|,
literal|0
block|,
literal|"Invalid OPTLV"
block|,
name|invoptlv_print
block|}
block|,
comment|/* F_OP_SET */
block|{
name|TTLV_T2
block|,
name|B_FULLD
operator||
name|B_SPARD
block|,
literal|" Set"
block|,
name|recpdoptlv_print
block|}
block|,
comment|/* F_OP_SETPROP */
block|{
name|TTLV_T2
block|,
name|B_FULLD
operator||
name|B_SPARD
block|,
literal|" SetProp"
block|,
name|recpdoptlv_print
block|}
block|,
comment|/* F_OP_SETRESP */
block|{
name|TTLV_T2
block|,
name|B_RESTV
block|,
literal|" SetResp"
block|,
name|recpdoptlv_print
block|}
block|,
comment|/* F_OP_SETPRESP */
block|{
name|TTLV_T2
block|,
name|B_RESTV
block|,
literal|" SetPropResp"
block|,
name|recpdoptlv_print
block|}
block|,
comment|/* F_OP_DEL */
block|{
name|ZERO_TTLV
block|,
literal|0
block|,
literal|" Del"
block|,
name|recpdoptlv_print
block|}
block|,
comment|/* F_OP_DELRESP */
block|{
name|TTLV_T2
block|,
name|B_RESTV
block|,
literal|" DelResp"
block|,
name|recpdoptlv_print
block|}
block|,
comment|/* F_OP_GET */
block|{
name|ZERO_TTLV
block|,
literal|0
block|,
literal|" Get"
block|,
name|recpdoptlv_print
block|}
block|,
comment|/* F_OP_GETPROP */
block|{
name|ZERO_TTLV
block|,
literal|0
block|,
literal|" GetProp"
block|,
name|recpdoptlv_print
block|}
block|,
comment|/* F_OP_GETRESP */
block|{
name|TTLV_T2
block|,
name|B_FULLD
operator||
name|B_SPARD
operator||
name|B_RESTV
block|,
literal|" GetResp"
block|,
name|recpdoptlv_print
block|}
block|,
comment|/* F_OP_GETPRESP */
block|{
name|TTLV_T2
block|,
name|B_FULLD
operator||
name|B_RESTV
block|,
literal|" GetPropResp"
block|,
name|recpdoptlv_print
block|}
block|,
comment|/* F_OP_REPORT */
block|{
name|TTLV_T2
block|,
name|B_FULLD
operator||
name|B_SPARD
block|,
literal|" Report"
block|,
name|recpdoptlv_print
block|}
block|,
comment|/* F_OP_COMMIT */
block|{
name|ZERO_TTLV
block|,
literal|0
block|,
literal|" Commit"
block|,
name|NULL
block|}
block|,
comment|/* F_OP_RCOMMIT */
block|{
name|TTLV_T1
block|,
name|B_RESTV
block|,
literal|" RCommit"
block|,
name|genoptlv_print
block|}
block|,
comment|/* F_OP_RTRCOMP */
block|{
name|ZERO_TTLV
block|,
literal|0
block|,
literal|" RTRCOMP"
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
specifier|const
name|struct
name|optlv_h
modifier|*
name|get_forces_optlv_h
parameter_list|(
name|uint16_t
name|opt
parameter_list|)
block|{
if|if
condition|(
name|opt
operator|>
name|F_OP_MAX
operator|||
name|opt
operator|<=
name|F_OP_RSV
condition|)
return|return
operator|&
name|OPTLV_msg
index|[
name|F_OP_RSV
index|]
return|;
return|return
operator|&
name|OPTLV_msg
index|[
name|opt
index|]
return|;
block|}
end_function

begin_define
define|#
directive|define
name|IND_SIZE
value|256
end_define

begin_define
define|#
directive|define
name|IND_CHR
value|' '
end_define

begin_define
define|#
directive|define
name|IND_PREF
value|'\n'
end_define

begin_define
define|#
directive|define
name|IND_SUF
value|0x0
end_define

begin_decl_stmt
name|char
name|ind_buf
index|[
name|IND_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|char
modifier|*
name|indent_pr
parameter_list|(
name|int
name|indent
parameter_list|,
name|int
name|nlpref
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|r
init|=
name|ind_buf
decl_stmt|;
if|if
condition|(
name|indent
operator|>
operator|(
name|IND_SIZE
operator|-
literal|1
operator|)
condition|)
name|indent
operator|=
name|IND_SIZE
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|nlpref
condition|)
block|{
name|r
index|[
name|i
index|]
operator|=
name|IND_PREF
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|indent
operator|--
expr_stmt|;
block|}
while|while
condition|(
operator|--
name|indent
operator|>=
literal|0
condition|)
name|r
index|[
name|i
operator|++
index|]
operator|=
name|IND_CHR
expr_stmt|;
name|r
index|[
name|i
index|]
operator|=
name|IND_SUF
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|op_valid
parameter_list|(
name|uint16_t
name|op
parameter_list|,
name|uint16_t
name|mask
parameter_list|)
block|{
name|int
name|opb
init|=
literal|1
operator|<<
operator|(
name|op
operator|-
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|op
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|opb
operator|&
name|mask
condition|)
return|return
literal|1
return|;
comment|/* I guess we should allow vendor operations? */
if|if
condition|(
name|op
operator|>=
literal|0x8000
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|F_TLV_RSVD
value|0x0000
end_define

begin_define
define|#
directive|define
name|F_TLV_REDR
value|0x0001
end_define

begin_define
define|#
directive|define
name|F_TLV_ASRS
value|0x0010
end_define

begin_define
define|#
directive|define
name|F_TLV_ASRT
value|0x0011
end_define

begin_define
define|#
directive|define
name|F_TLV_LFBS
value|0x1000
end_define

begin_define
define|#
directive|define
name|F_TLV_PDAT
value|0x0110
end_define

begin_define
define|#
directive|define
name|F_TLV_KEYI
value|0x0111
end_define

begin_define
define|#
directive|define
name|F_TLV_FULD
value|0x0112
end_define

begin_define
define|#
directive|define
name|F_TLV_SPAD
value|0x0113
end_define

begin_define
define|#
directive|define
name|F_TLV_REST
value|0x0114
end_define

begin_define
define|#
directive|define
name|F_TLV_METD
value|0x0115
end_define

begin_define
define|#
directive|define
name|F_TLV_REDD
value|0x0116
end_define

begin_define
define|#
directive|define
name|F_TLV_TRNG
value|0x0117
end_define

begin_define
define|#
directive|define
name|F_TLV_VNST
value|0x8000
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|tok
name|ForCES_TLV
index|[]
init|=
block|{
block|{
name|F_TLV_RSVD
block|,
literal|"Invalid TLV"
block|}
block|,
block|{
name|F_TLV_REDR
block|,
literal|"REDIRECT TLV"
block|}
block|,
block|{
name|F_TLV_ASRS
block|,
literal|"ASResult TLV"
block|}
block|,
block|{
name|F_TLV_ASRT
block|,
literal|"ASTreason TLV"
block|}
block|,
block|{
name|F_TLV_LFBS
block|,
literal|"LFBselect TLV"
block|}
block|,
block|{
name|F_TLV_PDAT
block|,
literal|"PATH-DATA TLV"
block|}
block|,
block|{
name|F_TLV_KEYI
block|,
literal|"KEYINFO TLV"
block|}
block|,
block|{
name|F_TLV_FULD
block|,
literal|"FULLDATA TLV"
block|}
block|,
block|{
name|F_TLV_SPAD
block|,
literal|"SPARSEDATA TLV"
block|}
block|,
block|{
name|F_TLV_REST
block|,
literal|"RESULT TLV"
block|}
block|,
block|{
name|F_TLV_METD
block|,
literal|"METADATA TLV"
block|}
block|,
block|{
name|F_TLV_REDD
block|,
literal|"REDIRECTDATA TLV"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TLV_HLN
value|4
end_define

begin_function
specifier|static
specifier|inline
name|int
name|ttlv_valid
parameter_list|(
name|uint16_t
name|ttlv
parameter_list|)
block|{
if|if
condition|(
name|ttlv
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|ttlv
operator|==
literal|1
operator|||
name|ttlv
operator|==
literal|0x1000
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|ttlv
operator|>=
literal|0x10
operator|&&
name|ttlv
operator|<=
literal|0x11
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|ttlv
operator|>=
literal|0x110
operator|&&
name|ttlv
operator|<=
literal|0x116
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|ttlv
operator|>=
literal|0x8000
condition|)
return|return
literal|0
return|;
comment|/* XXX: */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_struct
struct|struct
name|forces_ilv
block|{
name|uint32_t
name|type
decl_stmt|;
name|uint32_t
name|length
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|forces_tlv
block|{
name|uint16_t
name|type
decl_stmt|;
name|uint16_t
name|length
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|F_ALN_LEN
parameter_list|(
name|len
parameter_list|)
value|( ((len)+ForCES_ALNL-1)& ~(ForCES_ALNL-1) )
end_define

begin_define
define|#
directive|define
name|GET_TOP_TLV
parameter_list|(
name|fhdr
parameter_list|)
value|((struct forces_tlv *)((fhdr) + sizeof (struct forcesh)))
end_define

begin_define
define|#
directive|define
name|TLV_SET_LEN
parameter_list|(
name|len
parameter_list|)
value|(F_ALN_LEN(TLV_HDRL) + (len))
end_define

begin_define
define|#
directive|define
name|TLV_ALN_LEN
parameter_list|(
name|len
parameter_list|)
value|F_ALN_LEN(TLV_SET_LEN(len))
end_define

begin_define
define|#
directive|define
name|TLV_RDAT_LEN
parameter_list|(
name|tlv
parameter_list|)
value|((int)(EXTRACT_16BITS(&(tlv)->length) - TLV_SET_LEN(0))
end_define

begin_define
define|#
directive|define
name|TLV_DATA
parameter_list|(
name|tlvp
parameter_list|)
value|((void*)(((char*)(tlvp)) + TLV_SET_LEN(0)))
end_define

begin_define
define|#
directive|define
name|GO_NXT_TLV
parameter_list|(
name|tlv
parameter_list|,
name|rlen
parameter_list|)
value|((rlen) -= F_ALN_LEN(EXTRACT_16BITS(&(tlv)->length)), \ 		              (struct forces_tlv*)(((char*)(tlv)) \ 				      + F_ALN_LEN(EXTRACT_16BITS(&(tlv)->length))))
end_define

begin_define
define|#
directive|define
name|ILV_SET_LEN
parameter_list|(
name|len
parameter_list|)
value|(F_ALN_LEN(ILV_HDRL) + (len))
end_define

begin_define
define|#
directive|define
name|ILV_ALN_LEN
parameter_list|(
name|len
parameter_list|)
value|F_ALN_LEN(ILV_SET_LEN(len))
end_define

begin_define
define|#
directive|define
name|ILV_RDAT_LEN
parameter_list|(
name|ilv
parameter_list|)
value|((int)(EXTRACT_32BITS(&(ilv)->length)) - ILV_SET_LEN(0))
end_define

begin_define
define|#
directive|define
name|ILV_DATA
parameter_list|(
name|ilvp
parameter_list|)
value|((void*)(((char*)(ilvp)) + ILV_SET_LEN(0)))
end_define

begin_define
define|#
directive|define
name|GO_NXT_ILV
parameter_list|(
name|ilv
parameter_list|,
name|rlen
parameter_list|)
value|((rlen) -= F_ALN_LEN(EXTRACT_32BITS(&(ilv)->length)), \ 		              (struct forces_ilv *)(((char*)(ilv)) \ 				      + F_ALN_LEN(EXTRACT_32BITS(&(ilv)->length))))
end_define

begin_define
define|#
directive|define
name|INVALID_RLEN
value|1
end_define

begin_define
define|#
directive|define
name|INVALID_STLN
value|2
end_define

begin_define
define|#
directive|define
name|INVALID_LTLN
value|3
end_define

begin_define
define|#
directive|define
name|INVALID_ALEN
value|4
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|tok
name|ForCES_TLV_err
index|[]
init|=
block|{
block|{
name|INVALID_RLEN
block|,
literal|"Invalid total length"
block|}
block|,
block|{
name|INVALID_STLN
block|,
literal|"xLV too short"
block|}
block|,
block|{
name|INVALID_LTLN
block|,
literal|"xLV too long"
block|}
block|,
block|{
name|INVALID_ALEN
block|,
literal|"data padding missing"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|u_int
name|tlv_valid
parameter_list|(
specifier|const
name|struct
name|forces_tlv
modifier|*
name|tlv
parameter_list|,
name|u_int
name|rlen
parameter_list|)
block|{
if|if
condition|(
name|rlen
operator|<
name|TLV_HDRL
condition|)
return|return
name|INVALID_RLEN
return|;
if|if
condition|(
name|EXTRACT_16BITS
argument_list|(
operator|&
name|tlv
operator|->
name|length
argument_list|)
operator|<
name|TLV_HDRL
condition|)
return|return
name|INVALID_STLN
return|;
if|if
condition|(
name|EXTRACT_16BITS
argument_list|(
operator|&
name|tlv
operator|->
name|length
argument_list|)
operator|>
name|rlen
condition|)
return|return
name|INVALID_LTLN
return|;
if|if
condition|(
name|rlen
operator|<
name|F_ALN_LEN
argument_list|(
name|EXTRACT_16BITS
argument_list|(
operator|&
name|tlv
operator|->
name|length
argument_list|)
argument_list|)
condition|)
return|return
name|INVALID_ALEN
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|ilv_valid
parameter_list|(
specifier|const
name|struct
name|forces_ilv
modifier|*
name|ilv
parameter_list|,
name|u_int
name|rlen
parameter_list|)
block|{
if|if
condition|(
name|rlen
operator|<
name|ILV_HDRL
condition|)
return|return
name|INVALID_RLEN
return|;
if|if
condition|(
name|EXTRACT_32BITS
argument_list|(
operator|&
name|ilv
operator|->
name|length
argument_list|)
operator|<
name|ILV_HDRL
condition|)
return|return
name|INVALID_STLN
return|;
if|if
condition|(
name|EXTRACT_32BITS
argument_list|(
operator|&
name|ilv
operator|->
name|length
argument_list|)
operator|>
name|rlen
condition|)
return|return
name|INVALID_LTLN
return|;
if|if
condition|(
name|rlen
operator|<
name|F_ALN_LEN
argument_list|(
name|EXTRACT_32BITS
argument_list|(
operator|&
name|ilv
operator|->
name|length
argument_list|)
argument_list|)
condition|)
return|return
name|INVALID_ALEN
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function_decl
specifier|static
name|int
name|lfbselect_print
parameter_list|(
name|netdissect_options
modifier|*
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|uint16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|redirect_print
parameter_list|(
name|netdissect_options
modifier|*
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|uint16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|asrtlv_print
parameter_list|(
name|netdissect_options
modifier|*
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|uint16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|asttlv_print
parameter_list|(
name|netdissect_options
modifier|*
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|uint16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|forces_lfbsh
block|{
name|uint32_t
name|class
decl_stmt|;
name|uint32_t
name|instance
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ASSNS_OPS
value|(B_OP_REPORT)
end_define

begin_define
define|#
directive|define
name|CFG_OPS
value|(B_OP_SET|B_OP_SETPROP|B_OP_DEL|B_OP_COMMIT|B_OP_RTRCOMP)
end_define

begin_define
define|#
directive|define
name|CFG_ROPS
value|(B_OP_SETRESP|B_OP_SETPRESP|B_OP_DELRESP|B_OP_RCOMMIT)
end_define

begin_define
define|#
directive|define
name|CFG_QY
value|(B_OP_GET|B_OP_GETPROP)
end_define

begin_define
define|#
directive|define
name|CFG_QYR
value|(B_OP_GETRESP|B_OP_GETPRESP)
end_define

begin_define
define|#
directive|define
name|CFG_EVN
value|(B_OP_REPORT)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|tom_h
name|ForCES_msg
index|[
name|TOM_MAX_IND
operator|+
literal|1
index|]
init|=
block|{
comment|/* TOM_RSV_I */
block|{
name|TOM_RSVD
block|,
name|ZERO_TTLV
block|,
literal|0
block|,
literal|"Invalid message"
block|,
name|NULL
block|}
block|,
comment|/* TOM_ASS_I */
block|{
name|TOM_ASSNSETUP
block|,
name|ZERO_MORE_TTLV
operator||
name|TWO_TLV
block|,
name|ASSNS_OPS
block|,
literal|"Association Setup"
block|,
name|lfbselect_print
block|}
block|,
comment|/* TOM_AST_I */
block|{
name|TOM_ASSNTEARD
block|,
name|TTLV_T1
block|,
literal|0
block|,
literal|"Association TearDown"
block|,
name|asttlv_print
block|}
block|,
comment|/* TOM_CFG_I */
block|{
name|TOM_CONFIG
block|,
name|TTLV_T2
block|,
name|CFG_OPS
block|,
literal|"Config"
block|,
name|lfbselect_print
block|}
block|,
comment|/* TOM_QRY_I */
block|{
name|TOM_QUERY
block|,
name|TTLV_T2
block|,
name|CFG_QY
block|,
literal|"Query"
block|,
name|lfbselect_print
block|}
block|,
comment|/* TOM_EVN_I */
block|{
name|TOM_EVENTNOT
block|,
name|TTLV_T1
block|,
name|CFG_EVN
block|,
literal|"Event Notification"
block|,
name|lfbselect_print
block|}
block|,
comment|/* TOM_RED_I */
block|{
name|TOM_PKTREDIR
block|,
name|TTLV_T2
block|,
literal|0
block|,
literal|"Packet Redirect"
block|,
name|redirect_print
block|}
block|,
comment|/* TOM_HBT_I */
block|{
name|TOM_HEARTBT
block|,
name|ZERO_TTLV
block|,
literal|0
block|,
literal|"HeartBeat"
block|,
name|NULL
block|}
block|,
comment|/* TOM_ASR_I */
block|{
name|TOM_ASSNSETREP
block|,
name|TTLV_T1
block|,
literal|0
block|,
literal|"Association Response"
block|,
name|asrtlv_print
block|}
block|,
comment|/* TOM_CNR_I */
block|{
name|TOM_CONFIGREP
block|,
name|TTLV_T2
block|,
name|CFG_ROPS
block|,
literal|"Config Response"
block|,
name|lfbselect_print
block|}
block|,
comment|/* TOM_QRR_I */
block|{
name|TOM_QUERYREP
block|,
name|TTLV_T2
block|,
name|CFG_QYR
block|,
literal|"Query Response"
block|,
name|lfbselect_print
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
specifier|const
name|struct
name|tom_h
modifier|*
name|get_forces_tom
parameter_list|(
name|uint8_t
name|tom
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|TOM_RSV_I
init|;
name|i
operator|<=
name|TOM_MAX_IND
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|tom_h
modifier|*
name|th
init|=
operator|&
name|ForCES_msg
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|th
operator|->
name|v
operator|==
name|tom
condition|)
return|return
name|th
return|;
block|}
return|return
operator|&
name|ForCES_msg
index|[
name|TOM_RSV_I
index|]
return|;
block|}
end_function

begin_struct
struct|struct
name|pdata_ops
block|{
name|uint32_t
name|v
decl_stmt|;
name|uint16_t
name|flags
decl_stmt|;
name|uint16_t
name|op_msk
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
function_decl|(
modifier|*
name|print
function_decl|)
parameter_list|(
name|netdissect_options
modifier|*
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|uint16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_enum
enum|enum
block|{
name|PD_RSV_I
block|,
name|PD_SEL_I
block|,
name|PD_FDT_I
block|,
name|PD_SDT_I
block|,
name|PD_RES_I
block|,
name|PD_PDT_I
block|,
name|_PD_RSV_MAX
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|PD_MAX_IND
value|(_TOM_RSV_MAX - 1)
end_define

begin_function
specifier|static
specifier|inline
name|int
name|pd_valid
parameter_list|(
name|uint16_t
name|pd
parameter_list|)
block|{
if|if
condition|(
name|pd
operator|>=
name|F_TLV_PDAT
operator|&&
name|pd
operator|<=
name|F_TLV_REST
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|chk_op_type
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
name|uint16_t
name|type
parameter_list|,
name|uint16_t
name|msk
parameter_list|,
name|uint16_t
name|omsk
parameter_list|)
block|{
if|if
condition|(
name|type
operator|!=
name|F_TLV_PDAT
condition|)
block|{
if|if
condition|(
name|msk
operator|&
name|B_KEYIN
condition|)
block|{
if|if
condition|(
name|type
operator|!=
name|F_TLV_KEYI
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"Based on flags expected KEYINFO TLV!\n"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|msk
operator|&
name|omsk
operator|)
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"Illegal DATA encoding for type 0x%x programmed %x got %x \n"
operator|,
name|type
operator|,
name|omsk
operator|,
name|msk
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_define
define|#
directive|define
name|F_SELKEY
value|1
end_define

begin_define
define|#
directive|define
name|F_SELTABRANGE
value|2
end_define

begin_define
define|#
directive|define
name|F_TABAPPEND
value|4
end_define

begin_struct
struct|struct
name|res_val
block|{
name|uint8_t
name|result
decl_stmt|;
name|uint8_t
name|resv1
decl_stmt|;
name|uint16_t
name|resv2
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|prestlv_print
parameter_list|(
name|netdissect_options
modifier|*
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|uint16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pkeyitlv_print
parameter_list|(
name|netdissect_options
modifier|*
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|uint16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fdatatlv_print
parameter_list|(
name|netdissect_options
modifier|*
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|uint16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sdatatlv_print
parameter_list|(
name|netdissect_options
modifier|*
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|uint16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|pdata_ops
name|ForCES_pdata
index|[
name|PD_MAX_IND
operator|+
literal|1
index|]
init|=
block|{
comment|/* PD_RSV_I */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"Invalid message"
block|,
name|NULL
block|}
block|,
comment|/* PD_SEL_I */
block|{
name|F_TLV_KEYI
block|,
literal|0
block|,
literal|0
block|,
literal|"KEYINFO TLV"
block|,
name|pkeyitlv_print
block|}
block|,
comment|/* PD_FDT_I */
block|{
name|F_TLV_FULD
block|,
literal|0
block|,
name|B_FULLD
block|,
literal|"FULLDATA TLV"
block|,
name|fdatatlv_print
block|}
block|,
comment|/* PD_SDT_I */
block|{
name|F_TLV_SPAD
block|,
literal|0
block|,
name|B_SPARD
block|,
literal|"SPARSEDATA TLV"
block|,
name|sdatatlv_print
block|}
block|,
comment|/* PD_RES_I */
block|{
name|F_TLV_REST
block|,
literal|0
block|,
name|B_RESTV
block|,
literal|"RESULT TLV"
block|,
name|prestlv_print
block|}
block|,
comment|/* PD_PDT_I */
block|{
name|F_TLV_PDAT
block|,
literal|0
block|,
literal|0
block|,
literal|"Inner PATH-DATA TLV"
block|,
name|recpdoptlv_print
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
specifier|const
name|struct
name|pdata_ops
modifier|*
name|get_forces_pd
parameter_list|(
name|uint16_t
name|pd
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|PD_RSV_I
operator|+
literal|1
init|;
name|i
operator|<=
name|PD_MAX_IND
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|pdata_ops
modifier|*
name|pdo
init|=
operator|&
name|ForCES_pdata
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|pdo
operator|->
name|v
operator|==
name|pd
condition|)
return|return
name|pdo
return|;
block|}
return|return
operator|&
name|ForCES_pdata
index|[
name|TOM_RSV_I
index|]
return|;
block|}
end_function

begin_enum
enum|enum
block|{
name|E_SUCCESS
block|,
name|E_INVALID_HEADER
block|,
name|E_LENGTH_MISMATCH
block|,
name|E_VERSION_MISMATCH
block|,
name|E_INVALID_DESTINATION_PID
block|,
name|E_LFB_UNKNOWN
block|,
name|E_LFB_NOT_FOUND
block|,
name|E_LFB_INSTANCE_ID_NOT_FOUND
block|,
name|E_INVALID_PATH
block|,
name|E_COMPONENT_DOES_NOT_EXIST
block|,
name|E_EXISTS
block|,
name|E_NOT_FOUND
block|,
name|E_READ_ONLY
block|,
name|E_INVALID_ARRAY_CREATION
block|,
name|E_VALUE_OUT_OF_RANGE
block|,
name|E_CONTENTS_TOO_LONG
block|,
name|E_INVALID_PARAMETERS
block|,
name|E_INVALID_MESSAGE_TYPE
block|,
name|E_INVALID_FLAGS
block|,
name|E_INVALID_TLV
block|,
name|E_EVENT_ERROR
block|,
name|E_NOT_SUPPORTED
block|,
name|E_MEMORY_ERROR
block|,
name|E_INTERNAL_ERROR
block|,
comment|/* 0x18-0xFE are reserved .. */
name|E_UNSPECIFIED_ERROR
init|=
literal|0XFF
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|tok
name|ForCES_errs
index|[]
init|=
block|{
block|{
name|E_SUCCESS
block|,
literal|"SUCCESS"
block|}
block|,
block|{
name|E_INVALID_HEADER
block|,
literal|"INVALID HEADER"
block|}
block|,
block|{
name|E_LENGTH_MISMATCH
block|,
literal|"LENGTH MISMATCH"
block|}
block|,
block|{
name|E_VERSION_MISMATCH
block|,
literal|"VERSION MISMATCH"
block|}
block|,
block|{
name|E_INVALID_DESTINATION_PID
block|,
literal|"INVALID DESTINATION PID"
block|}
block|,
block|{
name|E_LFB_UNKNOWN
block|,
literal|"LFB UNKNOWN"
block|}
block|,
block|{
name|E_LFB_NOT_FOUND
block|,
literal|"LFB NOT FOUND"
block|}
block|,
block|{
name|E_LFB_INSTANCE_ID_NOT_FOUND
block|,
literal|"LFB INSTANCE ID NOT FOUND"
block|}
block|,
block|{
name|E_INVALID_PATH
block|,
literal|"INVALID PATH"
block|}
block|,
block|{
name|E_COMPONENT_DOES_NOT_EXIST
block|,
literal|"COMPONENT DOES NOT EXIST"
block|}
block|,
block|{
name|E_EXISTS
block|,
literal|"EXISTS ALREADY"
block|}
block|,
block|{
name|E_NOT_FOUND
block|,
literal|"NOT FOUND"
block|}
block|,
block|{
name|E_READ_ONLY
block|,
literal|"READ ONLY"
block|}
block|,
block|{
name|E_INVALID_ARRAY_CREATION
block|,
literal|"INVALID ARRAY CREATION"
block|}
block|,
block|{
name|E_VALUE_OUT_OF_RANGE
block|,
literal|"VALUE OUT OF RANGE"
block|}
block|,
block|{
name|E_CONTENTS_TOO_LONG
block|,
literal|"CONTENTS TOO LONG"
block|}
block|,
block|{
name|E_INVALID_PARAMETERS
block|,
literal|"INVALID PARAMETERS"
block|}
block|,
block|{
name|E_INVALID_MESSAGE_TYPE
block|,
literal|"INVALID MESSAGE TYPE"
block|}
block|,
block|{
name|E_INVALID_FLAGS
block|,
literal|"INVALID FLAGS"
block|}
block|,
block|{
name|E_INVALID_TLV
block|,
literal|"INVALID TLV"
block|}
block|,
block|{
name|E_EVENT_ERROR
block|,
literal|"EVENT ERROR"
block|}
block|,
block|{
name|E_NOT_SUPPORTED
block|,
literal|"NOT SUPPORTED"
block|}
block|,
block|{
name|E_MEMORY_ERROR
block|,
literal|"MEMORY ERROR"
block|}
block|,
block|{
name|E_INTERNAL_ERROR
block|,
literal|"INTERNAL ERROR"
block|}
block|,
block|{
name|E_UNSPECIFIED_ERROR
block|,
literal|"UNSPECIFIED ERROR"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RESLEN
value|4
end_define

begin_function
specifier|static
name|int
name|prestlv_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|uint16_t
name|op_msk
name|_U_
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
specifier|const
name|struct
name|forces_tlv
modifier|*
name|tlv
init|=
operator|(
expr|struct
name|forces_tlv
operator|*
operator|)
name|pptr
decl_stmt|;
specifier|register
specifier|const
name|u_char
modifier|*
name|tdp
init|=
operator|(
name|u_char
operator|*
operator|)
name|TLV_DATA
argument_list|(
name|tlv
argument_list|)
decl_stmt|;
name|struct
name|res_val
modifier|*
name|r
init|=
operator|(
expr|struct
name|res_val
operator|*
operator|)
name|tdp
decl_stmt|;
name|u_int
name|dlen
decl_stmt|;
comment|/* 	 * pdatacnt_print() has ensured that len (the TLV length) 	 *>= TLV_HDRL. 	 */
name|dlen
operator|=
name|len
operator|-
name|TLV_HDRL
expr_stmt|;
if|if
condition|(
name|dlen
operator|!=
name|RESLEN
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"illegal RESULT-TLV: %d bytes!\n"
operator|,
name|dlen
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ND_TCHECK
argument_list|(
operator|*
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|result
operator|>=
literal|0x18
operator|&&
name|r
operator|->
name|result
operator|<=
literal|0xFE
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"illegal reserved result code: 0x%x!\n"
operator|,
name|r
operator|->
name|result
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
operator|>=
literal|3
condition|)
block|{
name|char
modifier|*
name|ib
init|=
name|indent_pr
argument_list|(
name|indent
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s  Result: %s (code 0x%x)\n"
operator|,
name|ib
operator|,
name|tok2str
argument_list|(
name|ForCES_errs
argument_list|,
name|NULL
argument_list|,
name|r
operator|->
name|result
argument_list|)
operator|,
name|r
operator|->
name|result
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
name|trunc
label|:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s"
operator|,
name|tstr
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fdatatlv_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|uint16_t
name|op_msk
name|_U_
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
specifier|const
name|struct
name|forces_tlv
modifier|*
name|tlv
init|=
operator|(
expr|struct
name|forces_tlv
operator|*
operator|)
name|pptr
decl_stmt|;
name|u_int
name|rlen
decl_stmt|;
specifier|register
specifier|const
name|u_char
modifier|*
name|tdp
init|=
operator|(
name|u_char
operator|*
operator|)
name|TLV_DATA
argument_list|(
name|tlv
argument_list|)
decl_stmt|;
name|uint16_t
name|type
decl_stmt|;
comment|/* 	 * pdatacnt_print() or pkeyitlv_print() has ensured that len 	 * (the TLV length)>= TLV_HDRL. 	 */
name|rlen
operator|=
name|len
operator|-
name|TLV_HDRL
expr_stmt|;
name|ND_TCHECK
argument_list|(
operator|*
name|tlv
argument_list|)
expr_stmt|;
name|type
operator|=
name|EXTRACT_16BITS
argument_list|(
operator|&
name|tlv
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|F_TLV_FULD
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"Error: expecting FULLDATA!\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
operator|>=
literal|3
condition|)
block|{
name|char
modifier|*
name|ib
init|=
name|indent_pr
argument_list|(
name|indent
operator|+
literal|2
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s["
operator|,
operator|&
name|ib
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
name|hex_print_with_offset
argument_list|(
name|ndo
argument_list|,
name|ib
argument_list|,
name|tdp
argument_list|,
name|rlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\n%s]\n"
operator|,
operator|&
name|ib
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
name|trunc
label|:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s"
operator|,
name|tstr
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sdatailv_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|uint16_t
name|op_msk
name|_U_
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|u_int
name|rlen
decl_stmt|;
specifier|const
name|struct
name|forces_ilv
modifier|*
name|ilv
init|=
operator|(
expr|struct
name|forces_ilv
operator|*
operator|)
name|pptr
decl_stmt|;
name|int
name|invilv
decl_stmt|;
if|if
condition|(
name|len
operator|<
name|ILV_HDRL
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"Error: BAD SPARSEDATA-TLV!\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|rlen
operator|=
name|len
expr_stmt|;
name|indent
operator|+=
literal|1
expr_stmt|;
while|while
condition|(
name|rlen
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
literal|0
block|ND_PRINT((ndo, "Jamal - outstanding length<%d>\n", rlen));
endif|#
directive|endif
name|char
modifier|*
name|ib
init|=
name|indent_pr
argument_list|(
name|indent
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|register
specifier|const
name|u_char
modifier|*
name|tdp
init|=
operator|(
name|u_char
operator|*
operator|)
name|ILV_DATA
argument_list|(
name|ilv
argument_list|)
decl_stmt|;
name|ND_TCHECK
argument_list|(
operator|*
name|ilv
argument_list|)
expr_stmt|;
name|invilv
operator|=
name|ilv_valid
argument_list|(
name|ilv
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|invilv
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s["
operator|,
operator|&
name|ib
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
name|hex_print_with_offset
argument_list|(
name|ndo
argument_list|,
name|ib
argument_list|,
name|tdp
argument_list|,
name|rlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\n%s]\n"
operator|,
operator|&
name|ib
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
operator|>=
literal|3
condition|)
block|{
name|int
name|ilvl
init|=
name|EXTRACT_32BITS
argument_list|(
operator|&
name|ilv
operator|->
name|length
argument_list|)
decl_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\n%s ILV: type %x length %d\n"
operator|,
operator|&
name|ib
index|[
literal|1
index|]
operator|,
name|EXTRACT_32BITS
argument_list|(
operator|&
name|ilv
operator|->
name|type
argument_list|)
operator|,
name|ilvl
operator|)
argument_list|)
expr_stmt|;
name|hex_print_with_offset
argument_list|(
name|ndo
argument_list|,
literal|"\t\t["
argument_list|,
name|tdp
argument_list|,
name|ilvl
operator|-
name|ILV_HDRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ilv
operator|=
name|GO_NXT_ILV
argument_list|(
name|ilv
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
name|trunc
label|:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s"
operator|,
name|tstr
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sdatatlv_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|uint16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
specifier|const
name|struct
name|forces_tlv
modifier|*
name|tlv
init|=
operator|(
expr|struct
name|forces_tlv
operator|*
operator|)
name|pptr
decl_stmt|;
name|u_int
name|rlen
decl_stmt|;
specifier|register
specifier|const
name|u_char
modifier|*
name|tdp
init|=
operator|(
name|u_char
operator|*
operator|)
name|TLV_DATA
argument_list|(
name|tlv
argument_list|)
decl_stmt|;
name|uint16_t
name|type
decl_stmt|;
comment|/* 	 * pdatacnt_print() has ensured that len (the TLV length) 	 *>= TLV_HDRL. 	 */
name|rlen
operator|=
name|len
operator|-
name|TLV_HDRL
expr_stmt|;
name|ND_TCHECK
argument_list|(
operator|*
name|tlv
argument_list|)
expr_stmt|;
name|type
operator|=
name|EXTRACT_16BITS
argument_list|(
operator|&
name|tlv
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|F_TLV_SPAD
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"Error: expecting SPARSEDATA!\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|sdatailv_print
argument_list|(
name|ndo
argument_list|,
name|tdp
argument_list|,
name|rlen
argument_list|,
name|op_msk
argument_list|,
name|indent
argument_list|)
return|;
name|trunc
label|:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s"
operator|,
name|tstr
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pkeyitlv_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|uint16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
specifier|const
name|struct
name|forces_tlv
modifier|*
name|tlv
init|=
operator|(
expr|struct
name|forces_tlv
operator|*
operator|)
name|pptr
decl_stmt|;
specifier|register
specifier|const
name|u_char
modifier|*
name|tdp
init|=
operator|(
name|u_char
operator|*
operator|)
name|TLV_DATA
argument_list|(
name|tlv
argument_list|)
decl_stmt|;
specifier|register
specifier|const
name|u_char
modifier|*
name|dp
init|=
name|tdp
operator|+
literal|4
decl_stmt|;
specifier|const
name|struct
name|forces_tlv
modifier|*
name|kdtlv
init|=
operator|(
expr|struct
name|forces_tlv
operator|*
operator|)
name|dp
decl_stmt|;
name|uint32_t
name|id
decl_stmt|;
name|char
modifier|*
name|ib
init|=
name|indent_pr
argument_list|(
name|indent
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|uint16_t
name|type
decl_stmt|,
name|tll
decl_stmt|;
name|u_int
name|invtlv
decl_stmt|;
name|ND_TCHECK
argument_list|(
operator|*
name|tdp
argument_list|)
expr_stmt|;
name|id
operator|=
name|EXTRACT_32BITS
argument_list|(
name|tdp
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%sKeyinfo: Key 0x%x\n"
operator|,
name|ib
operator|,
name|id
operator|)
argument_list|)
expr_stmt|;
name|ND_TCHECK
argument_list|(
operator|*
name|kdtlv
argument_list|)
expr_stmt|;
name|type
operator|=
name|EXTRACT_16BITS
argument_list|(
operator|&
name|kdtlv
operator|->
name|type
argument_list|)
expr_stmt|;
name|invtlv
operator|=
name|tlv_valid
argument_list|(
name|kdtlv
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|invtlv
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s TLV type 0x%x len %d\n"
operator|,
name|tok2str
argument_list|(
name|ForCES_TLV_err
argument_list|,
name|NULL
argument_list|,
name|invtlv
argument_list|)
operator|,
name|type
operator|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|kdtlv
operator|->
name|length
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 	 * At this point, tlv_valid() has ensured that the TLV 	 * length is large enough but not too large (it doesn't 	 * go past the end of the containing TLV). 	 */
name|tll
operator|=
name|EXTRACT_16BITS
argument_list|(
operator|&
name|kdtlv
operator|->
name|length
argument_list|)
expr_stmt|;
name|dp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|TLV_DATA
argument_list|(
name|kdtlv
argument_list|)
expr_stmt|;
return|return
name|fdatatlv_print
argument_list|(
name|ndo
argument_list|,
name|dp
argument_list|,
name|tll
argument_list|,
name|op_msk
argument_list|,
name|indent
argument_list|)
return|;
name|trunc
label|:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s"
operator|,
name|tstr
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PTH_DESC_SIZE
value|12
end_define

begin_function
specifier|static
name|int
name|pdatacnt_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|uint16_t
name|IDcnt
parameter_list|,
name|uint16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|uint32_t
name|id
decl_stmt|;
name|char
modifier|*
name|ib
init|=
name|indent_pr
argument_list|(
name|indent
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|op_msk
operator|&
name|B_APPND
operator|)
operator|&&
name|ndo
operator|->
name|ndo_vflag
operator|>=
literal|3
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%sTABLE APPEND\n"
operator|,
name|ib
operator|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IDcnt
condition|;
name|i
operator|++
control|)
block|{
name|ND_TCHECK2
argument_list|(
operator|*
name|pptr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|4
condition|)
goto|goto
name|trunc
goto|;
name|id
operator|=
name|EXTRACT_32BITS
argument_list|(
name|pptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
operator|>=
literal|3
condition|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%sID#%02u: %d\n"
operator|,
name|ib
operator|,
name|i
operator|+
literal|1
operator|,
name|id
operator|)
argument_list|)
expr_stmt|;
name|len
operator|-=
literal|4
expr_stmt|;
name|pptr
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|op_msk
operator|&
name|B_TRNG
operator|)
operator|||
operator|(
name|op_msk
operator|&
name|B_KEYIN
operator|)
condition|)
block|{
if|if
condition|(
name|op_msk
operator|&
name|B_TRNG
condition|)
block|{
name|uint32_t
name|starti
decl_stmt|,
name|endi
decl_stmt|;
if|if
condition|(
name|len
operator|<
name|PTH_DESC_SIZE
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"pathlength %d with key/range too short %d\n"
operator|,
name|len
operator|,
name|PTH_DESC_SIZE
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|pptr
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|forces_tlv
argument_list|)
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|forces_tlv
argument_list|)
expr_stmt|;
name|starti
operator|=
name|EXTRACT_32BITS
argument_list|(
name|pptr
argument_list|)
expr_stmt|;
name|pptr
operator|+=
literal|4
expr_stmt|;
name|len
operator|-=
literal|4
expr_stmt|;
name|endi
operator|=
name|EXTRACT_32BITS
argument_list|(
name|pptr
argument_list|)
expr_stmt|;
name|pptr
operator|+=
literal|4
expr_stmt|;
name|len
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
operator|>=
literal|3
condition|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%sTable range: [%d,%d]\n"
operator|,
name|ib
operator|,
name|starti
operator|,
name|endi
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op_msk
operator|&
name|B_KEYIN
condition|)
block|{
name|struct
name|forces_tlv
modifier|*
name|keytlv
decl_stmt|;
name|uint16_t
name|tll
decl_stmt|;
if|if
condition|(
name|len
operator|<
name|PTH_DESC_SIZE
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"pathlength %d with key/range too short %d\n"
operator|,
name|len
operator|,
name|PTH_DESC_SIZE
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* skip keyid */
name|pptr
operator|+=
literal|4
expr_stmt|;
name|len
operator|-=
literal|4
expr_stmt|;
name|keytlv
operator|=
operator|(
expr|struct
name|forces_tlv
operator|*
operator|)
name|pptr
expr_stmt|;
comment|/* skip header */
name|pptr
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|forces_tlv
argument_list|)
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|forces_tlv
argument_list|)
expr_stmt|;
comment|/* skip key content */
name|tll
operator|=
name|EXTRACT_16BITS
argument_list|(
operator|&
name|keytlv
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|tll
operator|<
name|TLV_HDRL
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"key content length %u< %u\n"
operator|,
name|tll
operator|,
name|TLV_HDRL
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|tll
operator|-=
name|TLV_HDRL
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|tll
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"key content too short\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|pptr
operator|+=
name|tll
expr_stmt|;
name|len
operator|-=
name|tll
expr_stmt|;
block|}
block|}
if|if
condition|(
name|len
condition|)
block|{
specifier|const
name|struct
name|forces_tlv
modifier|*
name|pdtlv
init|=
operator|(
expr|struct
name|forces_tlv
operator|*
operator|)
name|pptr
decl_stmt|;
name|uint16_t
name|type
decl_stmt|;
name|uint16_t
name|tll
decl_stmt|;
name|int
name|pad
init|=
literal|0
decl_stmt|;
name|u_int
name|aln
decl_stmt|;
name|u_int
name|invtlv
decl_stmt|;
name|ND_TCHECK
argument_list|(
operator|*
name|pdtlv
argument_list|)
expr_stmt|;
name|type
operator|=
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|type
argument_list|)
expr_stmt|;
name|invtlv
operator|=
name|tlv_valid
argument_list|(
name|pdtlv
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|invtlv
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s Outstanding bytes %d for TLV type 0x%x TLV len %d\n"
operator|,
name|tok2str
argument_list|(
name|ForCES_TLV_err
argument_list|,
name|NULL
argument_list|,
name|invtlv
argument_list|)
operator|,
name|len
operator|,
name|type
operator|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|length
argument_list|)
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|pd_err
goto|;
block|}
comment|/* 		 * At this point, tlv_valid() has ensured that the TLV 		 * length is large enough but not too large (it doesn't 		 * go past the end of the containing TLV). 		 */
name|tll
operator|=
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|length
argument_list|)
operator|-
name|TLV_HDRL
expr_stmt|;
name|aln
operator|=
name|F_ALN_LEN
argument_list|(
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|length
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|aln
operator|>
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|length
argument_list|)
condition|)
block|{
if|if
condition|(
name|aln
operator|>
name|len
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"Invalid padded pathdata TLV type 0x%x len %d missing %d pad bytes\n"
operator|,
name|type
operator|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|length
argument_list|)
operator|,
name|aln
operator|-
name|len
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pad
operator|=
name|aln
operator|-
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pd_valid
argument_list|(
name|type
argument_list|)
condition|)
block|{
specifier|const
name|struct
name|pdata_ops
modifier|*
name|ops
init|=
name|get_forces_pd
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
operator|>=
literal|3
operator|&&
name|ops
operator|->
name|v
operator|!=
name|F_TLV_PDAT
condition|)
block|{
if|if
condition|(
name|pad
condition|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s  %s (Length %d DataLen %d pad %d Bytes)\n"
operator|,
name|ib
operator|,
name|ops
operator|->
name|s
operator|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|length
argument_list|)
operator|,
name|tll
operator|,
name|pad
operator|)
argument_list|)
expr_stmt|;
else|else
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s  %s (Length %d DataLen %d Bytes)\n"
operator|,
name|ib
operator|,
name|ops
operator|->
name|s
operator|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|length
argument_list|)
operator|,
name|tll
operator|)
argument_list|)
expr_stmt|;
block|}
name|chk_op_type
argument_list|(
name|ndo
argument_list|,
name|type
argument_list|,
name|op_msk
argument_list|,
name|ops
operator|->
name|op_msk
argument_list|)
expr_stmt|;
if|if
condition|(
name|ops
operator|->
name|print
argument_list|(
name|ndo
argument_list|,
operator|(
specifier|const
name|u_char
operator|*
operator|)
name|pdtlv
argument_list|,
name|tll
operator|+
name|pad
operator|+
name|TLV_HDRL
argument_list|,
name|op_msk
argument_list|,
name|indent
operator|+
literal|2
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|len
operator|-=
operator|(
name|TLV_HDRL
operator|+
name|pad
operator|+
name|tll
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"Invalid path data content type 0x%x len %d\n"
operator|,
name|type
operator|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|length
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|pd_err
label|:
if|if
condition|(
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|length
argument_list|)
condition|)
block|{
name|hex_print_with_offset
argument_list|(
name|ndo
argument_list|,
literal|"Bad Data val\n\t  ["
argument_list|,
name|pptr
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"]\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
return|return
name|len
return|;
name|trunc
label|:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s"
operator|,
name|tstr
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pdata_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|uint16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
specifier|const
name|struct
name|pathdata_h
modifier|*
name|pdh
init|=
operator|(
expr|struct
name|pathdata_h
operator|*
operator|)
name|pptr
decl_stmt|;
name|char
modifier|*
name|ib
init|=
name|indent_pr
argument_list|(
name|indent
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|u_int
name|minsize
init|=
literal|0
decl_stmt|;
name|int
name|more_pd
init|=
literal|0
decl_stmt|;
name|uint16_t
name|idcnt
init|=
literal|0
decl_stmt|;
name|ND_TCHECK
argument_list|(
operator|*
name|pdh
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|pathdata_h
argument_list|)
condition|)
goto|goto
name|trunc
goto|;
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
operator|>=
literal|3
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\n%sPathdata: Flags 0x%x ID count %d\n"
operator|,
name|ib
operator|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdh
operator|->
name|pflags
argument_list|)
operator|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdh
operator|->
name|pIDcnt
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdh
operator|->
name|pflags
argument_list|)
operator|&
name|F_SELKEY
condition|)
block|{
name|op_msk
operator||=
name|B_KEYIN
expr_stmt|;
block|}
comment|/* Table GET Range operation */
if|if
condition|(
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdh
operator|->
name|pflags
argument_list|)
operator|&
name|F_SELTABRANGE
condition|)
block|{
name|op_msk
operator||=
name|B_TRNG
expr_stmt|;
block|}
comment|/* Table SET append operation */
if|if
condition|(
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdh
operator|->
name|pflags
argument_list|)
operator|&
name|F_TABAPPEND
condition|)
block|{
name|op_msk
operator||=
name|B_APPND
expr_stmt|;
block|}
name|pptr
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|pathdata_h
argument_list|)
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|pathdata_h
argument_list|)
expr_stmt|;
name|idcnt
operator|=
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdh
operator|->
name|pIDcnt
argument_list|)
expr_stmt|;
name|minsize
operator|=
name|idcnt
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|minsize
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\t\t\ttruncated IDs expected %uB got %uB\n"
operator|,
name|minsize
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
name|hex_print_with_offset
argument_list|(
name|ndo
argument_list|,
literal|"\t\t\tID Data["
argument_list|,
name|pptr
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"]\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|op_msk
operator|&
name|B_TRNG
operator|)
operator|&&
operator|(
name|op_msk
operator|&
name|B_KEYIN
operator|)
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\t\t\tIllegal to have both Table ranges and keys\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|more_pd
operator|=
name|pdatacnt_print
argument_list|(
name|ndo
argument_list|,
name|pptr
argument_list|,
name|len
argument_list|,
name|idcnt
argument_list|,
name|op_msk
argument_list|,
name|indent
argument_list|)
expr_stmt|;
if|if
condition|(
name|more_pd
operator|>
literal|0
condition|)
block|{
name|int
name|consumed
init|=
name|len
operator|-
name|more_pd
decl_stmt|;
name|pptr
operator|+=
name|consumed
expr_stmt|;
name|len
operator|=
name|more_pd
expr_stmt|;
comment|/* XXX: Argh, recurse some more */
return|return
name|recpdoptlv_print
argument_list|(
name|ndo
argument_list|,
name|pptr
argument_list|,
name|len
argument_list|,
name|op_msk
argument_list|,
name|indent
operator|+
literal|1
argument_list|)
return|;
block|}
else|else
return|return
literal|0
return|;
name|trunc
label|:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s"
operator|,
name|tstr
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|genoptlv_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|uint16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
specifier|const
name|struct
name|forces_tlv
modifier|*
name|pdtlv
init|=
operator|(
expr|struct
name|forces_tlv
operator|*
operator|)
name|pptr
decl_stmt|;
name|uint16_t
name|type
decl_stmt|;
name|int
name|tll
decl_stmt|;
name|u_int
name|invtlv
decl_stmt|;
name|char
modifier|*
name|ib
init|=
name|indent_pr
argument_list|(
name|indent
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ND_TCHECK
argument_list|(
operator|*
name|pdtlv
argument_list|)
expr_stmt|;
name|type
operator|=
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|type
argument_list|)
expr_stmt|;
name|tll
operator|=
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|length
argument_list|)
operator|-
name|TLV_HDRL
expr_stmt|;
name|invtlv
operator|=
name|tlv_valid
argument_list|(
name|pdtlv
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"genoptlvprint - %s TLV type 0x%x len %d\n"
operator|,
name|tok2str
argument_list|(
name|ForCES_TLV
argument_list|,
name|NULL
argument_list|,
name|type
argument_list|)
operator|,
name|type
operator|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|length
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|invtlv
condition|)
block|{
comment|/* 		 * At this point, tlv_valid() has ensured that the TLV 		 * length is large enough but not too large (it doesn't 		 * go past the end of the containing TLV). 		 */
specifier|register
specifier|const
name|u_char
modifier|*
name|dp
init|=
operator|(
name|u_char
operator|*
operator|)
name|TLV_DATA
argument_list|(
name|pdtlv
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ttlv_valid
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s TLV type 0x%x len %d\n"
operator|,
name|tok2str
argument_list|(
name|ForCES_TLV_err
argument_list|,
name|NULL
argument_list|,
name|invtlv
argument_list|)
operator|,
name|type
operator|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|length
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
operator|>=
literal|3
condition|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s%s, length %d (data length %d Bytes)"
operator|,
name|ib
operator|,
name|tok2str
argument_list|(
name|ForCES_TLV
argument_list|,
name|NULL
argument_list|,
name|type
argument_list|)
operator|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|length
argument_list|)
operator|,
name|tll
operator|)
argument_list|)
expr_stmt|;
return|return
name|pdata_print
argument_list|(
name|ndo
argument_list|,
name|dp
argument_list|,
name|tll
argument_list|,
name|op_msk
argument_list|,
name|indent
operator|+
literal|1
argument_list|)
return|;
block|}
else|else
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\t\t\tInvalid ForCES TLV type=%x"
operator|,
name|type
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|trunc
label|:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s"
operator|,
name|tstr
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|recpdoptlv_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|uint16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
specifier|const
name|struct
name|forces_tlv
modifier|*
name|pdtlv
init|=
operator|(
expr|struct
name|forces_tlv
operator|*
operator|)
name|pptr
decl_stmt|;
name|int
name|tll
decl_stmt|;
name|u_int
name|invtlv
decl_stmt|;
name|uint16_t
name|type
decl_stmt|;
specifier|register
specifier|const
name|u_char
modifier|*
name|dp
decl_stmt|;
name|char
modifier|*
name|ib
decl_stmt|;
while|while
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|ND_TCHECK
argument_list|(
operator|*
name|pdtlv
argument_list|)
expr_stmt|;
name|invtlv
operator|=
name|tlv_valid
argument_list|(
name|pdtlv
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|invtlv
condition|)
block|{
break|break;
block|}
comment|/* 		 * At this point, tlv_valid() has ensured that the TLV 		 * length is large enough but not too large (it doesn't 		 * go past the end of the containing TLV). 		 */
name|ib
operator|=
name|indent_pr
argument_list|(
name|indent
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|type
operator|=
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|type
argument_list|)
expr_stmt|;
name|dp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|TLV_DATA
argument_list|(
name|pdtlv
argument_list|)
expr_stmt|;
name|tll
operator|=
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|length
argument_list|)
operator|-
name|TLV_HDRL
expr_stmt|;
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
operator|>=
literal|3
condition|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s%s, length %d (data encapsulated %d Bytes)"
operator|,
name|ib
operator|,
name|tok2str
argument_list|(
name|ForCES_TLV
argument_list|,
name|NULL
argument_list|,
name|type
argument_list|)
operator|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|length
argument_list|)
operator|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|length
argument_list|)
operator|-
name|TLV_HDRL
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdata_print
argument_list|(
name|ndo
argument_list|,
name|dp
argument_list|,
name|tll
argument_list|,
name|op_msk
argument_list|,
name|indent
operator|+
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|pdtlv
operator|=
name|GO_NXT_TLV
argument_list|(
name|pdtlv
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\n\t\tMessy PATHDATA TLV header, type (0x%x)\n\t\texcess of %d Bytes "
operator|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|type
argument_list|)
operator|,
name|len
operator|-
name|EXTRACT_16BITS
argument_list|(
operator|&
name|pdtlv
operator|->
name|length
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
name|trunc
label|:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s"
operator|,
name|tstr
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|invoptlv_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|uint16_t
name|op_msk
name|_U_
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|char
modifier|*
name|ib
init|=
name|indent_pr
argument_list|(
name|indent
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
operator|>=
literal|3
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%sData["
operator|,
operator|&
name|ib
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
name|hex_print_with_offset
argument_list|(
name|ndo
argument_list|,
name|ib
argument_list|,
name|pptr
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s]\n"
operator|,
name|ib
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|otlv_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|const
name|struct
name|forces_tlv
modifier|*
name|otlv
parameter_list|,
name|uint16_t
name|op_msk
name|_U_
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
specifier|register
specifier|const
name|u_char
modifier|*
name|dp
init|=
operator|(
name|u_char
operator|*
operator|)
name|TLV_DATA
argument_list|(
name|otlv
argument_list|)
decl_stmt|;
name|uint16_t
name|type
decl_stmt|;
name|int
name|tll
decl_stmt|;
name|char
modifier|*
name|ib
init|=
name|indent_pr
argument_list|(
name|indent
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|optlv_h
modifier|*
name|ops
decl_stmt|;
comment|/* 	 * lfbselect_print() has ensured that EXTRACT_16BITS(&otlv->length) 	 *>= TLV_HDRL. 	 */
name|ND_TCHECK
argument_list|(
operator|*
name|otlv
argument_list|)
expr_stmt|;
name|type
operator|=
name|EXTRACT_16BITS
argument_list|(
operator|&
name|otlv
operator|->
name|type
argument_list|)
expr_stmt|;
name|tll
operator|=
name|EXTRACT_16BITS
argument_list|(
operator|&
name|otlv
operator|->
name|length
argument_list|)
operator|-
name|TLV_HDRL
expr_stmt|;
name|ops
operator|=
name|get_forces_optlv_h
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
operator|>=
literal|3
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%sOper TLV %s(0x%x) length %d\n"
operator|,
name|ib
operator|,
name|ops
operator|->
name|s
operator|,
name|type
operator|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|otlv
operator|->
name|length
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* rest of ops must at least have 12B {pathinfo} */
if|if
condition|(
name|tll
operator|<
name|OP_MIN_SIZ
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\t\tOper TLV %s(0x%x) length %d\n"
operator|,
name|ops
operator|->
name|s
operator|,
name|type
operator|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|otlv
operator|->
name|length
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\t\tTruncated data size %d minimum required %d\n"
operator|,
name|tll
operator|,
name|OP_MIN_SIZ
operator|)
argument_list|)
expr_stmt|;
return|return
name|invoptlv_print
argument_list|(
name|ndo
argument_list|,
name|dp
argument_list|,
name|tll
argument_list|,
name|ops
operator|->
name|op_msk
argument_list|,
name|indent
argument_list|)
return|;
block|}
comment|/* XXX - do anything with ops->flags? */
if|if
condition|(
name|ops
operator|->
name|print
condition|)
block|{
name|rc
operator|=
name|ops
operator|->
name|print
argument_list|(
name|ndo
argument_list|,
name|dp
argument_list|,
name|tll
argument_list|,
name|ops
operator|->
name|op_msk
argument_list|,
name|indent
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
return|;
name|trunc
label|:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s"
operator|,
name|tstr
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ASTDLN
value|4
end_define

begin_define
define|#
directive|define
name|ASTMCD
value|255
end_define

begin_function
specifier|static
name|int
name|asttlv_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|uint16_t
name|op_msk
name|_U_
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|uint32_t
name|rescode
decl_stmt|;
name|u_int
name|dlen
decl_stmt|;
name|char
modifier|*
name|ib
init|=
name|indent_pr
argument_list|(
name|indent
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* 	 * forces_type_print() has ensured that len (the TLV length) 	 *>= TLV_HDRL. 	 */
name|dlen
operator|=
name|len
operator|-
name|TLV_HDRL
expr_stmt|;
if|if
condition|(
name|dlen
operator|!=
name|ASTDLN
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"illegal ASTresult-TLV: %d bytes!\n"
operator|,
name|dlen
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ND_TCHECK2
argument_list|(
operator|*
name|pptr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|rescode
operator|=
name|EXTRACT_32BITS
argument_list|(
name|pptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rescode
operator|>
name|ASTMCD
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"illegal ASTresult result code: %d!\n"
operator|,
name|rescode
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
operator|>=
literal|3
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"Teardown reason:\n%s"
operator|,
name|ib
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rescode
condition|)
block|{
case|case
literal|0
case|:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"Normal Teardown"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"Loss of Heartbeats"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"Out of bandwidth"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"Out of Memory"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"Application Crash"
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"Unknown Teardown reason"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"(%x)\n%s"
operator|,
name|rescode
operator|,
name|ib
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
name|trunc
label|:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s"
operator|,
name|tstr
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ASRDLN
value|4
end_define

begin_define
define|#
directive|define
name|ASRMCD
value|3
end_define

begin_function
specifier|static
name|int
name|asrtlv_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|uint16_t
name|op_msk
name|_U_
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|uint32_t
name|rescode
decl_stmt|;
name|u_int
name|dlen
decl_stmt|;
name|char
modifier|*
name|ib
init|=
name|indent_pr
argument_list|(
name|indent
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* 	 * forces_type_print() has ensured that len (the TLV length) 	 *>= TLV_HDRL. 	 */
name|dlen
operator|=
name|len
operator|-
name|TLV_HDRL
expr_stmt|;
if|if
condition|(
name|dlen
operator|!=
name|ASRDLN
condition|)
block|{
comment|/* id, instance, oper tlv */
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"illegal ASRresult-TLV: %d bytes!\n"
operator|,
name|dlen
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ND_TCHECK2
argument_list|(
operator|*
name|pptr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|rescode
operator|=
name|EXTRACT_32BITS
argument_list|(
name|pptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rescode
operator|>
name|ASRMCD
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"illegal ASRresult result code: %d!\n"
operator|,
name|rescode
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
operator|>=
literal|3
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\n%s"
operator|,
name|ib
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rescode
condition|)
block|{
case|case
literal|0
case|:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"Success "
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"FE ID invalid "
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"permission denied "
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"Unknown "
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"(%x)\n%s"
operator|,
name|rescode
operator|,
name|ib
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
name|trunc
label|:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s"
operator|,
name|tstr
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * XXX - not used.  */
end_comment

begin_comment
unit|static int gentltlv_print(netdissect_options *ndo,                register const u_char * pptr _U_, register u_int len,                uint16_t op_msk _U_, int indent _U_) { 	u_int dlen = len - TLV_HDRL;  	if (dlen< 4) {
comment|/* at least 32 bits must exist */
end_comment

begin_endif
unit|ND_PRINT((ndo, "truncated TLV: %d bytes missing! ", 4 - dlen)); 		return -1; 	} 	return 0; }
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|RD_MIN
value|8
end_define

begin_function
specifier|static
name|int
name|print_metailv
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
name|uint16_t
name|op_msk
name|_U_
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|u_int
name|rlen
decl_stmt|;
name|char
modifier|*
name|ib
init|=
name|indent_pr
argument_list|(
name|indent
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* XXX: check header length */
specifier|const
name|struct
name|forces_ilv
modifier|*
name|ilv
init|=
operator|(
expr|struct
name|forces_ilv
operator|*
operator|)
name|pptr
decl_stmt|;
comment|/* 	 * print_metatlv() has ensured that len (what remains in the 	 * ILV)>= ILV_HDRL. 	 */
name|rlen
operator|=
name|EXTRACT_32BITS
argument_list|(
operator|&
name|ilv
operator|->
name|length
argument_list|)
operator|-
name|ILV_HDRL
expr_stmt|;
name|ND_TCHECK
argument_list|(
operator|*
name|ilv
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%sMetaID 0x%x length %d\n"
operator|,
name|ib
operator|,
name|EXTRACT_32BITS
argument_list|(
operator|&
name|ilv
operator|->
name|type
argument_list|)
operator|,
name|EXTRACT_32BITS
argument_list|(
operator|&
name|ilv
operator|->
name|length
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
operator|>=
literal|3
condition|)
block|{
name|hex_print_with_offset
argument_list|(
name|ndo
argument_list|,
literal|"\t\t["
argument_list|,
name|ILV_DATA
argument_list|(
name|ilv
argument_list|)
argument_list|,
name|rlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|" ]\n"
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
name|trunc
label|:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s"
operator|,
name|tstr
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|print_metatlv
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|uint16_t
name|op_msk
name|_U_
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|u_int
name|dlen
decl_stmt|;
name|char
modifier|*
name|ib
init|=
name|indent_pr
argument_list|(
name|indent
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|u_int
name|rlen
decl_stmt|;
specifier|const
name|struct
name|forces_ilv
modifier|*
name|ilv
init|=
operator|(
expr|struct
name|forces_ilv
operator|*
operator|)
name|pptr
decl_stmt|;
name|int
name|invilv
decl_stmt|;
comment|/* 	 * redirect_print() has ensured that len (what remains in the 	 * TLV)>= TLV_HDRL. 	 */
name|dlen
operator|=
name|len
operator|-
name|TLV_HDRL
expr_stmt|;
name|rlen
operator|=
name|dlen
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\n%s METADATA length %d \n"
operator|,
name|ib
operator|,
name|rlen
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|rlen
operator|!=
literal|0
condition|)
block|{
name|ND_TCHECK
argument_list|(
operator|*
name|ilv
argument_list|)
expr_stmt|;
name|invilv
operator|=
name|ilv_valid
argument_list|(
name|ilv
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|invilv
condition|)
block|{
break|break;
block|}
comment|/* 		 * At this point, ilv_valid() has ensured that the ILV 		 * length is large enough but not too large (it doesn't 		 * go past the end of the containing TLV). 		 */
name|print_metailv
argument_list|(
name|ndo
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|ilv
argument_list|,
literal|0
argument_list|,
name|indent
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ilv
operator|=
name|GO_NXT_ILV
argument_list|(
name|ilv
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
name|trunc
label|:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s"
operator|,
name|tstr
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|print_reddata
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|uint16_t
name|op_msk
name|_U_
parameter_list|,
name|int
name|indent
name|_U_
parameter_list|)
block|{
name|u_int
name|dlen
decl_stmt|;
name|char
modifier|*
name|ib
init|=
name|indent_pr
argument_list|(
name|indent
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|u_int
name|rlen
decl_stmt|;
name|dlen
operator|=
name|len
operator|-
name|TLV_HDRL
expr_stmt|;
name|rlen
operator|=
name|dlen
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\n%s Redirect Data length %d \n"
operator|,
name|ib
operator|,
name|rlen
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
operator|>=
literal|3
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\t\t["
operator|)
argument_list|)
expr_stmt|;
name|hex_print_with_offset
argument_list|(
name|ndo
argument_list|,
literal|"\n\t\t"
argument_list|,
name|pptr
argument_list|,
name|rlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\n\t\t]"
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|redirect_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|uint16_t
name|op_msk
name|_U_
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
specifier|const
name|struct
name|forces_tlv
modifier|*
name|tlv
init|=
operator|(
expr|struct
name|forces_tlv
operator|*
operator|)
name|pptr
decl_stmt|;
name|u_int
name|dlen
decl_stmt|;
name|u_int
name|rlen
decl_stmt|;
name|u_int
name|invtlv
decl_stmt|;
comment|/* 	 * forces_type_print() has ensured that len (the TLV length) 	 *>= TLV_HDRL. 	 */
name|dlen
operator|=
name|len
operator|-
name|TLV_HDRL
expr_stmt|;
if|if
condition|(
name|dlen
operator|<=
name|RD_MIN
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\n\t\ttruncated Redirect TLV: %d bytes missing! "
operator|,
name|RD_MIN
operator|-
name|dlen
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|rlen
operator|=
name|dlen
expr_stmt|;
name|indent
operator|+=
literal|1
expr_stmt|;
while|while
condition|(
name|rlen
operator|!=
literal|0
condition|)
block|{
name|ND_TCHECK
argument_list|(
operator|*
name|tlv
argument_list|)
expr_stmt|;
name|invtlv
operator|=
name|tlv_valid
argument_list|(
name|tlv
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|invtlv
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"Bad Redirect data\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * At this point, tlv_valid() has ensured that the TLV 		 * length is large enough but not too large (it doesn't 		 * go past the end of the containing TLV). 		 */
if|if
condition|(
name|EXTRACT_16BITS
argument_list|(
operator|&
name|tlv
operator|->
name|type
argument_list|)
operator|==
name|F_TLV_METD
condition|)
block|{
name|print_metatlv
argument_list|(
name|ndo
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|TLV_DATA
argument_list|(
name|tlv
argument_list|)
argument_list|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|tlv
operator|->
name|length
argument_list|)
argument_list|,
literal|0
argument_list|,
name|indent
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|EXTRACT_16BITS
argument_list|(
operator|&
name|tlv
operator|->
name|type
argument_list|)
operator|==
name|F_TLV_REDD
operator|)
condition|)
block|{
name|print_reddata
argument_list|(
name|ndo
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|TLV_DATA
argument_list|(
name|tlv
argument_list|)
argument_list|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|tlv
operator|->
name|length
argument_list|)
argument_list|,
literal|0
argument_list|,
name|indent
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"Unknown REDIRECT TLV 0x%x len %d\n"
operator|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|tlv
operator|->
name|type
argument_list|)
operator|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|tlv
operator|->
name|length
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|tlv
operator|=
name|GO_NXT_TLV
argument_list|(
name|tlv
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rlen
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\n\t\tMessy Redirect TLV header, type (0x%x)\n\t\texcess of %d Bytes "
operator|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|tlv
operator|->
name|type
argument_list|)
operator|,
name|rlen
operator|-
name|EXTRACT_16BITS
argument_list|(
operator|&
name|tlv
operator|->
name|length
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
name|trunc
label|:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s"
operator|,
name|tstr
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|OP_OFF
value|8
end_define

begin_define
define|#
directive|define
name|OP_MIN
value|12
end_define

begin_function
specifier|static
name|int
name|lfbselect_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|,
name|uint16_t
name|op_msk
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
specifier|const
name|struct
name|forces_lfbsh
modifier|*
name|lfbs
decl_stmt|;
specifier|const
name|struct
name|forces_tlv
modifier|*
name|otlv
decl_stmt|;
name|char
modifier|*
name|ib
init|=
name|indent_pr
argument_list|(
name|indent
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|u_int
name|dlen
decl_stmt|;
name|u_int
name|rlen
decl_stmt|;
name|u_int
name|invtlv
decl_stmt|;
comment|/* 	 * forces_type_print() has ensured that len (the TLV length) 	 *>= TLV_HDRL. 	 */
name|dlen
operator|=
name|len
operator|-
name|TLV_HDRL
expr_stmt|;
if|if
condition|(
name|dlen
operator|<=
name|OP_MIN
condition|)
block|{
comment|/* id, instance, oper tlv header .. */
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\n\t\ttruncated lfb selector: %d bytes missing! "
operator|,
name|OP_MIN
operator|-
name|dlen
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 	 * At this point, we know that dlen> OP_MIN; OP_OFF< OP_MIN, so 	 * we also know that it's> OP_OFF. 	 */
name|rlen
operator|=
name|dlen
operator|-
name|OP_OFF
expr_stmt|;
name|lfbs
operator|=
operator|(
specifier|const
expr|struct
name|forces_lfbsh
operator|*
operator|)
name|pptr
expr_stmt|;
name|ND_TCHECK
argument_list|(
operator|*
name|lfbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
operator|>=
literal|3
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\n%s%s(Classid %x) instance %x\n"
operator|,
name|ib
operator|,
name|tok2str
argument_list|(
name|ForCES_LFBs
argument_list|,
name|NULL
argument_list|,
name|EXTRACT_32BITS
argument_list|(
operator|&
name|lfbs
operator|->
name|class
argument_list|)
argument_list|)
operator|,
name|EXTRACT_32BITS
argument_list|(
operator|&
name|lfbs
operator|->
name|class
argument_list|)
operator|,
name|EXTRACT_32BITS
argument_list|(
operator|&
name|lfbs
operator|->
name|instance
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|otlv
operator|=
operator|(
expr|struct
name|forces_tlv
operator|*
operator|)
operator|(
name|lfbs
operator|+
literal|1
operator|)
expr_stmt|;
name|indent
operator|+=
literal|1
expr_stmt|;
while|while
condition|(
name|rlen
operator|!=
literal|0
condition|)
block|{
name|ND_TCHECK
argument_list|(
operator|*
name|otlv
argument_list|)
expr_stmt|;
name|invtlv
operator|=
name|tlv_valid
argument_list|(
name|otlv
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|invtlv
condition|)
break|break;
comment|/* 		 * At this point, tlv_valid() has ensured that the TLV 		 * length is large enough but not too large (it doesn't 		 * go past the end of the containing TLV). 		 */
if|if
condition|(
name|op_valid
argument_list|(
name|EXTRACT_16BITS
argument_list|(
operator|&
name|otlv
operator|->
name|type
argument_list|)
argument_list|,
name|op_msk
argument_list|)
condition|)
block|{
name|otlv_print
argument_list|(
name|ndo
argument_list|,
name|otlv
argument_list|,
literal|0
argument_list|,
name|indent
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
operator|<
literal|3
condition|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\t\tINValid oper-TLV type 0x%x length %d for this ForCES message\n"
operator|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|otlv
operator|->
name|type
argument_list|)
operator|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|otlv
operator|->
name|length
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|invoptlv_print
argument_list|(
name|ndo
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|otlv
argument_list|,
name|rlen
argument_list|,
literal|0
argument_list|,
name|indent
argument_list|)
expr_stmt|;
block|}
name|otlv
operator|=
name|GO_NXT_TLV
argument_list|(
name|otlv
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rlen
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\n\t\tMessy oper TLV header, type (0x%x)\n\t\texcess of %d Bytes "
operator|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|otlv
operator|->
name|type
argument_list|)
operator|,
name|rlen
operator|-
name|EXTRACT_16BITS
argument_list|(
operator|&
name|otlv
operator|->
name|length
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
name|trunc
label|:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s"
operator|,
name|tstr
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|forces_type_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|const
name|struct
name|forcesh
modifier|*
name|fhdr
name|_U_
parameter_list|,
specifier|register
name|u_int
name|mlen
parameter_list|,
specifier|const
name|struct
name|tom_h
modifier|*
name|tops
parameter_list|)
block|{
specifier|const
name|struct
name|forces_tlv
modifier|*
name|tltlv
decl_stmt|;
name|u_int
name|rlen
decl_stmt|;
name|u_int
name|invtlv
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|int
name|ttlv
init|=
literal|0
decl_stmt|;
comment|/* 	 * forces_print() has already checked that mlen>= ForCES_HDRL 	 * by calling ForCES_HLN_VALID(). 	 */
name|rlen
operator|=
name|mlen
operator|-
name|ForCES_HDRL
expr_stmt|;
if|if
condition|(
name|rlen
operator|>
name|TLV_HLN
condition|)
block|{
if|if
condition|(
name|tops
operator|->
name|flags
operator|&
name|ZERO_TTLV
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"<0x%x>Illegal Top level TLV!\n"
operator|,
name|tops
operator|->
name|flags
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|tops
operator|->
name|flags
operator|&
name|ZERO_MORE_TTLV
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|tops
operator|->
name|flags
operator|&
name|ONE_MORE_TTLV
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\tTop level TLV Data missing!\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
if|if
condition|(
name|tops
operator|->
name|flags
operator|&
name|ZERO_TTLV
condition|)
block|{
return|return
literal|0
return|;
block|}
name|ttlv
operator|=
name|tops
operator|->
name|flags
operator|>>
literal|4
expr_stmt|;
name|tltlv
operator|=
name|GET_TOP_TLV
argument_list|(
name|pptr
argument_list|)
expr_stmt|;
comment|/*XXX: 15 top level tlvs will probably be fine 	   You are nuts if you send more ;-> */
while|while
condition|(
name|rlen
operator|!=
literal|0
condition|)
block|{
name|ND_TCHECK
argument_list|(
operator|*
name|tltlv
argument_list|)
expr_stmt|;
name|invtlv
operator|=
name|tlv_valid
argument_list|(
name|tltlv
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|invtlv
condition|)
break|break;
comment|/* 		 * At this point, tlv_valid() has ensured that the TLV 		 * length is large enough but not too large (it doesn't 		 * go past the end of the packet). 		 */
if|if
condition|(
operator|!
name|ttlv_valid
argument_list|(
name|EXTRACT_16BITS
argument_list|(
operator|&
name|tltlv
operator|->
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\n\tInvalid ForCES Top TLV type=0x%x"
operator|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|tltlv
operator|->
name|type
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
operator|>=
literal|3
condition|)
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\t%s, length %d (data length %d Bytes)"
operator|,
name|tok2str
argument_list|(
name|ForCES_TLV
argument_list|,
name|NULL
argument_list|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|tltlv
operator|->
name|type
argument_list|)
argument_list|)
operator|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|tltlv
operator|->
name|length
argument_list|)
operator|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|tltlv
operator|->
name|length
argument_list|)
operator|-
name|TLV_HDRL
operator|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|tops
operator|->
name|print
argument_list|(
name|ndo
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|TLV_DATA
argument_list|(
name|tltlv
argument_list|)
argument_list|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|tltlv
operator|->
name|length
argument_list|)
argument_list|,
name|tops
operator|->
name|op_msk
argument_list|,
literal|9
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|tltlv
operator|=
name|GO_NXT_TLV
argument_list|(
name|tltlv
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
name|ttlv
operator|--
expr_stmt|;
if|if
condition|(
name|ttlv
operator|<=
literal|0
condition|)
break|break;
block|}
comment|/* 	 * XXX - if ttlv != 0, does that mean that the packet was too 	 * short, and didn't have *enough* TLVs in it? 	 */
if|if
condition|(
name|rlen
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\tMess TopTLV header: min %u, total %d advertised %d "
operator|,
name|TLV_HDRL
operator|,
name|rlen
operator|,
name|EXTRACT_16BITS
argument_list|(
operator|&
name|tltlv
operator|->
name|length
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
name|trunc
label|:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s"
operator|,
name|tstr
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|void
name|forces_print
parameter_list|(
name|netdissect_options
modifier|*
name|ndo
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|pptr
parameter_list|,
specifier|register
name|u_int
name|len
parameter_list|)
block|{
specifier|const
name|struct
name|forcesh
modifier|*
name|fhdr
decl_stmt|;
name|u_int
name|mlen
decl_stmt|;
name|uint32_t
name|flg_raw
decl_stmt|;
specifier|const
name|struct
name|tom_h
modifier|*
name|tops
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|fhdr
operator|=
operator|(
specifier|const
expr|struct
name|forcesh
operator|*
operator|)
name|pptr
expr_stmt|;
name|ND_TCHECK
argument_list|(
operator|*
name|fhdr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tom_valid
argument_list|(
name|fhdr
operator|->
name|fm_tom
argument_list|)
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"Invalid ForCES message type %d\n"
operator|,
name|fhdr
operator|->
name|fm_tom
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|mlen
operator|=
name|ForCES_BLN
argument_list|(
name|fhdr
argument_list|)
expr_stmt|;
name|tops
operator|=
name|get_forces_tom
argument_list|(
name|fhdr
operator|->
name|fm_tom
argument_list|)
expr_stmt|;
if|if
condition|(
name|tops
operator|->
name|v
operator|==
name|TOM_RSVD
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\n\tUnknown ForCES message type=0x%x"
operator|,
name|fhdr
operator|->
name|fm_tom
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\n\tForCES %s "
operator|,
name|tops
operator|->
name|s
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ForCES_HLN_VALID
argument_list|(
name|mlen
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"Illegal ForCES pkt len - min %u, total recvd %d, advertised %d "
operator|,
name|ForCES_HDRL
operator|,
name|len
operator|,
name|ForCES_BLN
argument_list|(
name|fhdr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|ND_TCHECK2
argument_list|(
operator|*
operator|(
name|pptr
operator|+
literal|20
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|flg_raw
operator|=
name|EXTRACT_32BITS
argument_list|(
name|pptr
operator|+
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
operator|>=
literal|1
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\n\tForCES Version %d len %uB flags 0x%08x "
operator|,
name|ForCES_V
argument_list|(
name|fhdr
argument_list|)
operator|,
name|mlen
operator|,
name|flg_raw
operator|)
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\n\tSrcID 0x%x(%s) DstID 0x%x(%s) Correlator 0x%"
name|PRIx64
operator|,
name|ForCES_SID
argument_list|(
name|fhdr
argument_list|)
operator|,
name|ForCES_node
argument_list|(
name|ForCES_SID
argument_list|(
name|fhdr
argument_list|)
argument_list|)
operator|,
name|ForCES_DID
argument_list|(
name|fhdr
argument_list|)
operator|,
name|ForCES_node
argument_list|(
name|ForCES_DID
argument_list|(
name|fhdr
argument_list|)
argument_list|)
operator|,
name|EXTRACT_64BITS
argument_list|(
name|fhdr
operator|->
name|fm_cor
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
operator|>=
literal|2
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\n\tForCES flags:\n\t  %s(0x%x), prio=%d, %s(0x%x),\n\t  %s(0x%x), %s(0x%x)\n"
operator|,
name|tok2str
argument_list|(
name|ForCES_ACKs
argument_list|,
literal|"ACKUnknown"
argument_list|,
name|ForCES_ACK
argument_list|(
name|fhdr
argument_list|)
argument_list|)
operator|,
name|ForCES_ACK
argument_list|(
name|fhdr
argument_list|)
operator|,
name|ForCES_PRI
argument_list|(
name|fhdr
argument_list|)
operator|,
name|tok2str
argument_list|(
name|ForCES_EMs
argument_list|,
literal|"EMUnknown"
argument_list|,
name|ForCES_EM
argument_list|(
name|fhdr
argument_list|)
argument_list|)
operator|,
name|ForCES_EM
argument_list|(
name|fhdr
argument_list|)
operator|,
name|tok2str
argument_list|(
name|ForCES_ATs
argument_list|,
literal|"ATUnknown"
argument_list|,
name|ForCES_AT
argument_list|(
name|fhdr
argument_list|)
argument_list|)
operator|,
name|ForCES_AT
argument_list|(
name|fhdr
argument_list|)
operator|,
name|tok2str
argument_list|(
name|ForCES_TPs
argument_list|,
literal|"TPUnknown"
argument_list|,
name|ForCES_TP
argument_list|(
name|fhdr
argument_list|)
argument_list|)
operator|,
name|ForCES_TP
argument_list|(
name|fhdr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\t  Extra flags: rsv(b5-7) 0x%x rsv(b13-31) 0x%x\n"
operator|,
name|ForCES_RS1
argument_list|(
name|fhdr
argument_list|)
operator|,
name|ForCES_RS2
argument_list|(
name|fhdr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|forces_type_print
argument_list|(
name|ndo
argument_list|,
name|pptr
argument_list|,
name|fhdr
argument_list|,
name|mlen
argument_list|,
name|tops
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
name|error
label|:
name|hex_print_with_offset
argument_list|(
name|ndo
argument_list|,
literal|"\n\t["
argument_list|,
name|pptr
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\n\t]"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ndo
operator|->
name|ndo_vflag
operator|>=
literal|4
condition|)
block|{
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\n\t  Raw ForCES message\n\t ["
operator|)
argument_list|)
expr_stmt|;
name|hex_print_with_offset
argument_list|(
name|ndo
argument_list|,
literal|"\n\t "
argument_list|,
name|pptr
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\n\t ]"
operator|)
argument_list|)
expr_stmt|;
block|}
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
return|return;
name|trunc
label|:
name|ND_PRINT
argument_list|(
operator|(
name|ndo
operator|,
literal|"%s"
operator|,
name|tstr
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Local Variables:  * c-style: whitesmith  * c-basic-offset: 8  * End:  */
end_comment

end_unit

