begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the project nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * "#ifdef FAITH" part is local hack for supporting IPv4-v6 translator.  *  * Issues to be discussed:  * - Thread safe-ness must be checked.  * - Return values.  There are nonstandard return values defined and used  *   in the source code.  This is because RFC2553 is silent about which error  *   code must be returned for which situation.  * Note:  * - We use getipnodebyname() just for thread-safeness.  There's no intent  *   to let it do PF_UNSPEC (actually we never pass PF_UNSPEC to  *   getipnodebyname().  * - The code filters out AFs that are not supported by the kernel,  *   when globbing NULL hostname (to loopback, or wildcard).  Is it the right  *   thing to do?  What is the relationship with post-RFC2553 AI_ADDRCONFIG  *   in ai_flags?  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"@(#) $Header: /tcpdump/master/tcpdump/missing/getaddrinfo.c,v 1.6.2.2 2000/01/25 18:39:03 itojun Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_if
if|#
directive|if
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_PORTABLE_PROTOTYPE
end_ifndef

begin_include
include|#
directive|include
file|"cdecl_ext.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_U_INT32_T
end_ifndef

begin_include
include|#
directive|include
file|"bittypes.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_SOCKADDR_STORAGE
end_ifndef

begin_include
include|#
directive|include
file|"sockstorage.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_ADDRINFO_H
end_ifdef

begin_include
include|#
directive|include
file|"addrinfo.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__KAME__
argument_list|)
operator|&&
name|defined
argument_list|(
name|INET6
argument_list|)
end_if

begin_define
define|#
directive|define
name|FAITH
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SUCCESS
value|0
end_define

begin_define
define|#
directive|define
name|ANY
value|0
end_define

begin_define
define|#
directive|define
name|YES
value|1
end_define

begin_define
define|#
directive|define
name|NO
value|0
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|FAITH
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|translate
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|in6_addr
name|faith_prefix
init|=
name|IN6ADDR_ANY_INIT
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
name|in_addrany
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|in6_addrany
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|in_loopback
index|[]
init|=
block|{
literal|127
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|in6_loopback
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|sockinet
block|{
name|u_char
name|si_len
decl_stmt|;
name|u_char
name|si_family
decl_stmt|;
name|u_short
name|si_port
decl_stmt|;
name|u_int32_t
name|si_scope_id
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
specifier|static
specifier|const
struct|struct
name|afd
block|{
name|int
name|a_af
decl_stmt|;
name|int
name|a_addrlen
decl_stmt|;
name|int
name|a_socklen
decl_stmt|;
name|int
name|a_off
decl_stmt|;
specifier|const
name|char
modifier|*
name|a_addrany
decl_stmt|;
specifier|const
name|char
modifier|*
name|a_loopback
decl_stmt|;
name|int
name|a_scoped
decl_stmt|;
block|}
name|afdl
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|INET6
block|{
name|PF_INET6
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|,
name|sin6_addr
argument_list|)
block|,
name|in6_addrany
block|,
name|in6_loopback
block|,
literal|1
block|}
block|,
endif|#
directive|endif
block|{
name|PF_INET
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|,
name|sin_addr
argument_list|)
block|,
name|in_addrany
block|,
name|in_loopback
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|, }
struct|;
end_struct

begin_struct
struct|struct
name|explore
block|{
name|int
name|e_af
decl_stmt|;
name|int
name|e_socktype
decl_stmt|;
name|int
name|e_protocol
decl_stmt|;
specifier|const
name|char
modifier|*
name|e_protostr
decl_stmt|;
name|int
name|e_wild
decl_stmt|;
define|#
directive|define
name|WILD_AF
parameter_list|(
name|ex
parameter_list|)
value|((ex)->e_wild& 0x01)
define|#
directive|define
name|WILD_SOCKTYPE
parameter_list|(
name|ex
parameter_list|)
value|((ex)->e_wild& 0x02)
define|#
directive|define
name|WILD_PROTOCOL
parameter_list|(
name|ex
parameter_list|)
value|((ex)->e_wild& 0x04)
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|explore
name|explore
index|[]
init|=
block|{
if|#
directive|if
literal|0
block|{ PF_LOCAL, 0, ANY, ANY, NULL, 0x01 },
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
block|{
name|PF_INET6
block|,
name|SOCK_DGRAM
block|,
name|IPPROTO_UDP
block|,
literal|"udp"
block|,
literal|0x07
block|}
block|,
block|{
name|PF_INET6
block|,
name|SOCK_STREAM
block|,
name|IPPROTO_TCP
block|,
literal|"tcp"
block|,
literal|0x07
block|}
block|,
block|{
name|PF_INET6
block|,
name|SOCK_RAW
block|,
name|ANY
block|,
name|NULL
block|,
literal|0x05
block|}
block|,
endif|#
directive|endif
block|{
name|PF_INET
block|,
name|SOCK_DGRAM
block|,
name|IPPROTO_UDP
block|,
literal|"udp"
block|,
literal|0x07
block|}
block|,
block|{
name|PF_INET
block|,
name|SOCK_STREAM
block|,
name|IPPROTO_TCP
block|,
literal|"tcp"
block|,
literal|0x07
block|}
block|,
block|{
name|PF_INET
block|,
name|SOCK_RAW
block|,
name|ANY
block|,
name|NULL
block|,
literal|0x05
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_define
define|#
directive|define
name|PTON_MAX
value|16
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PTON_MAX
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|str_isnumber
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|explore_fqdn
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|addrinfo
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
expr|struct
name|addrinfo
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|explore_null
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|addrinfo
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
expr|struct
name|addrinfo
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|explore_numeric
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|addrinfo
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
expr|struct
name|addrinfo
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|explore_numeric_scope
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|addrinfo
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
expr|struct
name|addrinfo
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_name
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
expr|struct
name|afd
operator|*
operator|,
expr|struct
name|addrinfo
operator|*
operator|*
operator|,
name|char
operator|*
operator|,
specifier|const
expr|struct
name|addrinfo
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_canonname
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|addrinfo
operator|*
operator|,
expr|struct
name|addrinfo
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|addrinfo
modifier|*
name|get_ai
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|addrinfo
operator|*
operator|,
specifier|const
expr|struct
name|afd
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_portmatch
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|addrinfo
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_port
name|__P
argument_list|(
operator|(
expr|struct
name|addrinfo
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|afd
modifier|*
name|find_afd
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ai_errlist
index|[]
init|=
block|{
literal|"Success"
block|,
literal|"Address family for hostname not supported"
block|,
comment|/* EAI_ADDRFAMILY */
literal|"Temporary failure in name resolution"
block|,
comment|/* EAI_AGAIN      */
literal|"Invalid value for ai_flags"
block|,
comment|/* EAI_BADFLAGS   */
literal|"Non-recoverable failure in name resolution"
block|,
comment|/* EAI_FAIL       */
literal|"ai_family not supported"
block|,
comment|/* EAI_FAMILY     */
literal|"Memory allocation failure"
block|,
comment|/* EAI_MEMORY     */
literal|"No address associated with hostname"
block|,
comment|/* EAI_NODATA     */
literal|"hostname nor servname provided, or not known"
block|,
comment|/* EAI_NONAME     */
literal|"servname not supported for ai_socktype"
block|,
comment|/* EAI_SERVICE    */
literal|"ai_socktype not supported"
block|,
comment|/* EAI_SOCKTYPE   */
literal|"System error returned in errno"
block|,
comment|/* EAI_SYSTEM     */
literal|"Invalid value for hints"
block|,
comment|/* EAI_BADHINTS	  */
literal|"Resolved protocol is unknown"
block|,
comment|/* EAI_PROTOCOL   */
literal|"Unknown error"
block|,
comment|/* EAI_MAX        */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX macros that make external reference is BAD. */
end_comment

begin_define
define|#
directive|define
name|GET_AI
parameter_list|(
name|ai
parameter_list|,
name|afd
parameter_list|,
name|addr
parameter_list|)
define|\
value|do { \
comment|/* external reference: pai, error, and label free */
value|\ 	(ai) = get_ai(pai, (afd), (addr)); \ 	if ((ai) == NULL) { \ 		error = EAI_MEMORY; \ 		goto free; \ 	} \ } while (0)
end_define

begin_define
define|#
directive|define
name|GET_PORT
parameter_list|(
name|ai
parameter_list|,
name|serv
parameter_list|)
define|\
value|do { \
comment|/* external reference: error and label free */
value|\ 	error = get_port((ai), (serv), 0); \ 	if (error != 0) \ 		goto free; \ } while (0)
end_define

begin_define
define|#
directive|define
name|GET_CANONNAME
parameter_list|(
name|ai
parameter_list|,
name|str
parameter_list|)
define|\
value|do { \
comment|/* external reference: pai, error and label free */
value|\ 	error = get_canonname(pai, (ai), (str)); \ 	if (error != 0) \ 		goto free; \ } while (0)
end_define

begin_define
define|#
directive|define
name|ERR
parameter_list|(
name|err
parameter_list|)
define|\
value|do { \
comment|/* external reference: error, and label bad */
value|\ 	error = (err); \ 	goto bad; \ } while (0)
end_define

begin_define
define|#
directive|define
name|MATCH_FAMILY
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|w
parameter_list|)
define|\
value|((x) == (y) || ((w)&& ((x) == PF_UNSPEC || (y) == PF_UNSPEC)))
end_define

begin_define
define|#
directive|define
name|MATCH
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|w
parameter_list|)
define|\
value|((x) == (y) || ((w)&& ((x) == ANY || (y) == ANY)))
end_define

begin_function
name|char
modifier|*
name|gai_strerror
parameter_list|(
name|ecode
parameter_list|)
name|int
name|ecode
decl_stmt|;
block|{
if|if
condition|(
name|ecode
operator|<
literal|0
operator|||
name|ecode
operator|>
name|EAI_MAX
condition|)
name|ecode
operator|=
name|EAI_MAX
expr_stmt|;
return|return
name|ai_errlist
index|[
name|ecode
index|]
return|;
block|}
end_function

begin_function
name|void
name|freeaddrinfo
parameter_list|(
name|ai
parameter_list|)
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|;
block|{
name|struct
name|addrinfo
modifier|*
name|next
decl_stmt|;
do|do
block|{
name|next
operator|=
name|ai
operator|->
name|ai_next
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|ai_canonname
condition|)
name|free
argument_list|(
name|ai
operator|->
name|ai_canonname
argument_list|)
expr_stmt|;
comment|/* no need to free(ai->ai_addr) */
name|free
argument_list|(
name|ai
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|ai
operator|=
name|next
operator|)
operator|!=
name|NULL
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|int
name|str_isnumber
parameter_list|(
name|p
parameter_list|)
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|char
modifier|*
name|q
init|=
operator|(
name|char
operator|*
operator|)
name|p
decl_stmt|;
while|while
condition|(
operator|*
name|q
condition|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|q
argument_list|)
condition|)
return|return
name|NO
return|;
name|q
operator|++
expr_stmt|;
block|}
return|return
name|YES
return|;
block|}
end_function

begin_function
name|int
name|getaddrinfo
parameter_list|(
name|hostname
parameter_list|,
name|servname
parameter_list|,
name|hints
parameter_list|,
name|res
parameter_list|)
specifier|const
name|char
modifier|*
name|hostname
decl_stmt|,
decl|*
name|servname
decl_stmt|;
end_function

begin_decl_stmt
specifier|const
name|struct
name|addrinfo
modifier|*
name|hints
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|addrinfo
modifier|*
modifier|*
name|res
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|addrinfo
name|sentinel
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|cur
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|addrinfo
name|ai
decl_stmt|;
name|struct
name|addrinfo
name|ai0
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|pai
decl_stmt|;
specifier|const
name|struct
name|afd
modifier|*
name|afd
decl_stmt|;
specifier|const
name|struct
name|explore
modifier|*
name|ex
decl_stmt|;
ifdef|#
directive|ifdef
name|FAITH
specifier|static
name|int
name|firsttime
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|firsttime
condition|)
block|{
comment|/* translator hack */
name|char
modifier|*
name|q
init|=
name|getenv
argument_list|(
literal|"GAI"
argument_list|)
decl_stmt|;
if|if
condition|(
name|q
operator|&&
name|inet_pton
argument_list|(
name|AF_INET6
argument_list|,
name|q
argument_list|,
operator|&
name|faith_prefix
argument_list|)
operator|==
literal|1
condition|)
name|translate
operator|=
name|YES
expr_stmt|;
name|firsttime
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|sentinel
operator|.
name|ai_next
operator|=
name|NULL
expr_stmt|;
name|cur
operator|=
operator|&
name|sentinel
expr_stmt|;
name|pai
operator|=
operator|&
name|ai
expr_stmt|;
name|pai
operator|->
name|ai_flags
operator|=
literal|0
expr_stmt|;
name|pai
operator|->
name|ai_family
operator|=
name|PF_UNSPEC
expr_stmt|;
name|pai
operator|->
name|ai_socktype
operator|=
name|ANY
expr_stmt|;
name|pai
operator|->
name|ai_protocol
operator|=
name|ANY
expr_stmt|;
name|pai
operator|->
name|ai_addrlen
operator|=
literal|0
expr_stmt|;
name|pai
operator|->
name|ai_canonname
operator|=
name|NULL
expr_stmt|;
name|pai
operator|->
name|ai_addr
operator|=
name|NULL
expr_stmt|;
name|pai
operator|->
name|ai_next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|hostname
operator|==
name|NULL
operator|&&
name|servname
operator|==
name|NULL
condition|)
return|return
name|EAI_NONAME
return|;
if|if
condition|(
name|hints
condition|)
block|{
comment|/* error check for hints */
if|if
condition|(
name|hints
operator|->
name|ai_addrlen
operator|||
name|hints
operator|->
name|ai_canonname
operator|||
name|hints
operator|->
name|ai_addr
operator|||
name|hints
operator|->
name|ai_next
condition|)
name|ERR
argument_list|(
name|EAI_BADHINTS
argument_list|)
expr_stmt|;
comment|/* xxx */
if|if
condition|(
name|hints
operator|->
name|ai_flags
operator|&
operator|~
name|AI_MASK
condition|)
name|ERR
argument_list|(
name|EAI_BADFLAGS
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hints
operator|->
name|ai_family
condition|)
block|{
case|case
name|PF_UNSPEC
case|:
case|case
name|PF_INET
case|:
ifdef|#
directive|ifdef
name|INET6
case|case
name|PF_INET6
case|:
endif|#
directive|endif
break|break;
default|default:
name|ERR
argument_list|(
name|EAI_FAMILY
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|pai
argument_list|,
name|hints
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pai
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * if both socktype/protocol are specified, check if they 		 * are meaningful combination. 		 */
if|if
condition|(
name|pai
operator|->
name|ai_socktype
operator|!=
name|ANY
operator|&&
name|pai
operator|->
name|ai_protocol
operator|!=
name|ANY
condition|)
block|{
for|for
control|(
name|ex
operator|=
name|explore
init|;
name|ex
operator|->
name|e_af
operator|>=
literal|0
condition|;
name|ex
operator|++
control|)
block|{
if|if
condition|(
name|pai
operator|->
name|ai_family
operator|!=
name|ex
operator|->
name|e_af
condition|)
continue|continue;
if|if
condition|(
name|ex
operator|->
name|e_socktype
operator|==
name|ANY
condition|)
continue|continue;
if|if
condition|(
name|ex
operator|->
name|e_protocol
operator|==
name|ANY
condition|)
continue|continue;
if|if
condition|(
name|pai
operator|->
name|ai_socktype
operator|==
name|ex
operator|->
name|e_socktype
operator|&&
name|pai
operator|->
name|ai_protocol
operator|!=
name|ex
operator|->
name|e_protocol
condition|)
block|{
name|ERR
argument_list|(
name|EAI_BADHINTS
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 	 * check for special cases.  (1) numeric servname is disallowed if 	 * socktype/protocol are left unspecified. (2) servname is disallowed 	 * for raw and other inet{,6} sockets. 	 */
if|if
condition|(
name|MATCH_FAMILY
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|,
name|PF_INET
argument_list|,
literal|1
argument_list|)
ifdef|#
directive|ifdef
name|PF_INET6
operator|||
name|MATCH_FAMILY
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|,
name|PF_INET6
argument_list|,
literal|1
argument_list|)
endif|#
directive|endif
condition|)
block|{
name|ai0
operator|=
operator|*
name|pai
expr_stmt|;
if|if
condition|(
name|pai
operator|->
name|ai_family
operator|==
name|PF_UNSPEC
condition|)
block|{
ifdef|#
directive|ifdef
name|PF_INET6
name|pai
operator|->
name|ai_family
operator|=
name|PF_INET6
expr_stmt|;
else|#
directive|else
name|pai
operator|->
name|ai_family
operator|=
name|PF_INET
expr_stmt|;
endif|#
directive|endif
block|}
name|error
operator|=
name|get_portmatch
argument_list|(
name|pai
argument_list|,
name|servname
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|ERR
argument_list|(
name|error
argument_list|)
expr_stmt|;
operator|*
name|pai
operator|=
name|ai0
expr_stmt|;
block|}
name|ai0
operator|=
operator|*
name|pai
expr_stmt|;
comment|/* NULL hostname, or numeric hostname */
for|for
control|(
name|ex
operator|=
name|explore
init|;
name|ex
operator|->
name|e_af
operator|>=
literal|0
condition|;
name|ex
operator|++
control|)
block|{
operator|*
name|pai
operator|=
name|ai0
expr_stmt|;
if|if
condition|(
operator|!
name|MATCH_FAMILY
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|,
name|ex
operator|->
name|e_af
argument_list|,
name|WILD_AF
argument_list|(
name|ex
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|pai
operator|->
name|ai_socktype
argument_list|,
name|ex
operator|->
name|e_socktype
argument_list|,
name|WILD_SOCKTYPE
argument_list|(
name|ex
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|pai
operator|->
name|ai_protocol
argument_list|,
name|ex
operator|->
name|e_protocol
argument_list|,
name|WILD_PROTOCOL
argument_list|(
name|ex
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|pai
operator|->
name|ai_family
operator|==
name|PF_UNSPEC
condition|)
name|pai
operator|->
name|ai_family
operator|=
name|ex
operator|->
name|e_af
expr_stmt|;
if|if
condition|(
name|pai
operator|->
name|ai_socktype
operator|==
name|ANY
operator|&&
name|ex
operator|->
name|e_socktype
operator|!=
name|ANY
condition|)
name|pai
operator|->
name|ai_socktype
operator|=
name|ex
operator|->
name|e_socktype
expr_stmt|;
if|if
condition|(
name|pai
operator|->
name|ai_protocol
operator|==
name|ANY
operator|&&
name|ex
operator|->
name|e_protocol
operator|!=
name|ANY
condition|)
name|pai
operator|->
name|ai_protocol
operator|=
name|ex
operator|->
name|e_protocol
expr_stmt|;
if|if
condition|(
name|hostname
operator|==
name|NULL
condition|)
name|error
operator|=
name|explore_null
argument_list|(
name|pai
argument_list|,
name|hostname
argument_list|,
name|servname
argument_list|,
operator|&
name|cur
operator|->
name|ai_next
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|explore_numeric_scope
argument_list|(
name|pai
argument_list|,
name|hostname
argument_list|,
name|servname
argument_list|,
operator|&
name|cur
operator|->
name|ai_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|free
goto|;
while|while
condition|(
name|cur
operator|&&
name|cur
operator|->
name|ai_next
condition|)
name|cur
operator|=
name|cur
operator|->
name|ai_next
expr_stmt|;
block|}
comment|/* 	 * XXX 	 * If numreic representation of AF1 can be interpreted as FQDN 	 * representation of AF2, we need to think again about the code below. 	 */
if|if
condition|(
name|sentinel
operator|.
name|ai_next
condition|)
goto|goto
name|good
goto|;
if|if
condition|(
name|pai
operator|->
name|ai_flags
operator|&
name|AI_NUMERICHOST
condition|)
name|ERR
argument_list|(
name|EAI_NONAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostname
operator|==
name|NULL
condition|)
name|ERR
argument_list|(
name|EAI_NONAME
argument_list|)
expr_stmt|;
comment|/* 	 * hostname as alphabetical name. 	 * we would like to prefer AF_INET6 than AF_INET, so we'll make a 	 * outer loop by AFs. 	 */
for|for
control|(
name|afd
operator|=
name|afdl
init|;
name|afd
operator|->
name|a_af
condition|;
name|afd
operator|++
control|)
block|{
operator|*
name|pai
operator|=
name|ai0
expr_stmt|;
if|if
condition|(
operator|!
name|MATCH_FAMILY
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|,
name|afd
operator|->
name|a_af
argument_list|,
literal|1
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|ex
operator|=
name|explore
init|;
name|ex
operator|->
name|e_af
operator|>=
literal|0
condition|;
name|ex
operator|++
control|)
block|{
operator|*
name|pai
operator|=
name|ai0
expr_stmt|;
if|if
condition|(
name|pai
operator|->
name|ai_family
operator|==
name|PF_UNSPEC
condition|)
name|pai
operator|->
name|ai_family
operator|=
name|afd
operator|->
name|a_af
expr_stmt|;
if|if
condition|(
operator|!
name|MATCH_FAMILY
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|,
name|ex
operator|->
name|e_af
argument_list|,
name|WILD_AF
argument_list|(
name|ex
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|pai
operator|->
name|ai_socktype
argument_list|,
name|ex
operator|->
name|e_socktype
argument_list|,
name|WILD_SOCKTYPE
argument_list|(
name|ex
argument_list|)
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|pai
operator|->
name|ai_protocol
argument_list|,
name|ex
operator|->
name|e_protocol
argument_list|,
name|WILD_PROTOCOL
argument_list|(
name|ex
argument_list|)
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|pai
operator|->
name|ai_family
operator|==
name|PF_UNSPEC
condition|)
name|pai
operator|->
name|ai_family
operator|=
name|ex
operator|->
name|e_af
expr_stmt|;
if|if
condition|(
name|pai
operator|->
name|ai_socktype
operator|==
name|ANY
operator|&&
name|ex
operator|->
name|e_socktype
operator|!=
name|ANY
condition|)
name|pai
operator|->
name|ai_socktype
operator|=
name|ex
operator|->
name|e_socktype
expr_stmt|;
if|if
condition|(
name|pai
operator|->
name|ai_protocol
operator|==
name|ANY
operator|&&
name|ex
operator|->
name|e_protocol
operator|!=
name|ANY
condition|)
name|pai
operator|->
name|ai_protocol
operator|=
name|ex
operator|->
name|e_protocol
expr_stmt|;
name|error
operator|=
name|explore_fqdn
argument_list|(
name|pai
argument_list|,
name|hostname
argument_list|,
name|servname
argument_list|,
operator|&
name|cur
operator|->
name|ai_next
argument_list|)
expr_stmt|;
while|while
condition|(
name|cur
operator|&&
name|cur
operator|->
name|ai_next
condition|)
name|cur
operator|=
name|cur
operator|->
name|ai_next
expr_stmt|;
block|}
block|}
comment|/* XXX */
if|if
condition|(
name|sentinel
operator|.
name|ai_next
condition|)
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|free
goto|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sentinel
operator|.
name|ai_next
condition|)
block|{
name|good
label|:
operator|*
name|res
operator|=
name|sentinel
operator|.
name|ai_next
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
else|else
name|error
operator|=
name|EAI_FAIL
expr_stmt|;
block|}
name|free
label|:
name|bad
label|:
if|if
condition|(
name|sentinel
operator|.
name|ai_next
condition|)
name|freeaddrinfo
argument_list|(
name|sentinel
operator|.
name|ai_next
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
name|NULL
expr_stmt|;
return|return
name|error
return|;
block|}
end_block

begin_comment
comment|/*  * FQDN hostname, DNS lookup  */
end_comment

begin_function
specifier|static
name|int
name|explore_fqdn
parameter_list|(
name|pai
parameter_list|,
name|hostname
parameter_list|,
name|servname
parameter_list|,
name|res
parameter_list|)
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
decl_stmt|;
specifier|const
name|char
modifier|*
name|hostname
decl_stmt|;
specifier|const
name|char
modifier|*
name|servname
decl_stmt|;
name|struct
name|addrinfo
modifier|*
modifier|*
name|res
decl_stmt|;
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|int
name|h_error
decl_stmt|;
name|int
name|af
decl_stmt|;
name|char
modifier|*
modifier|*
name|aplist
init|=
name|NULL
decl_stmt|,
modifier|*
name|apbuf
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|ap
decl_stmt|;
name|struct
name|addrinfo
name|sentinel
decl_stmt|,
modifier|*
name|cur
decl_stmt|;
name|int
name|i
decl_stmt|;
ifndef|#
directive|ifndef
name|USE_GETIPNODEBY
name|int
name|naddrs
decl_stmt|;
endif|#
directive|endif
specifier|const
name|struct
name|afd
modifier|*
name|afd
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|*
name|res
operator|=
name|NULL
expr_stmt|;
name|sentinel
operator|.
name|ai_next
operator|=
name|NULL
expr_stmt|;
name|cur
operator|=
operator|&
name|sentinel
expr_stmt|;
comment|/* 	 * Do not filter unsupported AFs here.  We need to honor content of 	 * databases (/etc/hosts, DNS and others).  Otherwise we cannot 	 * replace gethostbyname() by getaddrinfo(). 	 */
comment|/* 	 * if the servname does not match socktype/protocol, ignore it. 	 */
if|if
condition|(
name|get_portmatch
argument_list|(
name|pai
argument_list|,
name|servname
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|afd
operator|=
name|find_afd
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|)
expr_stmt|;
comment|/* 	 * post-RFC2553: should look at (pai->ai_flags& AI_ADDRCONFIG) 	 * rather than hardcoding it.  we may need to add AI_ADDRCONFIG 	 * handling code by ourselves in case we don't have getipnodebyname(). 	 */
ifdef|#
directive|ifdef
name|USE_GETIPNODEBY
name|hp
operator|=
name|getipnodebyname
argument_list|(
name|hostname
argument_list|,
name|pai
operator|->
name|ai_family
argument_list|,
name|AI_ADDRCONFIG
argument_list|,
operator|&
name|h_error
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|HAVE_GETHOSTBYNAME2
name|hp
operator|=
name|gethostbyname2
argument_list|(
name|hostname
argument_list|,
name|pai
operator|->
name|ai_family
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|pai
operator|->
name|ai_family
operator|!=
name|AF_INET
condition|)
return|return
literal|0
return|;
name|hp
operator|=
name|gethostbyname
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_H_ERRNO
name|h_error
operator|=
name|h_errno
expr_stmt|;
else|#
directive|else
name|h_error
operator|=
name|EINVAL
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/*HAVE_GETHOSTBYNAME2*/
endif|#
directive|endif
comment|/*USE_GETIPNODEBY*/
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
switch|switch
condition|(
name|h_error
condition|)
block|{
case|case
name|HOST_NOT_FOUND
case|:
case|case
name|NO_DATA
case|:
name|error
operator|=
name|EAI_NODATA
expr_stmt|;
break|break;
case|case
name|TRY_AGAIN
case|:
name|error
operator|=
name|EAI_AGAIN
expr_stmt|;
break|break;
case|case
name|NO_RECOVERY
case|:
case|case
name|NETDB_INTERNAL
case|:
default|default:
name|error
operator|=
name|EAI_FAIL
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|hp
operator|->
name|h_name
operator|==
name|NULL
operator|)
operator|||
operator|(
name|hp
operator|->
name|h_name
index|[
literal|0
index|]
operator|==
literal|0
operator|)
operator|||
operator|(
name|hp
operator|->
name|h_addr_list
index|[
literal|0
index|]
operator|==
name|NULL
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_GETIPNODEBY
name|freehostent
argument_list|(
name|hp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|EAI_FAIL
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
goto|goto
name|free
goto|;
ifdef|#
directive|ifdef
name|USE_GETIPNODEBY
name|aplist
operator|=
name|hp
operator|->
name|h_addr_list
expr_stmt|;
else|#
directive|else
comment|/* 	 * hp will be overwritten if we use gethostbyname2(). 	 * always deep copy for simplification. 	 */
for|for
control|(
name|naddrs
operator|=
literal|0
init|;
name|hp
operator|->
name|h_addr_list
index|[
name|naddrs
index|]
operator|!=
name|NULL
condition|;
name|naddrs
operator|++
control|)
empty_stmt|;
name|naddrs
operator|++
expr_stmt|;
name|aplist
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|aplist
index|[
literal|0
index|]
argument_list|)
operator|*
name|naddrs
argument_list|)
expr_stmt|;
name|apbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|hp
operator|->
name|h_length
operator|*
name|naddrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|aplist
operator|==
name|NULL
operator|||
name|apbuf
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EAI_MEMORY
expr_stmt|;
goto|goto
name|free
goto|;
block|}
name|memset
argument_list|(
name|aplist
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|aplist
index|[
literal|0
index|]
argument_list|)
operator|*
name|naddrs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|naddrs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|aplist
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
name|memcpy
argument_list|(
operator|&
name|apbuf
index|[
name|i
operator|*
name|hp
operator|->
name|h_length
index|]
argument_list|,
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
argument_list|,
name|hp
operator|->
name|h_length
argument_list|)
expr_stmt|;
name|aplist
index|[
name|i
index|]
operator|=
operator|&
name|apbuf
index|[
name|i
operator|*
name|hp
operator|->
name|h_length
index|]
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|aplist
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|af
operator|=
name|hp
operator|->
name|h_addrtype
expr_stmt|;
name|ap
operator|=
name|aplist
index|[
name|i
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|AF_INET6
if|if
condition|(
name|af
operator|==
name|AF_INET6
operator|&&
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|(
expr|struct
name|in6_addr
operator|*
operator|)
name|ap
argument_list|)
condition|)
block|{
name|af
operator|=
name|AF_INET
expr_stmt|;
name|ap
operator|=
name|ap
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|af
operator|!=
name|pai
operator|->
name|ai_family
condition|)
continue|continue;
if|if
condition|(
operator|(
name|pai
operator|->
name|ai_flags
operator|&
name|AI_CANONNAME
operator|)
operator|==
literal|0
condition|)
block|{
name|GET_AI
argument_list|(
name|cur
operator|->
name|ai_next
argument_list|,
name|afd
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|GET_PORT
argument_list|(
name|cur
operator|->
name|ai_next
argument_list|,
name|servname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * if AI_CANONNAME and if reverse lookup 			 * fail, return ai anyway to pacify 			 * calling application. 			 * 			 * XXX getaddrinfo() is a name->address 			 * translation function, and it looks 			 * strange that we do addr->name 			 * translation here. 			 */
name|get_name
argument_list|(
name|ap
argument_list|,
name|afd
argument_list|,
operator|&
name|cur
operator|->
name|ai_next
argument_list|,
name|ap
argument_list|,
name|pai
argument_list|,
name|servname
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|cur
operator|&&
name|cur
operator|->
name|ai_next
condition|)
name|cur
operator|=
name|cur
operator|->
name|ai_next
expr_stmt|;
block|}
operator|*
name|res
operator|=
name|sentinel
operator|.
name|ai_next
expr_stmt|;
return|return
literal|0
return|;
name|free
label|:
ifdef|#
directive|ifdef
name|USE_GETIPNODEBY
if|if
condition|(
name|hp
condition|)
name|freehostent
argument_list|(
name|hp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|aplist
condition|)
name|free
argument_list|(
name|aplist
argument_list|)
expr_stmt|;
if|if
condition|(
name|apbuf
condition|)
name|free
argument_list|(
name|apbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sentinel
operator|.
name|ai_next
condition|)
name|freeaddrinfo
argument_list|(
name|sentinel
operator|.
name|ai_next
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * hostname == NULL.  * passive socket -> anyaddr (0.0.0.0 or ::)  * non-passive socket -> localhost (127.0.0.1 or ::1)  */
end_comment

begin_function
specifier|static
name|int
name|explore_null
parameter_list|(
name|pai
parameter_list|,
name|hostname
parameter_list|,
name|servname
parameter_list|,
name|res
parameter_list|)
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
decl_stmt|;
specifier|const
name|char
modifier|*
name|hostname
decl_stmt|;
specifier|const
name|char
modifier|*
name|servname
decl_stmt|;
name|struct
name|addrinfo
modifier|*
modifier|*
name|res
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
specifier|const
name|struct
name|afd
modifier|*
name|afd
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|cur
decl_stmt|;
name|struct
name|addrinfo
name|sentinel
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|*
name|res
operator|=
name|NULL
expr_stmt|;
name|sentinel
operator|.
name|ai_next
operator|=
name|NULL
expr_stmt|;
name|cur
operator|=
operator|&
name|sentinel
expr_stmt|;
comment|/* 	 * filter out AFs that are not supported by the kernel 	 * XXX errno? 	 */
name|s
operator|=
name|socket
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EMFILE
condition|)
return|return
literal|0
return|;
block|}
else|else
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * if the servname does not match socktype/protocol, ignore it. 	 */
if|if
condition|(
name|get_portmatch
argument_list|(
name|pai
argument_list|,
name|servname
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|afd
operator|=
name|find_afd
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|)
expr_stmt|;
if|if
condition|(
name|pai
operator|->
name|ai_flags
operator|&
name|AI_PASSIVE
condition|)
block|{
name|GET_AI
argument_list|(
name|cur
operator|->
name|ai_next
argument_list|,
name|afd
argument_list|,
name|afd
operator|->
name|a_addrany
argument_list|)
expr_stmt|;
comment|/* xxx meaningless? 		 * GET_CANONNAME(cur->ai_next, "anyaddr"); 		 */
name|GET_PORT
argument_list|(
name|cur
operator|->
name|ai_next
argument_list|,
name|servname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|GET_AI
argument_list|(
name|cur
operator|->
name|ai_next
argument_list|,
name|afd
argument_list|,
name|afd
operator|->
name|a_loopback
argument_list|)
expr_stmt|;
comment|/* xxx meaningless? 		 * GET_CANONNAME(cur->ai_next, "localhost"); 		 */
name|GET_PORT
argument_list|(
name|cur
operator|->
name|ai_next
argument_list|,
name|servname
argument_list|)
expr_stmt|;
block|}
name|cur
operator|=
name|cur
operator|->
name|ai_next
expr_stmt|;
operator|*
name|res
operator|=
name|sentinel
operator|.
name|ai_next
expr_stmt|;
return|return
literal|0
return|;
name|free
label|:
if|if
condition|(
name|sentinel
operator|.
name|ai_next
condition|)
name|freeaddrinfo
argument_list|(
name|sentinel
operator|.
name|ai_next
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * numeric hostname  */
end_comment

begin_function
specifier|static
name|int
name|explore_numeric
parameter_list|(
name|pai
parameter_list|,
name|hostname
parameter_list|,
name|servname
parameter_list|,
name|res
parameter_list|)
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
decl_stmt|;
specifier|const
name|char
modifier|*
name|hostname
decl_stmt|;
specifier|const
name|char
modifier|*
name|servname
decl_stmt|;
name|struct
name|addrinfo
modifier|*
modifier|*
name|res
decl_stmt|;
block|{
specifier|const
name|struct
name|afd
modifier|*
name|afd
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|cur
decl_stmt|;
name|struct
name|addrinfo
name|sentinel
decl_stmt|;
name|int
name|error
decl_stmt|;
name|char
name|pton
index|[
name|PTON_MAX
index|]
decl_stmt|;
name|int
name|flags
decl_stmt|;
operator|*
name|res
operator|=
name|NULL
expr_stmt|;
name|sentinel
operator|.
name|ai_next
operator|=
name|NULL
expr_stmt|;
name|cur
operator|=
operator|&
name|sentinel
expr_stmt|;
comment|/* 	 * if the servname does not match socktype/protocol, ignore it. 	 */
if|if
condition|(
name|get_portmatch
argument_list|(
name|pai
argument_list|,
name|servname
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|afd
operator|=
name|find_afd
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|)
expr_stmt|;
name|flags
operator|=
name|pai
operator|->
name|ai_flags
expr_stmt|;
if|if
condition|(
name|inet_pton
argument_list|(
name|afd
operator|->
name|a_af
argument_list|,
name|hostname
argument_list|,
name|pton
argument_list|)
operator|==
literal|1
condition|)
block|{
name|u_int32_t
name|v4a
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|u_char
name|pfx
decl_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|afd
operator|->
name|a_af
condition|)
block|{
case|case
name|AF_INET
case|:
name|v4a
operator|=
operator|(
name|u_int32_t
operator|)
name|ntohl
argument_list|(
operator|(
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|pton
operator|)
operator|->
name|s_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|v4a
argument_list|)
operator|||
name|IN_EXPERIMENTAL
argument_list|(
name|v4a
argument_list|)
condition|)
name|flags
operator|&=
operator|~
name|AI_CANONNAME
expr_stmt|;
name|v4a
operator|>>=
name|IN_CLASSA_NSHIFT
expr_stmt|;
if|if
condition|(
name|v4a
operator|==
literal|0
operator|||
name|v4a
operator|==
name|IN_LOOPBACKNET
condition|)
name|flags
operator|&=
operator|~
name|AI_CANONNAME
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|pfx
operator|=
operator|(
operator|(
expr|struct
name|in6_addr
operator|*
operator|)
name|pton
operator|)
operator|->
name|s6_addr
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|pfx
operator|==
literal|0
operator|||
name|pfx
operator|==
literal|0xfe
operator|||
name|pfx
operator|==
literal|0xff
condition|)
name|flags
operator|&=
operator|~
name|AI_CANONNAME
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
if|if
condition|(
name|pai
operator|->
name|ai_family
operator|==
name|afd
operator|->
name|a_af
operator|||
name|pai
operator|->
name|ai_family
operator|==
name|PF_UNSPEC
comment|/*?*/
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|AI_CANONNAME
operator|)
operator|==
literal|0
condition|)
block|{
name|GET_AI
argument_list|(
name|cur
operator|->
name|ai_next
argument_list|,
name|afd
argument_list|,
name|pton
argument_list|)
expr_stmt|;
name|GET_PORT
argument_list|(
name|cur
operator|->
name|ai_next
argument_list|,
name|servname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * if AI_CANONNAME and if reverse lookup 				 * fail, return ai anyway to pacify 				 * calling application. 				 * 				 * XXX getaddrinfo() is a name->address 				 * translation function, and it looks 				 * strange that we do addr->name 				 * translation here. 				 */
name|get_name
argument_list|(
name|pton
argument_list|,
name|afd
argument_list|,
operator|&
name|cur
operator|->
name|ai_next
argument_list|,
name|pton
argument_list|,
name|pai
argument_list|,
name|servname
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|cur
operator|&&
name|cur
operator|->
name|ai_next
condition|)
name|cur
operator|=
name|cur
operator|->
name|ai_next
expr_stmt|;
block|}
else|else
name|ERR
argument_list|(
name|EAI_FAMILY
argument_list|)
expr_stmt|;
comment|/*xxx*/
block|}
operator|*
name|res
operator|=
name|sentinel
operator|.
name|ai_next
expr_stmt|;
return|return
literal|0
return|;
name|free
label|:
name|bad
label|:
if|if
condition|(
name|sentinel
operator|.
name|ai_next
condition|)
name|freeaddrinfo
argument_list|(
name|sentinel
operator|.
name|ai_next
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * numeric hostname with scope  */
end_comment

begin_function
specifier|static
name|int
name|explore_numeric_scope
parameter_list|(
name|pai
parameter_list|,
name|hostname
parameter_list|,
name|servname
parameter_list|,
name|res
parameter_list|)
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
decl_stmt|;
specifier|const
name|char
modifier|*
name|hostname
decl_stmt|;
specifier|const
name|char
modifier|*
name|servname
decl_stmt|;
name|struct
name|addrinfo
modifier|*
modifier|*
name|res
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|SCOPE_DELIMITER
return|return
name|explore_numeric
argument_list|(
name|pai
argument_list|,
name|hostname
argument_list|,
name|servname
argument_list|,
name|res
argument_list|)
return|;
else|#
directive|else
specifier|const
name|struct
name|afd
modifier|*
name|afd
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|cur
decl_stmt|;
name|int
name|error
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|hostname2
init|=
name|NULL
decl_stmt|;
name|int
name|scope
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
comment|/* 	 * if the servname does not match socktype/protocol, ignore it. 	 */
if|if
condition|(
name|get_portmatch
argument_list|(
name|pai
argument_list|,
name|servname
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|afd
operator|=
name|find_afd
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|afd
operator|->
name|a_scoped
condition|)
return|return
name|explore_numeric
argument_list|(
name|pai
argument_list|,
name|hostname
argument_list|,
name|servname
argument_list|,
name|res
argument_list|)
return|;
name|cp
operator|=
name|strchr
argument_list|(
name|hostname
argument_list|,
name|SCOPE_DELIMITER
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
name|explore_numeric
argument_list|(
name|pai
argument_list|,
name|hostname
argument_list|,
name|servname
argument_list|,
name|res
argument_list|)
return|;
comment|/* 	 * Handle special case of<scoped_address><delimiter><scope id> 	 */
name|hostname2
operator|=
name|strdup
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostname2
operator|==
name|NULL
condition|)
return|return
name|EAI_MEMORY
return|;
comment|/* terminate at the delimiter */
name|hostname2
index|[
name|cp
operator|-
name|hostname
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|++
expr_stmt|;
switch|switch
condition|(
name|pai
operator|->
name|ai_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|scope
operator|=
name|if_nametoindex
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|scope
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|hostname2
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAI_NONAME
operator|)
return|;
block|}
break|break;
endif|#
directive|endif
block|}
name|error
operator|=
name|explore_numeric
argument_list|(
name|pai
argument_list|,
name|hostname2
argument_list|,
name|servname
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|cur
operator|=
operator|*
name|res
init|;
name|cur
condition|;
name|cur
operator|=
name|cur
operator|->
name|ai_next
control|)
block|{
if|if
condition|(
name|cur
operator|->
name|ai_family
operator|!=
name|AF_INET6
condition|)
continue|continue;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|cur
operator|->
name|ai_addr
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
operator|||
name|IN6_IS_ADDR_MC_LINKLOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
name|sin6
operator|->
name|sin6_scope_id
operator|=
name|scope
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|hostname2
argument_list|)
expr_stmt|;
return|return
name|error
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|get_name
parameter_list|(
name|addr
parameter_list|,
name|afd
parameter_list|,
name|res
parameter_list|,
name|numaddr
parameter_list|,
name|pai
parameter_list|,
name|servname
parameter_list|)
specifier|const
name|char
modifier|*
name|addr
decl_stmt|;
specifier|const
name|struct
name|afd
modifier|*
name|afd
decl_stmt|;
name|struct
name|addrinfo
modifier|*
modifier|*
name|res
decl_stmt|;
name|char
modifier|*
name|numaddr
decl_stmt|;
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
decl_stmt|;
specifier|const
name|char
modifier|*
name|servname
decl_stmt|;
block|{
name|struct
name|hostent
modifier|*
name|hp
init|=
name|NULL
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|cur
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|ap
init|=
name|NULL
decl_stmt|,
modifier|*
name|cn
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_GETIPNODEBY
name|int
name|h_error
decl_stmt|;
name|hp
operator|=
name|getipnodebyaddr
argument_list|(
name|addr
argument_list|,
name|afd
operator|->
name|a_addrlen
argument_list|,
name|afd
operator|->
name|a_af
argument_list|,
operator|&
name|h_error
argument_list|)
expr_stmt|;
else|#
directive|else
name|hp
operator|=
name|gethostbyaddr
argument_list|(
name|addr
argument_list|,
name|afd
operator|->
name|a_addrlen
argument_list|,
name|afd
operator|->
name|a_af
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|hp
operator|&&
name|hp
operator|->
name|h_name
operator|&&
name|hp
operator|->
name|h_name
index|[
literal|0
index|]
operator|&&
name|hp
operator|->
name|h_addr_list
index|[
literal|0
index|]
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_GETIPNODEBY
name|GET_AI
argument_list|(
name|cur
argument_list|,
name|afd
argument_list|,
name|hp
operator|->
name|h_addr_list
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|GET_PORT
argument_list|(
name|cur
argument_list|,
name|servname
argument_list|)
expr_stmt|;
name|GET_CANONNAME
argument_list|(
name|cur
argument_list|,
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* hp will be damaged if we use gethostbyaddr() */
if|if
condition|(
operator|(
name|ap
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|hp
operator|->
name|h_length
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EAI_MEMORY
expr_stmt|;
goto|goto
name|free
goto|;
block|}
name|memcpy
argument_list|(
name|ap
argument_list|,
name|hp
operator|->
name|h_addr_list
index|[
literal|0
index|]
argument_list|,
name|hp
operator|->
name|h_length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cn
operator|=
name|strdup
argument_list|(
name|hp
operator|->
name|h_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EAI_MEMORY
expr_stmt|;
goto|goto
name|free
goto|;
block|}
name|GET_AI
argument_list|(
name|cur
argument_list|,
name|afd
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|GET_PORT
argument_list|(
name|cur
argument_list|,
name|servname
argument_list|)
expr_stmt|;
name|GET_CANONNAME
argument_list|(
name|cur
argument_list|,
name|cn
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|ap
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|cn
argument_list|)
expr_stmt|;
name|cn
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|GET_AI
argument_list|(
name|cur
argument_list|,
name|afd
argument_list|,
name|numaddr
argument_list|)
expr_stmt|;
name|GET_PORT
argument_list|(
name|cur
argument_list|,
name|servname
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USE_GETIPNODEBY
if|if
condition|(
name|hp
condition|)
name|freehostent
argument_list|(
name|hp
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|res
operator|=
name|cur
expr_stmt|;
return|return
name|SUCCESS
return|;
name|free
label|:
if|if
condition|(
name|cur
condition|)
name|freeaddrinfo
argument_list|(
name|cur
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
condition|)
name|free
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|cn
condition|)
name|free
argument_list|(
name|cn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_GETIPNODEBY
if|if
condition|(
name|hp
condition|)
name|freehostent
argument_list|(
name|hp
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|res
operator|=
name|NULL
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_canonname
parameter_list|(
name|pai
parameter_list|,
name|ai
parameter_list|,
name|str
parameter_list|)
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|pai
operator|->
name|ai_flags
operator|&
name|AI_CANONNAME
operator|)
operator|!=
literal|0
condition|)
block|{
name|ai
operator|->
name|ai_canonname
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|ai_canonname
operator|==
name|NULL
condition|)
return|return
name|EAI_MEMORY
return|;
name|strcpy
argument_list|(
name|ai
operator|->
name|ai_canonname
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|addrinfo
modifier|*
name|get_ai
parameter_list|(
name|pai
parameter_list|,
name|afd
parameter_list|,
name|addr
parameter_list|)
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
decl_stmt|;
specifier|const
name|struct
name|afd
modifier|*
name|afd
decl_stmt|;
specifier|const
name|char
modifier|*
name|addr
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|;
name|ai
operator|=
operator|(
expr|struct
name|addrinfo
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|addrinfo
argument_list|)
operator|+
operator|(
name|afd
operator|->
name|a_socklen
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memcpy
argument_list|(
name|ai
argument_list|,
name|pai
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|addrinfo
argument_list|)
argument_list|)
expr_stmt|;
name|ai
operator|->
name|ai_addr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|ai
operator|+
literal|1
operator|)
expr_stmt|;
name|memset
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|,
literal|0
argument_list|,
name|afd
operator|->
name|a_socklen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SOCKADDR_SA_LEN
name|ai
operator|->
name|ai_addr
operator|->
name|sa_len
operator|=
name|afd
operator|->
name|a_socklen
expr_stmt|;
endif|#
directive|endif
name|ai
operator|->
name|ai_addrlen
operator|=
name|afd
operator|->
name|a_socklen
expr_stmt|;
name|ai
operator|->
name|ai_addr
operator|->
name|sa_family
operator|=
name|ai
operator|->
name|ai_family
operator|=
name|afd
operator|->
name|a_af
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|ai
operator|->
name|ai_addr
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|+
name|afd
operator|->
name|a_off
argument_list|,
name|addr
argument_list|,
name|afd
operator|->
name|a_addrlen
argument_list|)
expr_stmt|;
return|return
name|ai
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_portmatch
parameter_list|(
name|ai
parameter_list|,
name|servname
parameter_list|)
specifier|const
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|;
specifier|const
name|char
modifier|*
name|servname
decl_stmt|;
block|{
comment|/* get_port does not touch first argument. when matchonly == 1. */
return|return
name|get_port
argument_list|(
operator|(
expr|struct
name|addrinfo
operator|*
operator|)
name|ai
argument_list|,
name|servname
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_port
parameter_list|(
name|ai
parameter_list|,
name|servname
parameter_list|,
name|matchonly
parameter_list|)
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|;
specifier|const
name|char
modifier|*
name|servname
decl_stmt|;
name|int
name|matchonly
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|proto
decl_stmt|;
name|struct
name|servent
modifier|*
name|sp
decl_stmt|;
name|int
name|port
decl_stmt|;
name|int
name|allownumeric
decl_stmt|;
if|if
condition|(
name|servname
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|ai
operator|->
name|ai_family
condition|)
block|{
case|case
name|AF_INET
case|:
ifdef|#
directive|ifdef
name|AF_INET6
case|case
name|AF_INET6
case|:
endif|#
directive|endif
break|break;
default|default:
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|ai
operator|->
name|ai_socktype
condition|)
block|{
case|case
name|SOCK_RAW
case|:
return|return
name|EAI_SERVICE
return|;
case|case
name|SOCK_DGRAM
case|:
case|case
name|SOCK_STREAM
case|:
name|allownumeric
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ANY
case|:
name|allownumeric
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
return|return
name|EAI_SOCKTYPE
return|;
block|}
if|if
condition|(
name|str_isnumber
argument_list|(
name|servname
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|allownumeric
condition|)
return|return
name|EAI_SERVICE
return|;
name|port
operator|=
name|htons
argument_list|(
name|atoi
argument_list|(
name|servname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|<
literal|0
operator|||
name|port
operator|>
literal|65535
condition|)
return|return
name|EAI_SERVICE
return|;
block|}
else|else
block|{
switch|switch
condition|(
name|ai
operator|->
name|ai_socktype
condition|)
block|{
case|case
name|SOCK_DGRAM
case|:
name|proto
operator|=
literal|"udp"
expr_stmt|;
break|break;
case|case
name|SOCK_STREAM
case|:
name|proto
operator|=
literal|"tcp"
expr_stmt|;
break|break;
default|default:
name|proto
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|sp
operator|=
name|getservbyname
argument_list|(
name|servname
argument_list|,
name|proto
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|EAI_SERVICE
return|;
name|port
operator|=
name|sp
operator|->
name|s_port
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|matchonly
condition|)
block|{
switch|switch
condition|(
name|ai
operator|->
name|ai_family
condition|)
block|{
case|case
name|AF_INET
case|:
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|ai
operator|->
name|ai_addr
operator|)
operator|->
name|sin_port
operator|=
name|port
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|ai
operator|->
name|ai_addr
operator|)
operator|->
name|sin6_port
operator|=
name|port
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|struct
name|afd
modifier|*
name|find_afd
parameter_list|(
name|af
parameter_list|)
name|int
name|af
decl_stmt|;
block|{
specifier|const
name|struct
name|afd
modifier|*
name|afd
decl_stmt|;
if|if
condition|(
name|af
operator|==
name|PF_UNSPEC
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|afd
operator|=
name|afdl
init|;
name|afd
operator|->
name|a_af
condition|;
name|afd
operator|++
control|)
block|{
if|if
condition|(
name|afd
operator|->
name|a_af
operator|==
name|af
condition|)
return|return
name|afd
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

end_unit

