begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, 1993, 1994, 1995, 1996  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that: (1) source code distributions  * retain the above copyright notice and this paragraph in its entirety, (2)  * distributions including binary code include the above copyright notice and  * this paragraph in its entirety in the documentation or other materials  * provided with the distribution, and (3) all advertising materials mentioning  * features or use of this software display the following acknowledgement:  * ``This product includes software developed by the University of California,  * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of  * the University nor the names of its contributors may be used to endorse  * or promote products derived from this software without specific prior  * written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_comment
comment|/*  * Original code by Matt Thomas, Digital Equipment Corporation  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"@(#) $Header: print-isoclns.c,v 1.12 96/07/14 19:39:00 leres Exp $ (LBL)"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_struct_decl
struct_decl|struct
name|mbuf
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|rtentry
struct_decl|;
end_struct_decl

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"interface.h"
end_include

begin_include
include|#
directive|include
file|"addrtoname.h"
end_include

begin_include
include|#
directive|include
file|"ethertype.h"
end_include

begin_include
include|#
directive|include
file|"extract.h"
end_include

begin_define
define|#
directive|define
name|NLPID_CLNS
value|129
end_define

begin_comment
comment|/* 0x81 */
end_comment

begin_define
define|#
directive|define
name|NLPID_ESIS
value|130
end_define

begin_comment
comment|/* 0x82 */
end_comment

begin_define
define|#
directive|define
name|NLPID_ISIS
value|131
end_define

begin_comment
comment|/* 0x83 */
end_comment

begin_define
define|#
directive|define
name|NLPID_NULLNS
value|0
end_define

begin_comment
comment|/*  * IS-IS is defined in ISO 10589.  Look there for protocol definitions.  */
end_comment

begin_define
define|#
directive|define
name|SYSTEM_ID_LEN
value|sizeof(struct ether_addr)
end_define

begin_define
define|#
directive|define
name|ISIS_VERSION
value|1
end_define

begin_define
define|#
directive|define
name|PDU_TYPE_MASK
value|0x1F
end_define

begin_define
define|#
directive|define
name|PRIORITY_MASK
value|0x7F
end_define

begin_define
define|#
directive|define
name|L1_LAN_IIH
value|15
end_define

begin_define
define|#
directive|define
name|L2_LAN_IIH
value|16
end_define

begin_define
define|#
directive|define
name|PTP_IIH
value|17
end_define

begin_define
define|#
directive|define
name|L1_LS_PDU
value|18
end_define

begin_define
define|#
directive|define
name|L2_LS_PDU
value|19
end_define

begin_define
define|#
directive|define
name|L1_COMPLETE_SEQ_PDU
value|24
end_define

begin_define
define|#
directive|define
name|L2_COMPLETE_SEQ_PDU
value|25
end_define

begin_comment
comment|/*  * A TLV is a tuple of a type, length and a value and is normally used for  * encoding information in all sorts of places.  This is an enumeration of  * the well known types.  */
end_comment

begin_define
define|#
directive|define
name|TLV_AREA_ADDR
value|1
end_define

begin_define
define|#
directive|define
name|TLV_IS_REACH
value|2
end_define

begin_define
define|#
directive|define
name|TLV_ES_REACH
value|3
end_define

begin_define
define|#
directive|define
name|TLV_SUMMARY
value|5
end_define

begin_define
define|#
directive|define
name|TLV_ISNEIGH
value|6
end_define

begin_define
define|#
directive|define
name|TLV_PADDING
value|8
end_define

begin_define
define|#
directive|define
name|TLV_LSP
value|9
end_define

begin_define
define|#
directive|define
name|TLV_AUTHENT
value|10
end_define

begin_define
define|#
directive|define
name|TLV_IP_REACH
value|128
end_define

begin_define
define|#
directive|define
name|TLV_PROTOCOLS
value|129
end_define

begin_define
define|#
directive|define
name|TLV_IP_EXTERN
value|130
end_define

begin_define
define|#
directive|define
name|TLV_IDRP_INFO
value|131
end_define

begin_define
define|#
directive|define
name|TLV_IPADDR
value|132
end_define

begin_define
define|#
directive|define
name|TLV_IPAUTH
value|133
end_define

begin_define
define|#
directive|define
name|TLV_PTP_ADJ
value|240
end_define

begin_comment
comment|/*  * Katz's point to point adjacency TLV uses codes to tell us the state of  * the remote adjacency.  Enumerate them.  */
end_comment

begin_define
define|#
directive|define
name|ISIS_PTP_ADJ_UP
value|0
end_define

begin_define
define|#
directive|define
name|ISIS_PTP_ADJ_INIT
value|1
end_define

begin_define
define|#
directive|define
name|ISIS_PTP_ADJ_DOWN
value|2
end_define

begin_function_decl
specifier|static
name|int
name|osi_cksum
parameter_list|(
specifier|const
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|esis_print
parameter_list|(
specifier|const
name|u_char
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isis_print
parameter_list|(
specifier|const
name|u_char
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|isis_ptp_adjancey_values
block|{
name|u_char
name|id
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|isis_ptp_adjancey_values
name|isis_ptp_adjancey_values
index|[]
init|=
block|{
name|ISIS_PTP_ADJ_UP
block|,
literal|"UP"
block|,
name|ISIS_PTP_ADJ_INIT
block|,
literal|"INIT"
block|,
name|ISIS_PTP_ADJ_DOWN
block|,
literal|"DOWN"
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|isis_common_header
block|{
name|u_char
name|nlpid
decl_stmt|;
name|u_char
name|fixed_len
decl_stmt|;
name|u_char
name|version
decl_stmt|;
comment|/* Protocol version? */
name|u_char
name|id_length
decl_stmt|;
name|u_char
name|enc_pdu_type
decl_stmt|;
comment|/* 3 MSbs are reserved */
name|u_char
name|pkt_version
decl_stmt|;
comment|/* Packet format version? */
name|u_char
name|reserved
decl_stmt|;
name|u_char
name|enc_max_area
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|isis_header
block|{
name|u_char
name|nlpid
decl_stmt|;
name|u_char
name|fixed_len
decl_stmt|;
name|u_char
name|version
decl_stmt|;
comment|/* Protocol version? */
name|u_char
name|id_length
decl_stmt|;
name|u_char
name|enc_pdu_type
decl_stmt|;
comment|/* 3 MSbs are reserved */
name|u_char
name|pkt_version
decl_stmt|;
comment|/* Packet format version? */
name|u_char
name|reserved
decl_stmt|;
name|u_char
name|enc_max_area
decl_stmt|;
name|u_char
name|circuit
decl_stmt|;
name|u_char
name|enc_source_id
index|[
name|SYSTEM_ID_LEN
index|]
decl_stmt|;
name|u_char
name|enc_holding_time
index|[
literal|2
index|]
decl_stmt|;
name|u_char
name|enc_packet_len
index|[
literal|2
index|]
decl_stmt|;
name|u_char
name|enc_priority
decl_stmt|;
name|u_char
name|enc_lan_id
index|[
name|SYSTEM_ID_LEN
operator|+
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|isis_lan_header
block|{
name|u_char
name|circuit
decl_stmt|;
name|u_char
name|enc_source_id
index|[
name|SYSTEM_ID_LEN
index|]
decl_stmt|;
name|u_char
name|enc_holding_time
index|[
literal|2
index|]
decl_stmt|;
name|u_char
name|enc_packet_len
index|[
literal|2
index|]
decl_stmt|;
name|u_char
name|enc_priority
decl_stmt|;
name|u_char
name|enc_lan_id
index|[
name|SYSTEM_ID_LEN
operator|+
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|isis_ptp_header
block|{
name|u_char
name|circuit
decl_stmt|;
name|u_char
name|enc_source_id
index|[
name|SYSTEM_ID_LEN
index|]
decl_stmt|;
name|u_char
name|enc_holding_time
index|[
literal|2
index|]
decl_stmt|;
name|u_char
name|enc_packet_len
index|[
literal|2
index|]
decl_stmt|;
name|u_char
name|loc_circuit_id
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ISIS_COMMON_HEADER_SIZE
value|(sizeof(struct isis_common_header))
end_define

begin_define
define|#
directive|define
name|ISIS_HEADER_SIZE
value|(15+(SYSTEM_ID_LEN<<1))
end_define

begin_define
define|#
directive|define
name|ISIS_PTP_HEADER_SIZE
value|(14+SYSTEM_ID_LEN)
end_define

begin_define
define|#
directive|define
name|L1_LS_PDU_HEADER_SIZE
value|(21+SYSTEM_ID_LEN)
end_define

begin_define
define|#
directive|define
name|L2_LS_PDU_HEADER_SIZE
value|L1_LS_PDU_HEADER_SIZE
end_define

begin_define
define|#
directive|define
name|L1_COMPLETE_SEQ_PDU_HEADER_SIZE
value|33
end_define

begin_define
define|#
directive|define
name|L2_COMPLETE_SEQ_PDU_HEADER_SIZE
value|L1_COMPLETE_SEQ_PDU_HEADER_SIZE
end_define

begin_function
name|void
name|isoclns_print
parameter_list|(
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|u_int
name|length
parameter_list|,
name|u_int
name|caplen
parameter_list|,
specifier|const
name|u_char
modifier|*
name|esrc
parameter_list|,
specifier|const
name|u_char
modifier|*
name|edst
parameter_list|)
block|{
name|u_char
name|pdu_type
decl_stmt|;
name|struct
name|isis_header
modifier|*
name|header
decl_stmt|;
name|header
operator|=
operator|(
expr|struct
name|isis_header
operator|*
operator|)
name|p
expr_stmt|;
name|pdu_type
operator|=
name|header
operator|->
name|enc_pdu_type
operator|&
name|PDU_TYPE_MASK
expr_stmt|;
if|if
condition|(
name|caplen
operator|<
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"[|iso-clns] "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eflag
condition|)
name|printf
argument_list|(
literal|"%s> %s"
argument_list|,
name|etheraddr_string
argument_list|(
name|esrc
argument_list|)
argument_list|,
name|etheraddr_string
argument_list|(
name|edst
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
name|NLPID_CLNS
case|:
name|printf
argument_list|(
literal|"iso clns"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eflag
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" %s> %s"
argument_list|,
name|etheraddr_string
argument_list|(
name|esrc
argument_list|)
argument_list|,
name|etheraddr_string
argument_list|(
name|edst
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NLPID_ESIS
case|:
name|printf
argument_list|(
literal|"iso esis"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eflag
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" %s> %s"
argument_list|,
name|etheraddr_string
argument_list|(
name|esrc
argument_list|)
argument_list|,
name|etheraddr_string
argument_list|(
name|edst
argument_list|)
argument_list|)
expr_stmt|;
name|esis_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
case|case
name|NLPID_ISIS
case|:
name|printf
argument_list|(
literal|"iso isis"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eflag
condition|)
block|{
if|if
condition|(
name|pdu_type
operator|!=
name|PTP_IIH
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" %s> %s"
argument_list|,
name|etheraddr_string
argument_list|(
name|esrc
argument_list|)
argument_list|,
name|etheraddr_string
argument_list|(
name|edst
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" len=%d "
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isis_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
condition|)
name|default_print_unaligned
argument_list|(
name|p
argument_list|,
name|caplen
argument_list|)
expr_stmt|;
break|break;
case|case
name|NLPID_NULLNS
case|:
name|printf
argument_list|(
literal|"iso nullns"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eflag
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" %s> %s"
argument_list|,
name|etheraddr_string
argument_list|(
name|esrc
argument_list|)
argument_list|,
name|etheraddr_string
argument_list|(
name|edst
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"iso clns %02x"
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eflag
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" %s> %s"
argument_list|,
name|etheraddr_string
argument_list|(
name|esrc
argument_list|)
argument_list|,
name|etheraddr_string
argument_list|(
name|edst
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" len=%d "
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|caplen
operator|>
literal|1
condition|)
name|default_print_unaligned
argument_list|(
name|p
argument_list|,
name|caplen
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|ESIS_REDIRECT
value|6
end_define

begin_define
define|#
directive|define
name|ESIS_ESH
value|2
end_define

begin_define
define|#
directive|define
name|ESIS_ISH
value|4
end_define

begin_struct
struct|struct
name|esis_hdr
block|{
name|u_char
name|version
decl_stmt|;
name|u_char
name|reserved
decl_stmt|;
name|u_char
name|type
decl_stmt|;
name|u_char
name|tmo
index|[
literal|2
index|]
decl_stmt|;
name|u_char
name|cksum
index|[
literal|2
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|esis_print
parameter_list|(
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|u_int
name|length
parameter_list|)
block|{
specifier|const
name|u_char
modifier|*
name|ep
decl_stmt|;
name|int
name|li
init|=
name|p
index|[
literal|1
index|]
decl_stmt|;
specifier|const
name|struct
name|esis_hdr
modifier|*
name|eh
init|=
operator|(
specifier|const
expr|struct
name|esis_hdr
operator|*
operator|)
operator|&
name|p
index|[
literal|2
index|]
decl_stmt|;
name|u_char
name|cksum
index|[
literal|2
index|]
decl_stmt|;
name|u_char
name|off
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|length
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|qflag
condition|)
name|printf
argument_list|(
literal|" bad pkt!"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" no header at all!"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ep
operator|=
name|p
operator|+
name|li
expr_stmt|;
if|if
condition|(
name|li
operator|>
name|length
condition|)
block|{
if|if
condition|(
name|qflag
condition|)
name|printf
argument_list|(
literal|" bad pkt!"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" LI(%d)> PDU size (%d)!"
argument_list|,
name|li
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|li
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|esis_hdr
argument_list|)
operator|+
literal|2
condition|)
block|{
if|if
condition|(
name|qflag
condition|)
name|printf
argument_list|(
literal|" bad pkt!"
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|" too short for esis header %d:"
argument_list|,
name|li
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|length
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"%02X"
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
switch|switch
condition|(
name|eh
operator|->
name|type
operator|&
literal|0x1f
condition|)
block|{
case|case
name|ESIS_REDIRECT
case|:
name|printf
argument_list|(
literal|" redirect"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ESIS_ESH
case|:
name|printf
argument_list|(
literal|" esh"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ESIS_ISH
case|:
name|printf
argument_list|(
literal|" ish"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|" type %d"
argument_list|,
name|eh
operator|->
name|type
operator|&
literal|0x1f
argument_list|)
expr_stmt|;
break|break;
block|}
name|off
index|[
literal|0
index|]
operator|=
name|eh
operator|->
name|cksum
index|[
literal|0
index|]
expr_stmt|;
name|off
index|[
literal|1
index|]
operator|=
name|eh
operator|->
name|cksum
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|vflag
operator|&&
name|osi_cksum
argument_list|(
name|p
argument_list|,
name|li
argument_list|,
name|off
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|" bad cksum (got %02x%02x)"
argument_list|,
name|eh
operator|->
name|cksum
index|[
literal|1
index|]
argument_list|,
name|eh
operator|->
name|cksum
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|default_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|eh
operator|->
name|version
operator|!=
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|" unsupported version %d"
argument_list|,
name|eh
operator|->
name|version
argument_list|)
expr_stmt|;
return|return;
block|}
name|p
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
operator|+
literal|2
expr_stmt|;
name|li
operator|-=
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
operator|+
literal|2
expr_stmt|;
comment|/* protoid * li */
switch|switch
condition|(
name|eh
operator|->
name|type
operator|&
literal|0x1f
condition|)
block|{
case|case
name|ESIS_REDIRECT
case|:
block|{
specifier|const
name|u_char
modifier|*
name|dst
decl_stmt|,
modifier|*
name|snpa
decl_stmt|,
modifier|*
name|is
decl_stmt|;
name|dst
operator|=
name|p
expr_stmt|;
name|p
operator|+=
operator|*
name|p
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|>
name|snapend
condition|)
return|return;
name|printf
argument_list|(
literal|"\n\t\t\t %s"
argument_list|,
name|isonsap_string
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
name|snpa
operator|=
name|p
expr_stmt|;
name|p
operator|+=
operator|*
name|p
operator|+
literal|1
expr_stmt|;
name|is
operator|=
name|p
expr_stmt|;
name|p
operator|+=
operator|*
name|p
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|>
name|snapend
condition|)
return|return;
if|if
condition|(
name|p
operator|>
name|ep
condition|)
block|{
name|printf
argument_list|(
literal|" [bad li]"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|is
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"> %s"
argument_list|,
name|etheraddr_string
argument_list|(
operator|&
name|snpa
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"> %s"
argument_list|,
name|isonsap_string
argument_list|(
name|is
argument_list|)
argument_list|)
expr_stmt|;
name|li
operator|=
name|ep
operator|-
name|p
expr_stmt|;
break|break;
block|}
if|#
directive|if
literal|0
block|case ESIS_ESH: 		printf(" esh"); 		break;
endif|#
directive|endif
case|case
name|ESIS_ISH
case|:
block|{
specifier|const
name|u_char
modifier|*
name|is
decl_stmt|;
name|is
operator|=
name|p
expr_stmt|;
name|p
operator|+=
operator|*
name|p
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|>
name|ep
condition|)
block|{
name|printf
argument_list|(
literal|" [bad li]"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p
operator|>
name|snapend
condition|)
return|return;
if|if
condition|(
operator|!
name|qflag
condition|)
name|printf
argument_list|(
literal|"\n\t\t\t %s"
argument_list|,
name|isonsap_string
argument_list|(
name|is
argument_list|)
argument_list|)
expr_stmt|;
name|li
operator|=
name|ep
operator|-
name|p
expr_stmt|;
break|break;
block|}
default|default:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" len=%d"
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|&&
name|p
operator|<
name|snapend
condition|)
block|{
name|length
operator|=
name|snapend
operator|-
name|p
expr_stmt|;
name|default_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|vflag
condition|)
while|while
condition|(
name|p
operator|<
name|ep
operator|&&
name|li
condition|)
block|{
name|int
name|op
decl_stmt|,
name|opli
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|snapend
operator|-
name|p
operator|<
literal|2
condition|)
return|return;
if|if
condition|(
name|li
operator|<
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|" bad opts/li"
argument_list|)
expr_stmt|;
return|return;
block|}
name|op
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|opli
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|li
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|opli
operator|>
name|li
condition|)
block|{
name|printf
argument_list|(
literal|" opt (%d) too long"
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return;
block|}
name|li
operator|-=
name|opli
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
name|p
operator|+=
name|opli
expr_stmt|;
if|if
condition|(
name|snapend
operator|<
name|p
condition|)
return|return;
if|if
condition|(
name|op
operator|==
literal|198
operator|&&
name|opli
operator|==
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|" tmo=%d"
argument_list|,
name|q
index|[
literal|0
index|]
operator|*
literal|256
operator|+
name|q
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|printf
argument_list|(
literal|" %d:<"
argument_list|,
name|op
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|opli
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
operator|*
name|q
operator|++
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|">"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * print_nsap  * Print out an NSAP.   */
end_comment

begin_function
name|void
name|print_nsap
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|cp
parameter_list|,
specifier|register
name|int
name|length
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%02x"
argument_list|,
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|i
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|i
operator|+
literal|1
operator|<
name|length
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * isis_print  * Decode IS-IS packets.  Return 0 on error.  *  * So far, this is only smart enough to print IIH's.  Someday...  */
end_comment

begin_function
specifier|static
name|int
name|isis_print
parameter_list|(
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|u_int
name|length
parameter_list|)
block|{
name|struct
name|isis_header
modifier|*
name|header
decl_stmt|;
name|struct
name|isis_ptp_header
modifier|*
name|header_ptp
decl_stmt|;
name|u_char
name|pdu_type
decl_stmt|,
name|max_area
decl_stmt|,
name|priority
decl_stmt|,
modifier|*
name|pptr
decl_stmt|,
name|type
decl_stmt|,
name|len
decl_stmt|,
modifier|*
name|tptr
decl_stmt|,
name|tmp
decl_stmt|,
name|alen
decl_stmt|;
name|u_short
name|packet_len
decl_stmt|,
name|holding_time
decl_stmt|;
name|int
name|i
decl_stmt|;
name|header_ptp
operator|=
operator|(
expr|struct
name|isis_ptp_header
operator|*
operator|)
name|header
operator|=
operator|(
expr|struct
name|isis_header
operator|*
operator|)
name|p
expr_stmt|;
name|printf
argument_list|(
literal|"\n\t\t\t"
argument_list|)
expr_stmt|;
comment|/*      * Sanity checking of the header.      */
if|if
condition|(
name|header
operator|->
name|nlpid
operator|!=
name|NLPID_ISIS
condition|)
block|{
name|printf
argument_list|(
literal|" coding error!"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|header
operator|->
name|version
operator|!=
name|ISIS_VERSION
condition|)
block|{
name|printf
argument_list|(
literal|" version %d packet not supported"
argument_list|,
name|header
operator|->
name|version
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|header
operator|->
name|id_length
operator|!=
name|SYSTEM_ID_LEN
operator|)
operator|&&
operator|(
name|header
operator|->
name|id_length
operator|!=
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|" system ID length of %d is not supported"
argument_list|,
name|header
operator|->
name|id_length
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|header
operator|->
name|fixed_len
operator|!=
name|ISIS_HEADER_SIZE
operator|)
operator|&&
operator|(
name|header
operator|->
name|fixed_len
operator|!=
name|ISIS_PTP_HEADER_SIZE
operator|)
operator|&&
operator|(
name|header
operator|->
name|fixed_len
operator|!=
name|L1_LS_PDU_HEADER_SIZE
operator|)
operator|&&
operator|(
name|header
operator|->
name|fixed_len
operator|!=
name|L1_COMPLETE_SEQ_PDU_HEADER_SIZE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|" bogus fixed header length"
argument_list|,
name|header
operator|->
name|fixed_len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pdu_type
operator|=
name|header
operator|->
name|enc_pdu_type
operator|&
name|PDU_TYPE_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|pdu_type
operator|!=
name|L1_LAN_IIH
operator|)
operator|&&
operator|(
name|pdu_type
operator|!=
name|L2_LAN_IIH
operator|)
operator|&&
operator|(
name|pdu_type
operator|!=
name|PTP_IIH
operator|)
operator|&&
operator|(
name|pdu_type
operator|!=
name|L1_COMPLETE_SEQ_PDU
operator|)
operator|&&
operator|(
name|pdu_type
operator|!=
name|L2_COMPLETE_SEQ_PDU
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|" PDU type (%d) not supported"
argument_list|,
name|pdu_type
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|header
operator|->
name|pkt_version
operator|!=
name|ISIS_VERSION
condition|)
block|{
name|printf
argument_list|(
literal|" version %d packet not supported"
argument_list|,
name|header
operator|->
name|pkt_version
argument_list|)
expr_stmt|;
return|return;
block|}
name|max_area
operator|=
name|header
operator|->
name|enc_max_area
expr_stmt|;
switch|switch
condition|(
name|max_area
condition|)
block|{
case|case
literal|0
case|:
name|max_area
operator|=
literal|3
expr_stmt|;
comment|/* silly shit */
break|break;
case|case
literal|255
case|:
name|printf
argument_list|(
literal|" bad packet -- 255 areas"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
break|break;
block|}
switch|switch
condition|(
name|header
operator|->
name|circuit
condition|)
block|{
case|case
literal|0
case|:
name|printf
argument_list|(
literal|" PDU with circuit type 0"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|1
case|:
if|if
condition|(
name|pdu_type
operator|==
name|L2_LAN_IIH
condition|)
block|{
name|printf
argument_list|(
literal|" L2 IIH on an L1 only circuit"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|pdu_type
operator|==
name|L1_LAN_IIH
condition|)
block|{
name|printf
argument_list|(
literal|" L1 IIH on an L2 only circuit"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
case|case
literal|3
case|:
break|break;
default|default:
name|printf
argument_list|(
literal|" unknown circuit type"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|holding_time
operator|=
name|EXTRACT_16BITS
argument_list|(
name|header
operator|->
name|enc_holding_time
argument_list|)
expr_stmt|;
name|packet_len
operator|=
name|EXTRACT_16BITS
argument_list|(
name|header
operator|->
name|enc_packet_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|packet_len
operator|<
name|ISIS_HEADER_SIZE
operator|)
operator|||
operator|(
name|packet_len
operator|>
name|length
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|" bogus packet length %d, real length %d"
argument_list|,
name|packet_len
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|pdu_type
operator|!=
name|PTP_IIH
condition|)
name|priority
operator|=
name|header
operator|->
name|enc_priority
operator|&
name|PRIORITY_MASK
expr_stmt|;
comment|/*      * Now print the fixed header.      */
switch|switch
condition|(
name|pdu_type
condition|)
block|{
case|case
name|L1_LAN_IIH
case|:
name|printf
argument_list|(
literal|" L1 lan iih, "
argument_list|)
expr_stmt|;
break|break;
case|case
name|L2_LAN_IIH
case|:
name|printf
argument_list|(
literal|" L2 lan iih, "
argument_list|)
expr_stmt|;
break|break;
case|case
name|PTP_IIH
case|:
name|printf
argument_list|(
literal|" PTP iih, "
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"circuit "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|header
operator|->
name|circuit
condition|)
block|{
case|case
literal|1
case|:
name|printf
argument_list|(
literal|"l1 only, "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|"l2 only, "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|printf
argument_list|(
literal|"l1-l2, "
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"holding time %d "
argument_list|,
name|holding_time
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\t\t\t source %s, length %d"
argument_list|,
name|etheraddr_string
argument_list|(
name|header
operator|->
name|enc_source_id
argument_list|)
argument_list|,
name|packet_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pdu_type
operator|==
name|L1_LAN_IIH
operator|)
operator|||
operator|(
name|pdu_type
operator|==
name|L2_LAN_IIH
operator|)
condition|)
name|printf
argument_list|(
literal|"\n\t\t\t lan id %s(%d)"
argument_list|,
name|etheraddr_string
argument_list|(
name|header
operator|->
name|enc_lan_id
argument_list|)
argument_list|,
name|header
operator|->
name|enc_lan_id
index|[
name|SYSTEM_ID_LEN
index|]
argument_list|)
expr_stmt|;
comment|/*      * Now print the TLV's.      */
if|if
condition|(
name|pdu_type
operator|==
name|PTP_IIH
condition|)
block|{
name|packet_len
operator|-=
name|ISIS_PTP_HEADER_SIZE
expr_stmt|;
name|pptr
operator|=
operator|(
name|char
operator|*
operator|)
name|p
operator|+
name|ISIS_PTP_HEADER_SIZE
expr_stmt|;
block|}
else|else
block|{
name|packet_len
operator|-=
name|ISIS_HEADER_SIZE
expr_stmt|;
name|pptr
operator|=
operator|(
name|char
operator|*
operator|)
name|p
operator|+
name|ISIS_HEADER_SIZE
expr_stmt|;
block|}
while|while
condition|(
name|packet_len
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|pptr
operator|>=
name|snapend
condition|)
block|{
name|printf
argument_list|(
literal|"\n\t\t\t packet exceeded snapshot"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|type
operator|=
operator|*
name|pptr
operator|++
expr_stmt|;
name|len
operator|=
operator|*
name|pptr
operator|++
expr_stmt|;
name|packet_len
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|packet_len
condition|)
block|{
break|break;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TLV_AREA_ADDR
case|:
name|printf
argument_list|(
literal|"\n\t\t\t area addresses"
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|len
expr_stmt|;
name|tptr
operator|=
name|pptr
expr_stmt|;
name|alen
operator|=
operator|*
name|tptr
operator|++
expr_stmt|;
while|while
condition|(
name|tmp
operator|&&
name|alen
operator|<
name|tmp
condition|)
block|{
name|printf
argument_list|(
literal|"\n\t\t\t "
argument_list|)
expr_stmt|;
name|print_nsap
argument_list|(
name|tptr
argument_list|,
name|alen
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" (%d)"
argument_list|,
name|alen
argument_list|)
expr_stmt|;
name|tptr
operator|+=
name|alen
expr_stmt|;
name|tmp
operator|-=
name|alen
operator|+
literal|1
expr_stmt|;
name|alen
operator|=
operator|*
name|tptr
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|TLV_ISNEIGH
case|:
name|printf
argument_list|(
literal|"\n\t\t\t neighbor addresses"
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|len
expr_stmt|;
name|tptr
operator|=
name|pptr
expr_stmt|;
while|while
condition|(
name|tmp
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_addr
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\n\t\t\t %s"
argument_list|,
name|etheraddr_string
argument_list|(
name|tptr
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_addr
argument_list|)
expr_stmt|;
name|tptr
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_addr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TLV_PADDING
case|:
name|printf
argument_list|(
literal|"\n\t\t\t padding for %d bytes"
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLV_AUTHENT
case|:
name|printf
argument_list|(
literal|"\n\t\t\t authentication data"
argument_list|)
expr_stmt|;
name|default_print
argument_list|(
name|pptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLV_PTP_ADJ
case|:
name|printf
argument_list|(
literal|"\n\t\t\t PTP adjacency status %s"
argument_list|,
name|isis_ptp_adjancey_values
index|[
operator|*
name|pptr
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLV_PROTOCOLS
case|:
name|printf
argument_list|(
literal|"\n\t\t\t Supports protocols %s"
argument_list|,
operator|(
name|len
operator|>
literal|1
operator|)
condition|?
literal|"are"
else|:
literal|"is"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %02X"
argument_list|,
operator|(
name|u_char
operator|)
operator|*
operator|(
name|pptr
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLV_IPADDR
case|:
name|printf
argument_list|(
literal|"\n\t\t\t IP address: %s"
argument_list|,
name|ipaddr_string
argument_list|(
name|pptr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"\n\t\t\t unknown TLV, type %d, length %d"
argument_list|,
name|type
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
block|}
name|pptr
operator|+=
name|len
expr_stmt|;
name|packet_len
operator|-=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|packet_len
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\n\t\t\t %d straggler bytes"
argument_list|,
name|packet_len
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Verify the checksum.  See 8473-1, Appendix C, section C.4.  */
end_comment

begin_function
specifier|static
name|int
name|osi_cksum
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
specifier|register
name|int
name|len
parameter_list|,
name|u_char
modifier|*
name|off
parameter_list|)
block|{
name|int32_t
name|c0
init|=
literal|0
decl_stmt|,
name|c1
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|off
index|[
literal|0
index|]
operator|==
literal|0
operator|)
operator|&&
operator|(
name|off
index|[
literal|1
index|]
operator|==
literal|0
operator|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
block|{
name|c0
operator|+=
operator|*
name|p
operator|++
expr_stmt|;
name|c0
operator|%=
literal|255
expr_stmt|;
name|c1
operator|+=
name|c0
expr_stmt|;
name|c1
operator|%=
literal|255
expr_stmt|;
block|}
return|return
operator|(
name|c0
operator||
name|c1
operator|)
return|;
block|}
end_function

end_unit

