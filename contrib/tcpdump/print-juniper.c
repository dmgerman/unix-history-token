begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that: (1) source code  * distributions retain the above copyright notice and this paragraph  * in its entirety, and (2) distributions including binary code include  * the above copyright notice and this paragraph in its entirety in  * the documentation or other materials provided with the distribution.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND  * WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT  * LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS  * FOR A PARTICULAR PURPOSE.  *  * Original code by Hannes Gredler (hannes@juniper.net)  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
name|_U_
init|=
literal|"@(#) $Header: /tcpdump/master/tcpdump/print-juniper.c,v 1.8 2005/04/06 21:32:41 mcr Exp $ (LBL)"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<tcpdump-stdinc.h>
end_include

begin_include
include|#
directive|include
file|<pcap.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"interface.h"
end_include

begin_include
include|#
directive|include
file|"extract.h"
end_include

begin_include
include|#
directive|include
file|"ppp.h"
end_include

begin_include
include|#
directive|include
file|"llc.h"
end_include

begin_include
include|#
directive|include
file|"nlpid.h"
end_include

begin_define
define|#
directive|define
name|JUNIPER_BPF_OUT
value|0
end_define

begin_comment
comment|/* Outgoing packet */
end_comment

begin_define
define|#
directive|define
name|JUNIPER_BPF_IN
value|1
end_define

begin_comment
comment|/* Incoming packet */
end_comment

begin_define
define|#
directive|define
name|JUNIPER_BPF_PKT_IN
value|0x1
end_define

begin_comment
comment|/* Incoming packet */
end_comment

begin_define
define|#
directive|define
name|JUNIPER_BPF_NO_L2
value|0x2
end_define

begin_comment
comment|/* L2 header stripped */
end_comment

begin_define
define|#
directive|define
name|LS_COOKIE_ID
value|0x54
end_define

begin_define
define|#
directive|define
name|LS_MLFR_LEN
value|4
end_define

begin_define
define|#
directive|define
name|ML_MLFR_LEN
value|2
end_define

begin_define
define|#
directive|define
name|ATM2_PKT_TYPE_MASK
value|0x70
end_define

begin_define
define|#
directive|define
name|ATM2_GAP_COUNT_MASK
value|0x3F
end_define

begin_function_decl
name|int
name|ip_heuristic_guess
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|juniper_ppp_heuristic_guess
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|juniper_parse_header
parameter_list|(
specifier|const
name|u_char
modifier|*
parameter_list|,
name|u_int8_t
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|u_int
name|juniper_mlppp_print
parameter_list|(
specifier|const
name|struct
name|pcap_pkthdr
modifier|*
name|h
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|p
parameter_list|)
block|{
specifier|register
name|u_int
name|length
init|=
name|h
operator|->
name|len
decl_stmt|;
specifier|register
name|u_int
name|caplen
init|=
name|h
operator|->
name|caplen
decl_stmt|;
name|u_int8_t
name|direction
decl_stmt|,
name|bundle
decl_stmt|,
name|cookie_len
decl_stmt|;
name|u_int32_t
name|cookie
decl_stmt|,
name|proto
decl_stmt|;
if|if
condition|(
name|juniper_parse_header
argument_list|(
name|p
argument_list|,
operator|&
name|direction
argument_list|,
name|length
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|p
operator|+=
literal|4
expr_stmt|;
name|length
operator|-=
literal|4
expr_stmt|;
name|caplen
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
name|LS_COOKIE_ID
condition|)
block|{
name|cookie
operator|=
name|EXTRACT_32BITS
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|eflag
condition|)
name|printf
argument_list|(
literal|"LSPIC-MLPPP cookie 0x%08x, "
argument_list|,
name|cookie
argument_list|)
expr_stmt|;
name|cookie_len
operator|=
name|LS_MLFR_LEN
expr_stmt|;
name|bundle
operator|=
name|cookie
operator|&
literal|0xff
expr_stmt|;
block|}
else|else
block|{
name|cookie
operator|=
name|EXTRACT_16BITS
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|eflag
condition|)
name|printf
argument_list|(
literal|"MLPIC-MLPPP cookie 0x%04x, "
argument_list|,
name|cookie
argument_list|)
expr_stmt|;
name|cookie_len
operator|=
name|ML_MLFR_LEN
expr_stmt|;
name|bundle
operator|=
operator|(
name|cookie
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
name|proto
operator|=
name|EXTRACT_16BITS
argument_list|(
name|p
operator|+
name|cookie_len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|cookie_len
expr_stmt|;
name|length
operator|-=
name|cookie_len
expr_stmt|;
name|caplen
operator|-=
name|cookie_len
expr_stmt|;
comment|/* suppress Bundle-ID if frame was captured on a child-link          * this may be the case if the cookie looks like a proto */
if|if
condition|(
name|eflag
operator|&&
name|cookie
operator|!=
name|PPP_OSI
operator|&&
name|cookie
operator|!=
operator|(
name|PPP_ADDRESS
operator|<<
literal|8
operator||
name|PPP_CONTROL
operator|)
condition|)
name|printf
argument_list|(
literal|"Bundle-ID %u, "
argument_list|,
name|bundle
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cookie
condition|)
block|{
case|case
name|PPP_OSI
case|:
name|ppp_print
argument_list|(
name|p
operator|-
literal|2
argument_list|,
name|length
operator|+
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|PPP_ADDRESS
operator|<<
literal|8
operator||
name|PPP_CONTROL
operator|)
case|:
comment|/* fall through */
default|default:
name|ppp_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|cookie_len
return|;
block|}
end_function

begin_function
name|u_int
name|juniper_mlfr_print
parameter_list|(
specifier|const
name|struct
name|pcap_pkthdr
modifier|*
name|h
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|p
parameter_list|)
block|{
specifier|register
name|u_int
name|length
init|=
name|h
operator|->
name|len
decl_stmt|;
specifier|register
name|u_int
name|caplen
init|=
name|h
operator|->
name|caplen
decl_stmt|;
name|u_int8_t
name|direction
decl_stmt|,
name|bundle
decl_stmt|,
name|cookie_len
decl_stmt|;
name|u_int32_t
name|cookie
decl_stmt|,
name|proto
decl_stmt|,
name|frelay_len
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|juniper_parse_header
argument_list|(
name|p
argument_list|,
operator|&
name|direction
argument_list|,
name|length
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|p
operator|+=
literal|4
expr_stmt|;
name|length
operator|-=
literal|4
expr_stmt|;
name|caplen
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
name|LS_COOKIE_ID
condition|)
block|{
name|cookie
operator|=
name|EXTRACT_32BITS
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|eflag
condition|)
name|printf
argument_list|(
literal|"LSPIC-MLFR cookie 0x%08x, "
argument_list|,
name|cookie
argument_list|)
expr_stmt|;
name|cookie_len
operator|=
name|LS_MLFR_LEN
expr_stmt|;
name|bundle
operator|=
name|cookie
operator|&
literal|0xff
expr_stmt|;
block|}
else|else
block|{
name|cookie
operator|=
name|EXTRACT_16BITS
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|eflag
condition|)
name|printf
argument_list|(
literal|"MLPIC-MLFR cookie 0x%04x, "
argument_list|,
name|cookie
argument_list|)
expr_stmt|;
name|cookie_len
operator|=
name|ML_MLFR_LEN
expr_stmt|;
name|bundle
operator|=
operator|(
name|cookie
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
name|proto
operator|=
name|EXTRACT_16BITS
argument_list|(
name|p
operator|+
name|cookie_len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|cookie_len
operator|+
literal|2
expr_stmt|;
name|length
operator|-=
name|cookie_len
operator|+
literal|2
expr_stmt|;
name|caplen
operator|-=
name|cookie_len
operator|+
literal|2
expr_stmt|;
comment|/* suppress Bundle-ID if frame was captured on a child-link */
if|if
condition|(
name|eflag
operator|&&
name|cookie
operator|!=
literal|1
condition|)
name|printf
argument_list|(
literal|"Bundle-ID %u, "
argument_list|,
name|bundle
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
operator|(
name|LLC_UI
operator|)
case|:
case|case
operator|(
name|LLC_UI
operator|<<
literal|8
operator|)
case|:
name|isoclns_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|,
name|caplen
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|LLC_UI
operator|<<
literal|8
operator||
name|NLPID_Q933
operator|)
case|:
case|case
operator|(
name|LLC_UI
operator|<<
literal|8
operator||
name|NLPID_IP
operator|)
case|:
case|case
operator|(
name|LLC_UI
operator|<<
literal|8
operator||
name|NLPID_IP6
operator|)
case|:
name|isoclns_print
argument_list|(
name|p
operator|-
literal|1
argument_list|,
name|length
operator|+
literal|1
argument_list|,
name|caplen
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* pass IP{4,6} to the OSI layer for proper link-layer printing */
break|break;
default|default:
name|printf
argument_list|(
literal|"unknown protocol 0x%04x, length %u"
argument_list|,
name|proto
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
return|return
name|cookie_len
operator|+
name|frelay_len
return|;
block|}
end_function

begin_comment
comment|/*  *     ATM1 PIC cookie format  *  *     +-----+-------------------------+-------------------------------+  *     |fmtid|     vc index            |  channel  ID                  |  *     +-----+-------------------------+-------------------------------+  */
end_comment

begin_function
name|u_int
name|juniper_atm1_print
parameter_list|(
specifier|const
name|struct
name|pcap_pkthdr
modifier|*
name|h
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|p
parameter_list|)
block|{
specifier|register
name|u_int
name|length
init|=
name|h
operator|->
name|len
decl_stmt|;
specifier|register
name|u_int
name|caplen
init|=
name|h
operator|->
name|caplen
decl_stmt|;
name|u_int16_t
name|extracted_ethertype
decl_stmt|;
name|u_int8_t
name|direction
decl_stmt|;
name|u_int32_t
name|cookie1
decl_stmt|;
if|if
condition|(
name|juniper_parse_header
argument_list|(
name|p
argument_list|,
operator|&
name|direction
argument_list|,
name|length
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|p
operator|+=
literal|4
expr_stmt|;
name|length
operator|-=
literal|4
expr_stmt|;
name|caplen
operator|-=
literal|4
expr_stmt|;
name|cookie1
operator|=
name|EXTRACT_32BITS
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|eflag
condition|)
block|{
comment|/* FIXME decode channel-id, vc-index, fmt-id                for once lets just hexdump the cookie */
name|printf
argument_list|(
literal|"ATM1 cookie 0x%08x, "
argument_list|,
name|cookie1
argument_list|)
expr_stmt|;
block|}
name|p
operator|+=
literal|4
expr_stmt|;
name|length
operator|-=
literal|4
expr_stmt|;
name|caplen
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
operator|(
name|cookie1
operator|>>
literal|24
operator|)
operator|==
literal|0x80
condition|)
block|{
comment|/* OAM cell ? */
name|oam_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|EXTRACT_24BITS
argument_list|(
name|p
argument_list|)
operator|==
literal|0xfefe03
operator|||
comment|/* NLPID encaps ? */
name|EXTRACT_24BITS
argument_list|(
name|p
argument_list|)
operator|==
literal|0xaaaa03
condition|)
block|{
comment|/* SNAP encaps ? */
if|if
condition|(
name|llc_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|,
name|caplen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|extracted_ethertype
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|8
return|;
block|}
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|0x03
condition|)
block|{
comment|/* Cisco style NLPID encaps ? */
name|isoclns_print
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|length
operator|-
literal|1
argument_list|,
name|caplen
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* FIXME check if frame was recognized */
return|return
literal|8
return|;
block|}
if|if
condition|(
name|ip_heuristic_guess
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
operator|!=
literal|0
condition|)
comment|/* last try - vcmux encaps ? */
return|return
literal|0
return|;
return|return
operator|(
literal|8
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *     ATM2 PIC cookie format  *  *     +-------------------------------+---------+---+-----+-----------+  *     |     channel ID                |  reserv |AAL| CCRQ| gap cnt   |  *     +-------------------------------+---------+---+-----+-----------+  */
end_comment

begin_function
name|u_int
name|juniper_atm2_print
parameter_list|(
specifier|const
name|struct
name|pcap_pkthdr
modifier|*
name|h
parameter_list|,
specifier|register
specifier|const
name|u_char
modifier|*
name|p
parameter_list|)
block|{
specifier|register
name|u_int
name|length
init|=
name|h
operator|->
name|len
decl_stmt|;
specifier|register
name|u_int
name|caplen
init|=
name|h
operator|->
name|caplen
decl_stmt|;
name|u_int16_t
name|extracted_ethertype
decl_stmt|;
name|u_int8_t
name|direction
decl_stmt|;
name|u_int32_t
name|cookie1
decl_stmt|,
name|cookie2
decl_stmt|;
if|if
condition|(
name|juniper_parse_header
argument_list|(
name|p
argument_list|,
operator|&
name|direction
argument_list|,
name|length
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|p
operator|+=
literal|4
expr_stmt|;
name|length
operator|-=
literal|4
expr_stmt|;
name|caplen
operator|-=
literal|4
expr_stmt|;
name|cookie1
operator|=
name|EXTRACT_32BITS
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|cookie2
operator|=
name|EXTRACT_32BITS
argument_list|(
name|p
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|eflag
condition|)
block|{
comment|/* FIXME decode channel, fmt-id, ccrq, aal, gap cnt                for once lets just hexdump the cookie */
name|printf
argument_list|(
literal|"ATM2 cookie 0x%08x%08x, "
argument_list|,
name|EXTRACT_32BITS
argument_list|(
name|p
argument_list|)
argument_list|,
name|EXTRACT_32BITS
argument_list|(
name|p
operator|+
literal|4
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|p
operator|+=
literal|8
expr_stmt|;
name|length
operator|-=
literal|8
expr_stmt|;
name|caplen
operator|-=
literal|8
expr_stmt|;
if|if
condition|(
name|cookie2
operator|&
name|ATM2_PKT_TYPE_MASK
condition|)
block|{
comment|/* OAM cell ? */
name|oam_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
literal|12
return|;
block|}
if|if
condition|(
name|EXTRACT_24BITS
argument_list|(
name|p
argument_list|)
operator|==
literal|0xfefe03
operator|||
comment|/* NLPID encaps ? */
name|EXTRACT_24BITS
argument_list|(
name|p
argument_list|)
operator|==
literal|0xaaaa03
condition|)
block|{
comment|/* SNAP encaps ? */
if|if
condition|(
name|llc_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|,
name|caplen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|extracted_ethertype
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|12
return|;
block|}
if|if
condition|(
name|direction
operator|!=
name|JUNIPER_BPF_PKT_IN
operator|&&
comment|/* ether-over-1483 encaps ? */
operator|(
name|cookie1
operator|&
name|ATM2_GAP_COUNT_MASK
operator|)
condition|)
block|{
name|ether_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|,
name|caplen
argument_list|)
expr_stmt|;
return|return
literal|12
return|;
block|}
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|0x03
condition|)
block|{
comment|/* Cisco style NLPID encaps ? */
name|isoclns_print
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|length
operator|-
literal|1
argument_list|,
name|caplen
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* FIXME check if frame was recognized */
return|return
literal|12
return|;
block|}
if|if
condition|(
name|juniper_ppp_heuristic_guess
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
operator|!=
literal|0
condition|)
comment|/* PPPoA vcmux encaps ? */
return|return
literal|12
return|;
if|if
condition|(
name|ip_heuristic_guess
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
operator|!=
literal|0
condition|)
comment|/* last try - vcmux encaps ? */
return|return
literal|12
return|;
return|return
operator|(
literal|12
operator|)
return|;
block|}
end_function

begin_comment
comment|/* try to guess, based on all PPP protos that are supported in  * a juniper router if the payload data is encapsulated using PPP */
end_comment

begin_function
name|int
name|juniper_ppp_heuristic_guess
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|u_int
name|length
parameter_list|)
block|{
switch|switch
condition|(
name|EXTRACT_16BITS
argument_list|(
name|p
argument_list|)
condition|)
block|{
case|case
name|PPP_IP
case|:
case|case
name|PPP_OSI
case|:
case|case
name|PPP_MPLS_UCAST
case|:
case|case
name|PPP_MPLS_MCAST
case|:
case|case
name|PPP_IPCP
case|:
case|case
name|PPP_OSICP
case|:
case|case
name|PPP_MPLSCP
case|:
case|case
name|PPP_LCP
case|:
case|case
name|PPP_PAP
case|:
case|case
name|PPP_CHAP
case|:
case|case
name|PPP_ML
case|:
ifdef|#
directive|ifdef
name|INET6
case|case
name|PPP_IPV6
case|:
case|case
name|PPP_IPV6CP
case|:
endif|#
directive|endif
name|ppp_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
comment|/* did not find a ppp header */
break|break;
block|}
return|return
literal|1
return|;
comment|/* we printed a ppp packet */
block|}
end_function

begin_function
name|int
name|ip_heuristic_guess
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|u_int
name|length
parameter_list|)
block|{
switch|switch
condition|(
name|p
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|0x45
case|:
case|case
literal|0x46
case|:
case|case
literal|0x47
case|:
case|case
literal|0x48
case|:
case|case
literal|0x49
case|:
case|case
literal|0x4a
case|:
case|case
literal|0x4b
case|:
case|case
literal|0x4c
case|:
case|case
literal|0x4d
case|:
case|case
literal|0x4e
case|:
case|case
literal|0x4f
case|:
name|ip_print
argument_list|(
name|gndo
argument_list|,
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
literal|0x60
case|:
case|case
literal|0x61
case|:
case|case
literal|0x62
case|:
case|case
literal|0x63
case|:
case|case
literal|0x64
case|:
case|case
literal|0x65
case|:
case|case
literal|0x66
case|:
case|case
literal|0x67
case|:
case|case
literal|0x68
case|:
case|case
literal|0x69
case|:
case|case
literal|0x6a
case|:
case|case
literal|0x6b
case|:
case|case
literal|0x6c
case|:
case|case
literal|0x6d
case|:
case|case
literal|0x6e
case|:
case|case
literal|0x6f
case|:
name|ip6_print
argument_list|(
name|p
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
return|return
literal|0
return|;
comment|/* did not find a ip header */
break|break;
block|}
return|return
literal|1
return|;
comment|/* we printed an v4/v6 packet */
block|}
end_function

begin_function
specifier|static
name|int
name|juniper_parse_header
parameter_list|(
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|u_int8_t
modifier|*
name|direction
parameter_list|,
name|u_int
name|length
parameter_list|)
block|{
operator|*
name|direction
operator|=
name|p
index|[
literal|3
index|]
operator|&
name|JUNIPER_BPF_PKT_IN
expr_stmt|;
if|if
condition|(
name|EXTRACT_24BITS
argument_list|(
name|p
argument_list|)
operator|!=
literal|0x4d4743
condition|)
comment|/* magic number found ? */
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|*
name|direction
operator|==
name|JUNIPER_BPF_PKT_IN
condition|)
block|{
if|if
condition|(
name|eflag
condition|)
name|printf
argument_list|(
literal|"%3s "
argument_list|,
literal|"In"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|eflag
condition|)
name|printf
argument_list|(
literal|"%3s "
argument_list|,
literal|"Out"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p
index|[
literal|3
index|]
operator|&
name|JUNIPER_BPF_NO_L2
operator|)
operator|==
name|JUNIPER_BPF_NO_L2
condition|)
block|{
if|if
condition|(
name|eflag
condition|)
name|printf
argument_list|(
literal|"no-L2-hdr, "
argument_list|)
expr_stmt|;
comment|/* there is no link-layer present -          * perform the v4/v6 heuristics          * to figure out what it is          */
if|if
condition|(
name|ip_heuristic_guess
argument_list|(
name|p
operator|+
literal|8
argument_list|,
name|length
operator|-
literal|8
argument_list|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"no IP-hdr found!"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* stop parsing the output further */
block|}
return|return
literal|1
return|;
comment|/* everything went ok so far. continue parsing */
block|}
end_function

begin_comment
comment|/*  * Local Variables:  * c-style: whitesmith  * c-basic-offset: 8  * End:  */
end_comment

end_unit

