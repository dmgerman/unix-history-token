begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * hostapd / EAP Standalone Authenticator state machine  * Copyright (c) 2004-2005, Jouni Malinen<jkmaline@cc.hut.fi>  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License version 2 as  * published by the Free Software Foundation.  *  * Alternatively, this software may be distributed under the terms of BSD  * license.  *  * See README and COPYING for more details.  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|"hostapd.h"
end_include

begin_include
include|#
directive|include
file|"eloop.h"
end_include

begin_include
include|#
directive|include
file|"sta_info.h"
end_include

begin_include
include|#
directive|include
file|"eap_i.h"
end_include

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eap_method
name|eap_method_identity
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|EAP_MD5
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eap_method
name|eap_method_md5
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EAP_MD5 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EAP_TLS
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eap_method
name|eap_method_tls
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EAP_TLS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EAP_MSCHAPv2
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eap_method
name|eap_method_mschapv2
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EAP_MSCHAPv2 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EAP_PEAP
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eap_method
name|eap_method_peap
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EAP_PEAP */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EAP_TLV
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eap_method
name|eap_method_tlv
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EAP_TLV */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EAP_GTC
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eap_method
name|eap_method_gtc
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EAP_GTC */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EAP_TTLS
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eap_method
name|eap_method_ttls
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EAP_TTLS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EAP_SIM
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|eap_method
name|eap_method_sim
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EAP_SIM */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|eap_method
modifier|*
name|eap_methods
index|[]
init|=
block|{
operator|&
name|eap_method_identity
block|,
ifdef|#
directive|ifdef
name|EAP_MD5
operator|&
name|eap_method_md5
block|,
endif|#
directive|endif
comment|/* EAP_MD5 */
ifdef|#
directive|ifdef
name|EAP_TLS
operator|&
name|eap_method_tls
block|,
endif|#
directive|endif
comment|/* EAP_TLS */
ifdef|#
directive|ifdef
name|EAP_MSCHAPv2
operator|&
name|eap_method_mschapv2
block|,
endif|#
directive|endif
comment|/* EAP_MSCHAPv2 */
ifdef|#
directive|ifdef
name|EAP_PEAP
operator|&
name|eap_method_peap
block|,
endif|#
directive|endif
comment|/* EAP_PEAP */
ifdef|#
directive|ifdef
name|EAP_TTLS
operator|&
name|eap_method_ttls
block|,
endif|#
directive|endif
comment|/* EAP_TTLS */
ifdef|#
directive|ifdef
name|EAP_TLV
operator|&
name|eap_method_tlv
block|,
endif|#
directive|endif
comment|/* EAP_TLV */
ifdef|#
directive|ifdef
name|EAP_GTC
operator|&
name|eap_method_gtc
block|,
endif|#
directive|endif
comment|/* EAP_GTC */
ifdef|#
directive|ifdef
name|EAP_SIM
operator|&
name|eap_method_sim
block|,
endif|#
directive|endif
comment|/* EAP_SIM */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NUM_EAP_METHODS
value|(sizeof(eap_methods) / sizeof(eap_methods[0]))
end_define

begin_function
specifier|const
name|struct
name|eap_method
modifier|*
name|eap_sm_get_eap_methods
parameter_list|(
name|int
name|method
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_EAP_METHODS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eap_methods
index|[
name|i
index|]
operator|->
name|method
operator|==
name|method
condition|)
return|return
name|eap_methods
index|[
name|i
index|]
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|eap_user_free
parameter_list|(
name|struct
name|eap_user
modifier|*
name|user
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* EAP state machines are described in draft-ietf-eap-statemachine-05.txt */
end_comment

begin_function_decl
specifier|static
name|int
name|eap_sm_calculateTimeout
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|retransCount
parameter_list|,
name|int
name|eapSRTT
parameter_list|,
name|int
name|eapRTTVAR
parameter_list|,
name|int
name|methodTimeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eap_sm_parseEapResp
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|u8
modifier|*
name|resp
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u8
modifier|*
name|eap_sm_buildSuccess
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|id
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u8
modifier|*
name|eap_sm_buildFailure
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|id
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|eap_sm_nextId
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eap_sm_Policy_update
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|u8
modifier|*
name|nak_list
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|EapType
name|eap_sm_Policy_getNextMethod
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|eap_sm_Policy_getDecision
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Boolean
name|eap_sm_Policy_doPickUp
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|EapType
name|method
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Definitions for clarifying state machine implementation */
end_comment

begin_define
define|#
directive|define
name|SM_STATE
parameter_list|(
name|machine
parameter_list|,
name|state
parameter_list|)
define|\
value|static void sm_ ## machine ## _ ## state ## _Enter(struct eap_sm *sm, \ 	int global)
end_define

begin_define
define|#
directive|define
name|SM_ENTRY
parameter_list|(
name|machine
parameter_list|,
name|state
parameter_list|)
define|\
value|if (!global || sm->machine ## _state != machine ## _ ## state) { \ 	sm->changed = TRUE; \ 	wpa_printf(MSG_DEBUG, "EAP: " #machine " entering state " #state); \ } \ sm->machine ## _state = machine ## _ ## state;
end_define

begin_define
define|#
directive|define
name|SM_ENTER
parameter_list|(
name|machine
parameter_list|,
name|state
parameter_list|)
define|\
value|sm_ ## machine ## _ ## state ## _Enter(sm, 0)
end_define

begin_define
define|#
directive|define
name|SM_ENTER_GLOBAL
parameter_list|(
name|machine
parameter_list|,
name|state
parameter_list|)
define|\
value|sm_ ## machine ## _ ## state ## _Enter(sm, 1)
end_define

begin_define
define|#
directive|define
name|SM_STEP
parameter_list|(
name|machine
parameter_list|)
define|\
value|static void sm_ ## machine ## _Step(struct eap_sm *sm)
end_define

begin_define
define|#
directive|define
name|SM_STEP_RUN
parameter_list|(
name|machine
parameter_list|)
value|sm_ ## machine ## _Step(sm)
end_define

begin_function
specifier|static
name|Boolean
name|eapol_get_bool
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|enum
name|eapol_bool_var
name|var
parameter_list|)
block|{
return|return
name|sm
operator|->
name|eapol_cb
operator|->
name|get_bool
argument_list|(
name|sm
operator|->
name|eapol_ctx
argument_list|,
name|var
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eapol_set_bool
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|enum
name|eapol_bool_var
name|var
parameter_list|,
name|Boolean
name|value
parameter_list|)
block|{
name|sm
operator|->
name|eapol_cb
operator|->
name|set_bool
argument_list|(
name|sm
operator|->
name|eapol_ctx
argument_list|,
name|var
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|eapol_set_eapReqData
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|u8
modifier|*
name|eapReqData
parameter_list|,
name|size_t
name|eapReqDataLen
parameter_list|)
block|{
name|wpa_hexdump
argument_list|(
name|MSG_MSGDUMP
argument_list|,
literal|"EAP: eapReqData -> EAPOL"
argument_list|,
name|sm
operator|->
name|eapReqData
argument_list|,
name|sm
operator|->
name|eapReqDataLen
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapol_cb
operator|->
name|set_eapReqData
argument_list|(
name|sm
operator|->
name|eapol_ctx
argument_list|,
name|eapReqData
argument_list|,
name|eapReqDataLen
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|eapol_set_eapKeyData
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|u8
modifier|*
name|eapKeyData
parameter_list|,
name|size_t
name|eapKeyDataLen
parameter_list|)
block|{
name|wpa_hexdump
argument_list|(
name|MSG_MSGDUMP
argument_list|,
literal|"EAP: eapKeyData -> EAPOL"
argument_list|,
name|sm
operator|->
name|eapKeyData
argument_list|,
name|sm
operator|->
name|eapKeyDataLen
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapol_cb
operator|->
name|set_eapKeyData
argument_list|(
name|sm
operator|->
name|eapol_ctx
argument_list|,
name|eapKeyData
argument_list|,
name|eapKeyDataLen
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|eap_user_get
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|u8
modifier|*
name|identity
parameter_list|,
name|size_t
name|identity_len
parameter_list|,
name|int
name|phase2
parameter_list|)
block|{
name|struct
name|eap_user
modifier|*
name|user
decl_stmt|;
if|if
condition|(
name|sm
operator|==
name|NULL
operator|||
name|sm
operator|->
name|eapol_cb
operator|==
name|NULL
operator|||
name|sm
operator|->
name|eapol_cb
operator|->
name|get_eap_user
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|eap_user_free
argument_list|(
name|sm
operator|->
name|user
argument_list|)
expr_stmt|;
name|sm
operator|->
name|user
operator|=
name|NULL
expr_stmt|;
name|user
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|user
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|user
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|memset
argument_list|(
name|user
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|user
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|eapol_cb
operator|->
name|get_eap_user
argument_list|(
name|sm
operator|->
name|eapol_ctx
argument_list|,
name|identity
argument_list|,
name|identity_len
argument_list|,
name|phase2
argument_list|,
name|user
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|eap_user_free
argument_list|(
name|user
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|sm
operator|->
name|user
operator|=
name|user
expr_stmt|;
name|sm
operator|->
name|user_eap_method_index
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|DISABLED
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|DISABLED
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|INITIALIZE
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|INITIALIZE
argument_list|)
expr_stmt|;
name|sm
operator|->
name|currentId
operator|=
operator|-
literal|1
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapSuccess
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapFail
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapTimeout
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sm
operator|->
name|eapKeyData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapKeyData
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|eapKeyDataLen
operator|=
literal|0
expr_stmt|;
comment|/* eapKeyAvailable = FALSE */
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapRestart
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* This is not defined in draft-ietf-eap-statemachine-05.txt, but 	 * method state needs to be reseted here so that it does not remain in 	 * success state when re-authentication starts. */
if|if
condition|(
name|sm
operator|->
name|m
operator|&&
name|sm
operator|->
name|eap_method_priv
condition|)
block|{
name|sm
operator|->
name|m
operator|->
name|reset
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eap_method_priv
operator|=
name|NULL
expr_stmt|;
block|}
name|sm
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|user_eap_method_index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|backend_auth
condition|)
block|{
name|sm
operator|->
name|currentMethod
operator|=
name|EAP_TYPE_NONE
expr_stmt|;
comment|/* parse rxResp, respId, respMethod */
name|eap_sm_parseEapResp
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eapRespData
argument_list|,
name|sm
operator|->
name|eapRespDataLen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|rxResp
condition|)
block|{
name|sm
operator|->
name|currentId
operator|=
name|sm
operator|->
name|respId
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|PICK_UP_METHOD
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|PICK_UP_METHOD
argument_list|)
expr_stmt|;
if|if
condition|(
name|eap_sm_Policy_doPickUp
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|respMethod
argument_list|)
condition|)
block|{
name|sm
operator|->
name|currentMethod
operator|=
name|sm
operator|->
name|respMethod
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
operator|&&
name|sm
operator|->
name|eap_method_priv
condition|)
block|{
name|sm
operator|->
name|m
operator|->
name|reset
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eap_method_priv
operator|=
name|NULL
expr_stmt|;
block|}
name|sm
operator|->
name|m
operator|=
name|eap_sm_get_eap_methods
argument_list|(
name|sm
operator|->
name|currentMethod
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
operator|&&
name|sm
operator|->
name|m
operator|->
name|initPickUp
condition|)
block|{
name|sm
operator|->
name|eap_method_priv
operator|=
name|sm
operator|->
name|m
operator|->
name|initPickUp
argument_list|(
name|sm
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|eap_method_priv
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Failed to "
literal|"initialize EAP method %d"
argument_list|,
name|sm
operator|->
name|currentMethod
argument_list|)
expr_stmt|;
name|sm
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|currentMethod
operator|=
name|EAP_TYPE_NONE
expr_stmt|;
block|}
block|}
else|else
block|{
name|sm
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|currentMethod
operator|=
name|EAP_TYPE_NONE
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|IDLE
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|IDLE
argument_list|)
expr_stmt|;
name|sm
operator|->
name|retransWhile
operator|=
name|eap_sm_calculateTimeout
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|retransCount
argument_list|,
name|sm
operator|->
name|eapSRTT
argument_list|,
name|sm
operator|->
name|eapRTTVAR
argument_list|,
name|sm
operator|->
name|methodTimeout
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|RETRANSMIT
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|RETRANSMIT
argument_list|)
expr_stmt|;
comment|/* TODO: Is this needed since EAPOL state machines take care of 	 * retransmit? */
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|RECEIVED
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|RECEIVED
argument_list|)
expr_stmt|;
comment|/* parse rxResp, respId, respMethod */
name|eap_sm_parseEapResp
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eapRespData
argument_list|,
name|sm
operator|->
name|eapRespDataLen
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|DISCARD
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|DISCARD
argument_list|)
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapResp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapNoReq
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|SEND_REQUEST
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|SEND_REQUEST
argument_list|)
expr_stmt|;
name|sm
operator|->
name|retransCount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|eapReqData
condition|)
block|{
name|eapol_set_eapReqData
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eapReqData
argument_list|,
name|sm
operator|->
name|eapReqDataLen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sm
operator|->
name|lastReqData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|lastReqData
operator|=
name|sm
operator|->
name|eapReqData
expr_stmt|;
name|sm
operator|->
name|lastReqDataLen
operator|=
name|sm
operator|->
name|eapReqDataLen
expr_stmt|;
name|sm
operator|->
name|eapReqData
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|eapReqDataLen
operator|=
literal|0
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapResp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapReq
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wpa_printf
argument_list|(
name|MSG_INFO
argument_list|,
literal|"EAP: SEND_REQUEST - no eapReqData"
argument_list|)
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapResp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapReq
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapNoReq
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|INTEGRITY_CHECK
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|INTEGRITY_CHECK
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
operator|->
name|check
condition|)
block|{
name|sm
operator|->
name|ignore
operator|=
name|sm
operator|->
name|m
operator|->
name|check
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|,
name|sm
operator|->
name|eapRespData
argument_list|,
name|sm
operator|->
name|eapRespDataLen
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|METHOD_REQUEST
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|METHOD_REQUEST
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: method not initialized"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sm
operator|->
name|currentId
operator|=
name|eap_sm_nextId
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|currentId
argument_list|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: building EAP-Request: Identifier %d"
argument_list|,
name|sm
operator|->
name|currentId
argument_list|)
expr_stmt|;
name|sm
operator|->
name|lastId
operator|=
name|sm
operator|->
name|currentId
expr_stmt|;
name|free
argument_list|(
name|sm
operator|->
name|eapReqData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapReqData
operator|=
name|sm
operator|->
name|m
operator|->
name|buildReq
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|,
name|sm
operator|->
name|currentId
argument_list|,
operator|&
name|sm
operator|->
name|eapReqDataLen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
operator|->
name|getTimeout
condition|)
name|sm
operator|->
name|methodTimeout
operator|=
name|sm
operator|->
name|m
operator|->
name|getTimeout
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
expr_stmt|;
else|else
name|sm
operator|->
name|methodTimeout
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|METHOD_RESPONSE
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|METHOD_RESPONSE
argument_list|)
expr_stmt|;
name|sm
operator|->
name|m
operator|->
name|process
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|,
name|sm
operator|->
name|eapRespData
argument_list|,
name|sm
operator|->
name|eapRespDataLen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
operator|->
name|isDone
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
condition|)
block|{
name|eap_sm_Policy_update
argument_list|(
name|sm
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sm
operator|->
name|eapKeyData
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
operator|->
name|getKey
condition|)
block|{
name|sm
operator|->
name|eapKeyData
operator|=
name|sm
operator|->
name|m
operator|->
name|getKey
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|,
operator|&
name|sm
operator|->
name|eapKeyDataLen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sm
operator|->
name|eapKeyData
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|eapKeyDataLen
operator|=
literal|0
expr_stmt|;
block|}
name|sm
operator|->
name|methodState
operator|=
name|METHOD_END
expr_stmt|;
block|}
else|else
block|{
name|sm
operator|->
name|methodState
operator|=
name|METHOD_CONTINUE
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|PROPOSE_METHOD
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|PROPOSE_METHOD
argument_list|)
expr_stmt|;
name|sm
operator|->
name|currentMethod
operator|=
name|eap_sm_Policy_getNextMethod
argument_list|(
name|sm
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
operator|&&
name|sm
operator|->
name|eap_method_priv
condition|)
block|{
name|sm
operator|->
name|m
operator|->
name|reset
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eap_method_priv
operator|=
name|NULL
expr_stmt|;
block|}
name|sm
operator|->
name|m
operator|=
name|eap_sm_get_eap_methods
argument_list|(
name|sm
operator|->
name|currentMethod
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
condition|)
block|{
name|sm
operator|->
name|eap_method_priv
operator|=
name|sm
operator|->
name|m
operator|->
name|init
argument_list|(
name|sm
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|eap_method_priv
operator|==
name|NULL
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Failed to initialize EAP "
literal|"method %d"
argument_list|,
name|sm
operator|->
name|currentMethod
argument_list|)
expr_stmt|;
name|sm
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|currentMethod
operator|=
name|EAP_TYPE_NONE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sm
operator|->
name|currentMethod
operator|==
name|EAP_TYPE_IDENTITY
operator|||
name|sm
operator|->
name|currentMethod
operator|==
name|EAP_TYPE_NOTIFICATION
condition|)
name|sm
operator|->
name|methodState
operator|=
name|METHOD_CONTINUE
expr_stmt|;
else|else
name|sm
operator|->
name|methodState
operator|=
name|METHOD_PROPOSED
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|NAK
argument_list|)
end_macro

begin_block
block|{
name|struct
name|eap_hdr
modifier|*
name|nak
decl_stmt|;
name|size_t
name|len
init|=
literal|0
decl_stmt|;
name|u8
modifier|*
name|pos
decl_stmt|,
modifier|*
name|nak_list
init|=
name|NULL
decl_stmt|;
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|NAK
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|eap_method_priv
condition|)
block|{
name|sm
operator|->
name|m
operator|->
name|reset
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eap_method_priv
operator|=
name|NULL
expr_stmt|;
block|}
name|sm
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|nak
operator|=
operator|(
expr|struct
name|eap_hdr
operator|*
operator|)
name|sm
operator|->
name|eapRespData
expr_stmt|;
if|if
condition|(
name|nak
operator|&&
name|sm
operator|->
name|eapRespDataLen
operator|>
sizeof|sizeof
argument_list|(
operator|*
name|nak
argument_list|)
condition|)
block|{
name|len
operator|=
name|ntohs
argument_list|(
name|nak
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|sm
operator|->
name|eapRespDataLen
condition|)
name|len
operator|=
name|sm
operator|->
name|eapRespDataLen
expr_stmt|;
name|pos
operator|=
operator|(
name|u8
operator|*
operator|)
operator|(
name|nak
operator|+
literal|1
operator|)
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
operator|*
name|nak
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pos
operator|==
name|EAP_TYPE_NAK
condition|)
block|{
name|pos
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
name|nak_list
operator|=
name|pos
expr_stmt|;
block|}
block|}
name|eap_sm_Policy_update
argument_list|(
name|sm
argument_list|,
name|nak_list
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|SELECT_ACTION
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|SELECT_ACTION
argument_list|)
expr_stmt|;
name|sm
operator|->
name|decision
operator|=
name|eap_sm_Policy_getDecision
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|TIMEOUT_FAILURE
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|TIMEOUT_FAILURE
argument_list|)
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapTimeout
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|FAILURE
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|FAILURE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sm
operator|->
name|eapReqData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapReqData
operator|=
name|eap_sm_buildFailure
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|currentId
argument_list|,
operator|&
name|sm
operator|->
name|eapReqDataLen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|eapReqData
condition|)
block|{
name|eapol_set_eapReqData
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eapReqData
argument_list|,
name|sm
operator|->
name|eapReqDataLen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sm
operator|->
name|eapReqData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapReqData
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|eapReqDataLen
operator|=
literal|0
expr_stmt|;
block|}
name|free
argument_list|(
name|sm
operator|->
name|lastReqData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|lastReqData
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|lastReqDataLen
operator|=
literal|0
expr_stmt|;
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapFail
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STATE
argument_list|(
argument|EAP
argument_list|,
argument|SUCCESS
argument_list|)
end_macro

begin_block
block|{
name|SM_ENTRY
argument_list|(
name|EAP
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sm
operator|->
name|eapReqData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapReqData
operator|=
name|eap_sm_buildSuccess
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|currentId
argument_list|,
operator|&
name|sm
operator|->
name|eapReqDataLen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|eapReqData
condition|)
block|{
name|eapol_set_eapReqData
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eapReqData
argument_list|,
name|sm
operator|->
name|eapReqDataLen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sm
operator|->
name|eapReqData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapReqData
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|eapReqDataLen
operator|=
literal|0
expr_stmt|;
block|}
name|free
argument_list|(
name|sm
operator|->
name|lastReqData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|lastReqData
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|lastReqDataLen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|eapKeyData
condition|)
block|{
name|eapol_set_eapKeyData
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eapKeyData
argument_list|,
name|sm
operator|->
name|eapKeyDataLen
argument_list|)
expr_stmt|;
block|}
name|eapol_set_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapSuccess
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|SM_STEP
argument_list|(
argument|EAP
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|eapol_get_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapRestart
argument_list|)
operator|&&
name|eapol_get_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_portEnabled
argument_list|)
condition|)
name|SM_ENTER_GLOBAL
argument_list|(
name|EAP
argument_list|,
name|INITIALIZE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|eapol_get_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_portEnabled
argument_list|)
condition|)
name|SM_ENTER_GLOBAL
argument_list|(
name|EAP
argument_list|,
name|DISABLED
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
name|sm
operator|->
name|EAP_state
condition|)
block|{
case|case
name|EAP_INITIALIZE
case|:
if|if
condition|(
name|sm
operator|->
name|backend_auth
condition|)
block|{
if|if
condition|(
operator|!
name|sm
operator|->
name|rxResp
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SELECT_ACTION
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|rxResp
operator|&&
operator|(
name|sm
operator|->
name|respMethod
operator|==
name|EAP_TYPE_NAK
operator|||
name|sm
operator|->
name|respMethod
operator|==
name|EAP_TYPE_EXPANDED_NAK
operator|)
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|NAK
argument_list|)
expr_stmt|;
else|else
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|PICK_UP_METHOD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SELECT_ACTION
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EAP_PICK_UP_METHOD
case|:
if|if
condition|(
name|sm
operator|->
name|currentMethod
operator|==
name|EAP_TYPE_NONE
condition|)
block|{
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SELECT_ACTION
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|METHOD_RESPONSE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EAP_DISABLED
case|:
if|if
condition|(
name|eapol_get_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_portEnabled
argument_list|)
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|INITIALIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_IDLE
case|:
if|if
condition|(
name|sm
operator|->
name|retransWhile
operator|==
literal|0
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|RETRANSMIT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|eapol_get_bool
argument_list|(
name|sm
argument_list|,
name|EAPOL_eapResp
argument_list|)
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|RECEIVED
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_RETRANSMIT
case|:
if|if
condition|(
name|sm
operator|->
name|retransCount
operator|>
name|sm
operator|->
name|MaxRetrans
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|TIMEOUT_FAILURE
argument_list|)
expr_stmt|;
else|else
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|IDLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_RECEIVED
case|:
if|if
condition|(
name|sm
operator|->
name|rxResp
operator|&&
operator|(
name|sm
operator|->
name|respId
operator|==
name|sm
operator|->
name|currentId
operator|)
operator|&&
operator|(
name|sm
operator|->
name|respMethod
operator|==
name|EAP_TYPE_NAK
operator|||
name|sm
operator|->
name|respMethod
operator|==
name|EAP_TYPE_EXPANDED_NAK
operator|)
operator|&&
operator|(
name|sm
operator|->
name|methodState
operator|==
name|METHOD_PROPOSED
operator|)
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|NAK
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|rxResp
operator|&&
operator|(
name|sm
operator|->
name|respId
operator|==
name|sm
operator|->
name|currentId
operator|)
operator|&&
operator|(
name|sm
operator|->
name|respMethod
operator|==
name|sm
operator|->
name|currentMethod
operator|)
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|INTEGRITY_CHECK
argument_list|)
expr_stmt|;
else|else
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|DISCARD
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_DISCARD
case|:
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|IDLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_SEND_REQUEST
case|:
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|IDLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_INTEGRITY_CHECK
case|:
if|if
condition|(
name|sm
operator|->
name|ignore
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|DISCARD
argument_list|)
expr_stmt|;
else|else
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|METHOD_RESPONSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_METHOD_REQUEST
case|:
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SEND_REQUEST
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_METHOD_RESPONSE
case|:
if|if
condition|(
name|sm
operator|->
name|methodState
operator|==
name|METHOD_END
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SELECT_ACTION
argument_list|)
expr_stmt|;
else|else
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|METHOD_REQUEST
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_PROPOSE_METHOD
case|:
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|METHOD_REQUEST
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_NAK
case|:
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SELECT_ACTION
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_SELECT_ACTION
case|:
if|if
condition|(
name|sm
operator|->
name|decision
operator|==
name|DECISION_FAILURE
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|FAILURE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sm
operator|->
name|decision
operator|==
name|DECISION_SUCCESS
condition|)
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|SUCCESS
argument_list|)
expr_stmt|;
else|else
name|SM_ENTER
argument_list|(
name|EAP
argument_list|,
name|PROPOSE_METHOD
argument_list|)
expr_stmt|;
break|break;
case|case
name|EAP_TIMEOUT_FAILURE
case|:
break|break;
case|case
name|EAP_FAILURE
case|:
break|break;
case|case
name|EAP_SUCCESS
case|:
break|break;
block|}
block|}
end_block

begin_function
specifier|static
name|int
name|eap_sm_calculateTimeout
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|retransCount
parameter_list|,
name|int
name|eapSRTT
parameter_list|,
name|int
name|eapRTTVAR
parameter_list|,
name|int
name|methodTimeout
parameter_list|)
block|{
comment|/* For now, retransmission is done in EAPOL state machines, so make 	 * sure EAP state machine does not end up trying to retransmit packets. 	 */
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eap_sm_parseEapResp
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|u8
modifier|*
name|resp
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|struct
name|eap_hdr
modifier|*
name|hdr
decl_stmt|;
name|size_t
name|plen
decl_stmt|;
comment|/* parse rxResp, respId, respMethod */
name|sm
operator|->
name|rxResp
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|respId
operator|=
operator|-
literal|1
expr_stmt|;
name|sm
operator|->
name|respMethod
operator|=
name|EAP_TYPE_NONE
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
operator|||
name|len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
condition|)
return|return;
name|hdr
operator|=
operator|(
expr|struct
name|eap_hdr
operator|*
operator|)
name|resp
expr_stmt|;
name|plen
operator|=
name|ntohs
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|>
name|len
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Ignored truncated EAP-Packet "
literal|"(len=%lu plen=%lu)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|len
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|plen
argument_list|)
expr_stmt|;
return|return;
block|}
name|sm
operator|->
name|respId
operator|=
name|hdr
operator|->
name|identifier
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|code
operator|==
name|EAP_CODE_RESPONSE
condition|)
name|sm
operator|->
name|rxResp
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
condition|)
name|sm
operator|->
name|respMethod
operator|=
operator|*
operator|(
operator|(
name|u8
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: parseEapResp: rxResp=%d respId=%d "
literal|"respMethod=%d"
argument_list|,
name|sm
operator|->
name|rxResp
argument_list|,
name|sm
operator|->
name|respId
argument_list|,
name|sm
operator|->
name|respMethod
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u8
modifier|*
name|eap_sm_buildSuccess
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|id
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|eap_hdr
modifier|*
name|resp
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Building EAP-Success (id=%d)"
argument_list|,
name|id
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|resp
argument_list|)
expr_stmt|;
name|resp
operator|=
name|malloc
argument_list|(
operator|*
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|resp
operator|->
name|code
operator|=
name|EAP_CODE_SUCCESS
expr_stmt|;
name|resp
operator|->
name|identifier
operator|=
name|id
expr_stmt|;
name|resp
operator|->
name|length
operator|=
name|htons
argument_list|(
operator|*
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|u8
operator|*
operator|)
name|resp
return|;
block|}
end_function

begin_function
specifier|static
name|u8
modifier|*
name|eap_sm_buildFailure
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|id
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|eap_hdr
modifier|*
name|resp
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: Building EAP-Failure (id=%d)"
argument_list|,
name|id
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|resp
argument_list|)
expr_stmt|;
name|resp
operator|=
name|malloc
argument_list|(
operator|*
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|resp
operator|->
name|code
operator|=
name|EAP_CODE_FAILURE
expr_stmt|;
name|resp
operator|->
name|identifier
operator|=
name|id
expr_stmt|;
name|resp
operator|->
name|length
operator|=
name|htons
argument_list|(
operator|*
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|u8
operator|*
operator|)
name|resp
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|eap_sm_nextId
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|int
name|id
parameter_list|)
block|{
if|if
condition|(
name|id
operator|<
literal|0
condition|)
block|{
comment|/* RFC 3748 Ch 4.1: recommended to initalize Identifier with a 		 * random number */
name|id
operator|=
name|rand
argument_list|()
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|id
operator|!=
name|sm
operator|->
name|lastId
condition|)
return|return
name|id
return|;
block|}
return|return
operator|(
name|id
operator|+
literal|1
operator|)
operator|&
literal|0xff
return|;
block|}
end_function

begin_function
name|void
name|eap_sm_process_nak
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|u8
modifier|*
name|nak_list
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|wpa_printf
argument_list|(
name|MSG_MSGDUMP
argument_list|,
literal|"EAP: processing NAK (current EAP method "
literal|"index %d)"
argument_list|,
name|sm
operator|->
name|user_eap_method_index
argument_list|)
expr_stmt|;
name|wpa_hexdump
argument_list|(
name|MSG_MSGDUMP
argument_list|,
literal|"EAP: configured methods"
argument_list|,
name|sm
operator|->
name|user
operator|->
name|methods
argument_list|,
name|EAP_MAX_METHODS
argument_list|)
expr_stmt|;
name|wpa_hexdump
argument_list|(
name|MSG_MSGDUMP
argument_list|,
literal|"EAP: list of methods supported by the peer"
argument_list|,
name|nak_list
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|i
operator|=
name|sm
operator|->
name|user_eap_method_index
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|EAP_MAX_METHODS
operator|&&
name|sm
operator|->
name|user
operator|->
name|methods
index|[
name|i
index|]
operator|!=
name|EAP_TYPE_NONE
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|nak_list
index|[
name|j
index|]
operator|==
name|sm
operator|->
name|user
operator|->
name|methods
index|[
name|i
index|]
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|j
operator|<
name|len
condition|)
block|{
comment|/* found */
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* not found - remove from the list */
name|memmove
argument_list|(
operator|&
name|sm
operator|->
name|user
operator|->
name|methods
index|[
name|i
index|]
argument_list|,
operator|&
name|sm
operator|->
name|user
operator|->
name|methods
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|EAP_MAX_METHODS
operator|-
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sm
operator|->
name|user
operator|->
name|methods
index|[
name|EAP_MAX_METHODS
operator|-
literal|1
index|]
operator|=
name|EAP_TYPE_NONE
expr_stmt|;
block|}
name|wpa_hexdump
argument_list|(
name|MSG_MSGDUMP
argument_list|,
literal|"EAP: new list of configured methods"
argument_list|,
name|sm
operator|->
name|user
operator|->
name|methods
argument_list|,
name|EAP_MAX_METHODS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|eap_sm_Policy_update
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|u8
modifier|*
name|nak_list
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|nak_list
operator|==
name|NULL
operator|||
name|sm
operator|==
name|NULL
operator|||
name|sm
operator|->
name|user
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|sm
operator|->
name|user
operator|->
name|phase2
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: EAP-Nak received after Phase2 user"
literal|" info was selected - reject"
argument_list|)
expr_stmt|;
name|sm
operator|->
name|decision
operator|=
name|DECISION_FAILURE
expr_stmt|;
return|return;
block|}
name|eap_sm_process_nak
argument_list|(
name|sm
argument_list|,
name|nak_list
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|EapType
name|eap_sm_Policy_getNextMethod
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
name|EapType
name|next
decl_stmt|;
comment|/* In theory, there should be no problems with starting 	 * re-authentication with something else than EAP-Request/Identity and 	 * this does indeed work with wpa_supplicant. However, at least Funk 	 * Supplicant seemed to ignore re-auth if it skipped 	 * EAP-Request/Identity. 	 * Re-auth sets currentId == -1, so that can be used here to select 	 * whether Identity needs to be requested again. */
if|if
condition|(
name|sm
operator|->
name|identity
operator|==
name|NULL
operator|||
name|sm
operator|->
name|currentId
operator|==
operator|-
literal|1
condition|)
block|{
name|next
operator|=
name|EAP_TYPE_IDENTITY
expr_stmt|;
name|sm
operator|->
name|update_user
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sm
operator|->
name|user
operator|&&
name|sm
operator|->
name|user_eap_method_index
operator|<
name|EAP_MAX_METHODS
operator|&&
name|sm
operator|->
name|user
operator|->
name|methods
index|[
name|sm
operator|->
name|user_eap_method_index
index|]
operator|!=
name|EAP_TYPE_NONE
condition|)
block|{
name|next
operator|=
name|sm
operator|->
name|user
operator|->
name|methods
index|[
name|sm
operator|->
name|user_eap_method_index
operator|++
index|]
expr_stmt|;
block|}
else|else
block|{
name|next
operator|=
name|EAP_TYPE_NONE
expr_stmt|;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: getNextMethod: type %d"
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return
name|next
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|eap_sm_Policy_getDecision
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|->
name|m
operator|&&
name|sm
operator|->
name|currentMethod
operator|!=
name|EAP_TYPE_IDENTITY
operator|&&
name|sm
operator|->
name|m
operator|->
name|isSuccess
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: getDecision: method succeeded -> "
literal|"SUCCESS"
argument_list|)
expr_stmt|;
name|sm
operator|->
name|update_user
operator|=
name|TRUE
expr_stmt|;
return|return
name|DECISION_SUCCESS
return|;
block|}
if|if
condition|(
name|sm
operator|->
name|m
operator|&&
name|sm
operator|->
name|m
operator|->
name|isDone
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
operator|&&
operator|!
name|sm
operator|->
name|m
operator|->
name|isSuccess
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: getDecision: method failed -> "
literal|"FAILURE"
argument_list|)
expr_stmt|;
name|sm
operator|->
name|update_user
operator|=
name|TRUE
expr_stmt|;
return|return
name|DECISION_FAILURE
return|;
block|}
if|if
condition|(
operator|(
name|sm
operator|->
name|user
operator|==
name|NULL
operator|||
name|sm
operator|->
name|update_user
operator|)
operator|&&
name|sm
operator|->
name|identity
condition|)
block|{
if|if
condition|(
name|eap_user_get
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|identity
argument_list|,
name|sm
operator|->
name|identity_len
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: getDecision: user not "
literal|"found from database -> FAILURE"
argument_list|)
expr_stmt|;
return|return
name|DECISION_FAILURE
return|;
block|}
name|sm
operator|->
name|update_user
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|sm
operator|->
name|user
operator|&&
name|sm
operator|->
name|user_eap_method_index
operator|<
name|EAP_MAX_METHODS
operator|&&
name|sm
operator|->
name|user
operator|->
name|methods
index|[
name|sm
operator|->
name|user_eap_method_index
index|]
operator|!=
name|EAP_TYPE_NONE
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: getDecision: another method "
literal|"available -> CONTINUE"
argument_list|)
expr_stmt|;
return|return
name|DECISION_CONTINUE
return|;
block|}
if|if
condition|(
name|sm
operator|->
name|identity
operator|==
name|NULL
operator|||
name|sm
operator|->
name|currentId
operator|==
operator|-
literal|1
condition|)
block|{
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: getDecision: no identity known "
literal|"yet -> CONTINUE"
argument_list|)
expr_stmt|;
return|return
name|DECISION_CONTINUE
return|;
block|}
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: getDecision: no more methods available -> "
literal|"FAILURE"
argument_list|)
expr_stmt|;
return|return
name|DECISION_FAILURE
return|;
block|}
end_function

begin_function
specifier|static
name|Boolean
name|eap_sm_Policy_doPickUp
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
name|EapType
name|method
parameter_list|)
block|{
return|return
name|method
operator|==
name|EAP_TYPE_IDENTITY
condition|?
name|TRUE
else|:
name|FALSE
return|;
block|}
end_function

begin_function
name|int
name|eap_sm_step
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
name|int
name|res
init|=
literal|0
decl_stmt|;
do|do
block|{
name|sm
operator|->
name|changed
operator|=
name|FALSE
expr_stmt|;
name|SM_STEP_RUN
argument_list|(
name|EAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|changed
condition|)
name|res
operator|=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|sm
operator|->
name|changed
condition|)
do|;
return|return
name|res
return|;
block|}
end_function

begin_function
name|u8
name|eap_get_type
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_EAP_METHODS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|eap_methods
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|eap_methods
index|[
name|i
index|]
operator|->
name|method
return|;
block|}
return|return
name|EAP_TYPE_NONE
return|;
block|}
end_function

begin_function
name|void
name|eap_set_eapRespData
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|,
specifier|const
name|u8
modifier|*
name|eapRespData
parameter_list|,
name|size_t
name|eapRespDataLen
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return;
name|free
argument_list|(
name|sm
operator|->
name|eapRespData
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapRespData
operator|=
name|malloc
argument_list|(
name|eapRespDataLen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|eapRespData
operator|==
name|NULL
condition|)
return|return;
name|memcpy
argument_list|(
name|sm
operator|->
name|eapRespData
argument_list|,
name|eapRespData
argument_list|,
name|eapRespDataLen
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapRespDataLen
operator|=
name|eapRespDataLen
expr_stmt|;
name|wpa_hexdump
argument_list|(
name|MSG_MSGDUMP
argument_list|,
literal|"EAP: EAP-Response received"
argument_list|,
name|eapRespData
argument_list|,
name|eapRespDataLen
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|eap_user_free
parameter_list|(
name|struct
name|eap_user
modifier|*
name|user
parameter_list|)
block|{
if|if
condition|(
name|user
operator|==
name|NULL
condition|)
return|return;
name|free
argument_list|(
name|user
operator|->
name|password
argument_list|)
expr_stmt|;
name|user
operator|->
name|password
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|user
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|eap_sm
modifier|*
name|eap_sm_init
parameter_list|(
name|void
modifier|*
name|eapol_ctx
parameter_list|,
name|struct
name|eapol_callbacks
modifier|*
name|eapol_cb
parameter_list|,
name|struct
name|eap_config
modifier|*
name|eap_conf
parameter_list|)
block|{
name|struct
name|eap_sm
modifier|*
name|sm
decl_stmt|;
name|sm
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|sm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sm
argument_list|)
argument_list|)
expr_stmt|;
name|sm
operator|->
name|eapol_ctx
operator|=
name|eapol_ctx
expr_stmt|;
name|sm
operator|->
name|eapol_cb
operator|=
name|eapol_cb
expr_stmt|;
name|sm
operator|->
name|MaxRetrans
operator|=
literal|10
expr_stmt|;
name|sm
operator|->
name|ssl_ctx
operator|=
name|eap_conf
operator|->
name|ssl_ctx
expr_stmt|;
name|sm
operator|->
name|eap_sim_db_priv
operator|=
name|eap_conf
operator|->
name|eap_sim_db_priv
expr_stmt|;
name|sm
operator|->
name|backend_auth
operator|=
name|eap_conf
operator|->
name|backend_auth
expr_stmt|;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: State machine created"
argument_list|)
expr_stmt|;
return|return
name|sm
return|;
block|}
end_function

begin_function
name|void
name|eap_sm_deinit
parameter_list|(
name|struct
name|eap_sm
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return;
name|wpa_printf
argument_list|(
name|MSG_DEBUG
argument_list|,
literal|"EAP: State machine removed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|m
operator|&&
name|sm
operator|->
name|eap_method_priv
condition|)
name|sm
operator|->
name|m
operator|->
name|reset
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|eap_method_priv
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sm
operator|->
name|eapReqData
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sm
operator|->
name|eapKeyData
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sm
operator|->
name|lastReqData
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sm
operator|->
name|eapRespData
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sm
operator|->
name|identity
argument_list|)
expr_stmt|;
name|eap_user_free
argument_list|(
name|sm
operator|->
name|user
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

