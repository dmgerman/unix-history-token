begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*  * Copyright (C) 1984-2000  Mark Nudelman  *  * You may distribute under the terms of either the GNU General Public  * License or the Less License, as specified in the README file.  *  * For more information about less, or for information on how to   * contact the author, see the README file.  */
end_comment

begin_comment
comment|/*  * Routines to search a file for a pattern.  */
end_comment

begin_include
include|#
directive|include
file|"less.h"
end_include

begin_include
include|#
directive|include
file|"position.h"
end_include

begin_define
define|#
directive|define
name|MINPOS
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)< (b)) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|MAXPOS
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)> (b)) ? (a) : (b))
end_define

begin_if
if|#
directive|if
name|HAVE_POSIX_REGCOMP
end_if

begin_include
include|#
directive|include
file|<regex.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|REG_EXTENDED
end_ifdef

begin_define
define|#
directive|define
name|REGCOMP_FLAG
value|(more_mode ? 0 : REG_EXTENDED)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|REGCOMP_FLAG
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_PCRE
end_if

begin_include
include|#
directive|include
file|<pcre.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_RE_COMP
end_if

begin_function_decl
name|char
modifier|*
name|re_comp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|re_exec
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_REGCMP
end_if

begin_function_decl
name|char
modifier|*
name|regcmp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|regex
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|__loc1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_V8_REGCOMP
end_if

begin_include
include|#
directive|include
file|"regexp.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|match
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|sigs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|how_search
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|caseless
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|linenums
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sc_height
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|jump_sline
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|bs_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|more_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|status_col
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|POSITION
name|start_attnpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|POSITION
name|end_attnpos
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|HILITE_SEARCH
end_if

begin_decl_stmt
specifier|extern
name|int
name|hilite_search
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|screen_trashed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|size_linebuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|squished
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|can_goto_line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hide_hilite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|POSITION
name|prep_startpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|POSITION
name|prep_endpos
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|hilite
block|{
name|struct
name|hilite
modifier|*
name|hl_next
decl_stmt|;
name|POSITION
name|hl_startpos
decl_stmt|;
name|POSITION
name|hl_endpos
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|hilite
name|hilite_anchor
init|=
block|{
name|NULL
block|,
name|NULL_POSITION
block|,
name|NULL_POSITION
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|hl_first
value|hl_next
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * These are the static variables that represent the "remembered"  * search pattern.    */
end_comment

begin_if
if|#
directive|if
name|HAVE_POSIX_REGCOMP
end_if

begin_decl_stmt
specifier|static
name|regex_t
modifier|*
name|regpattern
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_PCRE
end_if

begin_decl_stmt
name|pcre
modifier|*
name|regpattern
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_RE_COMP
end_if

begin_decl_stmt
name|int
name|re_pattern
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_REGCMP
end_if

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cpattern
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_V8_REGCOMP
end_if

begin_decl_stmt
specifier|static
name|struct
name|regexp
modifier|*
name|regpattern
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|is_caseless
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_ucase_pattern
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|last_search_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|last_pattern
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Convert text.  Perform one or more of these transformations:  */
end_comment

begin_define
define|#
directive|define
name|CVT_TO_LC
value|01
end_define

begin_comment
comment|/* Convert upper-case to lower-case */
end_comment

begin_define
define|#
directive|define
name|CVT_BS
value|02
end_define

begin_comment
comment|/* Do backspace processing */
end_comment

begin_define
define|#
directive|define
name|CVT_CRLF
value|04
end_define

begin_comment
comment|/* Remove CR after LF */
end_comment

begin_function
specifier|static
name|void
name|cvt_text
parameter_list|(
name|odst
parameter_list|,
name|osrc
parameter_list|,
name|ops
parameter_list|)
name|char
modifier|*
name|odst
decl_stmt|;
name|char
modifier|*
name|osrc
decl_stmt|;
name|int
name|ops
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|dst
decl_stmt|;
specifier|register
name|char
modifier|*
name|src
decl_stmt|;
for|for
control|(
name|src
operator|=
name|osrc
operator|,
name|dst
operator|=
name|odst
init|;
operator|*
name|src
operator|!=
literal|'\0'
condition|;
name|src
operator|++
operator|,
name|dst
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ops
operator|&
name|CVT_TO_LC
operator|)
operator|&&
name|isupper
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|src
argument_list|)
condition|)
comment|/* Convert uppercase to lowercase. */
operator|*
name|dst
operator|=
name|tolower
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|src
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ops
operator|&
name|CVT_BS
operator|)
operator|&&
operator|*
name|src
operator|==
literal|'\b'
operator|&&
name|dst
operator|>
name|odst
condition|)
comment|/* Delete BS and preceding char. */
name|dst
operator|-=
literal|2
expr_stmt|;
else|else
comment|/* Just copy. */
operator|*
name|dst
operator|=
operator|*
name|src
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ops
operator|&
name|CVT_CRLF
operator|)
operator|&&
name|dst
operator|>
name|odst
operator|&&
name|dst
index|[
operator|-
literal|1
index|]
operator|==
literal|'\r'
condition|)
name|dst
operator|--
expr_stmt|;
operator|*
name|dst
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Are there any uppercase letters in this string?  */
end_comment

begin_function
specifier|static
name|int
name|is_ucase
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|s
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|isupper
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Is there a previous (remembered) search pattern?  */
end_comment

begin_function
specifier|static
name|int
name|prev_pattern
parameter_list|()
block|{
if|if
condition|(
name|last_search_type
operator|&
name|SRCH_NO_REGEX
condition|)
return|return
operator|(
name|last_pattern
operator|!=
name|NULL
operator|)
return|;
if|#
directive|if
name|HAVE_POSIX_REGCOMP
return|return
operator|(
name|regpattern
operator|!=
name|NULL
operator|)
return|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_PCRE
return|return
operator|(
name|regpattern
operator|!=
name|NULL
operator|)
return|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_RE_COMP
return|return
operator|(
name|re_pattern
operator|!=
literal|0
operator|)
return|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_REGCMP
return|return
operator|(
name|cpattern
operator|!=
name|NULL
operator|)
return|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_V8_REGCOMP
return|return
operator|(
name|regpattern
operator|!=
name|NULL
operator|)
return|;
endif|#
directive|endif
if|#
directive|if
name|NO_REGEX
return|return
operator|(
name|last_pattern
operator|!=
name|NULL
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
name|HILITE_SEARCH
end_if

begin_comment
comment|/*  * Repaint the hilites currently displayed on the screen.  * Repaint each line which contains highlighted text.  * If on==0, force all hilites off.  */
end_comment

begin_function
name|public
name|void
name|repaint_hilite
parameter_list|(
name|on
parameter_list|)
name|int
name|on
decl_stmt|;
block|{
name|int
name|slinenum
decl_stmt|;
name|POSITION
name|pos
decl_stmt|;
name|POSITION
name|epos
decl_stmt|;
name|int
name|save_hide_hilite
decl_stmt|;
if|if
condition|(
name|squished
condition|)
name|repaint
argument_list|()
expr_stmt|;
name|save_hide_hilite
operator|=
name|hide_hilite
expr_stmt|;
if|if
condition|(
operator|!
name|on
condition|)
block|{
if|if
condition|(
name|hide_hilite
condition|)
return|return;
name|hide_hilite
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|can_goto_line
condition|)
block|{
name|repaint
argument_list|()
expr_stmt|;
name|hide_hilite
operator|=
name|save_hide_hilite
expr_stmt|;
return|return;
block|}
for|for
control|(
name|slinenum
operator|=
name|TOP
init|;
name|slinenum
operator|<
name|TOP
operator|+
name|sc_height
operator|-
literal|1
condition|;
name|slinenum
operator|++
control|)
block|{
name|pos
operator|=
name|position
argument_list|(
name|slinenum
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|NULL_POSITION
condition|)
continue|continue;
name|epos
operator|=
name|position
argument_list|(
name|slinenum
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * If any character in the line is highlighted,  		 * repaint the line. 		 */
if|if
condition|(
name|is_hilited
argument_list|(
name|pos
argument_list|,
name|epos
argument_list|,
literal|1
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|forw_line
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|goto_line
argument_list|(
name|slinenum
argument_list|)
expr_stmt|;
name|put_line
argument_list|()
expr_stmt|;
block|}
block|}
name|hide_hilite
operator|=
name|save_hide_hilite
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Clear the attn hilite.  */
end_comment

begin_function
name|public
name|void
name|clear_attn
parameter_list|()
block|{
name|int
name|slinenum
decl_stmt|;
name|POSITION
name|old_start_attnpos
decl_stmt|;
name|POSITION
name|old_end_attnpos
decl_stmt|;
name|POSITION
name|pos
decl_stmt|;
name|POSITION
name|epos
decl_stmt|;
if|if
condition|(
name|start_attnpos
operator|==
name|NULL_POSITION
condition|)
return|return;
name|old_start_attnpos
operator|=
name|start_attnpos
expr_stmt|;
name|old_end_attnpos
operator|=
name|end_attnpos
expr_stmt|;
name|start_attnpos
operator|=
name|end_attnpos
operator|=
name|NULL_POSITION
expr_stmt|;
if|if
condition|(
operator|!
name|can_goto_line
condition|)
block|{
name|repaint
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|squished
condition|)
name|repaint
argument_list|()
expr_stmt|;
for|for
control|(
name|slinenum
operator|=
name|TOP
init|;
name|slinenum
operator|<
name|TOP
operator|+
name|sc_height
operator|-
literal|1
condition|;
name|slinenum
operator|++
control|)
block|{
name|pos
operator|=
name|position
argument_list|(
name|slinenum
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|NULL_POSITION
condition|)
continue|continue;
name|epos
operator|=
name|position
argument_list|(
name|slinenum
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|<
name|old_end_attnpos
operator|&&
operator|(
name|epos
operator|==
name|NULL_POSITION
operator|||
name|epos
operator|>
name|old_start_attnpos
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|forw_line
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|goto_line
argument_list|(
name|slinenum
argument_list|)
expr_stmt|;
name|put_line
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Hide search string highlighting.  */
end_comment

begin_function
name|public
name|void
name|undo_search
parameter_list|()
block|{
if|if
condition|(
operator|!
name|prev_pattern
argument_list|()
condition|)
block|{
name|error
argument_list|(
literal|"No previous regular expression"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|HILITE_SEARCH
name|hide_hilite
operator|=
operator|!
name|hide_hilite
expr_stmt|;
name|repaint_hilite
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Compile a search pattern, for future use by match_pattern.  */
end_comment

begin_function
specifier|static
name|int
name|compile_pattern
parameter_list|(
name|pattern
parameter_list|,
name|search_type
parameter_list|)
name|char
modifier|*
name|pattern
decl_stmt|;
name|int
name|search_type
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|search_type
operator|&
name|SRCH_NO_REGEX
operator|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|HAVE_POSIX_REGCOMP
name|regex_t
modifier|*
name|s
init|=
operator|(
name|regex_t
operator|*
operator|)
name|ecalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|regex_t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|regcomp
argument_list|(
name|s
argument_list|,
name|pattern
argument_list|,
name|REGCOMP_FLAG
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Invalid pattern"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|regpattern
operator|!=
name|NULL
condition|)
name|regfree
argument_list|(
name|regpattern
argument_list|)
expr_stmt|;
name|regpattern
operator|=
name|s
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_PCRE
name|pcre
modifier|*
name|comp
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstring
decl_stmt|;
name|int
name|erroffset
decl_stmt|;
name|PARG
name|parg
decl_stmt|;
name|comp
operator|=
name|pcre_compile
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|,
operator|&
name|errstring
argument_list|,
operator|&
name|erroffset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp
operator|==
name|NULL
condition|)
block|{
name|parg
operator|.
name|p_string
operator|=
operator|(
name|char
operator|*
operator|)
name|errstring
expr_stmt|;
name|error
argument_list|(
literal|"%s"
argument_list|,
operator|&
name|parg
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|regpattern
operator|=
name|comp
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_RE_COMP
name|PARG
name|parg
decl_stmt|;
if|if
condition|(
operator|(
name|parg
operator|.
name|p_string
operator|=
name|re_comp
argument_list|(
name|pattern
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%s"
argument_list|,
operator|&
name|parg
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|re_pattern
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_REGCMP
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|regcmp
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"Invalid pattern"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|cpattern
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cpattern
argument_list|)
expr_stmt|;
name|cpattern
operator|=
name|s
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_V8_REGCOMP
name|struct
name|regexp
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|regcomp
argument_list|(
name|pattern
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * regcomp has already printed an error message  			 * via regerror(). 			 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|regpattern
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|regpattern
argument_list|)
expr_stmt|;
name|regpattern
operator|=
name|s
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|last_pattern
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|last_pattern
argument_list|)
expr_stmt|;
name|last_pattern
operator|=
operator|(
name|char
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
name|strlen
argument_list|(
name|pattern
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_pattern
operator|!=
name|NULL
condition|)
name|strcpy
argument_list|(
name|last_pattern
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
name|last_search_type
operator|=
name|search_type
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Forget that we have a compiled pattern.  */
end_comment

begin_function
specifier|static
name|void
name|uncompile_pattern
parameter_list|()
block|{
if|#
directive|if
name|HAVE_POSIX_REGCOMP
if|if
condition|(
name|regpattern
operator|!=
name|NULL
condition|)
name|regfree
argument_list|(
name|regpattern
argument_list|)
expr_stmt|;
name|regpattern
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_PCRE
if|if
condition|(
name|regpattern
operator|!=
name|NULL
condition|)
name|pcre_free
argument_list|(
name|regpattern
argument_list|)
expr_stmt|;
name|regpattern
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_RE_COMP
name|re_pattern
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_REGCMP
if|if
condition|(
name|cpattern
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cpattern
argument_list|)
expr_stmt|;
name|cpattern
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_V8_REGCOMP
if|if
condition|(
name|regpattern
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|regpattern
argument_list|)
expr_stmt|;
name|regpattern
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|last_pattern
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Perform a pattern match with the previously compiled pattern.  * Set sp and ep to the start and end of the matched string.  */
end_comment

begin_function
specifier|static
name|int
name|match_pattern
parameter_list|(
name|line
parameter_list|,
name|sp
parameter_list|,
name|ep
parameter_list|,
name|notbol
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
name|char
modifier|*
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
modifier|*
name|ep
decl_stmt|;
name|int
name|notbol
decl_stmt|;
block|{
name|int
name|matched
decl_stmt|;
if|if
condition|(
name|last_search_type
operator|&
name|SRCH_NO_REGEX
condition|)
return|return
operator|(
name|match
argument_list|(
name|last_pattern
argument_list|,
name|line
argument_list|,
name|sp
argument_list|,
name|ep
argument_list|)
operator|)
return|;
if|#
directive|if
name|HAVE_POSIX_REGCOMP
block|{
name|regmatch_t
name|rm
decl_stmt|;
name|int
name|flags
init|=
operator|(
name|notbol
operator|)
condition|?
name|REG_NOTBOL
else|:
literal|0
decl_stmt|;
name|matched
operator|=
operator|!
name|regexec
argument_list|(
name|regpattern
argument_list|,
name|line
argument_list|,
literal|1
argument_list|,
operator|&
name|rm
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|matched
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifndef|#
directive|ifndef
name|__WATCOMC__
operator|*
name|sp
operator|=
name|line
operator|+
name|rm
operator|.
name|rm_so
expr_stmt|;
operator|*
name|ep
operator|=
name|line
operator|+
name|rm
operator|.
name|rm_eo
expr_stmt|;
else|#
directive|else
operator|*
name|sp
operator|=
name|rm
operator|.
name|rm_sp
expr_stmt|;
operator|*
name|ep
operator|=
name|rm
operator|.
name|rm_ep
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
if|#
directive|if
name|HAVE_PCRE
block|{
name|int
name|flags
init|=
operator|(
name|notbol
operator|)
condition|?
name|PCRE_NOTBOL
else|:
literal|0
decl_stmt|;
name|int
name|ovector
index|[
literal|3
index|]
decl_stmt|;
name|matched
operator|=
name|pcre_exec
argument_list|(
name|regpattern
argument_list|,
name|NULL
argument_list|,
name|line
argument_list|,
name|strlen
argument_list|(
name|line
argument_list|)
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|,
name|ovector
argument_list|,
literal|3
argument_list|)
operator|>=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|matched
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|sp
operator|=
name|line
operator|+
name|ovector
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|ep
operator|=
name|line
operator|+
name|ovector
index|[
literal|1
index|]
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|HAVE_RE_COMP
name|matched
operator|=
operator|(
name|re_exec
argument_list|(
name|line
argument_list|)
operator|==
literal|1
operator|)
expr_stmt|;
comment|/* 	 * re_exec doesn't seem to provide a way to get the matched string. 	 */
operator|*
name|sp
operator|=
operator|*
name|ep
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_REGCMP
operator|*
name|ep
operator|=
name|regex
argument_list|(
name|cpattern
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|matched
operator|=
operator|(
operator|*
name|ep
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|matched
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|sp
operator|=
name|__loc1
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_V8_REGCOMP
if|#
directive|if
name|HAVE_REGEXEC2
name|matched
operator|=
name|regexec2
argument_list|(
name|regpattern
argument_list|,
name|line
argument_list|,
name|notbol
argument_list|)
expr_stmt|;
else|#
directive|else
name|matched
operator|=
name|regexec
argument_list|(
name|regpattern
argument_list|,
name|line
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|matched
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|sp
operator|=
name|regpattern
operator|->
name|startp
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|ep
operator|=
name|regpattern
operator|->
name|endp
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|NO_REGEX
name|matched
operator|=
name|match
argument_list|(
name|last_pattern
argument_list|,
name|line
argument_list|,
name|sp
argument_list|,
name|ep
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|matched
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|HILITE_SEARCH
end_if

begin_comment
comment|/*  * Clear the hilite list.  */
end_comment

begin_function
name|public
name|void
name|clr_hilite
parameter_list|()
block|{
name|struct
name|hilite
modifier|*
name|hl
decl_stmt|;
name|struct
name|hilite
modifier|*
name|nexthl
decl_stmt|;
for|for
control|(
name|hl
operator|=
name|hilite_anchor
operator|.
name|hl_first
init|;
name|hl
operator|!=
name|NULL
condition|;
name|hl
operator|=
name|nexthl
control|)
block|{
name|nexthl
operator|=
name|hl
operator|->
name|hl_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|hl
argument_list|)
expr_stmt|;
block|}
name|hilite_anchor
operator|.
name|hl_first
operator|=
name|NULL
expr_stmt|;
name|prep_startpos
operator|=
name|prep_endpos
operator|=
name|NULL_POSITION
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Should any characters in a specified range be highlighted?  * If nohide is nonzero, don't consider hide_hilite.  */
end_comment

begin_function
name|public
name|int
name|is_hilited
parameter_list|(
name|pos
parameter_list|,
name|epos
parameter_list|,
name|nohide
parameter_list|)
name|POSITION
name|pos
decl_stmt|;
name|POSITION
name|epos
decl_stmt|;
name|int
name|nohide
decl_stmt|;
block|{
name|struct
name|hilite
modifier|*
name|hl
decl_stmt|;
if|if
condition|(
operator|!
name|status_col
operator|&&
name|start_attnpos
operator|!=
name|NULL_POSITION
operator|&&
name|pos
operator|<
name|end_attnpos
operator|&&
operator|(
name|epos
operator|==
name|NULL_POSITION
operator|||
name|epos
operator|>
name|start_attnpos
operator|)
condition|)
comment|/* 		 * The attn line overlaps this range. 		 */
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|hilite_search
operator|==
literal|0
condition|)
comment|/* 		 * Not doing highlighting. 		 */
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|nohide
operator|&&
name|hide_hilite
condition|)
comment|/* 		 * Highlighting is hidden. 		 */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Look at each highlight and see if any part of it falls in the range. 	 */
for|for
control|(
name|hl
operator|=
name|hilite_anchor
operator|.
name|hl_first
init|;
name|hl
operator|!=
name|NULL
condition|;
name|hl
operator|=
name|hl
operator|->
name|hl_next
control|)
block|{
if|if
condition|(
name|hl
operator|->
name|hl_endpos
operator|>
name|pos
operator|&&
operator|(
name|epos
operator|==
name|NULL_POSITION
operator|||
name|epos
operator|>
name|hl
operator|->
name|hl_startpos
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a new hilite to a hilite list.  */
end_comment

begin_function
specifier|static
name|void
name|add_hilite
parameter_list|(
name|anchor
parameter_list|,
name|hl
parameter_list|)
name|struct
name|hilite
modifier|*
name|anchor
decl_stmt|;
name|struct
name|hilite
modifier|*
name|hl
decl_stmt|;
block|{
name|struct
name|hilite
modifier|*
name|ihl
decl_stmt|;
comment|/* 	 * Hilites are sorted in the list; find where new one belongs. 	 * Insert new one after ihl. 	 */
for|for
control|(
name|ihl
operator|=
name|anchor
init|;
name|ihl
operator|->
name|hl_next
operator|!=
name|NULL
condition|;
name|ihl
operator|=
name|ihl
operator|->
name|hl_next
control|)
block|{
if|if
condition|(
name|ihl
operator|->
name|hl_next
operator|->
name|hl_startpos
operator|>
name|hl
operator|->
name|hl_startpos
condition|)
break|break;
block|}
comment|/* 	 * Truncate hilite so it doesn't overlap any existing ones 	 * above and below it. 	 */
if|if
condition|(
name|ihl
operator|!=
name|anchor
condition|)
name|hl
operator|->
name|hl_startpos
operator|=
name|MAXPOS
argument_list|(
name|hl
operator|->
name|hl_startpos
argument_list|,
name|ihl
operator|->
name|hl_endpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|ihl
operator|->
name|hl_next
operator|!=
name|NULL
condition|)
name|hl
operator|->
name|hl_endpos
operator|=
name|MINPOS
argument_list|(
name|hl
operator|->
name|hl_endpos
argument_list|,
name|ihl
operator|->
name|hl_next
operator|->
name|hl_startpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|hl
operator|->
name|hl_startpos
operator|>=
name|hl
operator|->
name|hl_endpos
condition|)
block|{
comment|/* 		 * Hilite was truncated out of existence. 		 */
name|free
argument_list|(
name|hl
argument_list|)
expr_stmt|;
return|return;
block|}
name|hl
operator|->
name|hl_next
operator|=
name|ihl
operator|->
name|hl_next
expr_stmt|;
name|ihl
operator|->
name|hl_next
operator|=
name|hl
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Adjust hl_startpos& hl_endpos to account for backspace processing.  */
end_comment

begin_function
specifier|static
name|void
name|adj_hilite
parameter_list|(
name|anchor
parameter_list|,
name|linepos
parameter_list|)
name|struct
name|hilite
modifier|*
name|anchor
decl_stmt|;
name|POSITION
name|linepos
decl_stmt|;
block|{
name|char
modifier|*
name|line
decl_stmt|;
name|struct
name|hilite
modifier|*
name|hl
decl_stmt|;
name|int
name|checkstart
decl_stmt|;
name|POSITION
name|opos
decl_stmt|;
name|POSITION
name|npos
decl_stmt|;
comment|/* 	 * The line was already scanned and hilites were added (in hilite_line). 	 * But it was assumed that each char position in the line  	 * correponds to one char position in the file. 	 * This may not be true if there are backspaces in the line. 	 * Get the raw line again.  Look at each character. 	 */
operator|(
name|void
operator|)
name|forw_raw_line
argument_list|(
name|linepos
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
name|opos
operator|=
name|npos
operator|=
name|linepos
expr_stmt|;
name|hl
operator|=
name|anchor
operator|->
name|hl_first
expr_stmt|;
name|checkstart
operator|=
name|TRUE
expr_stmt|;
while|while
condition|(
name|hl
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * See if we need to adjust the current hl_startpos or  		 * hl_endpos.  After adjusting startpos[i], move to endpos[i]. 		 * After adjusting endpos[i], move to startpos[i+1]. 		 * The hilite list must be sorted thus:  		 * startpos[0]< endpos[0]<= startpos[1]< endpos[1]<= etc. 		 */
if|if
condition|(
name|checkstart
operator|&&
name|hl
operator|->
name|hl_startpos
operator|==
name|opos
condition|)
block|{
name|hl
operator|->
name|hl_startpos
operator|=
name|npos
expr_stmt|;
name|checkstart
operator|=
name|FALSE
expr_stmt|;
continue|continue;
comment|/* {{ not really necessary }} */
block|}
elseif|else
if|if
condition|(
operator|!
name|checkstart
operator|&&
name|hl
operator|->
name|hl_endpos
operator|==
name|opos
condition|)
block|{
name|hl
operator|->
name|hl_endpos
operator|=
name|npos
expr_stmt|;
name|checkstart
operator|=
name|TRUE
expr_stmt|;
name|hl
operator|=
name|hl
operator|->
name|hl_next
expr_stmt|;
continue|continue;
comment|/* {{ necessary }} */
block|}
if|if
condition|(
operator|*
name|line
operator|==
literal|'\0'
condition|)
break|break;
name|opos
operator|++
expr_stmt|;
name|npos
operator|++
expr_stmt|;
name|line
operator|++
expr_stmt|;
while|while
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'\b'
operator|&&
name|line
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
comment|/* 			 * Found a backspace.  The file position moves 			 * forward by 2 relative to the processed line 			 * which was searched in hilite_line. 			 */
name|npos
operator|+=
literal|2
expr_stmt|;
name|line
operator|+=
literal|2
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Make a hilite for each string in a physical line which matches   * the current pattern.  * sp,ep delimit the first match already found.  */
end_comment

begin_function
specifier|static
name|void
name|hilite_line
parameter_list|(
name|linepos
parameter_list|,
name|line
parameter_list|,
name|sp
parameter_list|,
name|ep
parameter_list|)
name|POSITION
name|linepos
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|char
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
block|{
name|char
modifier|*
name|searchp
decl_stmt|;
name|struct
name|hilite
modifier|*
name|hl
decl_stmt|;
name|struct
name|hilite
name|hilites
decl_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
operator|||
name|ep
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * sp and ep delimit the first match in the line. 	 * Mark the corresponding file positions, then 	 * look for further matches and mark them. 	 * {{ This technique, of calling match_pattern on subsequent 	 *    substrings of the line, may mark more than is correct 	 *    if the pattern starts with "^".  This bug is fixed 	 *    for those regex functions that accept a notbol parameter 	 *    (currently POSIX and V8-with-regexec2). }} 	 */
name|searchp
operator|=
name|line
expr_stmt|;
comment|/* 	 * Put the hilites into a temporary list until they're adjusted. 	 */
name|hilites
operator|.
name|hl_first
operator|=
name|NULL
expr_stmt|;
do|do
block|{
if|if
condition|(
name|ep
operator|>
name|sp
condition|)
block|{
comment|/* 			 * Assume that each char position in the "line" 			 * buffer corresponds to one char position in the file. 			 * This is not quite true; we need to adjust later. 			 */
name|hl
operator|=
operator|(
expr|struct
name|hilite
operator|*
operator|)
name|ecalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hilite
argument_list|)
argument_list|)
expr_stmt|;
name|hl
operator|->
name|hl_startpos
operator|=
name|linepos
operator|+
operator|(
name|sp
operator|-
name|line
operator|)
expr_stmt|;
name|hl
operator|->
name|hl_endpos
operator|=
name|linepos
operator|+
operator|(
name|ep
operator|-
name|line
operator|)
expr_stmt|;
name|add_hilite
argument_list|(
operator|&
name|hilites
argument_list|,
name|hl
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If we matched more than zero characters, 		 * move to the first char after the string we matched. 		 * If we matched zero, just move to the next char. 		 */
if|if
condition|(
name|ep
operator|>
name|searchp
condition|)
name|searchp
operator|=
name|ep
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|searchp
operator|!=
literal|'\0'
condition|)
name|searchp
operator|++
expr_stmt|;
else|else
comment|/* end of line */
break|break;
block|}
do|while
condition|(
name|match_pattern
argument_list|(
name|searchp
argument_list|,
operator|&
name|sp
argument_list|,
operator|&
name|ep
argument_list|,
literal|1
argument_list|)
condition|)
do|;
if|if
condition|(
name|bs_mode
operator|==
name|BS_SPECIAL
condition|)
block|{
comment|/* 		 * If there were backspaces in the original line, they 		 * were removed, and hl_startpos/hl_endpos are not correct. 		 * {{ This is very ugly. }} 		 */
name|adj_hilite
argument_list|(
operator|&
name|hilites
argument_list|,
name|linepos
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now put the hilites into the real list. 	 */
while|while
condition|(
operator|(
name|hl
operator|=
name|hilites
operator|.
name|hl_next
operator|)
operator|!=
name|NULL
condition|)
block|{
name|hilites
operator|.
name|hl_next
operator|=
name|hl
operator|->
name|hl_next
expr_stmt|;
name|add_hilite
argument_list|(
operator|&
name|hilite_anchor
argument_list|,
name|hl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Change the caseless-ness of searches.    * Updates the internal search state to reflect a change in the -i flag.  */
end_comment

begin_function
name|public
name|void
name|chg_caseless
parameter_list|()
block|{
if|if
condition|(
operator|!
name|is_ucase_pattern
condition|)
comment|/* 		 * Pattern did not have uppercase. 		 * Just set the search caselessness to the global caselessness. 		 */
name|is_caseless
operator|=
name|caseless
expr_stmt|;
else|else
comment|/* 		 * Pattern did have uppercase. 		 * Discard the pattern; we can't change search caselessness now. 		 */
name|uncompile_pattern
argument_list|()
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|HILITE_SEARCH
end_if

begin_comment
comment|/*  * Find matching text which is currently on screen and highlight it.  */
end_comment

begin_function
specifier|static
name|void
name|hilite_screen
parameter_list|()
block|{
name|struct
name|scrpos
name|scrpos
decl_stmt|;
name|get_scrpos
argument_list|(
operator|&
name|scrpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|scrpos
operator|.
name|pos
operator|==
name|NULL_POSITION
condition|)
return|return;
name|prep_hilite
argument_list|(
name|scrpos
operator|.
name|pos
argument_list|,
name|position
argument_list|(
name|BOTTOM_PLUS_ONE
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|repaint_hilite
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Change highlighting parameters.  */
end_comment

begin_function
name|public
name|void
name|chg_hilite
parameter_list|()
block|{
comment|/* 	 * Erase any highlights currently on screen. 	 */
name|clr_hilite
argument_list|()
expr_stmt|;
name|hide_hilite
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hilite_search
operator|==
name|OPT_ONPLUS
condition|)
comment|/* 		 * Display highlights. 		 */
name|hilite_screen
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Figure out where to start a search.  */
end_comment

begin_function
specifier|static
name|POSITION
name|search_pos
parameter_list|(
name|search_type
parameter_list|)
name|int
name|search_type
decl_stmt|;
block|{
name|POSITION
name|pos
decl_stmt|;
name|int
name|linenum
decl_stmt|;
if|if
condition|(
name|empty_screen
argument_list|()
condition|)
block|{
comment|/* 		 * Start at the beginning (or end) of the file. 		 * The empty_screen() case is mainly for  		 * command line initiated searches; 		 * for example, "+/xyz" on the command line. 		 * Also for multi-file (SRCH_PAST_EOF) searches. 		 */
if|if
condition|(
name|search_type
operator|&
name|SRCH_FORW
condition|)
block|{
return|return
operator|(
name|ch_zero
argument_list|()
operator|)
return|;
block|}
else|else
block|{
name|pos
operator|=
name|ch_length
argument_list|()
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|NULL_POSITION
condition|)
block|{
operator|(
name|void
operator|)
name|ch_end_seek
argument_list|()
expr_stmt|;
name|pos
operator|=
name|ch_length
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|pos
operator|)
return|;
block|}
block|}
if|if
condition|(
name|how_search
condition|)
block|{
comment|/* 		 * Search does not include current screen. 		 */
if|if
condition|(
name|search_type
operator|&
name|SRCH_FORW
condition|)
name|linenum
operator|=
name|BOTTOM_PLUS_ONE
expr_stmt|;
else|else
name|linenum
operator|=
name|TOP
expr_stmt|;
name|pos
operator|=
name|position
argument_list|(
name|linenum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Search includes current screen. 		 * It starts at the jump target (if searching backwards), 		 * or at the jump target plus one (if forwards). 		 */
name|linenum
operator|=
name|adjsline
argument_list|(
name|jump_sline
argument_list|)
expr_stmt|;
name|pos
operator|=
name|position
argument_list|(
name|linenum
argument_list|)
expr_stmt|;
if|if
condition|(
name|search_type
operator|&
name|SRCH_FORW
condition|)
block|{
name|pos
operator|=
name|forw_raw_line
argument_list|(
name|pos
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|pos
operator|==
name|NULL_POSITION
condition|)
block|{
if|if
condition|(
operator|++
name|linenum
operator|>=
name|sc_height
condition|)
break|break;
name|pos
operator|=
name|position
argument_list|(
name|linenum
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|pos
operator|==
name|NULL_POSITION
condition|)
block|{
if|if
condition|(
operator|--
name|linenum
operator|<
literal|0
condition|)
break|break;
name|pos
operator|=
name|position
argument_list|(
name|linenum
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|pos
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Search a subset of the file, specified by start/end position.  */
end_comment

begin_function
specifier|static
name|int
name|search_range
parameter_list|(
name|pos
parameter_list|,
name|endpos
parameter_list|,
name|search_type
parameter_list|,
name|matches
parameter_list|,
name|maxlines
parameter_list|,
name|plinepos
parameter_list|,
name|pendpos
parameter_list|)
name|POSITION
name|pos
decl_stmt|;
name|POSITION
name|endpos
decl_stmt|;
name|int
name|search_type
decl_stmt|;
name|int
name|matches
decl_stmt|;
name|int
name|maxlines
decl_stmt|;
name|POSITION
modifier|*
name|plinepos
decl_stmt|;
name|POSITION
modifier|*
name|pendpos
decl_stmt|;
block|{
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|linenum
decl_stmt|;
name|char
modifier|*
name|sp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|int
name|line_match
decl_stmt|;
name|POSITION
name|linepos
decl_stmt|,
name|oldpos
decl_stmt|;
name|linenum
operator|=
name|find_linenum
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|oldpos
operator|=
name|pos
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Get lines until we find a matching one or until 		 * we hit end-of-file (or beginning-of-file if we're  		 * going backwards), or until we hit the end position. 		 */
if|if
condition|(
name|ABORT_SIGS
argument_list|()
condition|)
block|{
comment|/* 			 * A signal aborts the search. 			 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|endpos
operator|!=
name|NULL_POSITION
operator|&&
name|pos
operator|>=
name|endpos
operator|)
operator|||
name|maxlines
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Reached end position without a match. 			 */
if|if
condition|(
name|pendpos
operator|!=
name|NULL
condition|)
operator|*
name|pendpos
operator|=
name|pos
expr_stmt|;
return|return
operator|(
name|matches
operator|)
return|;
block|}
if|if
condition|(
name|maxlines
operator|>
literal|0
condition|)
name|maxlines
operator|--
expr_stmt|;
if|if
condition|(
name|search_type
operator|&
name|SRCH_FORW
condition|)
block|{
comment|/* 			 * Read the next line, and save the  			 * starting position of that line in linepos. 			 */
name|linepos
operator|=
name|pos
expr_stmt|;
name|pos
operator|=
name|forw_raw_line
argument_list|(
name|pos
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|linenum
operator|!=
literal|0
condition|)
name|linenum
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Read the previous line and save the 			 * starting position of that line in linepos. 			 */
name|pos
operator|=
name|back_raw_line
argument_list|(
name|pos
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
name|linepos
operator|=
name|pos
expr_stmt|;
if|if
condition|(
name|linenum
operator|!=
literal|0
condition|)
name|linenum
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|==
name|NULL_POSITION
condition|)
block|{
comment|/* 			 * Reached EOF/BOF without a match. 			 */
if|if
condition|(
name|pendpos
operator|!=
name|NULL
condition|)
operator|*
name|pendpos
operator|=
name|oldpos
expr_stmt|;
return|return
operator|(
name|matches
operator|)
return|;
block|}
comment|/* 		 * If we're using line numbers, we might as well 		 * remember the information we have now (the position 		 * and line number of the current line). 		 * Don't do it for every line because it slows down 		 * the search.  Remember the line number only if 		 * we're "far" from the last place we remembered it. 		 */
if|if
condition|(
name|linenums
operator|&&
name|abs
argument_list|(
call|(
name|int
call|)
argument_list|(
name|pos
operator|-
name|oldpos
argument_list|)
argument_list|)
operator|>
literal|1024
condition|)
name|add_lnum
argument_list|(
name|linenum
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|oldpos
operator|=
name|pos
expr_stmt|;
comment|/* 		 * If it's a caseless search, convert the line to lowercase. 		 * If we're doing backspace processing, delete backspaces. 		 */
if|if
condition|(
name|is_caseless
operator|||
name|bs_mode
operator|==
name|BS_SPECIAL
condition|)
block|{
name|int
name|ops
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|is_caseless
condition|)
name|ops
operator||=
name|CVT_TO_LC
expr_stmt|;
if|if
condition|(
name|bs_mode
operator|==
name|BS_SPECIAL
condition|)
name|ops
operator||=
name|CVT_BS
expr_stmt|;
if|if
condition|(
name|bs_mode
operator|!=
name|BS_CONTROL
condition|)
name|ops
operator||=
name|CVT_CRLF
expr_stmt|;
name|cvt_text
argument_list|(
name|line
argument_list|,
name|line
argument_list|,
name|ops
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bs_mode
operator|!=
name|BS_CONTROL
condition|)
block|{
name|cvt_text
argument_list|(
name|line
argument_list|,
name|line
argument_list|,
name|CVT_CRLF
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Test the next line to see if we have a match. 		 * We are successful if we either want a match and got one, 		 * or if we want a non-match and got one. 		 */
name|line_match
operator|=
name|match_pattern
argument_list|(
name|line
argument_list|,
operator|&
name|sp
argument_list|,
operator|&
name|ep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|line_match
operator|=
operator|(
operator|!
operator|(
name|search_type
operator|&
name|SRCH_NO_MATCH
operator|)
operator|&&
name|line_match
operator|)
operator|||
operator|(
operator|(
name|search_type
operator|&
name|SRCH_NO_MATCH
operator|)
operator|&&
operator|!
name|line_match
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|line_match
condition|)
continue|continue;
comment|/* 		 * Got a match. 		 */
if|if
condition|(
name|search_type
operator|&
name|SRCH_FIND_ALL
condition|)
block|{
if|#
directive|if
name|HILITE_SEARCH
comment|/* 			 * We are supposed to find all matches in the range. 			 * Just add the matches in this line to the  			 * hilite list and keep searching. 			 */
if|if
condition|(
name|line_match
condition|)
name|hilite_line
argument_list|(
name|linepos
argument_list|,
name|line
argument_list|,
name|sp
argument_list|,
name|ep
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|--
name|matches
operator|<=
literal|0
condition|)
block|{
comment|/* 			 * Found the one match we're looking for. 			 * Return it. 			 */
if|#
directive|if
name|HILITE_SEARCH
if|if
condition|(
name|hilite_search
operator|==
literal|1
condition|)
block|{
comment|/* 				 * Clear the hilite list and add only 				 * the matches in this one line. 				 */
name|clr_hilite
argument_list|()
expr_stmt|;
if|if
condition|(
name|line_match
condition|)
name|hilite_line
argument_list|(
name|linepos
argument_list|,
name|line
argument_list|,
name|sp
argument_list|,
name|ep
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|plinepos
operator|!=
name|NULL
condition|)
operator|*
name|plinepos
operator|=
name|linepos
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Search for the n-th occurrence of a specified pattern,   * either forward or backward.  * Return the number of matches not yet found in this file  * (that is, n minus the number of matches found).  * Return -1 if the search should be aborted.  * Caller may continue the search in another file   * if less than n matches are found in this file.  */
end_comment

begin_function
name|public
name|int
name|search
parameter_list|(
name|search_type
parameter_list|,
name|pattern
parameter_list|,
name|n
parameter_list|)
name|int
name|search_type
decl_stmt|;
name|char
modifier|*
name|pattern
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|POSITION
name|pos
decl_stmt|;
name|int
name|ucase
decl_stmt|;
if|if
condition|(
name|pattern
operator|==
name|NULL
operator|||
operator|*
name|pattern
operator|==
literal|'\0'
condition|)
block|{
comment|/* 		 * A null pattern means use the previously compiled pattern. 		 */
if|if
condition|(
operator|!
name|prev_pattern
argument_list|()
condition|)
block|{
name|error
argument_list|(
literal|"No previous regular expression"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|search_type
operator|&
name|SRCH_NO_REGEX
operator|)
operator|!=
operator|(
name|last_search_type
operator|&
name|SRCH_NO_REGEX
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"Please re-enter search pattern"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|#
directive|if
name|HILITE_SEARCH
if|if
condition|(
name|hilite_search
operator|==
name|OPT_ON
condition|)
block|{
comment|/* 			 * Erase the highlights currently on screen. 			 * If the search fails, we'll redisplay them later. 			 */
name|repaint_hilite
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hilite_search
operator|==
name|OPT_ONPLUS
operator|&&
name|hide_hilite
condition|)
block|{
comment|/* 			 * Highlight any matches currently on screen, 			 * before we actually start the search. 			 */
name|hide_hilite
operator|=
literal|0
expr_stmt|;
name|hilite_screen
argument_list|()
expr_stmt|;
block|}
name|hide_hilite
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* 		 * Compile the pattern. 		 */
name|ucase
operator|=
name|is_ucase
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|caseless
operator|==
name|OPT_ONPLUS
condition|)
name|cvt_text
argument_list|(
name|pattern
argument_list|,
name|pattern
argument_list|,
name|CVT_TO_LC
argument_list|)
expr_stmt|;
if|if
condition|(
name|compile_pattern
argument_list|(
name|pattern
argument_list|,
name|search_type
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 		 * Ignore case if -I is set OR 		 * -i is set AND the pattern is all lowercase. 		 */
name|is_ucase_pattern
operator|=
name|ucase
expr_stmt|;
if|if
condition|(
name|is_ucase_pattern
operator|&&
name|caseless
operator|!=
name|OPT_ONPLUS
condition|)
name|is_caseless
operator|=
literal|0
expr_stmt|;
else|else
name|is_caseless
operator|=
name|caseless
expr_stmt|;
if|#
directive|if
name|HILITE_SEARCH
if|if
condition|(
name|hilite_search
condition|)
block|{
comment|/* 			 * Erase the highlights currently on screen. 			 * Also permanently delete them from the hilite list. 			 */
name|repaint_hilite
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hide_hilite
operator|=
literal|0
expr_stmt|;
name|clr_hilite
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|hilite_search
operator|==
name|OPT_ONPLUS
condition|)
block|{
comment|/* 			 * Highlight any matches currently on screen, 			 * before we actually start the search. 			 */
name|hilite_screen
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* 	 * Figure out where to start the search. 	 */
name|pos
operator|=
name|search_pos
argument_list|(
name|search_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|NULL_POSITION
condition|)
block|{
comment|/* 		 * Can't find anyplace to start searching from. 		 */
if|if
condition|(
name|search_type
operator|&
name|SRCH_PAST_EOF
condition|)
return|return
operator|(
name|n
operator|)
return|;
comment|/* repaint(); -- why was this here? */
name|error
argument_list|(
literal|"Nothing to search"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|n
operator|=
name|search_range
argument_list|(
name|pos
argument_list|,
name|NULL_POSITION
argument_list|,
name|search_type
argument_list|,
name|n
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pos
argument_list|,
operator|(
name|POSITION
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Search was unsuccessful. 		 */
if|#
directive|if
name|HILITE_SEARCH
if|if
condition|(
name|hilite_search
operator|==
name|OPT_ON
operator|&&
name|n
operator|>
literal|0
condition|)
comment|/* 			 * Redisplay old hilites. 			 */
name|repaint_hilite
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|n
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|search_type
operator|&
name|SRCH_NO_MOVE
operator|)
condition|)
block|{
comment|/* 		 * Go to the matching line. 		 */
name|jump_loc
argument_list|(
name|pos
argument_list|,
name|jump_sline
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|HILITE_SEARCH
if|if
condition|(
name|hilite_search
operator|==
name|OPT_ON
condition|)
comment|/* 		 * Display new hilites in the matching line. 		 */
name|repaint_hilite
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|HILITE_SEARCH
end_if

begin_comment
comment|/*  * Prepare hilites in a given range of the file.  *  * The pair (prep_startpos,prep_endpos) delimits a contiguous region  * of the file that has been "prepared"; that is, scanned for matches for  * the current search pattern, and hilites have been created for such matches.  * If prep_startpos == NULL_POSITION, the prep region is empty.  * If prep_endpos == NULL_POSITION, the prep region extends to EOF.  * prep_hilite asks that the range (spos,epos) be covered by the prep region.  */
end_comment

begin_function
name|public
name|void
name|prep_hilite
parameter_list|(
name|spos
parameter_list|,
name|epos
parameter_list|,
name|maxlines
parameter_list|)
name|POSITION
name|spos
decl_stmt|;
name|POSITION
name|epos
decl_stmt|;
name|int
name|maxlines
decl_stmt|;
block|{
name|POSITION
name|nprep_startpos
init|=
name|prep_startpos
decl_stmt|;
name|POSITION
name|nprep_endpos
init|=
name|prep_endpos
decl_stmt|;
name|POSITION
name|new_epos
decl_stmt|;
name|POSITION
name|max_epos
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*  * Search beyond where we're asked to search, so the prep region covers  * more than we need.  Do one big search instead of a bunch of small ones.  */
define|#
directive|define
name|SEARCH_MORE
value|(3*size_linebuf)
if|if
condition|(
operator|!
name|prev_pattern
argument_list|()
condition|)
return|return;
comment|/* 	 * If we're limited to a max number of lines, figure out the 	 * file position we should stop at. 	 */
if|if
condition|(
name|maxlines
operator|<
literal|0
condition|)
name|max_epos
operator|=
name|NULL_POSITION
expr_stmt|;
else|else
block|{
name|max_epos
operator|=
name|spos
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxlines
condition|;
name|i
operator|++
control|)
name|max_epos
operator|=
name|forw_raw_line
argument_list|(
name|max_epos
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Find two ranges: 	 * The range that we need to search (spos,epos); and the range that 	 * the "prep" region will then cover (nprep_startpos,nprep_endpos). 	 */
if|if
condition|(
name|prep_startpos
operator|==
name|NULL_POSITION
operator|||
operator|(
name|epos
operator|!=
name|NULL_POSITION
operator|&&
name|epos
operator|<
name|prep_startpos
operator|)
operator|||
name|spos
operator|>
name|prep_endpos
condition|)
block|{
comment|/* 		 * New range is not contiguous with old prep region. 		 * Discard the old prep region and start a new one. 		 */
name|clr_hilite
argument_list|()
expr_stmt|;
if|if
condition|(
name|epos
operator|!=
name|NULL_POSITION
condition|)
name|epos
operator|+=
name|SEARCH_MORE
expr_stmt|;
name|nprep_startpos
operator|=
name|spos
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * New range partially or completely overlaps old prep region. 		 */
if|if
condition|(
name|epos
operator|==
name|NULL_POSITION
condition|)
block|{
comment|/* 			 * New range goes to end of file. 			 */
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|epos
operator|>
name|prep_endpos
condition|)
block|{
comment|/* 			 * New range ends after old prep region. 			 * Extend prep region to end at end of new range. 			 */
name|epos
operator|+=
name|SEARCH_MORE
expr_stmt|;
block|}
else|else
comment|/* (epos<= prep_endpos) */
block|{
comment|/* 			 * New range ends within old prep region. 			 * Truncate search to end at start of old prep region. 			 */
name|epos
operator|=
name|prep_startpos
expr_stmt|;
block|}
if|if
condition|(
name|spos
operator|<
name|prep_startpos
condition|)
block|{
comment|/* 			 * New range starts before old prep region. 			 * Extend old prep region backwards to start at  			 * start of new range. 			 */
if|if
condition|(
name|spos
operator|<
name|SEARCH_MORE
condition|)
name|spos
operator|=
literal|0
expr_stmt|;
else|else
name|spos
operator|-=
name|SEARCH_MORE
expr_stmt|;
name|nprep_startpos
operator|=
name|spos
expr_stmt|;
block|}
else|else
comment|/* (spos>= prep_startpos) */
block|{
comment|/* 			 * New range starts within or after old prep region. 			 * Trim search to start at end of old prep region. 			 */
name|spos
operator|=
name|prep_endpos
expr_stmt|;
block|}
block|}
if|if
condition|(
name|epos
operator|!=
name|NULL_POSITION
operator|&&
name|max_epos
operator|!=
name|NULL_POSITION
operator|&&
name|epos
operator|>
name|max_epos
condition|)
comment|/* 		 * Don't go past the max position we're allowed. 		 */
name|epos
operator|=
name|max_epos
expr_stmt|;
if|if
condition|(
name|epos
operator|==
name|NULL_POSITION
operator|||
name|epos
operator|>
name|spos
condition|)
block|{
name|result
operator|=
name|search_range
argument_list|(
name|spos
argument_list|,
name|epos
argument_list|,
name|SRCH_FORW
operator||
name|SRCH_FIND_ALL
argument_list|,
literal|0
argument_list|,
name|maxlines
argument_list|,
operator|(
name|POSITION
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|new_epos
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|prep_endpos
operator|==
name|NULL_POSITION
operator|||
name|new_epos
operator|>
name|prep_endpos
condition|)
name|nprep_endpos
operator|=
name|new_epos
expr_stmt|;
block|}
name|prep_startpos
operator|=
name|nprep_startpos
expr_stmt|;
name|prep_endpos
operator|=
name|nprep_endpos
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Simple pattern matching function.  * It supports no metacharacters like *, etc.  */
end_comment

begin_function
specifier|static
name|int
name|match
parameter_list|(
name|pattern
parameter_list|,
name|buf
parameter_list|,
name|pfound
parameter_list|,
name|pend
parameter_list|)
name|char
modifier|*
name|pattern
decl_stmt|,
decl|*
name|buf
decl_stmt|;
end_function

begin_decl_stmt
name|char
modifier|*
modifier|*
name|pfound
decl_stmt|,
modifier|*
modifier|*
name|pend
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|pp
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
for|for
control|(
init|;
operator|*
name|buf
operator|!=
literal|'\0'
condition|;
name|buf
operator|++
control|)
block|{
for|for
control|(
name|pp
operator|=
name|pattern
operator|,
name|lp
operator|=
name|buf
init|;
operator|*
name|pp
operator|==
operator|*
name|lp
condition|;
name|pp
operator|++
operator|,
name|lp
operator|++
control|)
if|if
condition|(
operator|*
name|pp
operator|==
literal|'\0'
operator|||
operator|*
name|lp
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
operator|*
name|pp
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|pfound
operator|!=
name|NULL
condition|)
operator|*
name|pfound
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|pend
operator|!=
name|NULL
condition|)
operator|*
name|pend
operator|=
name|lp
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_if
if|#
directive|if
name|HAVE_V8_REGCOMP
end_if

begin_comment
comment|/*  * This function is called by the V8 regcomp to report   * errors in regular expressions.  */
end_comment

begin_function
name|void
name|regerror
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|PARG
name|parg
decl_stmt|;
name|parg
operator|.
name|p_string
operator|=
name|s
expr_stmt|;
name|error
argument_list|(
literal|"%s"
argument_list|,
operator|&
name|parg
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

