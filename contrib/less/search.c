begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1984-2015  Mark Nudelman  *  * You may distribute under the terms of either the GNU General Public  * License or the Less License, as specified in the README file.  *  * For more information, see the README file.  */
end_comment

begin_comment
comment|/*  * Routines to search a file for a pattern.  */
end_comment

begin_include
include|#
directive|include
file|"less.h"
end_include

begin_include
include|#
directive|include
file|"pattern.h"
end_include

begin_include
include|#
directive|include
file|"position.h"
end_include

begin_include
include|#
directive|include
file|"charset.h"
end_include

begin_define
define|#
directive|define
name|MINPOS
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)< (b)) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|MAXPOS
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)> (b)) ? (a) : (b))
end_define

begin_decl_stmt
specifier|extern
name|int
name|sigs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|how_search
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|caseless
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|linenums
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sc_height
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|jump_sline
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|bs_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ctldisp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|status_col
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
modifier|*
name|constant
name|ml_search
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|POSITION
name|start_attnpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|POSITION
name|end_attnpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|utf_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|screen_trashed
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|HILITE_SEARCH
end_if

begin_decl_stmt
specifier|extern
name|int
name|hilite_search
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|size_linebuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|squished
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|can_goto_line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hide_hilite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|POSITION
name|prep_startpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|POSITION
name|prep_endpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_caseless
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_ucase_pattern
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Structures for maintaining a set of ranges for hilites and filtered-out  * lines. Each range is stored as a node within a red-black tree, and we  * try to extend existing ranges (without creating overlaps) rather than  * create new nodes if possible. We remember the last node found by a  * search for constant-time lookup if the next search is near enough to  * the previous. To aid that, we overlay a secondary doubly-linked list  * on top of the red-black tree so we can find the preceding/succeeding  * nodes also in constant time.  *  * Each node is allocated from a series of pools, each pool double the size  * of the previous (for amortised constant time allocation). Since our only  * tree operations are clear and node insertion, not node removal, we don't  * need to maintain a usage bitmap or freelist and can just return nodes  * from the pool in-order until capacity is reached.  */
end_comment

begin_struct
struct|struct
name|hilite
block|{
name|POSITION
name|hl_startpos
decl_stmt|;
name|POSITION
name|hl_endpos
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|hilite_node
block|{
name|struct
name|hilite_node
modifier|*
name|parent
decl_stmt|;
name|struct
name|hilite_node
modifier|*
name|left
decl_stmt|;
name|struct
name|hilite_node
modifier|*
name|right
decl_stmt|;
name|struct
name|hilite_node
modifier|*
name|prev
decl_stmt|;
name|struct
name|hilite_node
modifier|*
name|next
decl_stmt|;
name|int
name|red
decl_stmt|;
name|struct
name|hilite
name|r
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|hilite_storage
block|{
name|int
name|capacity
decl_stmt|;
name|int
name|used
decl_stmt|;
name|struct
name|hilite_storage
modifier|*
name|next
decl_stmt|;
name|struct
name|hilite_node
modifier|*
name|nodes
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|hilite_tree
block|{
name|struct
name|hilite_storage
modifier|*
name|first
decl_stmt|;
name|struct
name|hilite_storage
modifier|*
name|current
decl_stmt|;
name|struct
name|hilite_node
modifier|*
name|root
decl_stmt|;
name|struct
name|hilite_node
modifier|*
name|lookaside
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|HILITE_INITIALIZER
parameter_list|()
value|{ NULL, NULL, NULL, NULL }
end_define

begin_define
define|#
directive|define
name|HILITE_LOOKASIDE_STEPS
value|2
end_define

begin_decl_stmt
specifier|static
name|struct
name|hilite_tree
name|hilite_anchor
init|=
name|HILITE_INITIALIZER
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hilite_tree
name|filter_anchor
init|=
name|HILITE_INITIALIZER
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * These are the static variables that represent the "remembered"  * search pattern and filter pattern.  */
end_comment

begin_struct
struct|struct
name|pattern_info
block|{
name|DEFINE_PATTERN
argument_list|(
name|compiled
argument_list|)
expr_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
name|int
name|search_type
decl_stmt|;
block|}
struct|;
end_struct

begin_if
if|#
directive|if
name|NO_REGEX
end_if

begin_define
define|#
directive|define
name|info_compiled
parameter_list|(
name|info
parameter_list|)
value|((void*)0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|info_compiled
parameter_list|(
name|info
parameter_list|)
value|((info)->compiled)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|pattern_info
name|search_info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pattern_info
name|filter_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Are there any uppercase letters in this string?  */
end_comment

begin_function
specifier|static
name|int
name|is_ucase
parameter_list|(
name|constant
name|char
modifier|*
name|str
parameter_list|)
block|{
name|constant
name|char
modifier|*
name|str_end
init|=
name|str
operator|+
name|strlen
argument_list|(
name|str
argument_list|)
decl_stmt|;
name|LWCHAR
name|ch
decl_stmt|;
while|while
condition|(
name|str
operator|<
name|str_end
condition|)
block|{
name|ch
operator|=
name|step_char
argument_list|(
operator|&
name|str
argument_list|,
operator|+
literal|1
argument_list|,
name|str_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_UPPER
argument_list|(
name|ch
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compile and save a search pattern.  */
end_comment

begin_function
specifier|static
name|int
name|set_pattern
parameter_list|(
name|struct
name|pattern_info
modifier|*
name|info
parameter_list|,
name|char
modifier|*
name|pattern
parameter_list|,
name|int
name|search_type
parameter_list|)
block|{
if|#
directive|if
operator|!
name|NO_REGEX
if|if
condition|(
name|pattern
operator|==
name|NULL
condition|)
name|CLEAR_PATTERN
argument_list|(
name|info
operator|->
name|compiled
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|compile_pattern
argument_list|(
name|pattern
argument_list|,
name|search_type
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|info
operator|->
name|compiled
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
comment|/* Pattern compiled successfully; save the text too. */
if|if
condition|(
name|info
operator|->
name|text
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|info
operator|->
name|text
argument_list|)
expr_stmt|;
name|info
operator|->
name|text
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pattern
operator|!=
name|NULL
condition|)
block|{
name|info
operator|->
name|text
operator|=
operator|(
name|char
operator|*
operator|)
name|ecalloc
argument_list|(
literal|1
argument_list|,
name|strlen
argument_list|(
name|pattern
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|info
operator|->
name|text
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
block|}
name|info
operator|->
name|search_type
operator|=
name|search_type
expr_stmt|;
comment|/* 	 * Ignore case if -I is set OR 	 * -i is set AND the pattern is all lowercase. 	 */
name|is_ucase_pattern
operator|=
name|is_ucase
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_ucase_pattern
operator|&&
name|caseless
operator|!=
name|OPT_ONPLUS
condition|)
name|is_caseless
operator|=
literal|0
expr_stmt|;
else|else
name|is_caseless
operator|=
name|caseless
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Discard a saved pattern.  */
end_comment

begin_function
specifier|static
name|void
name|clear_pattern
parameter_list|(
name|struct
name|pattern_info
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
name|info
operator|->
name|text
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|info
operator|->
name|text
argument_list|)
expr_stmt|;
name|info
operator|->
name|text
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
operator|!
name|NO_REGEX
name|uncompile_pattern
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|info
operator|->
name|compiled
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Initialize saved pattern to nothing.  */
end_comment

begin_function
specifier|static
name|void
name|init_pattern
parameter_list|(
name|struct
name|pattern_info
modifier|*
name|info
parameter_list|)
block|{
name|CLEAR_PATTERN
argument_list|(
name|info
operator|->
name|compiled
argument_list|)
expr_stmt|;
name|info
operator|->
name|text
operator|=
name|NULL
expr_stmt|;
name|info
operator|->
name|search_type
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize search variables.  */
end_comment

begin_function
name|public
name|void
name|init_search
parameter_list|(
name|void
parameter_list|)
block|{
name|init_pattern
argument_list|(
operator|&
name|search_info
argument_list|)
expr_stmt|;
name|init_pattern
argument_list|(
operator|&
name|filter_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Determine which text conversions to perform before pattern matching.  */
end_comment

begin_function
specifier|static
name|int
name|get_cvt_ops
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ops
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|is_caseless
operator|||
name|bs_mode
operator|==
name|BS_SPECIAL
condition|)
block|{
if|if
condition|(
name|is_caseless
condition|)
name|ops
operator||=
name|CVT_TO_LC
expr_stmt|;
if|if
condition|(
name|bs_mode
operator|==
name|BS_SPECIAL
condition|)
name|ops
operator||=
name|CVT_BS
expr_stmt|;
if|if
condition|(
name|bs_mode
operator|!=
name|BS_CONTROL
condition|)
name|ops
operator||=
name|CVT_CRLF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bs_mode
operator|!=
name|BS_CONTROL
condition|)
block|{
name|ops
operator||=
name|CVT_CRLF
expr_stmt|;
block|}
if|if
condition|(
name|ctldisp
operator|==
name|OPT_ONPLUS
condition|)
name|ops
operator||=
name|CVT_ANSI
expr_stmt|;
return|return
operator|(
name|ops
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Is there a previous (remembered) search pattern?  */
end_comment

begin_function
specifier|static
name|int
name|prev_pattern
parameter_list|(
name|struct
name|pattern_info
modifier|*
name|info
parameter_list|)
block|{
if|#
directive|if
operator|!
name|NO_REGEX
if|if
condition|(
operator|(
name|info
operator|->
name|search_type
operator|&
name|SRCH_NO_REGEX
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|!
name|is_null_pattern
argument_list|(
name|info
operator|->
name|compiled
argument_list|)
operator|)
return|;
endif|#
directive|endif
return|return
operator|(
name|info
operator|->
name|text
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|HILITE_SEARCH
end_if

begin_comment
comment|/*  * Repaint the hilites currently displayed on the screen.  * Repaint each line which contains highlighted text.  * If on==0, force all hilites off.  */
end_comment

begin_function
name|public
name|void
name|repaint_hilite
parameter_list|(
name|int
name|on
parameter_list|)
block|{
name|int
name|slinenum
decl_stmt|;
name|POSITION
name|pos
decl_stmt|;
name|int
name|save_hide_hilite
decl_stmt|;
if|if
condition|(
name|squished
condition|)
name|repaint
argument_list|()
expr_stmt|;
name|save_hide_hilite
operator|=
name|hide_hilite
expr_stmt|;
if|if
condition|(
operator|!
name|on
condition|)
block|{
if|if
condition|(
name|hide_hilite
condition|)
return|return;
name|hide_hilite
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|can_goto_line
condition|)
block|{
name|repaint
argument_list|()
expr_stmt|;
name|hide_hilite
operator|=
name|save_hide_hilite
expr_stmt|;
return|return;
block|}
for|for
control|(
name|slinenum
operator|=
name|TOP
init|;
name|slinenum
operator|<
name|TOP
operator|+
name|sc_height
operator|-
literal|1
condition|;
name|slinenum
operator|++
control|)
block|{
name|pos
operator|=
name|position
argument_list|(
name|slinenum
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|NULL_POSITION
condition|)
continue|continue;
operator|(
name|void
operator|)
name|forw_line
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|goto_line
argument_list|(
name|slinenum
argument_list|)
expr_stmt|;
name|put_line
argument_list|()
expr_stmt|;
block|}
name|lower_left
argument_list|()
expr_stmt|;
name|hide_hilite
operator|=
name|save_hide_hilite
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Clear the attn hilite.  */
end_comment

begin_function
name|public
name|void
name|clear_attn
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|slinenum
decl_stmt|;
name|POSITION
name|old_start_attnpos
decl_stmt|;
name|POSITION
name|old_end_attnpos
decl_stmt|;
name|POSITION
name|pos
decl_stmt|;
name|POSITION
name|epos
decl_stmt|;
name|int
name|moved
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|start_attnpos
operator|==
name|NULL_POSITION
condition|)
return|return;
name|old_start_attnpos
operator|=
name|start_attnpos
expr_stmt|;
name|old_end_attnpos
operator|=
name|end_attnpos
expr_stmt|;
name|start_attnpos
operator|=
name|end_attnpos
operator|=
name|NULL_POSITION
expr_stmt|;
if|if
condition|(
operator|!
name|can_goto_line
condition|)
block|{
name|repaint
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|squished
condition|)
name|repaint
argument_list|()
expr_stmt|;
for|for
control|(
name|slinenum
operator|=
name|TOP
init|;
name|slinenum
operator|<
name|TOP
operator|+
name|sc_height
operator|-
literal|1
condition|;
name|slinenum
operator|++
control|)
block|{
name|pos
operator|=
name|position
argument_list|(
name|slinenum
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|NULL_POSITION
condition|)
continue|continue;
name|epos
operator|=
name|position
argument_list|(
name|slinenum
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|<
name|old_end_attnpos
operator|&&
operator|(
name|epos
operator|==
name|NULL_POSITION
operator|||
name|epos
operator|>
name|old_start_attnpos
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|forw_line
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|goto_line
argument_list|(
name|slinenum
argument_list|)
expr_stmt|;
name|put_line
argument_list|()
expr_stmt|;
name|moved
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|moved
condition|)
name|lower_left
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Hide search string highlighting.  */
end_comment

begin_function
name|public
name|void
name|undo_search
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|prev_pattern
argument_list|(
operator|&
name|search_info
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"No previous regular expression"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|HILITE_SEARCH
name|hide_hilite
operator|=
operator|!
name|hide_hilite
expr_stmt|;
name|repaint_hilite
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
name|HILITE_SEARCH
end_if

begin_comment
comment|/*  * Clear the hilite list.  */
end_comment

begin_function
name|public
name|void
name|clr_hlist
parameter_list|(
name|struct
name|hilite_tree
modifier|*
name|anchor
parameter_list|)
block|{
name|struct
name|hilite_storage
modifier|*
name|hls
decl_stmt|;
name|struct
name|hilite_storage
modifier|*
name|nexthls
decl_stmt|;
for|for
control|(
name|hls
operator|=
name|anchor
operator|->
name|first
init|;
name|hls
operator|!=
name|NULL
condition|;
name|hls
operator|=
name|nexthls
control|)
block|{
name|nexthls
operator|=
name|hls
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|hls
operator|->
name|nodes
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|hls
argument_list|)
expr_stmt|;
block|}
name|anchor
operator|->
name|first
operator|=
name|NULL
expr_stmt|;
name|anchor
operator|->
name|current
operator|=
name|NULL
expr_stmt|;
name|anchor
operator|->
name|root
operator|=
name|NULL
expr_stmt|;
name|anchor
operator|->
name|lookaside
operator|=
name|NULL
expr_stmt|;
name|prep_startpos
operator|=
name|prep_endpos
operator|=
name|NULL_POSITION
expr_stmt|;
block|}
end_function

begin_function
name|public
name|void
name|clr_hilite
parameter_list|(
name|void
parameter_list|)
block|{
name|clr_hlist
argument_list|(
operator|&
name|hilite_anchor
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|public
name|void
name|clr_filter
parameter_list|(
name|void
parameter_list|)
block|{
name|clr_hlist
argument_list|(
operator|&
name|filter_anchor
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|hilite_node
modifier|*
name|hlist_last
parameter_list|(
name|anchor
parameter_list|)
name|struct
name|hilite_tree
modifier|*
name|anchor
decl_stmt|;
block|{
name|struct
name|hilite_node
modifier|*
name|n
init|=
name|anchor
operator|->
name|root
decl_stmt|;
while|while
condition|(
name|n
operator|!=
name|NULL
operator|&&
name|n
operator|->
name|right
operator|!=
name|NULL
condition|)
name|n
operator|=
name|n
operator|->
name|right
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_function
name|struct
name|hilite_node
modifier|*
name|hlist_next
parameter_list|(
name|n
parameter_list|)
name|struct
name|hilite_node
modifier|*
name|n
decl_stmt|;
block|{
return|return
name|n
operator|->
name|next
return|;
block|}
end_function

begin_function
name|struct
name|hilite_node
modifier|*
name|hlist_prev
parameter_list|(
name|n
parameter_list|)
name|struct
name|hilite_node
modifier|*
name|n
decl_stmt|;
block|{
return|return
name|n
operator|->
name|prev
return|;
block|}
end_function

begin_comment
comment|/*  * Find the node covering pos, or the node after it if no node covers it,  * or return NULL if pos is after the last range. Remember the found node,  * to speed up subsequent searches for the same or similar positions (if  * we return NULL, remember the last node.)  */
end_comment

begin_function
name|struct
name|hilite_node
modifier|*
name|hlist_find
parameter_list|(
name|anchor
parameter_list|,
name|pos
parameter_list|)
name|struct
name|hilite_tree
modifier|*
name|anchor
decl_stmt|;
name|POSITION
name|pos
decl_stmt|;
block|{
name|struct
name|hilite_node
modifier|*
name|n
decl_stmt|,
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|anchor
operator|->
name|lookaside
condition|)
block|{
name|int
name|steps
init|=
literal|0
decl_stmt|;
name|int
name|hit
init|=
literal|0
decl_stmt|;
name|n
operator|=
name|anchor
operator|->
name|lookaside
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|pos
operator|<
name|n
operator|->
name|r
operator|.
name|hl_endpos
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|prev
operator|==
name|NULL
operator|||
name|pos
operator|>=
name|n
operator|->
name|prev
operator|->
name|r
operator|.
name|hl_endpos
condition|)
block|{
name|hit
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|n
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
name|n
operator|=
name|NULL
expr_stmt|;
name|hit
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* 			 * If we don't find the right node within a small 			 * distance, don't keep doing a linear search! 			 */
if|if
condition|(
name|steps
operator|>=
name|HILITE_LOOKASIDE_STEPS
condition|)
break|break;
name|steps
operator|++
expr_stmt|;
if|if
condition|(
name|pos
operator|<
name|n
operator|->
name|r
operator|.
name|hl_endpos
condition|)
name|anchor
operator|->
name|lookaside
operator|=
name|n
operator|=
name|n
operator|->
name|prev
expr_stmt|;
else|else
name|anchor
operator|->
name|lookaside
operator|=
name|n
operator|=
name|n
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|hit
condition|)
return|return
name|n
return|;
block|}
name|n
operator|=
name|anchor
operator|->
name|root
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|n
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pos
operator|<
name|n
operator|->
name|r
operator|.
name|hl_startpos
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|left
operator|!=
name|NULL
condition|)
block|{
name|m
operator|=
name|n
expr_stmt|;
name|n
operator|=
name|n
operator|->
name|left
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
if|if
condition|(
name|pos
operator|>=
name|n
operator|->
name|r
operator|.
name|hl_endpos
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|right
operator|!=
name|NULL
condition|)
block|{
name|n
operator|=
name|n
operator|->
name|right
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|n
operator|=
name|m
expr_stmt|;
block|}
else|else
block|{
name|m
operator|=
name|n
expr_stmt|;
name|n
operator|=
name|NULL
expr_stmt|;
block|}
block|}
break|break;
block|}
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
name|anchor
operator|->
name|lookaside
operator|=
name|n
expr_stmt|;
elseif|else
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|anchor
operator|->
name|lookaside
operator|=
name|m
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/*  * Should any characters in a specified range be highlighted?  */
end_comment

begin_function
specifier|static
name|int
name|is_hilited_range
parameter_list|(
name|POSITION
name|pos
parameter_list|,
name|POSITION
name|epos
parameter_list|)
block|{
name|struct
name|hilite_node
modifier|*
name|n
init|=
name|hlist_find
argument_list|(
operator|&
name|hilite_anchor
argument_list|,
name|pos
argument_list|)
decl_stmt|;
return|return
operator|(
name|n
operator|!=
name|NULL
operator|&&
operator|(
name|epos
operator|==
name|NULL_POSITION
operator|||
name|epos
operator|>
name|n
operator|->
name|r
operator|.
name|hl_startpos
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * Is a line "filtered" -- that is, should it be hidden?  */
end_comment

begin_function
name|public
name|int
name|is_filtered
parameter_list|(
name|POSITION
name|pos
parameter_list|)
block|{
name|struct
name|hilite_node
modifier|*
name|n
decl_stmt|;
if|if
condition|(
name|ch_getflags
argument_list|()
operator|&
name|CH_HELPFILE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|n
operator|=
name|hlist_find
argument_list|(
operator|&
name|filter_anchor
argument_list|,
name|pos
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|!=
name|NULL
operator|&&
name|pos
operator|>=
name|n
operator|->
name|r
operator|.
name|hl_startpos
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If pos is hidden, return the next position which isn't, otherwise  * just return pos.  */
end_comment

begin_function
name|public
name|POSITION
name|next_unfiltered
parameter_list|(
name|POSITION
name|pos
parameter_list|)
block|{
name|struct
name|hilite_node
modifier|*
name|n
decl_stmt|;
if|if
condition|(
name|ch_getflags
argument_list|()
operator|&
name|CH_HELPFILE
condition|)
return|return
operator|(
name|pos
operator|)
return|;
name|n
operator|=
name|hlist_find
argument_list|(
operator|&
name|filter_anchor
argument_list|,
name|pos
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|!=
name|NULL
operator|&&
name|pos
operator|>=
name|n
operator|->
name|r
operator|.
name|hl_startpos
condition|)
block|{
name|pos
operator|=
name|n
operator|->
name|r
operator|.
name|hl_endpos
expr_stmt|;
name|n
operator|=
name|n
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
name|pos
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If pos is hidden, return the previous position which isn't or 0 if  * we're filtered right to the beginning, otherwise just return pos.  */
end_comment

begin_function
name|public
name|POSITION
name|prev_unfiltered
parameter_list|(
name|POSITION
name|pos
parameter_list|)
block|{
name|struct
name|hilite_node
modifier|*
name|n
decl_stmt|;
if|if
condition|(
name|ch_getflags
argument_list|()
operator|&
name|CH_HELPFILE
condition|)
return|return
operator|(
name|pos
operator|)
return|;
name|n
operator|=
name|hlist_find
argument_list|(
operator|&
name|filter_anchor
argument_list|,
name|pos
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|!=
name|NULL
operator|&&
name|pos
operator|>=
name|n
operator|->
name|r
operator|.
name|hl_startpos
condition|)
block|{
name|pos
operator|=
name|n
operator|->
name|r
operator|.
name|hl_startpos
expr_stmt|;
if|if
condition|(
name|pos
operator|==
literal|0
condition|)
break|break;
name|pos
operator|--
expr_stmt|;
name|n
operator|=
name|n
operator|->
name|prev
expr_stmt|;
block|}
return|return
operator|(
name|pos
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Should any characters in a specified range be highlighted?  * If nohide is nonzero, don't consider hide_hilite.  */
end_comment

begin_function
name|public
name|int
name|is_hilited
parameter_list|(
name|POSITION
name|pos
parameter_list|,
name|POSITION
name|epos
parameter_list|,
name|int
name|nohide
parameter_list|,
name|int
modifier|*
name|p_matches
parameter_list|)
block|{
name|int
name|match
decl_stmt|;
if|if
condition|(
name|p_matches
operator|!=
name|NULL
condition|)
operator|*
name|p_matches
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|status_col
operator|&&
name|start_attnpos
operator|!=
name|NULL_POSITION
operator|&&
name|pos
operator|<
name|end_attnpos
operator|&&
operator|(
name|epos
operator|==
name|NULL_POSITION
operator|||
name|epos
operator|>
name|start_attnpos
operator|)
condition|)
comment|/* 		 * The attn line overlaps this range. 		 */
return|return
operator|(
literal|1
operator|)
return|;
name|match
operator|=
name|is_hilited_range
argument_list|(
name|pos
argument_list|,
name|epos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|match
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|p_matches
operator|!=
name|NULL
condition|)
comment|/* 		 * Report matches, even if we're hiding highlights. 		 */
operator|*
name|p_matches
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|hilite_search
operator|==
literal|0
condition|)
comment|/* 		 * Not doing highlighting. 		 */
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|nohide
operator|&&
name|hide_hilite
condition|)
comment|/* 		 * Highlighting is hidden. 		 */
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Tree node storage: get the current block of nodes if it has spare  * capacity, or create a new one if not.  */
end_comment

begin_function
specifier|static
name|struct
name|hilite_storage
modifier|*
name|hlist_getstorage
parameter_list|(
name|struct
name|hilite_tree
modifier|*
name|anchor
parameter_list|)
block|{
name|int
name|capacity
init|=
literal|1
decl_stmt|;
name|struct
name|hilite_storage
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|anchor
operator|->
name|current
condition|)
block|{
if|if
condition|(
name|anchor
operator|->
name|current
operator|->
name|used
operator|<
name|anchor
operator|->
name|current
operator|->
name|capacity
condition|)
return|return
name|anchor
operator|->
name|current
return|;
name|capacity
operator|=
name|anchor
operator|->
name|current
operator|->
name|capacity
operator|*
literal|2
expr_stmt|;
block|}
name|s
operator|=
operator|(
expr|struct
name|hilite_storage
operator|*
operator|)
name|ecalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hilite_storage
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|nodes
operator|=
operator|(
expr|struct
name|hilite_node
operator|*
operator|)
name|ecalloc
argument_list|(
name|capacity
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hilite_node
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|capacity
operator|=
name|capacity
expr_stmt|;
name|s
operator|->
name|used
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|anchor
operator|->
name|current
condition|)
name|anchor
operator|->
name|current
operator|->
name|next
operator|=
name|s
expr_stmt|;
else|else
name|anchor
operator|->
name|first
operator|=
name|s
expr_stmt|;
name|anchor
operator|->
name|current
operator|=
name|s
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/*  * Tree node storage: retrieve a new empty node to be inserted into the  * tree.  */
end_comment

begin_function
specifier|static
name|struct
name|hilite_node
modifier|*
name|hlist_getnode
parameter_list|(
name|struct
name|hilite_tree
modifier|*
name|anchor
parameter_list|)
block|{
name|struct
name|hilite_storage
modifier|*
name|s
init|=
name|hlist_getstorage
argument_list|(
name|anchor
argument_list|)
decl_stmt|;
return|return
operator|&
name|s
operator|->
name|nodes
index|[
name|s
operator|->
name|used
operator|++
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * Rotate the tree left around a pivot node.  */
end_comment

begin_function
specifier|static
name|void
name|hlist_rotate_left
parameter_list|(
name|struct
name|hilite_tree
modifier|*
name|anchor
parameter_list|,
name|struct
name|hilite_node
modifier|*
name|n
parameter_list|)
block|{
name|struct
name|hilite_node
modifier|*
name|np
init|=
name|n
operator|->
name|parent
decl_stmt|;
name|struct
name|hilite_node
modifier|*
name|nr
init|=
name|n
operator|->
name|right
decl_stmt|;
name|struct
name|hilite_node
modifier|*
name|nrl
init|=
name|n
operator|->
name|right
operator|->
name|left
decl_stmt|;
if|if
condition|(
name|np
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|n
operator|==
name|np
operator|->
name|left
condition|)
name|np
operator|->
name|left
operator|=
name|nr
expr_stmt|;
else|else
name|np
operator|->
name|right
operator|=
name|nr
expr_stmt|;
block|}
else|else
block|{
name|anchor
operator|->
name|root
operator|=
name|nr
expr_stmt|;
block|}
name|nr
operator|->
name|left
operator|=
name|n
expr_stmt|;
name|n
operator|->
name|right
operator|=
name|nrl
expr_stmt|;
name|nr
operator|->
name|parent
operator|=
name|np
expr_stmt|;
name|n
operator|->
name|parent
operator|=
name|nr
expr_stmt|;
if|if
condition|(
name|nrl
operator|!=
name|NULL
condition|)
name|nrl
operator|->
name|parent
operator|=
name|n
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Rotate the tree right around a pivot node.  */
end_comment

begin_function
specifier|static
name|void
name|hlist_rotate_right
parameter_list|(
name|struct
name|hilite_tree
modifier|*
name|anchor
parameter_list|,
name|struct
name|hilite_node
modifier|*
name|n
parameter_list|)
block|{
name|struct
name|hilite_node
modifier|*
name|np
init|=
name|n
operator|->
name|parent
decl_stmt|;
name|struct
name|hilite_node
modifier|*
name|nl
init|=
name|n
operator|->
name|left
decl_stmt|;
name|struct
name|hilite_node
modifier|*
name|nlr
init|=
name|n
operator|->
name|left
operator|->
name|right
decl_stmt|;
if|if
condition|(
name|np
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|n
operator|==
name|np
operator|->
name|right
condition|)
name|np
operator|->
name|right
operator|=
name|nl
expr_stmt|;
else|else
name|np
operator|->
name|left
operator|=
name|nl
expr_stmt|;
block|}
else|else
block|{
name|anchor
operator|->
name|root
operator|=
name|nl
expr_stmt|;
block|}
name|nl
operator|->
name|right
operator|=
name|n
expr_stmt|;
name|n
operator|->
name|left
operator|=
name|nlr
expr_stmt|;
name|nl
operator|->
name|parent
operator|=
name|np
expr_stmt|;
name|n
operator|->
name|parent
operator|=
name|nl
expr_stmt|;
if|if
condition|(
name|nlr
operator|!=
name|NULL
condition|)
name|nlr
operator|->
name|parent
operator|=
name|n
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a new hilite to a hilite list.  */
end_comment

begin_function
specifier|static
name|void
name|add_hilite
parameter_list|(
name|struct
name|hilite_tree
modifier|*
name|anchor
parameter_list|,
name|struct
name|hilite
modifier|*
name|hl
parameter_list|)
block|{
name|struct
name|hilite_node
modifier|*
name|p
decl_stmt|,
modifier|*
name|n
decl_stmt|,
modifier|*
name|u
decl_stmt|;
comment|/* Ignore empty ranges. */
if|if
condition|(
name|hl
operator|->
name|hl_startpos
operator|>=
name|hl
operator|->
name|hl_endpos
condition|)
return|return;
name|p
operator|=
name|anchor
operator|->
name|root
expr_stmt|;
comment|/* Inserting the very first node is trivial. */
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|n
operator|=
name|hlist_getnode
argument_list|(
name|anchor
argument_list|)
expr_stmt|;
name|n
operator|->
name|r
operator|=
operator|*
name|hl
expr_stmt|;
name|anchor
operator|->
name|root
operator|=
name|n
expr_stmt|;
name|anchor
operator|->
name|lookaside
operator|=
name|n
expr_stmt|;
return|return;
block|}
comment|/* 	 * Find our insertion point. If we come across any overlapping 	 * or adjoining existing ranges, shrink our range and discard 	 * if it become empty. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|hl
operator|->
name|hl_startpos
operator|<
name|p
operator|->
name|r
operator|.
name|hl_startpos
condition|)
block|{
if|if
condition|(
name|hl
operator|->
name|hl_endpos
operator|>
name|p
operator|->
name|r
operator|.
name|hl_startpos
condition|)
name|hl
operator|->
name|hl_endpos
operator|=
name|p
operator|->
name|r
operator|.
name|hl_startpos
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|left
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|p
operator|->
name|left
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
if|if
condition|(
name|hl
operator|->
name|hl_startpos
operator|<
name|p
operator|->
name|r
operator|.
name|hl_endpos
condition|)
block|{
name|hl
operator|->
name|hl_startpos
operator|=
name|p
operator|->
name|r
operator|.
name|hl_endpos
expr_stmt|;
if|if
condition|(
name|hl
operator|->
name|hl_startpos
operator|>=
name|hl
operator|->
name|hl_endpos
condition|)
return|return;
block|}
if|if
condition|(
name|p
operator|->
name|right
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|p
operator|->
name|right
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
comment|/* 	 * Now we're at the right leaf, again check for contiguous ranges 	 * and extend the existing node if possible to avoid the 	 * insertion. Otherwise insert a new node at the leaf. 	 */
if|if
condition|(
name|hl
operator|->
name|hl_startpos
operator|<
name|p
operator|->
name|r
operator|.
name|hl_startpos
condition|)
block|{
if|if
condition|(
name|hl
operator|->
name|hl_endpos
operator|==
name|p
operator|->
name|r
operator|.
name|hl_startpos
condition|)
block|{
name|p
operator|->
name|r
operator|.
name|hl_startpos
operator|=
name|hl
operator|->
name|hl_startpos
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p
operator|->
name|prev
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|prev
operator|->
name|r
operator|.
name|hl_endpos
operator|==
name|hl
operator|->
name|hl_startpos
condition|)
block|{
name|p
operator|->
name|prev
operator|->
name|r
operator|.
name|hl_endpos
operator|=
name|hl
operator|->
name|hl_endpos
expr_stmt|;
return|return;
block|}
name|p
operator|->
name|left
operator|=
name|n
operator|=
name|hlist_getnode
argument_list|(
name|anchor
argument_list|)
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|prev
operator|!=
name|NULL
condition|)
block|{
name|n
operator|->
name|prev
operator|=
name|p
operator|->
name|prev
expr_stmt|;
name|p
operator|->
name|prev
operator|->
name|next
operator|=
name|n
expr_stmt|;
block|}
name|p
operator|->
name|prev
operator|=
name|n
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p
operator|->
name|r
operator|.
name|hl_endpos
operator|==
name|hl
operator|->
name|hl_startpos
condition|)
block|{
name|p
operator|->
name|r
operator|.
name|hl_endpos
operator|=
name|hl
operator|->
name|hl_endpos
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p
operator|->
name|next
operator|!=
name|NULL
operator|&&
name|hl
operator|->
name|hl_endpos
operator|==
name|p
operator|->
name|next
operator|->
name|r
operator|.
name|hl_startpos
condition|)
block|{
name|p
operator|->
name|next
operator|->
name|r
operator|.
name|hl_startpos
operator|=
name|hl
operator|->
name|hl_startpos
expr_stmt|;
return|return;
block|}
name|p
operator|->
name|right
operator|=
name|n
operator|=
name|hlist_getnode
argument_list|(
name|anchor
argument_list|)
expr_stmt|;
name|n
operator|->
name|prev
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|next
operator|!=
name|NULL
condition|)
block|{
name|n
operator|->
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|next
operator|->
name|prev
operator|=
name|n
expr_stmt|;
block|}
name|p
operator|->
name|next
operator|=
name|n
expr_stmt|;
block|}
name|n
operator|->
name|parent
operator|=
name|p
expr_stmt|;
name|n
operator|->
name|red
operator|=
literal|1
expr_stmt|;
name|n
operator|->
name|r
operator|=
operator|*
name|hl
expr_stmt|;
comment|/* 	 * The tree is in the correct order and covers the right ranges 	 * now, but may have become unbalanced. Rebalance it using the 	 * standard red-black tree constraints and operations. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* case 1 - current is root, root is always black */
if|if
condition|(
name|n
operator|->
name|parent
operator|==
name|NULL
condition|)
block|{
name|n
operator|->
name|red
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* case 2 - parent is black, we can always be red */
if|if
condition|(
operator|!
name|n
operator|->
name|parent
operator|->
name|red
condition|)
break|break;
comment|/* 		 * constraint: because the root must be black, if our 		 * parent is red it cannot be the root therefore we must 		 * have a grandparent 		 */
comment|/* 		 * case 3 - parent and uncle are red, repaint them black, 		 * the grandparent red, and start again at the grandparent. 		 */
name|u
operator|=
name|n
operator|->
name|parent
operator|->
name|parent
operator|->
name|left
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|parent
operator|==
name|u
condition|)
name|u
operator|=
name|n
operator|->
name|parent
operator|->
name|parent
operator|->
name|right
expr_stmt|;
if|if
condition|(
name|u
operator|!=
name|NULL
operator|&&
name|u
operator|->
name|red
condition|)
block|{
name|n
operator|->
name|parent
operator|->
name|red
operator|=
literal|0
expr_stmt|;
name|u
operator|->
name|red
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|n
operator|->
name|parent
operator|->
name|parent
expr_stmt|;
name|n
operator|->
name|red
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * case 4 - parent is red but uncle is black, parent and 		 * grandparent on opposite sides. We need to start 		 * changing the structure now. This and case 5 will shorten 		 * our branch and lengthen the sibling, between them 		 * restoring balance. 		 */
if|if
condition|(
name|n
operator|==
name|n
operator|->
name|parent
operator|->
name|right
operator|&&
name|n
operator|->
name|parent
operator|==
name|n
operator|->
name|parent
operator|->
name|parent
operator|->
name|left
condition|)
block|{
name|hlist_rotate_left
argument_list|(
name|anchor
argument_list|,
name|n
operator|->
name|parent
argument_list|)
expr_stmt|;
name|n
operator|=
name|n
operator|->
name|left
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|==
name|n
operator|->
name|parent
operator|->
name|left
operator|&&
name|n
operator|->
name|parent
operator|==
name|n
operator|->
name|parent
operator|->
name|parent
operator|->
name|right
condition|)
block|{
name|hlist_rotate_right
argument_list|(
name|anchor
argument_list|,
name|n
operator|->
name|parent
argument_list|)
expr_stmt|;
name|n
operator|=
name|n
operator|->
name|right
expr_stmt|;
block|}
comment|/* 		 * case 5 - parent is red but uncle is black, parent and 		 * grandparent on same side 		 */
name|n
operator|->
name|parent
operator|->
name|red
operator|=
literal|0
expr_stmt|;
name|n
operator|->
name|parent
operator|->
name|parent
operator|->
name|red
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|n
operator|->
name|parent
operator|->
name|left
condition|)
name|hlist_rotate_right
argument_list|(
name|anchor
argument_list|,
name|n
operator|->
name|parent
operator|->
name|parent
argument_list|)
expr_stmt|;
else|else
name|hlist_rotate_left
argument_list|(
name|anchor
argument_list|,
name|n
operator|->
name|parent
operator|->
name|parent
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Hilight every character in a range of displayed characters.  */
end_comment

begin_function
specifier|static
name|void
name|create_hilites
parameter_list|(
name|POSITION
name|linepos
parameter_list|,
name|int
name|start_index
parameter_list|,
name|int
name|end_index
parameter_list|,
name|int
modifier|*
name|chpos
parameter_list|)
block|{
name|struct
name|hilite
name|hl
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Start the first hilite. */
name|hl
operator|.
name|hl_startpos
operator|=
name|linepos
operator|+
name|chpos
index|[
name|start_index
index|]
expr_stmt|;
comment|/* 	 * Step through the displayed chars. 	 * If the source position (before cvt) of the char is one more 	 * than the source pos of the previous char (the usual case), 	 * just increase the size of the current hilite by one. 	 * Otherwise (there are backspaces or something involved), 	 * finish the current hilite and start a new one. 	 */
for|for
control|(
name|i
operator|=
name|start_index
operator|+
literal|1
init|;
name|i
operator|<=
name|end_index
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|chpos
index|[
name|i
index|]
operator|!=
name|chpos
index|[
name|i
operator|-
literal|1
index|]
operator|+
literal|1
operator|||
name|i
operator|==
name|end_index
condition|)
block|{
name|hl
operator|.
name|hl_endpos
operator|=
name|linepos
operator|+
name|chpos
index|[
name|i
operator|-
literal|1
index|]
operator|+
literal|1
expr_stmt|;
name|add_hilite
argument_list|(
operator|&
name|hilite_anchor
argument_list|,
operator|&
name|hl
argument_list|)
expr_stmt|;
comment|/* Start new hilite unless this is the last char. */
if|if
condition|(
name|i
operator|<
name|end_index
condition|)
block|{
name|hl
operator|.
name|hl_startpos
operator|=
name|linepos
operator|+
name|chpos
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Make a hilite for each string in a physical line which matches   * the current pattern.  * sp,ep delimit the first match already found.  */
end_comment

begin_function
specifier|static
name|void
name|hilite_line
parameter_list|(
name|POSITION
name|linepos
parameter_list|,
name|char
modifier|*
name|line
parameter_list|,
name|int
name|line_len
parameter_list|,
name|int
modifier|*
name|chpos
parameter_list|,
name|char
modifier|*
name|sp
parameter_list|,
name|char
modifier|*
name|ep
parameter_list|,
name|int
name|cvt_ops
parameter_list|)
block|{
name|char
modifier|*
name|searchp
decl_stmt|;
name|char
modifier|*
name|line_end
init|=
name|line
operator|+
name|line_len
decl_stmt|;
comment|/* 	 * sp and ep delimit the first match in the line. 	 * Mark the corresponding file positions, then 	 * look for further matches and mark them. 	 * {{ This technique, of calling match_pattern on subsequent 	 *    substrings of the line, may mark more than is correct 	 *    if the pattern starts with "^".  This bug is fixed 	 *    for those regex functions that accept a notbol parameter 	 *    (currently POSIX, PCRE and V8-with-regexec2). }} 	 */
name|searchp
operator|=
name|line
expr_stmt|;
do|do
block|{
if|if
condition|(
name|sp
operator|==
name|NULL
operator|||
name|ep
operator|==
name|NULL
condition|)
return|return;
name|create_hilites
argument_list|(
name|linepos
argument_list|,
name|sp
operator|-
name|line
argument_list|,
name|ep
operator|-
name|line
argument_list|,
name|chpos
argument_list|)
expr_stmt|;
comment|/* 		 * If we matched more than zero characters, 		 * move to the first char after the string we matched. 		 * If we matched zero, just move to the next char. 		 */
if|if
condition|(
name|ep
operator|>
name|searchp
condition|)
name|searchp
operator|=
name|ep
expr_stmt|;
elseif|else
if|if
condition|(
name|searchp
operator|!=
name|line_end
condition|)
name|searchp
operator|++
expr_stmt|;
else|else
comment|/* end of line */
break|break;
block|}
do|while
condition|(
name|match_pattern
argument_list|(
name|info_compiled
argument_list|(
operator|&
name|search_info
argument_list|)
argument_list|,
name|search_info
operator|.
name|text
argument_list|,
name|searchp
argument_list|,
name|line_end
operator|-
name|searchp
argument_list|,
operator|&
name|sp
argument_list|,
operator|&
name|ep
argument_list|,
literal|1
argument_list|,
name|search_info
operator|.
name|search_type
argument_list|)
condition|)
do|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Change the caseless-ness of searches.    * Updates the internal search state to reflect a change in the -i flag.  */
end_comment

begin_function
name|public
name|void
name|chg_caseless
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|is_ucase_pattern
condition|)
comment|/* 		 * Pattern did not have uppercase. 		 * Just set the search caselessness to the global caselessness. 		 */
name|is_caseless
operator|=
name|caseless
expr_stmt|;
else|else
comment|/* 		 * Pattern did have uppercase. 		 * Discard the pattern; we can't change search caselessness now. 		 */
name|clear_pattern
argument_list|(
operator|&
name|search_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|HILITE_SEARCH
end_if

begin_comment
comment|/*  * Find matching text which is currently on screen and highlight it.  */
end_comment

begin_function
specifier|static
name|void
name|hilite_screen
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|scrpos
name|scrpos
decl_stmt|;
name|get_scrpos
argument_list|(
operator|&
name|scrpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|scrpos
operator|.
name|pos
operator|==
name|NULL_POSITION
condition|)
return|return;
name|prep_hilite
argument_list|(
name|scrpos
operator|.
name|pos
argument_list|,
name|position
argument_list|(
name|BOTTOM_PLUS_ONE
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|repaint_hilite
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Change highlighting parameters.  */
end_comment

begin_function
name|public
name|void
name|chg_hilite
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * Erase any highlights currently on screen. 	 */
name|clr_hilite
argument_list|()
expr_stmt|;
name|hide_hilite
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hilite_search
operator|==
name|OPT_ONPLUS
condition|)
comment|/* 		 * Display highlights. 		 */
name|hilite_screen
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Figure out where to start a search.  */
end_comment

begin_function
specifier|static
name|POSITION
name|search_pos
parameter_list|(
name|int
name|search_type
parameter_list|)
block|{
name|POSITION
name|pos
decl_stmt|;
name|int
name|linenum
decl_stmt|;
if|if
condition|(
name|empty_screen
argument_list|()
condition|)
block|{
comment|/* 		 * Start at the beginning (or end) of the file. 		 * The empty_screen() case is mainly for  		 * command line initiated searches; 		 * for example, "+/xyz" on the command line. 		 * Also for multi-file (SRCH_PAST_EOF) searches. 		 */
if|if
condition|(
name|search_type
operator|&
name|SRCH_FORW
condition|)
block|{
name|pos
operator|=
name|ch_zero
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|pos
operator|=
name|ch_length
argument_list|()
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|NULL_POSITION
condition|)
block|{
operator|(
name|void
operator|)
name|ch_end_seek
argument_list|()
expr_stmt|;
name|pos
operator|=
name|ch_length
argument_list|()
expr_stmt|;
block|}
block|}
name|linenum
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|int
name|add_one
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|how_search
operator|==
name|OPT_ON
condition|)
block|{
comment|/* 			 * Search does not include current screen. 			 */
if|if
condition|(
name|search_type
operator|&
name|SRCH_FORW
condition|)
name|linenum
operator|=
name|BOTTOM_PLUS_ONE
expr_stmt|;
else|else
name|linenum
operator|=
name|TOP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|how_search
operator|==
name|OPT_ONPLUS
operator|&&
operator|!
operator|(
name|search_type
operator|&
name|SRCH_AFTER_TARGET
operator|)
condition|)
block|{
comment|/* 			 * Search includes all of displayed screen. 			 */
if|if
condition|(
name|search_type
operator|&
name|SRCH_FORW
condition|)
name|linenum
operator|=
name|TOP
expr_stmt|;
else|else
name|linenum
operator|=
name|BOTTOM_PLUS_ONE
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Search includes the part of current screen beyond the jump target. 			 * It starts at the jump target (if searching backwards), 			 * or at the jump target plus one (if forwards). 			 */
name|linenum
operator|=
name|adjsline
argument_list|(
name|jump_sline
argument_list|)
expr_stmt|;
if|if
condition|(
name|search_type
operator|&
name|SRCH_FORW
condition|)
name|add_one
operator|=
literal|1
expr_stmt|;
block|}
name|pos
operator|=
name|position
argument_list|(
name|linenum
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_one
condition|)
name|pos
operator|=
name|forw_raw_line
argument_list|(
name|pos
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the line is empty, look around for a plausible starting place. 	 */
if|if
condition|(
name|search_type
operator|&
name|SRCH_FORW
condition|)
block|{
while|while
condition|(
name|pos
operator|==
name|NULL_POSITION
condition|)
block|{
if|if
condition|(
operator|++
name|linenum
operator|>=
name|sc_height
condition|)
break|break;
name|pos
operator|=
name|position
argument_list|(
name|linenum
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|pos
operator|==
name|NULL_POSITION
condition|)
block|{
if|if
condition|(
operator|--
name|linenum
operator|<
literal|0
condition|)
break|break;
name|pos
operator|=
name|position
argument_list|(
name|linenum
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|pos
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Search a subset of the file, specified by start/end position.  */
end_comment

begin_function
specifier|static
name|int
name|search_range
parameter_list|(
name|POSITION
name|pos
parameter_list|,
name|POSITION
name|endpos
parameter_list|,
name|int
name|search_type
parameter_list|,
name|int
name|matches
parameter_list|,
name|int
name|maxlines
parameter_list|,
name|POSITION
modifier|*
name|plinepos
parameter_list|,
name|POSITION
modifier|*
name|pendpos
parameter_list|)
block|{
name|char
modifier|*
name|line
decl_stmt|;
name|char
modifier|*
name|cline
decl_stmt|;
name|int
name|line_len
decl_stmt|;
name|LINENUM
name|linenum
decl_stmt|;
name|char
modifier|*
name|sp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|int
name|line_match
decl_stmt|;
name|int
name|cvt_ops
decl_stmt|;
name|int
name|cvt_len
decl_stmt|;
name|int
modifier|*
name|chpos
decl_stmt|;
name|POSITION
name|linepos
decl_stmt|,
name|oldpos
decl_stmt|;
name|linenum
operator|=
name|find_linenum
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|oldpos
operator|=
name|pos
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Get lines until we find a matching one or until 		 * we hit end-of-file (or beginning-of-file if we're  		 * going backwards), or until we hit the end position. 		 */
if|if
condition|(
name|ABORT_SIGS
argument_list|()
condition|)
block|{
comment|/* 			 * A signal aborts the search. 			 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|endpos
operator|!=
name|NULL_POSITION
operator|&&
name|pos
operator|>=
name|endpos
operator|)
operator|||
name|maxlines
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Reached end position without a match. 			 */
if|if
condition|(
name|pendpos
operator|!=
name|NULL
condition|)
operator|*
name|pendpos
operator|=
name|pos
expr_stmt|;
return|return
operator|(
name|matches
operator|)
return|;
block|}
if|if
condition|(
name|maxlines
operator|>
literal|0
condition|)
name|maxlines
operator|--
expr_stmt|;
if|if
condition|(
name|search_type
operator|&
name|SRCH_FORW
condition|)
block|{
comment|/* 			 * Read the next line, and save the  			 * starting position of that line in linepos. 			 */
name|linepos
operator|=
name|pos
expr_stmt|;
name|pos
operator|=
name|forw_raw_line
argument_list|(
name|pos
argument_list|,
operator|&
name|line
argument_list|,
operator|&
name|line_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|linenum
operator|!=
literal|0
condition|)
name|linenum
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Read the previous line and save the 			 * starting position of that line in linepos. 			 */
name|pos
operator|=
name|back_raw_line
argument_list|(
name|pos
argument_list|,
operator|&
name|line
argument_list|,
operator|&
name|line_len
argument_list|)
expr_stmt|;
name|linepos
operator|=
name|pos
expr_stmt|;
if|if
condition|(
name|linenum
operator|!=
literal|0
condition|)
name|linenum
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|==
name|NULL_POSITION
condition|)
block|{
comment|/* 			 * Reached EOF/BOF without a match. 			 */
if|if
condition|(
name|pendpos
operator|!=
name|NULL
condition|)
operator|*
name|pendpos
operator|=
name|oldpos
expr_stmt|;
return|return
operator|(
name|matches
operator|)
return|;
block|}
comment|/* 		 * If we're using line numbers, we might as well 		 * remember the information we have now (the position 		 * and line number of the current line). 		 * Don't do it for every line because it slows down 		 * the search.  Remember the line number only if 		 * we're "far" from the last place we remembered it. 		 */
if|if
condition|(
name|linenums
operator|&&
name|abs
argument_list|(
call|(
name|int
call|)
argument_list|(
name|pos
operator|-
name|oldpos
argument_list|)
argument_list|)
operator|>
literal|2048
condition|)
name|add_lnum
argument_list|(
name|linenum
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|oldpos
operator|=
name|pos
expr_stmt|;
if|if
condition|(
name|is_filtered
argument_list|(
name|linepos
argument_list|)
condition|)
continue|continue;
comment|/* 		 * If it's a caseless search, convert the line to lowercase. 		 * If we're doing backspace processing, delete backspaces. 		 */
name|cvt_ops
operator|=
name|get_cvt_ops
argument_list|()
expr_stmt|;
name|cvt_len
operator|=
name|cvt_length
argument_list|(
name|line_len
argument_list|,
name|cvt_ops
argument_list|)
expr_stmt|;
name|cline
operator|=
operator|(
name|char
operator|*
operator|)
name|ecalloc
argument_list|(
literal|1
argument_list|,
name|cvt_len
argument_list|)
expr_stmt|;
name|chpos
operator|=
name|cvt_alloc_chpos
argument_list|(
name|cvt_len
argument_list|)
expr_stmt|;
name|cvt_text
argument_list|(
name|cline
argument_list|,
name|line
argument_list|,
name|chpos
argument_list|,
operator|&
name|line_len
argument_list|,
name|cvt_ops
argument_list|)
expr_stmt|;
if|#
directive|if
name|HILITE_SEARCH
comment|/* 		 * Check to see if the line matches the filter pattern. 		 * If so, add an entry to the filter list. 		 */
if|if
condition|(
operator|(
operator|(
name|search_type
operator|&
name|SRCH_FIND_ALL
operator|)
operator|||
name|prep_startpos
operator|==
name|NULL_POSITION
operator|||
name|linepos
operator|<
name|prep_startpos
operator|||
name|linepos
operator|>=
name|prep_endpos
operator|)
operator|&&
name|prev_pattern
argument_list|(
operator|&
name|filter_info
argument_list|)
condition|)
block|{
name|int
name|line_filter
init|=
name|match_pattern
argument_list|(
name|info_compiled
argument_list|(
operator|&
name|filter_info
argument_list|)
argument_list|,
name|filter_info
operator|.
name|text
argument_list|,
name|cline
argument_list|,
name|line_len
argument_list|,
operator|&
name|sp
argument_list|,
operator|&
name|ep
argument_list|,
literal|0
argument_list|,
name|filter_info
operator|.
name|search_type
argument_list|)
decl_stmt|;
if|if
condition|(
name|line_filter
condition|)
block|{
name|struct
name|hilite
name|hl
decl_stmt|;
name|hl
operator|.
name|hl_startpos
operator|=
name|linepos
expr_stmt|;
name|hl
operator|.
name|hl_endpos
operator|=
name|pos
expr_stmt|;
name|add_hilite
argument_list|(
operator|&
name|filter_anchor
argument_list|,
operator|&
name|hl
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
endif|#
directive|endif
comment|/* 		 * Test the next line to see if we have a match. 		 * We are successful if we either want a match and got one, 		 * or if we want a non-match and got one. 		 */
if|if
condition|(
name|prev_pattern
argument_list|(
operator|&
name|search_info
argument_list|)
condition|)
block|{
name|line_match
operator|=
name|match_pattern
argument_list|(
name|info_compiled
argument_list|(
operator|&
name|search_info
argument_list|)
argument_list|,
name|search_info
operator|.
name|text
argument_list|,
name|cline
argument_list|,
name|line_len
argument_list|,
operator|&
name|sp
argument_list|,
operator|&
name|ep
argument_list|,
literal|0
argument_list|,
name|search_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_match
condition|)
block|{
comment|/* 				 * Got a match. 				 */
if|if
condition|(
name|search_type
operator|&
name|SRCH_FIND_ALL
condition|)
block|{
if|#
directive|if
name|HILITE_SEARCH
comment|/* 					 * We are supposed to find all matches in the range. 					 * Just add the matches in this line to the  					 * hilite list and keep searching. 					 */
name|hilite_line
argument_list|(
name|linepos
argument_list|,
name|cline
argument_list|,
name|line_len
argument_list|,
name|chpos
argument_list|,
name|sp
argument_list|,
name|ep
argument_list|,
name|cvt_ops
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|--
name|matches
operator|<=
literal|0
condition|)
block|{
comment|/* 					 * Found the one match we're looking for. 					 * Return it. 					 */
if|#
directive|if
name|HILITE_SEARCH
if|if
condition|(
name|hilite_search
operator|==
name|OPT_ON
condition|)
block|{
comment|/* 						 * Clear the hilite list and add only 						 * the matches in this one line. 						 */
name|clr_hilite
argument_list|()
expr_stmt|;
name|hilite_line
argument_list|(
name|linepos
argument_list|,
name|cline
argument_list|,
name|line_len
argument_list|,
name|chpos
argument_list|,
name|sp
argument_list|,
name|ep
argument_list|,
name|cvt_ops
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|free
argument_list|(
name|cline
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|chpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|plinepos
operator|!=
name|NULL
condition|)
operator|*
name|plinepos
operator|=
name|linepos
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
name|free
argument_list|(
name|cline
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|chpos
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * search for a pattern in history. If found, compile that pattern.  */
end_comment

begin_function
specifier|static
name|int
name|hist_pattern
parameter_list|(
name|int
name|search_type
parameter_list|)
block|{
if|#
directive|if
name|CMD_HISTORY
name|char
modifier|*
name|pattern
decl_stmt|;
name|set_mlist
argument_list|(
name|ml_search
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pattern
operator|=
name|cmd_lastpattern
argument_list|()
expr_stmt|;
if|if
condition|(
name|pattern
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|set_pattern
argument_list|(
operator|&
name|search_info
argument_list|,
name|pattern
argument_list|,
name|search_type
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|#
directive|if
name|HILITE_SEARCH
if|if
condition|(
name|hilite_search
operator|==
name|OPT_ONPLUS
operator|&&
operator|!
name|hide_hilite
condition|)
name|hilite_screen
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
else|#
directive|else
comment|/* CMD_HISTORY */
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* CMD_HISTORY */
block|}
end_function

begin_comment
comment|/*  * Search for the n-th occurrence of a specified pattern,   * either forward or backward.  * Return the number of matches not yet found in this file  * (that is, n minus the number of matches found).  * Return -1 if the search should be aborted.  * Caller may continue the search in another file   * if less than n matches are found in this file.  */
end_comment

begin_function
name|public
name|int
name|search
parameter_list|(
name|int
name|search_type
parameter_list|,
name|char
modifier|*
name|pattern
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|POSITION
name|pos
decl_stmt|;
if|if
condition|(
name|pattern
operator|==
name|NULL
operator|||
operator|*
name|pattern
operator|==
literal|'\0'
condition|)
block|{
comment|/* 		 * A null pattern means use the previously compiled pattern. 		 */
name|search_type
operator||=
name|SRCH_AFTER_TARGET
expr_stmt|;
if|if
condition|(
operator|!
name|prev_pattern
argument_list|(
operator|&
name|search_info
argument_list|)
operator|&&
operator|!
name|hist_pattern
argument_list|(
name|search_type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"No previous regular expression"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|search_type
operator|&
name|SRCH_NO_REGEX
operator|)
operator|!=
operator|(
name|search_info
operator|.
name|search_type
operator|&
name|SRCH_NO_REGEX
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"Please re-enter search pattern"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|#
directive|if
name|HILITE_SEARCH
if|if
condition|(
name|hilite_search
operator|==
name|OPT_ON
condition|)
block|{
comment|/* 			 * Erase the highlights currently on screen. 			 * If the search fails, we'll redisplay them later. 			 */
name|repaint_hilite
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hilite_search
operator|==
name|OPT_ONPLUS
operator|&&
name|hide_hilite
condition|)
block|{
comment|/* 			 * Highlight any matches currently on screen, 			 * before we actually start the search. 			 */
name|hide_hilite
operator|=
literal|0
expr_stmt|;
name|hilite_screen
argument_list|()
expr_stmt|;
block|}
name|hide_hilite
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* 		 * Compile the pattern. 		 */
if|if
condition|(
name|set_pattern
argument_list|(
operator|&
name|search_info
argument_list|,
name|pattern
argument_list|,
name|search_type
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|#
directive|if
name|HILITE_SEARCH
if|if
condition|(
name|hilite_search
condition|)
block|{
comment|/* 			 * Erase the highlights currently on screen. 			 * Also permanently delete them from the hilite list. 			 */
name|repaint_hilite
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hide_hilite
operator|=
literal|0
expr_stmt|;
name|clr_hilite
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|hilite_search
operator|==
name|OPT_ONPLUS
condition|)
block|{
comment|/* 			 * Highlight any matches currently on screen, 			 * before we actually start the search. 			 */
name|hilite_screen
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* 	 * Figure out where to start the search. 	 */
name|pos
operator|=
name|search_pos
argument_list|(
name|search_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|NULL_POSITION
condition|)
block|{
comment|/* 		 * Can't find anyplace to start searching from. 		 */
if|if
condition|(
name|search_type
operator|&
name|SRCH_PAST_EOF
condition|)
return|return
operator|(
name|n
operator|)
return|;
comment|/* repaint(); -- why was this here? */
name|error
argument_list|(
literal|"Nothing to search"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|n
operator|=
name|search_range
argument_list|(
name|pos
argument_list|,
name|NULL_POSITION
argument_list|,
name|search_type
argument_list|,
name|n
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|pos
argument_list|,
operator|(
name|POSITION
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Search was unsuccessful. 		 */
if|#
directive|if
name|HILITE_SEARCH
if|if
condition|(
name|hilite_search
operator|==
name|OPT_ON
operator|&&
name|n
operator|>
literal|0
condition|)
comment|/* 			 * Redisplay old hilites. 			 */
name|repaint_hilite
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|n
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|search_type
operator|&
name|SRCH_NO_MOVE
operator|)
condition|)
block|{
comment|/* 		 * Go to the matching line. 		 */
name|jump_loc
argument_list|(
name|pos
argument_list|,
name|jump_sline
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|HILITE_SEARCH
if|if
condition|(
name|hilite_search
operator|==
name|OPT_ON
condition|)
comment|/* 		 * Display new hilites in the matching line. 		 */
name|repaint_hilite
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|HILITE_SEARCH
end_if

begin_comment
comment|/*  * Prepare hilites in a given range of the file.  *  * The pair (prep_startpos,prep_endpos) delimits a contiguous region  * of the file that has been "prepared"; that is, scanned for matches for  * the current search pattern, and hilites have been created for such matches.  * If prep_startpos == NULL_POSITION, the prep region is empty.  * If prep_endpos == NULL_POSITION, the prep region extends to EOF.  * prep_hilite asks that the range (spos,epos) be covered by the prep region.  */
end_comment

begin_function
name|public
name|void
name|prep_hilite
parameter_list|(
name|POSITION
name|spos
parameter_list|,
name|POSITION
name|epos
parameter_list|,
name|int
name|maxlines
parameter_list|)
block|{
name|POSITION
name|nprep_startpos
init|=
name|prep_startpos
decl_stmt|;
name|POSITION
name|nprep_endpos
init|=
name|prep_endpos
decl_stmt|;
name|POSITION
name|new_epos
decl_stmt|;
name|POSITION
name|max_epos
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*  * Search beyond where we're asked to search, so the prep region covers  * more than we need.  Do one big search instead of a bunch of small ones.  */
define|#
directive|define
name|SEARCH_MORE
value|(3*size_linebuf)
if|if
condition|(
operator|!
name|prev_pattern
argument_list|(
operator|&
name|search_info
argument_list|)
operator|&&
operator|!
name|is_filtering
argument_list|()
condition|)
return|return;
comment|/* 	 * Make sure our prep region always starts at the beginning of 	 * a line. (search_range takes care of the end boundary below.) 	 */
name|spos
operator|=
name|back_raw_line
argument_list|(
name|spos
operator|+
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * If we're limited to a max number of lines, figure out the 	 * file position we should stop at. 	 */
if|if
condition|(
name|maxlines
operator|<
literal|0
condition|)
name|max_epos
operator|=
name|NULL_POSITION
expr_stmt|;
else|else
block|{
name|max_epos
operator|=
name|spos
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxlines
condition|;
name|i
operator|++
control|)
name|max_epos
operator|=
name|forw_raw_line
argument_list|(
name|max_epos
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Find two ranges: 	 * The range that we need to search (spos,epos); and the range that 	 * the "prep" region will then cover (nprep_startpos,nprep_endpos). 	 */
if|if
condition|(
name|prep_startpos
operator|==
name|NULL_POSITION
operator|||
operator|(
name|epos
operator|!=
name|NULL_POSITION
operator|&&
name|epos
operator|<
name|prep_startpos
operator|)
operator|||
name|spos
operator|>
name|prep_endpos
condition|)
block|{
comment|/* 		 * New range is not contiguous with old prep region. 		 * Discard the old prep region and start a new one. 		 */
name|clr_hilite
argument_list|()
expr_stmt|;
name|clr_filter
argument_list|()
expr_stmt|;
if|if
condition|(
name|epos
operator|!=
name|NULL_POSITION
condition|)
name|epos
operator|+=
name|SEARCH_MORE
expr_stmt|;
name|nprep_startpos
operator|=
name|spos
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * New range partially or completely overlaps old prep region. 		 */
if|if
condition|(
name|epos
operator|==
name|NULL_POSITION
condition|)
block|{
comment|/* 			 * New range goes to end of file. 			 */
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|epos
operator|>
name|prep_endpos
condition|)
block|{
comment|/* 			 * New range ends after old prep region. 			 * Extend prep region to end at end of new range. 			 */
name|epos
operator|+=
name|SEARCH_MORE
expr_stmt|;
block|}
else|else
comment|/* (epos<= prep_endpos) */
block|{
comment|/* 			 * New range ends within old prep region. 			 * Truncate search to end at start of old prep region. 			 */
name|epos
operator|=
name|prep_startpos
expr_stmt|;
block|}
if|if
condition|(
name|spos
operator|<
name|prep_startpos
condition|)
block|{
comment|/* 			 * New range starts before old prep region. 			 * Extend old prep region backwards to start at  			 * start of new range. 			 */
if|if
condition|(
name|spos
operator|<
name|SEARCH_MORE
condition|)
name|spos
operator|=
literal|0
expr_stmt|;
else|else
name|spos
operator|-=
name|SEARCH_MORE
expr_stmt|;
name|nprep_startpos
operator|=
name|spos
expr_stmt|;
block|}
else|else
comment|/* (spos>= prep_startpos) */
block|{
comment|/* 			 * New range starts within or after old prep region. 			 * Trim search to start at end of old prep region. 			 */
name|spos
operator|=
name|prep_endpos
expr_stmt|;
block|}
block|}
if|if
condition|(
name|epos
operator|!=
name|NULL_POSITION
operator|&&
name|max_epos
operator|!=
name|NULL_POSITION
operator|&&
name|epos
operator|>
name|max_epos
condition|)
comment|/* 		 * Don't go past the max position we're allowed. 		 */
name|epos
operator|=
name|max_epos
expr_stmt|;
if|if
condition|(
name|epos
operator|==
name|NULL_POSITION
operator|||
name|epos
operator|>
name|spos
condition|)
block|{
name|int
name|search_type
init|=
name|SRCH_FORW
operator||
name|SRCH_FIND_ALL
decl_stmt|;
name|search_type
operator||=
operator|(
name|search_info
operator|.
name|search_type
operator|&
name|SRCH_NO_REGEX
operator|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|result
operator|=
name|search_range
argument_list|(
name|spos
argument_list|,
name|epos
argument_list|,
name|search_type
argument_list|,
literal|0
argument_list|,
name|maxlines
argument_list|,
operator|(
name|POSITION
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|new_epos
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|prep_endpos
operator|==
name|NULL_POSITION
operator|||
name|new_epos
operator|>
name|prep_endpos
condition|)
name|nprep_endpos
operator|=
name|new_epos
expr_stmt|;
comment|/* 			 * Check both ends of the resulting prep region to 			 * make sure they're not filtered. If they are, 			 * keep going at least one more line until we find 			 * something that isn't filtered, or hit the end. 			 */
if|if
condition|(
name|prep_endpos
operator|==
name|NULL_POSITION
operator|||
name|nprep_endpos
operator|>
name|prep_endpos
condition|)
block|{
if|if
condition|(
name|new_epos
operator|>=
name|nprep_endpos
operator|&&
name|is_filtered
argument_list|(
name|new_epos
operator|-
literal|1
argument_list|)
condition|)
block|{
name|spos
operator|=
name|nprep_endpos
expr_stmt|;
name|epos
operator|=
name|forw_raw_line
argument_list|(
name|nprep_endpos
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|epos
operator|==
name|NULL_POSITION
condition|)
break|break;
name|maxlines
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|prep_startpos
operator|==
name|NULL_POSITION
operator|||
name|nprep_startpos
operator|<
name|prep_startpos
condition|)
block|{
if|if
condition|(
name|nprep_startpos
operator|>
literal|0
operator|&&
name|is_filtered
argument_list|(
name|nprep_startpos
argument_list|)
condition|)
block|{
name|epos
operator|=
name|nprep_startpos
expr_stmt|;
name|spos
operator|=
name|back_raw_line
argument_list|(
name|nprep_startpos
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|spos
operator|==
name|NULL_POSITION
condition|)
break|break;
name|nprep_startpos
operator|=
name|spos
expr_stmt|;
name|maxlines
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
break|break;
block|}
block|}
name|prep_startpos
operator|=
name|nprep_startpos
expr_stmt|;
name|prep_endpos
operator|=
name|nprep_endpos
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the pattern to be used for line filtering.  */
end_comment

begin_function
name|public
name|void
name|set_filter_pattern
parameter_list|(
name|char
modifier|*
name|pattern
parameter_list|,
name|int
name|search_type
parameter_list|)
block|{
name|clr_filter
argument_list|()
expr_stmt|;
if|if
condition|(
name|pattern
operator|==
name|NULL
operator|||
operator|*
name|pattern
operator|==
literal|'\0'
condition|)
name|clear_pattern
argument_list|(
operator|&
name|filter_info
argument_list|)
expr_stmt|;
else|else
name|set_pattern
argument_list|(
operator|&
name|filter_info
argument_list|,
name|pattern
argument_list|,
name|search_type
argument_list|)
expr_stmt|;
name|screen_trashed
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Is there a line filter in effect?  */
end_comment

begin_function
name|public
name|int
name|is_filtering
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|ch_getflags
argument_list|()
operator|&
name|CH_HELPFILE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
name|prev_pattern
argument_list|(
operator|&
name|filter_info
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_V8_REGCOMP
end_if

begin_comment
comment|/*  * This function is called by the V8 regcomp to report   * errors in regular expressions.  */
end_comment

begin_decl_stmt
name|public
name|int
name|reg_show_error
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|regerror
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|PARG
name|parg
decl_stmt|;
if|if
condition|(
operator|!
name|reg_show_error
condition|)
return|return;
name|parg
operator|.
name|p_string
operator|=
name|s
expr_stmt|;
name|error
argument_list|(
literal|"%s"
argument_list|,
operator|&
name|parg
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

