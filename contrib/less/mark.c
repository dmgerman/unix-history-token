begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1984-2000  Mark Nudelman  *  * You may distribute under the terms of either the GNU General Public  * License or the Less License, as specified in the README file.  *  * For more information about less, or for information on how to   * contact the author, see the README file.  */
end_comment

begin_include
include|#
directive|include
file|"less.h"
end_include

begin_decl_stmt
specifier|extern
name|IFILE
name|curr_ifile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sc_height
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|jump_sline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * A mark is an ifile (input file) plus a position within the file.  */
end_comment

begin_struct
struct|struct
name|mark
block|{
name|IFILE
name|m_ifile
decl_stmt|;
name|struct
name|scrpos
name|m_scrpos
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * The table of marks.  * Each mark is identified by a lowercase or uppercase letter.  * The final one is lmark, for the "last mark"; addressed by the apostrophe.  */
end_comment

begin_define
define|#
directive|define
name|NMARKS
value|((2*26)+1)
end_define

begin_comment
comment|/* a-z, A-Z, lastmark */
end_comment

begin_define
define|#
directive|define
name|LASTMARK
value|(NMARKS-1)
end_define

begin_decl_stmt
specifier|static
name|struct
name|mark
name|marks
index|[
name|NMARKS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initialize the mark table to show no marks are set.  */
end_comment

begin_function
name|public
name|void
name|init_mark
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NMARKS
condition|;
name|i
operator|++
control|)
name|marks
index|[
name|i
index|]
operator|.
name|m_scrpos
operator|.
name|pos
operator|=
name|NULL_POSITION
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * See if a mark letter is valid (between a and z).  */
end_comment

begin_function
specifier|static
name|struct
name|mark
modifier|*
name|getumark
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
condition|)
return|return
operator|(
operator|&
name|marks
index|[
name|c
operator|-
literal|'a'
index|]
operator|)
return|;
if|if
condition|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
condition|)
return|return
operator|(
operator|&
name|marks
index|[
name|c
operator|-
literal|'A'
operator|+
literal|26
index|]
operator|)
return|;
name|error
argument_list|(
literal|"Invalid mark letter"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the mark structure identified by a character.  * The mark struct may come either from the mark table  * or may be constructed on the fly for certain characters like ^, $.  */
end_comment

begin_function
specifier|static
name|struct
name|mark
modifier|*
name|getmark
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
specifier|register
name|struct
name|mark
modifier|*
name|m
decl_stmt|;
specifier|static
name|struct
name|mark
name|sm
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'^'
case|:
comment|/* 		 * Beginning of the current file. 		 */
name|m
operator|=
operator|&
name|sm
expr_stmt|;
name|m
operator|->
name|m_scrpos
operator|.
name|pos
operator|=
name|ch_zero
argument_list|()
expr_stmt|;
name|m
operator|->
name|m_scrpos
operator|.
name|ln
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|m_ifile
operator|=
name|curr_ifile
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
comment|/* 		 * End of the current file. 		 */
if|if
condition|(
name|ch_end_seek
argument_list|()
condition|)
block|{
name|error
argument_list|(
literal|"Cannot seek to end of file"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|m
operator|=
operator|&
name|sm
expr_stmt|;
name|m
operator|->
name|m_scrpos
operator|.
name|pos
operator|=
name|ch_tell
argument_list|()
expr_stmt|;
name|m
operator|->
name|m_scrpos
operator|.
name|ln
operator|=
name|sc_height
operator|-
literal|1
expr_stmt|;
name|m
operator|->
name|m_ifile
operator|=
name|curr_ifile
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
comment|/* 		 * Current position in the current file. 		 */
name|m
operator|=
operator|&
name|sm
expr_stmt|;
name|get_scrpos
argument_list|(
operator|&
name|m
operator|->
name|m_scrpos
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_ifile
operator|=
name|curr_ifile
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
comment|/* 		 * The "last mark". 		 */
name|m
operator|=
operator|&
name|marks
index|[
name|LASTMARK
index|]
expr_stmt|;
break|break;
default|default:
comment|/* 		 * Must be a user-defined mark. 		 */
name|m
operator|=
name|getumark
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|m
operator|->
name|m_scrpos
operator|.
name|pos
operator|==
name|NULL_POSITION
condition|)
block|{
name|error
argument_list|(
literal|"Mark not set"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
break|break;
block|}
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Is a mark letter is invalid?  */
end_comment

begin_function
name|public
name|int
name|badmark
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
return|return
operator|(
name|getmark
argument_list|(
name|c
argument_list|)
operator|==
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set a user-defined mark.  */
end_comment

begin_function
name|public
name|void
name|setmark
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
specifier|register
name|struct
name|mark
modifier|*
name|m
decl_stmt|;
name|struct
name|scrpos
name|scrpos
decl_stmt|;
name|m
operator|=
name|getumark
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
name|get_scrpos
argument_list|(
operator|&
name|scrpos
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_scrpos
operator|=
name|scrpos
expr_stmt|;
name|m
operator|->
name|m_ifile
operator|=
name|curr_ifile
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set lmark (the mark named by the apostrophe).  */
end_comment

begin_function
name|public
name|void
name|lastmark
parameter_list|()
block|{
name|struct
name|scrpos
name|scrpos
decl_stmt|;
if|if
condition|(
name|ch_getflags
argument_list|()
operator|&
name|CH_HELPFILE
condition|)
return|return;
name|get_scrpos
argument_list|(
operator|&
name|scrpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|scrpos
operator|.
name|pos
operator|==
name|NULL_POSITION
condition|)
return|return;
name|marks
index|[
name|LASTMARK
index|]
operator|.
name|m_scrpos
operator|=
name|scrpos
expr_stmt|;
name|marks
index|[
name|LASTMARK
index|]
operator|.
name|m_ifile
operator|=
name|curr_ifile
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Go to a mark.  */
end_comment

begin_function
name|public
name|void
name|gomark
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
specifier|register
name|struct
name|mark
modifier|*
name|m
decl_stmt|;
name|struct
name|scrpos
name|scrpos
decl_stmt|;
name|m
operator|=
name|getmark
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * If we're trying to go to the lastmark and  	 * it has not been set to anything yet, 	 * set it to the beginning of the current file. 	 */
if|if
condition|(
name|m
operator|==
operator|&
name|marks
index|[
name|LASTMARK
index|]
operator|&&
name|m
operator|->
name|m_scrpos
operator|.
name|pos
operator|==
name|NULL_POSITION
condition|)
block|{
name|m
operator|->
name|m_ifile
operator|=
name|curr_ifile
expr_stmt|;
name|m
operator|->
name|m_scrpos
operator|.
name|pos
operator|=
name|ch_zero
argument_list|()
expr_stmt|;
name|m
operator|->
name|m_scrpos
operator|.
name|ln
operator|=
name|jump_sline
expr_stmt|;
block|}
comment|/* 	 * If we're using lmark, we must save the screen position now, 	 * because if we call edit_ifile() below, lmark will change. 	 * (We save the screen position even if we're not using lmark.) 	 */
name|scrpos
operator|=
name|m
operator|->
name|m_scrpos
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_ifile
operator|!=
name|curr_ifile
condition|)
block|{
comment|/* 		 * Not in the current file; edit the correct file. 		 */
if|if
condition|(
name|edit_ifile
argument_list|(
name|m
operator|->
name|m_ifile
argument_list|)
condition|)
return|return;
block|}
name|jump_loc
argument_list|(
name|scrpos
operator|.
name|pos
argument_list|,
name|scrpos
operator|.
name|ln
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the position associated with a given mark letter.  *  * We don't return which screen line the position   * is associated with, but this doesn't matter much,  * because it's always the first non-blank line on the screen.  */
end_comment

begin_function
name|public
name|POSITION
name|markpos
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
specifier|register
name|struct
name|mark
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|getmark
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL_POSITION
operator|)
return|;
if|if
condition|(
name|m
operator|->
name|m_ifile
operator|!=
name|curr_ifile
condition|)
block|{
name|error
argument_list|(
literal|"Mark not in current file"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL_POSITION
operator|)
return|;
block|}
return|return
operator|(
name|m
operator|->
name|m_scrpos
operator|.
name|pos
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clear the marks associated with a specified ifile.  */
end_comment

begin_function
name|public
name|void
name|unmark
parameter_list|(
name|ifile
parameter_list|)
name|IFILE
name|ifile
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NMARKS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|marks
index|[
name|i
index|]
operator|.
name|m_ifile
operator|==
name|ifile
condition|)
name|marks
index|[
name|i
index|]
operator|.
name|m_scrpos
operator|.
name|pos
operator|=
name|NULL_POSITION
expr_stmt|;
block|}
end_function

end_unit

