begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1984-2000  Mark Nudelman  *  * You may distribute under the terms of either the GNU General Public  * License or the Less License, as specified in the README file.  *  * For more information about less, or for information on how to   * contact the author, see the README file.  */
end_comment

begin_comment
comment|/*  * Low level character input from the input file.  * We use these special purpose routines which optimize moving  * both forward and backward from the current read pointer.  */
end_comment

begin_include
include|#
directive|include
file|"less.h"
end_include

begin_if
if|#
directive|if
name|MSDOS_COMPILER
operator|==
name|WIN32C
end_if

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|POSITION
name|BLOCKNUM
typedef|;
end_typedef

begin_decl_stmt
name|public
name|int
name|ignore_eoi
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Pool of buffers holding the most recently used blocks of the input file.  * The buffer pool is kept as a doubly-linked circular list,  * in order from most- to least-recently used.  * The circular list is anchored by the file state "thisfile".  */
end_comment

begin_define
define|#
directive|define
name|LBUFSIZE
value|8192
end_define

begin_struct
struct|struct
name|buf
block|{
name|struct
name|buf
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|struct
name|buf
modifier|*
name|hnext
decl_stmt|,
modifier|*
name|hprev
decl_stmt|;
name|BLOCKNUM
name|block
decl_stmt|;
name|unsigned
name|int
name|datasize
decl_stmt|;
name|unsigned
name|char
name|data
index|[
name|LBUFSIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|buflist
block|{
comment|/* -- Following members must match struct buf */
name|struct
name|buf
modifier|*
name|buf_next
decl_stmt|,
modifier|*
name|buf_prev
decl_stmt|;
name|struct
name|buf
modifier|*
name|buf_hnext
decl_stmt|,
modifier|*
name|buf_hprev
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * The file state is maintained in a filestate structure.  * A pointer to the filestate is kept in the ifile structure.  */
end_comment

begin_define
define|#
directive|define
name|BUFHASH_SIZE
value|64
end_define

begin_struct
struct|struct
name|filestate
block|{
name|struct
name|buf
modifier|*
name|buf_next
decl_stmt|,
modifier|*
name|buf_prev
decl_stmt|;
name|struct
name|buflist
name|hashtbl
index|[
name|BUFHASH_SIZE
index|]
decl_stmt|;
name|int
name|file
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|POSITION
name|fpos
decl_stmt|;
name|int
name|nbufs
decl_stmt|;
name|BLOCKNUM
name|block
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
name|POSITION
name|fsize
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ch_bufhead
value|thisfile->buf_next
end_define

begin_define
define|#
directive|define
name|ch_buftail
value|thisfile->buf_prev
end_define

begin_define
define|#
directive|define
name|ch_nbufs
value|thisfile->nbufs
end_define

begin_define
define|#
directive|define
name|ch_block
value|thisfile->block
end_define

begin_define
define|#
directive|define
name|ch_offset
value|thisfile->offset
end_define

begin_define
define|#
directive|define
name|ch_fpos
value|thisfile->fpos
end_define

begin_define
define|#
directive|define
name|ch_fsize
value|thisfile->fsize
end_define

begin_define
define|#
directive|define
name|ch_flags
value|thisfile->flags
end_define

begin_define
define|#
directive|define
name|ch_file
value|thisfile->file
end_define

begin_define
define|#
directive|define
name|END_OF_CHAIN
value|((struct buf *)&thisfile->buf_next)
end_define

begin_define
define|#
directive|define
name|END_OF_HCHAIN
parameter_list|(
name|h
parameter_list|)
value|((struct buf *)&thisfile->hashtbl[h])
end_define

begin_define
define|#
directive|define
name|BUFHASH
parameter_list|(
name|blk
parameter_list|)
value|((blk)& (BUFHASH_SIZE-1))
end_define

begin_define
define|#
directive|define
name|FOR_BUFS_IN_CHAIN
parameter_list|(
name|h
parameter_list|,
name|bp
parameter_list|)
define|\
value|for (bp = thisfile->hashtbl[h].buf_hnext;  \ 	     bp != END_OF_HCHAIN(h);  bp = bp->hnext)
end_define

begin_define
define|#
directive|define
name|HASH_RM
parameter_list|(
name|bp
parameter_list|)
define|\
value|(bp)->hnext->hprev = (bp)->hprev; \ 	(bp)->hprev->hnext = (bp)->hnext;
end_define

begin_define
define|#
directive|define
name|HASH_INS
parameter_list|(
name|bp
parameter_list|,
name|h
parameter_list|)
define|\
value|(bp)->hnext = thisfile->hashtbl[h].buf_hnext; \ 	(bp)->hprev = END_OF_HCHAIN(h); \ 	thisfile->hashtbl[h].buf_hnext->hprev = (bp); \ 	thisfile->hashtbl[h].buf_hnext = (bp);
end_define

begin_decl_stmt
specifier|static
name|struct
name|filestate
modifier|*
name|thisfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ch_ungotchar
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|autobuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sigs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|cbufs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|secure
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|constant
name|char
name|helpdata
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|constant
name|int
name|size_helpdata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|IFILE
name|curr_ifile
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|LOGFILE
end_if

begin_decl_stmt
specifier|extern
name|int
name|logfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|namelogfile
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|ch_addbuf
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Get the character pointed to by the read pointer.  * ch_get() is a macro which is more efficient to call  * than fch_get (the function), in the usual case   * that the block desired is at the head of the chain.  */
end_comment

begin_define
define|#
directive|define
name|ch_get
parameter_list|()
value|((ch_block == ch_bufhead->block&& \ 		     ch_offset< ch_bufhead->datasize) ? \ 			ch_bufhead->data[ch_offset] : fch_get())
end_define

begin_function
name|int
name|fch_get
parameter_list|()
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|int
name|slept
decl_stmt|;
specifier|register
name|int
name|h
decl_stmt|;
name|POSITION
name|pos
decl_stmt|;
name|POSITION
name|len
decl_stmt|;
name|slept
operator|=
name|FALSE
expr_stmt|;
comment|/* 	 * Look for a buffer holding the desired block. 	 */
name|h
operator|=
name|BUFHASH
argument_list|(
name|ch_block
argument_list|)
expr_stmt|;
name|FOR_BUFS_IN_CHAIN
argument_list|(
argument|h
argument_list|,
argument|bp
argument_list|)
block|{
if|if
condition|(
name|bp
operator|->
name|block
operator|==
name|ch_block
condition|)
block|{
if|if
condition|(
name|ch_offset
operator|>=
name|bp
operator|->
name|datasize
condition|)
comment|/* 				 * Need more data in this buffer. 				 */
goto|goto
name|read_more
goto|;
goto|goto
name|found
goto|;
block|}
block|}
comment|/* 	 * Block is not in a buffer.   	 * Take the least recently used buffer  	 * and read the desired block into it. 	 * If the LRU buffer has data in it,  	 * then maybe allocate a new buffer. 	 */
if|if
condition|(
name|ch_buftail
operator|==
name|END_OF_CHAIN
operator|||
name|ch_buftail
operator|->
name|block
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* 		 * There is no empty buffer to use. 		 * Allocate a new buffer if: 		 * 1. We can't seek on this file and -b is not in effect; or 		 * 2. We haven't allocated the max buffers for this file yet. 		 */
if|if
condition|(
operator|(
name|autobuf
operator|&&
operator|!
operator|(
name|ch_flags
operator|&
name|CH_CANSEEK
operator|)
operator|)
operator|||
operator|(
name|cbufs
operator|==
operator|-
literal|1
operator|||
name|ch_nbufs
operator|<
name|cbufs
operator|)
condition|)
if|if
condition|(
name|ch_addbuf
argument_list|()
condition|)
comment|/* 				 * Allocation failed: turn off autobuf. 				 */
name|autobuf
operator|=
name|OPT_OFF
expr_stmt|;
block|}
name|bp
operator|=
name|ch_buftail
expr_stmt|;
name|HASH_RM
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* Remove from old hash chain. */
name|bp
operator|->
name|block
operator|=
name|ch_block
expr_stmt|;
name|bp
operator|->
name|datasize
operator|=
literal|0
expr_stmt|;
name|HASH_INS
argument_list|(
name|bp
argument_list|,
name|h
argument_list|)
expr_stmt|;
comment|/* Insert into new hash chain. */
name|read_more
label|:
name|pos
operator|=
operator|(
name|ch_block
operator|*
name|LBUFSIZE
operator|)
operator|+
name|bp
operator|->
name|datasize
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|ch_length
argument_list|()
operator|)
operator|!=
name|NULL_POSITION
operator|&&
name|pos
operator|>=
name|len
condition|)
comment|/* 		 * At end of file. 		 */
return|return
operator|(
name|EOI
operator|)
return|;
if|if
condition|(
name|pos
operator|!=
name|ch_fpos
condition|)
block|{
comment|/* 		 * Not at the correct position: must seek. 		 * If input is a pipe, we're in trouble (can't seek on a pipe). 		 * Some data has been lost: just return "?". 		 */
if|if
condition|(
operator|!
operator|(
name|ch_flags
operator|&
name|CH_CANSEEK
operator|)
condition|)
return|return
operator|(
literal|'?'
operator|)
return|;
if|if
condition|(
name|lseek
argument_list|(
name|ch_file
argument_list|,
operator|(
name|off_t
operator|)
name|pos
argument_list|,
literal|0
argument_list|)
operator|==
name|BAD_LSEEK
condition|)
block|{
name|error
argument_list|(
literal|"seek error"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
name|clear_eol
argument_list|()
expr_stmt|;
return|return
operator|(
name|EOI
operator|)
return|;
block|}
name|ch_fpos
operator|=
name|pos
expr_stmt|;
block|}
comment|/* 	 * Read the block. 	 * If we read less than a full block, that's ok. 	 * We use partial block and pick up the rest next time. 	 */
if|if
condition|(
name|ch_ungotchar
operator|!=
operator|-
literal|1
condition|)
block|{
name|bp
operator|->
name|data
index|[
name|bp
operator|->
name|datasize
index|]
operator|=
name|ch_ungotchar
expr_stmt|;
name|n
operator|=
literal|1
expr_stmt|;
name|ch_ungotchar
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch_flags
operator|&
name|CH_HELPFILE
condition|)
block|{
name|bp
operator|->
name|data
index|[
name|bp
operator|->
name|datasize
index|]
operator|=
name|helpdata
index|[
name|ch_fpos
index|]
expr_stmt|;
name|n
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|iread
argument_list|(
name|ch_file
argument_list|,
operator|&
name|bp
operator|->
name|data
index|[
name|bp
operator|->
name|datasize
index|]
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|LBUFSIZE
operator|-
name|bp
operator|->
name|datasize
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
name|READ_INTR
condition|)
return|return
operator|(
name|EOI
operator|)
return|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|#
directive|if
name|MSDOS_COMPILER
operator|==
name|WIN32C
if|if
condition|(
name|errno
operator|!=
name|EPIPE
condition|)
endif|#
directive|endif
block|{
name|error
argument_list|(
literal|"read error"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
name|clear_eol
argument_list|()
expr_stmt|;
block|}
name|n
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
name|LOGFILE
comment|/* 	 * If we have a log file, write the new data to it. 	 */
if|if
condition|(
operator|!
name|secure
operator|&&
name|logfile
operator|>=
literal|0
operator|&&
name|n
operator|>
literal|0
condition|)
name|write
argument_list|(
name|logfile
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|bp
operator|->
name|data
index|[
name|bp
operator|->
name|datasize
index|]
argument_list|,
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ch_fpos
operator|+=
name|n
expr_stmt|;
name|bp
operator|->
name|datasize
operator|+=
name|n
expr_stmt|;
comment|/* 	 * If we have read to end of file, set ch_fsize to indicate 	 * the position of the end of file. 	 */
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|ch_fsize
operator|=
name|pos
expr_stmt|;
if|if
condition|(
name|ignore_eoi
condition|)
block|{
comment|/* 			 * We are ignoring EOF. 			 * Wait a while, then try again. 			 */
if|if
condition|(
operator|!
name|slept
condition|)
block|{
name|PARG
name|parg
decl_stmt|;
name|parg
operator|.
name|p_string
operator|=
name|wait_message
argument_list|()
expr_stmt|;
name|ierror
argument_list|(
literal|"%s"
argument_list|,
operator|&
name|parg
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|MSDOS_COMPILER
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|MSDOS_COMPILER
operator|==
name|WIN32C
name|Sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|slept
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|sigs
condition|)
return|return
operator|(
name|EOI
operator|)
return|;
block|}
name|found
label|:
if|if
condition|(
name|ch_bufhead
operator|!=
name|bp
condition|)
block|{
comment|/* 		 * Move the buffer to the head of the buffer chain. 		 * This orders the buffer chain, most- to least-recently used. 		 */
name|bp
operator|->
name|next
operator|->
name|prev
operator|=
name|bp
operator|->
name|prev
expr_stmt|;
name|bp
operator|->
name|prev
operator|->
name|next
operator|=
name|bp
operator|->
name|next
expr_stmt|;
name|bp
operator|->
name|next
operator|=
name|ch_bufhead
expr_stmt|;
name|bp
operator|->
name|prev
operator|=
name|END_OF_CHAIN
expr_stmt|;
name|ch_bufhead
operator|->
name|prev
operator|=
name|bp
expr_stmt|;
name|ch_bufhead
operator|=
name|bp
expr_stmt|;
comment|/* 		 * Move to head of hash chain too. 		 */
name|HASH_RM
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|HASH_INS
argument_list|(
name|bp
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ch_offset
operator|>=
name|bp
operator|->
name|datasize
condition|)
comment|/* 		 * After all that, we still don't have enough data. 		 * Go back and try again. 		 */
goto|goto
name|read_more
goto|;
return|return
operator|(
name|bp
operator|->
name|data
index|[
name|ch_offset
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ch_ungetchar is a rather kludgy and limited way to push   * a single char onto an input file descriptor.  */
end_comment

begin_function
name|public
name|void
name|ch_ungetchar
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
operator|&&
name|ch_ungotchar
operator|!=
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"ch_ungetchar overrun"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
name|ch_ungotchar
operator|=
name|c
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|LOGFILE
end_if

begin_comment
comment|/*  * Close the logfile.  * If we haven't read all of standard input into it, do that now.  */
end_comment

begin_function
name|public
name|void
name|end_logfile
parameter_list|()
block|{
specifier|static
name|int
name|tried
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|logfile
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
name|tried
operator|&&
name|ch_fsize
operator|==
name|NULL_POSITION
condition|)
block|{
name|tried
operator|=
name|TRUE
expr_stmt|;
name|ierror
argument_list|(
literal|"Finishing logfile"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
while|while
condition|(
name|ch_forw_get
argument_list|()
operator|!=
name|EOI
condition|)
if|if
condition|(
name|ABORT_SIGS
argument_list|()
condition|)
break|break;
block|}
name|close
argument_list|(
name|logfile
argument_list|)
expr_stmt|;
name|logfile
operator|=
operator|-
literal|1
expr_stmt|;
name|namelogfile
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start a log file AFTER less has already been running.  * Invoked from the - command; see toggle_option().  * Write all the existing buffered data to the log file.  */
end_comment

begin_function
name|public
name|void
name|sync_logfile
parameter_list|()
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|warned
init|=
name|FALSE
decl_stmt|;
name|BLOCKNUM
name|block
decl_stmt|;
name|BLOCKNUM
name|nblocks
decl_stmt|;
name|nblocks
operator|=
operator|(
name|ch_fpos
operator|+
name|LBUFSIZE
operator|-
literal|1
operator|)
operator|/
name|LBUFSIZE
expr_stmt|;
for|for
control|(
name|block
operator|=
literal|0
init|;
name|block
operator|<
name|nblocks
condition|;
name|block
operator|++
control|)
block|{
for|for
control|(
name|bp
operator|=
name|ch_bufhead
init|;
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|bp
operator|==
name|END_OF_CHAIN
condition|)
block|{
if|if
condition|(
operator|!
name|warned
condition|)
block|{
name|error
argument_list|(
literal|"Warning: log file is incomplete"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
name|warned
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|bp
operator|->
name|block
operator|==
name|block
condition|)
block|{
name|write
argument_list|(
name|logfile
argument_list|,
operator|(
name|char
operator|*
operator|)
name|bp
operator|->
name|data
argument_list|,
name|bp
operator|->
name|datasize
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Determine if a specific block is currently in one of the buffers.  */
end_comment

begin_function
specifier|static
name|int
name|buffered
parameter_list|(
name|block
parameter_list|)
name|BLOCKNUM
name|block
decl_stmt|;
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|int
name|h
decl_stmt|;
name|h
operator|=
name|BUFHASH
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|FOR_BUFS_IN_CHAIN
argument_list|(
argument|h
argument_list|,
argument|bp
argument_list|)
block|{
if|if
condition|(
name|bp
operator|->
name|block
operator|==
name|block
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Seek to a specified position in the file.  * Return 0 if successful, non-zero if can't seek there.  */
end_comment

begin_function
name|public
name|int
name|ch_seek
parameter_list|(
name|pos
parameter_list|)
specifier|register
name|POSITION
name|pos
decl_stmt|;
block|{
name|BLOCKNUM
name|new_block
decl_stmt|;
name|POSITION
name|len
decl_stmt|;
name|len
operator|=
name|ch_length
argument_list|()
expr_stmt|;
if|if
condition|(
name|pos
operator|<
name|ch_zero
argument_list|()
operator|||
operator|(
name|len
operator|!=
name|NULL_POSITION
operator|&&
name|pos
operator|>
name|len
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|new_block
operator|=
name|pos
operator|/
name|LBUFSIZE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ch_flags
operator|&
name|CH_CANSEEK
operator|)
operator|&&
name|pos
operator|!=
name|ch_fpos
operator|&&
operator|!
name|buffered
argument_list|(
name|new_block
argument_list|)
condition|)
block|{
if|if
condition|(
name|ch_fpos
operator|>
name|pos
condition|)
return|return
operator|(
literal|1
operator|)
return|;
while|while
condition|(
name|ch_fpos
operator|<
name|pos
condition|)
block|{
if|if
condition|(
name|ch_forw_get
argument_list|()
operator|==
name|EOI
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|ABORT_SIGS
argument_list|()
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Set read pointer. 	 */
name|ch_block
operator|=
name|new_block
expr_stmt|;
name|ch_offset
operator|=
name|pos
operator|%
name|LBUFSIZE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Seek to the end of the file.  */
end_comment

begin_function
name|public
name|int
name|ch_end_seek
parameter_list|()
block|{
name|POSITION
name|len
decl_stmt|;
if|if
condition|(
name|ch_flags
operator|&
name|CH_CANSEEK
condition|)
name|ch_fsize
operator|=
name|filesize
argument_list|(
name|ch_file
argument_list|)
expr_stmt|;
name|len
operator|=
name|ch_length
argument_list|()
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|NULL_POSITION
condition|)
return|return
operator|(
name|ch_seek
argument_list|(
name|len
argument_list|)
operator|)
return|;
comment|/* 	 * Do it the slow way: read till end of data. 	 */
while|while
condition|(
name|ch_forw_get
argument_list|()
operator|!=
name|EOI
condition|)
if|if
condition|(
name|ABORT_SIGS
argument_list|()
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Seek to the beginning of the file, or as close to it as we can get.  * We may not be able to seek there if input is a pipe and the  * beginning of the pipe is no longer buffered.  */
end_comment

begin_function
name|public
name|int
name|ch_beg_seek
parameter_list|()
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|firstbp
decl_stmt|;
comment|/* 	 * Try a plain ch_seek first. 	 */
if|if
condition|(
name|ch_seek
argument_list|(
name|ch_zero
argument_list|()
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Can't get to position 0. 	 * Look thru the buffers for the one closest to position 0. 	 */
name|firstbp
operator|=
name|bp
operator|=
name|ch_bufhead
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|END_OF_CHAIN
condition|)
return|return
operator|(
literal|1
operator|)
return|;
while|while
condition|(
operator|(
name|bp
operator|=
name|bp
operator|->
name|next
operator|)
operator|!=
name|END_OF_CHAIN
condition|)
if|if
condition|(
name|bp
operator|->
name|block
operator|<
name|firstbp
operator|->
name|block
condition|)
name|firstbp
operator|=
name|bp
expr_stmt|;
name|ch_block
operator|=
name|firstbp
operator|->
name|block
expr_stmt|;
name|ch_offset
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the length of the file, if known.  */
end_comment

begin_function
name|public
name|POSITION
name|ch_length
parameter_list|()
block|{
if|if
condition|(
name|ignore_eoi
condition|)
return|return
operator|(
name|NULL_POSITION
operator|)
return|;
if|if
condition|(
name|ch_flags
operator|&
name|CH_HELPFILE
condition|)
return|return
operator|(
name|size_helpdata
operator|)
return|;
return|return
operator|(
name|ch_fsize
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the current position in the file.  */
end_comment

begin_function
name|public
name|POSITION
name|ch_tell
parameter_list|()
block|{
return|return
operator|(
name|ch_block
operator|*
name|LBUFSIZE
operator|)
operator|+
name|ch_offset
return|;
block|}
end_function

begin_comment
comment|/*  * Get the current char and post-increment the read pointer.  */
end_comment

begin_function
name|public
name|int
name|ch_forw_get
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|c
operator|=
name|ch_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOI
condition|)
return|return
operator|(
name|EOI
operator|)
return|;
if|if
condition|(
name|ch_offset
operator|<
name|LBUFSIZE
operator|-
literal|1
condition|)
name|ch_offset
operator|++
expr_stmt|;
else|else
block|{
name|ch_block
operator|++
expr_stmt|;
name|ch_offset
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pre-decrement the read pointer and get the new current char.  */
end_comment

begin_function
name|public
name|int
name|ch_back_get
parameter_list|()
block|{
if|if
condition|(
name|ch_offset
operator|>
literal|0
condition|)
name|ch_offset
operator|--
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ch_block
operator|<=
literal|0
condition|)
return|return
operator|(
name|EOI
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|ch_flags
operator|&
name|CH_CANSEEK
operator|)
operator|&&
operator|!
name|buffered
argument_list|(
name|ch_block
operator|-
literal|1
argument_list|)
condition|)
return|return
operator|(
name|EOI
operator|)
return|;
name|ch_block
operator|--
expr_stmt|;
name|ch_offset
operator|=
name|LBUFSIZE
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|ch_get
argument_list|()
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate buffers.  * Caller wants us to have a total of at least want_nbufs buffers.  */
end_comment

begin_function
name|public
name|int
name|ch_nbuf
parameter_list|(
name|want_nbufs
parameter_list|)
name|int
name|want_nbufs
decl_stmt|;
block|{
name|PARG
name|parg
decl_stmt|;
while|while
condition|(
name|ch_nbufs
operator|<
name|want_nbufs
condition|)
block|{
if|if
condition|(
name|ch_addbuf
argument_list|()
condition|)
block|{
comment|/* 			 * Cannot allocate enough buffers. 			 * If we don't have ANY, then quit. 			 * Otherwise, just report the error and return. 			 */
name|parg
operator|.
name|p_int
operator|=
name|want_nbufs
operator|-
name|ch_nbufs
expr_stmt|;
name|error
argument_list|(
literal|"Cannot allocate %d buffers"
argument_list|,
operator|&
name|parg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch_nbufs
operator|==
literal|0
condition|)
name|quit
argument_list|(
name|QUIT_ERROR
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|ch_nbufs
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Flush (discard) any saved file state, including buffer contents.  */
end_comment

begin_function
name|public
name|void
name|ch_flush
parameter_list|()
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ch_flags
operator|&
name|CH_CANSEEK
operator|)
condition|)
block|{
comment|/* 		 * If input is a pipe, we don't flush buffer contents, 		 * since the contents can't be recovered. 		 */
name|ch_fsize
operator|=
name|NULL_POSITION
expr_stmt|;
return|return;
block|}
comment|/* 	 * Initialize all the buffers. 	 */
for|for
control|(
name|bp
operator|=
name|ch_bufhead
init|;
name|bp
operator|!=
name|END_OF_CHAIN
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
name|bp
operator|->
name|block
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 	 * Figure out the size of the file, if we can. 	 */
name|ch_fsize
operator|=
name|filesize
argument_list|(
name|ch_file
argument_list|)
expr_stmt|;
comment|/* 	 * Seek to a known position: the beginning of the file. 	 */
name|ch_fpos
operator|=
literal|0
expr_stmt|;
name|ch_block
operator|=
literal|0
expr_stmt|;
comment|/* ch_fpos / LBUFSIZE; */
name|ch_offset
operator|=
literal|0
expr_stmt|;
comment|/* ch_fpos % LBUFSIZE; */
if|#
directive|if
literal|1
comment|/* 	 * This is a kludge to workaround a Linux kernel bug: files in 	 * /proc have a size of 0 according to fstat() but have readable  	 * data.  They are sometimes, but not always, seekable. 	 * Force them to be non-seekable here. 	 */
if|if
condition|(
name|ch_fsize
operator|==
literal|0
condition|)
block|{
name|ch_fsize
operator|=
name|NULL_POSITION
expr_stmt|;
name|ch_flags
operator|&=
operator|~
name|CH_CANSEEK
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|lseek
argument_list|(
name|ch_file
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
name|BAD_LSEEK
condition|)
block|{
comment|/* 		 * Warning only; even if the seek fails for some reason, 		 * there's a good chance we're at the beginning anyway. 		 * {{ I think this is bogus reasoning. }} 		 */
name|error
argument_list|(
literal|"seek error to 0"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Allocate a new buffer.  * The buffer is added to the tail of the buffer chain.  */
end_comment

begin_function
specifier|static
name|int
name|ch_addbuf
parameter_list|()
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* 	 * Allocate and initialize a new buffer and link it  	 * onto the tail of the buffer list. 	 */
name|bp
operator|=
operator|(
expr|struct
name|buf
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ch_nbufs
operator|++
expr_stmt|;
name|bp
operator|->
name|block
operator|=
operator|-
literal|1
expr_stmt|;
name|bp
operator|->
name|next
operator|=
name|END_OF_CHAIN
expr_stmt|;
name|bp
operator|->
name|prev
operator|=
name|ch_buftail
expr_stmt|;
name|ch_buftail
operator|->
name|next
operator|=
name|bp
expr_stmt|;
name|ch_buftail
operator|=
name|bp
expr_stmt|;
name|HASH_INS
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
specifier|static
name|void
name|init_hashtbl
parameter_list|()
block|{
specifier|register
name|int
name|h
decl_stmt|;
for|for
control|(
name|h
operator|=
literal|0
init|;
name|h
operator|<
name|BUFHASH_SIZE
condition|;
name|h
operator|++
control|)
block|{
name|thisfile
operator|->
name|hashtbl
index|[
name|h
index|]
operator|.
name|buf_hnext
operator|=
name|END_OF_HCHAIN
argument_list|(
name|h
argument_list|)
expr_stmt|;
name|thisfile
operator|->
name|hashtbl
index|[
name|h
index|]
operator|.
name|buf_hprev
operator|=
name|END_OF_HCHAIN
argument_list|(
name|h
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Delete all buffers for this file.  */
end_comment

begin_function
specifier|static
name|void
name|ch_delbufs
parameter_list|()
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
while|while
condition|(
name|ch_bufhead
operator|!=
name|END_OF_CHAIN
condition|)
block|{
name|bp
operator|=
name|ch_bufhead
expr_stmt|;
name|bp
operator|->
name|next
operator|->
name|prev
operator|=
name|bp
operator|->
name|prev
expr_stmt|;
empty_stmt|;
name|bp
operator|->
name|prev
operator|->
name|next
operator|=
name|bp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|ch_nbufs
operator|=
literal|0
expr_stmt|;
name|init_hashtbl
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Is it possible to seek on a file descriptor?  */
end_comment

begin_function
name|public
name|int
name|seekable
parameter_list|(
name|f
parameter_list|)
name|int
name|f
decl_stmt|;
block|{
if|#
directive|if
name|MSDOS_COMPILER
specifier|extern
name|int
name|fd0
decl_stmt|;
if|if
condition|(
name|f
operator|==
name|fd0
operator|&&
operator|!
name|isatty
argument_list|(
name|fd0
argument_list|)
condition|)
block|{
comment|/* 		 * In MS-DOS, pipes are seekable.  Check for 		 * standard input, and pretend it is not seekable. 		 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
name|lseek
argument_list|(
name|f
argument_list|,
operator|(
name|off_t
operator|)
literal|1
argument_list|,
literal|0
argument_list|)
operator|!=
name|BAD_LSEEK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize file state for a new file.  */
end_comment

begin_function
name|public
name|void
name|ch_init
parameter_list|(
name|f
parameter_list|,
name|flags
parameter_list|)
name|int
name|f
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
comment|/* 	 * See if we already have a filestate for this file. 	 */
name|thisfile
operator|=
operator|(
expr|struct
name|filestate
operator|*
operator|)
name|get_filestate
argument_list|(
name|curr_ifile
argument_list|)
expr_stmt|;
if|if
condition|(
name|thisfile
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Allocate and initialize a new filestate. 		 */
name|thisfile
operator|=
operator|(
expr|struct
name|filestate
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|filestate
argument_list|)
argument_list|)
expr_stmt|;
name|thisfile
operator|->
name|buf_next
operator|=
name|thisfile
operator|->
name|buf_prev
operator|=
name|END_OF_CHAIN
expr_stmt|;
name|thisfile
operator|->
name|nbufs
operator|=
literal|0
expr_stmt|;
name|thisfile
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|thisfile
operator|->
name|fpos
operator|=
literal|0
expr_stmt|;
name|thisfile
operator|->
name|block
operator|=
literal|0
expr_stmt|;
name|thisfile
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|thisfile
operator|->
name|file
operator|=
operator|-
literal|1
expr_stmt|;
name|thisfile
operator|->
name|fsize
operator|=
name|NULL_POSITION
expr_stmt|;
name|ch_flags
operator|=
name|flags
expr_stmt|;
name|init_hashtbl
argument_list|()
expr_stmt|;
comment|/* 		 * Try to seek; set CH_CANSEEK if it works. 		 */
if|if
condition|(
operator|(
name|flags
operator|&
name|CH_CANSEEK
operator|)
operator|&&
operator|!
name|seekable
argument_list|(
name|f
argument_list|)
condition|)
name|ch_flags
operator|&=
operator|~
name|CH_CANSEEK
expr_stmt|;
name|set_filestate
argument_list|(
name|curr_ifile
argument_list|,
operator|(
name|void
operator|*
operator|)
name|thisfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|thisfile
operator|->
name|file
operator|==
operator|-
literal|1
condition|)
name|thisfile
operator|->
name|file
operator|=
name|f
expr_stmt|;
name|ch_flush
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Close a filestate.  */
end_comment

begin_function
name|public
name|void
name|ch_close
parameter_list|()
block|{
name|int
name|keepstate
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|ch_flags
operator|&
operator|(
name|CH_CANSEEK
operator||
name|CH_POPENED
operator||
name|CH_HELPFILE
operator|)
condition|)
block|{
comment|/* 		 * We can seek or re-open, so we don't need to keep buffers. 		 */
name|ch_delbufs
argument_list|()
expr_stmt|;
block|}
else|else
name|keepstate
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ch_flags
operator|&
name|CH_KEEPOPEN
operator|)
condition|)
block|{
comment|/* 		 * We don't need to keep the file descriptor open 		 * (because we can re-open it.) 		 * But don't really close it if it was opened via popen(), 		 * because pclose() wants to close it. 		 */
if|if
condition|(
operator|!
operator|(
name|ch_flags
operator|&
operator|(
name|CH_POPENED
operator||
name|CH_HELPFILE
operator|)
operator|)
condition|)
name|close
argument_list|(
name|ch_file
argument_list|)
expr_stmt|;
name|ch_file
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|keepstate
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|keepstate
condition|)
block|{
comment|/* 		 * We don't even need to keep the filestate structure. 		 */
name|free
argument_list|(
name|thisfile
argument_list|)
expr_stmt|;
name|thisfile
operator|=
name|NULL
expr_stmt|;
name|set_filestate
argument_list|(
name|curr_ifile
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Return ch_flags for the current file.  */
end_comment

begin_function
name|public
name|int
name|ch_getflags
parameter_list|()
block|{
return|return
operator|(
name|ch_flags
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|public void ch_dump(struct filestate *fs) { 	struct buf *bp; 	unsigned char *s;  	if (fs == NULL) 	{ 		printf(" --no filestate\n"); 		return; 	} 	printf(" file %d, flags %x, fpos %x, fsize %x, blk/off %x/%x\n", 		fs->file, fs->flags, fs->fpos,  		fs->fsize, fs->block, fs->offset); 	printf(" %d bufs:\n", fs->nbufs); 	for (bp = fs->buf_next; bp != (struct buf *)fs;  bp = bp->next) 	{ 		printf("%x: blk %x, size %x \"", 			bp, bp->block, bp->datasize); 		for (s = bp->data;  s< bp->data + 30;  s++) 			if (*s>= ' '&& *s< 0x7F) 				printf("%c", *s); 			else 				printf("."); 		printf("\"\n"); 	} }
endif|#
directive|endif
end_endif

end_unit

