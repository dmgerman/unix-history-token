begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1984-2000  Mark Nudelman  *  * You may distribute under the terms of either the GNU General Public  * License or the Less License, as specified in the README file.  *  * For more information about less, or for information on how to   * contact the author, see the README file.  */
end_comment

begin_comment
comment|/*  * Routines to mess around with filenames (and files).  * Much of this is very OS dependent.  */
end_comment

begin_include
include|#
directive|include
file|"less.h"
end_include

begin_include
include|#
directive|include
file|"lglob.h"
end_include

begin_if
if|#
directive|if
name|MSDOS_COMPILER
end_if

begin_include
include|#
directive|include
file|<dos.h>
end_include

begin_if
if|#
directive|if
name|MSDOS_COMPILER
operator|==
name|WIN32C
operator|&&
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_if

begin_include
include|#
directive|include
file|<dir.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|MSDOS_COMPILER
operator|==
name|DJGPPC
end_if

begin_include
include|#
directive|include
file|<glob.h>
end_include

begin_include
include|#
directive|include
file|<dir.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_define
define|#
directive|define
name|_MAX_PATH
value|PATH_MAX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_OSK
end_ifdef

begin_include
include|#
directive|include
file|<rbf.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_OSK_MWC32
end_ifndef

begin_include
include|#
directive|include
file|<modes.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_STAT
end_if

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|S_ISDIR
end_ifndef

begin_define
define|#
directive|define
name|S_ISDIR
parameter_list|(
name|m
parameter_list|)
value|(((m)& S_IFMT) == S_IFDIR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|S_ISREG
end_ifndef

begin_define
define|#
directive|define
name|S_ISREG
parameter_list|(
name|m
parameter_list|)
value|(((m)& S_IFMT) == S_IFREG)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|force_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|secure
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|IFILE
name|curr_ifile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|IFILE
name|old_ifile
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|SPACES_IN_FILENAMES
end_if

begin_decl_stmt
specifier|extern
name|char
name|openquote
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|closequote
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Remove quotes around a filename.  */
end_comment

begin_function
name|public
name|char
modifier|*
name|unquote_file
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
if|#
directive|if
name|SPACES_IN_FILENAMES
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|*
name|str
operator|!=
name|openquote
condition|)
return|return
operator|(
name|save
argument_list|(
name|str
argument_list|)
operator|)
return|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|ecalloc
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|str
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|name
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
name|closequote
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|name
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|save
argument_list|(
name|str
argument_list|)
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Return a pathname that points to a specified file in a specified directory.  * Return NULL if the file does not exist in the directory.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|dirfile
parameter_list|(
name|dirname
parameter_list|,
name|filename
parameter_list|)
name|char
modifier|*
name|dirname
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|char
modifier|*
name|pathname
decl_stmt|;
name|char
modifier|*
name|qpathname
decl_stmt|;
name|int
name|f
decl_stmt|;
if|if
condition|(
name|dirname
operator|==
name|NULL
operator|||
operator|*
name|dirname
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * Construct the full pathname. 	 */
name|pathname
operator|=
operator|(
name|char
operator|*
operator|)
name|calloc
argument_list|(
name|strlen
argument_list|(
name|dirname
argument_list|)
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|2
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pathname
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|sprintf
argument_list|(
name|pathname
argument_list|,
literal|"%s%s%s"
argument_list|,
name|dirname
argument_list|,
name|PATHNAME_SEP
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure the file exists. 	 */
name|qpathname
operator|=
name|unquote_file
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
name|f
operator|=
name|open
argument_list|(
name|qpathname
argument_list|,
name|OPEN_READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
name|pathname
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|qpathname
argument_list|)
expr_stmt|;
return|return
operator|(
name|pathname
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the full pathname of the given file in the "home directory".  */
end_comment

begin_function
name|public
name|char
modifier|*
name|homefile
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|pathname
decl_stmt|;
comment|/* 	 * Try $HOME/filename. 	 */
name|pathname
operator|=
name|dirfile
argument_list|(
name|lgetenv
argument_list|(
literal|"HOME"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|pathname
operator|!=
name|NULL
condition|)
return|return
operator|(
name|pathname
operator|)
return|;
if|#
directive|if
name|OS2
comment|/* 	 * Try $INIT/filename. 	 */
name|pathname
operator|=
name|dirfile
argument_list|(
name|lgetenv
argument_list|(
literal|"INIT"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|pathname
operator|!=
name|NULL
condition|)
return|return
operator|(
name|pathname
operator|)
return|;
endif|#
directive|endif
if|#
directive|if
name|MSDOS_COMPILER
operator|||
name|OS2
comment|/* 	 * Look for the file anywhere on search path. 	 */
name|pathname
operator|=
operator|(
name|char
operator|*
operator|)
name|calloc
argument_list|(
name|_MAX_PATH
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|MSDOS_COMPILER
operator|==
name|DJGPPC
block|{
name|char
modifier|*
name|res
init|=
name|searchpath
argument_list|(
name|filename
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
operator|*
name|pathname
operator|=
literal|'\0'
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|pathname
argument_list|,
name|res
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|_searchenv
argument_list|(
name|filename
argument_list|,
literal|"PATH"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|*
name|pathname
operator|!=
literal|'\0'
condition|)
return|return
operator|(
name|pathname
operator|)
return|;
name|free
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Expand a string, substituting any "%" with the current filename,  * and any "#" with the previous filename.  * But a string of N "%"s is just replaced with N-1 "%"s.  * Likewise for a string of N "#"s.  * {{ This is a lot of work just to support % and #. }}  */
end_comment

begin_function
name|public
name|char
modifier|*
name|fexpand
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|fr
decl_stmt|,
modifier|*
name|to
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|char
modifier|*
name|e
decl_stmt|;
name|IFILE
name|ifile
decl_stmt|;
define|#
directive|define
name|fchar_ifile
parameter_list|(
name|c
parameter_list|)
define|\
value|((c) == '%' ? curr_ifile : \ 	 (c) == '#' ? old_ifile : NULL_IFILE)
comment|/* 	 * Make one pass to see how big a buffer we  	 * need to allocate for the expanded string. 	 */
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fr
operator|=
name|s
init|;
operator|*
name|fr
operator|!=
literal|'\0'
condition|;
name|fr
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|fr
condition|)
block|{
case|case
literal|'%'
case|:
case|case
literal|'#'
case|:
if|if
condition|(
name|fr
operator|>
name|s
operator|&&
name|fr
index|[
operator|-
literal|1
index|]
operator|==
operator|*
name|fr
condition|)
block|{
comment|/* 				 * Second (or later) char in a string 				 * of identical chars.  Treat as normal. 				 */
name|n
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fr
index|[
literal|1
index|]
operator|!=
operator|*
name|fr
condition|)
block|{
comment|/* 				 * Single char (not repeated).  Treat specially. 				 */
name|ifile
operator|=
name|fchar_ifile
argument_list|(
operator|*
name|fr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifile
operator|==
name|NULL_IFILE
condition|)
name|n
operator|++
expr_stmt|;
else|else
name|n
operator|+=
name|strlen
argument_list|(
name|get_filename
argument_list|(
name|ifile
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Else it is the first char in a string of 			 * identical chars.  Just discard it. 			 */
break|break;
default|default:
name|n
operator|++
expr_stmt|;
break|break;
block|}
block|}
name|e
operator|=
operator|(
name|char
operator|*
operator|)
name|ecalloc
argument_list|(
name|n
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Now copy the string, expanding any "%" or "#". 	 */
name|to
operator|=
name|e
expr_stmt|;
for|for
control|(
name|fr
operator|=
name|s
init|;
operator|*
name|fr
operator|!=
literal|'\0'
condition|;
name|fr
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|fr
condition|)
block|{
case|case
literal|'%'
case|:
case|case
literal|'#'
case|:
if|if
condition|(
name|fr
operator|>
name|s
operator|&&
name|fr
index|[
operator|-
literal|1
index|]
operator|==
operator|*
name|fr
condition|)
block|{
operator|*
name|to
operator|++
operator|=
operator|*
name|fr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fr
index|[
literal|1
index|]
operator|!=
operator|*
name|fr
condition|)
block|{
name|ifile
operator|=
name|fchar_ifile
argument_list|(
operator|*
name|fr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifile
operator|==
name|NULL_IFILE
condition|)
operator|*
name|to
operator|++
operator|=
operator|*
name|fr
expr_stmt|;
else|else
block|{
name|strcpy
argument_list|(
name|to
argument_list|,
name|get_filename
argument_list|(
name|ifile
argument_list|)
argument_list|)
expr_stmt|;
name|to
operator|+=
name|strlen
argument_list|(
name|to
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
operator|*
name|to
operator|++
operator|=
operator|*
name|fr
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|to
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|e
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|TAB_COMPLETE_FILENAME
end_if

begin_comment
comment|/*  * Return a blank-separated list of filenames which "complete"  * the given string.  */
end_comment

begin_function
name|public
name|char
modifier|*
name|fcomplete
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|fpat
decl_stmt|;
if|if
condition|(
name|secure
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * Complete the filename "s" by globbing "s*". 	 */
if|#
directive|if
name|MSDOS_COMPILER
operator|&&
operator|(
name|MSDOS_COMPILER
operator|==
name|MSOFTC
operator|||
name|MSDOS_COMPILER
operator|==
name|BORLANDC
operator|)
comment|/* 	 * But in DOS, we have to glob "s*.*". 	 * But if the final component of the filename already has 	 * a dot in it, just do "s*".   	 * (Thus, "FILE" is globbed as "FILE*.*",  	 *  but "FILE.A" is globbed as "FILE.A*"). 	 */
block|{
name|char
modifier|*
name|slash
decl_stmt|;
for|for
control|(
name|slash
operator|=
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
operator|-
literal|1
init|;
name|slash
operator|>
name|s
condition|;
name|slash
operator|--
control|)
if|if
condition|(
operator|*
name|slash
operator|==
operator|*
name|PATHNAME_SEP
operator|||
operator|*
name|slash
operator|==
literal|'/'
condition|)
break|break;
name|fpat
operator|=
operator|(
name|char
operator|*
operator|)
name|ecalloc
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|4
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|slash
argument_list|,
literal|'.'
argument_list|)
operator|==
name|NULL
condition|)
name|sprintf
argument_list|(
name|fpat
argument_list|,
literal|"%s*.*"
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|fpat
argument_list|,
literal|"%s*"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|fpat
operator|=
operator|(
name|char
operator|*
operator|)
name|ecalloc
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|2
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|fpat
argument_list|,
literal|"%s*"
argument_list|,
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|lglob
argument_list|(
name|fpat
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
name|fpat
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * The filename didn't expand. 		 */
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|fpat
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Try to determine if a file is "binary".  * This is just a guess, and we need not try too hard to make it accurate.  */
end_comment

begin_function
name|public
name|int
name|bin_file
parameter_list|(
name|f
parameter_list|)
name|int
name|f
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|n
decl_stmt|;
name|unsigned
name|char
name|data
index|[
literal|64
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|seekable
argument_list|(
name|f
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|lseek
argument_list|(
name|f
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
name|BAD_LSEEK
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|n
operator|=
name|read
argument_list|(
name|f
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|binary_char
argument_list|(
name|data
index|[
name|i
index|]
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Try to determine the size of a file by seeking to the end.  */
end_comment

begin_function
specifier|static
name|POSITION
name|seek_filesize
parameter_list|(
name|f
parameter_list|)
name|int
name|f
decl_stmt|;
block|{
name|off_t
name|spos
decl_stmt|;
name|spos
operator|=
name|lseek
argument_list|(
name|f
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|spos
operator|==
name|BAD_LSEEK
condition|)
return|return
operator|(
name|NULL_POSITION
operator|)
return|;
return|return
operator|(
operator|(
name|POSITION
operator|)
name|spos
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read a string from a file.  * Return a pointer to the string in memory.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|readfd
parameter_list|(
name|fd
parameter_list|)
name|FILE
modifier|*
name|fd
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/*  	 * Make a guess about how many chars in the string 	 * and allocate a buffer to hold it. 	 */
name|len
operator|=
literal|100
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|ecalloc
argument_list|(
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|buf
init|;
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|fd
argument_list|)
operator|)
operator|==
literal|'\n'
operator|||
name|ch
operator|==
name|EOF
condition|)
break|break;
if|if
condition|(
name|p
operator|-
name|buf
operator|>=
name|len
operator|-
literal|1
condition|)
block|{
comment|/* 			 * The string is too big to fit in the buffer we have. 			 * Allocate a new buffer, twice as big. 			 */
name|len
operator|*=
literal|2
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|ecalloc
argument_list|(
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
name|ch
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|HAVE_SHELL
end_if

begin_comment
comment|/*  * Get the shell's escape character.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_meta_escape
parameter_list|()
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|lgetenv
argument_list|(
literal|"LESSMETAESCAPE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|s
operator|=
name|DEF_METAESCAPE
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Is this a shell metacharacter?  */
end_comment

begin_function
specifier|static
name|int
name|metachar
parameter_list|(
name|c
parameter_list|)
name|char
name|c
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|metachars
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|metachars
operator|==
name|NULL
condition|)
block|{
name|metachars
operator|=
name|lgetenv
argument_list|(
literal|"LESSMETACHARS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|metachars
operator|==
name|NULL
condition|)
name|metachars
operator|=
name|DEF_METACHARS
expr_stmt|;
block|}
return|return
operator|(
name|strchr
argument_list|(
name|metachars
argument_list|,
name|c
argument_list|)
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Insert a backslash before each metacharacter in a string.  */
end_comment

begin_function
name|public
name|char
modifier|*
name|esc_metachars
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|newstr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|esc
decl_stmt|;
name|int
name|esclen
decl_stmt|;
comment|/* 	 * Determine how big a string we need to allocate. 	 */
name|esc
operator|=
name|get_meta_escape
argument_list|()
expr_stmt|;
name|esclen
operator|=
name|strlen
argument_list|(
name|esc
argument_list|)
expr_stmt|;
name|len
operator|=
literal|1
expr_stmt|;
comment|/* Trailing null byte */
for|for
control|(
name|p
operator|=
name|s
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
name|len
operator|++
expr_stmt|;
if|if
condition|(
name|metachar
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|esc
operator|==
literal|'\0'
condition|)
block|{
comment|/* 				 * We've got a metachar, but this shell  				 * doesn't support escape chars.  Give up. 				 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 			 * Allow space for the escape char. 			 */
name|len
operator|+=
name|esclen
expr_stmt|;
block|}
block|}
comment|/* 	 * Allocate and construct the new string. 	 */
name|newstr
operator|=
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|ecalloc
argument_list|(
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|metachar
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
comment|/* 			 * Add the escape char. 			 */
name|strcpy
argument_list|(
name|p
argument_list|,
name|esc
argument_list|)
expr_stmt|;
name|p
operator|+=
name|esclen
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|newstr
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* HAVE_SHELL */
end_comment

begin_function
name|public
name|char
modifier|*
name|esc_metachars
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
return|return
operator|(
name|save
argument_list|(
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SHELL */
end_comment

begin_if
if|#
directive|if
name|HAVE_POPEN
end_if

begin_function_decl
name|FILE
modifier|*
name|popen
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Execute a shell command.  * Return a pointer to a pipe connected to the shell command's standard output.  */
end_comment

begin_function
specifier|static
name|FILE
modifier|*
name|shellcmd
parameter_list|(
name|cmd
parameter_list|)
name|char
modifier|*
name|cmd
decl_stmt|;
block|{
name|FILE
modifier|*
name|fd
decl_stmt|;
if|#
directive|if
name|HAVE_SHELL
name|char
modifier|*
name|shell
decl_stmt|;
name|shell
operator|=
name|lgetenv
argument_list|(
literal|"SHELL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|shell
operator|!=
name|NULL
operator|&&
operator|*
name|shell
operator|!=
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|scmd
decl_stmt|;
name|char
modifier|*
name|esccmd
decl_stmt|;
comment|/* 		 * Try to escape any metacharacters in the command. 		 * If we can't do that, just put the command in quotes. 		 * (But that doesn't work well if the command itself  		 * contains quotes.) 		 */
if|if
condition|(
operator|(
name|esccmd
operator|=
name|esc_metachars
argument_list|(
name|cmd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Cannot escape the metacharacters, so use quotes. 			 * Read the output of<$SHELL -c "cmd">. 			 */
name|scmd
operator|=
operator|(
name|char
operator|*
operator|)
name|ecalloc
argument_list|(
name|strlen
argument_list|(
name|shell
argument_list|)
operator|+
name|strlen
argument_list|(
name|cmd
argument_list|)
operator|+
literal|7
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|scmd
argument_list|,
literal|"%s -c \"%s\""
argument_list|,
name|shell
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Read the output of<$SHELL -c cmd>.   			 * No quotes; use the escaped cmd. 			 */
name|scmd
operator|=
operator|(
name|char
operator|*
operator|)
name|ecalloc
argument_list|(
name|strlen
argument_list|(
name|shell
argument_list|)
operator|+
name|strlen
argument_list|(
name|esccmd
argument_list|)
operator|+
literal|5
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|scmd
argument_list|,
literal|"%s -c %s"
argument_list|,
name|shell
argument_list|,
name|esccmd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|esccmd
argument_list|)
expr_stmt|;
block|}
name|fd
operator|=
name|popen
argument_list|(
name|scmd
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|scmd
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|fd
operator|=
name|popen
argument_list|(
name|cmd
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
comment|/* 		 * Redirection in `popen' might have messed with the 		 * standard devices.  Restore binary input mode. 		 */
name|SET_BINARY
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|fd
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_POPEN */
end_comment

begin_comment
comment|/*  * Expand a filename, doing any system-specific metacharacter substitutions.  */
end_comment

begin_function
name|public
name|char
modifier|*
name|lglob
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|char
modifier|*
name|gfilename
decl_stmt|;
name|char
modifier|*
name|ofilename
decl_stmt|;
name|ofilename
operator|=
name|fexpand
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|secure
condition|)
return|return
operator|(
name|ofilename
operator|)
return|;
name|filename
operator|=
name|unquote_file
argument_list|(
name|ofilename
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DECL_GLOB_LIST
block|{
comment|/* 	 * The globbing function returns a list of names. 	 */
name|int
name|length
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|DECL_GLOB_LIST
argument_list|(
argument|list
argument_list|)
name|GLOB_LIST
argument_list|(
name|filename
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|GLOB_LIST_FAILED
argument_list|(
name|list
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
name|ofilename
operator|)
return|;
block|}
name|length
operator|=
literal|1
expr_stmt|;
comment|/* Room for trailing null byte */
for|for
control|(
name|SCAN_GLOB_LIST
argument_list|(
name|list
argument_list|,
name|p
argument_list|)
control|)
block|{
name|INIT_GLOB_LIST
argument_list|(
name|list
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|length
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
expr_stmt|;
if|#
directive|if
name|SPACES_IN_FILENAMES
if|if
condition|(
name|strchr
argument_list|(
name|p
argument_list|,
literal|' '
argument_list|)
operator|!=
name|NULL
condition|)
name|length
operator|+=
literal|2
expr_stmt|;
comment|/* Allow for quotes */
endif|#
directive|endif
block|}
name|gfilename
operator|=
operator|(
name|char
operator|*
operator|)
name|ecalloc
argument_list|(
name|length
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|SCAN_GLOB_LIST
argument_list|(
name|list
argument_list|,
name|p
argument_list|)
control|)
block|{
name|INIT_GLOB_LIST
argument_list|(
name|list
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|#
directive|if
name|SPACES_IN_FILENAMES
if|if
condition|(
name|strchr
argument_list|(
name|p
argument_list|,
literal|' '
argument_list|)
operator|!=
name|NULL
condition|)
name|sprintf
argument_list|(
name|gfilename
operator|+
name|strlen
argument_list|(
name|gfilename
argument_list|)
argument_list|,
literal|"%c%s%c "
argument_list|,
name|openquote
argument_list|,
name|p
argument_list|,
name|closequote
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|sprintf
argument_list|(
name|gfilename
operator|+
name|strlen
argument_list|(
name|gfilename
argument_list|)
argument_list|,
literal|"%s "
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Overwrite the final trailing space with a null terminator. 	 */
operator|*
operator|--
name|p
operator|=
literal|'\0'
expr_stmt|;
name|GLOB_LIST_DONE
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
ifdef|#
directive|ifdef
name|DECL_GLOB_NAME
block|{
comment|/* 	 * The globbing function returns a single name, and 	 * is called multiple times to walk thru all names. 	 */
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
if|#
directive|if
name|SPACES_IN_FILENAMES
specifier|register
name|int
name|spaces_in_file
decl_stmt|;
endif|#
directive|endif
name|DECL_GLOB_NAME
argument_list|(
argument|fnd
argument_list|,
argument|drive
argument_list|,
argument|dir
argument_list|,
argument|fname
argument_list|,
argument|ext
argument_list|,
argument|handle
argument_list|)
name|GLOB_FIRST_NAME
argument_list|(
name|filename
argument_list|,
operator|&
name|fnd
argument_list|,
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|GLOB_FIRST_FAILED
argument_list|(
name|handle
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
name|ofilename
operator|)
return|;
block|}
name|_splitpath
argument_list|(
name|filename
argument_list|,
name|drive
argument_list|,
name|dir
argument_list|,
name|fname
argument_list|,
name|ext
argument_list|)
expr_stmt|;
name|len
operator|=
literal|100
expr_stmt|;
name|gfilename
operator|=
operator|(
name|char
operator|*
operator|)
name|ecalloc
argument_list|(
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|gfilename
expr_stmt|;
do|do
block|{
name|n
operator|=
name|strlen
argument_list|(
name|drive
argument_list|)
operator|+
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
name|strlen
argument_list|(
name|fnd
operator|.
name|GLOB_NAME
argument_list|)
operator|+
literal|1
expr_stmt|;
if|#
directive|if
name|SPACES_IN_FILENAMES
name|spaces_in_file
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|fnd
operator|.
name|GLOB_NAME
argument_list|,
literal|' '
argument_list|)
operator|!=
name|NULL
operator|||
name|strchr
argument_list|(
name|filename
argument_list|,
literal|' '
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|spaces_in_file
operator|=
literal|1
expr_stmt|;
name|n
operator|+=
literal|2
expr_stmt|;
block|}
endif|#
directive|endif
while|while
condition|(
name|p
operator|-
name|gfilename
operator|+
name|n
operator|+
literal|2
operator|>=
name|len
condition|)
block|{
comment|/* 			 * No room in current buffer.  Allocate a bigger one. 			 */
name|len
operator|*=
literal|2
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|ecalloc
argument_list|(
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|gfilename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|gfilename
argument_list|)
expr_stmt|;
name|gfilename
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|gfilename
operator|+
name|strlen
argument_list|(
name|gfilename
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|SPACES_IN_FILENAMES
if|if
condition|(
name|spaces_in_file
condition|)
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%c%s%s%s%c "
argument_list|,
name|openquote
argument_list|,
name|drive
argument_list|,
name|dir
argument_list|,
name|fnd
operator|.
name|GLOB_NAME
argument_list|,
name|closequote
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%s%s%s "
argument_list|,
name|drive
argument_list|,
name|dir
argument_list|,
name|fnd
operator|.
name|GLOB_NAME
argument_list|)
expr_stmt|;
name|p
operator|+=
name|n
expr_stmt|;
block|}
do|while
condition|(
name|GLOB_NEXT_NAME
argument_list|(
name|handle
argument_list|,
operator|&
name|fnd
argument_list|)
operator|==
literal|0
condition|)
do|;
comment|/* 	 * Overwrite the final trailing space with a null terminator. 	 */
operator|*
operator|--
name|p
operator|=
literal|'\0'
expr_stmt|;
name|GLOB_NAME_DONE
argument_list|(
name|handle
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|#
directive|if
name|HAVE_POPEN
block|{
comment|/* 	 * We get the shell to glob the filename for us by passing 	 * an "echo" command to the shell and reading its output. 	 */
name|FILE
modifier|*
name|fd
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|lessecho
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
name|lessecho
operator|=
name|lgetenv
argument_list|(
literal|"LESSECHO"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lessecho
operator|==
name|NULL
operator|||
operator|*
name|lessecho
operator|==
literal|'\0'
condition|)
name|lessecho
operator|=
literal|"lessecho"
expr_stmt|;
name|s
operator|=
name|esc_metachars
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * There may be dangerous metachars in this name. 		 * We can't risk passing it to the shell. 		 * {{ For example, do "!;TAB" when the first file  		 *    in the dir is named "rm". }} 		 */
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
name|ofilename
operator|)
return|;
block|}
comment|/* 	 * Invoke lessecho, and read its output (a globbed list of filenames). 	 */
name|cmd
operator|=
operator|(
name|char
operator|*
operator|)
name|ecalloc
argument_list|(
name|strlen
argument_list|(
name|lessecho
argument_list|)
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|24
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|cmd
argument_list|,
literal|"%s -p0x%x -d0x%x -- %s"
argument_list|,
name|lessecho
argument_list|,
name|openquote
argument_list|,
name|closequote
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|fd
operator|=
name|shellcmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Cannot create the pipe. 		 * Just return the original (fexpanded) filename. 		 */
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
name|ofilename
operator|)
return|;
block|}
name|gfilename
operator|=
name|readfd
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|pclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|gfilename
operator|==
literal|'\0'
condition|)
block|{
name|free
argument_list|(
name|gfilename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
name|ofilename
operator|)
return|;
block|}
block|}
else|#
directive|else
comment|/* 	 * No globbing functions at all.  Just use the fexpanded filename. 	 */
name|gfilename
operator|=
name|save
argument_list|(
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ofilename
argument_list|)
expr_stmt|;
return|return
operator|(
name|gfilename
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * See if we should open a "replacement file"   * instead of the file we're about to open.  */
end_comment

begin_function
name|public
name|char
modifier|*
name|open_altfile
parameter_list|(
name|filename
parameter_list|,
name|pf
parameter_list|,
name|pfd
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
modifier|*
name|pf
decl_stmt|;
name|void
modifier|*
modifier|*
name|pfd
decl_stmt|;
block|{
if|#
directive|if
operator|!
name|HAVE_POPEN
return|return
operator|(
name|NULL
operator|)
return|;
else|#
directive|else
name|char
modifier|*
name|lessopen
decl_stmt|;
name|char
modifier|*
name|gfilename
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
name|FILE
modifier|*
name|fd
decl_stmt|;
if|#
directive|if
name|HAVE_FILENO
name|int
name|returnfd
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|secure
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ch_ungetchar
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lessopen
operator|=
name|lgetenv
argument_list|(
literal|"LESSOPEN"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|filename
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|*
name|lessopen
operator|==
literal|'|'
condition|)
block|{
comment|/* 		 * If LESSOPEN starts with a |, it indicates  		 * a "pipe preprocessor". 		 */
if|#
directive|if
name|HAVE_FILENO
name|lessopen
operator|++
expr_stmt|;
name|returnfd
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|error
argument_list|(
literal|"LESSOPEN pipe is not supported"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
endif|#
directive|endif
block|}
name|gfilename
operator|=
name|esc_metachars
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|gfilename
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Cannot escape metacharacters. 		 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|cmd
operator|=
operator|(
name|char
operator|*
operator|)
name|ecalloc
argument_list|(
name|strlen
argument_list|(
name|lessopen
argument_list|)
operator|+
name|strlen
argument_list|(
name|gfilename
argument_list|)
operator|+
literal|2
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|cmd
argument_list|,
name|lessopen
argument_list|,
name|gfilename
argument_list|)
expr_stmt|;
name|fd
operator|=
name|shellcmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|gfilename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Cannot create the pipe. 		 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|#
directive|if
name|HAVE_FILENO
if|if
condition|(
name|returnfd
condition|)
block|{
name|int
name|f
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/* 		 * Read one char to see if the pipe will produce any data. 		 * If it does, push the char back on the pipe. 		 */
name|f
operator|=
name|fileno
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|SET_BINARY
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|f
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
block|{
comment|/* 			 * Pipe is empty.  This means there is no alt file. 			 */
name|pclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ch_ungetchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|*
name|pfd
operator|=
operator|(
name|void
operator|*
operator|)
name|fd
expr_stmt|;
operator|*
name|pf
operator|=
name|f
expr_stmt|;
return|return
operator|(
name|save
argument_list|(
literal|"-"
argument_list|)
operator|)
return|;
block|}
endif|#
directive|endif
name|gfilename
operator|=
name|readfd
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|pclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|gfilename
operator|==
literal|'\0'
condition|)
comment|/* 		 * Pipe is empty.  This means there is no alt file. 		 */
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|gfilename
operator|)
return|;
endif|#
directive|endif
comment|/* HAVE_POPEN */
block|}
end_function

begin_comment
comment|/*  * Close a replacement file.  */
end_comment

begin_function
name|public
name|void
name|close_altfile
parameter_list|(
name|altfilename
parameter_list|,
name|filename
parameter_list|,
name|pipefd
parameter_list|)
name|char
modifier|*
name|altfilename
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|void
modifier|*
name|pipefd
decl_stmt|;
block|{
if|#
directive|if
name|HAVE_POPEN
name|char
modifier|*
name|lessclose
decl_stmt|;
name|char
modifier|*
name|gfilename
decl_stmt|;
name|char
modifier|*
name|galtfilename
decl_stmt|;
name|FILE
modifier|*
name|fd
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
if|if
condition|(
name|secure
condition|)
return|return;
if|if
condition|(
name|pipefd
operator|!=
name|NULL
condition|)
name|pclose
argument_list|(
operator|(
name|FILE
operator|*
operator|)
name|pipefd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lessclose
operator|=
name|lgetenv
argument_list|(
literal|"LESSCLOSE"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|gfilename
operator|=
name|esc_metachars
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|gfilename
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|galtfilename
operator|=
name|esc_metachars
argument_list|(
name|altfilename
argument_list|)
expr_stmt|;
if|if
condition|(
name|galtfilename
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|gfilename
argument_list|)
expr_stmt|;
return|return;
block|}
name|cmd
operator|=
operator|(
name|char
operator|*
operator|)
name|ecalloc
argument_list|(
name|strlen
argument_list|(
name|lessclose
argument_list|)
operator|+
name|strlen
argument_list|(
name|gfilename
argument_list|)
operator|+
name|strlen
argument_list|(
name|galtfilename
argument_list|)
operator|+
literal|2
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|cmd
argument_list|,
name|lessclose
argument_list|,
name|gfilename
argument_list|,
name|galtfilename
argument_list|)
expr_stmt|;
name|fd
operator|=
name|shellcmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|galtfilename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|gfilename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
name|NULL
condition|)
name|pclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Is the specified file a directory?  */
end_comment

begin_function
name|public
name|int
name|is_dir
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|int
name|isdir
init|=
literal|0
decl_stmt|;
name|filename
operator|=
name|unquote_file
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_STAT
block|{
name|int
name|r
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|r
operator|=
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|statbuf
argument_list|)
expr_stmt|;
name|isdir
operator|=
operator|(
name|r
operator|>=
literal|0
operator|&&
name|S_ISDIR
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
operator|)
expr_stmt|;
block|}
else|#
directive|else
ifdef|#
directive|ifdef
name|_OSK
block|{
specifier|register
name|int
name|f
decl_stmt|;
name|f
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|S_IREAD
operator||
name|S_IFDIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|isdir
operator|=
operator|(
name|f
operator|>=
literal|0
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
name|isdir
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns NULL if the file can be opened and  * is an ordinary file, otherwise an error message  * (if it cannot be opened or is a directory, etc.)  */
end_comment

begin_function
name|public
name|char
modifier|*
name|bad_file
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|filename
operator|=
name|unquote_file
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_dir
argument_list|(
name|filename
argument_list|)
condition|)
block|{
specifier|static
name|char
name|is_dir
index|[]
init|=
literal|" is a directory"
decl_stmt|;
name|m
operator|=
operator|(
name|char
operator|*
operator|)
name|ecalloc
argument_list|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|is_dir
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|m
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|m
argument_list|,
name|is_dir
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|HAVE_STAT
name|int
name|r
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|r
operator|=
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|statbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|m
operator|=
name|errno_message
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|force_open
condition|)
block|{
name|m
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
condition|)
block|{
specifier|static
name|char
name|not_reg
index|[]
init|=
literal|" is not a regular file (use -f to see it)"
decl_stmt|;
name|m
operator|=
operator|(
name|char
operator|*
operator|)
name|ecalloc
argument_list|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|not_reg
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|m
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|m
argument_list|,
name|not_reg
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the size of a file, as cheaply as possible.  * In Unix, we can stat the file.  */
end_comment

begin_function
name|public
name|POSITION
name|filesize
parameter_list|(
name|f
parameter_list|)
name|int
name|f
decl_stmt|;
block|{
if|#
directive|if
name|HAVE_STAT
name|struct
name|stat
name|statbuf
decl_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|f
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|>=
literal|0
condition|)
return|return
operator|(
operator|(
name|POSITION
operator|)
name|statbuf
operator|.
name|st_size
operator|)
return|;
else|#
directive|else
ifdef|#
directive|ifdef
name|_OSK
name|long
name|size
decl_stmt|;
if|if
condition|(
operator|(
name|size
operator|=
operator|(
name|long
operator|)
name|_gs_size
argument_list|(
name|f
argument_list|)
operator|)
operator|>=
literal|0
condition|)
return|return
operator|(
operator|(
name|POSITION
operator|)
name|size
operator|)
return|;
endif|#
directive|endif
endif|#
directive|endif
return|return
operator|(
name|seek_filesize
argument_list|(
name|f
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

