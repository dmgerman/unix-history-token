begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1984-2002  Mark Nudelman  *  * You may distribute under the terms of either the GNU General Public  * License or the Less License, as specified in the README file.  *  * For more information about less, or for information on how to   * contact the author, see the README file.  */
end_comment

begin_comment
comment|/*  * Routines which jump to a new location in the file.  */
end_comment

begin_include
include|#
directive|include
file|"less.h"
end_include

begin_include
include|#
directive|include
file|"position.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|hit_eof
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|jump_sline
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|squished
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|screen_trashed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sc_width
decl_stmt|,
name|sc_height
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|show_attn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Jump to the end of the file.  */
end_comment

begin_function
name|public
name|void
name|jump_forw
parameter_list|()
block|{
name|POSITION
name|pos
decl_stmt|;
if|if
condition|(
name|ch_end_seek
argument_list|()
condition|)
block|{
name|error
argument_list|(
literal|"Cannot seek to end of file"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Position the last line in the file at the last screen line. 	 * Go back one line from the end of the file 	 * to get to the beginning of the last line. 	 */
name|pos
operator|=
name|back_line
argument_list|(
name|ch_tell
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|NULL_POSITION
condition|)
name|jump_loc
argument_list|(
operator|(
name|POSITION
operator|)
literal|0
argument_list|,
name|sc_height
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|jump_loc
argument_list|(
name|pos
argument_list|,
name|sc_height
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Jump to line n in the file.  */
end_comment

begin_function
name|public
name|void
name|jump_back
parameter_list|(
name|linenum
parameter_list|)
name|LINENUM
name|linenum
decl_stmt|;
block|{
name|POSITION
name|pos
decl_stmt|;
name|PARG
name|parg
decl_stmt|;
comment|/* 	 * Find the position of the specified line. 	 * If we can seek there, just jump to it. 	 * If we can't seek, but we're trying to go to line number 1, 	 * use ch_beg_seek() to get as close as we can. 	 */
name|pos
operator|=
name|find_pos
argument_list|(
name|linenum
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|!=
name|NULL_POSITION
operator|&&
name|ch_seek
argument_list|(
name|pos
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|show_attn
condition|)
name|set_attnpos
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|jump_loc
argument_list|(
name|pos
argument_list|,
name|jump_sline
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|linenum
operator|<=
literal|1
operator|&&
name|ch_beg_seek
argument_list|()
operator|==
literal|0
condition|)
block|{
name|jump_loc
argument_list|(
name|ch_tell
argument_list|()
argument_list|,
name|jump_sline
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Cannot seek to beginning of file"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parg
operator|.
name|p_linenum
operator|=
name|linenum
expr_stmt|;
name|error
argument_list|(
literal|"Cannot seek to line number %n"
argument_list|,
operator|&
name|parg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Repaint the screen.  */
end_comment

begin_function
name|public
name|void
name|repaint
parameter_list|()
block|{
name|struct
name|scrpos
name|scrpos
decl_stmt|;
comment|/* 	 * Start at the line currently at the top of the screen 	 * and redisplay the screen. 	 */
name|get_scrpos
argument_list|(
operator|&
name|scrpos
argument_list|)
expr_stmt|;
name|pos_clear
argument_list|()
expr_stmt|;
name|jump_loc
argument_list|(
name|scrpos
operator|.
name|pos
argument_list|,
name|scrpos
operator|.
name|ln
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Jump to a specified percentage into the file.  */
end_comment

begin_function
name|public
name|void
name|jump_percent
parameter_list|(
name|percent
parameter_list|)
name|int
name|percent
decl_stmt|;
block|{
name|POSITION
name|pos
decl_stmt|,
name|len
decl_stmt|;
comment|/* 	 * Determine the position in the file 	 * (the specified percentage of the file's length). 	 */
if|if
condition|(
operator|(
name|len
operator|=
name|ch_length
argument_list|()
operator|)
operator|==
name|NULL_POSITION
condition|)
block|{
name|ierror
argument_list|(
literal|"Determining length of file"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
name|ch_end_seek
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|len
operator|=
name|ch_length
argument_list|()
operator|)
operator|==
name|NULL_POSITION
condition|)
block|{
name|error
argument_list|(
literal|"Don't know length of file"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
return|return;
block|}
name|pos
operator|=
name|percent_pos
argument_list|(
name|len
argument_list|,
name|percent
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|>=
name|len
condition|)
name|pos
operator|=
name|len
operator|-
literal|1
expr_stmt|;
name|jump_line_loc
argument_list|(
name|pos
argument_list|,
name|jump_sline
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Jump to a specified position in the file.  * Like jump_loc, but the position need not be   * the first character in a line.  */
end_comment

begin_function
name|public
name|void
name|jump_line_loc
parameter_list|(
name|pos
parameter_list|,
name|sline
parameter_list|)
name|POSITION
name|pos
decl_stmt|;
name|int
name|sline
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|ch_seek
argument_list|(
name|pos
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Back up to the beginning of the line. 		 */
while|while
condition|(
operator|(
name|c
operator|=
name|ch_back_get
argument_list|()
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOI
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
operator|(
name|void
operator|)
name|ch_forw_get
argument_list|()
expr_stmt|;
name|pos
operator|=
name|ch_tell
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|show_attn
condition|)
name|set_attnpos
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|jump_loc
argument_list|(
name|pos
argument_list|,
name|sline
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Jump to a specified position in the file.  * The position must be the first character in a line.  * Place the target line on a specified line on the screen.  */
end_comment

begin_function
name|public
name|void
name|jump_loc
parameter_list|(
name|pos
parameter_list|,
name|sline
parameter_list|)
name|POSITION
name|pos
decl_stmt|;
name|int
name|sline
decl_stmt|;
block|{
specifier|register
name|int
name|nline
decl_stmt|;
name|POSITION
name|tpos
decl_stmt|;
name|POSITION
name|bpos
decl_stmt|;
comment|/* 	 * Normalize sline. 	 */
name|sline
operator|=
name|adjsline
argument_list|(
name|sline
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nline
operator|=
name|onscreen
argument_list|(
name|pos
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
comment|/* 		 * The line is currently displayed.   		 * Just scroll there. 		 */
name|nline
operator|-=
name|sline
expr_stmt|;
if|if
condition|(
name|nline
operator|>
literal|0
condition|)
name|forw
argument_list|(
name|nline
argument_list|,
name|position
argument_list|(
name|BOTTOM_PLUS_ONE
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|back
argument_list|(
operator|-
name|nline
argument_list|,
name|position
argument_list|(
name|TOP
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|show_attn
condition|)
name|repaint_hilite
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Line is not on screen. 	 * Seek to the desired location. 	 */
if|if
condition|(
name|ch_seek
argument_list|(
name|pos
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Cannot seek to that file position"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * See if the desired line is before or after  	 * the currently displayed screen. 	 */
name|tpos
operator|=
name|position
argument_list|(
name|TOP
argument_list|)
expr_stmt|;
name|bpos
operator|=
name|position
argument_list|(
name|BOTTOM_PLUS_ONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpos
operator|==
name|NULL_POSITION
operator|||
name|pos
operator|>=
name|tpos
condition|)
block|{
comment|/* 		 * The desired line is after the current screen. 		 * Move back in the file far enough so that we can 		 * call forw() and put the desired line at the  		 * sline-th line on the screen. 		 */
for|for
control|(
name|nline
operator|=
literal|0
init|;
name|nline
operator|<
name|sline
condition|;
name|nline
operator|++
control|)
block|{
if|if
condition|(
name|bpos
operator|!=
name|NULL_POSITION
operator|&&
name|pos
operator|<=
name|bpos
condition|)
block|{
comment|/* 				 * Surprise!  The desired line is 				 * close enough to the current screen 				 * that we can just scroll there after all. 				 */
name|forw
argument_list|(
name|sc_height
operator|-
name|sline
operator|+
name|nline
operator|-
literal|1
argument_list|,
name|bpos
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|show_attn
condition|)
name|repaint_hilite
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|pos
operator|=
name|back_line
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|NULL_POSITION
condition|)
block|{
comment|/* 				 * Oops.  Ran into the beginning of the file. 				 * Exit the loop here and rely on forw() 				 * below to draw the required number of 				 * blank lines at the top of the screen. 				 */
break|break;
block|}
block|}
name|lastmark
argument_list|()
expr_stmt|;
name|hit_eof
operator|=
literal|0
expr_stmt|;
name|squished
operator|=
literal|0
expr_stmt|;
name|screen_trashed
operator|=
literal|0
expr_stmt|;
name|forw
argument_list|(
name|sc_height
operator|-
literal|1
argument_list|,
name|pos
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|sline
operator|-
name|nline
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The desired line is before the current screen. 		 * Move forward in the file far enough so that we 		 * can call back() and put the desired line at the  		 * sline-th line on the screen. 		 */
for|for
control|(
name|nline
operator|=
name|sline
init|;
name|nline
operator|<
name|sc_height
operator|-
literal|1
condition|;
name|nline
operator|++
control|)
block|{
name|pos
operator|=
name|forw_line
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|NULL_POSITION
condition|)
block|{
comment|/* 				 * Ran into end of file. 				 * This shouldn't normally happen,  				 * but may if there is some kind of read error. 				 */
break|break;
block|}
if|if
condition|(
name|pos
operator|>=
name|tpos
condition|)
block|{
comment|/*  				 * Surprise!  The desired line is 				 * close enough to the current screen 				 * that we can just scroll there after all. 				 */
name|back
argument_list|(
name|nline
operator|+
literal|1
argument_list|,
name|tpos
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|show_attn
condition|)
name|repaint_hilite
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|lastmark
argument_list|()
expr_stmt|;
name|clear
argument_list|()
expr_stmt|;
name|screen_trashed
operator|=
literal|0
expr_stmt|;
name|add_back_pos
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|back
argument_list|(
name|sc_height
operator|-
literal|1
argument_list|,
name|pos
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

