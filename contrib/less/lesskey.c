begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1984-2000  Mark Nudelman  *  * You may distribute under the terms of either the GNU General Public  * License or the Less License, as specified in the README file.  *  * For more information about less, or for information on how to   * contact the author, see the README file.  */
end_comment

begin_comment
comment|/*  *	lesskey [-o output] [input]  *  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *   *  *	Make a .less file.  *	If no input file is specified, standard input is used.  *	If no output file is specified, $HOME/.less is used.  *  *	The .less file is used to specify (to "less") user-defined  *	key bindings.  Basically any sequence of 1 to MAX_CMDLEN  *	keystrokes may be bound to an existing less function.  *  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *   *  *	The input file is an ascii file consisting of a   *	sequence of lines of the form:  *		string<whitespace> action [chars]<newline>  *  *	"string" is a sequence of command characters which form  *		the new user-defined command.  The command  *		characters may be:  *		1. The actual character itself.  *		2. A character preceded by ^ to specify a  *		   control character (e.g. ^X means control-X).  *		3. A backslash followed by one to three octal digits  *		   to specify a character by its octal value.  *		4. A backslash followed by b, e, n, r or t  *		   to specify \b, ESC, \n, \r or \t, respectively.  *		5. Any character (other than those mentioned above) preceded   *		   by a \ to specify the character itself (characters which  *		   must be preceded by \ include ^, \, and whitespace.  *	"action" is the name of a "less" action, from the table below.  *	"chars" is an optional sequence of characters which is treated  *		as keyboard input after the command is executed.  *  *	Blank lines and lines which start with # are ignored,   *	except for the special control lines:  *		#command	Signals the beginning of the command  *				keys section.  *		#line-edit	Signals the beginning of the line-editing  *				keys section.  *		#env		Signals the beginning of the environment  *				variable section.  *		#stop		Stops command parsing in less;  *				causes all default keys to be disabled.  *  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *   *  *	The output file is a non-ascii file, consisting of a header,  *	one or more sections, and a trailer.  *	Each section begins with a section header, a section length word  *	and the section data.  Normally there are three sections:  *		CMD_SECTION	Definition of command keys.  *		EDIT_SECTION	Definition of editing keys.  *		END_SECTION	A special section header, with no   *				length word or section data.  *  *	Section data consists of zero or more byte sequences of the form:  *		string<0><action>  *	or  *		string<0><action|A_EXTRA> chars<0>  *  *	"string" is the command string.  *	"<0>" is one null byte.  *	"<action>" is one byte containing the action code (the A_xxx value).  *	If action is ORed with A_EXTRA, the action byte is followed  *		by the null-terminated "chars" string.  *  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *   */
end_comment

begin_include
include|#
directive|include
file|"less.h"
end_include

begin_include
include|#
directive|include
file|"lesskey.h"
end_include

begin_include
include|#
directive|include
file|"cmd.h"
end_include

begin_struct
struct|struct
name|cmdname
block|{
name|char
modifier|*
name|cn_name
decl_stmt|;
name|int
name|cn_action
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|cmdname
name|cmdnames
index|[]
init|=
block|{
literal|"back-bracket"
block|,
name|A_B_BRACKET
block|,
literal|"back-line"
block|,
name|A_B_LINE
block|,
literal|"back-line-force"
block|,
name|A_BF_LINE
block|,
literal|"back-screen"
block|,
name|A_B_SCREEN
block|,
literal|"back-scroll"
block|,
name|A_B_SCROLL
block|,
literal|"back-search"
block|,
name|A_B_SEARCH
block|,
literal|"back-window"
block|,
name|A_B_WINDOW
block|,
literal|"debug"
block|,
name|A_DEBUG
block|,
literal|"digit"
block|,
name|A_DIGIT
block|,
literal|"display-flag"
block|,
name|A_DISP_OPTION
block|,
literal|"display-option"
block|,
name|A_DISP_OPTION
block|,
literal|"end"
block|,
name|A_GOEND
block|,
literal|"examine"
block|,
name|A_EXAMINE
block|,
literal|"first-cmd"
block|,
name|A_FIRSTCMD
block|,
literal|"firstcmd"
block|,
name|A_FIRSTCMD
block|,
literal|"flush-repaint"
block|,
name|A_FREPAINT
block|,
literal|"forw-bracket"
block|,
name|A_F_BRACKET
block|,
literal|"forw-forever"
block|,
name|A_F_FOREVER
block|,
literal|"forw-line"
block|,
name|A_F_LINE
block|,
literal|"forw-line-force"
block|,
name|A_FF_LINE
block|,
literal|"forw-screen"
block|,
name|A_F_SCREEN
block|,
literal|"forw-screen-force"
block|,
name|A_FF_SCREEN
block|,
literal|"forw-scroll"
block|,
name|A_F_SCROLL
block|,
literal|"forw-search"
block|,
name|A_F_SEARCH
block|,
literal|"forw-window"
block|,
name|A_F_WINDOW
block|,
literal|"goto-end"
block|,
name|A_GOEND
block|,
literal|"goto-line"
block|,
name|A_GOLINE
block|,
literal|"goto-mark"
block|,
name|A_GOMARK
block|,
literal|"help"
block|,
name|A_HELP
block|,
literal|"index-file"
block|,
name|A_INDEX_FILE
block|,
literal|"invalid"
block|,
name|A_UINVALID
block|,
literal|"left-scroll"
block|,
name|A_LSHIFT
block|,
literal|"next-file"
block|,
name|A_NEXT_FILE
block|,
literal|"noaction"
block|,
name|A_NOACTION
block|,
literal|"percent"
block|,
name|A_PERCENT
block|,
literal|"pipe"
block|,
name|A_PIPE
block|,
literal|"prev-file"
block|,
name|A_PREV_FILE
block|,
literal|"quit"
block|,
name|A_QUIT
block|,
literal|"repaint"
block|,
name|A_REPAINT
block|,
literal|"repaint-flush"
block|,
name|A_FREPAINT
block|,
literal|"repeat-search"
block|,
name|A_AGAIN_SEARCH
block|,
literal|"repeat-search-all"
block|,
name|A_T_AGAIN_SEARCH
block|,
literal|"reverse-search"
block|,
name|A_REVERSE_SEARCH
block|,
literal|"reverse-search-all"
block|,
name|A_T_REVERSE_SEARCH
block|,
literal|"right-scroll"
block|,
name|A_RSHIFT
block|,
literal|"set-mark"
block|,
name|A_SETMARK
block|,
literal|"shell"
block|,
name|A_SHELL
block|,
literal|"status"
block|,
name|A_STAT
block|,
literal|"toggle-flag"
block|,
name|A_OPT_TOGGLE
block|,
literal|"toggle-option"
block|,
name|A_OPT_TOGGLE
block|,
literal|"undo-hilite"
block|,
name|A_UNDO_SEARCH
block|,
literal|"version"
block|,
name|A_VERSION
block|,
literal|"visual"
block|,
name|A_VISUAL
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmdname
name|editnames
index|[]
init|=
block|{
literal|"back-complete"
block|,
name|EC_B_COMPLETE
block|,
literal|"backspace"
block|,
name|EC_BACKSPACE
block|,
literal|"delete"
block|,
name|EC_DELETE
block|,
literal|"down"
block|,
name|EC_DOWN
block|,
literal|"end"
block|,
name|EC_END
block|,
literal|"expand"
block|,
name|EC_EXPAND
block|,
literal|"forw-complete"
block|,
name|EC_F_COMPLETE
block|,
literal|"home"
block|,
name|EC_HOME
block|,
literal|"insert"
block|,
name|EC_INSERT
block|,
literal|"invalid"
block|,
name|EC_UINVALID
block|,
literal|"kill-line"
block|,
name|EC_LINEKILL
block|,
literal|"left"
block|,
name|EC_LEFT
block|,
literal|"literal"
block|,
name|EC_LITERAL
block|,
literal|"right"
block|,
name|EC_RIGHT
block|,
literal|"up"
block|,
name|EC_UP
block|,
literal|"word-backspace"
block|,
name|EC_W_BACKSPACE
block|,
literal|"word-delete"
block|,
name|EC_W_DELETE
block|,
literal|"word-left"
block|,
name|EC_W_LEFT
block|,
literal|"word-right"
block|,
name|EC_W_RIGHT
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|table
block|{
name|struct
name|cmdname
modifier|*
name|names
decl_stmt|;
name|char
modifier|*
name|pbuffer
decl_stmt|;
name|char
name|buffer
index|[
name|MAX_USERCMD
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|table
name|cmdtable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|table
name|edittable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|table
name|vartable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|table
modifier|*
name|currtable
init|=
operator|&
name|cmdtable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|fileheader
index|[]
init|=
block|{
name|C0_LESSKEY_MAGIC
block|,
name|C1_LESSKEY_MAGIC
block|,
name|C2_LESSKEY_MAGIC
block|,
name|C3_LESSKEY_MAGIC
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|filetrailer
index|[]
init|=
block|{
name|C0_END_LESSKEY_MAGIC
block|,
name|C1_END_LESSKEY_MAGIC
block|,
name|C2_END_LESSKEY_MAGIC
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|cmdsection
index|[
literal|1
index|]
init|=
block|{
name|CMD_SECTION
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|editsection
index|[
literal|1
index|]
init|=
block|{
name|EDIT_SECTION
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|varsection
index|[
literal|1
index|]
init|=
block|{
name|VAR_SECTION
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|endsection
index|[
literal|1
index|]
init|=
block|{
name|END_SECTION
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|infile
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|outfile
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|linenum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|errors
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|version
index|[]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: lesskey [-o output] [input]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|mkpathname
parameter_list|(
name|dirname
parameter_list|,
name|filename
parameter_list|)
name|char
modifier|*
name|dirname
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|char
modifier|*
name|pathname
decl_stmt|;
name|pathname
operator|=
name|calloc
argument_list|(
name|strlen
argument_list|(
name|dirname
argument_list|)
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|2
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|pathname
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|pathname
argument_list|,
name|PATHNAME_SEP
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|pathname
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
name|pathname
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Figure out the name of a default file (in the user's HOME directory).  */
end_comment

begin_function
name|char
modifier|*
name|homefile
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|pathname
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
name|pathname
operator|=
name|mkpathname
argument_list|(
name|p
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|#
directive|if
name|OS2
elseif|else
if|if
condition|(
operator|(
name|p
operator|=
name|getenv
argument_list|(
literal|"INIT"
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
name|pathname
operator|=
name|mkpathname
argument_list|(
name|p
argument_list|,
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cannot find $HOME - using current directory\n"
argument_list|)
expr_stmt|;
name|pathname
operator|=
name|mkpathname
argument_list|(
literal|"."
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|pathname
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse command line arguments.  */
end_comment

begin_function
name|void
name|parse_args
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|arg
decl_stmt|;
name|outfile
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
condition|)
block|{
name|arg
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
comment|/* Arg does not start with "-"; it's not an option. */
break|break;
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
comment|/* "-" means standard input. */
break|break;
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|==
literal|'-'
operator|&&
name|arg
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* "--" means end of options. */
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|arg
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'-'
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"--output"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|arg
index|[
literal|8
index|]
operator|==
literal|'\0'
condition|)
name|outfile
operator|=
operator|&
name|arg
index|[
literal|8
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
index|[
literal|8
index|]
operator|==
literal|'='
condition|)
name|outfile
operator|=
operator|&
name|arg
index|[
literal|9
index|]
expr_stmt|;
else|else
name|usage
argument_list|()
expr_stmt|;
goto|goto
name|opt_o
goto|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--version"
argument_list|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|opt_V
goto|;
block|}
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|outfile
operator|=
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
name|opt_o
label|:
if|if
condition|(
operator|*
name|outfile
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|--
name|argc
operator|<=
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
name|outfile
operator|=
operator|*
operator|(
operator|++
name|argv
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|'V'
case|:
name|opt_V
label|:
name|printf
argument_list|(
literal|"lesskey  version %s\n"
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
comment|/* 	 * Open the input file, or use DEF_LESSKEYINFILE if none specified. 	 */
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
name|infile
operator|=
operator|*
name|argv
expr_stmt|;
else|else
name|infile
operator|=
name|homefile
argument_list|(
name|DEF_LESSKEYINFILE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize data structures.  */
end_comment

begin_function
name|void
name|init_tables
parameter_list|()
block|{
name|cmdtable
operator|.
name|names
operator|=
name|cmdnames
expr_stmt|;
name|cmdtable
operator|.
name|pbuffer
operator|=
name|cmdtable
operator|.
name|buffer
expr_stmt|;
name|edittable
operator|.
name|names
operator|=
name|editnames
expr_stmt|;
name|edittable
operator|.
name|pbuffer
operator|=
name|edittable
operator|.
name|buffer
expr_stmt|;
name|vartable
operator|.
name|names
operator|=
name|NULL
expr_stmt|;
name|vartable
operator|.
name|pbuffer
operator|=
name|vartable
operator|.
name|buffer
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Parse one character of a string.  */
end_comment

begin_function
name|char
modifier|*
name|tstr
parameter_list|(
name|pp
parameter_list|)
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
name|ch
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
specifier|static
name|char
name|tstr_control_k
index|[]
init|=
block|{
name|SK_SPECIAL_KEY
block|,
name|SK_CONTROL_K
block|,
literal|6
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|'\0'
block|}
decl_stmt|;
name|p
operator|=
operator|*
name|pp
expr_stmt|;
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'\\'
case|:
operator|++
name|p
expr_stmt|;
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
comment|/* 			 * Parse an octal number. 			 */
name|ch
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
do|do
name|ch
operator|=
literal|8
operator|*
name|ch
operator|+
operator|(
operator|*
name|p
operator|-
literal|'0'
operator|)
expr_stmt|;
do|while
condition|(
operator|*
operator|++
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'7'
operator|&&
operator|++
name|i
operator|<
literal|3
condition|)
do|;
operator|*
name|pp
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|CONTROL
argument_list|(
literal|'K'
argument_list|)
condition|)
return|return
name|tstr_control_k
return|;
name|buf
index|[
literal|0
index|]
operator|=
name|ch
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
case|case
literal|'b'
case|:
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
return|return
operator|(
literal|"\b"
operator|)
return|;
case|case
literal|'e'
case|:
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|ESC
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
case|case
literal|'n'
case|:
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
return|return
operator|(
literal|"\n"
operator|)
return|;
case|case
literal|'r'
case|:
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
return|return
operator|(
literal|"\r"
operator|)
return|;
case|case
literal|'t'
case|:
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
return|return
operator|(
literal|"\t"
operator|)
return|;
case|case
literal|'k'
case|:
switch|switch
condition|(
operator|*
operator|++
name|p
condition|)
block|{
case|case
literal|'u'
case|:
name|ch
operator|=
name|SK_UP_ARROW
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|ch
operator|=
name|SK_DOWN_ARROW
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|ch
operator|=
name|SK_RIGHT_ARROW
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|ch
operator|=
name|SK_LEFT_ARROW
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|ch
operator|=
name|SK_PAGE_UP
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|ch
operator|=
name|SK_PAGE_DOWN
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|ch
operator|=
name|SK_HOME
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|ch
operator|=
name|SK_END
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|ch
operator|=
name|SK_DELETE
expr_stmt|;
break|break;
block|}
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|SK_SPECIAL_KEY
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|ch
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
literal|6
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
literal|1
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
literal|1
expr_stmt|;
name|buf
index|[
literal|5
index|]
operator|=
literal|1
expr_stmt|;
name|buf
index|[
literal|6
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
default|default:
comment|/* 			 * Backslash followed by any other char  			 * just means that char. 			 */
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
operator|*
name|p
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
name|CONTROL
argument_list|(
literal|'K'
argument_list|)
condition|)
return|return
name|tstr_control_k
return|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
case|case
literal|'^'
case|:
comment|/* 		 * Carat means CONTROL. 		 */
operator|*
name|pp
operator|=
name|p
operator|+
literal|2
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|CONTROL
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
name|CONTROL
argument_list|(
literal|'K'
argument_list|)
condition|)
return|return
name|tstr_control_k
return|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
operator|*
name|p
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
name|CONTROL
argument_list|(
literal|'K'
argument_list|)
condition|)
return|return
name|tstr_control_k
return|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Skip leading spaces in a string.  */
end_comment

begin_function
name|public
name|char
modifier|*
name|skipsp
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
condition|)
name|s
operator|++
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Skip non-space characters in a string.  */
end_comment

begin_function
name|public
name|char
modifier|*
name|skipnsp
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
operator|&&
operator|*
name|s
operator|!=
literal|' '
operator|&&
operator|*
name|s
operator|!=
literal|'\t'
condition|)
name|s
operator|++
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clean up an input line:  * strip off the trailing newline& any trailing # comment.  */
end_comment

begin_function
name|char
modifier|*
name|clean_line
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|s
operator|=
name|skipsp
argument_list|(
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|s
index|[
name|i
index|]
operator|!=
literal|'\n'
operator|&&
name|s
index|[
name|i
index|]
operator|!=
literal|'\r'
operator|&&
name|s
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|s
index|[
name|i
index|]
operator|==
literal|'#'
operator|&&
operator|(
name|i
operator|==
literal|0
operator|||
name|s
index|[
name|i
operator|-
literal|1
index|]
operator|!=
literal|'\\'
operator|)
condition|)
break|break;
name|s
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a byte to the output command table.  */
end_comment

begin_function
name|void
name|add_cmd_char
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|currtable
operator|->
name|pbuffer
operator|>=
name|currtable
operator|->
name|buffer
operator|+
name|MAX_USERCMD
condition|)
block|{
name|error
argument_list|(
literal|"too many commands"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
operator|(
name|currtable
operator|->
name|pbuffer
operator|)
operator|++
operator|=
name|c
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a string to the output command table.  */
end_comment

begin_function
name|void
name|add_cmd_str
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
for|for
control|(
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
name|add_cmd_char
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * See if we have a special "control" line.  */
end_comment

begin_function
name|int
name|control_line
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
define|#
directive|define
name|PREFIX
parameter_list|(
name|str
parameter_list|,
name|pat
parameter_list|)
value|(strncmp(str,pat,strlen(pat)-1) == 0)
if|if
condition|(
name|PREFIX
argument_list|(
name|s
argument_list|,
literal|"#line-edit"
argument_list|)
condition|)
block|{
name|currtable
operator|=
operator|&
name|edittable
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|PREFIX
argument_list|(
name|s
argument_list|,
literal|"#command"
argument_list|)
condition|)
block|{
name|currtable
operator|=
operator|&
name|cmdtable
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|PREFIX
argument_list|(
name|s
argument_list|,
literal|"#env"
argument_list|)
condition|)
block|{
name|currtable
operator|=
operator|&
name|vartable
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|PREFIX
argument_list|(
name|s
argument_list|,
literal|"#stop"
argument_list|)
condition|)
block|{
name|add_cmd_char
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
name|add_cmd_char
argument_list|(
name|A_END_LIST
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Output some bytes.  */
end_comment

begin_function
name|void
name|fputbytes
parameter_list|(
name|fd
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|FILE
modifier|*
name|fd
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|fwrite
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|buf
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Output an integer, in special KRADIX form.  */
end_comment

begin_function
name|void
name|fputint
parameter_list|(
name|fd
parameter_list|,
name|val
parameter_list|)
name|FILE
modifier|*
name|fd
decl_stmt|;
name|unsigned
name|int
name|val
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
if|if
condition|(
name|val
operator|>=
name|KRADIX
operator|*
name|KRADIX
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error: integer too big (%d> %d)\n"
argument_list|,
name|val
argument_list|,
name|KRADIX
operator|*
name|KRADIX
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|val
operator|%
name|KRADIX
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|c
operator|=
name|val
operator|/
name|KRADIX
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find an action, given the name of the action.  */
end_comment

begin_function
name|int
name|findaction
parameter_list|(
name|actname
parameter_list|)
name|char
modifier|*
name|actname
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|currtable
operator|->
name|names
index|[
name|i
index|]
operator|.
name|cn_name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|currtable
operator|->
name|names
index|[
name|i
index|]
operator|.
name|cn_name
argument_list|,
name|actname
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|currtable
operator|->
name|names
index|[
name|i
index|]
operator|.
name|cn_action
operator|)
return|;
name|error
argument_list|(
literal|"unknown action"
argument_list|)
expr_stmt|;
return|return
operator|(
name|A_INVALID
operator|)
return|;
block|}
end_function

begin_function
name|void
name|error
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"line %d: %s\n"
argument_list|,
name|linenum
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|parse_cmdline
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|cmdlen
decl_stmt|;
name|char
modifier|*
name|actname
decl_stmt|;
name|int
name|action
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/* 	 * Parse the command string and store it in the current table. 	 */
name|cmdlen
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|s
operator|=
name|tstr
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
name|cmdlen
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmdlen
operator|>
name|MAX_CMDLEN
condition|)
name|error
argument_list|(
literal|"command too long"
argument_list|)
expr_stmt|;
else|else
name|add_cmd_str
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'\t'
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
do|;
comment|/* 	 * Terminate the command string with a null byte. 	 */
name|add_cmd_char
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
comment|/* 	 * Skip white space between the command string 	 * and the action name. 	 * Terminate the action name with a null byte. 	 */
name|p
operator|=
name|skipsp
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|error
argument_list|(
literal|"missing action"
argument_list|)
expr_stmt|;
return|return;
block|}
name|actname
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|skipnsp
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * Parse the action name and store it in the current table. 	 */
name|action
operator|=
name|findaction
argument_list|(
name|actname
argument_list|)
expr_stmt|;
comment|/* 	 * See if an extra string follows the action name. 	 */
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|p
operator|=
name|skipsp
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|add_cmd_char
argument_list|(
name|action
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * OR the special value A_EXTRA into the action byte. 		 * Put the extra string after the action byte. 		 */
name|add_cmd_char
argument_list|(
name|action
operator||
name|A_EXTRA
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
name|add_cmd_str
argument_list|(
name|tstr
argument_list|(
operator|&
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|add_cmd_char
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|parse_varline
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
do|do
block|{
name|s
operator|=
name|tstr
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
name|add_cmd_str
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'\t'
operator|&&
operator|*
name|p
operator|!=
literal|'='
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
do|;
comment|/* 	 * Terminate the variable name with a null byte. 	 */
name|add_cmd_char
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
name|p
operator|=
name|skipsp
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'='
condition|)
block|{
name|error
argument_list|(
literal|"missing ="
argument_list|)
expr_stmt|;
return|return;
block|}
name|add_cmd_char
argument_list|(
name|EV_OK
operator||
name|A_EXTRA
argument_list|)
expr_stmt|;
name|p
operator|=
name|skipsp
argument_list|(
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|s
operator|=
name|tstr
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
name|add_cmd_str
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|add_cmd_char
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Parse a line from the lesskey file.  */
end_comment

begin_function
name|void
name|parse_line
parameter_list|(
name|line
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* 	 * See if it is a control line. 	 */
if|if
condition|(
name|control_line
argument_list|(
name|line
argument_list|)
condition|)
return|return;
comment|/* 	 * Skip leading white space. 	 * Replace the final newline with a null byte. 	 * Ignore blank lines and comments. 	 */
name|p
operator|=
name|clean_line
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return;
if|if
condition|(
name|currtable
operator|==
operator|&
name|vartable
condition|)
name|parse_varline
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|parse_cmdline
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|FILE
modifier|*
name|desc
decl_stmt|;
name|FILE
modifier|*
name|out
decl_stmt|;
name|char
name|line
index|[
literal|200
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|WIN32
if|if
condition|(
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * If there is no HOME environment variable, 		 * try the concatenation of HOMEDRIVE + HOMEPATH. 		 */
name|char
modifier|*
name|drive
init|=
name|getenv
argument_list|(
literal|"HOMEDRIVE"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|path
init|=
name|getenv
argument_list|(
literal|"HOMEPATH"
argument_list|)
decl_stmt|;
if|if
condition|(
name|drive
operator|!=
name|NULL
operator|&&
name|path
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|env
init|=
operator|(
name|char
operator|*
operator|)
name|calloc
argument_list|(
name|strlen
argument_list|(
name|drive
argument_list|)
operator|+
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|6
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|env
argument_list|,
literal|"HOME="
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|env
argument_list|,
name|drive
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|env
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|putenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* WIN32 */
comment|/* 	 * Process command line arguments. 	 */
name|parse_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|init_tables
argument_list|()
expr_stmt|;
comment|/* 	 * Open the input file. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|infile
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|desc
operator|=
name|stdin
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|desc
operator|=
name|fopen
argument_list|(
name|infile
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|#
directive|if
name|HAVE_PERROR
name|perror
argument_list|(
name|infile
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot open %s\n"
argument_list|,
name|infile
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|usage
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * Read and parse the input file, one line at a time. 	 */
name|errors
operator|=
literal|0
expr_stmt|;
name|linenum
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|desc
argument_list|)
operator|!=
name|NULL
condition|)
block|{
operator|++
name|linenum
expr_stmt|;
name|parse_line
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Write the output file. 	 * If no output file was specified, use "$HOME/.less" 	 */
if|if
condition|(
name|errors
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d errors; no output produced\n"
argument_list|,
name|errors
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outfile
operator|==
name|NULL
condition|)
name|outfile
operator|=
name|getenv
argument_list|(
literal|"LESSKEY"
argument_list|)
expr_stmt|;
if|if
condition|(
name|outfile
operator|==
name|NULL
condition|)
name|outfile
operator|=
name|homefile
argument_list|(
name|LESSKEYFILE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|out
operator|=
name|fopen
argument_list|(
name|outfile
argument_list|,
literal|"wb"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|#
directive|if
name|HAVE_PERROR
name|perror
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot open %s\n"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* File header */
name|fputbytes
argument_list|(
name|out
argument_list|,
name|fileheader
argument_list|,
sizeof|sizeof
argument_list|(
name|fileheader
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Command key section */
name|fputbytes
argument_list|(
name|out
argument_list|,
name|cmdsection
argument_list|,
sizeof|sizeof
argument_list|(
name|cmdsection
argument_list|)
argument_list|)
expr_stmt|;
name|fputint
argument_list|(
name|out
argument_list|,
name|cmdtable
operator|.
name|pbuffer
operator|-
name|cmdtable
operator|.
name|buffer
argument_list|)
expr_stmt|;
name|fputbytes
argument_list|(
name|out
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cmdtable
operator|.
name|buffer
argument_list|,
name|cmdtable
operator|.
name|pbuffer
operator|-
name|cmdtable
operator|.
name|buffer
argument_list|)
expr_stmt|;
comment|/* Edit key section */
name|fputbytes
argument_list|(
name|out
argument_list|,
name|editsection
argument_list|,
sizeof|sizeof
argument_list|(
name|editsection
argument_list|)
argument_list|)
expr_stmt|;
name|fputint
argument_list|(
name|out
argument_list|,
name|edittable
operator|.
name|pbuffer
operator|-
name|edittable
operator|.
name|buffer
argument_list|)
expr_stmt|;
name|fputbytes
argument_list|(
name|out
argument_list|,
operator|(
name|char
operator|*
operator|)
name|edittable
operator|.
name|buffer
argument_list|,
name|edittable
operator|.
name|pbuffer
operator|-
name|edittable
operator|.
name|buffer
argument_list|)
expr_stmt|;
comment|/* Environment variable section */
name|fputbytes
argument_list|(
name|out
argument_list|,
name|varsection
argument_list|,
sizeof|sizeof
argument_list|(
name|varsection
argument_list|)
argument_list|)
expr_stmt|;
name|fputint
argument_list|(
name|out
argument_list|,
name|vartable
operator|.
name|pbuffer
operator|-
name|vartable
operator|.
name|buffer
argument_list|)
expr_stmt|;
name|fputbytes
argument_list|(
name|out
argument_list|,
operator|(
name|char
operator|*
operator|)
name|vartable
operator|.
name|buffer
argument_list|,
name|vartable
operator|.
name|pbuffer
operator|-
name|vartable
operator|.
name|buffer
argument_list|)
expr_stmt|;
comment|/* File trailer */
name|fputbytes
argument_list|(
name|out
argument_list|,
name|endsection
argument_list|,
sizeof|sizeof
argument_list|(
name|endsection
argument_list|)
argument_list|)
expr_stmt|;
name|fputbytes
argument_list|(
name|out
argument_list|,
name|filetrailer
argument_list|,
sizeof|sizeof
argument_list|(
name|filetrailer
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

