begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1984-2000  Mark Nudelman  *  * You may distribute under the terms of either the GNU General Public  * License or the Less License, as specified in the README file.  *  * For more information about less, or for information on how to   * contact the author, see the README file.  */
end_comment

begin_comment
comment|/*  * Routines to execute other programs.  * Necessarily very OS dependent.  */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"less.h"
end_include

begin_include
include|#
directive|include
file|"position.h"
end_include

begin_if
if|#
directive|if
name|MSDOS_COMPILER
end_if

begin_include
include|#
directive|include
file|<dos.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_include
include|#
directive|include
file|<direct.h>
end_include

begin_define
define|#
directive|define
name|setdisk
parameter_list|(
name|n
parameter_list|)
value|_chdrive((n)+1)
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<dir.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|screen_trashed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|IFILE
name|curr_ifile
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|HAVE_SYSTEM
end_if

begin_comment
comment|/*  * Pass the specified command to a shell to be executed.  * Like plain "system()", but handles resetting terminal modes, etc.  */
end_comment

begin_function
name|public
name|void
name|lsystem
parameter_list|(
name|cmd
parameter_list|,
name|donemsg
parameter_list|)
name|char
modifier|*
name|cmd
decl_stmt|;
name|char
modifier|*
name|donemsg
decl_stmt|;
block|{
specifier|register
name|int
name|inp
decl_stmt|;
if|#
directive|if
name|HAVE_SHELL
specifier|register
name|char
modifier|*
name|shell
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
endif|#
directive|endif
name|IFILE
name|save_ifile
decl_stmt|;
if|#
directive|if
name|MSDOS_COMPILER
name|char
name|cwd
index|[
name|FILENAME_MAX
operator|+
literal|1
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * Print the command which is to be executed, 	 * unless the command starts with a "-". 	 */
if|if
condition|(
name|cmd
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|cmd
operator|++
expr_stmt|;
else|else
block|{
name|clear_bot
argument_list|()
expr_stmt|;
name|putstr
argument_list|(
literal|"!"
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|MSDOS_COMPILER
comment|/* 	 * Working directory is global on MSDOS. 	 * The child might change the working directory, so we 	 * must save and restore CWD across calls to "system", 	 * or else we won't find our file when we return and 	 * try to "reedit_ifile" it. 	 */
name|getcwd
argument_list|(
name|cwd
argument_list|,
name|FILENAME_MAX
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Close the current input file. 	 */
name|save_ifile
operator|=
name|save_curr_ifile
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|edit_ifile
argument_list|(
name|NULL_IFILE
argument_list|)
expr_stmt|;
comment|/* 	 * De-initialize the terminal and take out of raw mode. 	 */
name|deinit
argument_list|()
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
comment|/* Make sure the deinit chars get out */
name|raw_mode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|MSDOS_COMPILER
operator|==
name|WIN32C
name|close_getchr
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Restore signals to their defaults. 	 */
name|init_signals
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_DUP
comment|/* 	 * Force standard input to be the user's terminal 	 * (the normal standard input), even if less's standard input  	 * is coming from a pipe. 	 */
name|inp
operator|=
name|dup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
name|OPEN_READ
argument_list|)
operator|<
literal|0
condition|)
name|dup
argument_list|(
name|inp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Pass the command to the system to be executed. 	 * If we have a SHELL environment variable, use 	 *<$SHELL -c "command"> instead of just<command>. 	 * If the command is empty, just invoke a shell. 	 */
if|#
directive|if
name|HAVE_SHELL
name|p
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|shell
operator|=
name|lgetenv
argument_list|(
literal|"SHELL"
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|*
name|shell
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'\0'
condition|)
name|p
operator|=
name|save
argument_list|(
name|shell
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|esccmd
decl_stmt|;
if|if
condition|(
operator|(
name|esccmd
operator|=
name|esc_metachars
argument_list|(
name|cmd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|ecalloc
argument_list|(
name|strlen
argument_list|(
name|shell
argument_list|)
operator|+
name|strlen
argument_list|(
name|cmd
argument_list|)
operator|+
literal|7
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%s -c \"%s\""
argument_list|,
name|shell
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|ecalloc
argument_list|(
name|strlen
argument_list|(
name|shell
argument_list|)
operator|+
name|strlen
argument_list|(
name|esccmd
argument_list|)
operator|+
literal|5
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%s -c %s"
argument_list|,
name|shell
argument_list|,
name|esccmd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|esccmd
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'\0'
condition|)
name|p
operator|=
name|save
argument_list|(
literal|"sh"
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|save
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
name|system
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|MSDOS_COMPILER
operator|==
name|DJGPPC
comment|/* 	 * Make stdin of the child be in cooked mode. 	 */
name|setmode
argument_list|(
literal|0
argument_list|,
name|O_TEXT
argument_list|)
expr_stmt|;
comment|/* 	 * We don't need to catch signals of the child (it 	 * also makes trouble with some DPMI servers). 	 */
name|__djgpp_exception_toggle
argument_list|()
expr_stmt|;
name|system
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|__djgpp_exception_toggle
argument_list|()
expr_stmt|;
else|#
directive|else
name|system
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|HAVE_DUP
comment|/* 	 * Restore standard input, reset signals, raw mode, etc. 	 */
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|inp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|MSDOS_COMPILER
operator|==
name|WIN32C
name|open_getchr
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|init_signals
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|raw_mode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|donemsg
operator|!=
name|NULL
condition|)
block|{
name|putstr
argument_list|(
name|donemsg
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"  (press RETURN)"
argument_list|)
expr_stmt|;
name|get_return
argument_list|()
expr_stmt|;
name|putchr
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
name|init
argument_list|()
expr_stmt|;
name|screen_trashed
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|MSDOS_COMPILER
comment|/* 	 * Restore the previous directory (possibly 	 * changed by the child program we just ran). 	 */
name|chdir
argument_list|(
name|cwd
argument_list|)
expr_stmt|;
if|#
directive|if
name|MSDOS_COMPILER
operator|!=
name|DJGPPC
comment|/* 	 * Some versions of chdir() don't change to the drive 	 * which is part of CWD.  (DJGPP does this in chdir.) 	 */
if|if
condition|(
name|cwd
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|cwd
index|[
literal|0
index|]
operator|>=
literal|'a'
operator|&&
name|cwd
index|[
literal|0
index|]
operator|<=
literal|'z'
condition|)
name|setdisk
argument_list|(
name|cwd
index|[
literal|0
index|]
operator|-
literal|'a'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cwd
index|[
literal|0
index|]
operator|>=
literal|'A'
operator|&&
name|cwd
index|[
literal|0
index|]
operator|<=
literal|'Z'
condition|)
name|setdisk
argument_list|(
name|cwd
index|[
literal|0
index|]
operator|-
literal|'A'
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* 	 * Reopen the current input file. 	 */
name|reedit_ifile
argument_list|(
name|save_ifile
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SIGWINCH
argument_list|)
operator|||
name|defined
argument_list|(
name|SIGWIND
argument_list|)
comment|/* 	 * Since we were ignoring window change signals while we executed 	 * the system command, we must assume the window changed. 	 * Warning: this leaves a signal pending (in "sigs"), 	 * so psignals() should be called soon after lsystem(). 	 */
name|winch
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|PIPEC
end_if

begin_comment
comment|/*  * Pipe a section of the input file into the given shell command.  * The section to be piped is the section "between" the current  * position and the position marked by the given letter.  *  * If the mark is after the current screen, the section between  * the top line displayed and the mark is piped.  * If the mark is before the current screen, the section between  * the mark and the bottom line displayed is piped.  * If the mark is on the current screen, or if the mark is ".",  * the whole current screen is piped.  */
end_comment

begin_function
name|public
name|int
name|pipe_mark
parameter_list|(
name|c
parameter_list|,
name|cmd
parameter_list|)
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
block|{
name|POSITION
name|mpos
decl_stmt|,
name|tpos
decl_stmt|,
name|bpos
decl_stmt|;
comment|/* 	 * mpos = the marked position. 	 * tpos = top of screen. 	 * bpos = bottom of screen. 	 */
name|mpos
operator|=
name|markpos
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpos
operator|==
name|NULL_POSITION
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|tpos
operator|=
name|position
argument_list|(
name|TOP
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpos
operator|==
name|NULL_POSITION
condition|)
name|tpos
operator|=
name|ch_zero
argument_list|()
expr_stmt|;
name|bpos
operator|=
name|position
argument_list|(
name|BOTTOM
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
return|return
operator|(
name|pipe_data
argument_list|(
name|cmd
argument_list|,
name|tpos
argument_list|,
name|bpos
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|mpos
operator|<=
name|tpos
condition|)
return|return
operator|(
name|pipe_data
argument_list|(
name|cmd
argument_list|,
name|mpos
argument_list|,
name|bpos
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|bpos
operator|==
name|NULL_POSITION
condition|)
return|return
operator|(
name|pipe_data
argument_list|(
name|cmd
argument_list|,
name|tpos
argument_list|,
name|bpos
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|pipe_data
argument_list|(
name|cmd
argument_list|,
name|tpos
argument_list|,
name|mpos
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a pipe to the given shell command.  * Feed it the file contents between the positions spos and epos.  */
end_comment

begin_function
name|public
name|int
name|pipe_data
parameter_list|(
name|cmd
parameter_list|,
name|spos
parameter_list|,
name|epos
parameter_list|)
name|char
modifier|*
name|cmd
decl_stmt|;
name|POSITION
name|spos
decl_stmt|;
name|POSITION
name|epos
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|extern
name|FILE
modifier|*
name|popen
parameter_list|()
function_decl|;
comment|/* 	 * This is structured much like lsystem(). 	 * Since we're running a shell program, we must be careful 	 * to perform the necessary deinitialization before running 	 * the command, and reinitialization after it. 	 */
if|if
condition|(
name|ch_seek
argument_list|(
name|spos
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Cannot seek to start position"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|f
operator|=
name|popen
argument_list|(
name|cmd
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"Cannot create pipe"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|clear_bot
argument_list|()
expr_stmt|;
name|putstr
argument_list|(
literal|"!"
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|deinit
argument_list|()
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
name|raw_mode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|init_signals
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|MSDOS_COMPILER
operator|==
name|WIN32C
name|close_getchr
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGPIPE
name|LSIGNAL
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|c
operator|=
name|EOI
expr_stmt|;
while|while
condition|(
name|epos
operator|==
name|NULL_POSITION
operator|||
name|spos
operator|++
operator|<=
name|epos
condition|)
block|{
comment|/* 		 * Read a character from the file and give it to the pipe. 		 */
name|c
operator|=
name|ch_forw_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOI
condition|)
break|break;
if|if
condition|(
name|putc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
operator|==
name|EOF
condition|)
break|break;
block|}
comment|/* 	 * Finish up the last line. 	 */
while|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOI
condition|)
block|{
name|c
operator|=
name|ch_forw_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOI
condition|)
break|break;
if|if
condition|(
name|putc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
operator|==
name|EOF
condition|)
break|break;
block|}
name|pclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGPIPE
name|LSIGNAL
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|MSDOS_COMPILER
operator|==
name|WIN32C
name|open_getchr
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|init_signals
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|raw_mode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|init
argument_list|()
expr_stmt|;
name|screen_trashed
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SIGWINCH
argument_list|)
operator|||
name|defined
argument_list|(
name|SIGWIND
argument_list|)
comment|/* {{ Probably don't need this here. }} */
name|winch
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_OSK
end_ifdef

begin_comment
comment|/*  *    Popen, and Pclose, for OS-9.  *  *    Based on code copyright (c) 1988 by Wolfgang Ocker, Puchheim,  *                                        Ulli Dessauer, Germering and  *                                        Reimer Mellin, Muenchen  *                                        (W-Germany)  *  *    These functions can be copied and distributed freely for any  *    non-commercial purposes.  It can only be incorporated into  *    commercial software with the written permission of the authors.  *  *    TOP-specific code stripped out and adapted for less by M.Gregorie, 1996  *  *    address:    Wolfgang Ocker  *                Lochhauserstrasse 35a  *                D-8039 Puchheim  *                West Germany  *  *    e-mail:     weo@altger.UUCP, ud@altger.UUCP, ram@altger.UUCP  *                pyramid!tmpmbx!recco!weo  *                pyramid!tmpmbx!nitmar!ud  *                pyramid!tmpmbx!ramsys!ram  *  *                Martin Gregorie  *                10 Sadlers Mead  *                Harlow  *                Essex, CM18 6HG  *                U.K.  *  *                gregorie@logica.com  */
end_comment

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|os9forkc
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|pids
index|[
name|_NFILE
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   * p o p e n  */
end_comment

begin_function
name|FILE
modifier|*
name|popen
parameter_list|(
name|name
parameter_list|,
name|mode
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|mode
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|,
name|fd2
decl_stmt|,
name|fdsav
decl_stmt|,
name|pid
decl_stmt|;
specifier|static
name|char
modifier|*
name|argv
index|[]
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
specifier|static
name|char
name|cmd
index|[
literal|200
index|]
decl_stmt|;
specifier|static
name|char
name|cmd_path
index|[
literal|200
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|shell
decl_stmt|;
name|FILE
modifier|*
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|shell
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|cp
operator|=
name|name
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|==
literal|' '
condition|)
name|cp
operator|++
expr_stmt|;
name|strcpy
argument_list|(
name|cmd_path
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|=
name|index
argument_list|(
name|cmd_path
argument_list|,
literal|' '
argument_list|)
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|strcpy
argument_list|(
name|cmd
argument_list|,
literal|"ex "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|cmd
argument_list|,
name|cmd_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
name|strcat
argument_list|(
name|cmd
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|cmd
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
name|argv
index|[
literal|0
index|]
operator|=
name|shell
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|=
name|cmd
expr_stmt|;
comment|/*          mode is "r" (stdout) or "w" (stdin)     */
switch|switch
condition|(
name|mode
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'w'
case|:
name|fd
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|fd
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|fd
operator|==
literal|1
condition|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fdsav
operator|=
name|dup
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|creat
argument_list|(
literal|"/pipe"
argument_list|,
name|S_IWRITE
operator|+
name|S_IREAD
argument_list|)
expr_stmt|;
name|pid
operator|=
name|os9exec
argument_list|(
name|os9forkc
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
argument_list|,
name|environ
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|fd2
operator|=
name|dup
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|fdsav
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fdsav
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|>
literal|0
condition|)
block|{
name|pids
index|[
name|fd2
index|]
operator|=
name|pid
expr_stmt|;
name|r
operator|=
name|fdopen
argument_list|(
name|fd2
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|close
argument_list|(
name|fd2
argument_list|)
expr_stmt|;
name|r
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * p c l o s e  */
end_comment

begin_function
name|int
name|pclose
parameter_list|(
name|fp
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|unsigned
name|int
name|status
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|i
decl_stmt|;
name|fd
operator|=
name|fileno
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pids
index|[
name|fd
index|]
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|pid
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
if|if
condition|(
name|pid
operator|==
name|pids
index|[
name|fd
index|]
condition|)
break|break;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|_NFILE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pids
index|[
name|i
index|]
operator|==
name|pid
condition|)
block|{
name|pids
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
name|status
operator|=
operator|-
literal|1
expr_stmt|;
name|pids
index|[
name|fd
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _OSK */
end_comment

end_unit

