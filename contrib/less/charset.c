begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1984-2015  Mark Nudelman  *  * You may distribute under the terms of either the GNU General Public  * License or the Less License, as specified in the README file.  *  * For more information, see the README file.  */
end_comment

begin_comment
comment|/*  * Functions to define the character set  * and do things specific to the character set.  */
end_comment

begin_include
include|#
directive|include
file|"less.h"
end_include

begin_if
if|#
directive|if
name|HAVE_LOCALE
end_if

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<langinfo.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"charset.h"
end_include

begin_decl_stmt
name|public
name|int
name|utf_mode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Predefined character sets,  * selected by the LESSCHARSET environment variable.  */
end_comment

begin_struct
struct|struct
name|charset
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
modifier|*
name|p_flag
decl_stmt|;
name|char
modifier|*
name|desc
decl_stmt|;
block|}
name|charsets
index|[]
init|=
block|{
block|{
literal|"ascii"
block|,
name|NULL
block|,
literal|"8bcccbcc18b95.b"
block|}
block|,
block|{
literal|"utf-8"
block|,
operator|&
name|utf_mode
block|,
literal|"8bcccbcc18b95.b126.bb"
block|}
block|,
block|{
literal|"iso8859"
block|,
name|NULL
block|,
literal|"8bcccbcc18b95.33b."
block|}
block|,
block|{
literal|"latin3"
block|,
name|NULL
block|,
literal|"8bcccbcc18b95.33b5.b8.b15.b4.b12.b18.b12.b."
block|}
block|,
block|{
literal|"arabic"
block|,
name|NULL
block|,
literal|"8bcccbcc18b95.33b.3b.7b2.13b.3b.b26.5b19.b"
block|}
block|,
block|{
literal|"greek"
block|,
name|NULL
block|,
literal|"8bcccbcc18b95.33b4.2b4.b3.b35.b44.b"
block|}
block|,
block|{
literal|"greek2005"
block|,
name|NULL
block|,
literal|"8bcccbcc18b95.33b14.b35.b44.b"
block|}
block|,
block|{
literal|"hebrew"
block|,
name|NULL
block|,
literal|"8bcccbcc18b95.33b.b29.32b28.2b2.b"
block|}
block|,
block|{
literal|"koi8-r"
block|,
name|NULL
block|,
literal|"8bcccbcc18b95.b."
block|}
block|,
block|{
literal|"KOI8-T"
block|,
name|NULL
block|,
literal|"8bcccbcc18b95.b8.b6.b8.b.b.5b7.3b4.b4.b3.b.b.3b."
block|}
block|,
block|{
literal|"georgianps"
block|,
name|NULL
block|,
literal|"8bcccbcc18b95.3b11.4b12.2b."
block|}
block|,
block|{
literal|"tcvn"
block|,
name|NULL
block|,
literal|"b..b...bcccbccbbb7.8b95.b48.5b."
block|}
block|,
block|{
literal|"TIS-620"
block|,
name|NULL
block|,
literal|"8bcccbcc18b95.b.4b.11b7.8b."
block|}
block|,
block|{
literal|"next"
block|,
name|NULL
block|,
literal|"8bcccbcc18b95.bb125.bb"
block|}
block|,
block|{
literal|"dos"
block|,
name|NULL
block|,
literal|"8bcccbcc12bc5b95.b."
block|}
block|,
block|{
literal|"windows-1251"
block|,
name|NULL
block|,
literal|"8bcccbcc12bc5b95.b24.b."
block|}
block|,
block|{
literal|"windows-1252"
block|,
name|NULL
block|,
literal|"8bcccbcc12bc5b95.b.b11.b.2b12.b."
block|}
block|,
block|{
literal|"windows-1255"
block|,
name|NULL
block|,
literal|"8bcccbcc12bc5b95.b.b8.b.5b9.b.4b."
block|}
block|,
block|{
literal|"ebcdic"
block|,
name|NULL
block|,
literal|"5bc6bcc7bcc41b.9b7.9b5.b..8b6.10b6.b9.7b9.8b8.17b3.3b9.7b9.8b8.6b10.b.b.b."
block|}
block|,
block|{
literal|"IBM-1047"
block|,
name|NULL
block|,
literal|"4cbcbc3b9cbccbccbb4c6bcc5b3cbbc4bc4bccbc191.b"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_comment
comment|/*  * Support "locale charmap"/nl_langinfo(CODESET) values, as well as others.  */
end_comment

begin_struct
struct|struct
name|cs_alias
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|oname
decl_stmt|;
block|}
name|cs_aliases
index|[]
init|=
block|{
block|{
literal|"UTF-8"
block|,
literal|"utf-8"
block|}
block|,
block|{
literal|"ANSI_X3.4-1968"
block|,
literal|"ascii"
block|}
block|,
block|{
literal|"US-ASCII"
block|,
literal|"ascii"
block|}
block|,
block|{
literal|"latin1"
block|,
literal|"iso8859"
block|}
block|,
block|{
literal|"ISO-8859-1"
block|,
literal|"iso8859"
block|}
block|,
block|{
literal|"latin9"
block|,
literal|"iso8859"
block|}
block|,
block|{
literal|"ISO-8859-15"
block|,
literal|"iso8859"
block|}
block|,
block|{
literal|"latin2"
block|,
literal|"iso8859"
block|}
block|,
block|{
literal|"ISO-8859-2"
block|,
literal|"iso8859"
block|}
block|,
block|{
literal|"ISO-8859-3"
block|,
literal|"latin3"
block|}
block|,
block|{
literal|"latin4"
block|,
literal|"iso8859"
block|}
block|,
block|{
literal|"ISO-8859-4"
block|,
literal|"iso8859"
block|}
block|,
block|{
literal|"cyrillic"
block|,
literal|"iso8859"
block|}
block|,
block|{
literal|"ISO-8859-5"
block|,
literal|"iso8859"
block|}
block|,
block|{
literal|"ISO-8859-6"
block|,
literal|"arabic"
block|}
block|,
block|{
literal|"ISO-8859-7"
block|,
literal|"greek"
block|}
block|,
block|{
literal|"IBM9005"
block|,
literal|"greek2005"
block|}
block|,
block|{
literal|"ISO-8859-8"
block|,
literal|"hebrew"
block|}
block|,
block|{
literal|"latin5"
block|,
literal|"iso8859"
block|}
block|,
block|{
literal|"ISO-8859-9"
block|,
literal|"iso8859"
block|}
block|,
block|{
literal|"latin6"
block|,
literal|"iso8859"
block|}
block|,
block|{
literal|"ISO-8859-10"
block|,
literal|"iso8859"
block|}
block|,
block|{
literal|"latin7"
block|,
literal|"iso8859"
block|}
block|,
block|{
literal|"ISO-8859-13"
block|,
literal|"iso8859"
block|}
block|,
block|{
literal|"latin8"
block|,
literal|"iso8859"
block|}
block|,
block|{
literal|"ISO-8859-14"
block|,
literal|"iso8859"
block|}
block|,
block|{
literal|"latin10"
block|,
literal|"iso8859"
block|}
block|,
block|{
literal|"ISO-8859-16"
block|,
literal|"iso8859"
block|}
block|,
block|{
literal|"IBM437"
block|,
literal|"dos"
block|}
block|,
block|{
literal|"EBCDIC-US"
block|,
literal|"ebcdic"
block|}
block|,
block|{
literal|"IBM1047"
block|,
literal|"IBM-1047"
block|}
block|,
block|{
literal|"KOI8-R"
block|,
literal|"koi8-r"
block|}
block|,
block|{
literal|"KOI8-U"
block|,
literal|"koi8-r"
block|}
block|,
block|{
literal|"GEORGIAN-PS"
block|,
literal|"georgianps"
block|}
block|,
block|{
literal|"TCVN5712-1"
block|,
literal|"tcvn"
block|}
block|,
block|{
literal|"NEXTSTEP"
block|,
literal|"next"
block|}
block|,
block|{
literal|"windows"
block|,
literal|"windows-1252"
block|}
block|,
comment|/* backward compatibility */
block|{
literal|"CP1251"
block|,
literal|"windows-1251"
block|}
block|,
block|{
literal|"CP1252"
block|,
literal|"windows-1252"
block|}
block|,
block|{
literal|"CP1255"
block|,
literal|"windows-1255"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|IS_BINARY_CHAR
value|01
end_define

begin_define
define|#
directive|define
name|IS_CONTROL_CHAR
value|02
end_define

begin_decl_stmt
specifier|static
name|char
name|chardef
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|binfmt
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|utfbinfmt
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|int
name|binattr
init|=
name|AT_STANDOUT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Define a charset, given a description string.  * The string consists of 256 letters,  * one for each character in the charset.  * If the string is shorter than 256 letters, missing letters  * are taken to be identical to the last one.  * A decimal number followed by a letter is taken to be a   * repetition of the letter.  *  * Each letter is one of:  *	. normal character  *	b binary character  *	c control character  */
end_comment

begin_function
specifier|static
name|void
name|ichardef
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|n
decl_stmt|;
name|char
name|v
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|v
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|chardef
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
block|{
switch|switch
condition|(
operator|*
name|s
operator|++
condition|)
block|{
case|case
literal|'.'
case|:
name|v
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|v
operator|=
name|IS_CONTROL_CHAR
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|v
operator|=
name|IS_BINARY_CHAR
operator||
name|IS_CONTROL_CHAR
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|n
operator|=
operator|(
literal|10
operator|*
name|n
operator|)
operator|+
operator|(
name|s
index|[
operator|-
literal|1
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
continue|continue;
default|default:
name|error
argument_list|(
literal|"invalid chardef"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
name|quit
argument_list|(
name|QUIT_ERROR
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
do|do
block|{
if|if
condition|(
name|cp
operator|>=
name|chardef
operator|+
sizeof|sizeof
argument_list|(
name|chardef
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"chardef longer than 256"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
name|quit
argument_list|(
name|QUIT_ERROR
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
operator|*
name|cp
operator|++
operator|=
name|v
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|n
operator|>
literal|0
condition|)
do|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|cp
operator|<
name|chardef
operator|+
sizeof|sizeof
argument_list|(
name|chardef
argument_list|)
condition|)
operator|*
name|cp
operator|++
operator|=
name|v
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Define a charset, given a charset name.  * The valid charset names are listed in the "charsets" array.  */
end_comment

begin_function
specifier|static
name|int
name|icharset
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|no_error
parameter_list|)
block|{
name|struct
name|charset
modifier|*
name|p
decl_stmt|;
name|struct
name|cs_alias
modifier|*
name|a
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
operator|*
name|name
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* First see if the name is an alias. */
for|for
control|(
name|a
operator|=
name|cs_aliases
init|;
name|a
operator|->
name|name
operator|!=
name|NULL
condition|;
name|a
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|a
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|name
operator|=
name|a
operator|->
name|oname
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|p
operator|=
name|charsets
init|;
name|p
operator|->
name|name
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|p
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ichardef
argument_list|(
name|p
operator|->
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_flag
operator|!=
name|NULL
condition|)
operator|*
operator|(
name|p
operator|->
name|p_flag
operator|)
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|!
name|no_error
condition|)
block|{
name|error
argument_list|(
literal|"invalid charset name"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
name|quit
argument_list|(
name|QUIT_ERROR
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|HAVE_LOCALE
end_if

begin_comment
comment|/*  * Define a charset, given a locale name.  */
end_comment

begin_function
specifier|static
name|void
name|ilocale
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|chardef
argument_list|)
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
name|chardef
index|[
name|c
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|iscntrl
argument_list|(
name|c
argument_list|)
condition|)
name|chardef
index|[
name|c
index|]
operator|=
name|IS_CONTROL_CHAR
expr_stmt|;
else|else
name|chardef
index|[
name|c
index|]
operator|=
name|IS_BINARY_CHAR
operator||
name|IS_CONTROL_CHAR
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Define the printing format for control (or binary utf) chars.  */
end_comment

begin_function
specifier|static
name|void
name|setbinfmt
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|char
modifier|*
modifier|*
name|fmtvarptr
parameter_list|,
name|char
modifier|*
name|default_fmt
parameter_list|)
block|{
if|if
condition|(
name|s
operator|&&
name|utf_mode
condition|)
block|{
comment|/* It would be too hard to account for width otherwise.  */
name|char
modifier|*
name|t
init|=
name|s
decl_stmt|;
while|while
condition|(
operator|*
name|t
condition|)
block|{
if|if
condition|(
operator|*
name|t
operator|<
literal|' '
operator|||
operator|*
name|t
operator|>
literal|'~'
condition|)
block|{
name|s
operator|=
name|default_fmt
expr_stmt|;
goto|goto
name|attr
goto|;
block|}
name|t
operator|++
expr_stmt|;
block|}
block|}
comment|/* %n is evil */
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|*
name|s
operator|==
literal|'\0'
operator|||
operator|(
operator|*
name|s
operator|==
literal|'*'
operator|&&
operator|(
name|s
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
name|s
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|||
name|strchr
argument_list|(
name|s
operator|+
literal|2
argument_list|,
literal|'n'
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|*
name|s
operator|!=
literal|'*'
operator|&&
name|strchr
argument_list|(
name|s
argument_list|,
literal|'n'
argument_list|)
operator|)
condition|)
name|s
operator|=
name|default_fmt
expr_stmt|;
comment|/* 	 * Select the attributes if it starts with "*". 	 */
name|attr
label|:
if|if
condition|(
operator|*
name|s
operator|==
literal|'*'
condition|)
block|{
switch|switch
condition|(
name|s
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'d'
case|:
name|binattr
operator|=
name|AT_BOLD
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|binattr
operator|=
name|AT_BLINK
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|binattr
operator|=
name|AT_STANDOUT
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|binattr
operator|=
name|AT_UNDERLINE
expr_stmt|;
break|break;
default|default:
name|binattr
operator|=
name|AT_NORMAL
expr_stmt|;
break|break;
block|}
name|s
operator|+=
literal|2
expr_stmt|;
block|}
operator|*
name|fmtvarptr
operator|=
name|s
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
specifier|static
name|void
name|set_charset
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
comment|/* 	 * See if environment variable LESSCHARSET is defined. 	 */
name|s
operator|=
name|lgetenv
argument_list|(
literal|"LESSCHARSET"
argument_list|)
expr_stmt|;
if|if
condition|(
name|icharset
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
comment|/* 	 * LESSCHARSET is not defined: try LESSCHARDEF. 	 */
name|s
operator|=
name|lgetenv
argument_list|(
literal|"LESSCHARDEF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|*
name|s
operator|!=
literal|'\0'
condition|)
block|{
name|ichardef
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|HAVE_LOCALE
ifdef|#
directive|ifdef
name|CODESET
comment|/* 	 * Try using the codeset name as the charset name. 	 */
name|s
operator|=
name|nl_langinfo
argument_list|(
name|CODESET
argument_list|)
expr_stmt|;
if|if
condition|(
name|icharset
argument_list|(
name|s
argument_list|,
literal|1
argument_list|)
condition|)
return|return;
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|HAVE_STRSTR
comment|/* 	 * Check whether LC_ALL, LC_CTYPE or LANG look like UTF-8 is used. 	 */
if|if
condition|(
operator|(
name|s
operator|=
name|lgetenv
argument_list|(
literal|"LC_ALL"
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|s
operator|=
name|lgetenv
argument_list|(
literal|"LC_CTYPE"
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|s
operator|=
name|lgetenv
argument_list|(
literal|"LANG"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strstr
argument_list|(
name|s
argument_list|,
literal|"UTF-8"
argument_list|)
operator|!=
name|NULL
operator|||
name|strstr
argument_list|(
name|s
argument_list|,
literal|"utf-8"
argument_list|)
operator|!=
name|NULL
operator|||
name|strstr
argument_list|(
name|s
argument_list|,
literal|"UTF8"
argument_list|)
operator|!=
name|NULL
operator|||
name|strstr
argument_list|(
name|s
argument_list|,
literal|"utf8"
argument_list|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|icharset
argument_list|(
literal|"utf-8"
argument_list|,
literal|1
argument_list|)
condition|)
return|return;
block|}
endif|#
directive|endif
if|#
directive|if
name|HAVE_LOCALE
comment|/* 	 * Get character definitions from locale functions, 	 * rather than from predefined charset entry. 	 */
name|ilocale
argument_list|()
expr_stmt|;
if|#
directive|if
name|MSDOS_COMPILER
comment|/* 	 * Default to "dos". 	 */
operator|(
name|void
operator|)
name|icharset
argument_list|(
literal|"dos"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* 	 * Default to "latin1". 	 */
operator|(
name|void
operator|)
name|icharset
argument_list|(
literal|"latin1"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Initialize charset data structures.  */
end_comment

begin_function
name|public
name|void
name|init_charset
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|#
directive|if
name|HAVE_LOCALE
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|set_charset
argument_list|()
expr_stmt|;
name|s
operator|=
name|lgetenv
argument_list|(
literal|"LESSBINFMT"
argument_list|)
expr_stmt|;
name|setbinfmt
argument_list|(
name|s
argument_list|,
operator|&
name|binfmt
argument_list|,
literal|"*s<%02X>"
argument_list|)
expr_stmt|;
name|s
operator|=
name|lgetenv
argument_list|(
literal|"LESSUTFBINFMT"
argument_list|)
expr_stmt|;
name|setbinfmt
argument_list|(
name|s
argument_list|,
operator|&
name|utfbinfmt
argument_list|,
literal|"<U+%04lX>"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Is a given character a "binary" character?  */
end_comment

begin_function
name|public
name|int
name|binary_char
parameter_list|(
name|LWCHAR
name|c
parameter_list|)
block|{
if|if
condition|(
name|utf_mode
condition|)
return|return
operator|(
name|is_ubin_char
argument_list|(
name|c
argument_list|)
operator|)
return|;
name|c
operator|&=
literal|0377
expr_stmt|;
return|return
operator|(
name|chardef
index|[
name|c
index|]
operator|&
name|IS_BINARY_CHAR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Is a given character a "control" character?  */
end_comment

begin_function
name|public
name|int
name|control_char
parameter_list|(
name|LWCHAR
name|c
parameter_list|)
block|{
name|c
operator|&=
literal|0377
expr_stmt|;
return|return
operator|(
name|chardef
index|[
name|c
index|]
operator|&
name|IS_CONTROL_CHAR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the printable form of a character.  * For example, in the "ascii" charset '\3' is printed as "^C".  */
end_comment

begin_function
name|public
name|char
modifier|*
name|prchar
parameter_list|(
name|LWCHAR
name|c
parameter_list|)
block|{
comment|/* {{ This buffer can be overrun if LESSBINFMT is a long string. }} */
specifier|static
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|c
operator|&=
literal|0377
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|<
literal|128
operator|||
operator|!
name|utf_mode
operator|)
operator|&&
operator|!
name|control_char
argument_list|(
name|c
argument_list|)
condition|)
name|SNPRINTF1
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%c"
argument_list|,
operator|(
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|ESC
condition|)
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"ESC"
argument_list|)
expr_stmt|;
if|#
directive|if
name|IS_EBCDIC_HOST
elseif|else
if|if
condition|(
operator|!
name|binary_char
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|<
literal|64
condition|)
name|SNPRINTF1
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"^%c"
argument_list|,
comment|/* 		 * This array roughly inverts CONTROL() #defined in less.h, 	 	 * and should be kept in sync with CONTROL() and IBM-1047.  	 	 */
literal|"@ABC.I.?...KLMNO"
literal|"PQRS.JH.XY.."
literal|"\\]^_"
literal|"......W[.....EFG"
literal|"..V....D....TU.Z"
index|[
name|c
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
elseif|else
if|if
condition|(
name|c
operator|<
literal|128
operator|&&
operator|!
name|control_char
argument_list|(
name|c
operator|^
literal|0100
argument_list|)
condition|)
name|SNPRINTF1
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"^%c"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|c
operator|^
literal|0100
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
name|SNPRINTF1
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|binfmt
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the printable form of a UTF-8 character.  */
end_comment

begin_function
name|public
name|char
modifier|*
name|prutfchar
parameter_list|(
name|LWCHAR
name|ch
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
if|if
condition|(
name|ch
operator|==
name|ESC
condition|)
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"ESC"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|<
literal|128
operator|&&
name|control_char
argument_list|(
name|ch
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|control_char
argument_list|(
name|ch
operator|^
literal|0100
argument_list|)
condition|)
name|SNPRINTF1
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"^%c"
argument_list|,
operator|(
operator|(
name|char
operator|)
name|ch
operator|)
operator|^
literal|0100
argument_list|)
expr_stmt|;
else|else
name|SNPRINTF1
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|binfmt
argument_list|,
operator|(
name|char
operator|)
name|ch
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_ubin_char
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|SNPRINTF1
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|utfbinfmt
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
if|if
condition|(
name|ch
operator|>=
literal|0x80000000
condition|)
name|ch
operator|=
literal|0xFFFD
expr_stmt|;
comment|/* REPLACEMENT CHARACTER */
name|put_wchar
argument_list|(
operator|&
name|p
argument_list|,
name|ch
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the length of a UTF-8 character in bytes.  */
end_comment

begin_function
name|public
name|int
name|utf_len
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ch
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|ch
operator|&
literal|0xE0
operator|)
operator|==
literal|0xC0
condition|)
return|return
literal|2
return|;
if|if
condition|(
operator|(
name|ch
operator|&
literal|0xF0
operator|)
operator|==
literal|0xE0
condition|)
return|return
literal|3
return|;
if|if
condition|(
operator|(
name|ch
operator|&
literal|0xF8
operator|)
operator|==
literal|0xF0
condition|)
return|return
literal|4
return|;
if|if
condition|(
operator|(
name|ch
operator|&
literal|0xFC
operator|)
operator|==
literal|0xF8
condition|)
return|return
literal|5
return|;
if|if
condition|(
operator|(
name|ch
operator|&
literal|0xFE
operator|)
operator|==
literal|0xFC
condition|)
return|return
literal|6
return|;
comment|/* Invalid UTF-8 encoding. */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Does the parameter point to the lead byte of a well-formed UTF-8 character?  */
end_comment

begin_function
name|public
name|int
name|is_utf8_well_formed
parameter_list|(
name|unsigned
name|char
modifier|*
name|s
parameter_list|,
name|int
name|slen
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|IS_UTF8_INVALID
argument_list|(
name|s
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|len
operator|=
name|utf_len
argument_list|(
operator|(
name|char
operator|)
name|s
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|slen
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|len
operator|==
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|len
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|<
literal|0xC2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|unsigned
name|char
name|mask
decl_stmt|;
name|mask
operator|=
operator|(
operator|~
operator|(
operator|(
literal|1
operator|<<
operator|(
literal|8
operator|-
name|len
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
operator|&
literal|0xFF
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
name|mask
operator|&&
operator|(
name|s
index|[
literal|1
index|]
operator|&
name|mask
operator|)
operator|==
literal|0x80
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|IS_UTF8_TRAIL
argument_list|(
name|s
index|[
name|i
index|]
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return number of invalid UTF-8 sequences found in a buffer.  */
end_comment

begin_function
name|public
name|int
name|utf_bin_count
parameter_list|(
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|bin_count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|is_utf8_well_formed
argument_list|(
name|data
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|int
name|clen
init|=
name|utf_len
argument_list|(
operator|*
name|data
argument_list|)
decl_stmt|;
name|data
operator|+=
name|clen
expr_stmt|;
name|len
operator|-=
name|clen
expr_stmt|;
block|}
else|else
block|{
comment|/* Skip to next lead byte. */
name|bin_count
operator|++
expr_stmt|;
do|do
block|{
operator|++
name|data
expr_stmt|;
operator|--
name|len
expr_stmt|;
block|}
do|while
condition|(
name|len
operator|>
literal|0
operator|&&
operator|!
name|IS_UTF8_LEAD
argument_list|(
operator|*
name|data
argument_list|)
condition|)
do|;
block|}
block|}
return|return
operator|(
name|bin_count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the value of a UTF-8 character.  */
end_comment

begin_function
name|public
name|LWCHAR
name|get_wchar
parameter_list|(
name|constant
name|char
modifier|*
name|p
parameter_list|)
block|{
switch|switch
condition|(
name|utf_len
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
default|default:
comment|/* 0xxxxxxx */
return|return
call|(
name|LWCHAR
call|)
argument_list|(
name|p
index|[
literal|0
index|]
operator|&
literal|0xFF
argument_list|)
return|;
case|case
literal|2
case|:
comment|/* 110xxxxx 10xxxxxx */
return|return
call|(
name|LWCHAR
call|)
argument_list|(
operator|(
operator|(
name|p
index|[
literal|0
index|]
operator|&
literal|0x1F
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
name|p
index|[
literal|1
index|]
operator|&
literal|0x3F
operator|)
argument_list|)
return|;
case|case
literal|3
case|:
comment|/* 1110xxxx 10xxxxxx 10xxxxxx */
return|return
call|(
name|LWCHAR
call|)
argument_list|(
operator|(
operator|(
name|p
index|[
literal|0
index|]
operator|&
literal|0x0F
operator|)
operator|<<
literal|12
operator|)
operator||
operator|(
operator|(
name|p
index|[
literal|1
index|]
operator|&
literal|0x3F
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
name|p
index|[
literal|2
index|]
operator|&
literal|0x3F
operator|)
argument_list|)
return|;
case|case
literal|4
case|:
comment|/* 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx */
return|return
call|(
name|LWCHAR
call|)
argument_list|(
operator|(
operator|(
name|p
index|[
literal|0
index|]
operator|&
literal|0x07
operator|)
operator|<<
literal|18
operator|)
operator||
operator|(
operator|(
name|p
index|[
literal|1
index|]
operator|&
literal|0x3F
operator|)
operator|<<
literal|12
operator|)
operator||
operator|(
operator|(
name|p
index|[
literal|2
index|]
operator|&
literal|0x3F
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
name|p
index|[
literal|3
index|]
operator|&
literal|0x3F
operator|)
argument_list|)
return|;
case|case
literal|5
case|:
comment|/* 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx */
return|return
call|(
name|LWCHAR
call|)
argument_list|(
operator|(
operator|(
name|p
index|[
literal|0
index|]
operator|&
literal|0x03
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|p
index|[
literal|1
index|]
operator|&
literal|0x3F
operator|)
operator|<<
literal|18
operator|)
operator||
operator|(
operator|(
name|p
index|[
literal|2
index|]
operator|&
literal|0x3F
operator|)
operator|<<
literal|12
operator|)
operator||
operator|(
operator|(
name|p
index|[
literal|3
index|]
operator|&
literal|0x3F
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
name|p
index|[
literal|4
index|]
operator|&
literal|0x3F
operator|)
argument_list|)
return|;
case|case
literal|6
case|:
comment|/* 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx */
return|return
call|(
name|LWCHAR
call|)
argument_list|(
operator|(
operator|(
name|p
index|[
literal|0
index|]
operator|&
literal|0x01
operator|)
operator|<<
literal|30
operator|)
operator||
operator|(
operator|(
name|p
index|[
literal|1
index|]
operator|&
literal|0x3F
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|p
index|[
literal|2
index|]
operator|&
literal|0x3F
operator|)
operator|<<
literal|18
operator|)
operator||
operator|(
operator|(
name|p
index|[
literal|3
index|]
operator|&
literal|0x3F
operator|)
operator|<<
literal|12
operator|)
operator||
operator|(
operator|(
name|p
index|[
literal|4
index|]
operator|&
literal|0x3F
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
name|p
index|[
literal|5
index|]
operator|&
literal|0x3F
operator|)
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Store a character into a UTF-8 string.  */
end_comment

begin_function
name|public
name|void
name|put_wchar
parameter_list|(
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
name|LWCHAR
name|ch
parameter_list|)
block|{
if|if
condition|(
operator|!
name|utf_mode
operator|||
name|ch
operator|<
literal|0x80
condition|)
block|{
comment|/* 0xxxxxxx */
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
operator|=
operator|(
name|char
operator|)
name|ch
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|<
literal|0x800
condition|)
block|{
comment|/* 110xxxxx 10xxxxxx */
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
literal|0xC0
operator||
operator|(
operator|(
name|ch
operator|>>
literal|6
operator|)
operator|&
literal|0x1F
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
literal|0x80
operator||
operator|(
name|ch
operator|&
literal|0x3F
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|<
literal|0x10000
condition|)
block|{
comment|/* 1110xxxx 10xxxxxx 10xxxxxx */
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
literal|0xE0
operator||
operator|(
operator|(
name|ch
operator|>>
literal|12
operator|)
operator|&
literal|0x0F
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
literal|0x80
operator||
operator|(
operator|(
name|ch
operator|>>
literal|6
operator|)
operator|&
literal|0x3F
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
literal|0x80
operator||
operator|(
name|ch
operator|&
literal|0x3F
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|<
literal|0x200000
condition|)
block|{
comment|/* 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx */
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
literal|0xF0
operator||
operator|(
operator|(
name|ch
operator|>>
literal|18
operator|)
operator|&
literal|0x07
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
literal|0x80
operator||
operator|(
operator|(
name|ch
operator|>>
literal|12
operator|)
operator|&
literal|0x3F
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
literal|0x80
operator||
operator|(
operator|(
name|ch
operator|>>
literal|6
operator|)
operator|&
literal|0x3F
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
literal|0x80
operator||
operator|(
name|ch
operator|&
literal|0x3F
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|<
literal|0x4000000
condition|)
block|{
comment|/* 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx */
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
literal|0xF0
operator||
operator|(
operator|(
name|ch
operator|>>
literal|24
operator|)
operator|&
literal|0x03
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
literal|0x80
operator||
operator|(
operator|(
name|ch
operator|>>
literal|18
operator|)
operator|&
literal|0x3F
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
literal|0x80
operator||
operator|(
operator|(
name|ch
operator|>>
literal|12
operator|)
operator|&
literal|0x3F
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
literal|0x80
operator||
operator|(
operator|(
name|ch
operator|>>
literal|6
operator|)
operator|&
literal|0x3F
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
literal|0x80
operator||
operator|(
name|ch
operator|&
literal|0x3F
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx */
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
literal|0xF0
operator||
operator|(
operator|(
name|ch
operator|>>
literal|30
operator|)
operator|&
literal|0x01
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
literal|0x80
operator||
operator|(
operator|(
name|ch
operator|>>
literal|24
operator|)
operator|&
literal|0x3F
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
literal|0x80
operator||
operator|(
operator|(
name|ch
operator|>>
literal|18
operator|)
operator|&
literal|0x3F
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
literal|0x80
operator||
operator|(
operator|(
name|ch
operator|>>
literal|12
operator|)
operator|&
literal|0x3F
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
literal|0x80
operator||
operator|(
operator|(
name|ch
operator|>>
literal|6
operator|)
operator|&
literal|0x3F
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
literal|0x80
operator||
operator|(
name|ch
operator|&
literal|0x3F
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Step forward or backward one character in a string.  */
end_comment

begin_function
name|public
name|LWCHAR
name|step_char
parameter_list|(
name|constant
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
name|signed
name|int
name|dir
parameter_list|,
name|constant
name|char
modifier|*
name|limit
parameter_list|)
block|{
name|LWCHAR
name|ch
decl_stmt|;
name|int
name|len
decl_stmt|;
name|constant
name|char
modifier|*
name|p
init|=
operator|*
name|pp
decl_stmt|;
if|if
condition|(
operator|!
name|utf_mode
condition|)
block|{
comment|/* It's easy if chars are one byte. */
if|if
condition|(
name|dir
operator|>
literal|0
condition|)
name|ch
operator|=
call|(
name|LWCHAR
call|)
argument_list|(
operator|(
name|p
operator|<
name|limit
operator|)
condition|?
operator|*
name|p
operator|++
else|:
literal|0
argument_list|)
expr_stmt|;
else|else
name|ch
operator|=
call|(
name|LWCHAR
call|)
argument_list|(
operator|(
name|p
operator|>
name|limit
operator|)
condition|?
operator|*
operator|--
name|p
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dir
operator|>
literal|0
condition|)
block|{
name|len
operator|=
name|utf_len
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|+
name|len
operator|>
name|limit
condition|)
block|{
name|ch
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|limit
expr_stmt|;
block|}
else|else
block|{
name|ch
operator|=
name|get_wchar
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|p
operator|>
name|limit
operator|&&
name|IS_UTF8_TRAIL
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|p
operator|--
expr_stmt|;
if|if
condition|(
name|p
operator|>
name|limit
condition|)
name|ch
operator|=
name|get_wchar
argument_list|(
operator|--
name|p
argument_list|)
expr_stmt|;
else|else
name|ch
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|pp
operator|=
name|p
expr_stmt|;
return|return
name|ch
return|;
block|}
end_function

begin_comment
comment|/*  * Unicode characters data  * Actual data is in the generated *.uni files.  */
end_comment

begin_define
define|#
directive|define
name|DECLARE_RANGE_TABLE_START
parameter_list|(
name|name
parameter_list|)
define|\
value|static struct wchar_range name##_array[] = {
end_define

begin_define
define|#
directive|define
name|DECLARE_RANGE_TABLE_END
parameter_list|(
name|name
parameter_list|)
define|\
value|}; struct wchar_range_table name##_table = { name##_array, sizeof(name##_array)/sizeof(*name##_array) };
end_define

begin_macro
name|DECLARE_RANGE_TABLE_START
argument_list|(
argument|compose
argument_list|)
end_macro

begin_include
include|#
directive|include
file|"compose.uni"
end_include

begin_macro
name|DECLARE_RANGE_TABLE_END
argument_list|(
argument|compose
argument_list|)
end_macro

begin_macro
name|DECLARE_RANGE_TABLE_START
argument_list|(
argument|ubin
argument_list|)
end_macro

begin_include
include|#
directive|include
file|"ubin.uni"
end_include

begin_macro
name|DECLARE_RANGE_TABLE_END
argument_list|(
argument|ubin
argument_list|)
end_macro

begin_macro
name|DECLARE_RANGE_TABLE_START
argument_list|(
argument|wide
argument_list|)
end_macro

begin_include
include|#
directive|include
file|"wide.uni"
end_include

begin_macro
name|DECLARE_RANGE_TABLE_END
argument_list|(
argument|wide
argument_list|)
end_macro

begin_comment
comment|/* comb_table is special pairs, not ranges. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|wchar_range
name|comb_table
index|[]
init|=
block|{
block|{
literal|0x0644
block|,
literal|0x0622
block|}
block|,
block|{
literal|0x0644
block|,
literal|0x0623
block|}
block|,
block|{
literal|0x0644
block|,
literal|0x0625
block|}
block|,
block|{
literal|0x0644
block|,
literal|0x0627
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|is_in_table
parameter_list|(
name|LWCHAR
name|ch
parameter_list|,
name|struct
name|wchar_range_table
modifier|*
name|table
parameter_list|)
block|{
name|int
name|hi
decl_stmt|;
name|int
name|lo
decl_stmt|;
comment|/* Binary search in the table. */
if|if
condition|(
name|ch
operator|<
name|table
operator|->
name|table
index|[
literal|0
index|]
operator|.
name|first
condition|)
return|return
literal|0
return|;
name|lo
operator|=
literal|0
expr_stmt|;
name|hi
operator|=
name|table
operator|->
name|count
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|lo
operator|<=
name|hi
condition|)
block|{
name|int
name|mid
init|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
decl_stmt|;
if|if
condition|(
name|ch
operator|>
name|table
operator|->
name|table
index|[
name|mid
index|]
operator|.
name|last
condition|)
name|lo
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|<
name|table
operator|->
name|table
index|[
name|mid
index|]
operator|.
name|first
condition|)
name|hi
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
else|else
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Is a character a UTF-8 composing character?  * If a composing character follows any char, the two combine into one glyph.  */
end_comment

begin_function
name|public
name|int
name|is_composing_char
parameter_list|(
name|LWCHAR
name|ch
parameter_list|)
block|{
return|return
name|is_in_table
argument_list|(
name|ch
argument_list|,
operator|&
name|compose_table
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Should this UTF-8 character be treated as binary?  */
end_comment

begin_function
name|public
name|int
name|is_ubin_char
parameter_list|(
name|LWCHAR
name|ch
parameter_list|)
block|{
return|return
name|is_in_table
argument_list|(
name|ch
argument_list|,
operator|&
name|ubin_table
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Is this a double width UTF-8 character?  */
end_comment

begin_function
name|public
name|int
name|is_wide_char
parameter_list|(
name|LWCHAR
name|ch
parameter_list|)
block|{
return|return
name|is_in_table
argument_list|(
name|ch
argument_list|,
operator|&
name|wide_table
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Is a character a UTF-8 combining character?  * A combining char acts like an ordinary char, but if it follows  * a specific char (not any char), the two combine into one glyph.  */
end_comment

begin_function
name|public
name|int
name|is_combining_char
parameter_list|(
name|LWCHAR
name|ch1
parameter_list|,
name|LWCHAR
name|ch2
parameter_list|)
block|{
comment|/* The table is small; use linear search. */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|comb_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|comb_table
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ch1
operator|==
name|comb_table
index|[
name|i
index|]
operator|.
name|first
operator|&&
name|ch2
operator|==
name|comb_table
index|[
name|i
index|]
operator|.
name|last
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

