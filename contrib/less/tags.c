begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1984-2015  Mark Nudelman  *  * You may distribute under the terms of either the GNU General Public  * License or the Less License, as specified in the README file.  *  * For more information, see the README file.  */
end_comment

begin_include
include|#
directive|include
file|"less.h"
end_include

begin_define
define|#
directive|define
name|WHITESP
parameter_list|(
name|c
parameter_list|)
value|((c)==' ' || (c)=='\t')
end_define

begin_if
if|#
directive|if
name|TAGS
end_if

begin_decl_stmt
name|public
name|char
name|ztags
index|[]
init|=
literal|"tags"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|char
modifier|*
name|tags
init|=
name|ztags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|curseq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|linenums
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sigs
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|tag_result
block|{
name|TAG_FOUND
block|,
name|TAG_NOFILE
block|,
name|TAG_NOTAG
block|,
name|TAG_NOTYPE
block|,
name|TAG_INTR
block|}
enum|;
end_enum

begin_comment
comment|/*  * Tag type  */
end_comment

begin_enum
enum|enum
block|{
name|T_CTAGS
block|,
comment|/* 'tags': standard and extended format (ctags) */
name|T_CTAGS_X
block|,
comment|/* stdin: cross reference format (ctags) */
name|T_GTAGS
block|,
comment|/* 'GTAGS': function defenition (global) */
name|T_GRTAGS
block|,
comment|/* 'GRTAGS': function reference (global) */
name|T_GSYMS
block|,
comment|/* 'GSYMS': other symbols (global) */
name|T_GPATH
comment|/* 'GPATH': path name (global) */
block|}
enum|;
end_enum

begin_function_decl
specifier|static
name|enum
name|tag_result
name|findctag
parameter_list|(
name|char
modifier|*
name|tag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|tag_result
name|findgtag
parameter_list|(
name|char
modifier|*
name|tag
parameter_list|,
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|nextgtag
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|prevgtag
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|POSITION
name|ctagsearch
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|POSITION
name|gtagsearch
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getentry
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
modifier|*
name|tag
parameter_list|,
name|char
modifier|*
modifier|*
name|file
parameter_list|,
name|char
modifier|*
modifier|*
name|line
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * The list of tags generated by the last findgtag() call.  *  * Use either pattern or line number.  * findgtag() always uses line number, so pattern is always NULL.  * findctag() uses either pattern (in which case line number is 0),  * or line number (in which case pattern is NULL).  */
end_comment

begin_struct
struct|struct
name|taglist
block|{
name|struct
name|tag
modifier|*
name|tl_first
decl_stmt|;
name|struct
name|tag
modifier|*
name|tl_last
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|TAG_END
value|((struct tag *)&taglist)
end_define

begin_decl_stmt
specifier|static
name|struct
name|taglist
name|taglist
init|=
block|{
name|TAG_END
block|,
name|TAG_END
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|tag
block|{
name|struct
name|tag
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
comment|/* List links */
name|char
modifier|*
name|tag_file
decl_stmt|;
comment|/* Source file containing the tag */
name|LINENUM
name|tag_linenum
decl_stmt|;
comment|/* Appropriate line number in source file */
name|char
modifier|*
name|tag_pattern
decl_stmt|;
comment|/* Pattern used to find the tag */
name|char
name|tag_endline
decl_stmt|;
comment|/* True if the pattern includes '$' */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|tag
modifier|*
name|curtag
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TAG_INS
parameter_list|(
name|tp
parameter_list|)
define|\
value|(tp)->next = TAG_END; \ 	(tp)->prev = taglist.tl_last; \ 	taglist.tl_last->next = (tp); \ 	taglist.tl_last = (tp);
end_define

begin_define
define|#
directive|define
name|TAG_RM
parameter_list|(
name|tp
parameter_list|)
define|\
value|(tp)->next->prev = (tp)->prev; \ 	(tp)->prev->next = (tp)->next;
end_define

begin_comment
comment|/*  * Delete tag structures.  */
end_comment

begin_function
name|public
name|void
name|cleantags
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|tag
modifier|*
name|tp
decl_stmt|;
comment|/* 	 * Delete any existing tag list. 	 * {{ Ideally, we wouldn't do this until after we know that we 	 *    can load some other tag information. }} 	 */
while|while
condition|(
operator|(
name|tp
operator|=
name|taglist
operator|.
name|tl_first
operator|)
operator|!=
name|TAG_END
condition|)
block|{
name|TAG_RM
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
name|curtag
operator|=
name|NULL
expr_stmt|;
name|total
operator|=
name|curseq
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create a new tag entry.  */
end_comment

begin_function
specifier|static
name|struct
name|tag
modifier|*
name|maketagent
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|file
parameter_list|,
name|LINENUM
name|linenum
parameter_list|,
name|char
modifier|*
name|pattern
parameter_list|,
name|int
name|endline
parameter_list|)
block|{
name|struct
name|tag
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
operator|(
expr|struct
name|tag
operator|*
operator|)
name|ecalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tag
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tp
operator|->
name|tag_file
operator|=
operator|(
name|char
operator|*
operator|)
name|ecalloc
argument_list|(
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tp
operator|->
name|tag_file
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|tp
operator|->
name|tag_linenum
operator|=
name|linenum
expr_stmt|;
name|tp
operator|->
name|tag_endline
operator|=
name|endline
expr_stmt|;
if|if
condition|(
name|pattern
operator|==
name|NULL
condition|)
name|tp
operator|->
name|tag_pattern
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|tp
operator|->
name|tag_pattern
operator|=
operator|(
name|char
operator|*
operator|)
name|ecalloc
argument_list|(
name|strlen
argument_list|(
name|pattern
argument_list|)
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tp
operator|->
name|tag_pattern
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|tp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get tag mode.  */
end_comment

begin_function
name|public
name|int
name|gettagtype
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|f
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|tags
argument_list|,
literal|"GTAGS"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|T_GTAGS
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|tags
argument_list|,
literal|"GRTAGS"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|T_GRTAGS
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|tags
argument_list|,
literal|"GSYMS"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|T_GSYMS
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|tags
argument_list|,
literal|"GPATH"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|T_GPATH
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|tags
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|T_CTAGS_X
return|;
name|f
operator|=
name|open
argument_list|(
name|tags
argument_list|,
name|OPEN_READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|>=
literal|0
condition|)
block|{
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
name|T_CTAGS
return|;
block|}
return|return
name|T_GTAGS
return|;
block|}
end_function

begin_comment
comment|/*  * Find tags in tag file.  * Find a tag in the "tags" file.  * Sets "tag_file" to the name of the file containing the tag,  * and "tagpattern" to the search pattern which should be used  * to find the tag.  */
end_comment

begin_function
name|public
name|void
name|findtag
parameter_list|(
name|char
modifier|*
name|tag
parameter_list|)
block|{
name|int
name|type
init|=
name|gettagtype
argument_list|()
decl_stmt|;
name|enum
name|tag_result
name|result
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|T_CTAGS
condition|)
name|result
operator|=
name|findctag
argument_list|(
name|tag
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|findgtag
argument_list|(
name|tag
argument_list|,
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|result
condition|)
block|{
case|case
name|TAG_FOUND
case|:
case|case
name|TAG_INTR
case|:
break|break;
case|case
name|TAG_NOFILE
case|:
name|error
argument_list|(
literal|"No tags file"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
break|break;
case|case
name|TAG_NOTAG
case|:
name|error
argument_list|(
literal|"No such tag in tags file"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
break|break;
case|case
name|TAG_NOTYPE
case|:
name|error
argument_list|(
literal|"unknown tag type"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Search for a tag.  */
end_comment

begin_function
name|public
name|POSITION
name|tagsearch
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|curtag
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL_POSITION
operator|)
return|;
comment|/* No gtags loaded! */
if|if
condition|(
name|curtag
operator|->
name|tag_linenum
operator|!=
literal|0
condition|)
return|return
name|gtagsearch
argument_list|()
return|;
else|else
return|return
name|ctagsearch
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/*  * Go to the next tag.  */
end_comment

begin_function
name|public
name|char
modifier|*
name|nexttag
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|char
modifier|*
name|tagfile
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
name|tagfile
operator|=
name|nextgtag
argument_list|()
expr_stmt|;
return|return
name|tagfile
return|;
block|}
end_function

begin_comment
comment|/*  * Go to the previous tag.  */
end_comment

begin_function
name|public
name|char
modifier|*
name|prevtag
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|char
modifier|*
name|tagfile
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
name|tagfile
operator|=
name|prevgtag
argument_list|()
expr_stmt|;
return|return
name|tagfile
return|;
block|}
end_function

begin_comment
comment|/*  * Return the total number of tags.  */
end_comment

begin_function
name|public
name|int
name|ntags
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|total
return|;
block|}
end_function

begin_comment
comment|/*  * Return the sequence number of current tag.  */
end_comment

begin_function
name|public
name|int
name|curr_tag
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|curseq
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  * ctags  */
end_comment

begin_comment
comment|/*  * Find tags in the "tags" file.  * Sets curtag to the first tag entry.  */
end_comment

begin_function
specifier|static
name|enum
name|tag_result
name|findctag
parameter_list|(
name|char
modifier|*
name|tag
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|taglen
decl_stmt|;
name|LINENUM
name|taglinenum
decl_stmt|;
name|char
modifier|*
name|tagfile
decl_stmt|;
name|char
modifier|*
name|tagpattern
decl_stmt|;
name|int
name|tagendline
decl_stmt|;
name|int
name|search_char
decl_stmt|;
name|int
name|err
decl_stmt|;
name|char
name|tline
index|[
name|TAGLINE_SIZE
index|]
decl_stmt|;
name|struct
name|tag
modifier|*
name|tp
decl_stmt|;
name|p
operator|=
name|shell_unquote
argument_list|(
name|tags
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|p
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
name|TAG_NOFILE
return|;
name|cleantags
argument_list|()
expr_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
name|taglen
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|tag
argument_list|)
expr_stmt|;
comment|/* 	 * Search the tags file for the desired tag. 	 */
while|while
condition|(
name|fgets
argument_list|(
name|tline
argument_list|,
sizeof|sizeof
argument_list|(
name|tline
argument_list|)
argument_list|,
name|f
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|tline
index|[
literal|0
index|]
operator|==
literal|'!'
condition|)
comment|/* Skip header of extended format. */
continue|continue;
if|if
condition|(
name|strncmp
argument_list|(
name|tag
argument_list|,
name|tline
argument_list|,
name|taglen
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|WHITESP
argument_list|(
name|tline
index|[
name|taglen
index|]
argument_list|)
condition|)
continue|continue;
comment|/* 		 * Found it. 		 * The line contains the tag, the filename and the 		 * location in the file, separated by white space. 		 * The location is either a decimal line number,  		 * or a search pattern surrounded by a pair of delimiters. 		 * Parse the line and extract these parts. 		 */
name|tagpattern
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * Skip over the whitespace after the tag name. 		 */
name|p
operator|=
name|skipsp
argument_list|(
name|tline
operator|+
name|taglen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
comment|/* File name is missing! */
continue|continue;
comment|/* 		 * Save the file name. 		 * Skip over the whitespace after the file name. 		 */
name|tagfile
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|!
name|WHITESP
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
name|skipsp
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
comment|/* Pattern is missing! */
continue|continue;
comment|/* 		 * First see if it is a line number.  		 */
name|tagendline
operator|=
literal|0
expr_stmt|;
name|taglinenum
operator|=
name|getnum
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* 			 * No, it must be a pattern. 			 * Delete the initial "^" (if present) and  			 * the final "$" from the pattern. 			 * Delete any backslash in the pattern. 			 */
name|taglinenum
operator|=
literal|0
expr_stmt|;
name|search_char
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'^'
condition|)
name|p
operator|++
expr_stmt|;
name|tagpattern
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|search_char
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
name|p
operator|++
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|tagendline
operator|=
operator|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'$'
operator|)
expr_stmt|;
if|if
condition|(
name|tagendline
condition|)
name|p
operator|--
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
name|tp
operator|=
name|maketagent
argument_list|(
name|tag
argument_list|,
name|tagfile
argument_list|,
name|taglinenum
argument_list|,
name|tagpattern
argument_list|,
name|tagendline
argument_list|)
expr_stmt|;
name|TAG_INS
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|total
operator|++
expr_stmt|;
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|total
operator|==
literal|0
condition|)
return|return
name|TAG_NOTAG
return|;
name|curtag
operator|=
name|taglist
operator|.
name|tl_first
expr_stmt|;
name|curseq
operator|=
literal|1
expr_stmt|;
return|return
name|TAG_FOUND
return|;
block|}
end_function

begin_comment
comment|/*  * Edit current tagged file.  */
end_comment

begin_function
name|public
name|int
name|edit_tagfile
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|curtag
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|edit
argument_list|(
name|curtag
operator|->
name|tag_file
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Search for a tag.  * This is a stripped-down version of search().  * We don't use search() for several reasons:  *   -	We don't want to blow away any search string we may have saved.  *   -	The various regular-expression functions (from different systems:  *	regcmp vs. re_comp) behave differently in the presence of   *	parentheses (which are almost always found in a tag).  */
end_comment

begin_function
specifier|static
name|POSITION
name|ctagsearch
parameter_list|(
name|void
parameter_list|)
block|{
name|POSITION
name|pos
decl_stmt|,
name|linepos
decl_stmt|;
name|LINENUM
name|linenum
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|pos
operator|=
name|ch_zero
argument_list|()
expr_stmt|;
name|linenum
operator|=
name|find_linenum
argument_list|(
name|pos
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Get lines until we find a matching one or  		 * until we hit end-of-file. 		 */
if|if
condition|(
name|ABORT_SIGS
argument_list|()
condition|)
return|return
operator|(
name|NULL_POSITION
operator|)
return|;
comment|/* 		 * Read the next line, and save the  		 * starting position of that line in linepos. 		 */
name|linepos
operator|=
name|pos
expr_stmt|;
name|pos
operator|=
name|forw_raw_line
argument_list|(
name|pos
argument_list|,
operator|&
name|line
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|linenum
operator|!=
literal|0
condition|)
name|linenum
operator|++
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|NULL_POSITION
condition|)
block|{
comment|/* 			 * We hit EOF without a match. 			 */
name|error
argument_list|(
literal|"Tag not found"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL_POSITION
operator|)
return|;
block|}
comment|/* 		 * If we're using line numbers, we might as well 		 * remember the information we have now (the position 		 * and line number of the current line). 		 */
if|if
condition|(
name|linenums
condition|)
name|add_lnum
argument_list|(
name|linenum
argument_list|,
name|pos
argument_list|)
expr_stmt|;
comment|/* 		 * Test the line to see if we have a match. 		 * Use strncmp because the pattern may be 		 * truncated (in the tags file) if it is too long. 		 * If tagendline is set, make sure we match all 		 * the way to end of line (no extra chars after the match). 		 */
name|len
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|curtag
operator|->
name|tag_pattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|curtag
operator|->
name|tag_pattern
argument_list|,
name|line
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|!
name|curtag
operator|->
name|tag_endline
operator|||
name|line
index|[
name|len
index|]
operator|==
literal|'\0'
operator|||
name|line
index|[
name|len
index|]
operator|==
literal|'\r'
operator|)
condition|)
block|{
name|curtag
operator|->
name|tag_linenum
operator|=
name|find_linenum
argument_list|(
name|linepos
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|linepos
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************************  * gtags  */
end_comment

begin_comment
comment|/*  * Find tags in the GLOBAL's tag file.  * The findgtag() will try and load information about the requested tag.  * It does this by calling "global -x tag" and storing the parsed output  * for future use by gtagsearch().  * Sets curtag to the first tag entry.  */
end_comment

begin_function
specifier|static
name|enum
name|tag_result
name|findgtag
parameter_list|(
name|char
modifier|*
name|tag
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|tag
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
name|type
operator|!=
name|T_CTAGS_X
operator|&&
name|tag
operator|==
name|NULL
condition|)
return|return
name|TAG_NOFILE
return|;
name|cleantags
argument_list|()
expr_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If type == T_CTAGS_X then read ctags's -x format from stdin 	 * else execute global(1) and read from it. 	 */
if|if
condition|(
name|type
operator|==
name|T_CTAGS_X
condition|)
block|{
name|fp
operator|=
name|stdin
expr_stmt|;
comment|/* Set tag default because we cannot read stdin again. */
name|tags
operator|=
name|ztags
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
operator|!
name|HAVE_POPEN
return|return
name|TAG_NOFILE
return|;
else|#
directive|else
name|char
modifier|*
name|command
decl_stmt|;
name|char
modifier|*
name|flag
decl_stmt|;
name|char
modifier|*
name|qtag
decl_stmt|;
name|char
modifier|*
name|cmd
init|=
name|lgetenv
argument_list|(
literal|"LESSGLOBALTAGS"
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmd
operator|==
name|NULL
operator|||
operator|*
name|cmd
operator|==
literal|'\0'
condition|)
return|return
name|TAG_NOFILE
return|;
comment|/* Get suitable flag value for global(1). */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_GTAGS
case|:
name|flag
operator|=
literal|""
expr_stmt|;
break|break;
case|case
name|T_GRTAGS
case|:
name|flag
operator|=
literal|"r"
expr_stmt|;
break|break;
case|case
name|T_GSYMS
case|:
name|flag
operator|=
literal|"s"
expr_stmt|;
break|break;
case|case
name|T_GPATH
case|:
name|flag
operator|=
literal|"P"
expr_stmt|;
break|break;
default|default:
return|return
name|TAG_NOTYPE
return|;
block|}
comment|/* Get our data from global(1). */
name|qtag
operator|=
name|shell_quote
argument_list|(
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|qtag
operator|==
name|NULL
condition|)
name|qtag
operator|=
name|tag
expr_stmt|;
name|command
operator|=
operator|(
name|char
operator|*
operator|)
name|ecalloc
argument_list|(
name|strlen
argument_list|(
name|cmd
argument_list|)
operator|+
name|strlen
argument_list|(
name|flag
argument_list|)
operator|+
name|strlen
argument_list|(
name|qtag
argument_list|)
operator|+
literal|5
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|command
argument_list|,
literal|"%s -x%s %s"
argument_list|,
name|cmd
argument_list|,
name|flag
argument_list|,
name|qtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|qtag
operator|!=
name|tag
condition|)
name|free
argument_list|(
name|qtag
argument_list|)
expr_stmt|;
name|fp
operator|=
name|popen
argument_list|(
name|command
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|command
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|file
decl_stmt|,
modifier|*
name|line
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|sigs
condition|)
block|{
if|#
directive|if
name|HAVE_POPEN
if|if
condition|(
name|fp
operator|!=
name|stdin
condition|)
name|pclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|TAG_INTR
return|;
block|}
name|len
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|buf
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|buf
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
block|{
name|int
name|c
decl_stmt|;
do|do
block|{
name|c
operator|=
name|fgetc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
do|;
block|}
if|if
condition|(
name|getentry
argument_list|(
name|buf
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|file
argument_list|,
operator|&
name|line
argument_list|)
condition|)
block|{
comment|/* 				 * Couldn't parse this line for some reason. 				 * We'll just pretend it never happened. 				 */
break|break;
block|}
comment|/* Make new entry and add to list. */
name|tp
operator|=
name|maketagent
argument_list|(
name|name
argument_list|,
name|file
argument_list|,
operator|(
name|LINENUM
operator|)
name|atoi
argument_list|(
name|line
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TAG_INS
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|total
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|!=
name|stdin
condition|)
block|{
if|if
condition|(
name|pclose
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|curtag
operator|=
name|NULL
expr_stmt|;
name|total
operator|=
name|curseq
operator|=
literal|0
expr_stmt|;
return|return
name|TAG_NOFILE
return|;
block|}
block|}
block|}
comment|/* Check to see if we found anything. */
name|tp
operator|=
name|taglist
operator|.
name|tl_first
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|TAG_END
condition|)
return|return
name|TAG_NOTAG
return|;
name|curtag
operator|=
name|tp
expr_stmt|;
name|curseq
operator|=
literal|1
expr_stmt|;
return|return
name|TAG_FOUND
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|circular
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1: circular tag structure */
end_comment

begin_comment
comment|/*  * Return the filename required for the next gtag in the queue that was setup  * by findgtag().  The next call to gtagsearch() will try to position at the  * appropriate tag.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|nextgtag
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|tag
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
name|curtag
operator|==
name|NULL
condition|)
comment|/* No tag loaded */
return|return
name|NULL
return|;
name|tp
operator|=
name|curtag
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|TAG_END
condition|)
block|{
if|if
condition|(
operator|!
name|circular
condition|)
return|return
name|NULL
return|;
comment|/* Wrapped around to the head of the queue */
name|curtag
operator|=
name|taglist
operator|.
name|tl_first
expr_stmt|;
name|curseq
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|curtag
operator|=
name|tp
expr_stmt|;
name|curseq
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|curtag
operator|->
name|tag_file
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the filename required for the previous gtag in the queue that was  * setup by findgtat().  The next call to gtagsearch() will try to position  * at the appropriate tag.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|prevgtag
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|tag
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
name|curtag
operator|==
name|NULL
condition|)
comment|/* No tag loaded */
return|return
name|NULL
return|;
name|tp
operator|=
name|curtag
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|TAG_END
condition|)
block|{
if|if
condition|(
operator|!
name|circular
condition|)
return|return
name|NULL
return|;
comment|/* Wrapped around to the tail of the queue */
name|curtag
operator|=
name|taglist
operator|.
name|tl_last
expr_stmt|;
name|curseq
operator|=
name|total
expr_stmt|;
block|}
else|else
block|{
name|curtag
operator|=
name|tp
expr_stmt|;
name|curseq
operator|--
expr_stmt|;
block|}
return|return
operator|(
name|curtag
operator|->
name|tag_file
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Position the current file at at what is hopefully the tag that was chosen  * using either findtag() or one of nextgtag() and prevgtag().  Returns -1  * if it was unable to position at the tag, 0 if successful.  */
end_comment

begin_function
specifier|static
name|POSITION
name|gtagsearch
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|curtag
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL_POSITION
operator|)
return|;
comment|/* No gtags loaded! */
return|return
operator|(
name|find_pos
argument_list|(
name|curtag
operator|->
name|tag_linenum
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The getentry() parses both standard and extended ctags -x format.  *  * [standard format]  *<tag><lineno><file><image>  * +------------------------------------------------  * |main     30      main.c         main(argc, argv)  * |func     21      subr.c         func(arg)  *  * The following commands write this format.  *	o Traditinal Ctags with -x option  *	o Global with -x option  *		See<http://www.gnu.org/software/global/global.html>  *  * [extended format]  *<tag><type><lineno><file><image>  * +----------------------------------------------------------  * |main     function 30      main.c         main(argc, argv)  * |func     function 21      subr.c         func(arg)  *  * The following commands write this format.  *	o Exuberant Ctags with -x option  *		See<http://ctags.sourceforge.net>  *  * Returns 0 on success, -1 on error.  * The tag, file, and line will each be NUL-terminated pointers  * into buf.  */
end_comment

begin_function
specifier|static
name|int
name|getentry
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
modifier|*
name|tag
parameter_list|,
name|char
modifier|*
modifier|*
name|file
parameter_list|,
name|char
modifier|*
modifier|*
name|line
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
for|for
control|(
operator|*
name|tag
operator|=
name|p
init|;
operator|*
name|p
operator|&&
operator|!
name|IS_SPACE
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
comment|/* tag name */
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
operator|&&
name|IS_SPACE
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
comment|/* (skip blanks) */
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * If the second part begin with other than digit, 	 * it is assumed tag type. Skip it. 	 */
if|if
condition|(
operator|!
name|IS_DIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
for|for
control|(
init|;
operator|*
name|p
operator|&&
operator|!
name|IS_SPACE
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
comment|/* (skip tag type) */
empty_stmt|;
for|for
control|(
init|;
operator|*
name|p
operator|&&
name|IS_SPACE
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
comment|/* (skip blanks) */
empty_stmt|;
block|}
if|if
condition|(
operator|!
name|IS_DIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|line
operator|=
name|p
expr_stmt|;
comment|/* line number */
for|for
control|(
operator|*
name|line
operator|=
name|p
init|;
operator|*
name|p
operator|&&
operator|!
name|IS_SPACE
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
operator|&&
name|IS_SPACE
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
comment|/* (skip blanks) */
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|file
operator|=
name|p
expr_stmt|;
comment|/* file name */
for|for
control|(
operator|*
name|file
operator|=
name|p
init|;
operator|*
name|p
operator|&&
operator|!
name|IS_SPACE
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
comment|/* value check */
if|if
condition|(
name|strlen
argument_list|(
operator|*
name|tag
argument_list|)
operator|&&
name|strlen
argument_list|(
operator|*
name|line
argument_list|)
operator|&&
name|strlen
argument_list|(
operator|*
name|file
argument_list|)
operator|&&
name|atoi
argument_list|(
operator|*
name|line
argument_list|)
operator|>
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

