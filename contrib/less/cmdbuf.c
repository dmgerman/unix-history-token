begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1984-2000  Mark Nudelman  *  * You may distribute under the terms of either the GNU General Public  * License or the Less License, as specified in the README file.  *  * For more information about less, or for information on how to   * contact the author, see the README file.  */
end_comment

begin_comment
comment|/*  * Functions which manipulate the command buffer.  * Used only by command() and related functions.  */
end_comment

begin_include
include|#
directive|include
file|"less.h"
end_include

begin_include
include|#
directive|include
file|"cmd.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|sc_width
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|cmdbuf
index|[
name|CMDBUF_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for holding a multi-char command */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cmd_col
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current column of the cursor */
end_comment

begin_decl_stmt
specifier|static
name|int
name|prompt_col
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Column of cursor just after prompt */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer into cmdbuf */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cmd_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index into cmdbuf of first displayed char */
end_comment

begin_decl_stmt
specifier|static
name|int
name|literal
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Next input char should not be interpreted */
end_comment

begin_if
if|#
directive|if
name|TAB_COMPLETE_FILENAME
end_if

begin_function_decl
specifier|static
name|int
name|cmd_complete
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * These variables are statics used by cmd_complete.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|in_completion
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tk_text
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tk_original
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tk_ipoint
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tk_trial
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|textlist
name|tk_tlist
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|cmd_left
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cmd_right
parameter_list|()
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|SPACES_IN_FILENAMES
end_if

begin_decl_stmt
name|public
name|char
name|openquote
init|=
literal|'"'
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|char
name|closequote
init|=
literal|'"'
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CMD_HISTORY
end_if

begin_comment
comment|/*  * A mlist structure represents a command history.  */
end_comment

begin_struct
struct|struct
name|mlist
block|{
name|struct
name|mlist
modifier|*
name|next
decl_stmt|;
name|struct
name|mlist
modifier|*
name|prev
decl_stmt|;
name|struct
name|mlist
modifier|*
name|curr_mp
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * These are the various command histories that exist.  */
end_comment

begin_decl_stmt
name|struct
name|mlist
name|mlist_search
init|=
block|{
operator|&
name|mlist_search
block|,
operator|&
name|mlist_search
block|,
operator|&
name|mlist_search
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|void
name|constant
modifier|*
name|ml_search
init|=
operator|(
name|void
operator|*
operator|)
operator|&
name|mlist_search
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mlist
name|mlist_examine
init|=
block|{
operator|&
name|mlist_examine
block|,
operator|&
name|mlist_examine
block|,
operator|&
name|mlist_examine
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|void
name|constant
modifier|*
name|ml_examine
init|=
operator|(
name|void
operator|*
operator|)
operator|&
name|mlist_examine
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|SHELL_ESCAPE
operator|||
name|PIPEC
end_if

begin_decl_stmt
name|struct
name|mlist
name|mlist_shell
init|=
block|{
operator|&
name|mlist_shell
block|,
operator|&
name|mlist_shell
block|,
operator|&
name|mlist_shell
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|void
name|constant
modifier|*
name|ml_shell
init|=
operator|(
name|void
operator|*
operator|)
operator|&
name|mlist_shell
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* CMD_HISTORY */
end_comment

begin_comment
comment|/* If CMD_HISTORY is off, these are just flags. */
end_comment

begin_decl_stmt
name|public
name|void
name|constant
modifier|*
name|ml_search
init|=
operator|(
name|void
operator|*
operator|)
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|void
name|constant
modifier|*
name|ml_examine
init|=
operator|(
name|void
operator|*
operator|)
literal|2
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|SHELL_ESCAPE
operator|||
name|PIPEC
end_if

begin_decl_stmt
name|public
name|void
name|constant
modifier|*
name|ml_shell
init|=
operator|(
name|void
operator|*
operator|)
literal|3
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CMD_HISTORY */
end_comment

begin_comment
comment|/*  * History for the current command.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mlist
modifier|*
name|curr_mlist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|curr_cmdflags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Reset command buffer (to empty).  */
end_comment

begin_function
name|public
name|void
name|cmd_reset
parameter_list|()
block|{
name|cp
operator|=
name|cmdbuf
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|cmd_col
operator|=
literal|0
expr_stmt|;
name|cmd_offset
operator|=
literal|0
expr_stmt|;
name|literal
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Clear command line on display.  */
end_comment

begin_function
name|public
name|void
name|clear_cmd
parameter_list|()
block|{
name|clear_bot
argument_list|()
expr_stmt|;
name|cmd_col
operator|=
name|prompt_col
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Display a string, usually as a prompt for input into the command buffer.  */
end_comment

begin_function
name|public
name|void
name|cmd_putstr
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|putstr
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|cmd_col
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|prompt_col
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * How many characters are in the command buffer?  */
end_comment

begin_function
name|public
name|int
name|len_cmdbuf
parameter_list|()
block|{
return|return
operator|(
name|strlen
argument_list|(
name|cmdbuf
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Repaint the line from cp onwards.  * Then position the cursor just after the char old_cp (a pointer into cmdbuf).  */
end_comment

begin_function
specifier|static
name|void
name|cmd_repaint
parameter_list|(
name|old_cp
parameter_list|)
name|char
modifier|*
name|old_cp
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* 	 * Repaint the line from the current position. 	 */
name|clear_eol
argument_list|()
expr_stmt|;
for|for
control|(
init|;
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
block|{
name|p
operator|=
name|prchar
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd_col
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
operator|>=
name|sc_width
condition|)
break|break;
name|putstr
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|cmd_col
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Back up the cursor to the correct position. 	 */
while|while
condition|(
name|cp
operator|>
name|old_cp
condition|)
name|cmd_left
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Put the cursor at "home" (just after the prompt),  * and set cp to the corresponding char in cmdbuf.  */
end_comment

begin_function
specifier|static
name|void
name|cmd_home
parameter_list|()
block|{
while|while
condition|(
name|cmd_col
operator|>
name|prompt_col
condition|)
block|{
name|putbs
argument_list|()
expr_stmt|;
name|cmd_col
operator|--
expr_stmt|;
block|}
name|cp
operator|=
operator|&
name|cmdbuf
index|[
name|cmd_offset
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Shift the cmdbuf display left a half-screen.  */
end_comment

begin_function
specifier|static
name|void
name|cmd_lshift
parameter_list|()
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|save_cp
decl_stmt|;
name|int
name|cols
decl_stmt|;
comment|/* 	 * Start at the first displayed char, count how far to the 	 * right we'd have to move to reach the center of the screen. 	 */
name|s
operator|=
name|cmdbuf
operator|+
name|cmd_offset
expr_stmt|;
name|cols
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cols
operator|<
operator|(
name|sc_width
operator|-
name|prompt_col
operator|)
operator|/
literal|2
operator|&&
operator|*
name|s
operator|!=
literal|'\0'
condition|)
name|cols
operator|+=
name|strlen
argument_list|(
name|prchar
argument_list|(
operator|*
name|s
operator|++
argument_list|)
argument_list|)
expr_stmt|;
name|cmd_offset
operator|=
name|s
operator|-
name|cmdbuf
expr_stmt|;
name|save_cp
operator|=
name|cp
expr_stmt|;
name|cmd_home
argument_list|()
expr_stmt|;
name|cmd_repaint
argument_list|(
name|save_cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Shift the cmdbuf display right a half-screen.  */
end_comment

begin_function
specifier|static
name|void
name|cmd_rshift
parameter_list|()
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|save_cp
decl_stmt|;
name|int
name|cols
decl_stmt|;
comment|/* 	 * Start at the first displayed char, count how far to the 	 * left we'd have to move to traverse a half-screen width 	 * of displayed characters. 	 */
name|s
operator|=
name|cmdbuf
operator|+
name|cmd_offset
expr_stmt|;
name|cols
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cols
operator|<
operator|(
name|sc_width
operator|-
name|prompt_col
operator|)
operator|/
literal|2
operator|&&
name|s
operator|>
name|cmdbuf
condition|)
block|{
name|p
operator|=
name|prchar
argument_list|(
operator|*
operator|--
name|s
argument_list|)
expr_stmt|;
name|cols
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|cmd_offset
operator|=
name|s
operator|-
name|cmdbuf
expr_stmt|;
name|save_cp
operator|=
name|cp
expr_stmt|;
name|cmd_home
argument_list|()
expr_stmt|;
name|cmd_repaint
argument_list|(
name|save_cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Move cursor right one character.  */
end_comment

begin_function
specifier|static
name|int
name|cmd_right
parameter_list|()
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
comment|/*  		 * Already at the end of the line. 		 */
return|return
operator|(
name|CC_OK
operator|)
return|;
block|}
name|p
operator|=
name|prchar
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd_col
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
operator|>=
name|sc_width
condition|)
name|cmd_lshift
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd_col
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
operator|==
name|sc_width
operator|-
literal|1
operator|&&
name|cp
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
name|cmd_lshift
argument_list|()
expr_stmt|;
name|cp
operator|++
expr_stmt|;
name|putstr
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|cmd_col
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|CC_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Move cursor left one character.  */
end_comment

begin_function
specifier|static
name|int
name|cmd_left
parameter_list|()
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|cp
operator|<=
name|cmdbuf
condition|)
block|{
comment|/* Already at the beginning of the line */
return|return
operator|(
name|CC_OK
operator|)
return|;
block|}
name|p
operator|=
name|prchar
argument_list|(
name|cp
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd_col
operator|<
name|prompt_col
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
condition|)
name|cmd_rshift
argument_list|()
expr_stmt|;
name|cp
operator|--
expr_stmt|;
name|cmd_col
operator|-=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'\0'
condition|)
name|putbs
argument_list|()
expr_stmt|;
return|return
operator|(
name|CC_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Insert a char into the command buffer, at the current position.  */
end_comment

begin_function
specifier|static
name|int
name|cmd_ichar
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|cmdbuf
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|cmdbuf
argument_list|)
operator|-
literal|2
condition|)
block|{
comment|/* 		 * No room in the command buffer for another char. 		 */
name|bell
argument_list|()
expr_stmt|;
return|return
operator|(
name|CC_ERROR
operator|)
return|;
block|}
comment|/* 	 * Insert the character into the buffer. 	 */
for|for
control|(
name|s
operator|=
operator|&
name|cmdbuf
index|[
name|strlen
argument_list|(
name|cmdbuf
argument_list|)
index|]
init|;
name|s
operator|>=
name|cp
condition|;
name|s
operator|--
control|)
name|s
index|[
literal|1
index|]
operator|=
name|s
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|cp
operator|=
name|c
expr_stmt|;
comment|/* 	 * Reprint the tail of the line from the inserted char. 	 */
name|cmd_repaint
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cmd_right
argument_list|()
expr_stmt|;
return|return
operator|(
name|CC_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Backspace in the command buffer.  * Delete the char to the left of the cursor.  */
end_comment

begin_function
specifier|static
name|int
name|cmd_erase
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|cp
operator|==
name|cmdbuf
condition|)
block|{
comment|/* 		 * Backspace past beginning of the buffer: 		 * this usually means abort the command. 		 */
return|return
operator|(
name|CC_QUIT
operator|)
return|;
block|}
comment|/* 	 * Move cursor left (to the char being erased). 	 */
name|cmd_left
argument_list|()
expr_stmt|;
comment|/* 	 * Remove the char from the buffer (shift the buffer left). 	 */
for|for
control|(
name|s
operator|=
name|cp
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
name|s
index|[
literal|0
index|]
operator|=
name|s
index|[
literal|1
index|]
expr_stmt|;
comment|/* 	 * Repaint the buffer after the erased char. 	 */
name|cmd_repaint
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* 	 * We say that erasing the entire command string causes us 	 * to abort the current command, if CF_QUIT_ON_ERASE is set. 	 */
if|if
condition|(
operator|(
name|curr_cmdflags
operator|&
name|CF_QUIT_ON_ERASE
operator|)
operator|&&
name|cp
operator|==
name|cmdbuf
operator|&&
operator|*
name|cp
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|CC_QUIT
operator|)
return|;
return|return
operator|(
name|CC_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Delete the char under the cursor.  */
end_comment

begin_function
specifier|static
name|int
name|cmd_delete
parameter_list|()
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
comment|/* 		 * At end of string; there is no char under the cursor. 		 */
return|return
operator|(
name|CC_OK
operator|)
return|;
block|}
comment|/* 	 * Move right, then use cmd_erase. 	 */
name|cmd_right
argument_list|()
expr_stmt|;
name|cmd_erase
argument_list|()
expr_stmt|;
return|return
operator|(
name|CC_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Delete the "word" to the left of the cursor.  */
end_comment

begin_function
specifier|static
name|int
name|cmd_werase
parameter_list|()
block|{
if|if
condition|(
name|cp
operator|>
name|cmdbuf
operator|&&
name|cp
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
block|{
comment|/* 		 * If the char left of cursor is a space, 		 * erase all the spaces left of cursor (to the first non-space). 		 */
while|while
condition|(
name|cp
operator|>
name|cmdbuf
operator|&&
name|cp
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
operator|(
name|void
operator|)
name|cmd_erase
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If the char left of cursor is not a space, 		 * erase all the nonspaces left of cursor (the whole "word"). 		 */
while|while
condition|(
name|cp
operator|>
name|cmdbuf
operator|&&
name|cp
index|[
operator|-
literal|1
index|]
operator|!=
literal|' '
condition|)
operator|(
name|void
operator|)
name|cmd_erase
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|CC_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Delete the "word" under the cursor.  */
end_comment

begin_function
specifier|static
name|int
name|cmd_wdelete
parameter_list|()
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|' '
condition|)
block|{
comment|/* 		 * If the char under the cursor is a space, 		 * delete it and all the spaces right of cursor. 		 */
while|while
condition|(
operator|*
name|cp
operator|==
literal|' '
condition|)
operator|(
name|void
operator|)
name|cmd_delete
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If the char under the cursor is not a space, 		 * delete it and all nonspaces right of cursor (the whole word). 		 */
while|while
condition|(
operator|*
name|cp
operator|!=
literal|' '
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|cmd_delete
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|CC_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Delete all chars in the command buffer.  */
end_comment

begin_function
specifier|static
name|int
name|cmd_kill
parameter_list|()
block|{
if|if
condition|(
name|cmdbuf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* 		 * Buffer is already empty; abort the current command. 		 */
return|return
operator|(
name|CC_QUIT
operator|)
return|;
block|}
name|cmd_offset
operator|=
literal|0
expr_stmt|;
name|cmd_home
argument_list|()
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|cmd_repaint
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* 	 * We say that erasing the entire command string causes us 	 * to abort the current command, if CF_QUIT_ON_ERASE is set. 	 */
if|if
condition|(
name|curr_cmdflags
operator|&
name|CF_QUIT_ON_ERASE
condition|)
return|return
operator|(
name|CC_QUIT
operator|)
return|;
return|return
operator|(
name|CC_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Select an mlist structure to be the current command history.  */
end_comment

begin_function
name|public
name|void
name|set_mlist
parameter_list|(
name|mlist
parameter_list|,
name|cmdflags
parameter_list|)
name|void
modifier|*
name|mlist
decl_stmt|;
name|int
name|cmdflags
decl_stmt|;
block|{
name|curr_mlist
operator|=
operator|(
expr|struct
name|mlist
operator|*
operator|)
name|mlist
expr_stmt|;
name|curr_cmdflags
operator|=
name|cmdflags
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|CMD_HISTORY
end_if

begin_comment
comment|/*  * Move up or down in the currently selected command history list.  */
end_comment

begin_function
specifier|static
name|int
name|cmd_updown
parameter_list|(
name|action
parameter_list|)
name|int
name|action
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|curr_mlist
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * The current command has no history list. 		 */
name|bell
argument_list|()
expr_stmt|;
return|return
operator|(
name|CC_OK
operator|)
return|;
block|}
name|cmd_home
argument_list|()
expr_stmt|;
name|clear_eol
argument_list|()
expr_stmt|;
comment|/* 	 * Move curr_mp to the next/prev entry. 	 */
if|if
condition|(
name|action
operator|==
name|EC_UP
condition|)
name|curr_mlist
operator|->
name|curr_mp
operator|=
name|curr_mlist
operator|->
name|curr_mp
operator|->
name|prev
expr_stmt|;
else|else
name|curr_mlist
operator|->
name|curr_mp
operator|=
name|curr_mlist
operator|->
name|curr_mp
operator|->
name|next
expr_stmt|;
comment|/* 	 * Copy the entry into cmdbuf and echo it on the screen. 	 */
name|s
operator|=
name|curr_mlist
operator|->
name|curr_mp
operator|->
name|string
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|s
operator|=
literal|""
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|cmdbuf
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
block|{
operator|*
name|cp
operator|=
operator|*
name|s
expr_stmt|;
name|cmd_right
argument_list|()
expr_stmt|;
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|CC_OK
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Add a string to a history list.  */
end_comment

begin_function
name|public
name|void
name|cmd_addhist
parameter_list|(
name|mlist
parameter_list|,
name|cmd
parameter_list|)
name|struct
name|mlist
modifier|*
name|mlist
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
block|{
if|#
directive|if
name|CMD_HISTORY
name|struct
name|mlist
modifier|*
name|ml
decl_stmt|;
comment|/* 	 * Don't save a trivial command. 	 */
if|if
condition|(
name|strlen
argument_list|(
name|cmd
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Don't save if a duplicate of a command which is already  	 * in the history. 	 * But select the one already in the history to be current. 	 */
for|for
control|(
name|ml
operator|=
name|mlist
operator|->
name|next
init|;
name|ml
operator|!=
name|mlist
condition|;
name|ml
operator|=
name|ml
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|ml
operator|->
name|string
argument_list|,
name|cmd
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|ml
operator|==
name|mlist
condition|)
block|{
comment|/* 		 * Did not find command in history. 		 * Save the command and put it at the end of the history list. 		 */
name|ml
operator|=
operator|(
expr|struct
name|mlist
operator|*
operator|)
name|ecalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mlist
argument_list|)
argument_list|)
expr_stmt|;
name|ml
operator|->
name|string
operator|=
name|save
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|ml
operator|->
name|next
operator|=
name|mlist
expr_stmt|;
name|ml
operator|->
name|prev
operator|=
name|mlist
operator|->
name|prev
expr_stmt|;
name|mlist
operator|->
name|prev
operator|->
name|next
operator|=
name|ml
expr_stmt|;
name|mlist
operator|->
name|prev
operator|=
name|ml
expr_stmt|;
block|}
comment|/* 	 * Point to the cmd just after the just-accepted command. 	 * Thus, an UPARROW will always retrieve the previous command. 	 */
name|mlist
operator|->
name|curr_mp
operator|=
name|ml
operator|->
name|next
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Accept the command in the command buffer.  * Add it to the currently selected history list.  */
end_comment

begin_function
name|public
name|void
name|cmd_accept
parameter_list|()
block|{
if|#
directive|if
name|CMD_HISTORY
comment|/* 	 * Nothing to do if there is no currently selected history list. 	 */
if|if
condition|(
name|curr_mlist
operator|==
name|NULL
condition|)
return|return;
name|cmd_addhist
argument_list|(
name|curr_mlist
argument_list|,
name|cmdbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Try to perform a line-edit function on the command buffer,  * using a specified char as a line-editing command.  * Returns:  *	CC_PASS	The char does not invoke a line edit function.  *	CC_OK	Line edit function done.  *	CC_QUIT	The char requests the current command to be aborted.  */
end_comment

begin_function
specifier|static
name|int
name|cmd_edit
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
name|int
name|action
decl_stmt|;
name|int
name|flags
decl_stmt|;
if|#
directive|if
name|TAB_COMPLETE_FILENAME
define|#
directive|define
name|not_in_completion
parameter_list|()
value|in_completion = 0
else|#
directive|else
define|#
directive|define
name|not_in_completion
parameter_list|()
endif|#
directive|endif
comment|/* 	 * See if the char is indeed a line-editing command. 	 */
name|flags
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|CMD_HISTORY
if|if
condition|(
name|curr_mlist
operator|==
name|NULL
condition|)
comment|/* 		 * No current history; don't accept history manipulation cmds. 		 */
name|flags
operator||=
name|EC_NOHISTORY
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|TAB_COMPLETE_FILENAME
if|if
condition|(
name|curr_mlist
operator|==
name|ml_search
condition|)
comment|/* 		 * In a search command; don't accept file-completion cmds. 		 */
name|flags
operator||=
name|EC_NOCOMPLETE
expr_stmt|;
endif|#
directive|endif
name|action
operator|=
name|editchar
argument_list|(
name|c
argument_list|,
name|flags
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|EC_RIGHT
case|:
name|not_in_completion
argument_list|()
expr_stmt|;
return|return
operator|(
name|cmd_right
argument_list|()
operator|)
return|;
case|case
name|EC_LEFT
case|:
name|not_in_completion
argument_list|()
expr_stmt|;
return|return
operator|(
name|cmd_left
argument_list|()
operator|)
return|;
case|case
name|EC_W_RIGHT
case|:
name|not_in_completion
argument_list|()
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|&&
operator|*
name|cp
operator|!=
literal|' '
condition|)
name|cmd_right
argument_list|()
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|==
literal|' '
condition|)
name|cmd_right
argument_list|()
expr_stmt|;
return|return
operator|(
name|CC_OK
operator|)
return|;
case|case
name|EC_W_LEFT
case|:
name|not_in_completion
argument_list|()
expr_stmt|;
while|while
condition|(
name|cp
operator|>
name|cmdbuf
operator|&&
name|cp
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|cmd_left
argument_list|()
expr_stmt|;
while|while
condition|(
name|cp
operator|>
name|cmdbuf
operator|&&
name|cp
index|[
operator|-
literal|1
index|]
operator|!=
literal|' '
condition|)
name|cmd_left
argument_list|()
expr_stmt|;
return|return
operator|(
name|CC_OK
operator|)
return|;
case|case
name|EC_HOME
case|:
name|not_in_completion
argument_list|()
expr_stmt|;
name|cmd_offset
operator|=
literal|0
expr_stmt|;
name|cmd_home
argument_list|()
expr_stmt|;
name|cmd_repaint
argument_list|(
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
name|CC_OK
operator|)
return|;
case|case
name|EC_END
case|:
name|not_in_completion
argument_list|()
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
name|cmd_right
argument_list|()
expr_stmt|;
return|return
operator|(
name|CC_OK
operator|)
return|;
case|case
name|EC_INSERT
case|:
name|not_in_completion
argument_list|()
expr_stmt|;
return|return
operator|(
name|CC_OK
operator|)
return|;
case|case
name|EC_BACKSPACE
case|:
name|not_in_completion
argument_list|()
expr_stmt|;
return|return
operator|(
name|cmd_erase
argument_list|()
operator|)
return|;
case|case
name|EC_LINEKILL
case|:
name|not_in_completion
argument_list|()
expr_stmt|;
return|return
operator|(
name|cmd_kill
argument_list|()
operator|)
return|;
case|case
name|EC_W_BACKSPACE
case|:
name|not_in_completion
argument_list|()
expr_stmt|;
return|return
operator|(
name|cmd_werase
argument_list|()
operator|)
return|;
case|case
name|EC_DELETE
case|:
name|not_in_completion
argument_list|()
expr_stmt|;
return|return
operator|(
name|cmd_delete
argument_list|()
operator|)
return|;
case|case
name|EC_W_DELETE
case|:
name|not_in_completion
argument_list|()
expr_stmt|;
return|return
operator|(
name|cmd_wdelete
argument_list|()
operator|)
return|;
case|case
name|EC_LITERAL
case|:
name|literal
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|CC_OK
operator|)
return|;
if|#
directive|if
name|CMD_HISTORY
case|case
name|EC_UP
case|:
case|case
name|EC_DOWN
case|:
name|not_in_completion
argument_list|()
expr_stmt|;
return|return
operator|(
name|cmd_updown
argument_list|(
name|action
argument_list|)
operator|)
return|;
endif|#
directive|endif
if|#
directive|if
name|TAB_COMPLETE_FILENAME
case|case
name|EC_F_COMPLETE
case|:
case|case
name|EC_B_COMPLETE
case|:
case|case
name|EC_EXPAND
case|:
return|return
operator|(
name|cmd_complete
argument_list|(
name|action
argument_list|)
operator|)
return|;
endif|#
directive|endif
case|case
name|EC_NOACTION
case|:
return|return
operator|(
name|CC_OK
operator|)
return|;
default|default:
name|not_in_completion
argument_list|()
expr_stmt|;
return|return
operator|(
name|CC_PASS
operator|)
return|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|TAB_COMPLETE_FILENAME
end_if

begin_comment
comment|/*  * Insert a string into the command buffer, at the current position.  */
end_comment

begin_function
specifier|static
name|int
name|cmd_istr
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|action
decl_stmt|;
for|for
control|(
name|s
operator|=
name|str
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
block|{
name|action
operator|=
name|cmd_ichar
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|!=
name|CC_OK
condition|)
block|{
name|bell
argument_list|()
expr_stmt|;
return|return
operator|(
name|action
operator|)
return|;
block|}
block|}
return|return
operator|(
name|CC_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the beginning and end of the "current" word.  * This is the word which the cursor (cp) is inside or at the end of.  * Return pointer to the beginning of the word and put the  * cursor at the end of the word.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|delimit_word
parameter_list|()
block|{
name|char
modifier|*
name|word
decl_stmt|;
if|#
directive|if
name|SPACES_IN_FILENAMES
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|quoted
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * Move cursor to end of word. 	 */
if|if
condition|(
operator|*
name|cp
operator|!=
literal|' '
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
comment|/* 		 * Cursor is on a nonspace. 		 * Move cursor right to the next space. 		 */
while|while
condition|(
operator|*
name|cp
operator|!=
literal|' '
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
name|cmd_right
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
operator|>
name|cmdbuf
operator|&&
name|cp
index|[
operator|-
literal|1
index|]
operator|!=
literal|' '
condition|)
block|{
comment|/* 		 * Cursor is on a space, and char to the left is a nonspace. 		 * We're already at the end of the word. 		 */
empty_stmt|;
block|}
else|else
block|{
comment|/* 		 * Cursor is on a space and char to the left is a space. 		 * Huh? There's no word here. 		 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Search backwards for beginning of the word. 	 */
if|if
condition|(
name|cp
operator|==
name|cmdbuf
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|#
directive|if
name|SPACES_IN_FILENAMES
comment|/* 	 * If we have an unbalanced quote (that is, an open quote 	 * without a corresponding close quote), we return everything 	 * from the open quote, including spaces. 	 */
name|quoted
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|cmdbuf
init|;
name|p
operator|<
name|cp
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|quoted
operator|&&
operator|*
name|p
operator|==
name|openquote
condition|)
block|{
name|quoted
operator|=
literal|1
expr_stmt|;
name|word
operator|=
name|p
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|quoted
operator|&&
operator|*
name|p
operator|==
name|closequote
condition|)
block|{
name|quoted
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|quoted
condition|)
return|return
operator|(
name|word
operator|)
return|;
endif|#
directive|endif
for|for
control|(
name|word
operator|=
name|cp
operator|-
literal|1
init|;
name|word
operator|>
name|cmdbuf
condition|;
name|word
operator|--
control|)
if|if
condition|(
name|word
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
break|break;
return|return
operator|(
name|word
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set things up to enter completion mode.  * Expand the word under the cursor into a list of filenames   * which start with that word, and set tk_text to that list.  */
end_comment

begin_function
specifier|static
name|void
name|init_compl
parameter_list|()
block|{
name|char
modifier|*
name|word
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/* 	 * Get rid of any previous tk_text. 	 */
if|if
condition|(
name|tk_text
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|tk_text
argument_list|)
expr_stmt|;
name|tk_text
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Find the original (uncompleted) word in the command buffer. 	 */
name|word
operator|=
name|delimit_word
argument_list|()
expr_stmt|;
if|if
condition|(
name|word
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Set the insertion point to the point in the command buffer 	 * where the original (uncompleted) word now sits. 	 */
name|tk_ipoint
operator|=
name|word
expr_stmt|;
comment|/* 	 * Save the original (uncompleted) word 	 */
if|if
condition|(
name|tk_original
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|tk_original
argument_list|)
expr_stmt|;
name|tk_original
operator|=
operator|(
name|char
operator|*
operator|)
name|ecalloc
argument_list|(
name|cp
operator|-
name|word
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|tk_original
argument_list|,
name|word
argument_list|,
name|cp
operator|-
name|word
argument_list|)
expr_stmt|;
comment|/* 	 * Get the expanded filename. 	 * This may result in a single filename, or 	 * a blank-separated list of filenames. 	 */
name|c
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|#
directive|if
name|SPACES_IN_FILENAMES
if|if
condition|(
operator|*
name|word
operator|==
name|openquote
condition|)
name|word
operator|++
expr_stmt|;
endif|#
directive|endif
name|tk_text
operator|=
name|fcomplete
argument_list|(
name|word
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
name|c
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the next word in the current completion list.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|next_compl
parameter_list|(
name|action
parameter_list|,
name|prev
parameter_list|)
name|int
name|action
decl_stmt|;
name|char
modifier|*
name|prev
decl_stmt|;
block|{
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|EC_F_COMPLETE
case|:
return|return
operator|(
name|forw_textlist
argument_list|(
operator|&
name|tk_tlist
argument_list|,
name|prev
argument_list|)
operator|)
return|;
case|case
name|EC_B_COMPLETE
case|:
return|return
operator|(
name|back_textlist
argument_list|(
operator|&
name|tk_tlist
argument_list|,
name|prev
argument_list|)
operator|)
return|;
block|}
comment|/* Cannot happen */
return|return
operator|(
literal|"?"
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Complete the filename before (or under) the cursor.  * cmd_complete may be called multiple times.  The global in_completion  * remembers whether this call is the first time (create the list),  * or a subsequent time (step thru the list).  */
end_comment

begin_function
specifier|static
name|int
name|cmd_complete
parameter_list|(
name|action
parameter_list|)
name|int
name|action
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|in_completion
operator|||
name|action
operator|==
name|EC_EXPAND
condition|)
block|{
comment|/* 		 * Expand the word under the cursor and  		 * use the first word in the expansion  		 * (or the entire expansion if we're doing EC_EXPAND). 		 */
name|init_compl
argument_list|()
expr_stmt|;
if|if
condition|(
name|tk_text
operator|==
name|NULL
condition|)
block|{
name|bell
argument_list|()
expr_stmt|;
return|return
operator|(
name|CC_OK
operator|)
return|;
block|}
if|if
condition|(
name|action
operator|==
name|EC_EXPAND
condition|)
block|{
comment|/* 			 * Use the whole list. 			 */
name|tk_trial
operator|=
name|tk_text
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Use the first filename in the list. 			 */
name|in_completion
operator|=
literal|1
expr_stmt|;
name|init_textlist
argument_list|(
operator|&
name|tk_tlist
argument_list|,
name|tk_text
argument_list|)
expr_stmt|;
name|tk_trial
operator|=
name|next_compl
argument_list|(
name|action
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * We already have a completion list. 		 * Use the next/previous filename from the list. 		 */
name|tk_trial
operator|=
name|next_compl
argument_list|(
name|action
argument_list|,
name|tk_trial
argument_list|)
expr_stmt|;
block|}
comment|/*   	 * Remove the original word, or the previous trial completion.   	 */
while|while
condition|(
name|cp
operator|>
name|tk_ipoint
condition|)
operator|(
name|void
operator|)
name|cmd_erase
argument_list|()
expr_stmt|;
if|if
condition|(
name|tk_trial
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * There are no more trial completions. 		 * Insert the original (uncompleted) filename. 		 */
name|in_completion
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cmd_istr
argument_list|(
name|tk_original
argument_list|)
operator|!=
name|CC_OK
condition|)
goto|goto
name|fail
goto|;
block|}
else|else
block|{
comment|/* 		 * Insert trial completion. 		 */
if|if
condition|(
name|cmd_istr
argument_list|(
name|tk_trial
argument_list|)
operator|!=
name|CC_OK
condition|)
goto|goto
name|fail
goto|;
comment|/* 		 * If it is a directory, append a slash. 		 */
if|if
condition|(
name|is_dir
argument_list|(
name|tk_trial
argument_list|)
condition|)
block|{
if|if
condition|(
name|cp
operator|>
name|cmdbuf
operator|&&
name|cp
index|[
operator|-
literal|1
index|]
operator|==
name|closequote
condition|)
operator|(
name|void
operator|)
name|cmd_erase
argument_list|()
expr_stmt|;
name|s
operator|=
name|lgetenv
argument_list|(
literal|"LESSSEPARATOR"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|s
operator|=
name|PATHNAME_SEP
expr_stmt|;
if|if
condition|(
name|cmd_istr
argument_list|(
name|s
argument_list|)
operator|!=
name|CC_OK
condition|)
goto|goto
name|fail
goto|;
block|}
block|}
return|return
operator|(
name|CC_OK
operator|)
return|;
name|fail
label|:
name|in_completion
operator|=
literal|0
expr_stmt|;
name|bell
argument_list|()
expr_stmt|;
return|return
operator|(
name|CC_OK
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TAB_COMPLETE_FILENAME */
end_comment

begin_comment
comment|/*  * Process a single character of a multi-character command, such as  * a number, or the pattern of a search command.  * Returns:  *	CC_OK		The char was accepted.  *	CC_QUIT		The char requests the command to be aborted.  *	CC_ERROR	The char could not be accepted due to an error.  */
end_comment

begin_function
name|public
name|int
name|cmd_char
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
name|int
name|action
decl_stmt|;
if|if
condition|(
name|literal
condition|)
block|{
comment|/* 		 * Insert the char, even if it is a line-editing char. 		 */
name|literal
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|cmd_ichar
argument_list|(
name|c
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * See if it is a special line-editing character. 	 */
if|if
condition|(
name|in_mca
argument_list|()
condition|)
block|{
name|action
operator|=
name|cmd_edit
argument_list|(
name|c
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|CC_OK
case|:
case|case
name|CC_QUIT
case|:
return|return
operator|(
name|action
operator|)
return|;
case|case
name|CC_PASS
case|:
break|break;
block|}
block|}
comment|/* 	 * Insert the char into the command buffer. 	 */
return|return
operator|(
name|cmd_ichar
argument_list|(
name|c
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the number currently in the command buffer.  */
end_comment

begin_function
name|public
name|int
name|cmd_int
parameter_list|()
block|{
return|return
operator|(
name|atoi
argument_list|(
name|cmdbuf
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return a pointer to the command buffer.  */
end_comment

begin_function
name|public
name|char
modifier|*
name|get_cmdbuf
parameter_list|()
block|{
return|return
operator|(
name|cmdbuf
operator|)
return|;
block|}
end_function

end_unit

