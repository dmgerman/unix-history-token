begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1984-2011  Mark Nudelman  *  * You may distribute under the terms of either the GNU General Public  * License or the Less License, as specified in the README file.  *  * For more information about less, or for information on how to   * contact the author, see the README file.  */
end_comment

begin_comment
comment|/*  * Routines dealing with getting input from the keyboard (i.e. from the user).  */
end_comment

begin_include
include|#
directive|include
file|"less.h"
end_include

begin_if
if|#
directive|if
name|OS2
end_if

begin_include
include|#
directive|include
file|"cmd.h"
end_include

begin_include
include|#
directive|include
file|"pckeys.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|MSDOS_COMPILER
operator|==
name|WIN32C
end_if

begin_include
include|#
directive|include
file|"windows.h"
end_include

begin_function_decl
specifier|extern
name|char
name|WIN32getch
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|DWORD
name|console_mode
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|public
name|int
name|tty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sigs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|utf_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Open keyboard for input.  */
end_comment

begin_function
name|public
name|void
name|open_getchr
parameter_list|()
block|{
if|#
directive|if
name|MSDOS_COMPILER
operator|==
name|WIN32C
comment|/* Need this to let child processes inherit our console handle */
name|SECURITY_ATTRIBUTES
name|sa
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sa
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|SECURITY_ATTRIBUTES
argument_list|)
argument_list|)
expr_stmt|;
name|sa
operator|.
name|nLength
operator|=
sizeof|sizeof
argument_list|(
name|SECURITY_ATTRIBUTES
argument_list|)
expr_stmt|;
name|sa
operator|.
name|bInheritHandle
operator|=
name|TRUE
expr_stmt|;
name|tty
operator|=
operator|(
name|int
operator|)
name|CreateFile
argument_list|(
literal|"CONIN$"
argument_list|,
name|GENERIC_READ
argument_list|,
name|FILE_SHARE_READ
argument_list|,
operator|&
name|sa
argument_list|,
name|OPEN_EXISTING
argument_list|,
literal|0L
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|GetConsoleMode
argument_list|(
operator|(
name|HANDLE
operator|)
name|tty
argument_list|,
operator|&
name|console_mode
argument_list|)
expr_stmt|;
comment|/* Make sure we get Ctrl+C events. */
name|SetConsoleMode
argument_list|(
operator|(
name|HANDLE
operator|)
name|tty
argument_list|,
name|ENABLE_PROCESSED_INPUT
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|MSDOS_COMPILER
specifier|extern
name|int
name|fd0
decl_stmt|;
comment|/* 	 * Open a new handle to CON: in binary mode  	 * for unbuffered keyboard read. 	 */
name|fd0
operator|=
name|dup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|tty
operator|=
name|open
argument_list|(
literal|"CON"
argument_list|,
name|OPEN_READ
argument_list|)
expr_stmt|;
if|#
directive|if
name|MSDOS_COMPILER
operator|==
name|DJGPPC
comment|/* 	 * Setting stdin to binary causes Ctrl-C to not 	 * raise SIGINT.  We must undo that side-effect. 	 */
operator|(
name|void
operator|)
name|__djgpp_set_ctrl_c
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* 	 * Try /dev/tty. 	 * If that doesn't work, use file descriptor 2, 	 * which in Unix is usually attached to the screen, 	 * but also usually lets you read from the keyboard. 	 */
if|#
directive|if
name|OS2
comment|/* The __open() system call translates "/dev/tty" to "con". */
name|tty
operator|=
name|__open
argument_list|(
literal|"/dev/tty"
argument_list|,
name|OPEN_READ
argument_list|)
expr_stmt|;
else|#
directive|else
name|tty
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
name|OPEN_READ
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tty
operator|<
literal|0
condition|)
name|tty
operator|=
literal|2
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Close the keyboard.  */
end_comment

begin_function
name|public
name|void
name|close_getchr
parameter_list|()
block|{
if|#
directive|if
name|MSDOS_COMPILER
operator|==
name|WIN32C
name|SetConsoleMode
argument_list|(
operator|(
name|HANDLE
operator|)
name|tty
argument_list|,
name|console_mode
argument_list|)
expr_stmt|;
name|CloseHandle
argument_list|(
operator|(
name|HANDLE
operator|)
name|tty
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Get a character from the keyboard.  */
end_comment

begin_function
name|public
name|int
name|getchr
parameter_list|()
block|{
name|char
name|c
decl_stmt|;
name|int
name|result
decl_stmt|;
do|do
block|{
if|#
directive|if
name|MSDOS_COMPILER
operator|&&
name|MSDOS_COMPILER
operator|!=
name|DJGPPC
comment|/* 		 * In raw read, we don't see ^C so look here for it. 		 */
name|flush
argument_list|()
expr_stmt|;
if|#
directive|if
name|MSDOS_COMPILER
operator|==
name|WIN32C
if|if
condition|(
name|ABORT_SIGS
argument_list|()
condition|)
return|return
operator|(
name|READ_INTR
operator|)
return|;
name|c
operator|=
name|WIN32getch
argument_list|(
name|tty
argument_list|)
expr_stmt|;
else|#
directive|else
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|result
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\003'
condition|)
return|return
operator|(
name|READ_INTR
operator|)
return|;
else|#
directive|else
name|result
operator|=
name|iread
argument_list|(
name|tty
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|READ_INTR
condition|)
return|return
operator|(
name|READ_INTR
operator|)
return|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
comment|/* 			 * Don't call error() here, 			 * because error calls getchr! 			 */
name|quit
argument_list|(
name|QUIT_ERROR
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* allow entering arbitrary hex chars for testing */
comment|/* ctrl-A followed by two hex chars makes a byte */
block|{ 		int hex_in = 0; 		int hex_value = 0; 		if (c == CONTROL('A')) 		{ 			hex_in = 2; 			result = 0; 			continue; 		} 		if (hex_in> 0) 		{ 			int v; 			if (c>= '0'&& c<= '9') 				v = c - '0'; 			else if (c>= 'a'&& c<= 'f') 				v = c - 'a' + 10; 			else if (c>= 'A'&& c<= 'F') 				v = c - 'A' + 10; 			else 				hex_in = 0; 			hex_value = (hex_value<< 4) | v; 			if (--hex_in> 0) 			{ 				result = 0; 				continue; 			} 			c = hex_value; 		} 	}
endif|#
directive|endif
comment|/* 		 * Various parts of the program cannot handle 		 * an input character of '\0'. 		 * If a '\0' was actually typed, convert it to '\340' here. 		 */
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
name|c
operator|=
literal|'\340'
expr_stmt|;
block|}
do|while
condition|(
name|result
operator|!=
literal|1
condition|)
do|;
return|return
operator|(
name|c
operator|&
literal|0xFF
operator|)
return|;
block|}
end_function

end_unit

