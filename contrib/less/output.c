begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1984-2000  Mark Nudelman  *  * You may distribute under the terms of either the GNU General Public  * License or the Less License, as specified in the README file.  *  * For more information about less, or for information on how to   * contact the author, see the README file.  */
end_comment

begin_comment
comment|/*  * High level routines dealing with the output to the screen.  */
end_comment

begin_include
include|#
directive|include
file|"less.h"
end_include

begin_if
if|#
directive|if
name|MSDOS_COMPILER
operator|==
name|WIN32C
end_if

begin_include
include|#
directive|include
file|"windows.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|public
name|int
name|errmsgs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count of messages displayed by error() */
end_comment

begin_decl_stmt
name|public
name|int
name|need_clr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|int
name|final_attr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sigs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sc_width
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|so_s_width
decl_stmt|,
name|so_e_width
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|screen_trashed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|any_display
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|is_tty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Display the line which is in the line buffer.  */
end_comment

begin_function
name|public
name|void
name|put_line
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|a
decl_stmt|;
name|int
name|curr_attr
decl_stmt|;
if|if
condition|(
name|ABORT_SIGS
argument_list|()
condition|)
block|{
comment|/* 		 * Don't output if a signal is pending. 		 */
name|screen_trashed
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|curr_attr
operator|=
name|AT_NORMAL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|c
operator|=
name|gline
argument_list|(
name|i
argument_list|,
operator|&
name|a
argument_list|)
operator|)
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|a
operator|!=
name|curr_attr
condition|)
block|{
comment|/* 			 * Changing attributes. 			 * Display the exit sequence for the old attribute 			 * and the enter sequence for the new one. 			 */
switch|switch
condition|(
name|curr_attr
condition|)
block|{
case|case
name|AT_UNDERLINE
case|:
name|ul_exit
argument_list|()
expr_stmt|;
break|break;
case|case
name|AT_BOLD
case|:
name|bo_exit
argument_list|()
expr_stmt|;
break|break;
case|case
name|AT_BLINK
case|:
name|bl_exit
argument_list|()
expr_stmt|;
break|break;
case|case
name|AT_STANDOUT
case|:
name|so_exit
argument_list|()
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|a
condition|)
block|{
case|case
name|AT_UNDERLINE
case|:
name|ul_enter
argument_list|()
expr_stmt|;
break|break;
case|case
name|AT_BOLD
case|:
name|bo_enter
argument_list|()
expr_stmt|;
break|break;
case|case
name|AT_BLINK
case|:
name|bl_enter
argument_list|()
expr_stmt|;
break|break;
case|case
name|AT_STANDOUT
case|:
name|so_enter
argument_list|()
expr_stmt|;
break|break;
block|}
name|curr_attr
operator|=
name|a
expr_stmt|;
block|}
if|if
condition|(
name|curr_attr
operator|==
name|AT_INVIS
condition|)
continue|continue;
if|if
condition|(
name|c
operator|==
literal|'\b'
condition|)
name|putbs
argument_list|()
expr_stmt|;
else|else
name|putchr
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|curr_attr
condition|)
block|{
case|case
name|AT_UNDERLINE
case|:
name|ul_exit
argument_list|()
expr_stmt|;
break|break;
case|case
name|AT_BOLD
case|:
name|bo_exit
argument_list|()
expr_stmt|;
break|break;
case|case
name|AT_BLINK
case|:
name|bl_exit
argument_list|()
expr_stmt|;
break|break;
case|case
name|AT_STANDOUT
case|:
name|so_exit
argument_list|()
expr_stmt|;
break|break;
block|}
name|final_attr
operator|=
name|curr_attr
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|obuf
index|[
name|OUTBUF_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ob
init|=
name|obuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Flush buffered output.  *  * If we haven't displayed any file data yet,  * output messages on error output (file descriptor 2),  * otherwise output on standard output (file descriptor 1).  *  * This has the desirable effect of producing all  * error messages on error output if standard output  * is directed to a file.  It also does the same if  * we never produce any real output; for example, if  * the input file(s) cannot be opened.  If we do  * eventually produce output, code in edit() makes  * sure these messages can be seen before they are  * overwritten or scrolled away.  */
end_comment

begin_function
name|public
name|void
name|flush
parameter_list|()
block|{
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|int
name|fd
decl_stmt|;
name|n
operator|=
name|ob
operator|-
name|obuf
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return;
if|#
directive|if
name|MSDOS_COMPILER
operator|==
name|WIN32C
if|if
condition|(
name|is_tty
operator|&&
name|any_display
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|op
decl_stmt|;
name|DWORD
name|nwritten
init|=
literal|0
decl_stmt|;
name|CONSOLE_SCREEN_BUFFER_INFO
name|scr
decl_stmt|;
name|DWORD
name|nchars
decl_stmt|;
name|COORD
name|cpos
decl_stmt|;
name|WORD
name|nm_attr
decl_stmt|;
name|int
name|olen
decl_stmt|;
specifier|extern
name|HANDLE
name|con_out
decl_stmt|;
specifier|extern
name|int
name|nm_fg_color
decl_stmt|;
specifier|extern
name|int
name|nm_bg_color
decl_stmt|;
define|#
directive|define
name|MAKEATTR
parameter_list|(
name|fg
parameter_list|,
name|bg
parameter_list|)
value|((WORD)((fg)|((bg)<<4)))
operator|*
name|ob
operator|=
literal|'\0'
expr_stmt|;
name|olen
operator|=
name|ob
operator|-
name|obuf
expr_stmt|;
comment|/* 		 * To avoid color problems, if we're scrolling the screen, 		 * we write only up to the char that causes the scroll, 		 * (a newline or a char in the last column), then fill  		 * the bottom line with the "normal" attribute, then  		 * write the rest. 		 * When Windows scrolls, it takes the attributes for the  		 * new line from the first char of the (previously)  		 * bottom line. 		 * 		 * {{ This still doesn't work correctly in all cases! }} 		 */
name|nm_attr
operator|=
name|MAKEATTR
argument_list|(
name|nm_fg_color
argument_list|,
name|nm_bg_color
argument_list|)
expr_stmt|;
for|for
control|(
name|op
operator|=
name|obuf
init|;
operator|*
name|op
operator|!=
literal|'\0'
condition|;
control|)
block|{
name|GetConsoleScreenBufferInfo
argument_list|(
name|con_out
argument_list|,
operator|&
name|scr
argument_list|)
expr_stmt|;
comment|/* Find the next newline. */
name|p
operator|=
name|strchr
argument_list|(
name|op
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|&&
name|scr
operator|.
name|dwCursorPosition
operator|.
name|X
operator|+
name|olen
operator|>=
name|sc_width
condition|)
block|{
comment|/* 				 * No newline, but writing in the  				 * last column causes scrolling. 				 */
name|p
operator|=
name|op
operator|+
name|sc_width
operator|-
name|scr
operator|.
name|dwCursorPosition
operator|.
name|X
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|scr
operator|.
name|dwCursorPosition
operator|.
name|Y
operator|!=
name|scr
operator|.
name|srWindow
operator|.
name|Bottom
operator|||
name|p
operator|==
name|NULL
condition|)
block|{
comment|/* Write the entire buffer. */
name|WriteConsole
argument_list|(
name|con_out
argument_list|,
name|op
argument_list|,
name|olen
argument_list|,
operator|&
name|nwritten
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|op
operator|+=
name|olen
expr_stmt|;
block|}
else|else
block|{
comment|/* Write only up to the scrolling char. */
name|WriteConsole
argument_list|(
name|con_out
argument_list|,
name|op
argument_list|,
name|p
operator|-
name|op
operator|+
literal|1
argument_list|,
operator|&
name|nwritten
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cpos
operator|.
name|X
operator|=
literal|0
expr_stmt|;
name|cpos
operator|.
name|Y
operator|=
name|scr
operator|.
name|dwCursorPosition
operator|.
name|Y
expr_stmt|;
name|FillConsoleOutputAttribute
argument_list|(
name|con_out
argument_list|,
name|nm_attr
argument_list|,
name|sc_width
argument_list|,
name|cpos
argument_list|,
operator|&
name|nchars
argument_list|)
expr_stmt|;
name|olen
operator|-=
name|p
operator|-
name|op
operator|+
literal|1
expr_stmt|;
name|op
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|ob
operator|=
name|obuf
expr_stmt|;
return|return;
block|}
else|#
directive|else
if|#
directive|if
name|MSDOS_COMPILER
operator|==
name|MSOFTC
if|if
condition|(
name|is_tty
operator|&&
name|any_display
condition|)
block|{
operator|*
name|ob
operator|=
literal|'\0'
expr_stmt|;
name|_outtext
argument_list|(
name|obuf
argument_list|)
expr_stmt|;
name|ob
operator|=
name|obuf
expr_stmt|;
return|return;
block|}
else|#
directive|else
if|#
directive|if
name|MSDOS_COMPILER
operator|==
name|BORLANDC
operator|||
name|MSDOS_COMPILER
operator|==
name|DJGPPC
if|if
condition|(
name|is_tty
operator|&&
name|any_display
condition|)
block|{
operator|*
name|ob
operator|=
literal|'\0'
expr_stmt|;
name|cputs
argument_list|(
name|obuf
argument_list|)
expr_stmt|;
name|ob
operator|=
name|obuf
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
name|fd
operator|=
operator|(
name|any_display
operator|)
condition|?
literal|1
else|:
literal|2
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|obuf
argument_list|,
name|n
argument_list|)
operator|!=
name|n
condition|)
name|screen_trashed
operator|=
literal|1
expr_stmt|;
name|ob
operator|=
name|obuf
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Output a character.  */
end_comment

begin_function
name|public
name|int
name|putchr
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|need_clr
condition|)
block|{
name|need_clr
operator|=
literal|0
expr_stmt|;
name|clear_bot
argument_list|()
expr_stmt|;
block|}
if|#
directive|if
name|MSDOS_COMPILER
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|is_tty
condition|)
block|{
comment|/* remove_top(1); */
name|putchr
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
ifdef|#
directive|ifdef
name|_OSK
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|is_tty
condition|)
comment|/* In OS-9, '\n' == 0x0D */
name|putchr
argument_list|(
literal|0x0A
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* 	 * Some versions of flush() write to *ob, so we must flush 	 * when we are still one char from the end of obuf. 	 */
if|if
condition|(
name|ob
operator|>=
operator|&
name|obuf
index|[
sizeof|sizeof
argument_list|(
name|obuf
argument_list|)
operator|-
literal|1
index|]
condition|)
name|flush
argument_list|()
expr_stmt|;
operator|*
name|ob
operator|++
operator|=
name|c
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Output a string.  */
end_comment

begin_function
name|public
name|void
name|putstr
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
name|putchr
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Output an integer in a given radix.  */
end_comment

begin_function
specifier|static
name|int
name|iprintnum
parameter_list|(
name|num
parameter_list|,
name|radix
parameter_list|)
name|int
name|num
decl_stmt|;
name|int
name|radix
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|r
decl_stmt|;
name|int
name|neg
decl_stmt|;
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
name|neg
operator|=
operator|(
name|num
operator|<
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|neg
condition|)
name|num
operator|=
operator|-
name|num
expr_stmt|;
name|s
operator|=
name|buf
expr_stmt|;
do|do
block|{
operator|*
name|s
operator|++
operator|=
operator|(
name|num
operator|%
name|radix
operator|)
operator|+
literal|'0'
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|num
operator|/=
name|radix
operator|)
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|neg
condition|)
operator|*
name|s
operator|++
operator|=
literal|'-'
expr_stmt|;
name|r
operator|=
name|s
operator|-
name|buf
expr_stmt|;
while|while
condition|(
name|s
operator|>
name|buf
condition|)
name|putchr
argument_list|(
operator|*
operator|--
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function implements printf-like functionality  * using a more portable argument list mechanism than printf's.  */
end_comment

begin_function
specifier|static
name|int
name|less_printf
parameter_list|(
name|fmt
parameter_list|,
name|parg
parameter_list|)
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
name|PARG
modifier|*
name|parg
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|int
name|col
decl_stmt|;
name|col
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|fmt
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|fmt
operator|!=
literal|'%'
condition|)
block|{
name|putchr
argument_list|(
operator|*
name|fmt
operator|++
argument_list|)
expr_stmt|;
name|col
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|++
name|fmt
expr_stmt|;
switch|switch
condition|(
operator|*
name|fmt
operator|++
condition|)
block|{
case|case
literal|'s'
case|:
name|s
operator|=
name|parg
operator|->
name|p_string
expr_stmt|;
name|parg
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
block|{
name|putchr
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
name|col
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'d'
case|:
name|n
operator|=
name|parg
operator|->
name|p_int
expr_stmt|;
name|parg
operator|++
expr_stmt|;
name|col
operator|+=
name|iprintnum
argument_list|(
name|n
argument_list|,
literal|10
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
operator|(
name|col
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get a RETURN.  * If some other non-trivial char is pressed, unget it, so it will  * become the next command.  */
end_comment

begin_function
name|public
name|void
name|get_return
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
if|#
directive|if
name|ONLY_RETURN
while|while
condition|(
operator|(
name|c
operator|=
name|getchr
argument_list|()
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'\r'
condition|)
name|bell
argument_list|()
expr_stmt|;
else|#
directive|else
name|c
operator|=
name|getchr
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'\r'
operator|&&
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
name|READ_INTR
condition|)
name|ungetcc
argument_list|(
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Output a message in the lower left corner of the screen  * and wait for carriage return.  */
end_comment

begin_function
name|public
name|void
name|error
parameter_list|(
name|fmt
parameter_list|,
name|parg
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
name|PARG
modifier|*
name|parg
decl_stmt|;
block|{
name|int
name|col
init|=
literal|0
decl_stmt|;
specifier|static
name|char
name|return_to_continue
index|[]
init|=
literal|"  (press RETURN)"
decl_stmt|;
name|errmsgs
operator|++
expr_stmt|;
if|if
condition|(
name|any_display
operator|&&
name|is_tty
condition|)
block|{
name|clear_bot
argument_list|()
expr_stmt|;
name|so_enter
argument_list|()
expr_stmt|;
name|col
operator|+=
name|so_s_width
expr_stmt|;
block|}
name|col
operator|+=
name|less_printf
argument_list|(
name|fmt
argument_list|,
name|parg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|any_display
operator|&&
name|is_tty
operator|)
condition|)
block|{
name|putchr
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
return|return;
block|}
name|putstr
argument_list|(
name|return_to_continue
argument_list|)
expr_stmt|;
name|so_exit
argument_list|()
expr_stmt|;
name|col
operator|+=
sizeof|sizeof
argument_list|(
name|return_to_continue
argument_list|)
operator|+
name|so_e_width
expr_stmt|;
name|get_return
argument_list|()
expr_stmt|;
name|lower_left
argument_list|()
expr_stmt|;
if|if
condition|(
name|col
operator|>=
name|sc_width
condition|)
comment|/* 		 * Printing the message has probably scrolled the screen. 		 * {{ Unless the terminal doesn't have auto margins, 		 *    in which case we just hammered on the right margin. }} 		 */
name|screen_trashed
operator|=
literal|1
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|intr_to_abort
index|[]
init|=
literal|"... (interrupt to abort)"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Output a message in the lower left corner of the screen  * and don't wait for carriage return.  * Usually used to warn that we are beginning a potentially  * time-consuming operation.  */
end_comment

begin_function
name|public
name|void
name|ierror
parameter_list|(
name|fmt
parameter_list|,
name|parg
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
name|PARG
modifier|*
name|parg
decl_stmt|;
block|{
name|clear_bot
argument_list|()
expr_stmt|;
name|so_enter
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|less_printf
argument_list|(
name|fmt
argument_list|,
name|parg
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
name|intr_to_abort
argument_list|)
expr_stmt|;
name|so_exit
argument_list|()
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
name|need_clr
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Output a message in the lower left corner of the screen  * and return a single-character response.  */
end_comment

begin_function
name|public
name|int
name|query
parameter_list|(
name|fmt
parameter_list|,
name|parg
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
name|PARG
modifier|*
name|parg
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|col
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|any_display
operator|&&
name|is_tty
condition|)
name|clear_bot
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|less_printf
argument_list|(
name|fmt
argument_list|,
name|parg
argument_list|)
expr_stmt|;
name|c
operator|=
name|getchr
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|any_display
operator|&&
name|is_tty
operator|)
condition|)
block|{
name|putchr
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
name|lower_left
argument_list|()
expr_stmt|;
if|if
condition|(
name|col
operator|>=
name|sc_width
condition|)
name|screen_trashed
operator|=
literal|1
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

end_unit

