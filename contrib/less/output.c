begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1984-2017  Mark Nudelman  *  * You may distribute under the terms of either the GNU General Public  * License or the Less License, as specified in the README file.  *  * For more information, see the README file.  */
end_comment

begin_comment
comment|/*  * High level routines dealing with the output to the screen.  */
end_comment

begin_include
include|#
directive|include
file|"less.h"
end_include

begin_if
if|#
directive|if
name|MSDOS_COMPILER
operator|==
name|WIN32C
end_if

begin_include
include|#
directive|include
file|"windows.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|COMMON_LVB_UNDERSCORE
end_ifndef

begin_define
define|#
directive|define
name|COMMON_LVB_UNDERSCORE
value|0x8000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|public
name|int
name|errmsgs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count of messages displayed by error() */
end_comment

begin_decl_stmt
name|public
name|int
name|need_clr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|int
name|final_attr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|int
name|at_prompt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sigs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sc_width
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|so_s_width
decl_stmt|,
name|so_e_width
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|screen_trashed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|any_display
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|is_tty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|oldbot
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|MSDOS_COMPILER
operator|==
name|WIN32C
operator|||
name|MSDOS_COMPILER
operator|==
name|BORLANDC
operator|||
name|MSDOS_COMPILER
operator|==
name|DJGPPC
end_if

begin_decl_stmt
specifier|extern
name|int
name|ctldisp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nm_fg_color
decl_stmt|,
name|nm_bg_color
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|bo_fg_color
decl_stmt|,
name|bo_bg_color
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ul_fg_color
decl_stmt|,
name|ul_bg_color
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|so_fg_color
decl_stmt|,
name|so_bg_color
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|bl_fg_color
decl_stmt|,
name|bl_bg_color
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sgr_mode
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|MSDOS_COMPILER
operator|==
name|WIN32C
end_if

begin_decl_stmt
specifier|extern
name|int
name|have_ul
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Display the line which is in the line buffer.  */
end_comment

begin_function
name|public
name|void
name|put_line
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|a
decl_stmt|;
if|if
condition|(
name|ABORT_SIGS
argument_list|()
condition|)
block|{
comment|/* 		 * Don't output if a signal is pending. 		 */
name|screen_trashed
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|final_attr
operator|=
name|AT_NORMAL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|c
operator|=
name|gline
argument_list|(
name|i
argument_list|,
operator|&
name|a
argument_list|)
operator|)
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
block|{
name|at_switch
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|final_attr
operator|=
name|a
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\b'
condition|)
name|putbs
argument_list|()
expr_stmt|;
else|else
name|putchr
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|at_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|obuf
index|[
name|OUTBUF_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ob
init|=
name|obuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Flush buffered output.  *  * If we haven't displayed any file data yet,  * output messages on error output (file descriptor 2),  * otherwise output on standard output (file descriptor 1).  *  * This has the desirable effect of producing all  * error messages on error output if standard output  * is directed to a file.  It also does the same if  * we never produce any real output; for example, if  * the input file(s) cannot be opened.  If we do  * eventually produce output, code in edit() makes  * sure these messages can be seen before they are  * overwritten or scrolled away.  */
end_comment

begin_function
name|public
name|void
name|flush
parameter_list|()
block|{
name|int
name|n
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|n
operator|=
call|(
name|int
call|)
argument_list|(
name|ob
operator|-
name|obuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return;
if|#
directive|if
name|MSDOS_COMPILER
operator|==
name|MSOFTC
if|if
condition|(
name|is_tty
operator|&&
name|any_display
condition|)
block|{
operator|*
name|ob
operator|=
literal|'\0'
expr_stmt|;
name|_outtext
argument_list|(
name|obuf
argument_list|)
expr_stmt|;
name|ob
operator|=
name|obuf
expr_stmt|;
return|return;
block|}
else|#
directive|else
if|#
directive|if
name|MSDOS_COMPILER
operator|==
name|WIN32C
operator|||
name|MSDOS_COMPILER
operator|==
name|BORLANDC
operator|||
name|MSDOS_COMPILER
operator|==
name|DJGPPC
if|if
condition|(
name|is_tty
operator|&&
name|any_display
condition|)
block|{
operator|*
name|ob
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|ctldisp
operator|!=
name|OPT_ONPLUS
condition|)
name|WIN32textout
argument_list|(
name|obuf
argument_list|,
name|ob
operator|-
name|obuf
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* 			 * Look for SGR escape sequences, and convert them 			 * to color commands.  Replace bold, underline, 			 * and italic escapes into colors specified via 			 * the -D command-line option. 			 */
name|char
modifier|*
name|anchor
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|p_next
decl_stmt|;
specifier|static
name|int
name|fg
decl_stmt|,
name|fgi
decl_stmt|,
name|bg
decl_stmt|,
name|bgi
decl_stmt|;
specifier|static
name|int
name|at
decl_stmt|;
name|int
name|f
decl_stmt|,
name|b
decl_stmt|;
if|#
directive|if
name|MSDOS_COMPILER
operator|==
name|WIN32C
comment|/* Screen colors used by 3x and 4x SGR commands. */
specifier|static
name|unsigned
name|char
name|screen_color
index|[]
init|=
block|{
literal|0
block|,
comment|/* BLACK */
name|FOREGROUND_RED
block|,
name|FOREGROUND_GREEN
block|,
name|FOREGROUND_RED
operator||
name|FOREGROUND_GREEN
block|,
name|FOREGROUND_BLUE
block|,
name|FOREGROUND_BLUE
operator||
name|FOREGROUND_RED
block|,
name|FOREGROUND_BLUE
operator||
name|FOREGROUND_GREEN
block|,
name|FOREGROUND_BLUE
operator||
name|FOREGROUND_GREEN
operator||
name|FOREGROUND_RED
block|}
decl_stmt|;
else|#
directive|else
specifier|static
name|enum
name|COLORS
name|screen_color
index|[]
init|=
block|{
name|BLACK
block|,
name|RED
block|,
name|GREEN
block|,
name|BROWN
block|,
name|BLUE
block|,
name|MAGENTA
block|,
name|CYAN
block|,
name|LIGHTGRAY
block|}
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fg
operator|==
literal|0
operator|&&
name|bg
operator|==
literal|0
condition|)
block|{
name|fg
operator|=
name|nm_fg_color
operator|&
literal|7
expr_stmt|;
name|fgi
operator|=
name|nm_fg_color
operator|&
literal|8
expr_stmt|;
name|bg
operator|=
name|nm_bg_color
operator|&
literal|7
expr_stmt|;
name|bgi
operator|=
name|nm_bg_color
operator|&
literal|8
expr_stmt|;
block|}
for|for
control|(
name|anchor
operator|=
name|p_next
operator|=
name|obuf
init|;
operator|(
name|p_next
operator|=
name|memchr
argument_list|(
name|p_next
argument_list|,
name|ESC
argument_list|,
name|ob
operator|-
name|p_next
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|p
operator|=
name|p_next
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'['
condition|)
comment|/* "ESC-[" sequence */
block|{
if|if
condition|(
name|p
operator|>
name|anchor
condition|)
block|{
comment|/* 						 * If some chars seen since 						 * the last escape sequence, 						 * write them out to the screen. 						 */
name|WIN32textout
argument_list|(
name|anchor
argument_list|,
name|p
operator|-
name|anchor
argument_list|)
expr_stmt|;
name|anchor
operator|=
name|p
expr_stmt|;
block|}
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* Skip the "ESC-[" */
if|if
condition|(
name|is_ansi_end
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
comment|/* 						 * Handle null escape sequence 						 * "ESC[m", which restores 						 * the normal color. 						 */
name|p
operator|++
expr_stmt|;
name|anchor
operator|=
name|p_next
operator|=
name|p
expr_stmt|;
name|fg
operator|=
name|nm_fg_color
operator|&
literal|7
expr_stmt|;
name|fgi
operator|=
name|nm_fg_color
operator|&
literal|8
expr_stmt|;
name|bg
operator|=
name|nm_bg_color
operator|&
literal|7
expr_stmt|;
name|bgi
operator|=
name|nm_bg_color
operator|&
literal|8
expr_stmt|;
name|at
operator|=
literal|0
expr_stmt|;
name|WIN32setcolors
argument_list|(
name|nm_fg_color
argument_list|,
name|nm_bg_color
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|p_next
operator|=
name|p
expr_stmt|;
name|at
operator|&=
operator|~
literal|32
expr_stmt|;
comment|/* 					 * Select foreground/background colors 					 * based on the escape sequence.  					 */
while|while
condition|(
operator|!
name|is_ansi_end
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|char
modifier|*
name|q
decl_stmt|;
name|long
name|code
init|=
name|strtol
argument_list|(
name|p
argument_list|,
operator|&
name|q
argument_list|,
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
literal|'\0'
condition|)
block|{
comment|/* 							 * Incomplete sequence. 							 * Leave it unprocessed 							 * in the buffer. 							 */
name|int
name|slop
init|=
call|(
name|int
call|)
argument_list|(
name|q
operator|-
name|anchor
argument_list|)
decl_stmt|;
comment|/* {{ strcpy args overlap! }} */
name|strcpy
argument_list|(
name|obuf
argument_list|,
name|anchor
argument_list|)
expr_stmt|;
name|ob
operator|=
operator|&
name|obuf
index|[
name|slop
index|]
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|q
operator|==
name|p
operator|||
name|code
operator|>
literal|49
operator|||
name|code
operator|<
literal|0
operator|||
operator|(
operator|!
name|is_ansi_end
argument_list|(
operator|*
name|q
argument_list|)
operator|&&
operator|*
name|q
operator|!=
literal|';'
operator|)
condition|)
block|{
name|p_next
operator|=
name|q
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|q
operator|==
literal|';'
condition|)
block|{
name|q
operator|++
expr_stmt|;
name|at
operator||=
literal|32
expr_stmt|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
default|default:
comment|/* case 0: all attrs off */
name|fg
operator|=
name|nm_fg_color
operator|&
literal|7
expr_stmt|;
name|bg
operator|=
name|nm_bg_color
operator|&
literal|7
expr_stmt|;
name|at
operator|&=
literal|32
expr_stmt|;
comment|/* 							 * \e[0m use normal 							 * intensities, but 							 * \e[0;...m resets them 							 */
if|if
condition|(
name|at
operator|&
literal|32
condition|)
block|{
name|fgi
operator|=
literal|0
expr_stmt|;
name|bgi
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fgi
operator|=
name|nm_fg_color
operator|&
literal|8
expr_stmt|;
name|bgi
operator|=
name|nm_bg_color
operator|&
literal|8
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
comment|/* bold on */
name|fgi
operator|=
literal|8
expr_stmt|;
name|at
operator||=
literal|1
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* italic on */
case|case
literal|7
case|:
comment|/* inverse on */
name|at
operator||=
literal|2
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* underline on */
if|#
directive|if
name|MSDOS_COMPILER
operator|==
name|WIN32C
if|if
condition|(
name|have_ul
condition|)
name|bgi
operator|=
name|COMMON_LVB_UNDERSCORE
operator|>>
literal|4
expr_stmt|;
else|else
endif|#
directive|endif
name|bgi
operator|=
literal|8
expr_stmt|;
name|at
operator||=
literal|4
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* slow blink on */
case|case
literal|6
case|:
comment|/* fast blink on */
name|bgi
operator|=
literal|8
expr_stmt|;
name|at
operator||=
literal|8
expr_stmt|;
break|break;
case|case
literal|8
case|:
comment|/* concealed on */
name|at
operator||=
literal|16
expr_stmt|;
break|break;
case|case
literal|22
case|:
comment|/* bold off */
name|fgi
operator|=
literal|0
expr_stmt|;
name|at
operator|&=
operator|~
literal|1
expr_stmt|;
break|break;
case|case
literal|23
case|:
comment|/* italic off */
case|case
literal|27
case|:
comment|/* inverse off */
name|at
operator|&=
operator|~
literal|2
expr_stmt|;
break|break;
case|case
literal|24
case|:
comment|/* underline off */
name|bgi
operator|=
literal|0
expr_stmt|;
name|at
operator|&=
operator|~
literal|4
expr_stmt|;
break|break;
case|case
literal|28
case|:
comment|/* concealed off */
name|at
operator|&=
operator|~
literal|16
expr_stmt|;
break|break;
case|case
literal|30
case|:
case|case
literal|31
case|:
case|case
literal|32
case|:
case|case
literal|33
case|:
case|case
literal|34
case|:
case|case
literal|35
case|:
case|case
literal|36
case|:
case|case
literal|37
case|:
name|fg
operator|=
name|screen_color
index|[
name|code
operator|-
literal|30
index|]
expr_stmt|;
name|at
operator||=
literal|32
expr_stmt|;
break|break;
case|case
literal|39
case|:
comment|/* default fg */
name|fg
operator|=
name|nm_fg_color
operator|&
literal|7
expr_stmt|;
name|at
operator||=
literal|32
expr_stmt|;
break|break;
case|case
literal|40
case|:
case|case
literal|41
case|:
case|case
literal|42
case|:
case|case
literal|43
case|:
case|case
literal|44
case|:
case|case
literal|45
case|:
case|case
literal|46
case|:
case|case
literal|47
case|:
name|bg
operator|=
name|screen_color
index|[
name|code
operator|-
literal|40
index|]
expr_stmt|;
name|at
operator||=
literal|32
expr_stmt|;
break|break;
case|case
literal|49
case|:
comment|/* default bg */
name|bg
operator|=
name|nm_bg_color
operator|&
literal|7
expr_stmt|;
name|at
operator||=
literal|32
expr_stmt|;
break|break;
block|}
name|p
operator|=
name|q
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_ansi_end
argument_list|(
operator|*
name|p
argument_list|)
operator|||
name|p
operator|==
name|p_next
condition|)
break|break;
comment|/* 					 * In SGR mode, the ANSI sequence is 					 * always honored; otherwise if an attr 					 * is used by itself ("\e[1m" versus 					 * "\e[1;33m", for example), set the 					 * color assigned to that attribute. 					 */
if|if
condition|(
name|sgr_mode
operator|||
operator|(
name|at
operator|&
literal|32
operator|)
condition|)
block|{
if|if
condition|(
name|at
operator|&
literal|2
condition|)
block|{
name|f
operator|=
name|bg
operator||
name|bgi
expr_stmt|;
name|b
operator|=
name|fg
operator||
name|fgi
expr_stmt|;
block|}
else|else
block|{
name|f
operator|=
name|fg
operator||
name|fgi
expr_stmt|;
name|b
operator|=
name|bg
operator||
name|bgi
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|at
operator|&
literal|1
condition|)
block|{
name|f
operator|=
name|bo_fg_color
expr_stmt|;
name|b
operator|=
name|bo_bg_color
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|at
operator|&
literal|2
condition|)
block|{
name|f
operator|=
name|so_fg_color
expr_stmt|;
name|b
operator|=
name|so_bg_color
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|at
operator|&
literal|4
condition|)
block|{
name|f
operator|=
name|ul_fg_color
expr_stmt|;
name|b
operator|=
name|ul_bg_color
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|at
operator|&
literal|8
condition|)
block|{
name|f
operator|=
name|bl_fg_color
expr_stmt|;
name|b
operator|=
name|bl_bg_color
expr_stmt|;
block|}
else|else
block|{
name|f
operator|=
name|nm_fg_color
expr_stmt|;
name|b
operator|=
name|nm_bg_color
expr_stmt|;
block|}
block|}
if|if
condition|(
name|at
operator|&
literal|16
condition|)
name|f
operator|=
name|b
operator|^
literal|8
expr_stmt|;
name|f
operator|&=
literal|0xf
expr_stmt|;
if|#
directive|if
name|MSDOS_COMPILER
operator|==
name|WIN32C
name|b
operator|&=
literal|0xf
operator||
operator|(
name|COMMON_LVB_UNDERSCORE
operator|>>
literal|4
operator|)
expr_stmt|;
else|#
directive|else
name|b
operator|&=
literal|0xf
expr_stmt|;
endif|#
directive|endif
name|WIN32setcolors
argument_list|(
name|f
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|p_next
operator|=
name|anchor
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|p_next
operator|++
expr_stmt|;
block|}
comment|/* Output what's left in the buffer.  */
name|WIN32textout
argument_list|(
name|anchor
argument_list|,
name|ob
operator|-
name|anchor
argument_list|)
expr_stmt|;
block|}
name|ob
operator|=
name|obuf
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
endif|#
directive|endif
name|fd
operator|=
operator|(
name|any_display
operator|)
condition|?
literal|1
else|:
literal|2
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|obuf
argument_list|,
name|n
argument_list|)
operator|!=
name|n
condition|)
name|screen_trashed
operator|=
literal|1
expr_stmt|;
name|ob
operator|=
name|obuf
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Output a character.  */
end_comment

begin_function
name|public
name|int
name|putchr
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
if|#
directive|if
literal|0
comment|/* fake UTF-8 output for testing */
block|extern int utf_mode; 	if (utf_mode) 	{ 		static char ubuf[MAX_UTF_CHAR_LEN]; 		static int ubuf_len = 0; 		static int ubuf_index = 0; 		if (ubuf_len == 0) 		{ 			ubuf_len = utf_len(c); 			ubuf_index = 0; 		} 		ubuf[ubuf_index++] = c; 		if (ubuf_index< ubuf_len) 			return c; 		c = get_wchar(ubuf)& 0xFF; 		ubuf_len = 0; 	}
endif|#
directive|endif
if|if
condition|(
name|need_clr
condition|)
block|{
name|need_clr
operator|=
literal|0
expr_stmt|;
name|clear_bot
argument_list|()
expr_stmt|;
block|}
if|#
directive|if
name|MSDOS_COMPILER
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|is_tty
condition|)
block|{
comment|/* remove_top(1); */
name|putchr
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
ifdef|#
directive|ifdef
name|_OSK
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|is_tty
condition|)
comment|/* In OS-9, '\n' == 0x0D */
name|putchr
argument_list|(
literal|0x0A
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* 	 * Some versions of flush() write to *ob, so we must flush 	 * when we are still one char from the end of obuf. 	 */
if|if
condition|(
name|ob
operator|>=
operator|&
name|obuf
index|[
sizeof|sizeof
argument_list|(
name|obuf
argument_list|)
operator|-
literal|1
index|]
condition|)
name|flush
argument_list|()
expr_stmt|;
operator|*
name|ob
operator|++
operator|=
name|c
expr_stmt|;
name|at_prompt
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Output a string.  */
end_comment

begin_function
name|public
name|void
name|putstr
parameter_list|(
name|s
parameter_list|)
name|constant
name|char
modifier|*
name|s
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
name|putchr
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Convert an integral type to a string.  */
end_comment

begin_define
define|#
directive|define
name|TYPE_TO_A_FUNC
parameter_list|(
name|funcname
parameter_list|,
name|type
parameter_list|)
define|\
value|void funcname(num, buf) \ 	type num; \ 	char *buf; \ { \ 	int neg = (num< 0); \ 	char tbuf[INT_STRLEN_BOUND(num)+2]; \ 	char *s = tbuf + sizeof(tbuf); \ 	if (neg) num = -num; \ 	*--s = '\0'; \ 	do { \ 		*--s = (num % 10) + '0'; \ 	} while ((num /= 10) != 0); \ 	if (neg) *--s = '-'; \ 	strcpy(buf, s); \ }
end_define

begin_macro
name|TYPE_TO_A_FUNC
argument_list|(
argument|postoa
argument_list|,
argument|POSITION
argument_list|)
end_macro

begin_macro
name|TYPE_TO_A_FUNC
argument_list|(
argument|linenumtoa
argument_list|,
argument|LINENUM
argument_list|)
end_macro

begin_macro
name|TYPE_TO_A_FUNC
argument_list|(
argument|inttoa
argument_list|,
argument|int
argument_list|)
end_macro

begin_comment
comment|/*  * Output an integer in a given radix.  */
end_comment

begin_function
specifier|static
name|int
name|iprint_int
parameter_list|(
name|num
parameter_list|)
name|int
name|num
decl_stmt|;
block|{
name|char
name|buf
index|[
name|INT_STRLEN_BOUND
argument_list|(
name|num
argument_list|)
index|]
decl_stmt|;
name|inttoa
argument_list|(
name|num
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|buf
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Output a line number in a given radix.  */
end_comment

begin_function
specifier|static
name|int
name|iprint_linenum
parameter_list|(
name|num
parameter_list|)
name|LINENUM
name|num
decl_stmt|;
block|{
name|char
name|buf
index|[
name|INT_STRLEN_BOUND
argument_list|(
name|num
argument_list|)
index|]
decl_stmt|;
name|linenumtoa
argument_list|(
name|num
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|buf
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function implements printf-like functionality  * using a more portable argument list mechanism than printf's.  */
end_comment

begin_function
specifier|static
name|int
name|less_printf
parameter_list|(
name|fmt
parameter_list|,
name|parg
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
name|PARG
modifier|*
name|parg
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|col
decl_stmt|;
name|col
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|fmt
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|fmt
operator|!=
literal|'%'
condition|)
block|{
name|putchr
argument_list|(
operator|*
name|fmt
operator|++
argument_list|)
expr_stmt|;
name|col
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|++
name|fmt
expr_stmt|;
switch|switch
condition|(
operator|*
name|fmt
operator|++
condition|)
block|{
case|case
literal|'s'
case|:
name|s
operator|=
name|parg
operator|->
name|p_string
expr_stmt|;
name|parg
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
block|{
name|putchr
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
name|col
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'d'
case|:
name|col
operator|+=
name|iprint_int
argument_list|(
name|parg
operator|->
name|p_int
argument_list|)
expr_stmt|;
name|parg
operator|++
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|col
operator|+=
name|iprint_linenum
argument_list|(
name|parg
operator|->
name|p_linenum
argument_list|)
expr_stmt|;
name|parg
operator|++
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
name|putchr
argument_list|(
literal|'%'
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
operator|(
name|col
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get a RETURN.  * If some other non-trivial char is pressed, unget it, so it will  * become the next command.  */
end_comment

begin_function
name|public
name|void
name|get_return
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
if|#
directive|if
name|ONLY_RETURN
while|while
condition|(
operator|(
name|c
operator|=
name|getchr
argument_list|()
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'\r'
condition|)
name|bell
argument_list|()
expr_stmt|;
else|#
directive|else
name|c
operator|=
name|getchr
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'\r'
operator|&&
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
name|READ_INTR
condition|)
name|ungetcc
argument_list|(
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Output a message in the lower left corner of the screen  * and wait for carriage return.  */
end_comment

begin_function
name|public
name|void
name|error
parameter_list|(
name|fmt
parameter_list|,
name|parg
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
name|PARG
modifier|*
name|parg
decl_stmt|;
block|{
name|int
name|col
init|=
literal|0
decl_stmt|;
specifier|static
name|char
name|return_to_continue
index|[]
init|=
literal|"  (press RETURN)"
decl_stmt|;
name|errmsgs
operator|++
expr_stmt|;
if|if
condition|(
name|any_display
operator|&&
name|is_tty
condition|)
block|{
if|if
condition|(
operator|!
name|oldbot
condition|)
name|squish_check
argument_list|()
expr_stmt|;
name|at_exit
argument_list|()
expr_stmt|;
name|clear_bot
argument_list|()
expr_stmt|;
name|at_enter
argument_list|(
name|AT_STANDOUT
argument_list|)
expr_stmt|;
name|col
operator|+=
name|so_s_width
expr_stmt|;
block|}
name|col
operator|+=
name|less_printf
argument_list|(
name|fmt
argument_list|,
name|parg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|any_display
operator|&&
name|is_tty
operator|)
condition|)
block|{
name|putchr
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
return|return;
block|}
name|putstr
argument_list|(
name|return_to_continue
argument_list|)
expr_stmt|;
name|at_exit
argument_list|()
expr_stmt|;
name|col
operator|+=
sizeof|sizeof
argument_list|(
name|return_to_continue
argument_list|)
operator|+
name|so_e_width
expr_stmt|;
name|get_return
argument_list|()
expr_stmt|;
name|lower_left
argument_list|()
expr_stmt|;
name|clear_eol
argument_list|()
expr_stmt|;
if|if
condition|(
name|col
operator|>=
name|sc_width
condition|)
comment|/* 		 * Printing the message has probably scrolled the screen. 		 * {{ Unless the terminal doesn't have auto margins, 		 *    in which case we just hammered on the right margin. }} 		 */
name|screen_trashed
operator|=
literal|1
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|intr_to_abort
index|[]
init|=
literal|"... (interrupt to abort)"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Output a message in the lower left corner of the screen  * and don't wait for carriage return.  * Usually used to warn that we are beginning a potentially  * time-consuming operation.  */
end_comment

begin_function
name|public
name|void
name|ierror
parameter_list|(
name|fmt
parameter_list|,
name|parg
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
name|PARG
modifier|*
name|parg
decl_stmt|;
block|{
name|at_exit
argument_list|()
expr_stmt|;
name|clear_bot
argument_list|()
expr_stmt|;
name|at_enter
argument_list|(
name|AT_STANDOUT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|less_printf
argument_list|(
name|fmt
argument_list|,
name|parg
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
name|intr_to_abort
argument_list|)
expr_stmt|;
name|at_exit
argument_list|()
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
name|need_clr
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Output a message in the lower left corner of the screen  * and return a single-character response.  */
end_comment

begin_function
name|public
name|int
name|query
parameter_list|(
name|fmt
parameter_list|,
name|parg
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
name|PARG
modifier|*
name|parg
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|int
name|col
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|any_display
operator|&&
name|is_tty
condition|)
name|clear_bot
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|less_printf
argument_list|(
name|fmt
argument_list|,
name|parg
argument_list|)
expr_stmt|;
name|c
operator|=
name|getchr
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|any_display
operator|&&
name|is_tty
operator|)
condition|)
block|{
name|putchr
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
name|lower_left
argument_list|()
expr_stmt|;
if|if
condition|(
name|col
operator|>=
name|sc_width
condition|)
name|screen_trashed
operator|=
literal|1
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

end_unit

