begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1984-2007  Mark Nudelman  *  * You may distribute under the terms of either the GNU General Public  * License or the Less License, as specified in the README file.  *  * For more information about less, or for information on how to   * contact the author, see the README file.  */
end_comment

begin_include
include|#
directive|include
file|"less.h"
end_include

begin_if
if|#
directive|if
name|HAVE_STAT
end_if

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|public
name|int
name|fd0
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|new_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|errmsgs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|cbufs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|every_first_cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|any_display
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|force_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|is_tty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sigs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|IFILE
name|curr_ifile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|IFILE
name|old_ifile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|scrpos
name|initial_scrpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|constant
modifier|*
name|ml_examine
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|SPACES_IN_FILENAMES
end_if

begin_decl_stmt
specifier|extern
name|char
name|openquote
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|closequote
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|LOGFILE
end_if

begin_decl_stmt
specifier|extern
name|int
name|logfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|force_logfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|namelogfile
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_STAT_INO
end_if

begin_decl_stmt
name|public
name|dev_t
name|curr_dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|ino_t
name|curr_ino
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|curr_altfilename
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|curr_altpipe
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Textlist functions deal with a list of words separated by spaces.  * init_textlist sets up a textlist structure.  * forw_textlist uses that structure to iterate thru the list of  * words, returning each one as a standard null-terminated string.  * back_textlist does the same, but runs thru the list backwards.  */
end_comment

begin_function
name|public
name|void
name|init_textlist
parameter_list|(
name|tlist
parameter_list|,
name|str
parameter_list|)
name|struct
name|textlist
modifier|*
name|tlist
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|#
directive|if
name|SPACES_IN_FILENAMES
name|int
name|meta_quoted
init|=
literal|0
decl_stmt|;
name|int
name|delim_quoted
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|esc
init|=
name|get_meta_escape
argument_list|()
decl_stmt|;
name|int
name|esclen
init|=
name|strlen
argument_list|(
name|esc
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|tlist
operator|->
name|string
operator|=
name|skipsp
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|tlist
operator|->
name|endstring
operator|=
name|tlist
operator|->
name|string
operator|+
name|strlen
argument_list|(
name|tlist
operator|->
name|string
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|str
init|;
name|s
operator|<
name|tlist
operator|->
name|endstring
condition|;
name|s
operator|++
control|)
block|{
if|#
directive|if
name|SPACES_IN_FILENAMES
if|if
condition|(
name|meta_quoted
condition|)
block|{
name|meta_quoted
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|esclen
operator|>
literal|0
operator|&&
name|s
operator|+
name|esclen
operator|<
name|tlist
operator|->
name|endstring
operator|&&
name|strncmp
argument_list|(
name|s
argument_list|,
name|esc
argument_list|,
name|esclen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|meta_quoted
operator|=
literal|1
expr_stmt|;
name|s
operator|+=
name|esclen
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|delim_quoted
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
name|closequote
condition|)
name|delim_quoted
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* (!delim_quoted) */
block|{
if|if
condition|(
operator|*
name|s
operator|==
name|openquote
condition|)
name|delim_quoted
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_function
name|public
name|char
modifier|*
name|forw_textlist
parameter_list|(
name|tlist
parameter_list|,
name|prev
parameter_list|)
name|struct
name|textlist
modifier|*
name|tlist
decl_stmt|;
name|char
modifier|*
name|prev
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
comment|/* 	 * prev == NULL means return the first word in the list. 	 * Otherwise, return the word after "prev". 	 */
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
name|s
operator|=
name|tlist
operator|->
name|string
expr_stmt|;
else|else
name|s
operator|=
name|prev
operator|+
name|strlen
argument_list|(
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|>=
name|tlist
operator|->
name|endstring
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
while|while
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|>=
name|tlist
operator|->
name|endstring
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_function
name|public
name|char
modifier|*
name|back_textlist
parameter_list|(
name|tlist
parameter_list|,
name|prev
parameter_list|)
name|struct
name|textlist
modifier|*
name|tlist
decl_stmt|;
name|char
modifier|*
name|prev
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
comment|/* 	 * prev == NULL means return the last word in the list. 	 * Otherwise, return the word before "prev". 	 */
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
name|s
operator|=
name|tlist
operator|->
name|endstring
expr_stmt|;
elseif|else
if|if
condition|(
name|prev
operator|<=
name|tlist
operator|->
name|string
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
name|s
operator|=
name|prev
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
name|s
operator|--
expr_stmt|;
if|if
condition|(
name|s
operator|<=
name|tlist
operator|->
name|string
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
while|while
condition|(
name|s
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\0'
operator|&&
name|s
operator|>
name|tlist
operator|->
name|string
condition|)
name|s
operator|--
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close the current input file.  */
end_comment

begin_function
specifier|static
name|void
name|close_file
parameter_list|()
block|{
name|struct
name|scrpos
name|scrpos
decl_stmt|;
if|if
condition|(
name|curr_ifile
operator|==
name|NULL_IFILE
condition|)
return|return;
comment|/* 	 * Save the current position so that we can return to 	 * the same position if we edit this file again. 	 */
name|get_scrpos
argument_list|(
operator|&
name|scrpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|scrpos
operator|.
name|pos
operator|!=
name|NULL_POSITION
condition|)
block|{
name|store_pos
argument_list|(
name|curr_ifile
argument_list|,
operator|&
name|scrpos
argument_list|)
expr_stmt|;
name|lastmark
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * Close the file descriptor, unless it is a pipe. 	 */
name|ch_close
argument_list|()
expr_stmt|;
comment|/* 	 * If we opened a file using an alternate name, 	 * do special stuff to close it. 	 */
if|if
condition|(
name|curr_altfilename
operator|!=
name|NULL
condition|)
block|{
name|close_altfile
argument_list|(
name|curr_altfilename
argument_list|,
name|get_filename
argument_list|(
name|curr_ifile
argument_list|)
argument_list|,
name|curr_altpipe
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|curr_altfilename
argument_list|)
expr_stmt|;
name|curr_altfilename
operator|=
name|NULL
expr_stmt|;
block|}
name|curr_ifile
operator|=
name|NULL_IFILE
expr_stmt|;
if|#
directive|if
name|HAVE_STAT_INO
name|curr_ino
operator|=
name|curr_dev
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Edit a new file (given its name).  * Filename == "-" means standard input.  * Filename == NULL means just close the current file.  */
end_comment

begin_function
name|public
name|int
name|edit
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
return|return
operator|(
name|edit_ifile
argument_list|(
name|NULL_IFILE
argument_list|)
operator|)
return|;
return|return
operator|(
name|edit_ifile
argument_list|(
name|get_ifile
argument_list|(
name|filename
argument_list|,
name|curr_ifile
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Edit a new file (given its IFILE).  * ifile == NULL means just close the current file.  */
end_comment

begin_function
name|public
name|int
name|edit_ifile
parameter_list|(
name|ifile
parameter_list|)
name|IFILE
name|ifile
decl_stmt|;
block|{
name|int
name|f
decl_stmt|;
name|int
name|answer
decl_stmt|;
name|int
name|no_display
decl_stmt|;
name|int
name|chflags
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|open_filename
decl_stmt|;
name|char
modifier|*
name|qopen_filename
decl_stmt|;
name|char
modifier|*
name|alt_filename
decl_stmt|;
name|void
modifier|*
name|alt_pipe
decl_stmt|;
name|IFILE
name|was_curr_ifile
decl_stmt|;
name|PARG
name|parg
decl_stmt|;
if|if
condition|(
name|ifile
operator|==
name|curr_ifile
condition|)
block|{
comment|/* 		 * Already have the correct file open. 		 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * We must close the currently open file now. 	 * This is necessary to make the open_altfile/close_altfile pairs 	 * nest properly (or rather to avoid nesting at all). 	 * {{ Some stupid implementations of popen() mess up if you do: 	 *    fA = popen("A"); fB = popen("B"); pclose(fA); pclose(fB); }} 	 */
if|#
directive|if
name|LOGFILE
name|end_logfile
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|was_curr_ifile
operator|=
name|save_curr_ifile
argument_list|()
expr_stmt|;
if|if
condition|(
name|curr_ifile
operator|!=
name|NULL_IFILE
condition|)
block|{
name|chflags
operator|=
name|ch_getflags
argument_list|()
expr_stmt|;
name|close_file
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|chflags
operator|&
name|CH_HELPFILE
operator|)
operator|&&
name|held_ifile
argument_list|(
name|was_curr_ifile
argument_list|)
operator|<=
literal|1
condition|)
block|{
comment|/* 			 * Don't keep the help file in the ifile list. 			 */
name|del_ifile
argument_list|(
name|was_curr_ifile
argument_list|)
expr_stmt|;
name|was_curr_ifile
operator|=
name|old_ifile
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ifile
operator|==
name|NULL_IFILE
condition|)
block|{
comment|/* 		 * No new file to open. 		 * (Don't set old_ifile, because if you call edit_ifile(NULL), 		 *  you're supposed to have saved curr_ifile yourself, 		 *  and you'll restore it if necessary.) 		 */
name|unsave_ifile
argument_list|(
name|was_curr_ifile
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|filename
operator|=
name|save
argument_list|(
name|get_filename
argument_list|(
name|ifile
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * See if LESSOPEN specifies an "alternate" file to open. 	 */
name|alt_pipe
operator|=
name|NULL
expr_stmt|;
name|alt_filename
operator|=
name|open_altfile
argument_list|(
name|filename
argument_list|,
operator|&
name|f
argument_list|,
operator|&
name|alt_pipe
argument_list|)
expr_stmt|;
name|open_filename
operator|=
operator|(
name|alt_filename
operator|!=
name|NULL
operator|)
condition|?
name|alt_filename
else|:
name|filename
expr_stmt|;
name|qopen_filename
operator|=
name|shell_unquote
argument_list|(
name|open_filename
argument_list|)
expr_stmt|;
name|chflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|alt_pipe
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * The alternate "file" is actually a pipe. 		 * f has already been set to the file descriptor of the pipe 		 * in the call to open_altfile above. 		 * Keep the file descriptor open because it was opened  		 * via popen(), and pclose() wants to close it. 		 */
name|chflags
operator||=
name|CH_POPENED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|open_filename
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/*  		 * Use standard input. 		 * Keep the file descriptor open because we can't reopen it. 		 */
name|f
operator|=
name|fd0
expr_stmt|;
name|chflags
operator||=
name|CH_KEEPOPEN
expr_stmt|;
comment|/* 		 * Must switch stdin to BINARY mode. 		 */
name|SET_BINARY
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|#
directive|if
name|MSDOS_COMPILER
operator|==
name|DJGPPC
comment|/* 		 * Setting stdin to binary by default causes 		 * Ctrl-C to not raise SIGINT.  We must undo 		 * that side-effect. 		 */
name|__djgpp_set_ctrl_c
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|open_filename
argument_list|,
name|FAKE_HELPFILE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|f
operator|=
operator|-
literal|1
expr_stmt|;
name|chflags
operator||=
name|CH_HELPFILE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|parg
operator|.
name|p_string
operator|=
name|bad_file
argument_list|(
name|open_filename
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * It looks like a bad file.  Don't try to open it. 		 */
name|error
argument_list|(
literal|"%s"
argument_list|,
operator|&
name|parg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|parg
operator|.
name|p_string
argument_list|)
expr_stmt|;
name|err1
label|:
if|if
condition|(
name|alt_filename
operator|!=
name|NULL
condition|)
block|{
name|close_altfile
argument_list|(
name|alt_filename
argument_list|,
name|filename
argument_list|,
name|alt_pipe
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|alt_filename
argument_list|)
expr_stmt|;
block|}
name|del_ifile
argument_list|(
name|ifile
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|qopen_filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/* 		 * Re-open the current file. 		 */
if|if
condition|(
name|was_curr_ifile
operator|==
name|ifile
condition|)
block|{
comment|/* 			 * Whoops.  The "current" ifile is the one we just deleted. 			 * Just give up. 			 */
name|quit
argument_list|(
name|QUIT_ERROR
argument_list|)
expr_stmt|;
block|}
name|reedit_ifile
argument_list|(
name|was_curr_ifile
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|f
operator|=
name|open
argument_list|(
name|qopen_filename
argument_list|,
name|OPEN_READ
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* 		 * Got an error trying to open it. 		 */
name|parg
operator|.
name|p_string
operator|=
name|errno_message
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"%s"
argument_list|,
operator|&
name|parg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|parg
operator|.
name|p_string
argument_list|)
expr_stmt|;
goto|goto
name|err1
goto|;
block|}
else|else
block|{
name|chflags
operator||=
name|CH_CANSEEK
expr_stmt|;
if|if
condition|(
operator|!
name|force_open
operator|&&
operator|!
name|opened
argument_list|(
name|ifile
argument_list|)
operator|&&
name|bin_file
argument_list|(
name|f
argument_list|)
condition|)
block|{
comment|/* 			 * Looks like a binary file.   			 * Ask user if we should proceed. 			 */
name|parg
operator|.
name|p_string
operator|=
name|filename
expr_stmt|;
name|answer
operator|=
name|query
argument_list|(
literal|"\"%s\" may be a binary file.  See it anyway? "
argument_list|,
operator|&
name|parg
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|!=
literal|'y'
operator|&&
name|answer
operator|!=
literal|'Y'
condition|)
block|{
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
goto|goto
name|err1
goto|;
block|}
block|}
block|}
comment|/* 	 * Get the new ifile. 	 * Get the saved position for the file. 	 */
if|if
condition|(
name|was_curr_ifile
operator|!=
name|NULL_IFILE
condition|)
block|{
name|old_ifile
operator|=
name|was_curr_ifile
expr_stmt|;
name|unsave_ifile
argument_list|(
name|was_curr_ifile
argument_list|)
expr_stmt|;
block|}
name|curr_ifile
operator|=
name|ifile
expr_stmt|;
name|curr_altfilename
operator|=
name|alt_filename
expr_stmt|;
name|curr_altpipe
operator|=
name|alt_pipe
expr_stmt|;
name|set_open
argument_list|(
name|curr_ifile
argument_list|)
expr_stmt|;
comment|/* File has been opened */
name|get_pos
argument_list|(
name|curr_ifile
argument_list|,
operator|&
name|initial_scrpos
argument_list|)
expr_stmt|;
name|new_file
operator|=
name|TRUE
expr_stmt|;
name|ch_init
argument_list|(
name|f
argument_list|,
name|chflags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|chflags
operator|&
name|CH_HELPFILE
operator|)
condition|)
block|{
if|#
directive|if
name|LOGFILE
if|if
condition|(
name|namelogfile
operator|!=
name|NULL
operator|&&
name|is_tty
condition|)
name|use_logfile
argument_list|(
name|namelogfile
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_STAT_INO
comment|/* Remember the i-number and device of the opened file. */
block|{
name|struct
name|stat
name|statbuf
decl_stmt|;
name|int
name|r
init|=
name|stat
argument_list|(
name|qopen_filename
argument_list|,
operator|&
name|statbuf
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|curr_ino
operator|=
name|statbuf
operator|.
name|st_ino
expr_stmt|;
name|curr_dev
operator|=
name|statbuf
operator|.
name|st_dev
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|every_first_cmd
operator|!=
name|NULL
condition|)
name|ungetsc
argument_list|(
name|every_first_cmd
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|qopen_filename
argument_list|)
expr_stmt|;
name|no_display
operator|=
operator|!
name|any_display
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
name|any_display
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|is_tty
condition|)
block|{
comment|/* 		 * Output is to a real tty. 		 */
comment|/* 		 * Indicate there is nothing displayed yet. 		 */
name|pos_clear
argument_list|()
expr_stmt|;
name|clr_linenum
argument_list|()
expr_stmt|;
if|#
directive|if
name|HILITE_SEARCH
name|clr_hilite
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|cmd_addhist
argument_list|(
name|ml_examine
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|no_display
operator|&&
name|errmsgs
operator|>
literal|0
condition|)
block|{
comment|/* 			 * We displayed some messages on error output 			 * (file descriptor 2; see error() function). 			 * Before erasing the screen contents, 			 * display the file name and wait for a keystroke. 			 */
name|parg
operator|.
name|p_string
operator|=
name|filename
expr_stmt|;
name|error
argument_list|(
literal|"%s"
argument_list|,
operator|&
name|parg
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Edit a space-separated list of files.  * For each filename in the list, enter it into the ifile list.  * Then edit the first one.  */
end_comment

begin_function
name|public
name|int
name|edit_list
parameter_list|(
name|filelist
parameter_list|)
name|char
modifier|*
name|filelist
decl_stmt|;
block|{
name|IFILE
name|save_ifile
decl_stmt|;
name|char
modifier|*
name|good_filename
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|gfilelist
decl_stmt|;
name|char
modifier|*
name|gfilename
decl_stmt|;
name|struct
name|textlist
name|tl_files
decl_stmt|;
name|struct
name|textlist
name|tl_gfiles
decl_stmt|;
name|save_ifile
operator|=
name|save_curr_ifile
argument_list|()
expr_stmt|;
name|good_filename
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Run thru each filename in the list. 	 * Try to glob the filename.   	 * If it doesn't expand, just try to open the filename. 	 * If it does expand, try to open each name in that list. 	 */
name|init_textlist
argument_list|(
operator|&
name|tl_files
argument_list|,
name|filelist
argument_list|)
expr_stmt|;
name|filename
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|filename
operator|=
name|forw_textlist
argument_list|(
operator|&
name|tl_files
argument_list|,
name|filename
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|gfilelist
operator|=
name|lglob
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|init_textlist
argument_list|(
operator|&
name|tl_gfiles
argument_list|,
name|gfilelist
argument_list|)
expr_stmt|;
name|gfilename
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|gfilename
operator|=
name|forw_textlist
argument_list|(
operator|&
name|tl_gfiles
argument_list|,
name|gfilename
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|edit
argument_list|(
name|gfilename
argument_list|)
operator|==
literal|0
operator|&&
name|good_filename
operator|==
name|NULL
condition|)
name|good_filename
operator|=
name|get_filename
argument_list|(
name|curr_ifile
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|gfilelist
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Edit the first valid filename in the list. 	 */
if|if
condition|(
name|good_filename
operator|==
name|NULL
condition|)
block|{
name|unsave_ifile
argument_list|(
name|save_ifile
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|get_ifile
argument_list|(
name|good_filename
argument_list|,
name|curr_ifile
argument_list|)
operator|==
name|curr_ifile
condition|)
block|{
comment|/* 		 * Trying to edit the current file; don't reopen it. 		 */
name|unsave_ifile
argument_list|(
name|save_ifile
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|reedit_ifile
argument_list|(
name|save_ifile
argument_list|)
expr_stmt|;
return|return
operator|(
name|edit
argument_list|(
name|good_filename
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Edit the first file in the command line (ifile) list.  */
end_comment

begin_function
name|public
name|int
name|edit_first
parameter_list|()
block|{
name|curr_ifile
operator|=
name|NULL_IFILE
expr_stmt|;
return|return
operator|(
name|edit_next
argument_list|(
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Edit the last file in the command line (ifile) list.  */
end_comment

begin_function
name|public
name|int
name|edit_last
parameter_list|()
block|{
name|curr_ifile
operator|=
name|NULL_IFILE
expr_stmt|;
return|return
operator|(
name|edit_prev
argument_list|(
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Edit the n-th next or previous file in the command line (ifile) list.  */
end_comment

begin_function
specifier|static
name|int
name|edit_istep
parameter_list|(
name|h
parameter_list|,
name|n
parameter_list|,
name|dir
parameter_list|)
name|IFILE
name|h
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|dir
decl_stmt|;
block|{
name|IFILE
name|next
decl_stmt|;
comment|/* 	 * Skip n filenames, then try to edit each filename. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|next
operator|=
operator|(
name|dir
operator|>
literal|0
operator|)
condition|?
name|next_ifile
argument_list|(
name|h
argument_list|)
else|:
name|prev_ifile
argument_list|(
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|edit_ifile
argument_list|(
name|h
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|next
operator|==
name|NULL_IFILE
condition|)
block|{
comment|/* 			 * Reached end of the ifile list. 			 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ABORT_SIGS
argument_list|()
condition|)
block|{
comment|/* 			 * Interrupt breaks out, if we're in a long 			 * list of files that can't be opened. 			 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|h
operator|=
name|next
expr_stmt|;
block|}
comment|/* 	 * Found a file that we can edit. 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|edit_inext
parameter_list|(
name|h
parameter_list|,
name|n
parameter_list|)
name|IFILE
name|h
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
return|return
operator|(
name|edit_istep
argument_list|(
name|h
argument_list|,
name|n
argument_list|,
operator|+
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|public
name|int
name|edit_next
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
return|return
name|edit_istep
argument_list|(
name|curr_ifile
argument_list|,
name|n
argument_list|,
operator|+
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|edit_iprev
parameter_list|(
name|h
parameter_list|,
name|n
parameter_list|)
name|IFILE
name|h
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
return|return
operator|(
name|edit_istep
argument_list|(
name|h
argument_list|,
name|n
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|public
name|int
name|edit_prev
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
return|return
name|edit_istep
argument_list|(
name|curr_ifile
argument_list|,
name|n
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Edit a specific file in the command line (ifile) list.  */
end_comment

begin_function
name|public
name|int
name|edit_index
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
name|IFILE
name|h
decl_stmt|;
name|h
operator|=
name|NULL_IFILE
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|h
operator|=
name|next_ifile
argument_list|(
name|h
argument_list|)
operator|)
operator|==
name|NULL_IFILE
condition|)
block|{
comment|/* 			 * Reached end of the list without finding it. 			 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
do|while
condition|(
name|get_index
argument_list|(
name|h
argument_list|)
operator|!=
name|n
condition|)
do|;
return|return
operator|(
name|edit_ifile
argument_list|(
name|h
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|public
name|IFILE
name|save_curr_ifile
parameter_list|()
block|{
if|if
condition|(
name|curr_ifile
operator|!=
name|NULL_IFILE
condition|)
name|hold_ifile
argument_list|(
name|curr_ifile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|curr_ifile
operator|)
return|;
block|}
end_function

begin_function
name|public
name|void
name|unsave_ifile
parameter_list|(
name|save_ifile
parameter_list|)
name|IFILE
name|save_ifile
decl_stmt|;
block|{
if|if
condition|(
name|save_ifile
operator|!=
name|NULL_IFILE
condition|)
name|hold_ifile
argument_list|(
name|save_ifile
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reedit the ifile which was previously open.  */
end_comment

begin_function
name|public
name|void
name|reedit_ifile
parameter_list|(
name|save_ifile
parameter_list|)
name|IFILE
name|save_ifile
decl_stmt|;
block|{
name|IFILE
name|next
decl_stmt|;
name|IFILE
name|prev
decl_stmt|;
comment|/* 	 * Try to reopen the ifile. 	 * Note that opening it may fail (maybe the file was removed), 	 * in which case the ifile will be deleted from the list. 	 * So save the next and prev ifiles first. 	 */
name|unsave_ifile
argument_list|(
name|save_ifile
argument_list|)
expr_stmt|;
name|next
operator|=
name|next_ifile
argument_list|(
name|save_ifile
argument_list|)
expr_stmt|;
name|prev
operator|=
name|prev_ifile
argument_list|(
name|save_ifile
argument_list|)
expr_stmt|;
if|if
condition|(
name|edit_ifile
argument_list|(
name|save_ifile
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * If can't reopen it, open the next input file in the list. 	 */
if|if
condition|(
name|next
operator|!=
name|NULL_IFILE
operator|&&
name|edit_inext
argument_list|(
name|next
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * If can't open THAT one, open the previous input file in the list. 	 */
if|if
condition|(
name|prev
operator|!=
name|NULL_IFILE
operator|&&
name|edit_iprev
argument_list|(
name|prev
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * If can't even open that, we're stuck.  Just quit. 	 */
name|quit
argument_list|(
name|QUIT_ERROR
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|public
name|void
name|reopen_curr_ifile
parameter_list|()
block|{
name|IFILE
name|save_ifile
init|=
name|save_curr_ifile
argument_list|()
decl_stmt|;
name|close_file
argument_list|()
expr_stmt|;
name|reedit_ifile
argument_list|(
name|save_ifile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Edit standard input.  */
end_comment

begin_function
name|public
name|int
name|edit_stdin
parameter_list|()
block|{
if|if
condition|(
name|isatty
argument_list|(
name|fd0
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Missing filename (\"less --help\" for help)"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
name|quit
argument_list|(
name|QUIT_OK
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|edit
argument_list|(
literal|"-"
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy a file directly to standard output.  * Used if standard output is not a tty.  */
end_comment

begin_function
name|public
name|void
name|cat_file
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|ch_forw_get
argument_list|()
operator|)
operator|!=
name|EOI
condition|)
name|putchr
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|LOGFILE
end_if

begin_comment
comment|/*  * If the user asked for a log file and our input file  * is standard input, create the log file.    * We take care not to blindly overwrite an existing file.  */
end_comment

begin_function
name|public
name|void
name|use_logfile
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
specifier|register
name|int
name|exists
decl_stmt|;
specifier|register
name|int
name|answer
decl_stmt|;
name|PARG
name|parg
decl_stmt|;
if|if
condition|(
name|ch_getflags
argument_list|()
operator|&
name|CH_CANSEEK
condition|)
comment|/* 		 * Can't currently use a log file on a file that can seek. 		 */
return|return;
comment|/* 	 * {{ We could use access() here. }} 	 */
name|filename
operator|=
name|shell_unquote
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|exists
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|OPEN_READ
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|exists
argument_list|)
expr_stmt|;
name|exists
operator|=
operator|(
name|exists
operator|>=
literal|0
operator|)
expr_stmt|;
comment|/* 	 * Decide whether to overwrite the log file or append to it. 	 * If it doesn't exist we "overwrite" it. 	 */
if|if
condition|(
operator|!
name|exists
operator|||
name|force_logfile
condition|)
block|{
comment|/* 		 * Overwrite (or create) the log file. 		 */
name|answer
operator|=
literal|'O'
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Ask user what to do. 		 */
name|parg
operator|.
name|p_string
operator|=
name|filename
expr_stmt|;
name|answer
operator|=
name|query
argument_list|(
literal|"Warning: \"%s\" exists; Overwrite, Append or Don't log? "
argument_list|,
operator|&
name|parg
argument_list|)
expr_stmt|;
block|}
name|loop
label|:
switch|switch
condition|(
name|answer
condition|)
block|{
case|case
literal|'O'
case|:
case|case
literal|'o'
case|:
comment|/* 		 * Overwrite: create the file. 		 */
name|logfile
operator|=
name|creat
argument_list|(
name|filename
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
case|case
literal|'a'
case|:
comment|/* 		 * Append: open the file and seek to the end. 		 */
name|logfile
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|OPEN_APPEND
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|logfile
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_END
argument_list|)
operator|==
name|BAD_LSEEK
condition|)
block|{
name|close
argument_list|(
name|logfile
argument_list|)
expr_stmt|;
name|logfile
operator|=
operator|-
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'D'
case|:
case|case
literal|'d'
case|:
comment|/* 		 * Don't do anything. 		 */
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'q'
case|:
name|quit
argument_list|(
name|QUIT_OK
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
default|default:
comment|/* 		 * Eh? 		 */
name|answer
operator|=
name|query
argument_list|(
literal|"Overwrite, Append, or Don't log? (Type \"O\", \"A\", \"D\" or \"q\") "
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
name|logfile
operator|<
literal|0
condition|)
block|{
comment|/* 		 * Error in opening logfile. 		 */
name|parg
operator|.
name|p_string
operator|=
name|filename
expr_stmt|;
name|error
argument_list|(
literal|"Cannot write to \"%s\""
argument_list|,
operator|&
name|parg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|SET_BINARY
argument_list|(
name|logfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

