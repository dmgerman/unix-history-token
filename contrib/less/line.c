begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1984-2000  Mark Nudelman  *  * You may distribute under the terms of either the GNU General Public  * License or the Less License, as specified in the README file.  *  * For more information about less, or for information on how to   * contact the author, see the README file.  */
end_comment

begin_comment
comment|/*  * Routines to manipulate the "line buffer".  * The line buffer holds a line of output as it is being built  * in preparation for output to the screen.  */
end_comment

begin_include
include|#
directive|include
file|"less.h"
end_include

begin_define
define|#
directive|define
name|IS_CONT
parameter_list|(
name|c
parameter_list|)
value|(((c)& 0xC0) == 0x80)
end_define

begin_define
define|#
directive|define
name|LINENUM_WIDTH
value|8
end_define

begin_comment
comment|/* Chars to use for line number */
end_comment

begin_comment
comment|/* Buffer which holds the current output line */
end_comment

begin_decl_stmt
name|public
name|char
name|linebuf
index|[
name|LINEBUF_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|int
name|size_linebuf
init|=
sizeof|sizeof
argument_list|(
name|linebuf
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|public
name|int
name|cshift
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current left-shift of output line buffer */
end_comment

begin_decl_stmt
name|public
name|int
name|hshift
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Desired left-shift of output line buffer */
end_comment

begin_decl_stmt
specifier|static
name|char
name|attr
index|[
name|LINEBUF_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Extension of linebuf to hold attributes */
end_comment

begin_decl_stmt
specifier|static
name|int
name|curr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index into linebuf */
end_comment

begin_decl_stmt
specifier|static
name|int
name|column
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Printable length, accounting for 				   backspaces, etc. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|overstrike
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Next char should overstrike previous char */
end_comment

begin_decl_stmt
specifier|static
name|int
name|is_null_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* There is no current line */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lmargin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Left margin */
end_comment

begin_decl_stmt
specifier|static
name|char
name|pendc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|POSITION
name|pendpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|end_ansi_chars
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|do_append
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|bs_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tabstop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|linenums
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ctldisp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|twiddle
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|binattr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|status_col
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|auto_wrap
decl_stmt|,
name|ignaw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|bo_s_width
decl_stmt|,
name|bo_e_width
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ul_s_width
decl_stmt|,
name|ul_e_width
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|bl_s_width
decl_stmt|,
name|bl_e_width
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|so_s_width
decl_stmt|,
name|so_e_width
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sc_width
decl_stmt|,
name|sc_height
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|utf_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|POSITION
name|start_attnpos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|POSITION
name|end_attnpos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initialize from environment variables.  */
end_comment

begin_function
name|public
name|void
name|init_line
parameter_list|()
block|{
name|end_ansi_chars
operator|=
name|lgetenv
argument_list|(
literal|"LESSANSIENDCHARS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|end_ansi_chars
operator|==
name|NULL
operator|||
operator|*
name|end_ansi_chars
operator|==
literal|'\0'
condition|)
name|end_ansi_chars
operator|=
literal|"m"
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Rewind the line buffer.  */
end_comment

begin_function
name|public
name|void
name|prewind
parameter_list|()
block|{
name|curr
operator|=
literal|0
expr_stmt|;
name|column
operator|=
literal|0
expr_stmt|;
name|overstrike
operator|=
literal|0
expr_stmt|;
name|is_null_line
operator|=
literal|0
expr_stmt|;
name|pendc
operator|=
literal|'\0'
expr_stmt|;
name|lmargin
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|status_col
condition|)
name|lmargin
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|linenums
operator|==
name|OPT_ONPLUS
condition|)
name|lmargin
operator|+=
name|LINENUM_WIDTH
operator|+
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Insert the line number (of the given position) into the line buffer.  */
end_comment

begin_function
name|public
name|void
name|plinenum
parameter_list|(
name|pos
parameter_list|)
name|POSITION
name|pos
decl_stmt|;
block|{
specifier|register
name|int
name|lno
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|linenums
operator|==
name|OPT_ONPLUS
condition|)
block|{
comment|/* 		 * Get the line number and put it in the current line. 		 * {{ Note: since find_linenum calls forw_raw_line, 		 *    it may seek in the input file, requiring the caller  		 *    of plinenum to re-seek if necessary. }} 		 * {{ Since forw_raw_line modifies linebuf, we must 		 *    do this first, before storing anything in linebuf. }} 		 */
name|lno
operator|=
name|find_linenum
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Display a status column if the -J option is set. 	 */
if|if
condition|(
name|status_col
condition|)
block|{
name|linebuf
index|[
name|curr
index|]
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|start_attnpos
operator|!=
name|NULL_POSITION
operator|&&
name|pos
operator|>=
name|start_attnpos
operator|&&
name|pos
operator|<
name|end_attnpos
condition|)
name|attr
index|[
name|curr
index|]
operator|=
name|AT_STANDOUT
expr_stmt|;
else|else
name|attr
index|[
name|curr
index|]
operator|=
literal|0
expr_stmt|;
name|curr
operator|++
expr_stmt|;
name|column
operator|++
expr_stmt|;
block|}
comment|/* 	 * Display the line number at the start of each line 	 * if the -N option is set. 	 */
if|if
condition|(
name|linenums
operator|==
name|OPT_ONPLUS
condition|)
block|{
name|sprintf
argument_list|(
operator|&
name|linebuf
index|[
name|curr
index|]
argument_list|,
literal|"%*d"
argument_list|,
name|LINENUM_WIDTH
argument_list|,
name|lno
argument_list|)
expr_stmt|;
name|column
operator|+=
name|LINENUM_WIDTH
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LINENUM_WIDTH
condition|;
name|i
operator|++
control|)
name|attr
index|[
name|curr
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Append enough spaces to bring us to the lmargin. 	 */
while|while
condition|(
name|column
operator|<
name|lmargin
condition|)
block|{
name|linebuf
index|[
name|curr
index|]
operator|=
literal|' '
expr_stmt|;
name|attr
index|[
name|curr
operator|++
index|]
operator|=
name|AT_NORMAL
expr_stmt|;
name|column
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
specifier|static
name|int
name|utf_len
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|ulen
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
operator|&&
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|IS_CONT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|len
operator|--
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|ulen
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|IS_CONT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|ulen
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|ulen
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Shift the input line left.  * This means discarding N printable chars at the start of the buffer.  */
end_comment

begin_function
specifier|static
name|void
name|pshift
parameter_list|(
name|shift
parameter_list|)
name|int
name|shift
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|real_shift
decl_stmt|;
if|if
condition|(
name|shift
operator|>
name|column
operator|-
name|lmargin
condition|)
name|shift
operator|=
name|column
operator|-
name|lmargin
expr_stmt|;
if|if
condition|(
name|shift
operator|>
name|curr
operator|-
name|lmargin
condition|)
name|shift
operator|=
name|curr
operator|-
name|lmargin
expr_stmt|;
if|if
condition|(
operator|!
name|utf_mode
condition|)
name|real_shift
operator|=
name|shift
expr_stmt|;
else|else
block|{
name|real_shift
operator|=
name|utf_len
argument_list|(
name|linebuf
operator|+
name|lmargin
argument_list|,
name|shift
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_shift
operator|>
name|curr
condition|)
name|real_shift
operator|=
name|curr
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|curr
operator|-
name|real_shift
condition|;
name|i
operator|++
control|)
block|{
name|linebuf
index|[
name|lmargin
operator|+
name|i
index|]
operator|=
name|linebuf
index|[
name|lmargin
operator|+
name|i
operator|+
name|real_shift
index|]
expr_stmt|;
name|attr
index|[
name|lmargin
operator|+
name|i
index|]
operator|=
name|attr
index|[
name|lmargin
operator|+
name|i
operator|+
name|real_shift
index|]
expr_stmt|;
block|}
name|column
operator|-=
name|shift
expr_stmt|;
name|curr
operator|-=
name|real_shift
expr_stmt|;
name|cshift
operator|+=
name|shift
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the printing width of the start (enter) sequence  * for a given character attribute.  */
end_comment

begin_function
specifier|static
name|int
name|attr_swidth
parameter_list|(
name|a
parameter_list|)
name|int
name|a
decl_stmt|;
block|{
switch|switch
condition|(
name|a
condition|)
block|{
case|case
name|AT_BOLD
case|:
return|return
operator|(
name|bo_s_width
operator|)
return|;
case|case
name|AT_UNDERLINE
case|:
return|return
operator|(
name|ul_s_width
operator|)
return|;
case|case
name|AT_BLINK
case|:
return|return
operator|(
name|bl_s_width
operator|)
return|;
case|case
name|AT_STANDOUT
case|:
return|return
operator|(
name|so_s_width
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the printing width of the end (exit) sequence  * for a given character attribute.  */
end_comment

begin_function
specifier|static
name|int
name|attr_ewidth
parameter_list|(
name|a
parameter_list|)
name|int
name|a
decl_stmt|;
block|{
switch|switch
condition|(
name|a
condition|)
block|{
case|case
name|AT_BOLD
case|:
return|return
operator|(
name|bo_e_width
operator|)
return|;
case|case
name|AT_UNDERLINE
case|:
return|return
operator|(
name|ul_e_width
operator|)
return|;
case|case
name|AT_BLINK
case|:
return|return
operator|(
name|bl_e_width
operator|)
return|;
case|case
name|AT_STANDOUT
case|:
return|return
operator|(
name|so_e_width
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the printing width of a given character and attribute,  * if the character were added to the current position in the line buffer.  * Adding a character with a given attribute may cause an enter or exit  * attribute sequence to be inserted, so this must be taken into account.  */
end_comment

begin_function
specifier|static
name|int
name|pwidth
parameter_list|(
name|c
parameter_list|,
name|a
parameter_list|)
name|int
name|c
decl_stmt|;
name|int
name|a
decl_stmt|;
block|{
specifier|register
name|int
name|w
decl_stmt|;
if|if
condition|(
name|utf_mode
operator|&&
name|IS_CONT
argument_list|(
name|c
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|c
operator|==
literal|'\b'
condition|)
comment|/* 		 * Backspace moves backwards one position. 		 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|control_char
argument_list|(
name|c
argument_list|)
condition|)
comment|/* 		 * Control characters do unpredicatable things, 		 * so we don't even try to guess; say it doesn't move. 		 * This can only happen if the -r flag is in effect. 		 */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Other characters take one space, 	 * plus the width of any attribute enter/exit sequence. 	 */
name|w
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|curr
operator|>
literal|0
operator|&&
name|attr
index|[
name|curr
operator|-
literal|1
index|]
operator|!=
name|a
condition|)
name|w
operator|+=
name|attr_ewidth
argument_list|(
name|attr
index|[
name|curr
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|&&
operator|(
name|curr
operator|==
literal|0
operator|||
name|attr
index|[
name|curr
operator|-
literal|1
index|]
operator|!=
name|a
operator|)
condition|)
name|w
operator|+=
name|attr_swidth
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return
operator|(
name|w
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Delete the previous character in the line buffer.  */
end_comment

begin_function
specifier|static
name|void
name|backc
parameter_list|()
block|{
name|curr
operator|--
expr_stmt|;
name|column
operator|-=
name|pwidth
argument_list|(
name|linebuf
index|[
name|curr
index|]
argument_list|,
name|attr
index|[
name|curr
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Are we currently within a recognized ANSI escape sequence?  */
end_comment

begin_function
specifier|static
name|int
name|in_ansi_esc_seq
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
comment|/* 	 * Search backwards for either an ESC (which means we ARE in a seq); 	 * or an end char (which means we're NOT in a seq). 	 */
for|for
control|(
name|i
operator|=
name|curr
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|linebuf
index|[
name|i
index|]
operator|==
name|ESC
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|strchr
argument_list|(
name|end_ansi_chars
argument_list|,
name|linebuf
index|[
name|i
index|]
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Append a character and attribute to the line buffer.  */
end_comment

begin_function
specifier|static
name|int
name|storec
parameter_list|(
name|c
parameter_list|,
name|a
parameter_list|,
name|pos
parameter_list|)
name|int
name|c
decl_stmt|;
name|int
name|a
decl_stmt|;
name|POSITION
name|pos
decl_stmt|;
block|{
specifier|register
name|int
name|w
decl_stmt|;
if|#
directive|if
name|HILITE_SEARCH
if|if
condition|(
name|is_hilited
argument_list|(
name|pos
argument_list|,
name|pos
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
comment|/* 		 * This character should be highlighted. 		 * Override the attribute passed in. 		 */
name|a
operator|=
name|AT_STANDOUT
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ctldisp
operator|==
name|OPT_ONPLUS
operator|&&
name|in_ansi_esc_seq
argument_list|()
condition|)
name|w
operator|=
literal|0
expr_stmt|;
else|else
name|w
operator|=
name|pwidth
argument_list|(
name|c
argument_list|,
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctldisp
operator|!=
name|OPT_ON
operator|&&
name|column
operator|+
name|w
operator|+
name|attr_ewidth
argument_list|(
name|a
argument_list|)
operator|>
name|sc_width
condition|)
comment|/* 		 * Won't fit on screen. 		 */
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|curr
operator|>=
sizeof|sizeof
argument_list|(
name|linebuf
argument_list|)
operator|-
literal|2
condition|)
comment|/* 		 * Won't fit in line buffer. 		 */
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * Special handling for "magic cookie" terminals. 	 * If an attribute enter/exit sequence has a printing width> 0, 	 * and the sequence is adjacent to a space, delete the space. 	 * We just mark the space as invisible, to avoid having too 	 * many spaces deleted. 	 * {{ Note that even if the attribute width is> 1, we 	 *    delete only one space.  It's not worth trying to do more. 	 *    It's hardly worth doing this much. }} 	 */
if|if
condition|(
name|curr
operator|>
literal|0
operator|&&
name|a
operator|!=
name|AT_NORMAL
operator|&&
name|linebuf
index|[
name|curr
operator|-
literal|1
index|]
operator|==
literal|' '
operator|&&
name|attr
index|[
name|curr
operator|-
literal|1
index|]
operator|==
name|AT_NORMAL
operator|&&
name|attr_swidth
argument_list|(
name|a
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* 		 * We are about to append an enter-attribute sequence 		 * just after a space.  Delete the space. 		 */
name|attr
index|[
name|curr
operator|-
literal|1
index|]
operator|=
name|AT_INVIS
expr_stmt|;
name|column
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|curr
operator|>
literal|0
operator|&&
name|attr
index|[
name|curr
operator|-
literal|1
index|]
operator|!=
name|AT_NORMAL
operator|&&
name|attr
index|[
name|curr
operator|-
literal|1
index|]
operator|!=
name|AT_INVIS
operator|&&
name|c
operator|==
literal|' '
operator|&&
name|a
operator|==
name|AT_NORMAL
operator|&&
name|attr_ewidth
argument_list|(
name|attr
index|[
name|curr
operator|-
literal|1
index|]
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* 		 * We are about to append a space just after an  		 * exit-attribute sequence.  Delete the space. 		 */
name|a
operator|=
name|AT_INVIS
expr_stmt|;
name|column
operator|--
expr_stmt|;
block|}
comment|/* End of magic cookie handling. */
name|linebuf
index|[
name|curr
index|]
operator|=
name|c
expr_stmt|;
name|attr
index|[
name|curr
index|]
operator|=
name|a
expr_stmt|;
name|column
operator|+=
name|w
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Append a character to the line buffer.  * Expand tabs into spaces, handle underlining, boldfacing, etc.  * Returns 0 if ok, 1 if couldn't fit in buffer.  */
end_comment

begin_function
name|public
name|int
name|pappend
parameter_list|(
name|c
parameter_list|,
name|pos
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
name|POSITION
name|pos
decl_stmt|;
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
name|pendc
condition|)
block|{
if|if
condition|(
name|do_append
argument_list|(
name|pendc
argument_list|,
name|pendpos
argument_list|)
condition|)
comment|/* 			 * Oops.  We've probably lost the char which 			 * was in pendc, since caller won't back up. 			 */
return|return
operator|(
literal|1
operator|)
return|;
name|pendc
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\r'
operator|&&
name|bs_mode
operator|==
name|BS_SPECIAL
condition|)
block|{
comment|/* 		 * Don't put the CR into the buffer until we see  		 * the next char.  If the next char is a newline, 		 * discard the CR. 		 */
name|pendc
operator|=
name|c
expr_stmt|;
name|pendpos
operator|=
name|pos
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|r
operator|=
name|do_append
argument_list|(
name|c
argument_list|,
name|pos
argument_list|)
expr_stmt|;
comment|/* 	 * If we need to shift the line, do it. 	 * But wait until we get to at least the middle of the screen, 	 * so shifting it doesn't affect the chars we're currently 	 * pappending.  (Bold& underline can get messed up otherwise.) 	 */
if|if
condition|(
name|cshift
operator|<
name|hshift
operator|&&
name|column
operator|>
name|sc_width
operator|/
literal|2
condition|)
name|pshift
argument_list|(
name|hshift
operator|-
name|cshift
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_append
parameter_list|(
name|c
parameter_list|,
name|pos
parameter_list|)
name|int
name|c
decl_stmt|;
name|POSITION
name|pos
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|a
decl_stmt|;
define|#
directive|define
name|STOREC
parameter_list|(
name|c
parameter_list|,
name|a
parameter_list|)
define|\
value|if (storec((c),(a),pos)) return (1); else curr++
if|if
condition|(
name|c
operator|==
literal|'\b'
condition|)
block|{
switch|switch
condition|(
name|bs_mode
condition|)
block|{
case|case
name|BS_NORMAL
case|:
name|STOREC
argument_list|(
name|c
argument_list|,
name|AT_NORMAL
argument_list|)
expr_stmt|;
break|break;
case|case
name|BS_CONTROL
case|:
goto|goto
name|do_control_char
goto|;
case|case
name|BS_SPECIAL
case|:
if|if
condition|(
name|curr
operator|==
literal|0
condition|)
break|break;
name|backc
argument_list|()
expr_stmt|;
name|overstrike
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|overstrike
condition|)
block|{
comment|/* 		 * Overstrike the character at the current position 		 * in the line buffer.  This will cause either  		 * underline (if a "_" is overstruck),  		 * bold (if an identical character is overstruck), 		 * or just deletion of the character in the buffer. 		 */
name|overstrike
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|char
operator|)
name|c
operator|==
name|linebuf
index|[
name|curr
index|]
condition|)
name|STOREC
argument_list|(
name|linebuf
index|[
name|curr
index|]
argument_list|,
name|AT_BOLD
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'_'
condition|)
name|STOREC
argument_list|(
name|linebuf
index|[
name|curr
index|]
argument_list|,
name|AT_UNDERLINE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|linebuf
index|[
name|curr
index|]
operator|==
literal|'_'
condition|)
name|STOREC
argument_list|(
name|c
argument_list|,
name|AT_UNDERLINE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|control_char
argument_list|(
name|c
argument_list|)
condition|)
goto|goto
name|do_control_char
goto|;
else|else
name|STOREC
argument_list|(
name|c
argument_list|,
name|AT_NORMAL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
comment|/* 		 * Expand a tab into spaces. 		 */
if|if
condition|(
name|tabstop
operator|==
literal|0
condition|)
name|tabstop
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|bs_mode
condition|)
block|{
case|case
name|BS_CONTROL
case|:
goto|goto
name|do_control_char
goto|;
case|case
name|BS_NORMAL
case|:
case|case
name|BS_SPECIAL
case|:
do|do
block|{
name|STOREC
argument_list|(
literal|' '
argument_list|,
name|AT_NORMAL
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
operator|(
name|column
operator|+
name|cshift
operator|-
name|lmargin
operator|)
operator|%
name|tabstop
operator|)
operator|!=
literal|0
condition|)
do|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|control_char
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|do_control_char
label|:
if|if
condition|(
name|ctldisp
operator|==
name|OPT_ON
operator|||
operator|(
name|ctldisp
operator|==
name|OPT_ONPLUS
operator|&&
name|c
operator|==
name|ESC
operator|)
condition|)
block|{
comment|/* 			 * Output as a normal character. 			 */
name|STOREC
argument_list|(
name|c
argument_list|,
name|AT_NORMAL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Convert to printable representation. 			 */
name|s
operator|=
name|prchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|a
operator|=
name|binattr
expr_stmt|;
comment|/* 			 * Make sure we can get the entire representation 			 * of the character on this line. 			 */
if|if
condition|(
name|column
operator|+
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
name|attr_swidth
argument_list|(
name|a
argument_list|)
operator|+
name|attr_ewidth
argument_list|(
name|a
argument_list|)
operator|>
name|sc_width
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
init|;
operator|*
name|s
operator|!=
literal|0
condition|;
name|s
operator|++
control|)
name|STOREC
argument_list|(
operator|*
name|s
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|STOREC
argument_list|(
name|c
argument_list|,
name|AT_NORMAL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Terminate the line in the line buffer.  */
end_comment

begin_function
name|public
name|void
name|pdone
parameter_list|(
name|endline
parameter_list|)
name|int
name|endline
decl_stmt|;
block|{
if|if
condition|(
name|pendc
operator|&&
operator|(
name|pendc
operator|!=
literal|'\r'
operator|||
operator|!
name|endline
operator|)
condition|)
comment|/* 		 * If we had a pending character, put it in the buffer. 		 * But discard a pending CR if we are at end of line 		 * (that is, discard the CR in a CR/LF sequence). 		 */
operator|(
name|void
operator|)
name|do_append
argument_list|(
name|pendc
argument_list|,
name|pendpos
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure we've shifted the line, if we need to. 	 */
if|if
condition|(
name|cshift
operator|<
name|hshift
condition|)
name|pshift
argument_list|(
name|hshift
operator|-
name|cshift
argument_list|)
expr_stmt|;
comment|/* 	 * Add a newline if necessary, 	 * and append a '\0' to the end of the line. 	 */
if|if
condition|(
name|column
operator|<
name|sc_width
operator|||
operator|!
name|auto_wrap
operator|||
name|ignaw
operator|||
name|ctldisp
operator|==
name|OPT_ON
condition|)
block|{
name|linebuf
index|[
name|curr
index|]
operator|=
literal|'\n'
expr_stmt|;
name|attr
index|[
name|curr
index|]
operator|=
name|AT_NORMAL
expr_stmt|;
name|curr
operator|++
expr_stmt|;
block|}
name|linebuf
index|[
name|curr
index|]
operator|=
literal|'\0'
expr_stmt|;
name|attr
index|[
name|curr
index|]
operator|=
name|AT_NORMAL
expr_stmt|;
comment|/* 	 * If we are done with this line, reset the current shift. 	 */
if|if
condition|(
name|endline
condition|)
name|cshift
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get a character from the current line.  * Return the character as the function return value,  * and the character attribute in *ap.  */
end_comment

begin_function
name|public
name|int
name|gline
parameter_list|(
name|i
parameter_list|,
name|ap
parameter_list|)
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
modifier|*
name|ap
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|is_null_line
condition|)
block|{
comment|/* 		 * If there is no current line, we pretend the line is 		 * either "~" or "", depending on the "twiddle" flag. 		 */
operator|*
name|ap
operator|=
name|AT_BOLD
expr_stmt|;
name|s
operator|=
operator|(
name|twiddle
operator|)
condition|?
literal|"~\n"
else|:
literal|"\n"
expr_stmt|;
return|return
operator|(
name|s
index|[
name|i
index|]
operator|)
return|;
block|}
operator|*
name|ap
operator|=
name|attr
index|[
name|i
index|]
expr_stmt|;
return|return
operator|(
name|linebuf
index|[
name|i
index|]
operator|&
literal|0377
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Indicate that there is no current line.  */
end_comment

begin_function
name|public
name|void
name|null_line
parameter_list|()
block|{
name|is_null_line
operator|=
literal|1
expr_stmt|;
name|cshift
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Analogous to forw_line(), but deals with "raw lines":  * lines which are not split for screen width.  * {{ This is supposed to be more efficient than forw_line(). }}  */
end_comment

begin_function
name|public
name|POSITION
name|forw_raw_line
parameter_list|(
name|curr_pos
parameter_list|,
name|linep
parameter_list|)
name|POSITION
name|curr_pos
decl_stmt|;
name|char
modifier|*
modifier|*
name|linep
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|POSITION
name|new_pos
decl_stmt|;
if|if
condition|(
name|curr_pos
operator|==
name|NULL_POSITION
operator|||
name|ch_seek
argument_list|(
name|curr_pos
argument_list|)
operator|||
operator|(
name|c
operator|=
name|ch_forw_get
argument_list|()
operator|)
operator|==
name|EOI
condition|)
return|return
operator|(
name|NULL_POSITION
operator|)
return|;
name|p
operator|=
name|linebuf
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
name|EOI
condition|)
block|{
name|new_pos
operator|=
name|ch_tell
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|p
operator|>=
operator|&
name|linebuf
index|[
sizeof|sizeof
argument_list|(
name|linebuf
argument_list|)
operator|-
literal|1
index|]
condition|)
block|{
comment|/* 			 * Overflowed the input buffer. 			 * Pretend the line ended here. 			 * {{ The line buffer is supposed to be big 			 *    enough that this never happens. }} 			 */
name|new_pos
operator|=
name|ch_tell
argument_list|()
operator|-
literal|1
expr_stmt|;
break|break;
block|}
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|ch_forw_get
argument_list|()
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|linep
operator|!=
name|NULL
condition|)
operator|*
name|linep
operator|=
name|linebuf
expr_stmt|;
return|return
operator|(
name|new_pos
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Analogous to back_line(), but deals with "raw lines".  * {{ This is supposed to be more efficient than back_line(). }}  */
end_comment

begin_function
name|public
name|POSITION
name|back_raw_line
parameter_list|(
name|curr_pos
parameter_list|,
name|linep
parameter_list|)
name|POSITION
name|curr_pos
decl_stmt|;
name|char
modifier|*
modifier|*
name|linep
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|POSITION
name|new_pos
decl_stmt|;
if|if
condition|(
name|curr_pos
operator|==
name|NULL_POSITION
operator|||
name|curr_pos
operator|<=
name|ch_zero
argument_list|()
operator|||
name|ch_seek
argument_list|(
name|curr_pos
operator|-
literal|1
argument_list|)
condition|)
return|return
operator|(
name|NULL_POSITION
operator|)
return|;
name|p
operator|=
operator|&
name|linebuf
index|[
sizeof|sizeof
argument_list|(
name|linebuf
argument_list|)
index|]
expr_stmt|;
operator|*
operator|--
name|p
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|ch_back_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
comment|/* 			 * This is the newline ending the previous line. 			 * We have hit the beginning of the line. 			 */
name|new_pos
operator|=
name|ch_tell
argument_list|()
operator|+
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
name|EOI
condition|)
block|{
comment|/* 			 * We have hit the beginning of the file. 			 * This must be the first line in the file. 			 * This must, of course, be the beginning of the line. 			 */
name|new_pos
operator|=
name|ch_zero
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|p
operator|<=
name|linebuf
condition|)
block|{
comment|/* 			 * Overflowed the input buffer. 			 * Pretend the line ended here. 			 */
name|new_pos
operator|=
name|ch_tell
argument_list|()
operator|+
literal|1
expr_stmt|;
break|break;
block|}
operator|*
operator|--
name|p
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|linep
operator|!=
name|NULL
condition|)
operator|*
name|linep
operator|=
name|p
expr_stmt|;
return|return
operator|(
name|new_pos
operator|)
return|;
block|}
end_function

end_unit

