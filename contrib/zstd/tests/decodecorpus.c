begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright (c) 2017-present, Facebook, Inc.  * All rights reserved.  *  * This source code is licensed under the BSD-style license found in the  * LICENSE file in the root directory of this source tree. An additional grant  * of patent rights can be found in the PATENTS file in the same directory.  */
end_comment

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|"zstd.h"
end_include

begin_include
include|#
directive|include
file|"zstd_internal.h"
end_include

begin_include
include|#
directive|include
file|"mem.h"
end_include

begin_comment
comment|// Direct access to internal compression functions is required
end_comment

begin_include
include|#
directive|include
file|"zstd_compress.c"
end_include

begin_define
define|#
directive|define
name|XXH_STATIC_LINKING_ONLY
end_define

begin_include
include|#
directive|include
file|"xxhash.h"
end_include

begin_comment
comment|/* XXH64 */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MIN
end_ifndef

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_PATH
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|PATH_MAX
end_ifdef

begin_define
define|#
directive|define
name|MAX_PATH
value|PATH_MAX
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MAX_PATH
value|256
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*-************************************ *  DISPLAY Macros **************************************/
end_comment

begin_define
define|#
directive|define
name|DISPLAY
parameter_list|(
modifier|...
parameter_list|)
value|fprintf(stderr, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|DISPLAYLEVEL
parameter_list|(
name|l
parameter_list|,
modifier|...
parameter_list|)
value|if (g_displayLevel>=l) { DISPLAY(__VA_ARGS__); }
end_define

begin_decl_stmt
specifier|static
name|U32
name|g_displayLevel
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DISPLAYUPDATE
parameter_list|(
modifier|...
parameter_list|)
define|\
value|do {                                                                       \         if ((clockSpan(g_displayClock)> g_refreshRate) ||                     \             (g_displayLevel>= 4)) {                                           \             g_displayClock = clock();                                          \             DISPLAY(__VA_ARGS__);                                              \             if (g_displayLevel>= 4) fflush(stderr);                           \         }                                                                      \     } while (0)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|clock_t
name|g_refreshRate
init|=
name|CLOCKS_PER_SEC
operator|/
literal|6
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|clock_t
name|g_displayClock
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|clock_t
name|clockSpan
parameter_list|(
name|clock_t
name|cStart
parameter_list|)
block|{
return|return
name|clock
argument_list|()
operator|-
name|cStart
return|;
comment|/* works even when overflow; max span ~ 30mn */
block|}
end_function

begin_define
define|#
directive|define
name|CHECKERR
parameter_list|(
name|code
parameter_list|)
define|\
value|do {                                                                       \         if (ZSTD_isError(code)) {                                              \             DISPLAY("Error occurred while generating data: %s\n",              \                     ZSTD_getErrorName(code));                                  \             exit(1);                                                           \         }                                                                      \     } while (0)
end_define

begin_comment
comment|/*-******************************************************* *  Random function *********************************************************/
end_comment

begin_define
define|#
directive|define
name|CLAMP
parameter_list|(
name|x
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|)
value|((x)< (a) ? (a) : ((x)> (b) ? (b) : (x)))
end_define

begin_function
specifier|static
name|unsigned
name|RAND
parameter_list|(
name|unsigned
modifier|*
name|src
parameter_list|)
block|{
define|#
directive|define
name|RAND_rotl32
parameter_list|(
name|x
parameter_list|,
name|r
parameter_list|)
value|((x<< r) | (x>> (32 - r)))
specifier|static
specifier|const
name|U32
name|prime1
init|=
literal|2654435761U
decl_stmt|;
specifier|static
specifier|const
name|U32
name|prime2
init|=
literal|2246822519U
decl_stmt|;
name|U32
name|rand32
init|=
operator|*
name|src
decl_stmt|;
name|rand32
operator|*=
name|prime1
expr_stmt|;
name|rand32
operator|+=
name|prime2
expr_stmt|;
name|rand32
operator|=
name|RAND_rotl32
argument_list|(
name|rand32
argument_list|,
literal|13
argument_list|)
expr_stmt|;
operator|*
name|src
operator|=
name|rand32
expr_stmt|;
return|return
name|RAND_rotl32
argument_list|(
name|rand32
argument_list|,
literal|27
argument_list|)
return|;
undef|#
directive|undef
name|RAND_rotl32
block|}
end_function

begin_define
define|#
directive|define
name|DISTSIZE
value|(8192)
end_define

begin_comment
comment|/* Write `size` bytes into `ptr`, all of which are less than or equal to `maxSymb` */
end_comment

begin_function
specifier|static
name|void
name|RAND_bufferMaxSymb
parameter_list|(
name|U32
modifier|*
name|seed
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|int
name|maxSymb
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|BYTE
modifier|*
name|op
init|=
name|ptr
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|op
index|[
name|i
index|]
operator|=
call|(
name|BYTE
call|)
argument_list|(
name|RAND
argument_list|(
name|seed
argument_list|)
operator|%
operator|(
name|maxSymb
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write `size` random bytes into `ptr` */
end_comment

begin_function
specifier|static
name|void
name|RAND_buffer
parameter_list|(
name|U32
modifier|*
name|seed
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|BYTE
modifier|*
name|op
init|=
name|ptr
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|+
literal|4
operator|<=
name|size
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|MEM_writeLE32
argument_list|(
name|op
operator|+
name|i
argument_list|,
name|RAND
argument_list|(
name|seed
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|op
index|[
name|i
index|]
operator|=
name|RAND
argument_list|(
name|seed
argument_list|)
operator|&
literal|0xff
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write `size` bytes into `ptr` following the distribution `dist` */
end_comment

begin_function
specifier|static
name|void
name|RAND_bufferDist
parameter_list|(
name|U32
modifier|*
name|seed
parameter_list|,
name|BYTE
modifier|*
name|dist
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|BYTE
modifier|*
name|op
init|=
name|ptr
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|op
index|[
name|i
index|]
operator|=
name|dist
index|[
name|RAND
argument_list|(
name|seed
argument_list|)
operator|%
name|DISTSIZE
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate a random distribution where the frequency of each symbol follows a  * geometric distribution defined by `weight`  * `dist` should have size at least `DISTSIZE` */
end_comment

begin_function
specifier|static
name|void
name|RAND_genDist
parameter_list|(
name|U32
modifier|*
name|seed
parameter_list|,
name|BYTE
modifier|*
name|dist
parameter_list|,
name|double
name|weight
parameter_list|)
block|{
name|size_t
name|i
init|=
literal|0
decl_stmt|;
name|size_t
name|statesLeft
init|=
name|DISTSIZE
decl_stmt|;
name|BYTE
name|symb
init|=
call|(
name|BYTE
call|)
argument_list|(
name|RAND
argument_list|(
name|seed
argument_list|)
operator|%
literal|256
argument_list|)
decl_stmt|;
name|BYTE
name|step
init|=
call|(
name|BYTE
call|)
argument_list|(
operator|(
name|RAND
argument_list|(
name|seed
argument_list|)
operator|%
literal|256
operator|)
operator||
literal|1
argument_list|)
decl_stmt|;
comment|/* force it to be odd so it's relatively prime to 256 */
while|while
condition|(
name|i
operator|<
name|DISTSIZE
condition|)
block|{
name|size_t
name|states
init|=
operator|(
call|(
name|size_t
call|)
argument_list|(
name|weight
operator|*
name|statesLeft
argument_list|)
operator|)
operator|+
literal|1
decl_stmt|;
name|size_t
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|states
operator|&&
name|i
operator|<
name|DISTSIZE
condition|;
name|j
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|dist
index|[
name|i
index|]
operator|=
name|symb
expr_stmt|;
block|}
name|symb
operator|+=
name|step
expr_stmt|;
name|statesLeft
operator|-=
name|states
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generates a random number in the range [min, max) */
end_comment

begin_function
specifier|static
specifier|inline
name|U32
name|RAND_range
parameter_list|(
name|U32
modifier|*
name|seed
parameter_list|,
name|U32
name|min
parameter_list|,
name|U32
name|max
parameter_list|)
block|{
return|return
operator|(
name|RAND
argument_list|(
name|seed
argument_list|)
operator|%
operator|(
name|max
operator|-
name|min
operator|)
operator|)
operator|+
name|min
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ROUND
parameter_list|(
name|x
parameter_list|)
value|((U32)(x + 0.5))
end_define

begin_comment
comment|/* Generates a random number in an exponential distribution with mean `mean` */
end_comment

begin_function
specifier|static
name|double
name|RAND_exp
parameter_list|(
name|U32
modifier|*
name|seed
parameter_list|,
name|double
name|mean
parameter_list|)
block|{
name|double
specifier|const
name|u
init|=
name|RAND
argument_list|(
name|seed
argument_list|)
operator|/
operator|(
name|double
operator|)
name|UINT_MAX
decl_stmt|;
return|return
name|log
argument_list|(
literal|1
operator|-
name|u
argument_list|)
operator|*
operator|(
operator|-
name|mean
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-******************************************************* *  Constants and Structs *********************************************************/
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|BLOCK_TYPES
index|[]
init|=
block|{
literal|"raw"
block|,
literal|"rle"
block|,
literal|"compressed"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAX_DECOMPRESSED_SIZE_LOG
value|20
end_define

begin_define
define|#
directive|define
name|MAX_DECOMPRESSED_SIZE
value|(1ULL<< MAX_DECOMPRESSED_SIZE_LOG)
end_define

begin_define
define|#
directive|define
name|MAX_WINDOW_LOG
value|22
end_define

begin_comment
comment|/* Recommended support is 8MB, so limit to 4MB + mantissa */
end_comment

begin_define
define|#
directive|define
name|MAX_BLOCK_SIZE
value|(128ULL * 1024)
end_define

begin_define
define|#
directive|define
name|MIN_SEQ_LEN
value|(3)
end_define

begin_define
define|#
directive|define
name|MAX_NB_SEQ
value|((MAX_BLOCK_SIZE + MIN_SEQ_LEN - 1) / MIN_SEQ_LEN)
end_define

begin_decl_stmt
name|BYTE
name|CONTENT_BUFFER
index|[
name|MAX_DECOMPRESSED_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BYTE
name|FRAME_BUFFER
index|[
name|MAX_DECOMPRESSED_SIZE
operator|*
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BYTE
name|LITERAL_BUFFER
index|[
name|MAX_BLOCK_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|seqDef
name|SEQUENCE_BUFFER
index|[
name|MAX_NB_SEQ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BYTE
name|SEQUENCE_LITERAL_BUFFER
index|[
name|MAX_BLOCK_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* storeSeq expects a place to copy literals to */
end_comment

begin_decl_stmt
name|BYTE
name|SEQUENCE_LLCODE
index|[
name|MAX_BLOCK_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BYTE
name|SEQUENCE_MLCODE
index|[
name|MAX_BLOCK_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BYTE
name|SEQUENCE_OFCODE
index|[
name|MAX_BLOCK_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|WKSP
index|[
literal|1024
index|]
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
block|{
name|size_t
name|contentSize
decl_stmt|;
comment|/* 0 means unknown (unless contentSize == windowSize == 0) */
name|unsigned
name|windowSize
decl_stmt|;
comment|/* contentSize>= windowSize means single segment */
block|}
name|frameHeader_t
typedef|;
end_typedef

begin_comment
comment|/* For repeat modes */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|U32
name|rep
index|[
name|ZSTD_REP_NUM
index|]
decl_stmt|;
name|int
name|hufInit
decl_stmt|;
comment|/* the distribution used in the previous block for repeat mode */
name|BYTE
name|hufDist
index|[
name|DISTSIZE
index|]
decl_stmt|;
name|U32
name|hufTable
index|[
literal|256
index|]
decl_stmt|;
comment|/* HUF_CElt is an incomplete type */
name|int
name|fseInit
decl_stmt|;
name|FSE_CTable
name|offcodeCTable
index|[
name|FSE_CTABLE_SIZE_U32
argument_list|(
name|OffFSELog
argument_list|,
name|MaxOff
argument_list|)
index|]
decl_stmt|;
name|FSE_CTable
name|matchlengthCTable
index|[
name|FSE_CTABLE_SIZE_U32
argument_list|(
name|MLFSELog
argument_list|,
name|MaxML
argument_list|)
index|]
decl_stmt|;
name|FSE_CTable
name|litlengthCTable
index|[
name|FSE_CTABLE_SIZE_U32
argument_list|(
name|LLFSELog
argument_list|,
name|MaxLL
argument_list|)
index|]
decl_stmt|;
comment|/* Symbols that were present in the previous distribution, for use with      * set_repeat */
name|BYTE
name|litlengthSymbolSet
index|[
literal|36
index|]
decl_stmt|;
name|BYTE
name|offsetSymbolSet
index|[
literal|29
index|]
decl_stmt|;
name|BYTE
name|matchlengthSymbolSet
index|[
literal|53
index|]
decl_stmt|;
block|}
name|cblockStats_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|void
modifier|*
name|data
decl_stmt|;
name|void
modifier|*
name|dataStart
decl_stmt|;
name|void
modifier|*
name|dataEnd
decl_stmt|;
name|void
modifier|*
name|src
decl_stmt|;
name|void
modifier|*
name|srcStart
decl_stmt|;
name|void
modifier|*
name|srcEnd
decl_stmt|;
name|frameHeader_t
name|header
decl_stmt|;
name|cblockStats_t
name|stats
decl_stmt|;
name|cblockStats_t
name|oldStats
decl_stmt|;
comment|/* so they can be rolled back if uncompressible */
block|}
name|frame_t
typedef|;
end_typedef

begin_comment
comment|/*-******************************************************* *  Generator Functions *********************************************************/
end_comment

begin_struct
struct|struct
block|{
name|int
name|contentSize
decl_stmt|;
comment|/* force the content size to be present */
block|}
name|opts
struct|;
end_struct

begin_comment
comment|/* advanced options on generation */
end_comment

begin_comment
comment|/* Generate and write a random frame header */
end_comment

begin_function
specifier|static
name|void
name|writeFrameHeader
parameter_list|(
name|U32
modifier|*
name|seed
parameter_list|,
name|frame_t
modifier|*
name|frame
parameter_list|)
block|{
name|BYTE
modifier|*
specifier|const
name|op
init|=
name|frame
operator|->
name|data
decl_stmt|;
name|size_t
name|pos
init|=
literal|0
decl_stmt|;
name|frameHeader_t
name|fh
decl_stmt|;
name|BYTE
name|windowByte
init|=
literal|0
decl_stmt|;
name|int
name|singleSegment
init|=
literal|0
decl_stmt|;
name|int
name|contentSizeFlag
init|=
literal|0
decl_stmt|;
name|int
name|fcsCode
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
operator|&
name|fh
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|fh
argument_list|)
argument_list|)
expr_stmt|;
comment|/* generate window size */
block|{
comment|/* Follow window algorithm from specification */
name|int
specifier|const
name|exponent
init|=
name|RAND
argument_list|(
name|seed
argument_list|)
operator|%
operator|(
name|MAX_WINDOW_LOG
operator|-
literal|10
operator|)
decl_stmt|;
name|int
specifier|const
name|mantissa
init|=
name|RAND
argument_list|(
name|seed
argument_list|)
operator|%
literal|8
decl_stmt|;
name|windowByte
operator|=
call|(
name|BYTE
call|)
argument_list|(
operator|(
name|exponent
operator|<<
literal|3
operator|)
operator||
name|mantissa
argument_list|)
expr_stmt|;
name|fh
operator|.
name|windowSize
operator|=
operator|(
literal|1U
operator|<<
operator|(
name|exponent
operator|+
literal|10
operator|)
operator|)
expr_stmt|;
name|fh
operator|.
name|windowSize
operator|+=
name|fh
operator|.
name|windowSize
operator|/
literal|8
operator|*
name|mantissa
expr_stmt|;
block|}
block|{
comment|/* Generate random content size */
name|size_t
name|highBit
decl_stmt|;
if|if
condition|(
name|RAND
argument_list|(
name|seed
argument_list|)
operator|&
literal|7
condition|)
block|{
comment|/* do content of at least 128 bytes */
name|highBit
operator|=
literal|1ULL
operator|<<
name|RAND_range
argument_list|(
name|seed
argument_list|,
literal|7
argument_list|,
name|MAX_DECOMPRESSED_SIZE_LOG
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RAND
argument_list|(
name|seed
argument_list|)
operator|&
literal|3
condition|)
block|{
comment|/* do small content */
name|highBit
operator|=
literal|1ULL
operator|<<
name|RAND_range
argument_list|(
name|seed
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 0 size frame */
name|highBit
operator|=
literal|0
expr_stmt|;
block|}
name|fh
operator|.
name|contentSize
operator|=
name|highBit
condition|?
name|highBit
operator|+
operator|(
name|RAND
argument_list|(
name|seed
argument_list|)
operator|%
name|highBit
operator|)
else|:
literal|0
expr_stmt|;
comment|/* provide size sometimes */
name|contentSizeFlag
operator|=
name|opts
operator|.
name|contentSize
operator||
operator|(
name|RAND
argument_list|(
name|seed
argument_list|)
operator|&
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|contentSizeFlag
operator|&&
operator|(
name|fh
operator|.
name|contentSize
operator|==
literal|0
operator|||
operator|!
operator|(
name|RAND
argument_list|(
name|seed
argument_list|)
operator|&
literal|7
operator|)
operator|)
condition|)
block|{
comment|/* do single segment sometimes */
name|fh
operator|.
name|windowSize
operator|=
operator|(
name|U32
operator|)
name|fh
operator|.
name|contentSize
expr_stmt|;
name|singleSegment
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|contentSizeFlag
condition|)
block|{
comment|/* Determine how large fcs field has to be */
name|int
name|minFcsCode
init|=
operator|(
name|fh
operator|.
name|contentSize
operator|>=
literal|256
operator|)
operator|+
operator|(
name|fh
operator|.
name|contentSize
operator|>=
literal|65536
operator|+
literal|256
operator|)
operator|+
operator|(
name|fh
operator|.
name|contentSize
operator|>
literal|0xFFFFFFFFU
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|singleSegment
operator|&&
operator|!
name|minFcsCode
condition|)
block|{
name|minFcsCode
operator|=
literal|1
expr_stmt|;
block|}
name|fcsCode
operator|=
name|minFcsCode
operator|+
operator|(
name|RAND
argument_list|(
name|seed
argument_list|)
operator|%
operator|(
literal|4
operator|-
name|minFcsCode
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|fcsCode
operator|==
literal|1
operator|&&
name|fh
operator|.
name|contentSize
operator|<
literal|256
condition|)
name|fcsCode
operator|++
expr_stmt|;
block|}
comment|/* write out the header */
name|MEM_writeLE32
argument_list|(
name|op
operator|+
name|pos
argument_list|,
name|ZSTD_MAGICNUMBER
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|4
expr_stmt|;
block|{
name|BYTE
specifier|const
name|frameHeaderDescriptor
init|=
call|(
name|BYTE
call|)
argument_list|(
operator|(
name|fcsCode
operator|<<
literal|6
operator|)
operator||
operator|(
name|singleSegment
operator|<<
literal|5
operator|)
operator||
operator|(
literal|1
operator|<<
literal|2
operator|)
argument_list|)
decl_stmt|;
name|op
index|[
name|pos
operator|++
index|]
operator|=
name|frameHeaderDescriptor
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|singleSegment
condition|)
block|{
name|op
index|[
name|pos
operator|++
index|]
operator|=
name|windowByte
expr_stmt|;
block|}
if|if
condition|(
name|contentSizeFlag
condition|)
block|{
switch|switch
condition|(
name|fcsCode
condition|)
block|{
default|default:
comment|/* Impossible */
case|case
literal|0
case|:
name|op
index|[
name|pos
operator|++
index|]
operator|=
operator|(
name|BYTE
operator|)
name|fh
operator|.
name|contentSize
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|MEM_writeLE16
argument_list|(
name|op
operator|+
name|pos
argument_list|,
call|(
name|U16
call|)
argument_list|(
name|fh
operator|.
name|contentSize
operator|-
literal|256
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|MEM_writeLE32
argument_list|(
name|op
operator|+
name|pos
argument_list|,
operator|(
name|U32
operator|)
name|fh
operator|.
name|contentSize
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|MEM_writeLE64
argument_list|(
name|op
operator|+
name|pos
argument_list|,
operator|(
name|U64
operator|)
name|fh
operator|.
name|contentSize
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|8
expr_stmt|;
break|break;
block|}
block|}
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|" frame content size:\t%u\n"
argument_list|,
operator|(
name|U32
operator|)
name|fh
operator|.
name|contentSize
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|" frame window size:\t%u\n"
argument_list|,
name|fh
operator|.
name|windowSize
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|" content size flag:\t%d\n"
argument_list|,
name|contentSizeFlag
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|" single segment flag:\t%d\n"
argument_list|,
name|singleSegment
argument_list|)
expr_stmt|;
name|frame
operator|->
name|data
operator|=
name|op
operator|+
name|pos
expr_stmt|;
name|frame
operator|->
name|header
operator|=
name|fh
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write a literal block in either raw or RLE form, return the literals size */
end_comment

begin_function
specifier|static
name|size_t
name|writeLiteralsBlockSimple
parameter_list|(
name|U32
modifier|*
name|seed
parameter_list|,
name|frame_t
modifier|*
name|frame
parameter_list|,
name|size_t
name|contentSize
parameter_list|)
block|{
name|BYTE
modifier|*
name|op
init|=
operator|(
name|BYTE
operator|*
operator|)
name|frame
operator|->
name|data
decl_stmt|;
name|int
specifier|const
name|type
init|=
name|RAND
argument_list|(
name|seed
argument_list|)
operator|%
literal|2
decl_stmt|;
name|int
specifier|const
name|sizeFormatDesc
init|=
name|RAND
argument_list|(
name|seed
argument_list|)
operator|%
literal|8
decl_stmt|;
name|size_t
name|litSize
decl_stmt|;
name|size_t
name|maxLitSize
init|=
name|MIN
argument_list|(
name|contentSize
argument_list|,
name|MAX_BLOCK_SIZE
argument_list|)
decl_stmt|;
if|if
condition|(
name|sizeFormatDesc
operator|==
literal|0
condition|)
block|{
comment|/* Size_FormatDesc = ?0 */
name|maxLitSize
operator|=
name|MIN
argument_list|(
name|maxLitSize
argument_list|,
literal|31
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sizeFormatDesc
operator|<=
literal|4
condition|)
block|{
comment|/* Size_FormatDesc = 01 */
name|maxLitSize
operator|=
name|MIN
argument_list|(
name|maxLitSize
argument_list|,
literal|4095
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Size_Format = 11 */
name|maxLitSize
operator|=
name|MIN
argument_list|(
name|maxLitSize
argument_list|,
literal|1048575
argument_list|)
expr_stmt|;
block|}
name|litSize
operator|=
name|RAND
argument_list|(
name|seed
argument_list|)
operator|%
operator|(
name|maxLitSize
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|src
operator|==
name|frame
operator|->
name|srcStart
operator|&&
name|litSize
operator|==
literal|0
condition|)
block|{
name|litSize
operator|=
literal|1
expr_stmt|;
comment|/* no empty literals if there's nothing preceding this block */
block|}
if|if
condition|(
name|litSize
operator|+
literal|3
operator|>
name|contentSize
condition|)
block|{
name|litSize
operator|=
name|contentSize
expr_stmt|;
comment|/* no matches shorter than 3 are allowed */
block|}
comment|/* use smallest size format that fits */
if|if
condition|(
name|litSize
operator|<
literal|32
condition|)
block|{
name|op
index|[
literal|0
index|]
operator|=
operator|(
name|type
operator||
operator|(
literal|0
operator|<<
literal|2
operator|)
operator||
operator|(
name|litSize
operator|<<
literal|3
operator|)
operator|)
operator|&
literal|0xff
expr_stmt|;
name|op
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|litSize
operator|<
literal|4096
condition|)
block|{
name|op
index|[
literal|0
index|]
operator|=
operator|(
name|type
operator||
operator|(
literal|1
operator|<<
literal|2
operator|)
operator||
operator|(
name|litSize
operator|<<
literal|4
operator|)
operator|)
operator|&
literal|0xff
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
operator|(
name|litSize
operator|>>
literal|4
operator|)
operator|&
literal|0xff
expr_stmt|;
name|op
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|op
index|[
literal|0
index|]
operator|=
operator|(
name|type
operator||
operator|(
literal|3
operator|<<
literal|2
operator|)
operator||
operator|(
name|litSize
operator|<<
literal|4
operator|)
operator|)
operator|&
literal|0xff
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
operator|(
name|litSize
operator|>>
literal|4
operator|)
operator|&
literal|0xff
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
operator|(
name|litSize
operator|>>
literal|12
operator|)
operator|&
literal|0xff
expr_stmt|;
name|op
operator|+=
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
literal|0
condition|)
block|{
comment|/* Raw literals */
name|DISPLAYLEVEL
argument_list|(
literal|4
argument_list|,
literal|"   raw literals\n"
argument_list|)
expr_stmt|;
name|RAND_buffer
argument_list|(
name|seed
argument_list|,
name|LITERAL_BUFFER
argument_list|,
name|litSize
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|op
argument_list|,
name|LITERAL_BUFFER
argument_list|,
name|litSize
argument_list|)
expr_stmt|;
name|op
operator|+=
name|litSize
expr_stmt|;
block|}
else|else
block|{
comment|/* RLE literals */
name|BYTE
specifier|const
name|symb
init|=
call|(
name|BYTE
call|)
argument_list|(
name|RAND
argument_list|(
name|seed
argument_list|)
operator|%
literal|256
argument_list|)
decl_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|4
argument_list|,
literal|"   rle literals: 0x%02x\n"
argument_list|,
operator|(
name|U32
operator|)
name|symb
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|LITERAL_BUFFER
argument_list|,
name|symb
argument_list|,
name|litSize
argument_list|)
expr_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|symb
expr_stmt|;
name|op
operator|++
expr_stmt|;
block|}
name|frame
operator|->
name|data
operator|=
name|op
expr_stmt|;
return|return
name|litSize
return|;
block|}
end_function

begin_comment
comment|/* Generate a Huffman header for the given source */
end_comment

begin_function
specifier|static
name|size_t
name|writeHufHeader
parameter_list|(
name|U32
modifier|*
name|seed
parameter_list|,
name|HUF_CElt
modifier|*
name|hufTable
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
name|BYTE
modifier|*
specifier|const
name|ostart
init|=
operator|(
name|BYTE
operator|*
operator|)
name|dst
decl_stmt|;
name|BYTE
modifier|*
name|op
init|=
name|ostart
decl_stmt|;
name|unsigned
name|huffLog
init|=
literal|11
decl_stmt|;
name|U32
name|maxSymbolValue
init|=
literal|255
decl_stmt|;
name|U32
name|count
index|[
name|HUF_SYMBOLVALUE_MAX
operator|+
literal|1
index|]
decl_stmt|;
comment|/* Scan input and build symbol stats */
block|{
name|size_t
specifier|const
name|largest
init|=
name|FSE_count_wksp
argument_list|(
name|count
argument_list|,
operator|&
name|maxSymbolValue
argument_list|,
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
argument_list|,
name|srcSize
argument_list|,
name|WKSP
argument_list|)
decl_stmt|;
if|if
condition|(
name|largest
operator|==
name|srcSize
condition|)
block|{
operator|*
name|ostart
operator|=
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
operator|)
index|[
literal|0
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* single symbol, rle */
if|if
condition|(
name|largest
operator|<=
operator|(
name|srcSize
operator|>>
literal|7
operator|)
operator|+
literal|1
condition|)
return|return
literal|0
return|;
comment|/* Fast heuristic : not compressible enough */
block|}
comment|/* Build Huffman Tree */
comment|/* Max Huffman log is 11, min is highbit(maxSymbolValue)+1 */
name|huffLog
operator|=
name|RAND_range
argument_list|(
name|seed
argument_list|,
name|ZSTD_highbit32
argument_list|(
name|maxSymbolValue
argument_list|)
operator|+
literal|1
argument_list|,
name|huffLog
operator|+
literal|1
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|6
argument_list|,
literal|"     huffman log: %u\n"
argument_list|,
name|huffLog
argument_list|)
expr_stmt|;
block|{
name|size_t
specifier|const
name|maxBits
init|=
name|HUF_buildCTable_wksp
argument_list|(
name|hufTable
argument_list|,
name|count
argument_list|,
name|maxSymbolValue
argument_list|,
name|huffLog
argument_list|,
name|WKSP
argument_list|,
sizeof|sizeof
argument_list|(
name|WKSP
argument_list|)
argument_list|)
decl_stmt|;
name|CHECKERR
argument_list|(
name|maxBits
argument_list|)
expr_stmt|;
name|huffLog
operator|=
operator|(
name|U32
operator|)
name|maxBits
expr_stmt|;
block|}
comment|/* Write table description header */
block|{
name|size_t
specifier|const
name|hSize
init|=
name|HUF_writeCTable
argument_list|(
name|op
argument_list|,
name|dstSize
argument_list|,
name|hufTable
argument_list|,
name|maxSymbolValue
argument_list|,
name|huffLog
argument_list|)
decl_stmt|;
if|if
condition|(
name|hSize
operator|+
literal|12
operator|>=
name|srcSize
condition|)
return|return
literal|0
return|;
comment|/* not useful to try compression */
name|op
operator|+=
name|hSize
expr_stmt|;
block|}
return|return
name|op
operator|-
name|ostart
return|;
block|}
end_function

begin_comment
comment|/* Write a Huffman coded literals block and return the litearls size */
end_comment

begin_function
specifier|static
name|size_t
name|writeLiteralsBlockCompressed
parameter_list|(
name|U32
modifier|*
name|seed
parameter_list|,
name|frame_t
modifier|*
name|frame
parameter_list|,
name|size_t
name|contentSize
parameter_list|)
block|{
name|BYTE
modifier|*
name|origop
init|=
operator|(
name|BYTE
operator|*
operator|)
name|frame
operator|->
name|data
decl_stmt|;
name|BYTE
modifier|*
name|opend
init|=
operator|(
name|BYTE
operator|*
operator|)
name|frame
operator|->
name|dataEnd
decl_stmt|;
name|BYTE
modifier|*
name|op
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|ostart
init|=
name|origop
decl_stmt|;
name|int
specifier|const
name|sizeFormat
init|=
name|RAND
argument_list|(
name|seed
argument_list|)
operator|%
literal|4
decl_stmt|;
name|size_t
name|litSize
decl_stmt|;
name|size_t
name|hufHeaderSize
init|=
literal|0
decl_stmt|;
name|size_t
name|compressedSize
init|=
literal|0
decl_stmt|;
name|size_t
name|maxLitSize
init|=
name|MIN
argument_list|(
name|contentSize
operator|-
literal|3
argument_list|,
name|MAX_BLOCK_SIZE
argument_list|)
decl_stmt|;
name|symbolEncodingType_e
name|hType
decl_stmt|;
if|if
condition|(
name|contentSize
operator|<
literal|64
condition|)
block|{
comment|/* make sure we get reasonably-sized literals for compression */
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
block|}
name|DISPLAYLEVEL
argument_list|(
literal|4
argument_list|,
literal|"   compressed literals\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sizeFormat
condition|)
block|{
case|case
literal|0
case|:
comment|/* fall through, size is the same as case 1 */
case|case
literal|1
case|:
name|maxLitSize
operator|=
name|MIN
argument_list|(
name|maxLitSize
argument_list|,
literal|1023
argument_list|)
expr_stmt|;
name|origop
operator|+=
literal|3
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|maxLitSize
operator|=
name|MIN
argument_list|(
name|maxLitSize
argument_list|,
literal|16383
argument_list|)
expr_stmt|;
name|origop
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|maxLitSize
operator|=
name|MIN
argument_list|(
name|maxLitSize
argument_list|,
literal|262143
argument_list|)
expr_stmt|;
name|origop
operator|+=
literal|5
expr_stmt|;
break|break;
default|default:
empty_stmt|;
comment|/* impossible */
block|}
do|do
block|{
name|op
operator|=
name|origop
expr_stmt|;
do|do
block|{
name|litSize
operator|=
name|RAND
argument_list|(
name|seed
argument_list|)
operator|%
operator|(
name|maxLitSize
operator|+
literal|1
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|litSize
operator|<
literal|32
condition|)
do|;
comment|/* avoid small literal sizes */
if|if
condition|(
name|litSize
operator|+
literal|3
operator|>
name|contentSize
condition|)
block|{
name|litSize
operator|=
name|contentSize
expr_stmt|;
comment|/* no matches shorter than 3 are allowed */
block|}
comment|/* most of the time generate a new distribution */
if|if
condition|(
operator|(
name|RAND
argument_list|(
name|seed
argument_list|)
operator|&
literal|3
operator|)
operator|||
operator|!
name|frame
operator|->
name|stats
operator|.
name|hufInit
condition|)
block|{
do|do
block|{
if|if
condition|(
name|RAND
argument_list|(
name|seed
argument_list|)
operator|&
literal|3
condition|)
block|{
comment|/* add 10 to ensure some compressability */
name|double
specifier|const
name|weight
init|=
operator|(
operator|(
name|RAND
argument_list|(
name|seed
argument_list|)
operator|%
literal|90
operator|)
operator|+
literal|10
operator|)
operator|/
literal|100.0
decl_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|5
argument_list|,
literal|"    distribution weight: %d%%\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|weight
operator|*
literal|100
argument_list|)
argument_list|)
expr_stmt|;
name|RAND_genDist
argument_list|(
name|seed
argument_list|,
name|frame
operator|->
name|stats
operator|.
name|hufDist
argument_list|,
name|weight
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* sometimes do restricted range literals to force                      * non-huffman headers */
name|DISPLAYLEVEL
argument_list|(
literal|5
argument_list|,
literal|"    small range literals\n"
argument_list|)
expr_stmt|;
name|RAND_bufferMaxSymb
argument_list|(
name|seed
argument_list|,
name|frame
operator|->
name|stats
operator|.
name|hufDist
argument_list|,
name|DISTSIZE
argument_list|,
literal|15
argument_list|)
expr_stmt|;
block|}
name|RAND_bufferDist
argument_list|(
name|seed
argument_list|,
name|frame
operator|->
name|stats
operator|.
name|hufDist
argument_list|,
name|LITERAL_BUFFER
argument_list|,
name|litSize
argument_list|)
expr_stmt|;
comment|/* generate the header from the distribution instead of the                  * actual data to avoid bugs with symbols that were in the                  * distribution but never showed up in the output */
name|hufHeaderSize
operator|=
name|writeHufHeader
argument_list|(
name|seed
argument_list|,
operator|(
name|HUF_CElt
operator|*
operator|)
name|frame
operator|->
name|stats
operator|.
name|hufTable
argument_list|,
name|op
argument_list|,
name|opend
operator|-
name|op
argument_list|,
name|frame
operator|->
name|stats
operator|.
name|hufDist
argument_list|,
name|DISTSIZE
argument_list|)
expr_stmt|;
name|CHECKERR
argument_list|(
name|hufHeaderSize
argument_list|)
expr_stmt|;
comment|/* repeat until a valid header is written */
block|}
do|while
condition|(
name|hufHeaderSize
operator|==
literal|0
condition|)
do|;
name|op
operator|+=
name|hufHeaderSize
expr_stmt|;
name|hType
operator|=
name|set_compressed
expr_stmt|;
name|frame
operator|->
name|stats
operator|.
name|hufInit
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* repeat the distribution/table from last time */
name|DISPLAYLEVEL
argument_list|(
literal|5
argument_list|,
literal|"    huffman repeat stats\n"
argument_list|)
expr_stmt|;
name|RAND_bufferDist
argument_list|(
name|seed
argument_list|,
name|frame
operator|->
name|stats
operator|.
name|hufDist
argument_list|,
name|LITERAL_BUFFER
argument_list|,
name|litSize
argument_list|)
expr_stmt|;
name|hufHeaderSize
operator|=
literal|0
expr_stmt|;
name|hType
operator|=
name|set_repeat
expr_stmt|;
block|}
do|do
block|{
name|compressedSize
operator|=
name|sizeFormat
operator|==
literal|0
condition|?
name|HUF_compress1X_usingCTable
argument_list|(
name|op
argument_list|,
name|opend
operator|-
name|op
argument_list|,
name|LITERAL_BUFFER
argument_list|,
name|litSize
argument_list|,
operator|(
name|HUF_CElt
operator|*
operator|)
name|frame
operator|->
name|stats
operator|.
name|hufTable
argument_list|)
else|:
name|HUF_compress4X_usingCTable
argument_list|(
name|op
argument_list|,
name|opend
operator|-
name|op
argument_list|,
name|LITERAL_BUFFER
argument_list|,
name|litSize
argument_list|,
operator|(
name|HUF_CElt
operator|*
operator|)
name|frame
operator|->
name|stats
operator|.
name|hufTable
argument_list|)
expr_stmt|;
name|CHECKERR
argument_list|(
name|compressedSize
argument_list|)
expr_stmt|;
comment|/* this only occurs when it could not compress or similar */
block|}
do|while
condition|(
name|compressedSize
operator|<=
literal|0
condition|)
do|;
name|op
operator|+=
name|compressedSize
expr_stmt|;
name|compressedSize
operator|+=
name|hufHeaderSize
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|5
argument_list|,
literal|"    regenerated size: %u\n"
argument_list|,
operator|(
name|U32
operator|)
name|litSize
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|5
argument_list|,
literal|"    compressed size: %u\n"
argument_list|,
operator|(
name|U32
operator|)
name|compressedSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|compressedSize
operator|>=
name|litSize
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|5
argument_list|,
literal|"     trying again\n"
argument_list|)
expr_stmt|;
comment|/* if we have to try again, reset the stats so we don't accidentally              * try to repeat a distribution we just made */
name|frame
operator|->
name|stats
operator|=
name|frame
operator|->
name|oldStats
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
do|while
condition|(
literal|1
condition|)
do|;
comment|/* write header */
switch|switch
condition|(
name|sizeFormat
condition|)
block|{
case|case
literal|0
case|:
comment|/* fall through, size is the same as case 1 */
case|case
literal|1
case|:
block|{
name|U32
specifier|const
name|header
init|=
name|hType
operator||
operator|(
name|sizeFormat
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|U32
operator|)
name|litSize
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
name|U32
operator|)
name|compressedSize
operator|<<
literal|14
operator|)
decl_stmt|;
name|MEM_writeLE24
argument_list|(
name|ostart
argument_list|,
name|header
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|2
case|:
block|{
name|U32
specifier|const
name|header
init|=
name|hType
operator||
operator|(
name|sizeFormat
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|U32
operator|)
name|litSize
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
name|U32
operator|)
name|compressedSize
operator|<<
literal|18
operator|)
decl_stmt|;
name|MEM_writeLE32
argument_list|(
name|ostart
argument_list|,
name|header
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|3
case|:
block|{
name|U32
specifier|const
name|header
init|=
name|hType
operator||
operator|(
name|sizeFormat
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|U32
operator|)
name|litSize
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
name|U32
operator|)
name|compressedSize
operator|<<
literal|22
operator|)
decl_stmt|;
name|MEM_writeLE32
argument_list|(
name|ostart
argument_list|,
name|header
argument_list|)
expr_stmt|;
name|ostart
index|[
literal|4
index|]
operator|=
call|(
name|BYTE
call|)
argument_list|(
name|compressedSize
operator|>>
literal|10
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
empty_stmt|;
comment|/* impossible */
block|}
name|frame
operator|->
name|data
operator|=
name|op
expr_stmt|;
return|return
name|litSize
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|writeLiteralsBlock
parameter_list|(
name|U32
modifier|*
name|seed
parameter_list|,
name|frame_t
modifier|*
name|frame
parameter_list|,
name|size_t
name|contentSize
parameter_list|)
block|{
comment|/* only do compressed for larger segments to avoid compressibility issues */
if|if
condition|(
name|RAND
argument_list|(
name|seed
argument_list|)
operator|&
literal|7
operator|&&
name|contentSize
operator|>=
literal|64
condition|)
block|{
return|return
name|writeLiteralsBlockCompressed
argument_list|(
name|seed
argument_list|,
name|frame
argument_list|,
name|contentSize
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|writeLiteralsBlockSimple
argument_list|(
name|seed
argument_list|,
name|frame
argument_list|,
name|contentSize
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|initSeqStore
parameter_list|(
name|seqStore_t
modifier|*
name|seqStore
parameter_list|)
block|{
name|seqStore
operator|->
name|sequencesStart
operator|=
name|SEQUENCE_BUFFER
expr_stmt|;
name|seqStore
operator|->
name|litStart
operator|=
name|SEQUENCE_LITERAL_BUFFER
expr_stmt|;
name|seqStore
operator|->
name|llCode
operator|=
name|SEQUENCE_LLCODE
expr_stmt|;
name|seqStore
operator|->
name|mlCode
operator|=
name|SEQUENCE_MLCODE
expr_stmt|;
name|seqStore
operator|->
name|ofCode
operator|=
name|SEQUENCE_OFCODE
expr_stmt|;
name|ZSTD_resetSeqStore
argument_list|(
name|seqStore
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Randomly generate sequence commands */
end_comment

begin_function
specifier|static
name|U32
name|generateSequences
parameter_list|(
name|U32
modifier|*
name|seed
parameter_list|,
name|frame_t
modifier|*
name|frame
parameter_list|,
name|seqStore_t
modifier|*
name|seqStore
parameter_list|,
name|size_t
name|contentSize
parameter_list|,
name|size_t
name|literalsSize
parameter_list|)
block|{
comment|/* The total length of all the matches */
name|size_t
specifier|const
name|remainingMatch
init|=
name|contentSize
operator|-
name|literalsSize
decl_stmt|;
name|size_t
name|excessMatch
init|=
literal|0
decl_stmt|;
name|U32
name|numSequences
init|=
literal|0
decl_stmt|;
name|U32
name|i
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|literals
init|=
name|LITERAL_BUFFER
decl_stmt|;
name|BYTE
modifier|*
name|srcPtr
init|=
name|frame
operator|->
name|src
decl_stmt|;
if|if
condition|(
name|literalsSize
operator|!=
name|contentSize
condition|)
block|{
comment|/* each match must be at least MIN_SEQ_LEN, so this is the maximum          * number of sequences we can have */
name|U32
specifier|const
name|maxSequences
init|=
operator|(
name|U32
operator|)
name|remainingMatch
operator|/
name|MIN_SEQ_LEN
decl_stmt|;
name|numSequences
operator|=
operator|(
name|RAND
argument_list|(
name|seed
argument_list|)
operator|%
name|maxSequences
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* the extra match lengths we have to allocate to each sequence */
name|excessMatch
operator|=
name|remainingMatch
operator|-
name|numSequences
operator|*
name|MIN_SEQ_LEN
expr_stmt|;
block|}
name|DISPLAYLEVEL
argument_list|(
literal|5
argument_list|,
literal|"    total match lengths: %u\n"
argument_list|,
operator|(
name|U32
operator|)
name|remainingMatch
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numSequences
condition|;
name|i
operator|++
control|)
block|{
comment|/* Generate match and literal lengths by exponential distribution to          * ensure nice numbers */
name|U32
name|matchLen
init|=
name|MIN_SEQ_LEN
operator|+
name|ROUND
argument_list|(
name|RAND_exp
argument_list|(
name|seed
argument_list|,
name|excessMatch
operator|/
call|(
name|double
call|)
argument_list|(
name|numSequences
operator|-
name|i
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|U32
name|literalLen
init|=
operator|(
name|RAND
argument_list|(
name|seed
argument_list|)
operator|&
literal|7
operator|)
condition|?
name|ROUND
argument_list|(
name|RAND_exp
argument_list|(
name|seed
argument_list|,
name|literalsSize
operator|/
call|(
name|double
call|)
argument_list|(
name|numSequences
operator|-
name|i
argument_list|)
argument_list|)
argument_list|)
else|:
literal|0
decl_stmt|;
comment|/* actual offset, code to send, and point to copy up to when shifting          * codes in the repeat offsets history */
name|U32
name|offset
decl_stmt|,
name|offsetCode
decl_stmt|,
name|repIndex
decl_stmt|;
comment|/* bounds checks */
name|matchLen
operator|=
operator|(
name|U32
operator|)
name|MIN
argument_list|(
name|matchLen
argument_list|,
name|excessMatch
operator|+
name|MIN_SEQ_LEN
argument_list|)
expr_stmt|;
name|literalLen
operator|=
name|MIN
argument_list|(
name|literalLen
argument_list|,
operator|(
name|U32
operator|)
name|literalsSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|srcPtr
operator|==
name|frame
operator|->
name|srcStart
operator|&&
name|literalLen
operator|==
literal|0
condition|)
name|literalLen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|numSequences
condition|)
name|matchLen
operator|=
name|MIN_SEQ_LEN
operator|+
operator|(
name|U32
operator|)
name|excessMatch
expr_stmt|;
name|memcpy
argument_list|(
name|srcPtr
argument_list|,
name|literals
argument_list|,
name|literalLen
argument_list|)
expr_stmt|;
name|srcPtr
operator|+=
name|literalLen
expr_stmt|;
do|do
block|{
if|if
condition|(
name|RAND
argument_list|(
name|seed
argument_list|)
operator|&
literal|7
condition|)
block|{
comment|/* do a normal offset */
name|offset
operator|=
operator|(
name|RAND
argument_list|(
name|seed
argument_list|)
operator|%
name|MIN
argument_list|(
name|frame
operator|->
name|header
operator|.
name|windowSize
argument_list|,
call|(
name|size_t
call|)
argument_list|(
operator|(
name|BYTE
operator|*
operator|)
name|srcPtr
operator|-
operator|(
name|BYTE
operator|*
operator|)
name|frame
operator|->
name|srcStart
argument_list|)
argument_list|)
operator|)
operator|+
literal|1
expr_stmt|;
name|offsetCode
operator|=
name|offset
operator|+
name|ZSTD_REP_MOVE
expr_stmt|;
name|repIndex
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* do a repeat offset */
name|offsetCode
operator|=
name|RAND
argument_list|(
name|seed
argument_list|)
operator|%
literal|3
expr_stmt|;
if|if
condition|(
name|literalLen
operator|>
literal|0
condition|)
block|{
name|offset
operator|=
name|frame
operator|->
name|stats
operator|.
name|rep
index|[
name|offsetCode
index|]
expr_stmt|;
name|repIndex
operator|=
name|offsetCode
expr_stmt|;
block|}
else|else
block|{
comment|/* special case */
name|offset
operator|=
name|offsetCode
operator|==
literal|2
condition|?
name|frame
operator|->
name|stats
operator|.
name|rep
index|[
literal|0
index|]
operator|-
literal|1
else|:
name|frame
operator|->
name|stats
operator|.
name|rep
index|[
name|offsetCode
operator|+
literal|1
index|]
expr_stmt|;
name|repIndex
operator|=
name|MIN
argument_list|(
literal|2
argument_list|,
name|offsetCode
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|offset
operator|>
call|(
name|size_t
call|)
argument_list|(
operator|(
name|BYTE
operator|*
operator|)
name|srcPtr
operator|-
operator|(
name|BYTE
operator|*
operator|)
name|frame
operator|->
name|srcStart
argument_list|)
operator|||
name|offset
operator|==
literal|0
condition|)
do|;
block|{
name|size_t
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|matchLen
condition|;
name|j
operator|++
control|)
block|{
operator|*
name|srcPtr
operator|=
operator|*
operator|(
name|srcPtr
operator|-
name|offset
operator|)
expr_stmt|;
name|srcPtr
operator|++
expr_stmt|;
block|}
block|}
block|{
name|int
name|r
decl_stmt|;
for|for
control|(
name|r
operator|=
name|repIndex
init|;
name|r
operator|>
literal|0
condition|;
name|r
operator|--
control|)
block|{
name|frame
operator|->
name|stats
operator|.
name|rep
index|[
name|r
index|]
operator|=
name|frame
operator|->
name|stats
operator|.
name|rep
index|[
name|r
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|frame
operator|->
name|stats
operator|.
name|rep
index|[
literal|0
index|]
operator|=
name|offset
expr_stmt|;
block|}
name|DISPLAYLEVEL
argument_list|(
literal|6
argument_list|,
literal|"      LL: %5u OF: %5u ML: %5u"
argument_list|,
name|literalLen
argument_list|,
name|offset
argument_list|,
name|matchLen
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|7
argument_list|,
literal|" srcPos: %8u seqNb: %3u"
argument_list|,
call|(
name|U32
call|)
argument_list|(
operator|(
name|BYTE
operator|*
operator|)
name|srcPtr
operator|-
operator|(
name|BYTE
operator|*
operator|)
name|frame
operator|->
name|srcStart
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|6
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|offsetCode
operator|<
literal|3
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|7
argument_list|,
literal|"        repeat offset: %d\n"
argument_list|,
name|repIndex
argument_list|)
expr_stmt|;
block|}
comment|/* use libzstd sequence handling */
name|ZSTD_storeSeq
argument_list|(
name|seqStore
argument_list|,
name|literalLen
argument_list|,
name|literals
argument_list|,
name|offsetCode
argument_list|,
name|matchLen
operator|-
name|MINMATCH
argument_list|)
expr_stmt|;
name|literalsSize
operator|-=
name|literalLen
expr_stmt|;
name|excessMatch
operator|-=
operator|(
name|matchLen
operator|-
name|MIN_SEQ_LEN
operator|)
expr_stmt|;
name|literals
operator|+=
name|literalLen
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|srcPtr
argument_list|,
name|literals
argument_list|,
name|literalsSize
argument_list|)
expr_stmt|;
name|srcPtr
operator|+=
name|literalsSize
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|6
argument_list|,
literal|"      excess literals: %5u"
argument_list|,
operator|(
name|U32
operator|)
name|literalsSize
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|7
argument_list|,
literal|" srcPos: %8u"
argument_list|,
call|(
name|U32
call|)
argument_list|(
operator|(
name|BYTE
operator|*
operator|)
name|srcPtr
operator|-
operator|(
name|BYTE
operator|*
operator|)
name|frame
operator|->
name|srcStart
argument_list|)
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|6
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
name|numSequences
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|initSymbolSet
parameter_list|(
specifier|const
name|BYTE
modifier|*
name|symbols
parameter_list|,
name|size_t
name|len
parameter_list|,
name|BYTE
modifier|*
name|set
parameter_list|,
name|BYTE
name|maxSymbolValue
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|memset
argument_list|(
name|set
argument_list|,
literal|0
argument_list|,
operator|(
name|size_t
operator|)
name|maxSymbolValue
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|set
index|[
name|symbols
index|[
name|i
index|]
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|isSymbolSubset
parameter_list|(
specifier|const
name|BYTE
modifier|*
name|symbols
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|BYTE
modifier|*
name|set
parameter_list|,
name|BYTE
name|maxSymbolValue
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|symbols
index|[
name|i
index|]
operator|>
name|maxSymbolValue
operator|||
operator|!
name|set
index|[
name|symbols
index|[
name|i
index|]
index|]
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|writeSequences
parameter_list|(
name|U32
modifier|*
name|seed
parameter_list|,
name|frame_t
modifier|*
name|frame
parameter_list|,
name|seqStore_t
modifier|*
name|seqStorePtr
parameter_list|,
name|size_t
name|nbSeq
parameter_list|)
block|{
comment|/* This code is mostly copied from ZSTD_compressSequences in zstd_compress.c */
name|U32
name|count
index|[
name|MaxSeq
operator|+
literal|1
index|]
decl_stmt|;
name|S16
name|norm
index|[
name|MaxSeq
operator|+
literal|1
index|]
decl_stmt|;
name|FSE_CTable
modifier|*
name|CTable_LitLength
init|=
name|frame
operator|->
name|stats
operator|.
name|litlengthCTable
decl_stmt|;
name|FSE_CTable
modifier|*
name|CTable_OffsetBits
init|=
name|frame
operator|->
name|stats
operator|.
name|offcodeCTable
decl_stmt|;
name|FSE_CTable
modifier|*
name|CTable_MatchLength
init|=
name|frame
operator|->
name|stats
operator|.
name|matchlengthCTable
decl_stmt|;
name|U32
name|LLtype
decl_stmt|,
name|Offtype
decl_stmt|,
name|MLtype
decl_stmt|;
comment|/* compressed, raw or rle */
specifier|const
name|seqDef
modifier|*
specifier|const
name|sequences
init|=
name|seqStorePtr
operator|->
name|sequencesStart
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|ofCodeTable
init|=
name|seqStorePtr
operator|->
name|ofCode
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|llCodeTable
init|=
name|seqStorePtr
operator|->
name|llCode
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|mlCodeTable
init|=
name|seqStorePtr
operator|->
name|mlCode
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|oend
init|=
operator|(
name|BYTE
operator|*
operator|)
name|frame
operator|->
name|dataEnd
decl_stmt|;
name|BYTE
modifier|*
name|op
init|=
operator|(
name|BYTE
operator|*
operator|)
name|frame
operator|->
name|data
decl_stmt|;
name|BYTE
modifier|*
name|seqHead
decl_stmt|;
name|BYTE
name|scratchBuffer
index|[
literal|1
operator|<<
name|MAX
argument_list|(
name|MLFSELog
argument_list|,
name|LLFSELog
argument_list|)
index|]
decl_stmt|;
comment|/* literals compressing block removed so that can be done separately */
comment|/* Sequences Header */
if|if
condition|(
operator|(
name|oend
operator|-
name|op
operator|)
operator|<
literal|3
comment|/*max nbSeq Size*/
operator|+
literal|1
comment|/*seqHead */
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
if|if
condition|(
name|nbSeq
operator|<
literal|0x7F
condition|)
operator|*
name|op
operator|++
operator|=
operator|(
name|BYTE
operator|)
name|nbSeq
expr_stmt|;
elseif|else
if|if
condition|(
name|nbSeq
operator|<
name|LONGNBSEQ
condition|)
name|op
index|[
literal|0
index|]
operator|=
call|(
name|BYTE
call|)
argument_list|(
operator|(
name|nbSeq
operator|>>
literal|8
operator|)
operator|+
literal|0x80
argument_list|)
operator|,
name|op
index|[
literal|1
index|]
operator|=
operator|(
name|BYTE
operator|)
name|nbSeq
operator|,
name|op
operator|+=
literal|2
expr_stmt|;
else|else
name|op
index|[
literal|0
index|]
operator|=
literal|0xFF
operator|,
name|MEM_writeLE16
argument_list|(
name|op
operator|+
literal|1
argument_list|,
call|(
name|U16
call|)
argument_list|(
name|nbSeq
operator|-
name|LONGNBSEQ
argument_list|)
argument_list|)
operator|,
name|op
operator|+=
literal|3
expr_stmt|;
comment|/* seqHead : flags for FSE encoding type */
name|seqHead
operator|=
name|op
operator|++
expr_stmt|;
if|if
condition|(
name|nbSeq
operator|==
literal|0
condition|)
block|{
name|frame
operator|->
name|data
operator|=
name|op
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* convert length/distances into codes */
name|ZSTD_seqToCodes
argument_list|(
name|seqStorePtr
argument_list|)
expr_stmt|;
comment|/* CTable for Literal Lengths */
block|{
name|U32
name|max
init|=
name|MaxLL
decl_stmt|;
name|size_t
specifier|const
name|mostFrequent
init|=
name|FSE_countFast_wksp
argument_list|(
name|count
argument_list|,
operator|&
name|max
argument_list|,
name|llCodeTable
argument_list|,
name|nbSeq
argument_list|,
name|WKSP
argument_list|)
decl_stmt|;
if|if
condition|(
name|mostFrequent
operator|==
name|nbSeq
condition|)
block|{
comment|/* do RLE if we have the chance */
operator|*
name|op
operator|++
operator|=
name|llCodeTable
index|[
literal|0
index|]
expr_stmt|;
name|FSE_buildCTable_rle
argument_list|(
name|CTable_LitLength
argument_list|,
operator|(
name|BYTE
operator|)
name|max
argument_list|)
expr_stmt|;
name|LLtype
operator|=
name|set_rle
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frame
operator|->
name|stats
operator|.
name|fseInit
operator|&&
operator|!
operator|(
name|RAND
argument_list|(
name|seed
argument_list|)
operator|&
literal|3
operator|)
operator|&&
name|isSymbolSubset
argument_list|(
name|llCodeTable
argument_list|,
name|nbSeq
argument_list|,
name|frame
operator|->
name|stats
operator|.
name|litlengthSymbolSet
argument_list|,
literal|35
argument_list|)
condition|)
block|{
comment|/* maybe do repeat mode if we're allowed to */
name|LLtype
operator|=
name|set_repeat
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|RAND
argument_list|(
name|seed
argument_list|)
operator|&
literal|3
operator|)
condition|)
block|{
comment|/* maybe use the default distribution */
name|FSE_buildCTable_wksp
argument_list|(
name|CTable_LitLength
argument_list|,
name|LL_defaultNorm
argument_list|,
name|MaxLL
argument_list|,
name|LL_defaultNormLog
argument_list|,
name|scratchBuffer
argument_list|,
sizeof|sizeof
argument_list|(
name|scratchBuffer
argument_list|)
argument_list|)
expr_stmt|;
name|LLtype
operator|=
name|set_basic
expr_stmt|;
block|}
else|else
block|{
comment|/* fall back on a full table */
name|size_t
name|nbSeq_1
init|=
name|nbSeq
decl_stmt|;
specifier|const
name|U32
name|tableLog
init|=
name|FSE_optimalTableLog
argument_list|(
name|LLFSELog
argument_list|,
name|nbSeq
argument_list|,
name|max
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
index|[
name|llCodeTable
index|[
name|nbSeq
operator|-
literal|1
index|]
index|]
operator|>
literal|1
condition|)
block|{
name|count
index|[
name|llCodeTable
index|[
name|nbSeq
operator|-
literal|1
index|]
index|]
operator|--
expr_stmt|;
name|nbSeq_1
operator|--
expr_stmt|;
block|}
name|FSE_normalizeCount
argument_list|(
name|norm
argument_list|,
name|tableLog
argument_list|,
name|count
argument_list|,
name|nbSeq_1
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|{
name|size_t
specifier|const
name|NCountSize
init|=
name|FSE_writeNCount
argument_list|(
name|op
argument_list|,
name|oend
operator|-
name|op
argument_list|,
name|norm
argument_list|,
name|max
argument_list|,
name|tableLog
argument_list|)
decl_stmt|;
comment|/* overflow protected */
if|if
condition|(
name|FSE_isError
argument_list|(
name|NCountSize
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
name|op
operator|+=
name|NCountSize
expr_stmt|;
block|}
name|FSE_buildCTable_wksp
argument_list|(
name|CTable_LitLength
argument_list|,
name|norm
argument_list|,
name|max
argument_list|,
name|tableLog
argument_list|,
name|scratchBuffer
argument_list|,
sizeof|sizeof
argument_list|(
name|scratchBuffer
argument_list|)
argument_list|)
expr_stmt|;
name|LLtype
operator|=
name|set_compressed
expr_stmt|;
block|}
block|}
comment|/* CTable for Offsets */
comment|/* see Literal Lengths for descriptions of mode choices */
block|{
name|U32
name|max
init|=
name|MaxOff
decl_stmt|;
name|size_t
specifier|const
name|mostFrequent
init|=
name|FSE_countFast_wksp
argument_list|(
name|count
argument_list|,
operator|&
name|max
argument_list|,
name|ofCodeTable
argument_list|,
name|nbSeq
argument_list|,
name|WKSP
argument_list|)
decl_stmt|;
if|if
condition|(
name|mostFrequent
operator|==
name|nbSeq
condition|)
block|{
operator|*
name|op
operator|++
operator|=
name|ofCodeTable
index|[
literal|0
index|]
expr_stmt|;
name|FSE_buildCTable_rle
argument_list|(
name|CTable_OffsetBits
argument_list|,
operator|(
name|BYTE
operator|)
name|max
argument_list|)
expr_stmt|;
name|Offtype
operator|=
name|set_rle
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frame
operator|->
name|stats
operator|.
name|fseInit
operator|&&
operator|!
operator|(
name|RAND
argument_list|(
name|seed
argument_list|)
operator|&
literal|3
operator|)
operator|&&
name|isSymbolSubset
argument_list|(
name|ofCodeTable
argument_list|,
name|nbSeq
argument_list|,
name|frame
operator|->
name|stats
operator|.
name|offsetSymbolSet
argument_list|,
literal|28
argument_list|)
condition|)
block|{
name|Offtype
operator|=
name|set_repeat
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|RAND
argument_list|(
name|seed
argument_list|)
operator|&
literal|3
operator|)
condition|)
block|{
name|FSE_buildCTable_wksp
argument_list|(
name|CTable_OffsetBits
argument_list|,
name|OF_defaultNorm
argument_list|,
name|MaxOff
argument_list|,
name|OF_defaultNormLog
argument_list|,
name|scratchBuffer
argument_list|,
sizeof|sizeof
argument_list|(
name|scratchBuffer
argument_list|)
argument_list|)
expr_stmt|;
name|Offtype
operator|=
name|set_basic
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|nbSeq_1
init|=
name|nbSeq
decl_stmt|;
specifier|const
name|U32
name|tableLog
init|=
name|FSE_optimalTableLog
argument_list|(
name|OffFSELog
argument_list|,
name|nbSeq
argument_list|,
name|max
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
index|[
name|ofCodeTable
index|[
name|nbSeq
operator|-
literal|1
index|]
index|]
operator|>
literal|1
condition|)
block|{
name|count
index|[
name|ofCodeTable
index|[
name|nbSeq
operator|-
literal|1
index|]
index|]
operator|--
expr_stmt|;
name|nbSeq_1
operator|--
expr_stmt|;
block|}
name|FSE_normalizeCount
argument_list|(
name|norm
argument_list|,
name|tableLog
argument_list|,
name|count
argument_list|,
name|nbSeq_1
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|{
name|size_t
specifier|const
name|NCountSize
init|=
name|FSE_writeNCount
argument_list|(
name|op
argument_list|,
name|oend
operator|-
name|op
argument_list|,
name|norm
argument_list|,
name|max
argument_list|,
name|tableLog
argument_list|)
decl_stmt|;
comment|/* overflow protected */
if|if
condition|(
name|FSE_isError
argument_list|(
name|NCountSize
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
name|op
operator|+=
name|NCountSize
expr_stmt|;
block|}
name|FSE_buildCTable_wksp
argument_list|(
name|CTable_OffsetBits
argument_list|,
name|norm
argument_list|,
name|max
argument_list|,
name|tableLog
argument_list|,
name|scratchBuffer
argument_list|,
sizeof|sizeof
argument_list|(
name|scratchBuffer
argument_list|)
argument_list|)
expr_stmt|;
name|Offtype
operator|=
name|set_compressed
expr_stmt|;
block|}
block|}
comment|/* CTable for MatchLengths */
comment|/* see Literal Lengths for descriptions of mode choices */
block|{
name|U32
name|max
init|=
name|MaxML
decl_stmt|;
name|size_t
specifier|const
name|mostFrequent
init|=
name|FSE_countFast_wksp
argument_list|(
name|count
argument_list|,
operator|&
name|max
argument_list|,
name|mlCodeTable
argument_list|,
name|nbSeq
argument_list|,
name|WKSP
argument_list|)
decl_stmt|;
if|if
condition|(
name|mostFrequent
operator|==
name|nbSeq
condition|)
block|{
operator|*
name|op
operator|++
operator|=
operator|*
name|mlCodeTable
expr_stmt|;
name|FSE_buildCTable_rle
argument_list|(
name|CTable_MatchLength
argument_list|,
operator|(
name|BYTE
operator|)
name|max
argument_list|)
expr_stmt|;
name|MLtype
operator|=
name|set_rle
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frame
operator|->
name|stats
operator|.
name|fseInit
operator|&&
operator|!
operator|(
name|RAND
argument_list|(
name|seed
argument_list|)
operator|&
literal|3
operator|)
operator|&&
name|isSymbolSubset
argument_list|(
name|mlCodeTable
argument_list|,
name|nbSeq
argument_list|,
name|frame
operator|->
name|stats
operator|.
name|matchlengthSymbolSet
argument_list|,
literal|52
argument_list|)
condition|)
block|{
name|MLtype
operator|=
name|set_repeat
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|RAND
argument_list|(
name|seed
argument_list|)
operator|&
literal|3
operator|)
condition|)
block|{
comment|/* sometimes do default distribution */
name|FSE_buildCTable_wksp
argument_list|(
name|CTable_MatchLength
argument_list|,
name|ML_defaultNorm
argument_list|,
name|MaxML
argument_list|,
name|ML_defaultNormLog
argument_list|,
name|scratchBuffer
argument_list|,
sizeof|sizeof
argument_list|(
name|scratchBuffer
argument_list|)
argument_list|)
expr_stmt|;
name|MLtype
operator|=
name|set_basic
expr_stmt|;
block|}
else|else
block|{
comment|/* fall back on table */
name|size_t
name|nbSeq_1
init|=
name|nbSeq
decl_stmt|;
specifier|const
name|U32
name|tableLog
init|=
name|FSE_optimalTableLog
argument_list|(
name|MLFSELog
argument_list|,
name|nbSeq
argument_list|,
name|max
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
index|[
name|mlCodeTable
index|[
name|nbSeq
operator|-
literal|1
index|]
index|]
operator|>
literal|1
condition|)
block|{
name|count
index|[
name|mlCodeTable
index|[
name|nbSeq
operator|-
literal|1
index|]
index|]
operator|--
expr_stmt|;
name|nbSeq_1
operator|--
expr_stmt|;
block|}
name|FSE_normalizeCount
argument_list|(
name|norm
argument_list|,
name|tableLog
argument_list|,
name|count
argument_list|,
name|nbSeq_1
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|{
name|size_t
specifier|const
name|NCountSize
init|=
name|FSE_writeNCount
argument_list|(
name|op
argument_list|,
name|oend
operator|-
name|op
argument_list|,
name|norm
argument_list|,
name|max
argument_list|,
name|tableLog
argument_list|)
decl_stmt|;
comment|/* overflow protected */
if|if
condition|(
name|FSE_isError
argument_list|(
name|NCountSize
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
name|op
operator|+=
name|NCountSize
expr_stmt|;
block|}
name|FSE_buildCTable_wksp
argument_list|(
name|CTable_MatchLength
argument_list|,
name|norm
argument_list|,
name|max
argument_list|,
name|tableLog
argument_list|,
name|scratchBuffer
argument_list|,
sizeof|sizeof
argument_list|(
name|scratchBuffer
argument_list|)
argument_list|)
expr_stmt|;
name|MLtype
operator|=
name|set_compressed
expr_stmt|;
block|}
block|}
name|frame
operator|->
name|stats
operator|.
name|fseInit
operator|=
literal|1
expr_stmt|;
name|initSymbolSet
argument_list|(
name|llCodeTable
argument_list|,
name|nbSeq
argument_list|,
name|frame
operator|->
name|stats
operator|.
name|litlengthSymbolSet
argument_list|,
literal|35
argument_list|)
expr_stmt|;
name|initSymbolSet
argument_list|(
name|ofCodeTable
argument_list|,
name|nbSeq
argument_list|,
name|frame
operator|->
name|stats
operator|.
name|offsetSymbolSet
argument_list|,
literal|28
argument_list|)
expr_stmt|;
name|initSymbolSet
argument_list|(
name|mlCodeTable
argument_list|,
name|nbSeq
argument_list|,
name|frame
operator|->
name|stats
operator|.
name|matchlengthSymbolSet
argument_list|,
literal|52
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|5
argument_list|,
literal|"    LL type: %d OF type: %d ML type: %d\n"
argument_list|,
name|LLtype
argument_list|,
name|Offtype
argument_list|,
name|MLtype
argument_list|)
expr_stmt|;
operator|*
name|seqHead
operator|=
call|(
name|BYTE
call|)
argument_list|(
operator|(
name|LLtype
operator|<<
literal|6
operator|)
operator|+
operator|(
name|Offtype
operator|<<
literal|4
operator|)
operator|+
operator|(
name|MLtype
operator|<<
literal|2
operator|)
argument_list|)
expr_stmt|;
comment|/* Encoding Sequences */
block|{
name|BIT_CStream_t
name|blockStream
decl_stmt|;
name|FSE_CState_t
name|stateMatchLength
decl_stmt|;
name|FSE_CState_t
name|stateOffsetBits
decl_stmt|;
name|FSE_CState_t
name|stateLitLength
decl_stmt|;
name|CHECK_E
argument_list|(
name|BIT_initCStream
argument_list|(
operator|&
name|blockStream
argument_list|,
name|op
argument_list|,
name|oend
operator|-
name|op
argument_list|)
argument_list|,
name|dstSize_tooSmall
argument_list|)
expr_stmt|;
comment|/* not enough space remaining */
comment|/* first symbols */
name|FSE_initCState2
argument_list|(
operator|&
name|stateMatchLength
argument_list|,
name|CTable_MatchLength
argument_list|,
name|mlCodeTable
index|[
name|nbSeq
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|FSE_initCState2
argument_list|(
operator|&
name|stateOffsetBits
argument_list|,
name|CTable_OffsetBits
argument_list|,
name|ofCodeTable
index|[
name|nbSeq
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|FSE_initCState2
argument_list|(
operator|&
name|stateLitLength
argument_list|,
name|CTable_LitLength
argument_list|,
name|llCodeTable
index|[
name|nbSeq
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|BIT_addBits
argument_list|(
operator|&
name|blockStream
argument_list|,
name|sequences
index|[
name|nbSeq
operator|-
literal|1
index|]
operator|.
name|litLength
argument_list|,
name|LL_bits
index|[
name|llCodeTable
index|[
name|nbSeq
operator|-
literal|1
index|]
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|MEM_32bits
argument_list|()
condition|)
name|BIT_flushBits
argument_list|(
operator|&
name|blockStream
argument_list|)
expr_stmt|;
name|BIT_addBits
argument_list|(
operator|&
name|blockStream
argument_list|,
name|sequences
index|[
name|nbSeq
operator|-
literal|1
index|]
operator|.
name|matchLength
argument_list|,
name|ML_bits
index|[
name|mlCodeTable
index|[
name|nbSeq
operator|-
literal|1
index|]
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|MEM_32bits
argument_list|()
condition|)
name|BIT_flushBits
argument_list|(
operator|&
name|blockStream
argument_list|)
expr_stmt|;
name|BIT_addBits
argument_list|(
operator|&
name|blockStream
argument_list|,
name|sequences
index|[
name|nbSeq
operator|-
literal|1
index|]
operator|.
name|offset
argument_list|,
name|ofCodeTable
index|[
name|nbSeq
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|BIT_flushBits
argument_list|(
operator|&
name|blockStream
argument_list|)
expr_stmt|;
block|{
name|size_t
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
name|nbSeq
operator|-
literal|2
init|;
name|n
operator|<
name|nbSeq
condition|;
name|n
operator|--
control|)
block|{
comment|/* intentional underflow */
name|BYTE
specifier|const
name|llCode
init|=
name|llCodeTable
index|[
name|n
index|]
decl_stmt|;
name|BYTE
specifier|const
name|ofCode
init|=
name|ofCodeTable
index|[
name|n
index|]
decl_stmt|;
name|BYTE
specifier|const
name|mlCode
init|=
name|mlCodeTable
index|[
name|n
index|]
decl_stmt|;
name|U32
specifier|const
name|llBits
init|=
name|LL_bits
index|[
name|llCode
index|]
decl_stmt|;
name|U32
specifier|const
name|ofBits
init|=
name|ofCode
decl_stmt|;
comment|/* 32b*/
comment|/* 64b*/
name|U32
specifier|const
name|mlBits
init|=
name|ML_bits
index|[
name|mlCode
index|]
decl_stmt|;
comment|/* (7)*/
comment|/* (7)*/
name|FSE_encodeSymbol
argument_list|(
operator|&
name|blockStream
argument_list|,
operator|&
name|stateOffsetBits
argument_list|,
name|ofCode
argument_list|)
expr_stmt|;
comment|/* 15 */
comment|/* 15 */
name|FSE_encodeSymbol
argument_list|(
operator|&
name|blockStream
argument_list|,
operator|&
name|stateMatchLength
argument_list|,
name|mlCode
argument_list|)
expr_stmt|;
comment|/* 24 */
comment|/* 24 */
if|if
condition|(
name|MEM_32bits
argument_list|()
condition|)
name|BIT_flushBits
argument_list|(
operator|&
name|blockStream
argument_list|)
expr_stmt|;
comment|/* (7)*/
name|FSE_encodeSymbol
argument_list|(
operator|&
name|blockStream
argument_list|,
operator|&
name|stateLitLength
argument_list|,
name|llCode
argument_list|)
expr_stmt|;
comment|/* 16 */
comment|/* 33 */
if|if
condition|(
name|MEM_32bits
argument_list|()
operator|||
operator|(
name|ofBits
operator|+
name|mlBits
operator|+
name|llBits
operator|>=
literal|64
operator|-
literal|7
operator|-
operator|(
name|LLFSELog
operator|+
name|MLFSELog
operator|+
name|OffFSELog
operator|)
operator|)
condition|)
name|BIT_flushBits
argument_list|(
operator|&
name|blockStream
argument_list|)
expr_stmt|;
comment|/* (7)*/
name|BIT_addBits
argument_list|(
operator|&
name|blockStream
argument_list|,
name|sequences
index|[
name|n
index|]
operator|.
name|litLength
argument_list|,
name|llBits
argument_list|)
expr_stmt|;
if|if
condition|(
name|MEM_32bits
argument_list|()
operator|&&
operator|(
operator|(
name|llBits
operator|+
name|mlBits
operator|)
operator|>
literal|24
operator|)
condition|)
name|BIT_flushBits
argument_list|(
operator|&
name|blockStream
argument_list|)
expr_stmt|;
name|BIT_addBits
argument_list|(
operator|&
name|blockStream
argument_list|,
name|sequences
index|[
name|n
index|]
operator|.
name|matchLength
argument_list|,
name|mlBits
argument_list|)
expr_stmt|;
if|if
condition|(
name|MEM_32bits
argument_list|()
condition|)
name|BIT_flushBits
argument_list|(
operator|&
name|blockStream
argument_list|)
expr_stmt|;
comment|/* (7)*/
name|BIT_addBits
argument_list|(
operator|&
name|blockStream
argument_list|,
name|sequences
index|[
name|n
index|]
operator|.
name|offset
argument_list|,
name|ofBits
argument_list|)
expr_stmt|;
comment|/* 31 */
name|BIT_flushBits
argument_list|(
operator|&
name|blockStream
argument_list|)
expr_stmt|;
comment|/* (7)*/
block|}
block|}
name|FSE_flushCState
argument_list|(
operator|&
name|blockStream
argument_list|,
operator|&
name|stateMatchLength
argument_list|)
expr_stmt|;
name|FSE_flushCState
argument_list|(
operator|&
name|blockStream
argument_list|,
operator|&
name|stateOffsetBits
argument_list|)
expr_stmt|;
name|FSE_flushCState
argument_list|(
operator|&
name|blockStream
argument_list|,
operator|&
name|stateLitLength
argument_list|)
expr_stmt|;
block|{
name|size_t
specifier|const
name|streamSize
init|=
name|BIT_closeCStream
argument_list|(
operator|&
name|blockStream
argument_list|)
decl_stmt|;
if|if
condition|(
name|streamSize
operator|==
literal|0
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
comment|/* not enough space */
name|op
operator|+=
name|streamSize
expr_stmt|;
block|}
block|}
name|frame
operator|->
name|data
operator|=
name|op
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|writeSequencesBlock
parameter_list|(
name|U32
modifier|*
name|seed
parameter_list|,
name|frame_t
modifier|*
name|frame
parameter_list|,
name|size_t
name|contentSize
parameter_list|,
name|size_t
name|literalsSize
parameter_list|)
block|{
name|seqStore_t
name|seqStore
decl_stmt|;
name|size_t
name|numSequences
decl_stmt|;
name|initSeqStore
argument_list|(
operator|&
name|seqStore
argument_list|)
expr_stmt|;
comment|/* randomly generate sequences */
name|numSequences
operator|=
name|generateSequences
argument_list|(
name|seed
argument_list|,
name|frame
argument_list|,
operator|&
name|seqStore
argument_list|,
name|contentSize
argument_list|,
name|literalsSize
argument_list|)
expr_stmt|;
comment|/* write them out to the frame data */
name|CHECKERR
argument_list|(
name|writeSequences
argument_list|(
name|seed
argument_list|,
name|frame
argument_list|,
operator|&
name|seqStore
argument_list|,
name|numSequences
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|numSequences
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|writeCompressedBlock
parameter_list|(
name|U32
modifier|*
name|seed
parameter_list|,
name|frame_t
modifier|*
name|frame
parameter_list|,
name|size_t
name|contentSize
parameter_list|)
block|{
name|BYTE
modifier|*
specifier|const
name|blockStart
init|=
operator|(
name|BYTE
operator|*
operator|)
name|frame
operator|->
name|data
decl_stmt|;
name|size_t
name|literalsSize
decl_stmt|;
name|size_t
name|nbSeq
decl_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|4
argument_list|,
literal|"  compressed block:\n"
argument_list|)
expr_stmt|;
name|literalsSize
operator|=
name|writeLiteralsBlock
argument_list|(
name|seed
argument_list|,
name|frame
argument_list|,
name|contentSize
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|4
argument_list|,
literal|"   literals size: %u\n"
argument_list|,
operator|(
name|U32
operator|)
name|literalsSize
argument_list|)
expr_stmt|;
name|nbSeq
operator|=
name|writeSequencesBlock
argument_list|(
name|seed
argument_list|,
name|frame
argument_list|,
name|contentSize
argument_list|,
name|literalsSize
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|4
argument_list|,
literal|"   number of sequences: %u\n"
argument_list|,
operator|(
name|U32
operator|)
name|nbSeq
argument_list|)
expr_stmt|;
return|return
operator|(
name|BYTE
operator|*
operator|)
name|frame
operator|->
name|data
operator|-
name|blockStart
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|writeBlock
parameter_list|(
name|U32
modifier|*
name|seed
parameter_list|,
name|frame_t
modifier|*
name|frame
parameter_list|,
name|size_t
name|contentSize
parameter_list|,
name|int
name|lastBlock
parameter_list|)
block|{
name|int
specifier|const
name|blockTypeDesc
init|=
name|RAND
argument_list|(
name|seed
argument_list|)
operator|%
literal|8
decl_stmt|;
name|size_t
name|blockSize
decl_stmt|;
name|int
name|blockType
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|header
init|=
operator|(
name|BYTE
operator|*
operator|)
name|frame
operator|->
name|data
decl_stmt|;
name|BYTE
modifier|*
name|op
init|=
name|header
operator|+
literal|3
decl_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|3
argument_list|,
literal|" block:\n"
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|3
argument_list|,
literal|"  block content size: %u\n"
argument_list|,
operator|(
name|U32
operator|)
name|contentSize
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|3
argument_list|,
literal|"  last block: %s\n"
argument_list|,
name|lastBlock
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
if|if
condition|(
name|blockTypeDesc
operator|==
literal|0
condition|)
block|{
comment|/* Raw data frame */
name|RAND_buffer
argument_list|(
name|seed
argument_list|,
name|frame
operator|->
name|src
argument_list|,
name|contentSize
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|op
argument_list|,
name|frame
operator|->
name|src
argument_list|,
name|contentSize
argument_list|)
expr_stmt|;
name|op
operator|+=
name|contentSize
expr_stmt|;
name|blockType
operator|=
literal|0
expr_stmt|;
name|blockSize
operator|=
name|contentSize
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|blockTypeDesc
operator|==
literal|1
condition|)
block|{
comment|/* RLE */
name|BYTE
specifier|const
name|symbol
init|=
name|RAND
argument_list|(
name|seed
argument_list|)
operator|&
literal|0xff
decl_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|symbol
expr_stmt|;
name|memset
argument_list|(
name|frame
operator|->
name|src
argument_list|,
name|symbol
argument_list|,
name|contentSize
argument_list|)
expr_stmt|;
name|op
operator|++
expr_stmt|;
name|blockType
operator|=
literal|1
expr_stmt|;
name|blockSize
operator|=
name|contentSize
expr_stmt|;
block|}
else|else
block|{
comment|/* compressed, most common */
name|size_t
name|compressedSize
decl_stmt|;
name|blockType
operator|=
literal|2
expr_stmt|;
name|frame
operator|->
name|oldStats
operator|=
name|frame
operator|->
name|stats
expr_stmt|;
name|frame
operator|->
name|data
operator|=
name|op
expr_stmt|;
name|compressedSize
operator|=
name|writeCompressedBlock
argument_list|(
name|seed
argument_list|,
name|frame
argument_list|,
name|contentSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|compressedSize
operator|>
name|contentSize
condition|)
block|{
name|blockType
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
name|op
argument_list|,
name|frame
operator|->
name|src
argument_list|,
name|contentSize
argument_list|)
expr_stmt|;
name|op
operator|+=
name|contentSize
expr_stmt|;
name|blockSize
operator|=
name|contentSize
expr_stmt|;
comment|/* fall back on raw block if data doesn't                                         compress */
name|frame
operator|->
name|stats
operator|=
name|frame
operator|->
name|oldStats
expr_stmt|;
comment|/* don't update the stats */
block|}
else|else
block|{
name|op
operator|+=
name|compressedSize
expr_stmt|;
name|blockSize
operator|=
name|compressedSize
expr_stmt|;
block|}
block|}
name|frame
operator|->
name|src
operator|=
operator|(
name|BYTE
operator|*
operator|)
name|frame
operator|->
name|src
operator|+
name|contentSize
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|3
argument_list|,
literal|"  block type: %s\n"
argument_list|,
name|BLOCK_TYPES
index|[
name|blockType
index|]
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|3
argument_list|,
literal|"  block size field: %u\n"
argument_list|,
operator|(
name|U32
operator|)
name|blockSize
argument_list|)
expr_stmt|;
name|header
index|[
literal|0
index|]
operator|=
call|(
name|BYTE
call|)
argument_list|(
operator|(
name|lastBlock
operator||
operator|(
name|blockType
operator|<<
literal|1
operator|)
operator||
operator|(
name|blockSize
operator|<<
literal|3
operator|)
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|MEM_writeLE16
argument_list|(
name|header
operator|+
literal|1
argument_list|,
call|(
name|U16
call|)
argument_list|(
name|blockSize
operator|>>
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|frame
operator|->
name|data
operator|=
name|op
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|writeBlocks
parameter_list|(
name|U32
modifier|*
name|seed
parameter_list|,
name|frame_t
modifier|*
name|frame
parameter_list|)
block|{
name|size_t
name|contentLeft
init|=
name|frame
operator|->
name|header
operator|.
name|contentSize
decl_stmt|;
name|size_t
specifier|const
name|maxBlockSize
init|=
name|MIN
argument_list|(
name|MAX_BLOCK_SIZE
argument_list|,
name|frame
operator|->
name|header
operator|.
name|windowSize
argument_list|)
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* 1 in 4 chance of ending frame */
name|int
specifier|const
name|lastBlock
init|=
name|contentLeft
operator|>
name|maxBlockSize
condition|?
literal|0
else|:
operator|!
operator|(
name|RAND
argument_list|(
name|seed
argument_list|)
operator|&
literal|3
operator|)
decl_stmt|;
name|size_t
name|blockContentSize
decl_stmt|;
if|if
condition|(
name|lastBlock
condition|)
block|{
name|blockContentSize
operator|=
name|contentLeft
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|contentLeft
operator|>
literal|0
operator|&&
operator|(
name|RAND
argument_list|(
name|seed
argument_list|)
operator|&
literal|7
operator|)
condition|)
block|{
comment|/* some variable size blocks */
name|blockContentSize
operator|=
name|RAND
argument_list|(
name|seed
argument_list|)
operator|%
operator|(
name|MIN
argument_list|(
name|maxBlockSize
argument_list|,
name|contentLeft
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|contentLeft
operator|>
name|maxBlockSize
operator|&&
operator|(
name|RAND
argument_list|(
name|seed
argument_list|)
operator|&
literal|1
operator|)
condition|)
block|{
comment|/* some full size blocks */
name|blockContentSize
operator|=
name|maxBlockSize
expr_stmt|;
block|}
else|else
block|{
comment|/* some empty blocks */
name|blockContentSize
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|writeBlock
argument_list|(
name|seed
argument_list|,
name|frame
argument_list|,
name|blockContentSize
argument_list|,
name|lastBlock
argument_list|)
expr_stmt|;
name|contentLeft
operator|-=
name|blockContentSize
expr_stmt|;
if|if
condition|(
name|lastBlock
condition|)
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|writeChecksum
parameter_list|(
name|frame_t
modifier|*
name|frame
parameter_list|)
block|{
comment|/* write checksum so implementations can verify their output */
name|U64
name|digest
init|=
name|XXH64
argument_list|(
name|frame
operator|->
name|srcStart
argument_list|,
operator|(
name|BYTE
operator|*
operator|)
name|frame
operator|->
name|src
operator|-
operator|(
name|BYTE
operator|*
operator|)
name|frame
operator|->
name|srcStart
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"  checksum: %08x\n"
argument_list|,
operator|(
name|U32
operator|)
name|digest
argument_list|)
expr_stmt|;
name|MEM_writeLE32
argument_list|(
name|frame
operator|->
name|data
argument_list|,
operator|(
name|U32
operator|)
name|digest
argument_list|)
expr_stmt|;
name|frame
operator|->
name|data
operator|=
operator|(
name|BYTE
operator|*
operator|)
name|frame
operator|->
name|data
operator|+
literal|4
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|outputBuffer
parameter_list|(
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
name|path
parameter_list|)
block|{
comment|/* write data out to file */
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|buf
decl_stmt|;
name|FILE
modifier|*
name|out
decl_stmt|;
if|if
condition|(
name|path
condition|)
block|{
name|out
operator|=
name|fopen
argument_list|(
name|path
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|=
name|stdout
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|out
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Failed to open file at %s: "
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|{
name|size_t
name|fsize
init|=
name|size
decl_stmt|;
name|size_t
name|written
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|written
operator|<
name|fsize
condition|)
block|{
name|written
operator|+=
name|fwrite
argument_list|(
name|ip
operator|+
name|written
argument_list|,
literal|1
argument_list|,
name|fsize
operator|-
name|written
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|out
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Failed to write to file at %s: "
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|path
condition|)
block|{
name|fclose
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|initFrame
parameter_list|(
name|frame_t
modifier|*
name|fr
parameter_list|)
block|{
name|memset
argument_list|(
name|fr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fr
argument_list|)
argument_list|)
expr_stmt|;
name|fr
operator|->
name|data
operator|=
name|fr
operator|->
name|dataStart
operator|=
name|FRAME_BUFFER
expr_stmt|;
name|fr
operator|->
name|dataEnd
operator|=
name|FRAME_BUFFER
operator|+
sizeof|sizeof
argument_list|(
name|FRAME_BUFFER
argument_list|)
expr_stmt|;
name|fr
operator|->
name|src
operator|=
name|fr
operator|->
name|srcStart
operator|=
name|CONTENT_BUFFER
expr_stmt|;
name|fr
operator|->
name|srcEnd
operator|=
name|CONTENT_BUFFER
operator|+
sizeof|sizeof
argument_list|(
name|CONTENT_BUFFER
argument_list|)
expr_stmt|;
comment|/* init repeat codes */
name|fr
operator|->
name|stats
operator|.
name|rep
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|fr
operator|->
name|stats
operator|.
name|rep
index|[
literal|1
index|]
operator|=
literal|4
expr_stmt|;
name|fr
operator|->
name|stats
operator|.
name|rep
index|[
literal|2
index|]
operator|=
literal|8
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the final seed */
end_comment

begin_function
specifier|static
name|U32
name|generateFrame
parameter_list|(
name|U32
name|seed
parameter_list|,
name|frame_t
modifier|*
name|fr
parameter_list|)
block|{
comment|/* generate a complete frame */
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"frame seed: %u\n"
argument_list|,
name|seed
argument_list|)
expr_stmt|;
name|initFrame
argument_list|(
name|fr
argument_list|)
expr_stmt|;
name|writeFrameHeader
argument_list|(
operator|&
name|seed
argument_list|,
name|fr
argument_list|)
expr_stmt|;
name|writeBlocks
argument_list|(
operator|&
name|seed
argument_list|,
name|fr
argument_list|)
expr_stmt|;
name|writeChecksum
argument_list|(
name|fr
argument_list|)
expr_stmt|;
return|return
name|seed
return|;
block|}
end_function

begin_comment
comment|/*-******************************************************* *  Test Mode *********************************************************/
end_comment

begin_decl_stmt
name|BYTE
name|DECOMPRESSED_BUFFER
index|[
name|MAX_DECOMPRESSED_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|size_t
name|testDecodeSimple
parameter_list|(
name|frame_t
modifier|*
name|fr
parameter_list|)
block|{
comment|/* test decoding the generated data with the simple API */
name|size_t
specifier|const
name|ret
init|=
name|ZSTD_decompress
argument_list|(
name|DECOMPRESSED_BUFFER
argument_list|,
name|MAX_DECOMPRESSED_SIZE
argument_list|,
name|fr
operator|->
name|dataStart
argument_list|,
operator|(
name|BYTE
operator|*
operator|)
name|fr
operator|->
name|data
operator|-
operator|(
name|BYTE
operator|*
operator|)
name|fr
operator|->
name|dataStart
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|ret
argument_list|)
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|memcmp
argument_list|(
name|DECOMPRESSED_BUFFER
argument_list|,
name|fr
operator|->
name|srcStart
argument_list|,
operator|(
name|BYTE
operator|*
operator|)
name|fr
operator|->
name|src
operator|-
operator|(
name|BYTE
operator|*
operator|)
name|fr
operator|->
name|srcStart
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|testDecodeStreaming
parameter_list|(
name|frame_t
modifier|*
name|fr
parameter_list|)
block|{
comment|/* test decoding the generated data with the streaming API */
name|ZSTD_DStream
modifier|*
name|zd
init|=
name|ZSTD_createDStream
argument_list|()
decl_stmt|;
name|ZSTD_inBuffer
name|in
decl_stmt|;
name|ZSTD_outBuffer
name|out
decl_stmt|;
name|size_t
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|zd
condition|)
return|return
name|ERROR
argument_list|(
name|memory_allocation
argument_list|)
return|;
name|in
operator|.
name|src
operator|=
name|fr
operator|->
name|dataStart
expr_stmt|;
name|in
operator|.
name|pos
operator|=
literal|0
expr_stmt|;
name|in
operator|.
name|size
operator|=
operator|(
name|BYTE
operator|*
operator|)
name|fr
operator|->
name|data
operator|-
operator|(
name|BYTE
operator|*
operator|)
name|fr
operator|->
name|dataStart
expr_stmt|;
name|out
operator|.
name|dst
operator|=
name|DECOMPRESSED_BUFFER
expr_stmt|;
name|out
operator|.
name|pos
operator|=
literal|0
expr_stmt|;
name|out
operator|.
name|size
operator|=
name|ZSTD_DStreamOutSize
argument_list|()
expr_stmt|;
name|ZSTD_initDStream
argument_list|(
name|zd
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|ret
operator|=
name|ZSTD_decompressStream
argument_list|(
name|zd
argument_list|,
operator|&
name|out
argument_list|,
operator|&
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|ret
argument_list|)
condition|)
goto|goto
name|cleanup
goto|;
comment|/* error */
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
break|break;
comment|/* frame is done */
comment|/* force decoding to be done in chunks */
name|out
operator|.
name|size
operator|+=
name|MIN
argument_list|(
name|ZSTD_DStreamOutSize
argument_list|()
argument_list|,
name|MAX_DECOMPRESSED_SIZE
operator|-
name|out
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|out
operator|.
name|pos
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|out
operator|.
name|dst
argument_list|,
name|fr
operator|->
name|srcStart
argument_list|,
name|out
operator|.
name|pos
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
block|}
name|cleanup
label|:
name|ZSTD_freeDStream
argument_list|(
name|zd
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|runTestMode
parameter_list|(
name|U32
name|seed
parameter_list|,
name|unsigned
name|numFiles
parameter_list|,
name|unsigned
specifier|const
name|testDurationS
parameter_list|)
block|{
name|unsigned
name|fnum
decl_stmt|;
name|clock_t
specifier|const
name|startClock
init|=
name|clock
argument_list|()
decl_stmt|;
name|clock_t
specifier|const
name|maxClockSpan
init|=
name|testDurationS
operator|*
name|CLOCKS_PER_SEC
decl_stmt|;
if|if
condition|(
name|numFiles
operator|==
literal|0
operator|&&
operator|!
name|testDurationS
condition|)
name|numFiles
operator|=
literal|1
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"seed: %u\n"
argument_list|,
name|seed
argument_list|)
expr_stmt|;
for|for
control|(
name|fnum
operator|=
literal|0
init|;
name|fnum
operator|<
name|numFiles
operator|||
name|clockSpan
argument_list|(
name|startClock
argument_list|)
operator|<
name|maxClockSpan
condition|;
name|fnum
operator|++
control|)
block|{
name|frame_t
name|fr
decl_stmt|;
if|if
condition|(
name|fnum
operator|<
name|numFiles
condition|)
name|DISPLAYUPDATE
argument_list|(
literal|"\r%u/%u        "
argument_list|,
name|fnum
argument_list|,
name|numFiles
argument_list|)
expr_stmt|;
else|else
name|DISPLAYUPDATE
argument_list|(
literal|"\r%u           "
argument_list|,
name|fnum
argument_list|)
expr_stmt|;
name|seed
operator|=
name|generateFrame
argument_list|(
name|seed
argument_list|,
operator|&
name|fr
argument_list|)
expr_stmt|;
block|{
name|size_t
specifier|const
name|r
init|=
name|testDecodeSimple
argument_list|(
operator|&
name|fr
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|DISPLAY
argument_list|(
literal|"Error in simple mode on test seed %u: %s\n"
argument_list|,
name|seed
operator|+
name|fnum
argument_list|,
name|ZSTD_getErrorName
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|{
name|size_t
specifier|const
name|r
init|=
name|testDecodeStreaming
argument_list|(
operator|&
name|fr
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|DISPLAY
argument_list|(
literal|"Error in streaming mode on test seed %u: %s\n"
argument_list|,
name|seed
operator|+
name|fnum
argument_list|,
name|ZSTD_getErrorName
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
name|DISPLAY
argument_list|(
literal|"\r%u tests completed: "
argument_list|,
name|fnum
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"OK\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*-******************************************************* *  File I/O *********************************************************/
end_comment

begin_function
specifier|static
name|int
name|generateFile
parameter_list|(
name|U32
name|seed
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
name|path
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
name|origPath
parameter_list|)
block|{
name|frame_t
name|fr
decl_stmt|;
name|DISPLAY
argument_list|(
literal|"seed: %u\n"
argument_list|,
name|seed
argument_list|)
expr_stmt|;
name|generateFrame
argument_list|(
name|seed
argument_list|,
operator|&
name|fr
argument_list|)
expr_stmt|;
name|outputBuffer
argument_list|(
name|fr
operator|.
name|dataStart
argument_list|,
operator|(
name|BYTE
operator|*
operator|)
name|fr
operator|.
name|data
operator|-
operator|(
name|BYTE
operator|*
operator|)
name|fr
operator|.
name|dataStart
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|origPath
condition|)
block|{
name|outputBuffer
argument_list|(
name|fr
operator|.
name|srcStart
argument_list|,
operator|(
name|BYTE
operator|*
operator|)
name|fr
operator|.
name|src
operator|-
operator|(
name|BYTE
operator|*
operator|)
name|fr
operator|.
name|srcStart
argument_list|,
name|origPath
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|generateCorpus
parameter_list|(
name|U32
name|seed
parameter_list|,
name|unsigned
name|numFiles
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
name|path
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
name|origPath
parameter_list|)
block|{
name|char
name|outPath
index|[
name|MAX_PATH
index|]
decl_stmt|;
name|unsigned
name|fnum
decl_stmt|;
name|DISPLAY
argument_list|(
literal|"seed: %u\n"
argument_list|,
name|seed
argument_list|)
expr_stmt|;
for|for
control|(
name|fnum
operator|=
literal|0
init|;
name|fnum
operator|<
name|numFiles
condition|;
name|fnum
operator|++
control|)
block|{
name|frame_t
name|fr
decl_stmt|;
name|DISPLAYUPDATE
argument_list|(
literal|"\r%u/%u        "
argument_list|,
name|fnum
argument_list|,
name|numFiles
argument_list|)
expr_stmt|;
name|seed
operator|=
name|generateFrame
argument_list|(
name|seed
argument_list|,
operator|&
name|fr
argument_list|)
expr_stmt|;
if|if
condition|(
name|snprintf
argument_list|(
name|outPath
argument_list|,
name|MAX_PATH
argument_list|,
literal|"%s/z%06u.zst"
argument_list|,
name|path
argument_list|,
name|fnum
argument_list|)
operator|+
literal|1
operator|>
name|MAX_PATH
condition|)
block|{
name|DISPLAY
argument_list|(
literal|"Error: path too long\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|outputBuffer
argument_list|(
name|fr
operator|.
name|dataStart
argument_list|,
operator|(
name|BYTE
operator|*
operator|)
name|fr
operator|.
name|data
operator|-
operator|(
name|BYTE
operator|*
operator|)
name|fr
operator|.
name|dataStart
argument_list|,
name|outPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|origPath
condition|)
block|{
if|if
condition|(
name|snprintf
argument_list|(
name|outPath
argument_list|,
name|MAX_PATH
argument_list|,
literal|"%s/z%06u"
argument_list|,
name|origPath
argument_list|,
name|fnum
argument_list|)
operator|+
literal|1
operator|>
name|MAX_PATH
condition|)
block|{
name|DISPLAY
argument_list|(
literal|"Error: path too long\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|outputBuffer
argument_list|(
name|fr
operator|.
name|srcStart
argument_list|,
operator|(
name|BYTE
operator|*
operator|)
name|fr
operator|.
name|src
operator|-
operator|(
name|BYTE
operator|*
operator|)
name|fr
operator|.
name|srcStart
argument_list|,
name|outPath
argument_list|)
expr_stmt|;
block|}
block|}
name|DISPLAY
argument_list|(
literal|"\r%u/%u      \n"
argument_list|,
name|fnum
argument_list|,
name|numFiles
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*_******************************************************* *  Command line *********************************************************/
end_comment

begin_function
specifier|static
name|U32
name|makeSeed
parameter_list|(
name|void
parameter_list|)
block|{
name|U32
name|t
init|=
operator|(
name|U32
operator|)
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
return|return
name|XXH32
argument_list|(
operator|&
name|t
argument_list|,
sizeof|sizeof
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|%
literal|65536
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|readInt
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|argument
parameter_list|)
block|{
name|unsigned
name|val
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
operator|*
operator|*
name|argument
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
operator|*
name|argument
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|val
operator|*=
literal|10
expr_stmt|;
name|val
operator|+=
operator|*
operator|*
name|argument
operator|-
literal|'0'
expr_stmt|;
operator|(
operator|*
name|argument
operator|)
operator|++
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
specifier|const
name|char
modifier|*
name|programName
parameter_list|)
block|{
name|DISPLAY
argument_list|(
literal|"Usage :\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"      %s [args]\n"
argument_list|,
name|programName
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"Arguments :\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -p<path> : select output path (default:stdout)\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"                in multiple files mode this should be a directory\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -o<path> : select path to output original file (default:no output)\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"                in multiple files mode this should be a directory\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -s#      : select seed (default:random based on time)\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -n#      : number of files to generate (default:1)\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -t       : activate test mode (test files against libzstd instead of outputting them)\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -T#      : length of time to run tests for\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -v       : increase verbosity level (default:0, max:7)\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -h/H     : display help/long help and exit\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|advancedUsage
parameter_list|(
specifier|const
name|char
modifier|*
name|programName
parameter_list|)
block|{
name|usage
argument_list|(
name|programName
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"Advanced arguments :\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" --content-size    : always include the content size in the frame header\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|U32
name|seed
init|=
literal|0
decl_stmt|;
name|int
name|seedset
init|=
literal|0
decl_stmt|;
name|unsigned
name|numFiles
init|=
literal|0
decl_stmt|;
name|unsigned
name|testDuration
init|=
literal|0
decl_stmt|;
name|int
name|testMode
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|origPath
init|=
name|NULL
decl_stmt|;
name|int
name|argNb
decl_stmt|;
comment|/* Check command line */
for|for
control|(
name|argNb
operator|=
literal|1
init|;
name|argNb
operator|<
name|argc
condition|;
name|argNb
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|argument
init|=
name|argv
index|[
name|argNb
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|argument
condition|)
continue|continue;
comment|/* Protection if argument empty */
comment|/* Handle commands. Aggregated commands are allowed */
if|if
condition|(
name|argument
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|argument
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|argument
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
operator|*
name|argument
condition|)
block|{
case|case
literal|'h'
case|:
name|usage
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|'H'
case|:
name|advancedUsage
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|'v'
case|:
name|argument
operator|++
expr_stmt|;
name|g_displayLevel
operator|++
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|argument
operator|++
expr_stmt|;
name|seedset
operator|=
literal|1
expr_stmt|;
name|seed
operator|=
name|readInt
argument_list|(
operator|&
name|argument
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|argument
operator|++
expr_stmt|;
name|numFiles
operator|=
name|readInt
argument_list|(
operator|&
name|argument
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|argument
operator|++
expr_stmt|;
name|testDuration
operator|=
name|readInt
argument_list|(
operator|&
name|argument
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|argument
operator|==
literal|'m'
condition|)
block|{
name|testDuration
operator|*=
literal|60
expr_stmt|;
name|argument
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|argument
operator|==
literal|'n'
condition|)
name|argument
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'o'
case|:
name|argument
operator|++
expr_stmt|;
name|origPath
operator|=
name|argument
expr_stmt|;
name|argument
operator|+=
name|strlen
argument_list|(
name|argument
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|argument
operator|++
expr_stmt|;
name|path
operator|=
name|argument
expr_stmt|;
name|argument
operator|+=
name|strlen
argument_list|(
name|argument
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|argument
operator|++
expr_stmt|;
name|testMode
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|argument
operator|++
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|argument
argument_list|,
literal|"content-size"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|opts
operator|.
name|contentSize
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|advancedUsage
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|argument
operator|+=
name|strlen
argument_list|(
name|argument
argument_list|)
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
block|}
comment|/* for (argNb=1; argNb<argc; argNb++) */
if|if
condition|(
operator|!
name|seedset
condition|)
block|{
name|seed
operator|=
name|makeSeed
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|testMode
condition|)
block|{
return|return
name|runTestMode
argument_list|(
name|seed
argument_list|,
name|numFiles
argument_list|,
name|testDuration
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|testDuration
condition|)
block|{
name|DISPLAY
argument_list|(
literal|"Error: -T requires test mode (-t)\n\n"
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
operator|!
name|path
condition|)
block|{
name|DISPLAY
argument_list|(
literal|"Error: path is required in file generation mode\n"
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|numFiles
operator|==
literal|0
condition|)
block|{
return|return
name|generateFile
argument_list|(
name|seed
argument_list|,
name|path
argument_list|,
name|origPath
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|generateCorpus
argument_list|(
name|seed
argument_list|,
name|numFiles
argument_list|,
name|path
argument_list|,
name|origPath
argument_list|)
return|;
block|}
block|}
end_function

end_unit

