begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright (c) 2016-present, Yann Collet, Facebook, Inc.  * All rights reserved.  *  * This source code is licensed under the BSD-style license found in the  * LICENSE file in the root directory of this source tree. An additional grant  * of patent rights can be found in the PATENTS file in the same directory.  */
end_comment

begin_comment
comment|/*-************************************ *  Compiler specific **************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_comment
comment|/* Visual Studio */
end_comment

begin_define
define|#
directive|define
name|_CRT_SECURE_NO_WARNINGS
end_define

begin_comment
comment|/* fgets */
end_comment

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4127
name|)
end_pragma

begin_comment
comment|/* disable: C4127: conditional expression is constant */
end_comment

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4146
name|)
end_pragma

begin_comment
comment|/* disable: C4146: minus unsigned expression */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*-************************************ *  Includes **************************************/
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* free */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* fgets, sscanf */
end_comment

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_comment
comment|/* clock_t, clock() */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* strcmp */
end_comment

begin_include
include|#
directive|include
file|"mem.h"
end_include

begin_define
define|#
directive|define
name|ZSTD_STATIC_LINKING_ONLY
end_define

begin_comment
comment|/* ZSTD_maxCLevel */
end_comment

begin_include
include|#
directive|include
file|"zstd.h"
end_include

begin_comment
comment|/* ZSTD_compressBound */
end_comment

begin_define
define|#
directive|define
name|ZBUFF_STATIC_LINKING_ONLY
end_define

begin_comment
comment|/* ZBUFF_createCCtx_advanced */
end_comment

begin_include
include|#
directive|include
file|"zbuff.h"
end_include

begin_comment
comment|/* ZBUFF_isError */
end_comment

begin_include
include|#
directive|include
file|"datagen.h"
end_include

begin_comment
comment|/* RDG_genBuffer */
end_comment

begin_define
define|#
directive|define
name|XXH_STATIC_LINKING_ONLY
end_define

begin_include
include|#
directive|include
file|"xxhash.h"
end_include

begin_comment
comment|/* XXH64_* */
end_comment

begin_comment
comment|/*-************************************ *  Constants **************************************/
end_comment

begin_define
define|#
directive|define
name|KB
value|*(1U<<10)
end_define

begin_define
define|#
directive|define
name|MB
value|*(1U<<20)
end_define

begin_define
define|#
directive|define
name|GB
value|*(1U<<30)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|U32
name|nbTestsDefault
init|=
literal|10000
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|COMPRESSIBLE_NOISE_LENGTH
value|(10 MB)
end_define

begin_define
define|#
directive|define
name|FUZ_COMPRESSIBILITY_DEFAULT
value|50
end_define

begin_decl_stmt
specifier|static
specifier|const
name|U32
name|prime1
init|=
literal|2654435761U
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|U32
name|prime2
init|=
literal|2246822519U
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*-************************************ *  Display Macros **************************************/
end_comment

begin_define
define|#
directive|define
name|DISPLAY
parameter_list|(
modifier|...
parameter_list|)
value|fprintf(stderr, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|DISPLAYLEVEL
parameter_list|(
name|l
parameter_list|,
modifier|...
parameter_list|)
value|if (g_displayLevel>=l) { DISPLAY(__VA_ARGS__); }
end_define

begin_decl_stmt
specifier|static
name|U32
name|g_displayLevel
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DISPLAYUPDATE
parameter_list|(
name|l
parameter_list|,
modifier|...
parameter_list|)
value|if (g_displayLevel>=l) { \             if ((FUZ_GetClockSpan(g_displayClock)> g_refreshRate) || (g_displayLevel>=4)) \             { g_displayClock = clock(); DISPLAY(__VA_ARGS__); \             if (g_displayLevel>=4) fflush(stdout); } }
end_define

begin_decl_stmt
specifier|static
specifier|const
name|clock_t
name|g_refreshRate
init|=
name|CLOCKS_PER_SEC
operator|*
literal|15
operator|/
literal|100
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|clock_t
name|g_displayClock
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|clock_t
name|g_clockTime
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*-******************************************************* *  Fuzzer functions *********************************************************/
end_comment

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)>(b)?(a):(b))
end_define

begin_function
specifier|static
name|clock_t
name|FUZ_GetClockSpan
parameter_list|(
name|clock_t
name|clockStart
parameter_list|)
block|{
return|return
name|clock
argument_list|()
operator|-
name|clockStart
return|;
comment|/* works even when overflow. Max span ~ 30 mn */
block|}
end_function

begin_comment
comment|/*! FUZ_rand() :     @return : a 27 bits random value, from a 32-bits `seed`.     `seed` is also modified */
end_comment

begin_define
define|#
directive|define
name|FUZ_rotl32
parameter_list|(
name|x
parameter_list|,
name|r
parameter_list|)
value|((x<< r) | (x>> (32 - r)))
end_define

begin_function
name|unsigned
name|int
name|FUZ_rand
parameter_list|(
name|unsigned
name|int
modifier|*
name|seedPtr
parameter_list|)
block|{
name|U32
name|rand32
init|=
operator|*
name|seedPtr
decl_stmt|;
name|rand32
operator|*=
name|prime1
expr_stmt|;
name|rand32
operator|+=
name|prime2
expr_stmt|;
name|rand32
operator|=
name|FUZ_rotl32
argument_list|(
name|rand32
argument_list|,
literal|13
argument_list|)
expr_stmt|;
operator|*
name|seedPtr
operator|=
name|rand32
expr_stmt|;
return|return
name|rand32
operator|>>
literal|5
return|;
block|}
end_function

begin_comment
comment|/* static unsigned FUZ_highbit32(U32 v32) {     unsigned nbBits = 0;     if (v32==0) return 0;     for ( ; v32 ; v32>>=1) nbBits++;     return nbBits; } */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|ZBUFF_allocFunction
parameter_list|(
name|void
modifier|*
name|opaque
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|address
init|=
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|opaque
expr_stmt|;
comment|/* DISPLAYLEVEL(4, "alloc %p, %d opaque=%p \n", address, (int)size, opaque); */
return|return
name|address
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ZBUFF_freeFunction
parameter_list|(
name|void
modifier|*
name|opaque
parameter_list|,
name|void
modifier|*
name|address
parameter_list|)
block|{
operator|(
name|void
operator|)
name|opaque
expr_stmt|;
comment|/* if (address) DISPLAYLEVEL(4, "free %p opaque=%p \n", address, opaque); */
name|free
argument_list|(
name|address
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|basicUnitTests
parameter_list|(
name|U32
name|seed
parameter_list|,
name|double
name|compressibility
parameter_list|,
name|ZSTD_customMem
name|customMem
parameter_list|)
block|{
name|int
name|testResult
init|=
literal|0
decl_stmt|;
name|size_t
name|CNBufferSize
init|=
name|COMPRESSIBLE_NOISE_LENGTH
decl_stmt|;
name|void
modifier|*
name|CNBuffer
init|=
name|malloc
argument_list|(
name|CNBufferSize
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|skippableFrameSize
init|=
literal|11
decl_stmt|;
name|size_t
specifier|const
name|compressedBufferSize
init|=
operator|(
literal|8
operator|+
name|skippableFrameSize
operator|)
operator|+
name|ZSTD_compressBound
argument_list|(
name|COMPRESSIBLE_NOISE_LENGTH
argument_list|)
decl_stmt|;
name|void
modifier|*
name|compressedBuffer
init|=
name|malloc
argument_list|(
name|compressedBufferSize
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|decodedBufferSize
init|=
name|CNBufferSize
decl_stmt|;
name|void
modifier|*
name|decodedBuffer
init|=
name|malloc
argument_list|(
name|decodedBufferSize
argument_list|)
decl_stmt|;
name|size_t
name|cSize
decl_stmt|,
name|readSize
decl_stmt|,
name|readSkipSize
decl_stmt|,
name|genSize
decl_stmt|;
name|U32
name|testNb
init|=
literal|0
decl_stmt|;
name|ZBUFF_CCtx
modifier|*
name|zc
init|=
name|ZBUFF_createCCtx_advanced
argument_list|(
name|customMem
argument_list|)
decl_stmt|;
name|ZBUFF_DCtx
modifier|*
name|zd
init|=
name|ZBUFF_createDCtx_advanced
argument_list|(
name|customMem
argument_list|)
decl_stmt|;
comment|/* Create compressible test buffer */
if|if
condition|(
operator|!
name|CNBuffer
operator|||
operator|!
name|compressedBuffer
operator|||
operator|!
name|decodedBuffer
operator|||
operator|!
name|zc
operator|||
operator|!
name|zd
condition|)
block|{
name|DISPLAY
argument_list|(
literal|"Not enough memory, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|_output_error
goto|;
block|}
name|RDG_genBuffer
argument_list|(
name|CNBuffer
argument_list|,
name|CNBufferSize
argument_list|,
name|compressibility
argument_list|,
literal|0.
argument_list|,
name|seed
argument_list|)
expr_stmt|;
comment|/* generate skippable frame */
name|MEM_writeLE32
argument_list|(
name|compressedBuffer
argument_list|,
name|ZSTD_MAGIC_SKIPPABLE_START
argument_list|)
expr_stmt|;
name|MEM_writeLE32
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|compressedBuffer
operator|)
operator|+
literal|4
argument_list|,
operator|(
name|U32
operator|)
name|skippableFrameSize
argument_list|)
expr_stmt|;
name|cSize
operator|=
name|skippableFrameSize
operator|+
literal|8
expr_stmt|;
comment|/* Basic compression test */
name|DISPLAYLEVEL
argument_list|(
literal|4
argument_list|,
literal|"test%3i : compress %u bytes : "
argument_list|,
name|testNb
operator|++
argument_list|,
name|COMPRESSIBLE_NOISE_LENGTH
argument_list|)
expr_stmt|;
name|ZBUFF_compressInitDictionary
argument_list|(
name|zc
argument_list|,
name|CNBuffer
argument_list|,
literal|128
name|KB
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|readSize
operator|=
name|CNBufferSize
expr_stmt|;
name|genSize
operator|=
name|compressedBufferSize
expr_stmt|;
block|{
name|size_t
specifier|const
name|r
init|=
name|ZBUFF_compressContinue
argument_list|(
name|zc
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|compressedBuffer
operator|)
operator|+
name|cSize
argument_list|,
operator|&
name|genSize
argument_list|,
name|CNBuffer
argument_list|,
operator|&
name|readSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZBUFF_isError
argument_list|(
name|r
argument_list|)
condition|)
goto|goto
name|_output_error
goto|;
block|}
if|if
condition|(
name|readSize
operator|!=
name|CNBufferSize
condition|)
goto|goto
name|_output_error
goto|;
comment|/* entire input should be consumed */
name|cSize
operator|+=
name|genSize
expr_stmt|;
name|genSize
operator|=
name|compressedBufferSize
operator|-
name|cSize
expr_stmt|;
block|{
name|size_t
specifier|const
name|r
init|=
name|ZBUFF_compressEnd
argument_list|(
name|zc
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|compressedBuffer
operator|)
operator|+
name|cSize
argument_list|,
operator|&
name|genSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
goto|goto
name|_output_error
goto|;
block|}
comment|/* error, or some data not flushed */
name|cSize
operator|+=
name|genSize
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|4
argument_list|,
literal|"OK (%u bytes : %.2f%%)\n"
argument_list|,
operator|(
name|U32
operator|)
name|cSize
argument_list|,
operator|(
name|double
operator|)
name|cSize
operator|/
name|COMPRESSIBLE_NOISE_LENGTH
operator|*
literal|100
argument_list|)
expr_stmt|;
comment|/* skippable frame test */
name|DISPLAYLEVEL
argument_list|(
literal|4
argument_list|,
literal|"test%3i : decompress skippable frame : "
argument_list|,
name|testNb
operator|++
argument_list|)
expr_stmt|;
name|ZBUFF_decompressInitDictionary
argument_list|(
name|zd
argument_list|,
name|CNBuffer
argument_list|,
literal|128
name|KB
argument_list|)
expr_stmt|;
name|readSkipSize
operator|=
name|cSize
expr_stmt|;
name|genSize
operator|=
name|CNBufferSize
expr_stmt|;
block|{
name|size_t
specifier|const
name|r
init|=
name|ZBUFF_decompressContinue
argument_list|(
name|zd
argument_list|,
name|decodedBuffer
argument_list|,
operator|&
name|genSize
argument_list|,
name|compressedBuffer
argument_list|,
operator|&
name|readSkipSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
goto|goto
name|_output_error
goto|;
block|}
if|if
condition|(
name|genSize
operator|!=
literal|0
condition|)
goto|goto
name|_output_error
goto|;
comment|/* skippable frame len is 0 */
name|DISPLAYLEVEL
argument_list|(
literal|4
argument_list|,
literal|"OK \n"
argument_list|)
expr_stmt|;
comment|/* Basic decompression test */
name|DISPLAYLEVEL
argument_list|(
literal|4
argument_list|,
literal|"test%3i : decompress %u bytes : "
argument_list|,
name|testNb
operator|++
argument_list|,
name|COMPRESSIBLE_NOISE_LENGTH
argument_list|)
expr_stmt|;
name|ZBUFF_decompressInitDictionary
argument_list|(
name|zd
argument_list|,
name|CNBuffer
argument_list|,
literal|128
name|KB
argument_list|)
expr_stmt|;
name|readSize
operator|=
name|cSize
operator|-
name|readSkipSize
expr_stmt|;
name|genSize
operator|=
name|CNBufferSize
expr_stmt|;
block|{
name|size_t
specifier|const
name|r
init|=
name|ZBUFF_decompressContinue
argument_list|(
name|zd
argument_list|,
name|decodedBuffer
argument_list|,
operator|&
name|genSize
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|compressedBuffer
operator|)
operator|+
name|readSkipSize
argument_list|,
operator|&
name|readSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
goto|goto
name|_output_error
goto|;
block|}
comment|/* should reach end of frame == 0; otherwise, some data left, or an error */
if|if
condition|(
name|genSize
operator|!=
name|CNBufferSize
condition|)
goto|goto
name|_output_error
goto|;
comment|/* should regenerate the same amount */
if|if
condition|(
name|readSize
operator|+
name|readSkipSize
operator|!=
name|cSize
condition|)
goto|goto
name|_output_error
goto|;
comment|/* should have read the entire frame */
name|DISPLAYLEVEL
argument_list|(
literal|4
argument_list|,
literal|"OK \n"
argument_list|)
expr_stmt|;
comment|/* check regenerated data is byte exact */
name|DISPLAYLEVEL
argument_list|(
literal|4
argument_list|,
literal|"test%3i : check decompressed result : "
argument_list|,
name|testNb
operator|++
argument_list|)
expr_stmt|;
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CNBufferSize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|BYTE
operator|*
operator|)
name|decodedBuffer
operator|)
index|[
name|i
index|]
operator|!=
operator|(
operator|(
name|BYTE
operator|*
operator|)
name|CNBuffer
operator|)
index|[
name|i
index|]
condition|)
goto|goto
name|_output_error
goto|;
empty_stmt|;
block|}
block|}
name|DISPLAYLEVEL
argument_list|(
literal|4
argument_list|,
literal|"OK \n"
argument_list|)
expr_stmt|;
comment|/* Byte-by-byte decompression test */
name|DISPLAYLEVEL
argument_list|(
literal|4
argument_list|,
literal|"test%3i : decompress byte-by-byte : "
argument_list|,
name|testNb
operator|++
argument_list|)
expr_stmt|;
block|{
name|size_t
name|r
decl_stmt|,
name|pIn
init|=
literal|0
decl_stmt|,
name|pOut
init|=
literal|0
decl_stmt|;
do|do
block|{
name|ZBUFF_decompressInitDictionary
argument_list|(
name|zd
argument_list|,
name|CNBuffer
argument_list|,
literal|128
name|KB
argument_list|)
expr_stmt|;
name|r
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|r
condition|)
block|{
name|size_t
name|inS
init|=
literal|1
decl_stmt|;
name|size_t
name|outS
init|=
literal|1
decl_stmt|;
name|r
operator|=
name|ZBUFF_decompressContinue
argument_list|(
name|zd
argument_list|,
operator|(
operator|(
name|BYTE
operator|*
operator|)
name|decodedBuffer
operator|)
operator|+
name|pOut
argument_list|,
operator|&
name|outS
argument_list|,
operator|(
operator|(
name|BYTE
operator|*
operator|)
name|compressedBuffer
operator|)
operator|+
name|pIn
argument_list|,
operator|&
name|inS
argument_list|)
expr_stmt|;
name|pIn
operator|+=
name|inS
expr_stmt|;
name|pOut
operator|+=
name|outS
expr_stmt|;
block|}
name|readSize
operator|=
name|pIn
expr_stmt|;
name|genSize
operator|=
name|pOut
expr_stmt|;
block|}
do|while
condition|(
name|genSize
operator|==
literal|0
condition|)
do|;
block|}
if|if
condition|(
name|genSize
operator|!=
name|CNBufferSize
condition|)
goto|goto
name|_output_error
goto|;
comment|/* should regenerate the same amount */
if|if
condition|(
name|readSize
operator|!=
name|cSize
condition|)
goto|goto
name|_output_error
goto|;
comment|/* should have read the entire frame */
name|DISPLAYLEVEL
argument_list|(
literal|4
argument_list|,
literal|"OK \n"
argument_list|)
expr_stmt|;
comment|/* check regenerated data is byte exact */
name|DISPLAYLEVEL
argument_list|(
literal|4
argument_list|,
literal|"test%3i : check decompressed result : "
argument_list|,
name|testNb
operator|++
argument_list|)
expr_stmt|;
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CNBufferSize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|BYTE
operator|*
operator|)
name|decodedBuffer
operator|)
index|[
name|i
index|]
operator|!=
operator|(
operator|(
name|BYTE
operator|*
operator|)
name|CNBuffer
operator|)
index|[
name|i
index|]
condition|)
goto|goto
name|_output_error
goto|;
empty_stmt|;
block|}
block|}
name|DISPLAYLEVEL
argument_list|(
literal|4
argument_list|,
literal|"OK \n"
argument_list|)
expr_stmt|;
name|_end
label|:
name|ZBUFF_freeCCtx
argument_list|(
name|zc
argument_list|)
expr_stmt|;
name|ZBUFF_freeDCtx
argument_list|(
name|zd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|CNBuffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|compressedBuffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|decodedBuffer
argument_list|)
expr_stmt|;
return|return
name|testResult
return|;
name|_output_error
label|:
name|testResult
operator|=
literal|1
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"Error detected in Unit tests ! \n"
argument_list|)
expr_stmt|;
goto|goto
name|_end
goto|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|findDiff
parameter_list|(
specifier|const
name|void
modifier|*
name|buf1
parameter_list|,
specifier|const
name|void
modifier|*
name|buf2
parameter_list|,
name|size_t
name|max
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|b1
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|buf1
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|b2
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|buf2
decl_stmt|;
name|size_t
name|u
decl_stmt|;
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|max
condition|;
name|u
operator|++
control|)
block|{
if|if
condition|(
name|b1
index|[
name|u
index|]
operator|!=
name|b2
index|[
name|u
index|]
condition|)
break|break;
block|}
return|return
name|u
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|FUZ_rLogLength
parameter_list|(
name|U32
modifier|*
name|seed
parameter_list|,
name|U32
name|logLength
parameter_list|)
block|{
name|size_t
specifier|const
name|lengthMask
init|=
operator|(
operator|(
name|size_t
operator|)
literal|1
operator|<<
name|logLength
operator|)
operator|-
literal|1
decl_stmt|;
return|return
operator|(
name|lengthMask
operator|+
literal|1
operator|)
operator|+
operator|(
name|FUZ_rand
argument_list|(
name|seed
argument_list|)
operator|&
name|lengthMask
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|FUZ_randomLength
parameter_list|(
name|U32
modifier|*
name|seed
parameter_list|,
name|U32
name|maxLog
parameter_list|)
block|{
name|U32
specifier|const
name|logLength
init|=
name|FUZ_rand
argument_list|(
name|seed
argument_list|)
operator|%
name|maxLog
decl_stmt|;
return|return
name|FUZ_rLogLength
argument_list|(
name|seed
argument_list|,
name|logLength
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|( (a)< (b) ? (a) : (b) )
end_define

begin_define
define|#
directive|define
name|CHECK
parameter_list|(
name|cond
parameter_list|,
modifier|...
parameter_list|)
value|if (cond) { DISPLAY("Error => "); DISPLAY(__VA_ARGS__); \                          DISPLAY(" (seed %u, test nb %u)  \n", seed, testNb); goto _output_error; }
end_define

begin_function
specifier|static
name|int
name|fuzzerTests
parameter_list|(
name|U32
name|seed
parameter_list|,
name|U32
name|nbTests
parameter_list|,
name|unsigned
name|startTest
parameter_list|,
name|double
name|compressibility
parameter_list|)
block|{
specifier|static
specifier|const
name|U32
name|maxSrcLog
init|=
literal|24
decl_stmt|;
specifier|static
specifier|const
name|U32
name|maxSampleLog
init|=
literal|19
decl_stmt|;
name|BYTE
modifier|*
name|cNoiseBuffer
index|[
literal|5
index|]
decl_stmt|;
name|size_t
specifier|const
name|srcBufferSize
init|=
operator|(
name|size_t
operator|)
literal|1
operator|<<
name|maxSrcLog
decl_stmt|;
name|BYTE
modifier|*
name|copyBuffer
decl_stmt|;
name|size_t
specifier|const
name|copyBufferSize
init|=
name|srcBufferSize
operator|+
operator|(
literal|1
operator|<<
name|maxSampleLog
operator|)
decl_stmt|;
name|BYTE
modifier|*
name|cBuffer
decl_stmt|;
name|size_t
specifier|const
name|cBufferSize
init|=
name|ZSTD_compressBound
argument_list|(
name|srcBufferSize
argument_list|)
decl_stmt|;
name|BYTE
modifier|*
name|dstBuffer
decl_stmt|;
name|size_t
name|dstBufferSize
init|=
name|srcBufferSize
decl_stmt|;
name|U32
name|result
init|=
literal|0
decl_stmt|;
name|U32
name|testNb
init|=
literal|0
decl_stmt|;
name|U32
name|coreSeed
init|=
name|seed
decl_stmt|;
name|ZBUFF_CCtx
modifier|*
name|zc
decl_stmt|;
name|ZBUFF_DCtx
modifier|*
name|zd
decl_stmt|;
name|clock_t
name|startClock
init|=
name|clock
argument_list|()
decl_stmt|;
comment|/* allocations */
name|zc
operator|=
name|ZBUFF_createCCtx
argument_list|()
expr_stmt|;
name|zd
operator|=
name|ZBUFF_createDCtx
argument_list|()
expr_stmt|;
name|cNoiseBuffer
index|[
literal|0
index|]
operator|=
operator|(
name|BYTE
operator|*
operator|)
name|malloc
argument_list|(
name|srcBufferSize
argument_list|)
expr_stmt|;
name|cNoiseBuffer
index|[
literal|1
index|]
operator|=
operator|(
name|BYTE
operator|*
operator|)
name|malloc
argument_list|(
name|srcBufferSize
argument_list|)
expr_stmt|;
name|cNoiseBuffer
index|[
literal|2
index|]
operator|=
operator|(
name|BYTE
operator|*
operator|)
name|malloc
argument_list|(
name|srcBufferSize
argument_list|)
expr_stmt|;
name|cNoiseBuffer
index|[
literal|3
index|]
operator|=
operator|(
name|BYTE
operator|*
operator|)
name|malloc
argument_list|(
name|srcBufferSize
argument_list|)
expr_stmt|;
name|cNoiseBuffer
index|[
literal|4
index|]
operator|=
operator|(
name|BYTE
operator|*
operator|)
name|malloc
argument_list|(
name|srcBufferSize
argument_list|)
expr_stmt|;
name|copyBuffer
operator|=
operator|(
name|BYTE
operator|*
operator|)
name|malloc
argument_list|(
name|copyBufferSize
argument_list|)
expr_stmt|;
name|dstBuffer
operator|=
operator|(
name|BYTE
operator|*
operator|)
name|malloc
argument_list|(
name|dstBufferSize
argument_list|)
expr_stmt|;
name|cBuffer
operator|=
operator|(
name|BYTE
operator|*
operator|)
name|malloc
argument_list|(
name|cBufferSize
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
operator|!
name|cNoiseBuffer
index|[
literal|0
index|]
operator|||
operator|!
name|cNoiseBuffer
index|[
literal|1
index|]
operator|||
operator|!
name|cNoiseBuffer
index|[
literal|2
index|]
operator|||
operator|!
name|cNoiseBuffer
index|[
literal|3
index|]
operator|||
operator|!
name|cNoiseBuffer
index|[
literal|4
index|]
operator|||
operator|!
name|copyBuffer
operator|||
operator|!
name|dstBuffer
operator|||
operator|!
name|cBuffer
operator|||
operator|!
name|zc
operator|||
operator|!
name|zd
argument_list|,
literal|"Not enough memory, fuzzer tests cancelled"
argument_list|)
expr_stmt|;
comment|/* Create initial samples */
name|RDG_genBuffer
argument_list|(
name|cNoiseBuffer
index|[
literal|0
index|]
argument_list|,
name|srcBufferSize
argument_list|,
literal|0.00
argument_list|,
literal|0.
argument_list|,
name|coreSeed
argument_list|)
expr_stmt|;
comment|/* pure noise */
name|RDG_genBuffer
argument_list|(
name|cNoiseBuffer
index|[
literal|1
index|]
argument_list|,
name|srcBufferSize
argument_list|,
literal|0.05
argument_list|,
literal|0.
argument_list|,
name|coreSeed
argument_list|)
expr_stmt|;
comment|/* barely compressible */
name|RDG_genBuffer
argument_list|(
name|cNoiseBuffer
index|[
literal|2
index|]
argument_list|,
name|srcBufferSize
argument_list|,
name|compressibility
argument_list|,
literal|0.
argument_list|,
name|coreSeed
argument_list|)
expr_stmt|;
name|RDG_genBuffer
argument_list|(
name|cNoiseBuffer
index|[
literal|3
index|]
argument_list|,
name|srcBufferSize
argument_list|,
literal|0.95
argument_list|,
literal|0.
argument_list|,
name|coreSeed
argument_list|)
expr_stmt|;
comment|/* highly compressible */
name|RDG_genBuffer
argument_list|(
name|cNoiseBuffer
index|[
literal|4
index|]
argument_list|,
name|srcBufferSize
argument_list|,
literal|1.00
argument_list|,
literal|0.
argument_list|,
name|coreSeed
argument_list|)
expr_stmt|;
comment|/* sparse content */
name|memset
argument_list|(
name|copyBuffer
argument_list|,
literal|0x65
argument_list|,
name|copyBufferSize
argument_list|)
expr_stmt|;
comment|/* make copyBuffer considered initialized */
comment|/* catch up testNb */
for|for
control|(
name|testNb
operator|=
literal|1
init|;
name|testNb
operator|<
name|startTest
condition|;
name|testNb
operator|++
control|)
name|FUZ_rand
argument_list|(
operator|&
name|coreSeed
argument_list|)
expr_stmt|;
comment|/* test loop */
for|for
control|(
init|;
operator|(
name|testNb
operator|<=
name|nbTests
operator|)
operator|||
operator|(
name|FUZ_GetClockSpan
argument_list|(
name|startClock
argument_list|)
operator|<
name|g_clockTime
operator|)
condition|;
name|testNb
operator|++
control|)
block|{
name|U32
name|lseed
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|srcBuffer
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|dict
decl_stmt|;
name|size_t
name|maxTestSize
decl_stmt|,
name|dictSize
decl_stmt|;
name|size_t
name|cSize
decl_stmt|,
name|totalTestSize
decl_stmt|,
name|totalCSize
decl_stmt|,
name|totalGenSize
decl_stmt|;
name|size_t
name|errorCode
decl_stmt|;
name|U32
name|n
decl_stmt|,
name|nbChunks
decl_stmt|;
name|XXH64_state_t
name|xxhState
decl_stmt|;
name|U64
name|crcOrig
decl_stmt|;
comment|/* init */
name|DISPLAYUPDATE
argument_list|(
literal|2
argument_list|,
literal|"\r%6u"
argument_list|,
name|testNb
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbTests
operator|>=
name|testNb
condition|)
name|DISPLAYUPDATE
argument_list|(
literal|2
argument_list|,
literal|"/%6u   "
argument_list|,
name|nbTests
argument_list|)
expr_stmt|;
name|FUZ_rand
argument_list|(
operator|&
name|coreSeed
argument_list|)
expr_stmt|;
name|lseed
operator|=
name|coreSeed
operator|^
name|prime1
expr_stmt|;
comment|/* states full reset (unsynchronized) */
comment|/* some issues only happen when reusing states in a specific sequence of parameters */
if|if
condition|(
operator|(
name|FUZ_rand
argument_list|(
operator|&
name|lseed
argument_list|)
operator|&
literal|0xFF
operator|)
operator|==
literal|131
condition|)
block|{
name|ZBUFF_freeCCtx
argument_list|(
name|zc
argument_list|)
expr_stmt|;
name|zc
operator|=
name|ZBUFF_createCCtx
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|FUZ_rand
argument_list|(
operator|&
name|lseed
argument_list|)
operator|&
literal|0xFF
operator|)
operator|==
literal|132
condition|)
block|{
name|ZBUFF_freeDCtx
argument_list|(
name|zd
argument_list|)
expr_stmt|;
name|zd
operator|=
name|ZBUFF_createDCtx
argument_list|()
expr_stmt|;
block|}
comment|/* srcBuffer selection [0-4] */
block|{
name|U32
name|buffNb
init|=
name|FUZ_rand
argument_list|(
operator|&
name|lseed
argument_list|)
operator|&
literal|0x7F
decl_stmt|;
if|if
condition|(
name|buffNb
operator|&
literal|7
condition|)
name|buffNb
operator|=
literal|2
expr_stmt|;
comment|/* most common : compressible (P) */
else|else
block|{
name|buffNb
operator|>>=
literal|3
expr_stmt|;
if|if
condition|(
name|buffNb
operator|&
literal|7
condition|)
block|{
specifier|const
name|U32
name|tnb
index|[
literal|2
index|]
init|=
block|{
literal|1
block|,
literal|3
block|}
decl_stmt|;
comment|/* barely/highly compressible */
name|buffNb
operator|=
name|tnb
index|[
name|buffNb
operator|>>
literal|3
index|]
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|U32
name|tnb
index|[
literal|2
index|]
init|=
block|{
literal|0
block|,
literal|4
block|}
decl_stmt|;
comment|/* not compressible / sparse */
name|buffNb
operator|=
name|tnb
index|[
name|buffNb
operator|>>
literal|3
index|]
expr_stmt|;
block|}
block|}
name|srcBuffer
operator|=
name|cNoiseBuffer
index|[
name|buffNb
index|]
expr_stmt|;
block|}
comment|/* compression init */
block|{
name|U32
specifier|const
name|testLog
init|=
name|FUZ_rand
argument_list|(
operator|&
name|lseed
argument_list|)
operator|%
name|maxSrcLog
decl_stmt|;
name|U32
specifier|const
name|cLevel
init|=
operator|(
name|FUZ_rand
argument_list|(
operator|&
name|lseed
argument_list|)
operator|%
operator|(
name|ZSTD_maxCLevel
argument_list|()
operator|-
operator|(
name|testLog
operator|/
literal|3
operator|)
operator|)
operator|)
operator|+
literal|1
decl_stmt|;
name|maxTestSize
operator|=
name|FUZ_rLogLength
argument_list|(
operator|&
name|lseed
argument_list|,
name|testLog
argument_list|)
expr_stmt|;
name|dictSize
operator|=
operator|(
name|FUZ_rand
argument_list|(
operator|&
name|lseed
argument_list|)
operator|==
literal|1
operator|)
condition|?
name|FUZ_randomLength
argument_list|(
operator|&
name|lseed
argument_list|,
name|maxSampleLog
argument_list|)
else|:
literal|0
expr_stmt|;
comment|/* random dictionary selection */
block|{
name|size_t
specifier|const
name|dictStart
init|=
name|FUZ_rand
argument_list|(
operator|&
name|lseed
argument_list|)
operator|%
operator|(
name|srcBufferSize
operator|-
name|dictSize
operator|)
decl_stmt|;
name|dict
operator|=
name|srcBuffer
operator|+
name|dictStart
expr_stmt|;
block|}
block|{
name|ZSTD_parameters
name|params
init|=
name|ZSTD_getParams
argument_list|(
name|cLevel
argument_list|,
literal|0
argument_list|,
name|dictSize
argument_list|)
decl_stmt|;
name|params
operator|.
name|fParams
operator|.
name|checksumFlag
operator|=
name|FUZ_rand
argument_list|(
operator|&
name|lseed
argument_list|)
operator|&
literal|1
expr_stmt|;
name|params
operator|.
name|fParams
operator|.
name|noDictIDFlag
operator|=
name|FUZ_rand
argument_list|(
operator|&
name|lseed
argument_list|)
operator|&
literal|1
expr_stmt|;
block|{
name|size_t
specifier|const
name|initError
init|=
name|ZBUFF_compressInit_advanced
argument_list|(
name|zc
argument_list|,
name|dict
argument_list|,
name|dictSize
argument_list|,
name|params
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|CHECK
argument_list|(
name|ZBUFF_isError
argument_list|(
name|initError
argument_list|)
argument_list|,
literal|"init error : %s"
argument_list|,
name|ZBUFF_getErrorName
argument_list|(
name|initError
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* multi-segments compression test */
name|XXH64_reset
argument_list|(
operator|&
name|xxhState
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nbChunks
operator|=
operator|(
name|FUZ_rand
argument_list|(
operator|&
name|lseed
argument_list|)
operator|&
literal|127
operator|)
operator|+
literal|2
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|cSize
operator|=
literal|0
operator|,
name|totalTestSize
operator|=
literal|0
init|;
operator|(
name|n
operator|<
name|nbChunks
operator|)
operator|&&
operator|(
name|totalTestSize
operator|<
name|maxTestSize
operator|)
condition|;
name|n
operator|++
control|)
block|{
comment|/* compress random chunk into random size dst buffer */
block|{
name|size_t
name|readChunkSize
init|=
name|FUZ_randomLength
argument_list|(
operator|&
name|lseed
argument_list|,
name|maxSampleLog
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|randomDstSize
init|=
name|FUZ_randomLength
argument_list|(
operator|&
name|lseed
argument_list|,
name|maxSampleLog
argument_list|)
decl_stmt|;
name|size_t
name|dstBuffSize
init|=
name|MIN
argument_list|(
name|cBufferSize
operator|-
name|cSize
argument_list|,
name|randomDstSize
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|srcStart
init|=
name|FUZ_rand
argument_list|(
operator|&
name|lseed
argument_list|)
operator|%
operator|(
name|srcBufferSize
operator|-
name|readChunkSize
operator|)
decl_stmt|;
name|size_t
specifier|const
name|compressionError
init|=
name|ZBUFF_compressContinue
argument_list|(
name|zc
argument_list|,
name|cBuffer
operator|+
name|cSize
argument_list|,
operator|&
name|dstBuffSize
argument_list|,
name|srcBuffer
operator|+
name|srcStart
argument_list|,
operator|&
name|readChunkSize
argument_list|)
decl_stmt|;
name|CHECK
argument_list|(
name|ZBUFF_isError
argument_list|(
name|compressionError
argument_list|)
argument_list|,
literal|"compression error : %s"
argument_list|,
name|ZBUFF_getErrorName
argument_list|(
name|compressionError
argument_list|)
argument_list|)
expr_stmt|;
name|XXH64_update
argument_list|(
operator|&
name|xxhState
argument_list|,
name|srcBuffer
operator|+
name|srcStart
argument_list|,
name|readChunkSize
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|copyBuffer
operator|+
name|totalTestSize
argument_list|,
name|srcBuffer
operator|+
name|srcStart
argument_list|,
name|readChunkSize
argument_list|)
expr_stmt|;
name|cSize
operator|+=
name|dstBuffSize
expr_stmt|;
name|totalTestSize
operator|+=
name|readChunkSize
expr_stmt|;
block|}
comment|/* random flush operation, to mess around */
if|if
condition|(
operator|(
name|FUZ_rand
argument_list|(
operator|&
name|lseed
argument_list|)
operator|&
literal|15
operator|)
operator|==
literal|0
condition|)
block|{
name|size_t
specifier|const
name|randomDstSize
init|=
name|FUZ_randomLength
argument_list|(
operator|&
name|lseed
argument_list|,
name|maxSampleLog
argument_list|)
decl_stmt|;
name|size_t
name|dstBuffSize
init|=
name|MIN
argument_list|(
name|cBufferSize
operator|-
name|cSize
argument_list|,
name|randomDstSize
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|flushError
init|=
name|ZBUFF_compressFlush
argument_list|(
name|zc
argument_list|,
name|cBuffer
operator|+
name|cSize
argument_list|,
operator|&
name|dstBuffSize
argument_list|)
decl_stmt|;
name|CHECK
argument_list|(
name|ZBUFF_isError
argument_list|(
name|flushError
argument_list|)
argument_list|,
literal|"flush error : %s"
argument_list|,
name|ZBUFF_getErrorName
argument_list|(
name|flushError
argument_list|)
argument_list|)
expr_stmt|;
name|cSize
operator|+=
name|dstBuffSize
expr_stmt|;
block|}
block|}
comment|/* final frame epilogue */
block|{
name|size_t
name|remainingToFlush
init|=
call|(
name|size_t
call|)
argument_list|(
operator|-
literal|1
argument_list|)
decl_stmt|;
while|while
condition|(
name|remainingToFlush
condition|)
block|{
name|size_t
specifier|const
name|randomDstSize
init|=
name|FUZ_randomLength
argument_list|(
operator|&
name|lseed
argument_list|,
name|maxSampleLog
argument_list|)
decl_stmt|;
name|size_t
name|dstBuffSize
init|=
name|MIN
argument_list|(
name|cBufferSize
operator|-
name|cSize
argument_list|,
name|randomDstSize
argument_list|)
decl_stmt|;
name|U32
specifier|const
name|enoughDstSize
init|=
name|dstBuffSize
operator|>=
name|remainingToFlush
decl_stmt|;
name|remainingToFlush
operator|=
name|ZBUFF_compressEnd
argument_list|(
name|zc
argument_list|,
name|cBuffer
operator|+
name|cSize
argument_list|,
operator|&
name|dstBuffSize
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|ZBUFF_isError
argument_list|(
name|remainingToFlush
argument_list|)
argument_list|,
literal|"flush error : %s"
argument_list|,
name|ZBUFF_getErrorName
argument_list|(
name|remainingToFlush
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|enoughDstSize
operator|&&
name|remainingToFlush
argument_list|,
literal|"ZBUFF_compressEnd() not fully flushed (%u remaining), but enough space available"
argument_list|,
operator|(
name|U32
operator|)
name|remainingToFlush
argument_list|)
expr_stmt|;
name|cSize
operator|+=
name|dstBuffSize
expr_stmt|;
block|}
block|}
name|crcOrig
operator|=
name|XXH64_digest
argument_list|(
operator|&
name|xxhState
argument_list|)
expr_stmt|;
comment|/* multi - fragments decompression test */
name|ZBUFF_decompressInitDictionary
argument_list|(
name|zd
argument_list|,
name|dict
argument_list|,
name|dictSize
argument_list|)
expr_stmt|;
name|errorCode
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|totalCSize
operator|=
literal|0
operator|,
name|totalGenSize
operator|=
literal|0
init|;
name|errorCode
condition|;
control|)
block|{
name|size_t
name|readCSrcSize
init|=
name|FUZ_randomLength
argument_list|(
operator|&
name|lseed
argument_list|,
name|maxSampleLog
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|randomDstSize
init|=
name|FUZ_randomLength
argument_list|(
operator|&
name|lseed
argument_list|,
name|maxSampleLog
argument_list|)
decl_stmt|;
name|size_t
name|dstBuffSize
init|=
name|MIN
argument_list|(
name|dstBufferSize
operator|-
name|totalGenSize
argument_list|,
name|randomDstSize
argument_list|)
decl_stmt|;
name|errorCode
operator|=
name|ZBUFF_decompressContinue
argument_list|(
name|zd
argument_list|,
name|dstBuffer
operator|+
name|totalGenSize
argument_list|,
operator|&
name|dstBuffSize
argument_list|,
name|cBuffer
operator|+
name|totalCSize
argument_list|,
operator|&
name|readCSrcSize
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|ZBUFF_isError
argument_list|(
name|errorCode
argument_list|)
argument_list|,
literal|"decompression error : %s"
argument_list|,
name|ZBUFF_getErrorName
argument_list|(
name|errorCode
argument_list|)
argument_list|)
expr_stmt|;
name|totalGenSize
operator|+=
name|dstBuffSize
expr_stmt|;
name|totalCSize
operator|+=
name|readCSrcSize
expr_stmt|;
block|}
name|CHECK
argument_list|(
name|errorCode
operator|!=
literal|0
argument_list|,
literal|"frame not fully decoded"
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
argument|totalGenSize != totalTestSize
argument_list|,
literal|"decompressed data : wrong size"
argument_list|)
name|CHECK
argument_list|(
argument|totalCSize != cSize
argument_list|,
literal|"compressed data should be fully read"
argument_list|)
block|{
name|U64
specifier|const
name|crcDest
init|=
name|XXH64
argument_list|(
name|dstBuffer
argument_list|,
name|totalTestSize
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|crcDest
operator|!=
name|crcOrig
condition|)
name|findDiff
argument_list|(
name|copyBuffer
argument_list|,
name|dstBuffer
argument_list|,
name|totalTestSize
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|crcDest
operator|!=
name|crcOrig
argument_list|,
literal|"decompressed data corrupted"
argument_list|)
expr_stmt|;
block|}
comment|/*=====   noisy/erroneous src decompression test   =====*/
comment|/* add some noise */
block|{
name|U32
specifier|const
name|nbNoiseChunks
init|=
operator|(
name|FUZ_rand
argument_list|(
operator|&
name|lseed
argument_list|)
operator|&
literal|7
operator|)
operator|+
literal|2
decl_stmt|;
name|U32
name|nn
decl_stmt|;
for|for
control|(
name|nn
operator|=
literal|0
init|;
name|nn
operator|<
name|nbNoiseChunks
condition|;
name|nn
operator|++
control|)
block|{
name|size_t
specifier|const
name|randomNoiseSize
init|=
name|FUZ_randomLength
argument_list|(
operator|&
name|lseed
argument_list|,
name|maxSampleLog
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|noiseSize
init|=
name|MIN
argument_list|(
operator|(
name|cSize
operator|/
literal|3
operator|)
argument_list|,
name|randomNoiseSize
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|noiseStart
init|=
name|FUZ_rand
argument_list|(
operator|&
name|lseed
argument_list|)
operator|%
operator|(
name|srcBufferSize
operator|-
name|noiseSize
operator|)
decl_stmt|;
name|size_t
specifier|const
name|cStart
init|=
name|FUZ_rand
argument_list|(
operator|&
name|lseed
argument_list|)
operator|%
operator|(
name|cSize
operator|-
name|noiseSize
operator|)
decl_stmt|;
name|memcpy
argument_list|(
name|cBuffer
operator|+
name|cStart
argument_list|,
name|srcBuffer
operator|+
name|noiseStart
argument_list|,
name|noiseSize
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* try decompression on noisy data */
name|ZBUFF_decompressInit
argument_list|(
name|zd
argument_list|)
expr_stmt|;
name|totalCSize
operator|=
literal|0
expr_stmt|;
name|totalGenSize
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|totalCSize
operator|<
name|cSize
operator|)
operator|&&
operator|(
name|totalGenSize
operator|<
name|dstBufferSize
operator|)
condition|)
block|{
name|size_t
name|readCSrcSize
init|=
name|FUZ_randomLength
argument_list|(
operator|&
name|lseed
argument_list|,
name|maxSampleLog
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|randomDstSize
init|=
name|FUZ_randomLength
argument_list|(
operator|&
name|lseed
argument_list|,
name|maxSampleLog
argument_list|)
decl_stmt|;
name|size_t
name|dstBuffSize
init|=
name|MIN
argument_list|(
name|dstBufferSize
operator|-
name|totalGenSize
argument_list|,
name|randomDstSize
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|decompressError
init|=
name|ZBUFF_decompressContinue
argument_list|(
name|zd
argument_list|,
name|dstBuffer
operator|+
name|totalGenSize
argument_list|,
operator|&
name|dstBuffSize
argument_list|,
name|cBuffer
operator|+
name|totalCSize
argument_list|,
operator|&
name|readCSrcSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZBUFF_isError
argument_list|(
name|decompressError
argument_list|)
condition|)
break|break;
comment|/* error correctly detected */
name|totalGenSize
operator|+=
name|dstBuffSize
expr_stmt|;
name|totalCSize
operator|+=
name|readCSrcSize
expr_stmt|;
block|}
block|}
name|DISPLAY
argument_list|(
literal|"\r%u fuzzer tests completed   \n"
argument_list|,
name|testNb
argument_list|)
expr_stmt|;
name|_cleanup
label|:
name|ZBUFF_freeCCtx
argument_list|(
name|zc
argument_list|)
expr_stmt|;
name|ZBUFF_freeDCtx
argument_list|(
name|zd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cNoiseBuffer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cNoiseBuffer
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cNoiseBuffer
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cNoiseBuffer
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cNoiseBuffer
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|copyBuffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cBuffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dstBuffer
argument_list|)
expr_stmt|;
return|return
name|result
return|;
name|_output_error
label|:
name|result
operator|=
literal|1
expr_stmt|;
goto|goto
name|_cleanup
goto|;
block|}
end_function

begin_comment
comment|/*-******************************************************* *  Command line *********************************************************/
end_comment

begin_function
name|int
name|FUZ_usage
parameter_list|(
specifier|const
name|char
modifier|*
name|programName
parameter_list|)
block|{
name|DISPLAY
argument_list|(
literal|"Usage :\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"      %s [args]\n"
argument_list|,
name|programName
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"Arguments :\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -i#    : Nb of tests (default:%u) \n"
argument_list|,
name|nbTestsDefault
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -s#    : Select seed (default:prompt user)\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -t#    : Select starting test number (default:0)\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -P#    : Select compressibility in %% (default:%i%%)\n"
argument_list|,
name|FUZ_COMPRESSIBILITY_DEFAULT
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -v     : verbose\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -p     : pause at the end\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -h     : display help and exit\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|U32
name|seed
init|=
literal|0
decl_stmt|;
name|int
name|seedset
init|=
literal|0
decl_stmt|;
name|int
name|argNb
decl_stmt|;
name|int
name|nbTests
init|=
name|nbTestsDefault
decl_stmt|;
name|int
name|testNb
init|=
literal|0
decl_stmt|;
name|int
name|proba
init|=
name|FUZ_COMPRESSIBILITY_DEFAULT
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
name|U32
name|mainPause
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|programName
init|=
name|argv
index|[
literal|0
index|]
decl_stmt|;
name|ZSTD_customMem
name|customMem
init|=
block|{
name|ZBUFF_allocFunction
block|,
name|ZBUFF_freeFunction
block|,
name|NULL
block|}
decl_stmt|;
name|ZSTD_customMem
name|customNULL
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
comment|/* Check command line */
for|for
control|(
name|argNb
operator|=
literal|1
init|;
name|argNb
operator|<
name|argc
condition|;
name|argNb
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|argument
init|=
name|argv
index|[
name|argNb
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|argument
condition|)
continue|continue;
comment|/* Protection if argument empty */
comment|/* Parsing commands. Aggregated commands are allowed */
if|if
condition|(
name|argument
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|argument
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|argument
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
operator|*
name|argument
condition|)
block|{
case|case
literal|'h'
case|:
return|return
name|FUZ_usage
argument_list|(
name|programName
argument_list|)
return|;
case|case
literal|'v'
case|:
name|argument
operator|++
expr_stmt|;
name|g_displayLevel
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|argument
operator|++
expr_stmt|;
name|g_displayLevel
operator|--
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* pause at the end */
name|argument
operator|++
expr_stmt|;
name|mainPause
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|argument
operator|++
expr_stmt|;
name|nbTests
operator|=
literal|0
expr_stmt|;
name|g_clockTime
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|argument
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|argument
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|nbTests
operator|*=
literal|10
expr_stmt|;
name|nbTests
operator|+=
operator|*
name|argument
operator|-
literal|'0'
expr_stmt|;
name|argument
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'T'
case|:
name|argument
operator|++
expr_stmt|;
name|nbTests
operator|=
literal|0
expr_stmt|;
name|g_clockTime
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|argument
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|argument
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|g_clockTime
operator|*=
literal|10
expr_stmt|;
name|g_clockTime
operator|+=
operator|*
name|argument
operator|-
literal|'0'
expr_stmt|;
name|argument
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|argument
operator|==
literal|'m'
condition|)
name|g_clockTime
operator|*=
literal|60
operator|,
name|argument
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|argument
operator|==
literal|'n'
condition|)
name|argument
operator|++
expr_stmt|;
name|g_clockTime
operator|*=
name|CLOCKS_PER_SEC
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|argument
operator|++
expr_stmt|;
name|seed
operator|=
literal|0
expr_stmt|;
name|seedset
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|argument
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|argument
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|seed
operator|*=
literal|10
expr_stmt|;
name|seed
operator|+=
operator|*
name|argument
operator|-
literal|'0'
expr_stmt|;
name|argument
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'t'
case|:
name|argument
operator|++
expr_stmt|;
name|testNb
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|argument
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|argument
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|testNb
operator|*=
literal|10
expr_stmt|;
name|testNb
operator|+=
operator|*
name|argument
operator|-
literal|'0'
expr_stmt|;
name|argument
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'P'
case|:
comment|/* compressibility % */
name|argument
operator|++
expr_stmt|;
name|proba
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|argument
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|argument
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|proba
operator|*=
literal|10
expr_stmt|;
name|proba
operator|+=
operator|*
name|argument
operator|-
literal|'0'
expr_stmt|;
name|argument
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|proba
operator|<
literal|0
condition|)
name|proba
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|proba
operator|>
literal|100
condition|)
name|proba
operator|=
literal|100
expr_stmt|;
break|break;
default|default:
return|return
name|FUZ_usage
argument_list|(
name|programName
argument_list|)
return|;
block|}
block|}
block|}
block|}
comment|/* for(argNb=1; argNb<argc; argNb++) */
comment|/* Get Seed */
name|DISPLAY
argument_list|(
literal|"Starting zstd_buffered tester (%i-bits, %s)\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|*
literal|8
argument_list|)
argument_list|,
name|ZSTD_VERSION_STRING
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|seedset
condition|)
block|{
name|time_t
specifier|const
name|t
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|U32
specifier|const
name|h
init|=
name|XXH32
argument_list|(
operator|&
name|t
argument_list|,
sizeof|sizeof
argument_list|(
name|t
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|seed
operator|=
name|h
operator|%
literal|10000
expr_stmt|;
block|}
name|DISPLAY
argument_list|(
literal|"Seed = %u\n"
argument_list|,
name|seed
argument_list|)
expr_stmt|;
if|if
condition|(
name|proba
operator|!=
name|FUZ_COMPRESSIBILITY_DEFAULT
condition|)
name|DISPLAY
argument_list|(
literal|"Compressibility : %i%%\n"
argument_list|,
name|proba
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbTests
operator|<=
literal|0
condition|)
name|nbTests
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|testNb
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|basicUnitTests
argument_list|(
literal|0
argument_list|,
operator|(
operator|(
name|double
operator|)
name|proba
operator|)
operator|/
literal|100
argument_list|,
name|customNULL
argument_list|)
expr_stmt|;
comment|/* constant seed for predictability */
if|if
condition|(
operator|!
name|result
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|4
argument_list|,
literal|"Unit tests using customMem :\n"
argument_list|)
name|result
operator|=
name|basicUnitTests
argument_list|(
literal|0
argument_list|,
operator|(
operator|(
name|double
operator|)
name|proba
operator|)
operator|/
literal|100
argument_list|,
name|customMem
argument_list|)
expr_stmt|;
comment|/* use custom memory allocation functions */
block|}
block|}
if|if
condition|(
operator|!
name|result
condition|)
name|result
operator|=
name|fuzzerTests
argument_list|(
name|seed
argument_list|,
name|nbTests
argument_list|,
name|testNb
argument_list|,
operator|(
operator|(
name|double
operator|)
name|proba
operator|)
operator|/
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|mainPause
condition|)
block|{
name|int
name|unused
decl_stmt|;
name|DISPLAY
argument_list|(
literal|"Press Enter \n"
argument_list|)
expr_stmt|;
name|unused
operator|=
name|getchar
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|unused
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

end_unit

