begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2017-present, Facebook, Inc.  * All rights reserved.  *  * This source code is licensed under the BSD-style license found in the  * LICENSE file in the root directory of this source tree. An additional grant  * of patent rights can be found in the PATENTS file in the same directory.  */
end_comment

begin_comment
comment|/// Zstandard educational decoder implementation
end_comment

begin_comment
comment|/// See https://github.com/facebook/zstd/blob/dev/doc/zstd_compression_format.md
end_comment

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/// Zstandard decompression functions.
end_comment

begin_comment
comment|/// `dst` must point to a space at least as large as the reconstructed output.
end_comment

begin_function_decl
name|size_t
name|ZSTD_decompress
parameter_list|(
name|void
modifier|*
specifier|const
name|dst
parameter_list|,
specifier|const
name|size_t
name|dst_len
parameter_list|,
specifier|const
name|void
modifier|*
specifier|const
name|src
parameter_list|,
specifier|const
name|size_t
name|src_len
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// If `dict != NULL` and `dict_len>= 8`, does the same thing as
end_comment

begin_comment
comment|/// `ZSTD_decompress` but uses the provided dict
end_comment

begin_function_decl
name|size_t
name|ZSTD_decompress_with_dict
parameter_list|(
name|void
modifier|*
specifier|const
name|dst
parameter_list|,
specifier|const
name|size_t
name|dst_len
parameter_list|,
specifier|const
name|void
modifier|*
specifier|const
name|src
parameter_list|,
specifier|const
name|size_t
name|src_len
parameter_list|,
specifier|const
name|void
modifier|*
specifier|const
name|dict
parameter_list|,
specifier|const
name|size_t
name|dict_len
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// Get the decompressed size of an input stream so memory can be allocated in
end_comment

begin_comment
comment|/// advance
end_comment

begin_comment
comment|/// Returns -1 if the size can't be determined
end_comment

begin_function_decl
name|size_t
name|ZSTD_get_decompressed_size
parameter_list|(
specifier|const
name|void
modifier|*
specifier|const
name|src
parameter_list|,
specifier|const
name|size_t
name|src_len
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/******* UTILITY MACROS AND TYPES *********************************************/
end_comment

begin_comment
comment|// Max block size decompressed size is 128 KB and literal blocks can't be
end_comment

begin_comment
comment|// larger than their block
end_comment

begin_define
define|#
directive|define
name|MAX_LITERALS_SIZE
value|((size_t)128 * 1024)
end_define

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_comment
comment|/// This decoder calls exit(1) when it encounters an error, however a production
end_comment

begin_comment
comment|/// library should propagate error codes
end_comment

begin_define
define|#
directive|define
name|ERROR
parameter_list|(
name|s
parameter_list|)
define|\
value|do {                                                                       \         fprintf(stderr, "Error: %s\n", s);                                     \         exit(1);                                                               \     } while (0)
end_define

begin_define
define|#
directive|define
name|INP_SIZE
parameter_list|()
define|\
value|ERROR("Input buffer smaller than it should be or input is "                \           "corrupted")
end_define

begin_define
define|#
directive|define
name|OUT_SIZE
parameter_list|()
value|ERROR("Output buffer too small for output")
end_define

begin_define
define|#
directive|define
name|CORRUPTION
parameter_list|()
value|ERROR("Corruption detected while decompressing")
end_define

begin_define
define|#
directive|define
name|BAD_ALLOC
parameter_list|()
value|ERROR("Memory allocation error")
end_define

begin_define
define|#
directive|define
name|IMPOSSIBLE
parameter_list|()
value|ERROR("An impossibility has occurred")
end_define

begin_typedef
typedef|typedef
name|uint8_t
name|u8
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|uint16_t
name|u16
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|uint32_t
name|u32
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|uint64_t
name|u64
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|int8_t
name|i8
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|int16_t
name|i16
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|int32_t
name|i32
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|int64_t
name|i64
typedef|;
end_typedef

begin_comment
comment|/******* END UTILITY MACROS AND TYPES *****************************************/
end_comment

begin_comment
comment|/******* IMPLEMENTATION PRIMITIVE PROTOTYPES **********************************/
end_comment

begin_comment
comment|/// The implementations for these functions can be found at the bottom of this
end_comment

begin_comment
comment|/// file.  They implement low-level functionality needed for the higher level
end_comment

begin_comment
comment|/// decompression functions.
end_comment

begin_comment
comment|/*** IO STREAM OPERATIONS *************/
end_comment

begin_comment
comment|/// ostream_t/istream_t are used to wrap the pointers/length data passed into
end_comment

begin_comment
comment|/// ZSTD_decompress, so that all IO operations are safely bounds checked
end_comment

begin_comment
comment|/// They are written/read forward, and reads are treated as little-endian
end_comment

begin_comment
comment|/// They should be used opaquely to ensure safety
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|u8
modifier|*
name|ptr
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|}
name|ostream_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|u8
modifier|*
name|ptr
decl_stmt|;
name|size_t
name|len
decl_stmt|;
comment|// Input often reads a few bits at a time, so maintain an internal offset
name|int
name|bit_offset
decl_stmt|;
block|}
name|istream_t
typedef|;
end_typedef

begin_comment
comment|/// The following two functions are the only ones that allow the istream to be
end_comment

begin_comment
comment|/// non-byte aligned
end_comment

begin_comment
comment|/// Reads `num` bits from a bitstream, and updates the internal offset
end_comment

begin_function_decl
specifier|static
specifier|inline
name|u64
name|IO_read_bits
parameter_list|(
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|,
specifier|const
name|int
name|num_bits
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// Backs-up the stream by `num` bits so they can be read again
end_comment

begin_function_decl
specifier|static
specifier|inline
name|void
name|IO_rewind_bits
parameter_list|(
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|,
specifier|const
name|int
name|num_bits
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// If the remaining bits in a byte will be unused, advance to the end of the
end_comment

begin_comment
comment|/// byte
end_comment

begin_function_decl
specifier|static
specifier|inline
name|void
name|IO_align_stream
parameter_list|(
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// Write the given byte into the output stream
end_comment

begin_function_decl
specifier|static
specifier|inline
name|void
name|IO_write_byte
parameter_list|(
name|ostream_t
modifier|*
specifier|const
name|out
parameter_list|,
name|u8
name|symb
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// Returns the number of bytes left to be read in this stream.  The stream must
end_comment

begin_comment
comment|/// be byte aligned.
end_comment

begin_function_decl
specifier|static
specifier|inline
name|size_t
name|IO_istream_len
parameter_list|(
specifier|const
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// Advances the stream by `len` bytes, and returns a pointer to the chunk that
end_comment

begin_comment
comment|/// was skipped.  The stream must be byte aligned.
end_comment

begin_function_decl
specifier|static
specifier|inline
specifier|const
name|u8
modifier|*
name|IO_read_bytes
parameter_list|(
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// Advances the stream by `len` bytes, and returns a pointer to the chunk that
end_comment

begin_comment
comment|/// was skipped so it can be written to.
end_comment

begin_function_decl
specifier|static
specifier|inline
name|u8
modifier|*
name|IO_write_bytes
parameter_list|(
name|ostream_t
modifier|*
specifier|const
name|out
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// Advance the inner state by `len` bytes.  The stream must be byte aligned.
end_comment

begin_function_decl
specifier|static
specifier|inline
name|void
name|IO_advance_input
parameter_list|(
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// Returns an `ostream_t` constructed from the given pointer and length.
end_comment

begin_function_decl
specifier|static
specifier|inline
name|ostream_t
name|IO_make_ostream
parameter_list|(
name|u8
modifier|*
name|out
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// Returns an `istream_t` constructed from the given pointer and length.
end_comment

begin_function_decl
specifier|static
specifier|inline
name|istream_t
name|IO_make_istream
parameter_list|(
specifier|const
name|u8
modifier|*
name|in
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// Returns an `istream_t` with the same base as `in`, and length `len`.
end_comment

begin_comment
comment|/// Then, advance `in` to account for the consumed bytes.
end_comment

begin_comment
comment|/// `in` must be byte aligned.
end_comment

begin_function_decl
specifier|static
specifier|inline
name|istream_t
name|IO_make_sub_istream
parameter_list|(
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*** END IO STREAM OPERATIONS *********/
end_comment

begin_comment
comment|/*** BITSTREAM OPERATIONS *************/
end_comment

begin_comment
comment|/// Read `num` bits (up to 64) from `src + offset`, where `offset` is in bits,
end_comment

begin_comment
comment|/// and return them interpreted as a little-endian unsigned integer.
end_comment

begin_function_decl
specifier|static
specifier|inline
name|u64
name|read_bits_LE
parameter_list|(
specifier|const
name|u8
modifier|*
name|src
parameter_list|,
specifier|const
name|int
name|num_bits
parameter_list|,
specifier|const
name|size_t
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// Read bits from the end of a HUF or FSE bitstream.  `offset` is in bits, so
end_comment

begin_comment
comment|/// it updates `offset` to `offset - bits`, and then reads `bits` bits from
end_comment

begin_comment
comment|/// `src + offset`.  If the offset becomes negative, the extra bits at the
end_comment

begin_comment
comment|/// bottom are filled in with `0` bits instead of reading from before `src`.
end_comment

begin_function_decl
specifier|static
specifier|inline
name|u64
name|STREAM_read_bits
parameter_list|(
specifier|const
name|u8
modifier|*
name|src
parameter_list|,
specifier|const
name|int
name|bits
parameter_list|,
name|i64
modifier|*
specifier|const
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*** END BITSTREAM OPERATIONS *********/
end_comment

begin_comment
comment|/*** BIT COUNTING OPERATIONS **********/
end_comment

begin_comment
comment|/// Returns the index of the highest set bit in `num`, or `-1` if `num == 0`
end_comment

begin_function_decl
specifier|static
specifier|inline
name|int
name|highest_set_bit
parameter_list|(
specifier|const
name|u64
name|num
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*** END BIT COUNTING OPERATIONS ******/
end_comment

begin_comment
comment|/*** HUFFMAN PRIMITIVES ***************/
end_comment

begin_comment
comment|// Table decode method uses exponential memory, so we need to limit depth
end_comment

begin_define
define|#
directive|define
name|HUF_MAX_BITS
value|(16)
end_define

begin_comment
comment|// Limit the maximum number of symbols to 256 so we can store a symbol in a byte
end_comment

begin_define
define|#
directive|define
name|HUF_MAX_SYMBS
value|(256)
end_define

begin_comment
comment|/// Structure containing all tables necessary for efficient Huffman decoding
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|u8
modifier|*
name|symbols
decl_stmt|;
name|u8
modifier|*
name|num_bits
decl_stmt|;
name|int
name|max_bits
decl_stmt|;
block|}
name|HUF_dtable
typedef|;
end_typedef

begin_comment
comment|/// Decode a single symbol and read in enough bits to refresh the state
end_comment

begin_function_decl
specifier|static
specifier|inline
name|u8
name|HUF_decode_symbol
parameter_list|(
specifier|const
name|HUF_dtable
modifier|*
specifier|const
name|dtable
parameter_list|,
name|u16
modifier|*
specifier|const
name|state
parameter_list|,
specifier|const
name|u8
modifier|*
specifier|const
name|src
parameter_list|,
name|i64
modifier|*
specifier|const
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// Read in a full state's worth of bits to initialize it
end_comment

begin_function_decl
specifier|static
specifier|inline
name|void
name|HUF_init_state
parameter_list|(
specifier|const
name|HUF_dtable
modifier|*
specifier|const
name|dtable
parameter_list|,
name|u16
modifier|*
specifier|const
name|state
parameter_list|,
specifier|const
name|u8
modifier|*
specifier|const
name|src
parameter_list|,
name|i64
modifier|*
specifier|const
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// Decompresses a single Huffman stream, returns the number of bytes decoded.
end_comment

begin_comment
comment|/// `src_len` must be the exact length of the Huffman-coded block.
end_comment

begin_function_decl
specifier|static
name|size_t
name|HUF_decompress_1stream
parameter_list|(
specifier|const
name|HUF_dtable
modifier|*
specifier|const
name|dtable
parameter_list|,
name|ostream_t
modifier|*
specifier|const
name|out
parameter_list|,
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// Same as previous but decodes 4 streams, formatted as in the Zstandard
end_comment

begin_comment
comment|/// specification.
end_comment

begin_comment
comment|/// `src_len` must be the exact length of the Huffman-coded block.
end_comment

begin_function_decl
specifier|static
name|size_t
name|HUF_decompress_4stream
parameter_list|(
specifier|const
name|HUF_dtable
modifier|*
specifier|const
name|dtable
parameter_list|,
name|ostream_t
modifier|*
specifier|const
name|out
parameter_list|,
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// Initialize a Huffman decoding table using the table of bit counts provided
end_comment

begin_function_decl
specifier|static
name|void
name|HUF_init_dtable
parameter_list|(
name|HUF_dtable
modifier|*
specifier|const
name|table
parameter_list|,
specifier|const
name|u8
modifier|*
specifier|const
name|bits
parameter_list|,
specifier|const
name|int
name|num_symbs
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// Initialize a Huffman decoding table using the table of weights provided
end_comment

begin_comment
comment|/// Weights follow the definition provided in the Zstandard specification
end_comment

begin_function_decl
specifier|static
name|void
name|HUF_init_dtable_usingweights
parameter_list|(
name|HUF_dtable
modifier|*
specifier|const
name|table
parameter_list|,
specifier|const
name|u8
modifier|*
specifier|const
name|weights
parameter_list|,
specifier|const
name|int
name|num_symbs
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// Free the malloc'ed parts of a decoding table
end_comment

begin_function_decl
specifier|static
name|void
name|HUF_free_dtable
parameter_list|(
name|HUF_dtable
modifier|*
specifier|const
name|dtable
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// Deep copy a decoding table, so that it can be used and free'd without
end_comment

begin_comment
comment|/// impacting the source table.
end_comment

begin_function_decl
specifier|static
name|void
name|HUF_copy_dtable
parameter_list|(
name|HUF_dtable
modifier|*
specifier|const
name|dst
parameter_list|,
specifier|const
name|HUF_dtable
modifier|*
specifier|const
name|src
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*** END HUFFMAN PRIMITIVES ***********/
end_comment

begin_comment
comment|/*** FSE PRIMITIVES *******************/
end_comment

begin_comment
comment|/// For more description of FSE see
end_comment

begin_comment
comment|/// https://github.com/Cyan4973/FiniteStateEntropy/
end_comment

begin_comment
comment|// FSE table decoding uses exponential memory, so limit the maximum accuracy
end_comment

begin_define
define|#
directive|define
name|FSE_MAX_ACCURACY_LOG
value|(15)
end_define

begin_comment
comment|// Limit the maximum number of symbols so they can be stored in a single byte
end_comment

begin_define
define|#
directive|define
name|FSE_MAX_SYMBS
value|(256)
end_define

begin_comment
comment|/// The tables needed to decode FSE encoded streams
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|u8
modifier|*
name|symbols
decl_stmt|;
name|u8
modifier|*
name|num_bits
decl_stmt|;
name|u16
modifier|*
name|new_state_base
decl_stmt|;
name|int
name|accuracy_log
decl_stmt|;
block|}
name|FSE_dtable
typedef|;
end_typedef

begin_comment
comment|/// Return the symbol for the current state
end_comment

begin_function_decl
specifier|static
specifier|inline
name|u8
name|FSE_peek_symbol
parameter_list|(
specifier|const
name|FSE_dtable
modifier|*
specifier|const
name|dtable
parameter_list|,
specifier|const
name|u16
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// Read the number of bits necessary to update state, update, and shift offset
end_comment

begin_comment
comment|/// back to reflect the bits read
end_comment

begin_function_decl
specifier|static
specifier|inline
name|void
name|FSE_update_state
parameter_list|(
specifier|const
name|FSE_dtable
modifier|*
specifier|const
name|dtable
parameter_list|,
name|u16
modifier|*
specifier|const
name|state
parameter_list|,
specifier|const
name|u8
modifier|*
specifier|const
name|src
parameter_list|,
name|i64
modifier|*
specifier|const
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// Combine peek and update: decode a symbol and update the state
end_comment

begin_function_decl
specifier|static
specifier|inline
name|u8
name|FSE_decode_symbol
parameter_list|(
specifier|const
name|FSE_dtable
modifier|*
specifier|const
name|dtable
parameter_list|,
name|u16
modifier|*
specifier|const
name|state
parameter_list|,
specifier|const
name|u8
modifier|*
specifier|const
name|src
parameter_list|,
name|i64
modifier|*
specifier|const
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// Read bits from the stream to initialize the state and shift offset back
end_comment

begin_function_decl
specifier|static
specifier|inline
name|void
name|FSE_init_state
parameter_list|(
specifier|const
name|FSE_dtable
modifier|*
specifier|const
name|dtable
parameter_list|,
name|u16
modifier|*
specifier|const
name|state
parameter_list|,
specifier|const
name|u8
modifier|*
specifier|const
name|src
parameter_list|,
name|i64
modifier|*
specifier|const
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// Decompress two interleaved bitstreams (e.g. compressed Huffman weights)
end_comment

begin_comment
comment|/// using an FSE decoding table.  `src_len` must be the exact length of the
end_comment

begin_comment
comment|/// block.
end_comment

begin_function_decl
specifier|static
name|size_t
name|FSE_decompress_interleaved2
parameter_list|(
specifier|const
name|FSE_dtable
modifier|*
specifier|const
name|dtable
parameter_list|,
name|ostream_t
modifier|*
specifier|const
name|out
parameter_list|,
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// Initialize a decoding table using normalized frequencies.
end_comment

begin_function_decl
specifier|static
name|void
name|FSE_init_dtable
parameter_list|(
name|FSE_dtable
modifier|*
specifier|const
name|dtable
parameter_list|,
specifier|const
name|i16
modifier|*
specifier|const
name|norm_freqs
parameter_list|,
specifier|const
name|int
name|num_symbs
parameter_list|,
specifier|const
name|int
name|accuracy_log
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// Decode an FSE header as defined in the Zstandard format specification and
end_comment

begin_comment
comment|/// use the decoded frequencies to initialize a decoding table.
end_comment

begin_function_decl
specifier|static
name|void
name|FSE_decode_header
parameter_list|(
name|FSE_dtable
modifier|*
specifier|const
name|dtable
parameter_list|,
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|,
specifier|const
name|int
name|max_accuracy_log
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// Initialize an FSE table that will always return the same symbol and consume
end_comment

begin_comment
comment|/// 0 bits per symbol, to be used for RLE mode in sequence commands
end_comment

begin_function_decl
specifier|static
name|void
name|FSE_init_dtable_rle
parameter_list|(
name|FSE_dtable
modifier|*
specifier|const
name|dtable
parameter_list|,
specifier|const
name|u8
name|symb
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// Free the malloc'ed parts of a decoding table
end_comment

begin_function_decl
specifier|static
name|void
name|FSE_free_dtable
parameter_list|(
name|FSE_dtable
modifier|*
specifier|const
name|dtable
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// Deep copy a decoding table, so that it can be used and free'd without
end_comment

begin_comment
comment|/// impacting the source table.
end_comment

begin_function_decl
specifier|static
name|void
name|FSE_copy_dtable
parameter_list|(
name|FSE_dtable
modifier|*
specifier|const
name|dst
parameter_list|,
specifier|const
name|FSE_dtable
modifier|*
specifier|const
name|src
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*** END FSE PRIMITIVES ***************/
end_comment

begin_comment
comment|/******* END IMPLEMENTATION PRIMITIVE PROTOTYPES ******************************/
end_comment

begin_comment
comment|/******* ZSTD HELPER STRUCTS AND PROTOTYPES ***********************************/
end_comment

begin_comment
comment|/// A small structure that can be reused in various places that need to access
end_comment

begin_comment
comment|/// frame header information
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
comment|// The size of window that we need to be able to contiguously store for
comment|// references
name|size_t
name|window_size
decl_stmt|;
comment|// The total output size of this compressed frame
name|size_t
name|frame_content_size
decl_stmt|;
comment|// The dictionary id if this frame uses one
name|u32
name|dictionary_id
decl_stmt|;
comment|// Whether or not the content of this frame has a checksum
name|int
name|content_checksum_flag
decl_stmt|;
comment|// Whether or not the output for this frame is in a single segment
name|int
name|single_segment_flag
decl_stmt|;
block|}
name|frame_header_t
typedef|;
end_typedef

begin_comment
comment|/// The context needed to decode blocks in a frame
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|frame_header_t
name|header
decl_stmt|;
comment|// The total amount of data available for backreferences, to determine if an
comment|// offset too large to be correct
name|size_t
name|current_total_output
decl_stmt|;
specifier|const
name|u8
modifier|*
name|dict_content
decl_stmt|;
name|size_t
name|dict_content_len
decl_stmt|;
comment|// Entropy encoding tables so they can be repeated by future blocks instead
comment|// of retransmitting
name|HUF_dtable
name|literals_dtable
decl_stmt|;
name|FSE_dtable
name|ll_dtable
decl_stmt|;
name|FSE_dtable
name|ml_dtable
decl_stmt|;
name|FSE_dtable
name|of_dtable
decl_stmt|;
comment|// The last 3 offsets for the special "repeat offsets".
name|u64
name|previous_offsets
index|[
literal|3
index|]
decl_stmt|;
block|}
name|frame_context_t
typedef|;
end_typedef

begin_comment
comment|/// The decoded contents of a dictionary so that it doesn't have to be repeated
end_comment

begin_comment
comment|/// for each frame that uses it
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
comment|// Entropy tables
name|HUF_dtable
name|literals_dtable
decl_stmt|;
name|FSE_dtable
name|ll_dtable
decl_stmt|;
name|FSE_dtable
name|ml_dtable
decl_stmt|;
name|FSE_dtable
name|of_dtable
decl_stmt|;
comment|// Raw content for backreferences
name|u8
modifier|*
name|content
decl_stmt|;
name|size_t
name|content_size
decl_stmt|;
comment|// Offset history to prepopulate the frame's history
name|u64
name|previous_offsets
index|[
literal|3
index|]
decl_stmt|;
name|u32
name|dictionary_id
decl_stmt|;
block|}
name|dictionary_t
typedef|;
end_typedef

begin_comment
comment|/// A tuple containing the parts necessary to decode and execute a ZSTD sequence
end_comment

begin_comment
comment|/// command
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|u32
name|literal_length
decl_stmt|;
name|u32
name|match_length
decl_stmt|;
name|u32
name|offset
decl_stmt|;
block|}
name|sequence_command_t
typedef|;
end_typedef

begin_comment
comment|/// The decoder works top-down, starting at the high level like Zstd frames, and
end_comment

begin_comment
comment|/// working down to lower more technical levels such as blocks, literals, and
end_comment

begin_comment
comment|/// sequences.  The high-level functions roughly follow the outline of the
end_comment

begin_comment
comment|/// format specification:
end_comment

begin_comment
comment|/// https://github.com/facebook/zstd/blob/dev/doc/zstd_compression_format.md
end_comment

begin_comment
comment|/// Before the implementation of each high-level function declared here, the
end_comment

begin_comment
comment|/// prototypes for their helper functions are defined and explained
end_comment

begin_comment
comment|/// Decode a single Zstd frame, or error if the input is not a valid frame.
end_comment

begin_comment
comment|/// Accepts a dict argument, which may be NULL indicating no dictionary.
end_comment

begin_comment
comment|/// See
end_comment

begin_comment
comment|/// https://github.com/facebook/zstd/blob/dev/doc/zstd_compression_format.md#frame-concatenation
end_comment

begin_function_decl
specifier|static
name|void
name|decode_frame
parameter_list|(
name|ostream_t
modifier|*
specifier|const
name|out
parameter_list|,
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|,
specifier|const
name|dictionary_t
modifier|*
specifier|const
name|dict
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// Decode data in a compressed block
end_comment

begin_function_decl
specifier|static
name|void
name|decompress_block
parameter_list|(
name|frame_context_t
modifier|*
specifier|const
name|ctx
parameter_list|,
name|ostream_t
modifier|*
specifier|const
name|out
parameter_list|,
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// Decode the literals section of a block
end_comment

begin_function_decl
specifier|static
name|size_t
name|decode_literals
parameter_list|(
name|frame_context_t
modifier|*
specifier|const
name|ctx
parameter_list|,
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|,
name|u8
modifier|*
modifier|*
specifier|const
name|literals
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// Decode the sequences part of a block
end_comment

begin_function_decl
specifier|static
name|size_t
name|decode_sequences
parameter_list|(
name|frame_context_t
modifier|*
specifier|const
name|ctx
parameter_list|,
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|,
name|sequence_command_t
modifier|*
modifier|*
specifier|const
name|sequences
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// Execute the decoded sequences on the literals block
end_comment

begin_function_decl
specifier|static
name|void
name|execute_sequences
parameter_list|(
name|frame_context_t
modifier|*
specifier|const
name|ctx
parameter_list|,
name|ostream_t
modifier|*
specifier|const
name|out
parameter_list|,
specifier|const
name|u8
modifier|*
specifier|const
name|literals
parameter_list|,
specifier|const
name|size_t
name|literals_len
parameter_list|,
specifier|const
name|sequence_command_t
modifier|*
specifier|const
name|sequences
parameter_list|,
specifier|const
name|size_t
name|num_sequences
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// Parse a provided dictionary blob for use in decompression
end_comment

begin_function_decl
specifier|static
name|void
name|parse_dictionary
parameter_list|(
name|dictionary_t
modifier|*
specifier|const
name|dict
parameter_list|,
specifier|const
name|u8
modifier|*
name|src
parameter_list|,
name|size_t
name|src_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_dictionary
parameter_list|(
name|dictionary_t
modifier|*
specifier|const
name|dict
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/******* END ZSTD HELPER STRUCTS AND PROTOTYPES *******************************/
end_comment

begin_function
name|size_t
name|ZSTD_decompress
parameter_list|(
name|void
modifier|*
specifier|const
name|dst
parameter_list|,
specifier|const
name|size_t
name|dst_len
parameter_list|,
specifier|const
name|void
modifier|*
specifier|const
name|src
parameter_list|,
specifier|const
name|size_t
name|src_len
parameter_list|)
block|{
return|return
name|ZSTD_decompress_with_dict
argument_list|(
name|dst
argument_list|,
name|dst_len
argument_list|,
name|src
argument_list|,
name|src_len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTD_decompress_with_dict
parameter_list|(
name|void
modifier|*
specifier|const
name|dst
parameter_list|,
specifier|const
name|size_t
name|dst_len
parameter_list|,
specifier|const
name|void
modifier|*
specifier|const
name|src
parameter_list|,
specifier|const
name|size_t
name|src_len
parameter_list|,
specifier|const
name|void
modifier|*
specifier|const
name|dict
parameter_list|,
specifier|const
name|size_t
name|dict_len
parameter_list|)
block|{
name|dictionary_t
name|parsed_dict
decl_stmt|;
name|memset
argument_list|(
operator|&
name|parsed_dict
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dictionary_t
argument_list|)
argument_list|)
expr_stmt|;
comment|// dict_len< 8 is not a valid dictionary
if|if
condition|(
name|dict
operator|&&
name|dict_len
operator|>
literal|8
condition|)
block|{
name|parse_dictionary
argument_list|(
operator|&
name|parsed_dict
argument_list|,
operator|(
specifier|const
name|u8
operator|*
operator|)
name|dict
argument_list|,
name|dict_len
argument_list|)
expr_stmt|;
block|}
name|istream_t
name|in
init|=
name|IO_make_istream
argument_list|(
name|src
argument_list|,
name|src_len
argument_list|)
decl_stmt|;
name|ostream_t
name|out
init|=
name|IO_make_ostream
argument_list|(
name|dst
argument_list|,
name|dst_len
argument_list|)
decl_stmt|;
comment|// "A content compressed by Zstandard is transformed into a Zstandard frame.
comment|// Multiple frames can be appended into a single file or stream. A frame is
comment|// totally independent, has a defined beginning and end, and a set of
comment|// parameters which tells the decoder how to decompress it."
while|while
condition|(
name|IO_istream_len
argument_list|(
operator|&
name|in
argument_list|)
operator|>
literal|0
condition|)
block|{
name|decode_frame
argument_list|(
operator|&
name|out
argument_list|,
operator|&
name|in
argument_list|,
operator|&
name|parsed_dict
argument_list|)
expr_stmt|;
block|}
name|free_dictionary
argument_list|(
operator|&
name|parsed_dict
argument_list|)
expr_stmt|;
return|return
name|out
operator|.
name|ptr
operator|-
operator|(
name|u8
operator|*
operator|)
name|dst
return|;
block|}
end_function

begin_comment
comment|/******* FRAME DECODING ******************************************************/
end_comment

begin_function_decl
specifier|static
name|void
name|decode_data_frame
parameter_list|(
name|ostream_t
modifier|*
specifier|const
name|out
parameter_list|,
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|,
specifier|const
name|dictionary_t
modifier|*
specifier|const
name|dict
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_frame_context
parameter_list|(
name|frame_context_t
modifier|*
specifier|const
name|context
parameter_list|,
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|,
specifier|const
name|dictionary_t
modifier|*
specifier|const
name|dict
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_frame_context
parameter_list|(
name|frame_context_t
modifier|*
specifier|const
name|context
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_frame_header
parameter_list|(
name|frame_header_t
modifier|*
specifier|const
name|header
parameter_list|,
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|frame_context_apply_dict
parameter_list|(
name|frame_context_t
modifier|*
specifier|const
name|ctx
parameter_list|,
specifier|const
name|dictionary_t
modifier|*
specifier|const
name|dict
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|decompress_data
parameter_list|(
name|frame_context_t
modifier|*
specifier|const
name|ctx
parameter_list|,
name|ostream_t
modifier|*
specifier|const
name|out
parameter_list|,
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|decode_frame
parameter_list|(
name|ostream_t
modifier|*
specifier|const
name|out
parameter_list|,
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|,
specifier|const
name|dictionary_t
modifier|*
specifier|const
name|dict
parameter_list|)
block|{
specifier|const
name|u32
name|magic_number
init|=
name|IO_read_bits
argument_list|(
name|in
argument_list|,
literal|32
argument_list|)
decl_stmt|;
comment|// Skippable frame
comment|//
comment|// "Magic_Number
comment|//
comment|// 4 Bytes, little-endian format. Value : 0x184D2A5?, which means any value
comment|// from 0x184D2A50 to 0x184D2A5F. All 16 values are valid to identify a
comment|// skippable frame."
if|if
condition|(
operator|(
name|magic_number
operator|&
operator|~
literal|0xFU
operator|)
operator|==
literal|0x184D2A50U
condition|)
block|{
comment|// "Skippable frames allow the insertion of user-defined data into a
comment|// flow of concatenated frames. Its design is pretty straightforward,
comment|// with the sole objective to allow the decoder to quickly skip over
comment|// user-defined data and continue decoding.
comment|//
comment|// Skippable frames defined in this specification are compatible with
comment|// LZ4 ones."
specifier|const
name|size_t
name|frame_size
init|=
name|IO_read_bits
argument_list|(
name|in
argument_list|,
literal|32
argument_list|)
decl_stmt|;
comment|// skip over frame
name|IO_advance_input
argument_list|(
name|in
argument_list|,
name|frame_size
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Zstandard frame
comment|//
comment|// "Magic_Number
comment|//
comment|// 4 Bytes, little-endian format. Value : 0xFD2FB528"
if|if
condition|(
name|magic_number
operator|==
literal|0xFD2FB528U
condition|)
block|{
comment|// ZSTD frame
name|decode_data_frame
argument_list|(
name|out
argument_list|,
name|in
argument_list|,
name|dict
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// not a real frame
name|ERROR
argument_list|(
literal|"Invalid magic number"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// Decode a frame that contains compressed data.  Not all frames do as there
end_comment

begin_comment
comment|/// are skippable frames.
end_comment

begin_comment
comment|/// See
end_comment

begin_comment
comment|/// https://github.com/facebook/zstd/blob/dev/doc/zstd_compression_format.md#general-structure-of-zstandard-frame-format
end_comment

begin_function
specifier|static
name|void
name|decode_data_frame
parameter_list|(
name|ostream_t
modifier|*
specifier|const
name|out
parameter_list|,
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|,
specifier|const
name|dictionary_t
modifier|*
specifier|const
name|dict
parameter_list|)
block|{
name|frame_context_t
name|ctx
decl_stmt|;
comment|// Initialize the context that needs to be carried from block to block
name|init_frame_context
argument_list|(
operator|&
name|ctx
argument_list|,
name|in
argument_list|,
name|dict
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|.
name|header
operator|.
name|frame_content_size
operator|!=
literal|0
operator|&&
name|ctx
operator|.
name|header
operator|.
name|frame_content_size
operator|>
name|out
operator|->
name|len
condition|)
block|{
name|OUT_SIZE
argument_list|()
expr_stmt|;
block|}
name|decompress_data
argument_list|(
operator|&
name|ctx
argument_list|,
name|out
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|free_frame_context
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// Takes the information provided in the header and dictionary, and initializes
end_comment

begin_comment
comment|/// the context for this frame
end_comment

begin_function
specifier|static
name|void
name|init_frame_context
parameter_list|(
name|frame_context_t
modifier|*
specifier|const
name|context
parameter_list|,
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|,
specifier|const
name|dictionary_t
modifier|*
specifier|const
name|dict
parameter_list|)
block|{
comment|// Most fields in context are correct when initialized to 0
name|memset
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|frame_context_t
argument_list|)
argument_list|)
expr_stmt|;
comment|// Parse data from the frame header
name|parse_frame_header
argument_list|(
operator|&
name|context
operator|->
name|header
argument_list|,
name|in
argument_list|)
expr_stmt|;
comment|// Set up the offset history for the repeat offset commands
name|context
operator|->
name|previous_offsets
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|context
operator|->
name|previous_offsets
index|[
literal|1
index|]
operator|=
literal|4
expr_stmt|;
name|context
operator|->
name|previous_offsets
index|[
literal|2
index|]
operator|=
literal|8
expr_stmt|;
comment|// Apply details from the dict if it exists
name|frame_context_apply_dict
argument_list|(
name|context
argument_list|,
name|dict
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_frame_context
parameter_list|(
name|frame_context_t
modifier|*
specifier|const
name|context
parameter_list|)
block|{
name|HUF_free_dtable
argument_list|(
operator|&
name|context
operator|->
name|literals_dtable
argument_list|)
expr_stmt|;
name|FSE_free_dtable
argument_list|(
operator|&
name|context
operator|->
name|ll_dtable
argument_list|)
expr_stmt|;
name|FSE_free_dtable
argument_list|(
operator|&
name|context
operator|->
name|ml_dtable
argument_list|)
expr_stmt|;
name|FSE_free_dtable
argument_list|(
operator|&
name|context
operator|->
name|of_dtable
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|frame_context_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|parse_frame_header
parameter_list|(
name|frame_header_t
modifier|*
specifier|const
name|header
parameter_list|,
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|)
block|{
comment|// "The first header's byte is called the Frame_Header_Descriptor. It tells
comment|// which other fields are present. Decoding this byte is enough to tell the
comment|// size of Frame_Header.
comment|//
comment|// Bit number   Field name
comment|// 7-6  Frame_Content_Size_flag
comment|// 5    Single_Segment_flag
comment|// 4    Unused_bit
comment|// 3    Reserved_bit
comment|// 2    Content_Checksum_flag
comment|// 1-0  Dictionary_ID_flag"
specifier|const
name|u8
name|descriptor
init|=
name|IO_read_bits
argument_list|(
name|in
argument_list|,
literal|8
argument_list|)
decl_stmt|;
comment|// decode frame header descriptor into flags
specifier|const
name|u8
name|frame_content_size_flag
init|=
name|descriptor
operator|>>
literal|6
decl_stmt|;
specifier|const
name|u8
name|single_segment_flag
init|=
operator|(
name|descriptor
operator|>>
literal|5
operator|)
operator|&
literal|1
decl_stmt|;
specifier|const
name|u8
name|reserved_bit
init|=
operator|(
name|descriptor
operator|>>
literal|3
operator|)
operator|&
literal|1
decl_stmt|;
specifier|const
name|u8
name|content_checksum_flag
init|=
operator|(
name|descriptor
operator|>>
literal|2
operator|)
operator|&
literal|1
decl_stmt|;
specifier|const
name|u8
name|dictionary_id_flag
init|=
name|descriptor
operator|&
literal|3
decl_stmt|;
if|if
condition|(
name|reserved_bit
operator|!=
literal|0
condition|)
block|{
name|CORRUPTION
argument_list|()
expr_stmt|;
block|}
name|header
operator|->
name|single_segment_flag
operator|=
name|single_segment_flag
expr_stmt|;
name|header
operator|->
name|content_checksum_flag
operator|=
name|content_checksum_flag
expr_stmt|;
comment|// decode window size
if|if
condition|(
operator|!
name|single_segment_flag
condition|)
block|{
comment|// "Provides guarantees on maximum back-reference distance that will be
comment|// used within compressed data. This information is important for
comment|// decoders to allocate enough memory.
comment|//
comment|// Bit numbers  7-3         2-0
comment|// Field name   Exponent    Mantissa"
name|u8
name|window_descriptor
init|=
name|IO_read_bits
argument_list|(
name|in
argument_list|,
literal|8
argument_list|)
decl_stmt|;
name|u8
name|exponent
init|=
name|window_descriptor
operator|>>
literal|3
decl_stmt|;
name|u8
name|mantissa
init|=
name|window_descriptor
operator|&
literal|7
decl_stmt|;
comment|// Use the algorithm from the specification to compute window size
comment|// https://github.com/facebook/zstd/blob/dev/doc/zstd_compression_format.md#window_descriptor
name|size_t
name|window_base
init|=
operator|(
name|size_t
operator|)
literal|1
operator|<<
operator|(
literal|10
operator|+
name|exponent
operator|)
decl_stmt|;
name|size_t
name|window_add
init|=
operator|(
name|window_base
operator|/
literal|8
operator|)
operator|*
name|mantissa
decl_stmt|;
name|header
operator|->
name|window_size
operator|=
name|window_base
operator|+
name|window_add
expr_stmt|;
block|}
comment|// decode dictionary id if it exists
if|if
condition|(
name|dictionary_id_flag
condition|)
block|{
comment|// "This is a variable size field, which contains the ID of the
comment|// dictionary required to properly decode the frame. Note that this
comment|// field is optional. When it's not present, it's up to the caller to
comment|// make sure it uses the correct dictionary. Format is little-endian."
specifier|const
name|int
name|bytes_array
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|4
block|}
decl_stmt|;
specifier|const
name|int
name|bytes
init|=
name|bytes_array
index|[
name|dictionary_id_flag
index|]
decl_stmt|;
name|header
operator|->
name|dictionary_id
operator|=
name|IO_read_bits
argument_list|(
name|in
argument_list|,
name|bytes
operator|*
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|header
operator|->
name|dictionary_id
operator|=
literal|0
expr_stmt|;
block|}
comment|// decode frame content size if it exists
if|if
condition|(
name|single_segment_flag
operator|||
name|frame_content_size_flag
condition|)
block|{
comment|// "This is the original (uncompressed) size. This information is
comment|// optional. The Field_Size is provided according to value of
comment|// Frame_Content_Size_flag. The Field_Size can be equal to 0 (not
comment|// present), 1, 2, 4 or 8 bytes. Format is little-endian."
comment|//
comment|// if frame_content_size_flag == 0 but single_segment_flag is set, we
comment|// still have a 1 byte field
specifier|const
name|int
name|bytes_array
index|[]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|8
block|}
decl_stmt|;
specifier|const
name|int
name|bytes
init|=
name|bytes_array
index|[
name|frame_content_size_flag
index|]
decl_stmt|;
name|header
operator|->
name|frame_content_size
operator|=
name|IO_read_bits
argument_list|(
name|in
argument_list|,
name|bytes
operator|*
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|==
literal|2
condition|)
block|{
comment|// "When Field_Size is 2, the offset of 256 is added."
name|header
operator|->
name|frame_content_size
operator|+=
literal|256
expr_stmt|;
block|}
block|}
else|else
block|{
name|header
operator|->
name|frame_content_size
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|single_segment_flag
condition|)
block|{
comment|// "The Window_Descriptor byte is optional. It is absent when
comment|// Single_Segment_flag is set. In this case, the maximum back-reference
comment|// distance is the content size itself, which can be any value from 1 to
comment|// 2^64-1 bytes (16 EB)."
name|header
operator|->
name|window_size
operator|=
name|header
operator|->
name|frame_content_size
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/// A dictionary acts as initializing values for the frame context before
end_comment

begin_comment
comment|/// decompression, so we implement it by applying it's predetermined
end_comment

begin_comment
comment|/// tables and content to the context before beginning decompression
end_comment

begin_function
specifier|static
name|void
name|frame_context_apply_dict
parameter_list|(
name|frame_context_t
modifier|*
specifier|const
name|ctx
parameter_list|,
specifier|const
name|dictionary_t
modifier|*
specifier|const
name|dict
parameter_list|)
block|{
comment|// If the content pointer is NULL then it must be an empty dict
if|if
condition|(
operator|!
name|dict
operator|||
operator|!
name|dict
operator|->
name|content
condition|)
return|return;
comment|// If the requested dictionary_id is non-zero, the correct dictionary must
comment|// be present
if|if
condition|(
name|ctx
operator|->
name|header
operator|.
name|dictionary_id
operator|!=
literal|0
operator|&&
name|ctx
operator|->
name|header
operator|.
name|dictionary_id
operator|!=
name|dict
operator|->
name|dictionary_id
condition|)
block|{
name|ERROR
argument_list|(
literal|"Wrong dictionary provided"
argument_list|)
expr_stmt|;
block|}
comment|// Copy the dict content to the context for references during sequence
comment|// execution
name|ctx
operator|->
name|dict_content
operator|=
name|dict
operator|->
name|content
expr_stmt|;
name|ctx
operator|->
name|dict_content_len
operator|=
name|dict
operator|->
name|content_size
expr_stmt|;
comment|// If it's a formatted dict copy the precomputed tables in so they can
comment|// be used in the table repeat modes
if|if
condition|(
name|dict
operator|->
name|dictionary_id
operator|!=
literal|0
condition|)
block|{
comment|// Deep copy the entropy tables so they can be freed independently of
comment|// the dictionary struct
name|HUF_copy_dtable
argument_list|(
operator|&
name|ctx
operator|->
name|literals_dtable
argument_list|,
operator|&
name|dict
operator|->
name|literals_dtable
argument_list|)
expr_stmt|;
name|FSE_copy_dtable
argument_list|(
operator|&
name|ctx
operator|->
name|ll_dtable
argument_list|,
operator|&
name|dict
operator|->
name|ll_dtable
argument_list|)
expr_stmt|;
name|FSE_copy_dtable
argument_list|(
operator|&
name|ctx
operator|->
name|of_dtable
argument_list|,
operator|&
name|dict
operator|->
name|of_dtable
argument_list|)
expr_stmt|;
name|FSE_copy_dtable
argument_list|(
operator|&
name|ctx
operator|->
name|ml_dtable
argument_list|,
operator|&
name|dict
operator|->
name|ml_dtable
argument_list|)
expr_stmt|;
comment|// Copy the repeated offsets
name|memcpy
argument_list|(
name|ctx
operator|->
name|previous_offsets
argument_list|,
name|dict
operator|->
name|previous_offsets
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|previous_offsets
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/// Decompress the data from a frame block by block
end_comment

begin_function
specifier|static
name|void
name|decompress_data
parameter_list|(
name|frame_context_t
modifier|*
specifier|const
name|ctx
parameter_list|,
name|ostream_t
modifier|*
specifier|const
name|out
parameter_list|,
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|)
block|{
comment|// "A frame encapsulates one or multiple blocks. Each block can be
comment|// compressed or not, and has a guaranteed maximum content size, which
comment|// depends on frame parameters. Unlike frames, each block depends on
comment|// previous blocks for proper decoding. However, each block can be
comment|// decompressed without waiting for its successor, allowing streaming
comment|// operations."
name|int
name|last_block
init|=
literal|0
decl_stmt|;
do|do
block|{
comment|// "Last_Block
comment|//
comment|// The lowest bit signals if this block is the last one. Frame ends
comment|// right after this block.
comment|//
comment|// Block_Type and Block_Size
comment|//
comment|// The next 2 bits represent the Block_Type, while the remaining 21 bits
comment|// represent the Block_Size. Format is little-endian."
name|last_block
operator|=
name|IO_read_bits
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
expr_stmt|;
specifier|const
name|int
name|block_type
init|=
name|IO_read_bits
argument_list|(
name|in
argument_list|,
literal|2
argument_list|)
decl_stmt|;
specifier|const
name|size_t
name|block_len
init|=
name|IO_read_bits
argument_list|(
name|in
argument_list|,
literal|21
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|block_type
condition|)
block|{
case|case
literal|0
case|:
block|{
comment|// "Raw_Block - this is an uncompressed block. Block_Size is the
comment|// number of bytes to read and copy."
specifier|const
name|u8
modifier|*
specifier|const
name|read_ptr
init|=
name|IO_read_bytes
argument_list|(
name|in
argument_list|,
name|block_len
argument_list|)
decl_stmt|;
name|u8
modifier|*
specifier|const
name|write_ptr
init|=
name|IO_write_bytes
argument_list|(
name|out
argument_list|,
name|block_len
argument_list|)
decl_stmt|;
comment|// Copy the raw data into the output
name|memcpy
argument_list|(
name|write_ptr
argument_list|,
name|read_ptr
argument_list|,
name|block_len
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|current_total_output
operator|+=
name|block_len
expr_stmt|;
break|break;
block|}
case|case
literal|1
case|:
block|{
comment|// "RLE_Block - this is a single byte, repeated N times. In which
comment|// case, Block_Size is the size to regenerate, while the
comment|// "compressed" block is just 1 byte (the byte to repeat)."
specifier|const
name|u8
modifier|*
specifier|const
name|read_ptr
init|=
name|IO_read_bytes
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|u8
modifier|*
specifier|const
name|write_ptr
init|=
name|IO_write_bytes
argument_list|(
name|out
argument_list|,
name|block_len
argument_list|)
decl_stmt|;
comment|// Copy `block_len` copies of `read_ptr[0]` to the output
name|memset
argument_list|(
name|write_ptr
argument_list|,
name|read_ptr
index|[
literal|0
index|]
argument_list|,
name|block_len
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|current_total_output
operator|+=
name|block_len
expr_stmt|;
break|break;
block|}
case|case
literal|2
case|:
block|{
comment|// "Compressed_Block - this is a Zstandard compressed block,
comment|// detailed in another section of this specification. Block_Size is
comment|// the compressed size.
comment|// Create a sub-stream for the block
name|istream_t
name|block_stream
init|=
name|IO_make_sub_istream
argument_list|(
name|in
argument_list|,
name|block_len
argument_list|)
decl_stmt|;
name|decompress_block
argument_list|(
name|ctx
argument_list|,
name|out
argument_list|,
operator|&
name|block_stream
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|3
case|:
comment|// "Reserved - this is not a block. This value cannot be used with
comment|// current version of this specification."
name|CORRUPTION
argument_list|()
expr_stmt|;
break|break;
default|default:
name|IMPOSSIBLE
argument_list|()
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
name|last_block
condition|)
do|;
if|if
condition|(
name|ctx
operator|->
name|header
operator|.
name|content_checksum_flag
condition|)
block|{
comment|// This program does not support checking the checksum, so skip over it
comment|// if it's present
name|IO_advance_input
argument_list|(
name|in
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******* END FRAME DECODING ***************************************************/
end_comment

begin_comment
comment|/******* BLOCK DECOMPRESSION **************************************************/
end_comment

begin_function
specifier|static
name|void
name|decompress_block
parameter_list|(
name|frame_context_t
modifier|*
specifier|const
name|ctx
parameter_list|,
name|ostream_t
modifier|*
specifier|const
name|out
parameter_list|,
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|)
block|{
comment|// "A compressed block consists of 2 sections :
comment|//
comment|// Literals_Section
comment|// Sequences_Section"
comment|// Part 1: decode the literals block
name|u8
modifier|*
name|literals
init|=
name|NULL
decl_stmt|;
specifier|const
name|size_t
name|literals_size
init|=
name|decode_literals
argument_list|(
name|ctx
argument_list|,
name|in
argument_list|,
operator|&
name|literals
argument_list|)
decl_stmt|;
comment|// Part 2: decode the sequences block
name|sequence_command_t
modifier|*
name|sequences
init|=
name|NULL
decl_stmt|;
specifier|const
name|size_t
name|num_sequences
init|=
name|decode_sequences
argument_list|(
name|ctx
argument_list|,
name|in
argument_list|,
operator|&
name|sequences
argument_list|)
decl_stmt|;
comment|// Part 3: combine literals and sequence commands to generate output
name|execute_sequences
argument_list|(
name|ctx
argument_list|,
name|out
argument_list|,
name|literals
argument_list|,
name|literals_size
argument_list|,
name|sequences
argument_list|,
name|num_sequences
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|literals
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sequences
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******* END BLOCK DECOMPRESSION **********************************************/
end_comment

begin_comment
comment|/******* LITERALS DECODING ****************************************************/
end_comment

begin_function_decl
specifier|static
name|size_t
name|decode_literals_simple
parameter_list|(
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|,
name|u8
modifier|*
modifier|*
specifier|const
name|literals
parameter_list|,
specifier|const
name|int
name|block_type
parameter_list|,
specifier|const
name|int
name|size_format
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|decode_literals_compressed
parameter_list|(
name|frame_context_t
modifier|*
specifier|const
name|ctx
parameter_list|,
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|,
name|u8
modifier|*
modifier|*
specifier|const
name|literals
parameter_list|,
specifier|const
name|int
name|block_type
parameter_list|,
specifier|const
name|int
name|size_format
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|decode_huf_table
parameter_list|(
name|HUF_dtable
modifier|*
specifier|const
name|dtable
parameter_list|,
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fse_decode_hufweights
parameter_list|(
name|ostream_t
modifier|*
name|weights
parameter_list|,
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|,
name|int
modifier|*
specifier|const
name|num_symbs
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|size_t
name|decode_literals
parameter_list|(
name|frame_context_t
modifier|*
specifier|const
name|ctx
parameter_list|,
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|,
name|u8
modifier|*
modifier|*
specifier|const
name|literals
parameter_list|)
block|{
comment|// "Literals can be stored uncompressed or compressed using Huffman prefix
comment|// codes. When compressed, an optional tree description can be present,
comment|// followed by 1 or 4 streams."
comment|//
comment|// "Literals_Section_Header
comment|//
comment|// Header is in charge of describing how literals are packed. It's a
comment|// byte-aligned variable-size bitfield, ranging from 1 to 5 bytes, using
comment|// little-endian convention."
comment|//
comment|// "Literals_Block_Type
comment|//
comment|// This field uses 2 lowest bits of first byte, describing 4 different block
comment|// types"
comment|//
comment|// size_format takes between 1 and 2 bits
name|int
name|block_type
init|=
name|IO_read_bits
argument_list|(
name|in
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|int
name|size_format
init|=
name|IO_read_bits
argument_list|(
name|in
argument_list|,
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|block_type
operator|<=
literal|1
condition|)
block|{
comment|// Raw or RLE literals block
return|return
name|decode_literals_simple
argument_list|(
name|in
argument_list|,
name|literals
argument_list|,
name|block_type
argument_list|,
name|size_format
argument_list|)
return|;
block|}
else|else
block|{
comment|// Huffman compressed literals
return|return
name|decode_literals_compressed
argument_list|(
name|ctx
argument_list|,
name|in
argument_list|,
name|literals
argument_list|,
name|block_type
argument_list|,
name|size_format
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/// Decodes literals blocks in raw or RLE form
end_comment

begin_function
specifier|static
name|size_t
name|decode_literals_simple
parameter_list|(
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|,
name|u8
modifier|*
modifier|*
specifier|const
name|literals
parameter_list|,
specifier|const
name|int
name|block_type
parameter_list|,
specifier|const
name|int
name|size_format
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|;
switch|switch
condition|(
name|size_format
condition|)
block|{
comment|// These cases are in the form ?0
comment|// In this case, the ? bit is actually part of the size field
case|case
literal|0
case|:
case|case
literal|2
case|:
comment|// "Size_Format uses 1 bit. Regenerated_Size uses 5 bits (0-31)."
name|IO_rewind_bits
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|size
operator|=
name|IO_read_bits
argument_list|(
name|in
argument_list|,
literal|5
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|// "Size_Format uses 2 bits. Regenerated_Size uses 12 bits (0-4095)."
name|size
operator|=
name|IO_read_bits
argument_list|(
name|in
argument_list|,
literal|12
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|// "Size_Format uses 2 bits. Regenerated_Size uses 20 bits (0-1048575)."
name|size
operator|=
name|IO_read_bits
argument_list|(
name|in
argument_list|,
literal|20
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|// Size format is in range 0-3
name|IMPOSSIBLE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|>
name|MAX_LITERALS_SIZE
condition|)
block|{
name|CORRUPTION
argument_list|()
expr_stmt|;
block|}
operator|*
name|literals
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|literals
condition|)
block|{
name|BAD_ALLOC
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|block_type
condition|)
block|{
case|case
literal|0
case|:
block|{
comment|// "Raw_Literals_Block - Literals are stored uncompressed."
specifier|const
name|u8
modifier|*
specifier|const
name|read_ptr
init|=
name|IO_read_bytes
argument_list|(
name|in
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
operator|*
name|literals
argument_list|,
name|read_ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|1
case|:
block|{
comment|// "RLE_Literals_Block - Literals consist of a single byte value repeated N times."
specifier|const
name|u8
modifier|*
specifier|const
name|read_ptr
init|=
name|IO_read_bytes
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|memset
argument_list|(
operator|*
name|literals
argument_list|,
name|read_ptr
index|[
literal|0
index|]
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|IMPOSSIBLE
argument_list|()
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/// Decodes Huffman compressed literals
end_comment

begin_function
specifier|static
name|size_t
name|decode_literals_compressed
parameter_list|(
name|frame_context_t
modifier|*
specifier|const
name|ctx
parameter_list|,
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|,
name|u8
modifier|*
modifier|*
specifier|const
name|literals
parameter_list|,
specifier|const
name|int
name|block_type
parameter_list|,
specifier|const
name|int
name|size_format
parameter_list|)
block|{
name|size_t
name|regenerated_size
decl_stmt|,
name|compressed_size
decl_stmt|;
comment|// Only size_format=0 has 1 stream, so default to 4
name|int
name|num_streams
init|=
literal|4
decl_stmt|;
switch|switch
condition|(
name|size_format
condition|)
block|{
case|case
literal|0
case|:
comment|// "A single stream. Both Compressed_Size and Regenerated_Size use 10
comment|// bits (0-1023)."
name|num_streams
operator|=
literal|1
expr_stmt|;
comment|// Fall through as it has the same size format
case|case
literal|1
case|:
comment|// "4 streams. Both Compressed_Size and Regenerated_Size use 10 bits
comment|// (0-1023)."
name|regenerated_size
operator|=
name|IO_read_bits
argument_list|(
name|in
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|compressed_size
operator|=
name|IO_read_bits
argument_list|(
name|in
argument_list|,
literal|10
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|// "4 streams. Both Compressed_Size and Regenerated_Size use 14 bits
comment|// (0-16383)."
name|regenerated_size
operator|=
name|IO_read_bits
argument_list|(
name|in
argument_list|,
literal|14
argument_list|)
expr_stmt|;
name|compressed_size
operator|=
name|IO_read_bits
argument_list|(
name|in
argument_list|,
literal|14
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|// "4 streams. Both Compressed_Size and Regenerated_Size use 18 bits
comment|// (0-262143)."
name|regenerated_size
operator|=
name|IO_read_bits
argument_list|(
name|in
argument_list|,
literal|18
argument_list|)
expr_stmt|;
name|compressed_size
operator|=
name|IO_read_bits
argument_list|(
name|in
argument_list|,
literal|18
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|// Impossible
name|IMPOSSIBLE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|regenerated_size
operator|>
name|MAX_LITERALS_SIZE
operator|||
name|compressed_size
operator|>=
name|regenerated_size
condition|)
block|{
name|CORRUPTION
argument_list|()
expr_stmt|;
block|}
operator|*
name|literals
operator|=
name|malloc
argument_list|(
name|regenerated_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|literals
condition|)
block|{
name|BAD_ALLOC
argument_list|()
expr_stmt|;
block|}
name|ostream_t
name|lit_stream
init|=
name|IO_make_ostream
argument_list|(
operator|*
name|literals
argument_list|,
name|regenerated_size
argument_list|)
decl_stmt|;
name|istream_t
name|huf_stream
init|=
name|IO_make_sub_istream
argument_list|(
name|in
argument_list|,
name|compressed_size
argument_list|)
decl_stmt|;
if|if
condition|(
name|block_type
operator|==
literal|2
condition|)
block|{
comment|// Decode the provided Huffman table
comment|// "This section is only present when Literals_Block_Type type is
comment|// Compressed_Literals_Block (2)."
name|HUF_free_dtable
argument_list|(
operator|&
name|ctx
operator|->
name|literals_dtable
argument_list|)
expr_stmt|;
name|decode_huf_table
argument_list|(
operator|&
name|ctx
operator|->
name|literals_dtable
argument_list|,
operator|&
name|huf_stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// If the previous Huffman table is being repeated, ensure it exists
if|if
condition|(
operator|!
name|ctx
operator|->
name|literals_dtable
operator|.
name|symbols
condition|)
block|{
name|CORRUPTION
argument_list|()
expr_stmt|;
block|}
block|}
name|size_t
name|symbols_decoded
decl_stmt|;
if|if
condition|(
name|num_streams
operator|==
literal|1
condition|)
block|{
name|symbols_decoded
operator|=
name|HUF_decompress_1stream
argument_list|(
operator|&
name|ctx
operator|->
name|literals_dtable
argument_list|,
operator|&
name|lit_stream
argument_list|,
operator|&
name|huf_stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|symbols_decoded
operator|=
name|HUF_decompress_4stream
argument_list|(
operator|&
name|ctx
operator|->
name|literals_dtable
argument_list|,
operator|&
name|lit_stream
argument_list|,
operator|&
name|huf_stream
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|symbols_decoded
operator|!=
name|regenerated_size
condition|)
block|{
name|CORRUPTION
argument_list|()
expr_stmt|;
block|}
return|return
name|regenerated_size
return|;
block|}
end_function

begin_comment
comment|// Decode the Huffman table description
end_comment

begin_function
specifier|static
name|void
name|decode_huf_table
parameter_list|(
name|HUF_dtable
modifier|*
specifier|const
name|dtable
parameter_list|,
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|)
block|{
comment|// "All literal values from zero (included) to last present one (excluded)
comment|// are represented by Weight with values from 0 to Max_Number_of_Bits."
comment|// "This is a single byte value (0-255), which describes how to decode the list of weights."
specifier|const
name|u8
name|header
init|=
name|IO_read_bits
argument_list|(
name|in
argument_list|,
literal|8
argument_list|)
decl_stmt|;
name|u8
name|weights
index|[
name|HUF_MAX_SYMBS
index|]
decl_stmt|;
name|memset
argument_list|(
name|weights
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|weights
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|num_symbs
decl_stmt|;
if|if
condition|(
name|header
operator|>=
literal|128
condition|)
block|{
comment|// "This is a direct representation, where each Weight is written
comment|// directly as a 4 bits field (0-15). The full representation occupies
comment|// ((Number_of_Symbols+1)/2) bytes, meaning it uses a last full byte
comment|// even if Number_of_Symbols is odd. Number_of_Symbols = headerByte -
comment|// 127"
name|num_symbs
operator|=
name|header
operator|-
literal|127
expr_stmt|;
specifier|const
name|size_t
name|bytes
init|=
operator|(
name|num_symbs
operator|+
literal|1
operator|)
operator|/
literal|2
decl_stmt|;
specifier|const
name|u8
modifier|*
specifier|const
name|weight_src
init|=
name|IO_read_bytes
argument_list|(
name|in
argument_list|,
name|bytes
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num_symbs
condition|;
name|i
operator|++
control|)
block|{
comment|// "They are encoded forward, 2
comment|// weights to a byte with the first weight taking the top four bits
comment|// and the second taking the bottom four (e.g. the following
comment|// operations could be used to read the weights: Weight[0] =
comment|// (Byte[0]>> 4), Weight[1] = (Byte[0]& 0xf), etc.)."
if|if
condition|(
name|i
operator|%
literal|2
operator|==
literal|0
condition|)
block|{
name|weights
index|[
name|i
index|]
operator|=
name|weight_src
index|[
name|i
operator|/
literal|2
index|]
operator|>>
literal|4
expr_stmt|;
block|}
else|else
block|{
name|weights
index|[
name|i
index|]
operator|=
name|weight_src
index|[
name|i
operator|/
literal|2
index|]
operator|&
literal|0xf
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// The weights are FSE encoded, decode them before we can construct the
comment|// table
name|istream_t
name|fse_stream
init|=
name|IO_make_sub_istream
argument_list|(
name|in
argument_list|,
name|header
argument_list|)
decl_stmt|;
name|ostream_t
name|weight_stream
init|=
name|IO_make_ostream
argument_list|(
name|weights
argument_list|,
name|HUF_MAX_SYMBS
argument_list|)
decl_stmt|;
name|fse_decode_hufweights
argument_list|(
operator|&
name|weight_stream
argument_list|,
operator|&
name|fse_stream
argument_list|,
operator|&
name|num_symbs
argument_list|)
expr_stmt|;
block|}
comment|// Construct the table using the decoded weights
name|HUF_init_dtable_usingweights
argument_list|(
name|dtable
argument_list|,
name|weights
argument_list|,
name|num_symbs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fse_decode_hufweights
parameter_list|(
name|ostream_t
modifier|*
name|weights
parameter_list|,
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|,
name|int
modifier|*
specifier|const
name|num_symbs
parameter_list|)
block|{
specifier|const
name|int
name|MAX_ACCURACY_LOG
init|=
literal|7
decl_stmt|;
name|FSE_dtable
name|dtable
decl_stmt|;
comment|// "An FSE bitstream starts by a header, describing probabilities
comment|// distribution. It will create a Decoding Table. For a list of Huffman
comment|// weights, maximum accuracy is 7 bits."
name|FSE_decode_header
argument_list|(
operator|&
name|dtable
argument_list|,
name|in
argument_list|,
name|MAX_ACCURACY_LOG
argument_list|)
expr_stmt|;
comment|// Decode the weights
operator|*
name|num_symbs
operator|=
name|FSE_decompress_interleaved2
argument_list|(
operator|&
name|dtable
argument_list|,
name|weights
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|FSE_free_dtable
argument_list|(
operator|&
name|dtable
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******* END LITERALS DECODING ************************************************/
end_comment

begin_comment
comment|/******* SEQUENCE DECODING ****************************************************/
end_comment

begin_comment
comment|/// The combination of FSE states needed to decode sequences
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|FSE_dtable
name|ll_table
decl_stmt|;
name|FSE_dtable
name|of_table
decl_stmt|;
name|FSE_dtable
name|ml_table
decl_stmt|;
name|u16
name|ll_state
decl_stmt|;
name|u16
name|of_state
decl_stmt|;
name|u16
name|ml_state
decl_stmt|;
block|}
name|sequence_states_t
typedef|;
end_typedef

begin_comment
comment|/// Different modes to signal to decode_seq_tables what to do
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|seq_literal_length
init|=
literal|0
block|,
name|seq_offset
init|=
literal|1
block|,
name|seq_match_length
init|=
literal|2
block|, }
name|seq_part_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|seq_predefined
init|=
literal|0
block|,
name|seq_rle
init|=
literal|1
block|,
name|seq_fse
init|=
literal|2
block|,
name|seq_repeat
init|=
literal|3
block|, }
name|seq_mode_t
typedef|;
end_typedef

begin_comment
comment|/// The predefined FSE distribution tables for `seq_predefined` mode
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|i16
name|SEQ_LITERAL_LENGTH_DEFAULT_DIST
index|[
literal|36
index|]
init|=
block|{
literal|4
block|,
literal|3
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|i16
name|SEQ_OFFSET_DEFAULT_DIST
index|[
literal|29
index|]
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|i16
name|SEQ_MATCH_LENGTH_DEFAULT_DIST
index|[
literal|53
index|]
init|=
block|{
literal|1
block|,
literal|4
block|,
literal|3
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// The sequence decoding baseline and number of additional bits to read/add
end_comment

begin_comment
comment|/// https://github.com/facebook/zstd/blob/dev/doc/zstd_compression_format.md#the-codes-for-literals-lengths-match-lengths-and-offsets
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|u32
name|SEQ_LITERAL_LENGTH_BASELINES
index|[
literal|36
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|18
block|,
literal|20
block|,
literal|22
block|,
literal|24
block|,
literal|28
block|,
literal|32
block|,
literal|40
block|,
literal|48
block|,
literal|64
block|,
literal|128
block|,
literal|256
block|,
literal|512
block|,
literal|1024
block|,
literal|2048
block|,
literal|4096
block|,
literal|8192
block|,
literal|16384
block|,
literal|32768
block|,
literal|65538
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|u8
name|SEQ_LITERAL_LENGTH_EXTRA_BITS
index|[
literal|36
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|u32
name|SEQ_MATCH_LENGTH_BASELINES
index|[
literal|53
index|]
init|=
block|{
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|37
block|,
literal|39
block|,
literal|41
block|,
literal|43
block|,
literal|47
block|,
literal|51
block|,
literal|59
block|,
literal|67
block|,
literal|83
block|,
literal|99
block|,
literal|131
block|,
literal|259
block|,
literal|515
block|,
literal|1027
block|,
literal|2051
block|,
literal|4099
block|,
literal|8195
block|,
literal|16387
block|,
literal|32771
block|,
literal|65539
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|u8
name|SEQ_MATCH_LENGTH_EXTRA_BITS
index|[
literal|53
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// Offset decoding is simpler so we just need a maximum code value
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|u8
name|SEQ_MAX_CODES
index|[
literal|3
index|]
init|=
block|{
literal|35
block|,
operator|-
literal|1
block|,
literal|52
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|decompress_sequences
parameter_list|(
name|frame_context_t
modifier|*
specifier|const
name|ctx
parameter_list|,
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|,
name|sequence_command_t
modifier|*
specifier|const
name|sequences
parameter_list|,
specifier|const
name|size_t
name|num_sequences
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|sequence_command_t
name|decode_sequence
parameter_list|(
name|sequence_states_t
modifier|*
specifier|const
name|state
parameter_list|,
specifier|const
name|u8
modifier|*
specifier|const
name|src
parameter_list|,
name|i64
modifier|*
specifier|const
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|decode_seq_table
parameter_list|(
name|FSE_dtable
modifier|*
specifier|const
name|table
parameter_list|,
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|,
specifier|const
name|seq_part_t
name|type
parameter_list|,
specifier|const
name|seq_mode_t
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|size_t
name|decode_sequences
parameter_list|(
name|frame_context_t
modifier|*
specifier|const
name|ctx
parameter_list|,
name|istream_t
modifier|*
name|in
parameter_list|,
name|sequence_command_t
modifier|*
modifier|*
specifier|const
name|sequences
parameter_list|)
block|{
comment|// "A compressed block is a succession of sequences . A sequence is a
comment|// literal copy command, followed by a match copy command. A literal copy
comment|// command specifies a length. It is the number of bytes to be copied (or
comment|// extracted) from the literal section. A match copy command specifies an
comment|// offset and a length. The offset gives the position to copy from, which
comment|// can be within a previous block."
name|size_t
name|num_sequences
decl_stmt|;
comment|// "Number_of_Sequences
comment|//
comment|// This is a variable size field using between 1 and 3 bytes. Let's call its
comment|// first byte byte0."
name|u8
name|header
init|=
name|IO_read_bits
argument_list|(
name|in
argument_list|,
literal|8
argument_list|)
decl_stmt|;
if|if
condition|(
name|header
operator|==
literal|0
condition|)
block|{
comment|// "There are no sequences. The sequence section stops there.
comment|// Regenerated content is defined entirely by literals section."
operator|*
name|sequences
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|header
operator|<
literal|128
condition|)
block|{
comment|// "Number_of_Sequences = byte0 . Uses 1 byte."
name|num_sequences
operator|=
name|header
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|header
operator|<
literal|255
condition|)
block|{
comment|// "Number_of_Sequences = ((byte0-128)<< 8) + byte1 . Uses 2 bytes."
name|num_sequences
operator|=
operator|(
operator|(
name|header
operator|-
literal|128
operator|)
operator|<<
literal|8
operator|)
operator|+
name|IO_read_bits
argument_list|(
name|in
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// "Number_of_Sequences = byte1 + (byte2<<8) + 0x7F00 . Uses 3 bytes."
name|num_sequences
operator|=
name|IO_read_bits
argument_list|(
name|in
argument_list|,
literal|16
argument_list|)
operator|+
literal|0x7F00
expr_stmt|;
block|}
operator|*
name|sequences
operator|=
name|malloc
argument_list|(
name|num_sequences
operator|*
sizeof|sizeof
argument_list|(
name|sequence_command_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|sequences
condition|)
block|{
name|BAD_ALLOC
argument_list|()
expr_stmt|;
block|}
name|decompress_sequences
argument_list|(
name|ctx
argument_list|,
name|in
argument_list|,
operator|*
name|sequences
argument_list|,
name|num_sequences
argument_list|)
expr_stmt|;
return|return
name|num_sequences
return|;
block|}
end_function

begin_comment
comment|/// Decompress the FSE encoded sequence commands
end_comment

begin_function
specifier|static
name|void
name|decompress_sequences
parameter_list|(
name|frame_context_t
modifier|*
specifier|const
name|ctx
parameter_list|,
name|istream_t
modifier|*
name|in
parameter_list|,
name|sequence_command_t
modifier|*
specifier|const
name|sequences
parameter_list|,
specifier|const
name|size_t
name|num_sequences
parameter_list|)
block|{
comment|// "The Sequences_Section regroup all symbols required to decode commands.
comment|// There are 3 symbol types : literals lengths, offsets and match lengths.
comment|// They are encoded together, interleaved, in a single bitstream."
comment|// "Symbol compression modes
comment|//
comment|// This is a single byte, defining the compression mode of each symbol
comment|// type."
comment|//
comment|// Bit number : Field name
comment|// 7-6        : Literals_Lengths_Mode
comment|// 5-4        : Offsets_Mode
comment|// 3-2        : Match_Lengths_Mode
comment|// 1-0        : Reserved
name|u8
name|compression_modes
init|=
name|IO_read_bits
argument_list|(
name|in
argument_list|,
literal|8
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|compression_modes
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// Reserved bits set
name|CORRUPTION
argument_list|()
expr_stmt|;
block|}
comment|// "Following the header, up to 3 distribution tables can be described. When
comment|// present, they are in this order :
comment|//
comment|// Literals lengths
comment|// Offsets
comment|// Match Lengths"
comment|// Update the tables we have stored in the context
name|decode_seq_table
argument_list|(
operator|&
name|ctx
operator|->
name|ll_dtable
argument_list|,
name|in
argument_list|,
name|seq_literal_length
argument_list|,
operator|(
name|compression_modes
operator|>>
literal|6
operator|)
operator|&
literal|3
argument_list|)
expr_stmt|;
name|decode_seq_table
argument_list|(
operator|&
name|ctx
operator|->
name|of_dtable
argument_list|,
name|in
argument_list|,
name|seq_offset
argument_list|,
operator|(
name|compression_modes
operator|>>
literal|4
operator|)
operator|&
literal|3
argument_list|)
expr_stmt|;
name|decode_seq_table
argument_list|(
operator|&
name|ctx
operator|->
name|ml_dtable
argument_list|,
name|in
argument_list|,
name|seq_match_length
argument_list|,
operator|(
name|compression_modes
operator|>>
literal|2
operator|)
operator|&
literal|3
argument_list|)
expr_stmt|;
name|sequence_states_t
name|states
decl_stmt|;
comment|// Initialize the decoding tables
block|{
name|states
operator|.
name|ll_table
operator|=
name|ctx
operator|->
name|ll_dtable
expr_stmt|;
name|states
operator|.
name|of_table
operator|=
name|ctx
operator|->
name|of_dtable
expr_stmt|;
name|states
operator|.
name|ml_table
operator|=
name|ctx
operator|->
name|ml_dtable
expr_stmt|;
block|}
specifier|const
name|size_t
name|len
init|=
name|IO_istream_len
argument_list|(
name|in
argument_list|)
decl_stmt|;
specifier|const
name|u8
modifier|*
specifier|const
name|src
init|=
name|IO_read_bytes
argument_list|(
name|in
argument_list|,
name|len
argument_list|)
decl_stmt|;
comment|// "After writing the last bit containing information, the compressor writes
comment|// a single 1-bit and then fills the byte with 0-7 0 bits of padding."
specifier|const
name|int
name|padding
init|=
literal|8
operator|-
name|highest_set_bit
argument_list|(
name|src
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
decl_stmt|;
comment|// The offset starts at the end because FSE streams are read backwards
name|i64
name|bit_offset
init|=
name|len
operator|*
literal|8
operator|-
name|padding
decl_stmt|;
comment|// "The bitstream starts with initial state values, each using the required
comment|// number of bits in their respective accuracy, decoded previously from
comment|// their normalized distribution.
comment|//
comment|// It starts by Literals_Length_State, followed by Offset_State, and finally
comment|// Match_Length_State."
name|FSE_init_state
argument_list|(
operator|&
name|states
operator|.
name|ll_table
argument_list|,
operator|&
name|states
operator|.
name|ll_state
argument_list|,
name|src
argument_list|,
operator|&
name|bit_offset
argument_list|)
expr_stmt|;
name|FSE_init_state
argument_list|(
operator|&
name|states
operator|.
name|of_table
argument_list|,
operator|&
name|states
operator|.
name|of_state
argument_list|,
name|src
argument_list|,
operator|&
name|bit_offset
argument_list|)
expr_stmt|;
name|FSE_init_state
argument_list|(
operator|&
name|states
operator|.
name|ml_table
argument_list|,
operator|&
name|states
operator|.
name|ml_state
argument_list|,
name|src
argument_list|,
operator|&
name|bit_offset
argument_list|)
expr_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num_sequences
condition|;
name|i
operator|++
control|)
block|{
comment|// Decode sequences one by one
name|sequences
index|[
name|i
index|]
operator|=
name|decode_sequence
argument_list|(
operator|&
name|states
argument_list|,
name|src
argument_list|,
operator|&
name|bit_offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bit_offset
operator|!=
literal|0
condition|)
block|{
name|CORRUPTION
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|// Decode a single sequence and update the state
end_comment

begin_function
specifier|static
name|sequence_command_t
name|decode_sequence
parameter_list|(
name|sequence_states_t
modifier|*
specifier|const
name|states
parameter_list|,
specifier|const
name|u8
modifier|*
specifier|const
name|src
parameter_list|,
name|i64
modifier|*
specifier|const
name|offset
parameter_list|)
block|{
comment|// "Each symbol is a code in its own context, which specifies Baseline and
comment|// Number_of_Bits to add. Codes are FSE compressed, and interleaved with raw
comment|// additional bits in the same bitstream."
comment|// Decode symbols, but don't update states
specifier|const
name|u8
name|of_code
init|=
name|FSE_peek_symbol
argument_list|(
operator|&
name|states
operator|->
name|of_table
argument_list|,
name|states
operator|->
name|of_state
argument_list|)
decl_stmt|;
specifier|const
name|u8
name|ll_code
init|=
name|FSE_peek_symbol
argument_list|(
operator|&
name|states
operator|->
name|ll_table
argument_list|,
name|states
operator|->
name|ll_state
argument_list|)
decl_stmt|;
specifier|const
name|u8
name|ml_code
init|=
name|FSE_peek_symbol
argument_list|(
operator|&
name|states
operator|->
name|ml_table
argument_list|,
name|states
operator|->
name|ml_state
argument_list|)
decl_stmt|;
comment|// Offset doesn't need a max value as it's not decoded using a table
if|if
condition|(
name|ll_code
operator|>
name|SEQ_MAX_CODES
index|[
name|seq_literal_length
index|]
operator|||
name|ml_code
operator|>
name|SEQ_MAX_CODES
index|[
name|seq_match_length
index|]
condition|)
block|{
name|CORRUPTION
argument_list|()
expr_stmt|;
block|}
comment|// Read the interleaved bits
name|sequence_command_t
name|seq
decl_stmt|;
comment|// "Decoding starts by reading the Number_of_Bits required to decode Offset.
comment|// It then does the same for Match_Length, and then for Literals_Length."
name|seq
operator|.
name|offset
operator|=
operator|(
operator|(
name|u32
operator|)
literal|1
operator|<<
name|of_code
operator|)
operator|+
name|STREAM_read_bits
argument_list|(
name|src
argument_list|,
name|of_code
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|seq
operator|.
name|match_length
operator|=
name|SEQ_MATCH_LENGTH_BASELINES
index|[
name|ml_code
index|]
operator|+
name|STREAM_read_bits
argument_list|(
name|src
argument_list|,
name|SEQ_MATCH_LENGTH_EXTRA_BITS
index|[
name|ml_code
index|]
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|seq
operator|.
name|literal_length
operator|=
name|SEQ_LITERAL_LENGTH_BASELINES
index|[
name|ll_code
index|]
operator|+
name|STREAM_read_bits
argument_list|(
name|src
argument_list|,
name|SEQ_LITERAL_LENGTH_EXTRA_BITS
index|[
name|ll_code
index|]
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|// "If it is not the last sequence in the block, the next operation is to
comment|// update states. Using the rules pre-calculated in the decoding tables,
comment|// Literals_Length_State is updated, followed by Match_Length_State, and
comment|// then Offset_State."
comment|// If the stream is complete don't read bits to update state
if|if
condition|(
operator|*
name|offset
operator|!=
literal|0
condition|)
block|{
name|FSE_update_state
argument_list|(
operator|&
name|states
operator|->
name|ll_table
argument_list|,
operator|&
name|states
operator|->
name|ll_state
argument_list|,
name|src
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|FSE_update_state
argument_list|(
operator|&
name|states
operator|->
name|ml_table
argument_list|,
operator|&
name|states
operator|->
name|ml_state
argument_list|,
name|src
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|FSE_update_state
argument_list|(
operator|&
name|states
operator|->
name|of_table
argument_list|,
operator|&
name|states
operator|->
name|of_state
argument_list|,
name|src
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
return|return
name|seq
return|;
block|}
end_function

begin_comment
comment|/// Given a sequence part and table mode, decode the FSE distribution
end_comment

begin_comment
comment|/// Errors if the mode is `seq_repeat` without a pre-existing table in `table`
end_comment

begin_function
specifier|static
name|void
name|decode_seq_table
parameter_list|(
name|FSE_dtable
modifier|*
specifier|const
name|table
parameter_list|,
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|,
specifier|const
name|seq_part_t
name|type
parameter_list|,
specifier|const
name|seq_mode_t
name|mode
parameter_list|)
block|{
comment|// Constant arrays indexed by seq_part_t
specifier|const
name|i16
modifier|*
specifier|const
name|default_distributions
index|[]
init|=
block|{
name|SEQ_LITERAL_LENGTH_DEFAULT_DIST
block|,
name|SEQ_OFFSET_DEFAULT_DIST
block|,
name|SEQ_MATCH_LENGTH_DEFAULT_DIST
block|}
decl_stmt|;
specifier|const
name|size_t
name|default_distribution_lengths
index|[]
init|=
block|{
literal|36
block|,
literal|29
block|,
literal|53
block|}
decl_stmt|;
specifier|const
name|size_t
name|default_distribution_accuracies
index|[]
init|=
block|{
literal|6
block|,
literal|5
block|,
literal|6
block|}
decl_stmt|;
specifier|const
name|size_t
name|max_accuracies
index|[]
init|=
block|{
literal|9
block|,
literal|8
block|,
literal|9
block|}
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|seq_repeat
condition|)
block|{
comment|// Free old one before overwriting
name|FSE_free_dtable
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|seq_predefined
case|:
block|{
comment|// "Predefined_Mode : uses a predefined distribution table."
specifier|const
name|i16
modifier|*
name|distribution
init|=
name|default_distributions
index|[
name|type
index|]
decl_stmt|;
specifier|const
name|size_t
name|symbs
init|=
name|default_distribution_lengths
index|[
name|type
index|]
decl_stmt|;
specifier|const
name|size_t
name|accuracy_log
init|=
name|default_distribution_accuracies
index|[
name|type
index|]
decl_stmt|;
name|FSE_init_dtable
argument_list|(
name|table
argument_list|,
name|distribution
argument_list|,
name|symbs
argument_list|,
name|accuracy_log
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|seq_rle
case|:
block|{
comment|// "RLE_Mode : it's a single code, repeated Number_of_Sequences times."
specifier|const
name|u8
name|symb
init|=
name|IO_read_bytes
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
index|[
literal|0
index|]
decl_stmt|;
name|FSE_init_dtable_rle
argument_list|(
name|table
argument_list|,
name|symb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|seq_fse
case|:
block|{
comment|// "FSE_Compressed_Mode : standard FSE compression. A distribution table
comment|// will be present "
name|FSE_decode_header
argument_list|(
name|table
argument_list|,
name|in
argument_list|,
name|max_accuracies
index|[
name|type
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|seq_repeat
case|:
comment|// "Repeat_Mode : re-use distribution table from previous compressed
comment|// block."
comment|// Nothing to do here, table will be unchanged
if|if
condition|(
operator|!
name|table
operator|->
name|symbols
condition|)
block|{
comment|// This mode is invalid if we don't already have a table
name|CORRUPTION
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
comment|// Impossible, as mode is from 0-3
name|IMPOSSIBLE
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/******* END SEQUENCE DECODING ************************************************/
end_comment

begin_comment
comment|/******* SEQUENCE EXECUTION ***************************************************/
end_comment

begin_function
specifier|static
name|void
name|execute_sequences
parameter_list|(
name|frame_context_t
modifier|*
specifier|const
name|ctx
parameter_list|,
name|ostream_t
modifier|*
specifier|const
name|out
parameter_list|,
specifier|const
name|u8
modifier|*
specifier|const
name|literals
parameter_list|,
specifier|const
name|size_t
name|literals_len
parameter_list|,
specifier|const
name|sequence_command_t
modifier|*
specifier|const
name|sequences
parameter_list|,
specifier|const
name|size_t
name|num_sequences
parameter_list|)
block|{
name|istream_t
name|litstream
init|=
name|IO_make_istream
argument_list|(
name|literals
argument_list|,
name|literals_len
argument_list|)
decl_stmt|;
name|u64
modifier|*
specifier|const
name|offset_hist
init|=
name|ctx
operator|->
name|previous_offsets
decl_stmt|;
name|size_t
name|total_output
init|=
name|ctx
operator|->
name|current_total_output
decl_stmt|;
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num_sequences
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|sequence_command_t
name|seq
init|=
name|sequences
index|[
name|i
index|]
decl_stmt|;
block|{
comment|// If the sequence asks for more literals than are left, the
comment|// sequence must be corrupted
if|if
condition|(
name|seq
operator|.
name|literal_length
operator|>
name|IO_istream_len
argument_list|(
operator|&
name|litstream
argument_list|)
condition|)
block|{
name|CORRUPTION
argument_list|()
expr_stmt|;
block|}
name|u8
modifier|*
specifier|const
name|write_ptr
init|=
name|IO_write_bytes
argument_list|(
name|out
argument_list|,
name|seq
operator|.
name|literal_length
argument_list|)
decl_stmt|;
specifier|const
name|u8
modifier|*
specifier|const
name|read_ptr
init|=
name|IO_read_bytes
argument_list|(
operator|&
name|litstream
argument_list|,
name|seq
operator|.
name|literal_length
argument_list|)
decl_stmt|;
comment|// Copy literals to output
name|memcpy
argument_list|(
name|write_ptr
argument_list|,
name|read_ptr
argument_list|,
name|seq
operator|.
name|literal_length
argument_list|)
expr_stmt|;
name|total_output
operator|+=
name|seq
operator|.
name|literal_length
expr_stmt|;
block|}
name|size_t
name|offset
decl_stmt|;
comment|// Offsets are special, we need to handle the repeat offsets
if|if
condition|(
name|seq
operator|.
name|offset
operator|<=
literal|3
condition|)
block|{
comment|// "The first 3 values define a repeated offset and we will call
comment|// them Repeated_Offset1, Repeated_Offset2, and Repeated_Offset3.
comment|// They are sorted in recency order, with Repeated_Offset1 meaning
comment|// 'most recent one'".
comment|// Use 0 indexing for the array
name|u32
name|idx
init|=
name|seq
operator|.
name|offset
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|seq
operator|.
name|literal_length
operator|==
literal|0
condition|)
block|{
comment|// "There is an exception though, when current sequence's
comment|// literals length is 0. In this case, repeated offsets are
comment|// shifted by one, so Repeated_Offset1 becomes Repeated_Offset2,
comment|// Repeated_Offset2 becomes Repeated_Offset3, and
comment|// Repeated_Offset3 becomes Repeated_Offset1 - 1_byte."
name|idx
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|idx
operator|==
literal|0
condition|)
block|{
name|offset
operator|=
name|offset_hist
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
comment|// If idx == 3 then literal length was 0 and the offset was 3,
comment|// as per the exception listed above
name|offset
operator|=
name|idx
operator|<
literal|3
condition|?
name|offset_hist
index|[
name|idx
index|]
else|:
name|offset_hist
index|[
literal|0
index|]
operator|-
literal|1
expr_stmt|;
comment|// If idx == 1 we don't need to modify offset_hist[2], since
comment|// we're using the second-most recent code
if|if
condition|(
name|idx
operator|>
literal|1
condition|)
block|{
name|offset_hist
index|[
literal|2
index|]
operator|=
name|offset_hist
index|[
literal|1
index|]
expr_stmt|;
block|}
name|offset_hist
index|[
literal|1
index|]
operator|=
name|offset_hist
index|[
literal|0
index|]
expr_stmt|;
name|offset_hist
index|[
literal|0
index|]
operator|=
name|offset
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// When it's not a repeat offset:
comment|// "if (Offset_Value> 3) offset = Offset_Value - 3;"
name|offset
operator|=
name|seq
operator|.
name|offset
operator|-
literal|3
expr_stmt|;
comment|// Shift back history
name|offset_hist
index|[
literal|2
index|]
operator|=
name|offset_hist
index|[
literal|1
index|]
expr_stmt|;
name|offset_hist
index|[
literal|1
index|]
operator|=
name|offset_hist
index|[
literal|0
index|]
expr_stmt|;
name|offset_hist
index|[
literal|0
index|]
operator|=
name|offset
expr_stmt|;
block|}
name|size_t
name|match_length
init|=
name|seq
operator|.
name|match_length
decl_stmt|;
name|u8
modifier|*
name|write_ptr
init|=
name|IO_write_bytes
argument_list|(
name|out
argument_list|,
name|match_length
argument_list|)
decl_stmt|;
if|if
condition|(
name|total_output
operator|<=
name|ctx
operator|->
name|header
operator|.
name|window_size
condition|)
block|{
comment|// In this case offset might go back into the dictionary
if|if
condition|(
name|offset
operator|>
name|total_output
operator|+
name|ctx
operator|->
name|dict_content_len
condition|)
block|{
comment|// The offset goes beyond even the dictionary
name|CORRUPTION
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|>
name|total_output
condition|)
block|{
comment|// "The rest of the dictionary is its content. The content act
comment|// as a "past" in front of data to compress or decompress, so it
comment|// can be referenced in sequence commands."
specifier|const
name|size_t
name|dict_copy
init|=
name|MIN
argument_list|(
name|offset
operator|-
name|total_output
argument_list|,
name|match_length
argument_list|)
decl_stmt|;
specifier|const
name|size_t
name|dict_offset
init|=
name|ctx
operator|->
name|dict_content_len
operator|-
operator|(
name|offset
operator|-
name|total_output
operator|)
decl_stmt|;
name|memcpy
argument_list|(
name|write_ptr
argument_list|,
name|ctx
operator|->
name|dict_content
operator|+
name|dict_offset
argument_list|,
name|dict_copy
argument_list|)
expr_stmt|;
name|write_ptr
operator|+=
name|dict_copy
expr_stmt|;
name|match_length
operator|-=
name|dict_copy
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|offset
operator|>
name|ctx
operator|->
name|header
operator|.
name|window_size
condition|)
block|{
name|CORRUPTION
argument_list|()
expr_stmt|;
block|}
comment|// We must copy byte by byte because the match length might be larger
comment|// than the offset
comment|// ex: if the output so far was "abc", a command with offset=3 and
comment|// match_length=6 would produce "abcabcabc" as the new output
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|match_length
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|write_ptr
operator|=
operator|*
operator|(
name|write_ptr
operator|-
name|offset
operator|)
expr_stmt|;
name|write_ptr
operator|++
expr_stmt|;
block|}
name|total_output
operator|+=
name|seq
operator|.
name|match_length
expr_stmt|;
block|}
comment|// Copy any leftover literals
block|{
name|size_t
name|len
init|=
name|IO_istream_len
argument_list|(
operator|&
name|litstream
argument_list|)
decl_stmt|;
name|u8
modifier|*
specifier|const
name|write_ptr
init|=
name|IO_write_bytes
argument_list|(
name|out
argument_list|,
name|len
argument_list|)
decl_stmt|;
specifier|const
name|u8
modifier|*
specifier|const
name|read_ptr
init|=
name|IO_read_bytes
argument_list|(
operator|&
name|litstream
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|write_ptr
argument_list|,
name|read_ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|total_output
operator|+=
name|len
expr_stmt|;
block|}
name|ctx
operator|->
name|current_total_output
operator|=
name|total_output
expr_stmt|;
block|}
end_function

begin_comment
comment|/******* END SEQUENCE EXECUTION ***********************************************/
end_comment

begin_comment
comment|/******* OUTPUT SIZE COUNTING *************************************************/
end_comment

begin_function_decl
specifier|static
name|void
name|traverse_frame
parameter_list|(
specifier|const
name|frame_header_t
modifier|*
specifier|const
name|header
parameter_list|,
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/// Get the decompressed size of an input stream so memory can be allocated in
end_comment

begin_comment
comment|/// advance.
end_comment

begin_comment
comment|/// This is more complex than the implementation in the reference
end_comment

begin_comment
comment|/// implementation, as this API allows for the decompression of multiple
end_comment

begin_comment
comment|/// concatenated frames.
end_comment

begin_function
name|size_t
name|ZSTD_get_decompressed_size
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
specifier|const
name|size_t
name|src_len
parameter_list|)
block|{
name|istream_t
name|in
init|=
name|IO_make_istream
argument_list|(
name|src
argument_list|,
name|src_len
argument_list|)
decl_stmt|;
name|size_t
name|dst_size
init|=
literal|0
decl_stmt|;
comment|// Each frame header only gives us the size of its frame, so iterate over
comment|// all
comment|// frames
while|while
condition|(
name|IO_istream_len
argument_list|(
operator|&
name|in
argument_list|)
operator|>
literal|0
condition|)
block|{
specifier|const
name|u32
name|magic_number
init|=
name|IO_read_bits
argument_list|(
operator|&
name|in
argument_list|,
literal|32
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|magic_number
operator|&
operator|~
literal|0xFU
operator|)
operator|==
literal|0x184D2A50U
condition|)
block|{
comment|// skippable frame, this has no impact on output size
specifier|const
name|size_t
name|frame_size
init|=
name|IO_read_bits
argument_list|(
operator|&
name|in
argument_list|,
literal|32
argument_list|)
decl_stmt|;
name|IO_advance_input
argument_list|(
operator|&
name|in
argument_list|,
name|frame_size
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|magic_number
operator|==
literal|0xFD2FB528U
condition|)
block|{
comment|// ZSTD frame
name|frame_header_t
name|header
decl_stmt|;
name|parse_frame_header
argument_list|(
operator|&
name|header
argument_list|,
operator|&
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|.
name|frame_content_size
operator|==
literal|0
operator|&&
operator|!
name|header
operator|.
name|single_segment_flag
condition|)
block|{
comment|// Content size not provided, we can't tell
return|return
operator|-
literal|1
return|;
block|}
name|dst_size
operator|+=
name|header
operator|.
name|frame_content_size
expr_stmt|;
comment|// Consume the input from the frame to reach the start of the next
name|traverse_frame
argument_list|(
operator|&
name|header
argument_list|,
operator|&
name|in
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// not a real frame
name|ERROR
argument_list|(
literal|"Invalid magic number"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|dst_size
return|;
block|}
end_function

begin_comment
comment|/// Iterate over each block in a frame to find the end of it, to get to the
end_comment

begin_comment
comment|/// start of the next frame
end_comment

begin_function
specifier|static
name|void
name|traverse_frame
parameter_list|(
specifier|const
name|frame_header_t
modifier|*
specifier|const
name|header
parameter_list|,
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|)
block|{
name|int
name|last_block
init|=
literal|0
decl_stmt|;
do|do
block|{
comment|// Parse the block header
name|last_block
operator|=
name|IO_read_bits
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
expr_stmt|;
specifier|const
name|int
name|block_type
init|=
name|IO_read_bits
argument_list|(
name|in
argument_list|,
literal|2
argument_list|)
decl_stmt|;
specifier|const
name|size_t
name|block_len
init|=
name|IO_read_bits
argument_list|(
name|in
argument_list|,
literal|21
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|block_type
condition|)
block|{
case|case
literal|0
case|:
comment|// Raw block, block_len bytes
name|IO_advance_input
argument_list|(
name|in
argument_list|,
name|block_len
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|// RLE block, 1 byte
name|IO_advance_input
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|// Compressed block, compressed size is block_len
name|IO_advance_input
argument_list|(
name|in
argument_list|,
name|block_len
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|// Reserved block type
name|CORRUPTION
argument_list|()
expr_stmt|;
break|break;
default|default:
name|IMPOSSIBLE
argument_list|()
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
name|last_block
condition|)
do|;
if|if
condition|(
name|header
operator|->
name|content_checksum_flag
condition|)
block|{
name|IO_advance_input
argument_list|(
name|in
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/******* END OUTPUT SIZE COUNTING *********************************************/
end_comment

begin_comment
comment|/******* DICTIONARY PARSING ***************************************************/
end_comment

begin_function_decl
specifier|static
name|void
name|init_dictionary_content
parameter_list|(
name|dictionary_t
modifier|*
specifier|const
name|dict
parameter_list|,
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|parse_dictionary
parameter_list|(
name|dictionary_t
modifier|*
specifier|const
name|dict
parameter_list|,
specifier|const
name|u8
modifier|*
name|src
parameter_list|,
name|size_t
name|src_len
parameter_list|)
block|{
name|memset
argument_list|(
name|dict
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dictionary_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_len
operator|<
literal|8
condition|)
block|{
name|INP_SIZE
argument_list|()
expr_stmt|;
block|}
name|istream_t
name|in
init|=
name|IO_make_istream
argument_list|(
name|src
argument_list|,
name|src_len
argument_list|)
decl_stmt|;
specifier|const
name|u32
name|magic_number
init|=
name|IO_read_bits
argument_list|(
operator|&
name|in
argument_list|,
literal|32
argument_list|)
decl_stmt|;
if|if
condition|(
name|magic_number
operator|!=
literal|0xEC30A437
condition|)
block|{
comment|// raw content dict
name|IO_rewind_bits
argument_list|(
operator|&
name|in
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|init_dictionary_content
argument_list|(
name|dict
argument_list|,
operator|&
name|in
argument_list|)
expr_stmt|;
return|return;
block|}
name|dict
operator|->
name|dictionary_id
operator|=
name|IO_read_bits
argument_list|(
operator|&
name|in
argument_list|,
literal|32
argument_list|)
expr_stmt|;
comment|// "Entropy_Tables : following the same format as the tables in compressed
comment|// blocks. They are stored in following order : Huffman tables for literals,
comment|// FSE table for offsets, FSE table for match lengths, and FSE table for
comment|// literals lengths. It's finally followed by 3 offset values, populating
comment|// recent offsets (instead of using {1,4,8}), stored in order, 4-bytes
comment|// little-endian each, for a total of 12 bytes. Each recent offset must have
comment|// a value< dictionary size."
name|decode_huf_table
argument_list|(
operator|&
name|dict
operator|->
name|literals_dtable
argument_list|,
operator|&
name|in
argument_list|)
expr_stmt|;
name|decode_seq_table
argument_list|(
operator|&
name|dict
operator|->
name|of_dtable
argument_list|,
operator|&
name|in
argument_list|,
name|seq_offset
argument_list|,
name|seq_fse
argument_list|)
expr_stmt|;
name|decode_seq_table
argument_list|(
operator|&
name|dict
operator|->
name|ml_dtable
argument_list|,
operator|&
name|in
argument_list|,
name|seq_match_length
argument_list|,
name|seq_fse
argument_list|)
expr_stmt|;
name|decode_seq_table
argument_list|(
operator|&
name|dict
operator|->
name|ll_dtable
argument_list|,
operator|&
name|in
argument_list|,
name|seq_literal_length
argument_list|,
name|seq_fse
argument_list|)
expr_stmt|;
comment|// Read in the previous offset history
name|dict
operator|->
name|previous_offsets
index|[
literal|0
index|]
operator|=
name|IO_read_bits
argument_list|(
operator|&
name|in
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|dict
operator|->
name|previous_offsets
index|[
literal|1
index|]
operator|=
name|IO_read_bits
argument_list|(
operator|&
name|in
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|dict
operator|->
name|previous_offsets
index|[
literal|2
index|]
operator|=
name|IO_read_bits
argument_list|(
operator|&
name|in
argument_list|,
literal|32
argument_list|)
expr_stmt|;
comment|// Ensure the provided offsets aren't too large
comment|// "Each recent offset must have a value< dictionary size."
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dict
operator|->
name|previous_offsets
index|[
name|i
index|]
operator|>
name|src_len
condition|)
block|{
name|ERROR
argument_list|(
literal|"Dictionary corrupted"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// "Content : The rest of the dictionary is its content. The content act as
comment|// a "past" in front of data to compress or decompress, so it can be
comment|// referenced in sequence commands."
name|init_dictionary_content
argument_list|(
name|dict
argument_list|,
operator|&
name|in
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_dictionary_content
parameter_list|(
name|dictionary_t
modifier|*
specifier|const
name|dict
parameter_list|,
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|)
block|{
comment|// Copy in the content
name|dict
operator|->
name|content_size
operator|=
name|IO_istream_len
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|dict
operator|->
name|content
operator|=
name|malloc
argument_list|(
name|dict
operator|->
name|content_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dict
operator|->
name|content
condition|)
block|{
name|BAD_ALLOC
argument_list|()
expr_stmt|;
block|}
specifier|const
name|u8
modifier|*
specifier|const
name|content
init|=
name|IO_read_bytes
argument_list|(
name|in
argument_list|,
name|dict
operator|->
name|content_size
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|dict
operator|->
name|content
argument_list|,
name|content
argument_list|,
name|dict
operator|->
name|content_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// Free an allocated dictionary
end_comment

begin_function
specifier|static
name|void
name|free_dictionary
parameter_list|(
name|dictionary_t
modifier|*
specifier|const
name|dict
parameter_list|)
block|{
name|HUF_free_dtable
argument_list|(
operator|&
name|dict
operator|->
name|literals_dtable
argument_list|)
expr_stmt|;
name|FSE_free_dtable
argument_list|(
operator|&
name|dict
operator|->
name|ll_dtable
argument_list|)
expr_stmt|;
name|FSE_free_dtable
argument_list|(
operator|&
name|dict
operator|->
name|of_dtable
argument_list|)
expr_stmt|;
name|FSE_free_dtable
argument_list|(
operator|&
name|dict
operator|->
name|ml_dtable
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dict
operator|->
name|content
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|dict
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dictionary_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******* END DICTIONARY PARSING ***********************************************/
end_comment

begin_comment
comment|/******* IO STREAM OPERATIONS *************************************************/
end_comment

begin_define
define|#
directive|define
name|UNALIGNED
parameter_list|()
value|ERROR("Attempting to operate on a non-byte aligned stream")
end_define

begin_comment
comment|/// Reads `num` bits from a bitstream, and updates the internal offset
end_comment

begin_function
specifier|static
specifier|inline
name|u64
name|IO_read_bits
parameter_list|(
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|,
specifier|const
name|int
name|num_bits
parameter_list|)
block|{
if|if
condition|(
name|num_bits
operator|>
literal|64
operator|||
name|num_bits
operator|<=
literal|0
condition|)
block|{
name|ERROR
argument_list|(
literal|"Attempt to read an invalid number of bits"
argument_list|)
expr_stmt|;
block|}
specifier|const
name|size_t
name|bytes
init|=
operator|(
name|num_bits
operator|+
name|in
operator|->
name|bit_offset
operator|+
literal|7
operator|)
operator|/
literal|8
decl_stmt|;
specifier|const
name|size_t
name|full_bytes
init|=
operator|(
name|num_bits
operator|+
name|in
operator|->
name|bit_offset
operator|)
operator|/
literal|8
decl_stmt|;
if|if
condition|(
name|bytes
operator|>
name|in
operator|->
name|len
condition|)
block|{
name|INP_SIZE
argument_list|()
expr_stmt|;
block|}
specifier|const
name|u64
name|result
init|=
name|read_bits_LE
argument_list|(
name|in
operator|->
name|ptr
argument_list|,
name|num_bits
argument_list|,
name|in
operator|->
name|bit_offset
argument_list|)
decl_stmt|;
name|in
operator|->
name|bit_offset
operator|=
operator|(
name|num_bits
operator|+
name|in
operator|->
name|bit_offset
operator|)
operator|%
literal|8
expr_stmt|;
name|in
operator|->
name|ptr
operator|+=
name|full_bytes
expr_stmt|;
name|in
operator|->
name|len
operator|-=
name|full_bytes
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/// If a non-zero number of bits have been read from the current byte, advance
end_comment

begin_comment
comment|/// the offset to the next byte
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|IO_rewind_bits
parameter_list|(
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|,
name|int
name|num_bits
parameter_list|)
block|{
if|if
condition|(
name|num_bits
operator|<
literal|0
condition|)
block|{
name|ERROR
argument_list|(
literal|"Attempting to rewind stream by a negative number of bits"
argument_list|)
expr_stmt|;
block|}
comment|// move the offset back by `num_bits` bits
specifier|const
name|int
name|new_offset
init|=
name|in
operator|->
name|bit_offset
operator|-
name|num_bits
decl_stmt|;
comment|// determine the number of whole bytes we have to rewind, rounding up to an
comment|// integer number (e.g. if `new_offset == -5`, `bytes == 1`)
specifier|const
name|i64
name|bytes
init|=
operator|-
operator|(
name|new_offset
operator|-
literal|7
operator|)
operator|/
literal|8
decl_stmt|;
name|in
operator|->
name|ptr
operator|-=
name|bytes
expr_stmt|;
name|in
operator|->
name|len
operator|+=
name|bytes
expr_stmt|;
comment|// make sure the resulting `bit_offset` is positive, as mod in C does not
comment|// convert numbers from negative to positive (e.g. -22 % 8 == -6)
name|in
operator|->
name|bit_offset
operator|=
operator|(
operator|(
name|new_offset
operator|%
literal|8
operator|)
operator|+
literal|8
operator|)
operator|%
literal|8
expr_stmt|;
block|}
end_function

begin_comment
comment|/// If the remaining bits in a byte will be unused, advance to the end of the
end_comment

begin_comment
comment|/// byte
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|IO_align_stream
parameter_list|(
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|)
block|{
if|if
condition|(
name|in
operator|->
name|bit_offset
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|in
operator|->
name|len
operator|==
literal|0
condition|)
block|{
name|INP_SIZE
argument_list|()
expr_stmt|;
block|}
name|in
operator|->
name|ptr
operator|++
expr_stmt|;
name|in
operator|->
name|len
operator|--
expr_stmt|;
name|in
operator|->
name|bit_offset
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/// Write the given byte into the output stream
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|IO_write_byte
parameter_list|(
name|ostream_t
modifier|*
specifier|const
name|out
parameter_list|,
name|u8
name|symb
parameter_list|)
block|{
if|if
condition|(
name|out
operator|->
name|len
operator|==
literal|0
condition|)
block|{
name|OUT_SIZE
argument_list|()
expr_stmt|;
block|}
name|out
operator|->
name|ptr
index|[
literal|0
index|]
operator|=
name|symb
expr_stmt|;
name|out
operator|->
name|ptr
operator|++
expr_stmt|;
name|out
operator|->
name|len
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/// Returns the number of bytes left to be read in this stream.  The stream must
end_comment

begin_comment
comment|/// be byte aligned.
end_comment

begin_function
specifier|static
specifier|inline
name|size_t
name|IO_istream_len
parameter_list|(
specifier|const
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|)
block|{
return|return
name|in
operator|->
name|len
return|;
block|}
end_function

begin_comment
comment|/// Returns a pointer where `len` bytes can be read, and advances the internal
end_comment

begin_comment
comment|/// state.  The stream must be byte aligned.
end_comment

begin_function
specifier|static
specifier|inline
specifier|const
name|u8
modifier|*
name|IO_read_bytes
parameter_list|(
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|>
name|in
operator|->
name|len
condition|)
block|{
name|INP_SIZE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|in
operator|->
name|bit_offset
operator|!=
literal|0
condition|)
block|{
name|UNALIGNED
argument_list|()
expr_stmt|;
block|}
specifier|const
name|u8
modifier|*
specifier|const
name|ptr
init|=
name|in
operator|->
name|ptr
decl_stmt|;
name|in
operator|->
name|ptr
operator|+=
name|len
expr_stmt|;
name|in
operator|->
name|len
operator|-=
name|len
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/// Returns a pointer to write `len` bytes to, and advances the internal state
end_comment

begin_function
specifier|static
specifier|inline
name|u8
modifier|*
name|IO_write_bytes
parameter_list|(
name|ostream_t
modifier|*
specifier|const
name|out
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|>
name|out
operator|->
name|len
condition|)
block|{
name|OUT_SIZE
argument_list|()
expr_stmt|;
block|}
name|u8
modifier|*
specifier|const
name|ptr
init|=
name|out
operator|->
name|ptr
decl_stmt|;
name|out
operator|->
name|ptr
operator|+=
name|len
expr_stmt|;
name|out
operator|->
name|len
operator|-=
name|len
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/// Advance the inner state by `len` bytes
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|IO_advance_input
parameter_list|(
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|>
name|in
operator|->
name|len
condition|)
block|{
name|INP_SIZE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|in
operator|->
name|bit_offset
operator|!=
literal|0
condition|)
block|{
name|UNALIGNED
argument_list|()
expr_stmt|;
block|}
name|in
operator|->
name|ptr
operator|+=
name|len
expr_stmt|;
name|in
operator|->
name|len
operator|-=
name|len
expr_stmt|;
block|}
end_function

begin_comment
comment|/// Returns an `ostream_t` constructed from the given pointer and length
end_comment

begin_function
specifier|static
specifier|inline
name|ostream_t
name|IO_make_ostream
parameter_list|(
name|u8
modifier|*
name|out
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
return|return
operator|(
name|ostream_t
operator|)
block|{
name|out
block|,
name|len
block|}
return|;
block|}
end_function

begin_comment
comment|/// Returns an `istream_t` constructed from the given pointer and length
end_comment

begin_function
specifier|static
specifier|inline
name|istream_t
name|IO_make_istream
parameter_list|(
specifier|const
name|u8
modifier|*
name|in
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
return|return
operator|(
name|istream_t
operator|)
block|{
name|in
block|,
name|len
block|,
literal|0
block|}
return|;
block|}
end_function

begin_comment
comment|/// Returns an `istream_t` with the same base as `in`, and length `len`
end_comment

begin_comment
comment|/// Then, advance `in` to account for the consumed bytes
end_comment

begin_comment
comment|/// `in` must be byte aligned
end_comment

begin_function
specifier|static
specifier|inline
name|istream_t
name|IO_make_sub_istream
parameter_list|(
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
comment|// Consume `len` bytes of the parent stream
specifier|const
name|u8
modifier|*
specifier|const
name|ptr
init|=
name|IO_read_bytes
argument_list|(
name|in
argument_list|,
name|len
argument_list|)
decl_stmt|;
comment|// Make a substream using the pointer to those `len` bytes
return|return
name|IO_make_istream
argument_list|(
name|ptr
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/******* END IO STREAM OPERATIONS *********************************************/
end_comment

begin_comment
comment|/******* BITSTREAM OPERATIONS *************************************************/
end_comment

begin_comment
comment|/// Read `num` bits (up to 64) from `src + offset`, where `offset` is in bits
end_comment

begin_function
specifier|static
specifier|inline
name|u64
name|read_bits_LE
parameter_list|(
specifier|const
name|u8
modifier|*
name|src
parameter_list|,
specifier|const
name|int
name|num_bits
parameter_list|,
specifier|const
name|size_t
name|offset
parameter_list|)
block|{
if|if
condition|(
name|num_bits
operator|>
literal|64
condition|)
block|{
name|ERROR
argument_list|(
literal|"Attempt to read an invalid number of bits"
argument_list|)
expr_stmt|;
block|}
comment|// Skip over bytes that aren't in range
name|src
operator|+=
name|offset
operator|/
literal|8
expr_stmt|;
name|size_t
name|bit_offset
init|=
name|offset
operator|%
literal|8
decl_stmt|;
name|u64
name|res
init|=
literal|0
decl_stmt|;
name|int
name|shift
init|=
literal|0
decl_stmt|;
name|int
name|left
init|=
name|num_bits
decl_stmt|;
while|while
condition|(
name|left
operator|>
literal|0
condition|)
block|{
name|u64
name|mask
init|=
name|left
operator|>=
literal|8
condition|?
literal|0xff
else|:
operator|(
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|left
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
comment|// Read the next byte, shift it to account for the offset, and then mask
comment|// out the top part if we don't need all the bits
name|res
operator|+=
operator|(
operator|(
operator|(
name|u64
operator|)
operator|*
name|src
operator|++
operator|>>
name|bit_offset
operator|)
operator|&
name|mask
operator|)
operator|<<
name|shift
expr_stmt|;
name|shift
operator|+=
literal|8
operator|-
name|bit_offset
expr_stmt|;
name|left
operator|-=
literal|8
operator|-
name|bit_offset
expr_stmt|;
name|bit_offset
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/// Read bits from the end of a HUF or FSE bitstream.  `offset` is in bits, so
end_comment

begin_comment
comment|/// it updates `offset` to `offset - bits`, and then reads `bits` bits from
end_comment

begin_comment
comment|/// `src + offset`.  If the offset becomes negative, the extra bits at the
end_comment

begin_comment
comment|/// bottom are filled in with `0` bits instead of reading from before `src`.
end_comment

begin_function
specifier|static
specifier|inline
name|u64
name|STREAM_read_bits
parameter_list|(
specifier|const
name|u8
modifier|*
specifier|const
name|src
parameter_list|,
specifier|const
name|int
name|bits
parameter_list|,
name|i64
modifier|*
specifier|const
name|offset
parameter_list|)
block|{
operator|*
name|offset
operator|=
operator|*
name|offset
operator|-
name|bits
expr_stmt|;
name|size_t
name|actual_off
init|=
operator|*
name|offset
decl_stmt|;
name|size_t
name|actual_bits
init|=
name|bits
decl_stmt|;
comment|// Don't actually read bits from before the start of src, so if `*offset<
comment|// 0` fix actual_off and actual_bits to reflect the quantity to read
if|if
condition|(
operator|*
name|offset
operator|<
literal|0
condition|)
block|{
name|actual_bits
operator|+=
operator|*
name|offset
expr_stmt|;
name|actual_off
operator|=
literal|0
expr_stmt|;
block|}
name|u64
name|res
init|=
name|read_bits_LE
argument_list|(
name|src
argument_list|,
name|actual_bits
argument_list|,
name|actual_off
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|offset
operator|<
literal|0
condition|)
block|{
comment|// Fill in the bottom "overflowed" bits with 0's
name|res
operator|=
operator|-
operator|*
name|offset
operator|>=
literal|64
condition|?
literal|0
else|:
operator|(
name|res
operator|<<
operator|-
operator|*
name|offset
operator|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/******* END BITSTREAM OPERATIONS *********************************************/
end_comment

begin_comment
comment|/******* BIT COUNTING OPERATIONS **********************************************/
end_comment

begin_comment
comment|/// Returns `x`, where `2^x` is the largest power of 2 less than or equal to
end_comment

begin_comment
comment|/// `num`, or `-1` if `num == 0`.
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|highest_set_bit
parameter_list|(
specifier|const
name|u64
name|num
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|63
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|i
operator|)
operator|<=
name|num
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/******* END BIT COUNTING OPERATIONS ******************************************/
end_comment

begin_comment
comment|/******* HUFFMAN PRIMITIVES ***************************************************/
end_comment

begin_function
specifier|static
specifier|inline
name|u8
name|HUF_decode_symbol
parameter_list|(
specifier|const
name|HUF_dtable
modifier|*
specifier|const
name|dtable
parameter_list|,
name|u16
modifier|*
specifier|const
name|state
parameter_list|,
specifier|const
name|u8
modifier|*
specifier|const
name|src
parameter_list|,
name|i64
modifier|*
specifier|const
name|offset
parameter_list|)
block|{
comment|// Look up the symbol and number of bits to read
specifier|const
name|u8
name|symb
init|=
name|dtable
operator|->
name|symbols
index|[
operator|*
name|state
index|]
decl_stmt|;
specifier|const
name|u8
name|bits
init|=
name|dtable
operator|->
name|num_bits
index|[
operator|*
name|state
index|]
decl_stmt|;
specifier|const
name|u16
name|rest
init|=
name|STREAM_read_bits
argument_list|(
name|src
argument_list|,
name|bits
argument_list|,
name|offset
argument_list|)
decl_stmt|;
comment|// Shift `bits` bits out of the state, keeping the low order bits that
comment|// weren't necessary to determine this symbol.  Then add in the new bits
comment|// read from the stream.
operator|*
name|state
operator|=
operator|(
operator|(
operator|*
name|state
operator|<<
name|bits
operator|)
operator|+
name|rest
operator|)
operator|&
operator|(
operator|(
operator|(
name|u16
operator|)
literal|1
operator|<<
name|dtable
operator|->
name|max_bits
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
return|return
name|symb
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|HUF_init_state
parameter_list|(
specifier|const
name|HUF_dtable
modifier|*
specifier|const
name|dtable
parameter_list|,
name|u16
modifier|*
specifier|const
name|state
parameter_list|,
specifier|const
name|u8
modifier|*
specifier|const
name|src
parameter_list|,
name|i64
modifier|*
specifier|const
name|offset
parameter_list|)
block|{
comment|// Read in a full `dtable->max_bits` bits to initialize the state
specifier|const
name|u8
name|bits
init|=
name|dtable
operator|->
name|max_bits
decl_stmt|;
operator|*
name|state
operator|=
name|STREAM_read_bits
argument_list|(
name|src
argument_list|,
name|bits
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|HUF_decompress_1stream
parameter_list|(
specifier|const
name|HUF_dtable
modifier|*
specifier|const
name|dtable
parameter_list|,
name|ostream_t
modifier|*
specifier|const
name|out
parameter_list|,
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|)
block|{
specifier|const
name|size_t
name|len
init|=
name|IO_istream_len
argument_list|(
name|in
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|INP_SIZE
argument_list|()
expr_stmt|;
block|}
specifier|const
name|u8
modifier|*
specifier|const
name|src
init|=
name|IO_read_bytes
argument_list|(
name|in
argument_list|,
name|len
argument_list|)
decl_stmt|;
comment|// "Each bitstream must be read backward, that is starting from the end down
comment|// to the beginning. Therefore it's necessary to know the size of each
comment|// bitstream.
comment|//
comment|// It's also necessary to know exactly which bit is the latest. This is
comment|// detected by a final bit flag : the highest bit of latest byte is a
comment|// final-bit-flag. Consequently, a last byte of 0 is not possible. And the
comment|// final-bit-flag itself is not part of the useful bitstream. Hence, the
comment|// last byte contains between 0 and 7 useful bits."
specifier|const
name|int
name|padding
init|=
literal|8
operator|-
name|highest_set_bit
argument_list|(
name|src
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
decl_stmt|;
comment|// Offset starts at the end because HUF streams are read backwards
name|i64
name|bit_offset
init|=
name|len
operator|*
literal|8
operator|-
name|padding
decl_stmt|;
name|u16
name|state
decl_stmt|;
name|HUF_init_state
argument_list|(
name|dtable
argument_list|,
operator|&
name|state
argument_list|,
name|src
argument_list|,
operator|&
name|bit_offset
argument_list|)
expr_stmt|;
name|size_t
name|symbols_written
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|bit_offset
operator|>
operator|-
name|dtable
operator|->
name|max_bits
condition|)
block|{
comment|// Iterate over the stream, decoding one symbol at a time
name|IO_write_byte
argument_list|(
name|out
argument_list|,
name|HUF_decode_symbol
argument_list|(
name|dtable
argument_list|,
operator|&
name|state
argument_list|,
name|src
argument_list|,
operator|&
name|bit_offset
argument_list|)
argument_list|)
expr_stmt|;
name|symbols_written
operator|++
expr_stmt|;
block|}
comment|// "The process continues up to reading the required number of symbols per
comment|// stream. If a bitstream is not entirely and exactly consumed, hence
comment|// reaching exactly its beginning position with all bits consumed, the
comment|// decoding process is considered faulty."
comment|// When all symbols have been decoded, the final state value shouldn't have
comment|// any data from the stream, so it should have "read" dtable->max_bits from
comment|// before the start of `src`
comment|// Therefore `offset`, the edge to start reading new bits at, should be
comment|// dtable->max_bits before the start of the stream
if|if
condition|(
name|bit_offset
operator|!=
operator|-
name|dtable
operator|->
name|max_bits
condition|)
block|{
name|CORRUPTION
argument_list|()
expr_stmt|;
block|}
return|return
name|symbols_written
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|HUF_decompress_4stream
parameter_list|(
specifier|const
name|HUF_dtable
modifier|*
specifier|const
name|dtable
parameter_list|,
name|ostream_t
modifier|*
specifier|const
name|out
parameter_list|,
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|)
block|{
comment|// "Compressed size is provided explicitly : in the 4-streams variant,
comment|// bitstreams are preceded by 3 unsigned little-endian 16-bits values. Each
comment|// value represents the compressed size of one stream, in order. The last
comment|// stream size is deducted from total compressed size and from previously
comment|// decoded stream sizes"
specifier|const
name|size_t
name|csize1
init|=
name|IO_read_bits
argument_list|(
name|in
argument_list|,
literal|16
argument_list|)
decl_stmt|;
specifier|const
name|size_t
name|csize2
init|=
name|IO_read_bits
argument_list|(
name|in
argument_list|,
literal|16
argument_list|)
decl_stmt|;
specifier|const
name|size_t
name|csize3
init|=
name|IO_read_bits
argument_list|(
name|in
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|istream_t
name|in1
init|=
name|IO_make_sub_istream
argument_list|(
name|in
argument_list|,
name|csize1
argument_list|)
decl_stmt|;
name|istream_t
name|in2
init|=
name|IO_make_sub_istream
argument_list|(
name|in
argument_list|,
name|csize2
argument_list|)
decl_stmt|;
name|istream_t
name|in3
init|=
name|IO_make_sub_istream
argument_list|(
name|in
argument_list|,
name|csize3
argument_list|)
decl_stmt|;
name|istream_t
name|in4
init|=
name|IO_make_sub_istream
argument_list|(
name|in
argument_list|,
name|IO_istream_len
argument_list|(
name|in
argument_list|)
argument_list|)
decl_stmt|;
name|size_t
name|total_output
init|=
literal|0
decl_stmt|;
comment|// Decode each stream independently for simplicity
comment|// If we wanted to we could decode all 4 at the same time for speed,
comment|// utilizing more execution units
name|total_output
operator|+=
name|HUF_decompress_1stream
argument_list|(
name|dtable
argument_list|,
name|out
argument_list|,
operator|&
name|in1
argument_list|)
expr_stmt|;
name|total_output
operator|+=
name|HUF_decompress_1stream
argument_list|(
name|dtable
argument_list|,
name|out
argument_list|,
operator|&
name|in2
argument_list|)
expr_stmt|;
name|total_output
operator|+=
name|HUF_decompress_1stream
argument_list|(
name|dtable
argument_list|,
name|out
argument_list|,
operator|&
name|in3
argument_list|)
expr_stmt|;
name|total_output
operator|+=
name|HUF_decompress_1stream
argument_list|(
name|dtable
argument_list|,
name|out
argument_list|,
operator|&
name|in4
argument_list|)
expr_stmt|;
return|return
name|total_output
return|;
block|}
end_function

begin_comment
comment|/// Initializes a Huffman table using canonical Huffman codes
end_comment

begin_comment
comment|/// For more explanation on canonical Huffman codes see
end_comment

begin_comment
comment|/// http://www.cs.uofs.edu/~mccloske/courses/cmps340/huff_canonical_dec2015.html
end_comment

begin_comment
comment|/// Codes within a level are allocated in symbol order (i.e. smaller symbols get
end_comment

begin_comment
comment|/// earlier codes)
end_comment

begin_function
specifier|static
name|void
name|HUF_init_dtable
parameter_list|(
name|HUF_dtable
modifier|*
specifier|const
name|table
parameter_list|,
specifier|const
name|u8
modifier|*
specifier|const
name|bits
parameter_list|,
specifier|const
name|int
name|num_symbs
parameter_list|)
block|{
name|memset
argument_list|(
name|table
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|HUF_dtable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_symbs
operator|>
name|HUF_MAX_SYMBS
condition|)
block|{
name|ERROR
argument_list|(
literal|"Too many symbols for Huffman"
argument_list|)
expr_stmt|;
block|}
name|u8
name|max_bits
init|=
literal|0
decl_stmt|;
name|u16
name|rank_count
index|[
name|HUF_MAX_BITS
operator|+
literal|1
index|]
decl_stmt|;
name|memset
argument_list|(
name|rank_count
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rank_count
argument_list|)
argument_list|)
expr_stmt|;
comment|// Count the number of symbols for each number of bits, and determine the
comment|// depth of the tree
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num_symbs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bits
index|[
name|i
index|]
operator|>
name|HUF_MAX_BITS
condition|)
block|{
name|ERROR
argument_list|(
literal|"Huffman table depth too large"
argument_list|)
expr_stmt|;
block|}
name|max_bits
operator|=
name|MAX
argument_list|(
name|max_bits
argument_list|,
name|bits
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|rank_count
index|[
name|bits
index|[
name|i
index|]
index|]
operator|++
expr_stmt|;
block|}
specifier|const
name|size_t
name|table_size
init|=
literal|1
operator|<<
name|max_bits
decl_stmt|;
name|table
operator|->
name|max_bits
operator|=
name|max_bits
expr_stmt|;
name|table
operator|->
name|symbols
operator|=
name|malloc
argument_list|(
name|table_size
argument_list|)
expr_stmt|;
name|table
operator|->
name|num_bits
operator|=
name|malloc
argument_list|(
name|table_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|table
operator|->
name|symbols
operator|||
operator|!
name|table
operator|->
name|num_bits
condition|)
block|{
name|free
argument_list|(
name|table
operator|->
name|symbols
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|table
operator|->
name|num_bits
argument_list|)
expr_stmt|;
name|BAD_ALLOC
argument_list|()
expr_stmt|;
block|}
comment|// "Symbols are sorted by Weight. Within same Weight, symbols keep natural
comment|// order. Symbols with a Weight of zero are removed. Then, starting from
comment|// lowest weight, prefix codes are distributed in order."
name|u32
name|rank_idx
index|[
name|HUF_MAX_BITS
operator|+
literal|1
index|]
decl_stmt|;
comment|// Initialize the starting codes for each rank (number of bits)
name|rank_idx
index|[
name|max_bits
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|max_bits
init|;
name|i
operator|>=
literal|1
condition|;
name|i
operator|--
control|)
block|{
name|rank_idx
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|rank_idx
index|[
name|i
index|]
operator|+
name|rank_count
index|[
name|i
index|]
operator|*
operator|(
literal|1
operator|<<
operator|(
name|max_bits
operator|-
name|i
operator|)
operator|)
expr_stmt|;
comment|// The entire range takes the same number of bits so we can memset it
name|memset
argument_list|(
operator|&
name|table
operator|->
name|num_bits
index|[
name|rank_idx
index|[
name|i
index|]
index|]
argument_list|,
name|i
argument_list|,
name|rank_idx
index|[
name|i
operator|-
literal|1
index|]
operator|-
name|rank_idx
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rank_idx
index|[
literal|0
index|]
operator|!=
name|table_size
condition|)
block|{
name|CORRUPTION
argument_list|()
expr_stmt|;
block|}
comment|// Allocate codes and fill in the table
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num_symbs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bits
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
comment|// Allocate a code for this symbol and set its range in the table
specifier|const
name|u16
name|code
init|=
name|rank_idx
index|[
name|bits
index|[
name|i
index|]
index|]
decl_stmt|;
comment|// Since the code doesn't care about the bottom `max_bits - bits[i]`
comment|// bits of state, it gets a range that spans all possible values of
comment|// the lower bits
specifier|const
name|u16
name|len
init|=
literal|1
operator|<<
operator|(
name|max_bits
operator|-
name|bits
index|[
name|i
index|]
operator|)
decl_stmt|;
name|memset
argument_list|(
operator|&
name|table
operator|->
name|symbols
index|[
name|code
index|]
argument_list|,
name|i
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|rank_idx
index|[
name|bits
index|[
name|i
index|]
index|]
operator|+=
name|len
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|HUF_init_dtable_usingweights
parameter_list|(
name|HUF_dtable
modifier|*
specifier|const
name|table
parameter_list|,
specifier|const
name|u8
modifier|*
specifier|const
name|weights
parameter_list|,
specifier|const
name|int
name|num_symbs
parameter_list|)
block|{
comment|// +1 because the last weight is not transmitted in the header
if|if
condition|(
name|num_symbs
operator|+
literal|1
operator|>
name|HUF_MAX_SYMBS
condition|)
block|{
name|ERROR
argument_list|(
literal|"Too many symbols for Huffman"
argument_list|)
expr_stmt|;
block|}
name|u8
name|bits
index|[
name|HUF_MAX_SYMBS
index|]
decl_stmt|;
name|u64
name|weight_sum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num_symbs
condition|;
name|i
operator|++
control|)
block|{
comment|// Weights are in the same range as bit count
if|if
condition|(
name|weights
index|[
name|i
index|]
operator|>
name|HUF_MAX_BITS
condition|)
block|{
name|CORRUPTION
argument_list|()
expr_stmt|;
block|}
name|weight_sum
operator|+=
name|weights
index|[
name|i
index|]
operator|>
literal|0
condition|?
operator|(
name|u64
operator|)
literal|1
operator|<<
operator|(
name|weights
index|[
name|i
index|]
operator|-
literal|1
operator|)
else|:
literal|0
expr_stmt|;
block|}
comment|// Find the first power of 2 larger than the sum
specifier|const
name|int
name|max_bits
init|=
name|highest_set_bit
argument_list|(
name|weight_sum
argument_list|)
operator|+
literal|1
decl_stmt|;
specifier|const
name|u64
name|left_over
init|=
operator|(
operator|(
name|u64
operator|)
literal|1
operator|<<
name|max_bits
operator|)
operator|-
name|weight_sum
decl_stmt|;
comment|// If the left over isn't a power of 2, the weights are invalid
if|if
condition|(
name|left_over
operator|&
operator|(
name|left_over
operator|-
literal|1
operator|)
condition|)
block|{
name|CORRUPTION
argument_list|()
expr_stmt|;
block|}
comment|// left_over is used to find the last weight as it's not transmitted
comment|// by inverting 2^(weight - 1) we can determine the value of last_weight
specifier|const
name|int
name|last_weight
init|=
name|highest_set_bit
argument_list|(
name|left_over
argument_list|)
operator|+
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num_symbs
condition|;
name|i
operator|++
control|)
block|{
comment|// "Number_of_Bits = Number_of_Bits ? Max_Number_of_Bits + 1 - Weight : 0"
name|bits
index|[
name|i
index|]
operator|=
name|weights
index|[
name|i
index|]
operator|>
literal|0
condition|?
operator|(
name|max_bits
operator|+
literal|1
operator|-
name|weights
index|[
name|i
index|]
operator|)
else|:
literal|0
expr_stmt|;
block|}
name|bits
index|[
name|num_symbs
index|]
operator|=
name|max_bits
operator|+
literal|1
operator|-
name|last_weight
expr_stmt|;
comment|// Last weight is always non-zero
name|HUF_init_dtable
argument_list|(
name|table
argument_list|,
name|bits
argument_list|,
name|num_symbs
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|HUF_free_dtable
parameter_list|(
name|HUF_dtable
modifier|*
specifier|const
name|dtable
parameter_list|)
block|{
name|free
argument_list|(
name|dtable
operator|->
name|symbols
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dtable
operator|->
name|num_bits
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|dtable
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|HUF_dtable
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|HUF_copy_dtable
parameter_list|(
name|HUF_dtable
modifier|*
specifier|const
name|dst
parameter_list|,
specifier|const
name|HUF_dtable
modifier|*
specifier|const
name|src
parameter_list|)
block|{
if|if
condition|(
name|src
operator|->
name|max_bits
operator|==
literal|0
condition|)
block|{
name|memset
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|HUF_dtable
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|const
name|size_t
name|size
init|=
operator|(
name|size_t
operator|)
literal|1
operator|<<
name|src
operator|->
name|max_bits
decl_stmt|;
name|dst
operator|->
name|max_bits
operator|=
name|src
operator|->
name|max_bits
expr_stmt|;
name|dst
operator|->
name|symbols
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|dst
operator|->
name|num_bits
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dst
operator|->
name|symbols
operator|||
operator|!
name|dst
operator|->
name|num_bits
condition|)
block|{
name|BAD_ALLOC
argument_list|()
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|dst
operator|->
name|symbols
argument_list|,
name|src
operator|->
name|symbols
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dst
operator|->
name|num_bits
argument_list|,
name|src
operator|->
name|num_bits
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******* END HUFFMAN PRIMITIVES ***********************************************/
end_comment

begin_comment
comment|/******* FSE PRIMITIVES *******************************************************/
end_comment

begin_comment
comment|/// For more description of FSE see
end_comment

begin_comment
comment|/// https://github.com/Cyan4973/FiniteStateEntropy/
end_comment

begin_comment
comment|/// Allow a symbol to be decoded without updating state
end_comment

begin_function
specifier|static
specifier|inline
name|u8
name|FSE_peek_symbol
parameter_list|(
specifier|const
name|FSE_dtable
modifier|*
specifier|const
name|dtable
parameter_list|,
specifier|const
name|u16
name|state
parameter_list|)
block|{
return|return
name|dtable
operator|->
name|symbols
index|[
name|state
index|]
return|;
block|}
end_function

begin_comment
comment|/// Consumes bits from the input and uses the current state to determine the
end_comment

begin_comment
comment|/// next state
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|FSE_update_state
parameter_list|(
specifier|const
name|FSE_dtable
modifier|*
specifier|const
name|dtable
parameter_list|,
name|u16
modifier|*
specifier|const
name|state
parameter_list|,
specifier|const
name|u8
modifier|*
specifier|const
name|src
parameter_list|,
name|i64
modifier|*
specifier|const
name|offset
parameter_list|)
block|{
specifier|const
name|u8
name|bits
init|=
name|dtable
operator|->
name|num_bits
index|[
operator|*
name|state
index|]
decl_stmt|;
specifier|const
name|u16
name|rest
init|=
name|STREAM_read_bits
argument_list|(
name|src
argument_list|,
name|bits
argument_list|,
name|offset
argument_list|)
decl_stmt|;
operator|*
name|state
operator|=
name|dtable
operator|->
name|new_state_base
index|[
operator|*
name|state
index|]
operator|+
name|rest
expr_stmt|;
block|}
end_function

begin_comment
comment|/// Decodes a single FSE symbol and updates the offset
end_comment

begin_function
specifier|static
specifier|inline
name|u8
name|FSE_decode_symbol
parameter_list|(
specifier|const
name|FSE_dtable
modifier|*
specifier|const
name|dtable
parameter_list|,
name|u16
modifier|*
specifier|const
name|state
parameter_list|,
specifier|const
name|u8
modifier|*
specifier|const
name|src
parameter_list|,
name|i64
modifier|*
specifier|const
name|offset
parameter_list|)
block|{
specifier|const
name|u8
name|symb
init|=
name|FSE_peek_symbol
argument_list|(
name|dtable
argument_list|,
operator|*
name|state
argument_list|)
decl_stmt|;
name|FSE_update_state
argument_list|(
name|dtable
argument_list|,
name|state
argument_list|,
name|src
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|symb
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|FSE_init_state
parameter_list|(
specifier|const
name|FSE_dtable
modifier|*
specifier|const
name|dtable
parameter_list|,
name|u16
modifier|*
specifier|const
name|state
parameter_list|,
specifier|const
name|u8
modifier|*
specifier|const
name|src
parameter_list|,
name|i64
modifier|*
specifier|const
name|offset
parameter_list|)
block|{
comment|// Read in a full `accuracy_log` bits to initialize the state
specifier|const
name|u8
name|bits
init|=
name|dtable
operator|->
name|accuracy_log
decl_stmt|;
operator|*
name|state
operator|=
name|STREAM_read_bits
argument_list|(
name|src
argument_list|,
name|bits
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|FSE_decompress_interleaved2
parameter_list|(
specifier|const
name|FSE_dtable
modifier|*
specifier|const
name|dtable
parameter_list|,
name|ostream_t
modifier|*
specifier|const
name|out
parameter_list|,
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|)
block|{
specifier|const
name|size_t
name|len
init|=
name|IO_istream_len
argument_list|(
name|in
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|INP_SIZE
argument_list|()
expr_stmt|;
block|}
specifier|const
name|u8
modifier|*
specifier|const
name|src
init|=
name|IO_read_bytes
argument_list|(
name|in
argument_list|,
name|len
argument_list|)
decl_stmt|;
comment|// "Each bitstream must be read backward, that is starting from the end down
comment|// to the beginning. Therefore it's necessary to know the size of each
comment|// bitstream.
comment|//
comment|// It's also necessary to know exactly which bit is the latest. This is
comment|// detected by a final bit flag : the highest bit of latest byte is a
comment|// final-bit-flag. Consequently, a last byte of 0 is not possible. And the
comment|// final-bit-flag itself is not part of the useful bitstream. Hence, the
comment|// last byte contains between 0 and 7 useful bits."
specifier|const
name|int
name|padding
init|=
literal|8
operator|-
name|highest_set_bit
argument_list|(
name|src
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
decl_stmt|;
name|i64
name|offset
init|=
name|len
operator|*
literal|8
operator|-
name|padding
decl_stmt|;
name|u16
name|state1
decl_stmt|,
name|state2
decl_stmt|;
comment|// "The first state (State1) encodes the even indexed symbols, and the
comment|// second (State2) encodes the odd indexes. State1 is initialized first, and
comment|// then State2, and they take turns decoding a single symbol and updating
comment|// their state."
name|FSE_init_state
argument_list|(
name|dtable
argument_list|,
operator|&
name|state1
argument_list|,
name|src
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|FSE_init_state
argument_list|(
name|dtable
argument_list|,
operator|&
name|state2
argument_list|,
name|src
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
comment|// Decode until we overflow the stream
comment|// Since we decode in reverse order, overflowing the stream is offset going
comment|// negative
name|size_t
name|symbols_written
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|// "The number of symbols to decode is determined by tracking bitStream
comment|// overflow condition: If updating state after decoding a symbol would
comment|// require more bits than remain in the stream, it is assumed the extra
comment|// bits are 0. Then, the symbols for each of the final states are
comment|// decoded and the process is complete."
name|IO_write_byte
argument_list|(
name|out
argument_list|,
name|FSE_decode_symbol
argument_list|(
name|dtable
argument_list|,
operator|&
name|state1
argument_list|,
name|src
argument_list|,
operator|&
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|symbols_written
operator|++
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
comment|// There's still a symbol to decode in state2
name|IO_write_byte
argument_list|(
name|out
argument_list|,
name|FSE_peek_symbol
argument_list|(
name|dtable
argument_list|,
name|state2
argument_list|)
argument_list|)
expr_stmt|;
name|symbols_written
operator|++
expr_stmt|;
break|break;
block|}
name|IO_write_byte
argument_list|(
name|out
argument_list|,
name|FSE_decode_symbol
argument_list|(
name|dtable
argument_list|,
operator|&
name|state2
argument_list|,
name|src
argument_list|,
operator|&
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|symbols_written
operator|++
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
comment|// There's still a symbol to decode in state1
name|IO_write_byte
argument_list|(
name|out
argument_list|,
name|FSE_peek_symbol
argument_list|(
name|dtable
argument_list|,
name|state1
argument_list|)
argument_list|)
expr_stmt|;
name|symbols_written
operator|++
expr_stmt|;
break|break;
block|}
block|}
return|return
name|symbols_written
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|FSE_init_dtable
parameter_list|(
name|FSE_dtable
modifier|*
specifier|const
name|dtable
parameter_list|,
specifier|const
name|i16
modifier|*
specifier|const
name|norm_freqs
parameter_list|,
specifier|const
name|int
name|num_symbs
parameter_list|,
specifier|const
name|int
name|accuracy_log
parameter_list|)
block|{
if|if
condition|(
name|accuracy_log
operator|>
name|FSE_MAX_ACCURACY_LOG
condition|)
block|{
name|ERROR
argument_list|(
literal|"FSE accuracy too large"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|num_symbs
operator|>
name|FSE_MAX_SYMBS
condition|)
block|{
name|ERROR
argument_list|(
literal|"Too many symbols for FSE"
argument_list|)
expr_stmt|;
block|}
name|dtable
operator|->
name|accuracy_log
operator|=
name|accuracy_log
expr_stmt|;
specifier|const
name|size_t
name|size
init|=
operator|(
name|size_t
operator|)
literal|1
operator|<<
name|accuracy_log
decl_stmt|;
name|dtable
operator|->
name|symbols
operator|=
name|malloc
argument_list|(
name|size
operator|*
sizeof|sizeof
argument_list|(
name|u8
argument_list|)
argument_list|)
expr_stmt|;
name|dtable
operator|->
name|num_bits
operator|=
name|malloc
argument_list|(
name|size
operator|*
sizeof|sizeof
argument_list|(
name|u8
argument_list|)
argument_list|)
expr_stmt|;
name|dtable
operator|->
name|new_state_base
operator|=
name|malloc
argument_list|(
name|size
operator|*
sizeof|sizeof
argument_list|(
name|u16
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dtable
operator|->
name|symbols
operator|||
operator|!
name|dtable
operator|->
name|num_bits
operator|||
operator|!
name|dtable
operator|->
name|new_state_base
condition|)
block|{
name|BAD_ALLOC
argument_list|()
expr_stmt|;
block|}
comment|// Used to determine how many bits need to be read for each state,
comment|// and where the destination range should start
comment|// Needs to be u16 because max value is 2 * max number of symbols,
comment|// which can be larger than a byte can store
name|u16
name|state_desc
index|[
name|FSE_MAX_SYMBS
index|]
decl_stmt|;
comment|// "Symbols are scanned in their natural order for "less than 1"
comment|// probabilities. Symbols with this probability are being attributed a
comment|// single cell, starting from the end of the table. These symbols define a
comment|// full state reset, reading Accuracy_Log bits."
name|int
name|high_threshold
init|=
name|size
decl_stmt|;
for|for
control|(
name|int
name|s
init|=
literal|0
init|;
name|s
operator|<
name|num_symbs
condition|;
name|s
operator|++
control|)
block|{
comment|// Scan for low probability symbols to put at the top
if|if
condition|(
name|norm_freqs
index|[
name|s
index|]
operator|==
operator|-
literal|1
condition|)
block|{
name|dtable
operator|->
name|symbols
index|[
operator|--
name|high_threshold
index|]
operator|=
name|s
expr_stmt|;
name|state_desc
index|[
name|s
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|// "All remaining symbols are sorted in their natural order. Starting from
comment|// symbol 0 and table position 0, each symbol gets attributed as many cells
comment|// as its probability. Cell allocation is spreaded, not linear."
comment|// Place the rest in the table
specifier|const
name|u16
name|step
init|=
operator|(
name|size
operator|>>
literal|1
operator|)
operator|+
operator|(
name|size
operator|>>
literal|3
operator|)
operator|+
literal|3
decl_stmt|;
specifier|const
name|u16
name|mask
init|=
name|size
operator|-
literal|1
decl_stmt|;
name|u16
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|s
init|=
literal|0
init|;
name|s
operator|<
name|num_symbs
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|norm_freqs
index|[
name|s
index|]
operator|<=
literal|0
condition|)
block|{
continue|continue;
block|}
name|state_desc
index|[
name|s
index|]
operator|=
name|norm_freqs
index|[
name|s
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|norm_freqs
index|[
name|s
index|]
condition|;
name|i
operator|++
control|)
block|{
comment|// Give `norm_freqs[s]` states to symbol s
name|dtable
operator|->
name|symbols
index|[
name|pos
index|]
operator|=
name|s
expr_stmt|;
comment|// "A position is skipped if already occupied, typically by a "less
comment|// than 1" probability symbol."
do|do
block|{
name|pos
operator|=
operator|(
name|pos
operator|+
name|step
operator|)
operator|&
name|mask
expr_stmt|;
block|}
do|while
condition|(
name|pos
operator|>=
name|high_threshold
condition|)
do|;
comment|// Note: no other collision checking is necessary as `step` is
comment|// coprime to `size`, so the cycle will visit each position exactly
comment|// once
block|}
block|}
if|if
condition|(
name|pos
operator|!=
literal|0
condition|)
block|{
name|CORRUPTION
argument_list|()
expr_stmt|;
block|}
comment|// Now we can fill baseline and num bits
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|u8
name|symbol
init|=
name|dtable
operator|->
name|symbols
index|[
name|i
index|]
decl_stmt|;
name|u16
name|next_state_desc
init|=
name|state_desc
index|[
name|symbol
index|]
operator|++
decl_stmt|;
comment|// Fills in the table appropriately, next_state_desc increases by symbol
comment|// over time, decreasing number of bits
name|dtable
operator|->
name|num_bits
index|[
name|i
index|]
operator|=
call|(
name|u8
call|)
argument_list|(
name|accuracy_log
operator|-
name|highest_set_bit
argument_list|(
name|next_state_desc
argument_list|)
argument_list|)
expr_stmt|;
comment|// Baseline increases until the bit threshold is passed, at which point
comment|// it resets to 0
name|dtable
operator|->
name|new_state_base
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|u16
operator|)
name|next_state_desc
operator|<<
name|dtable
operator|->
name|num_bits
index|[
name|i
index|]
operator|)
operator|-
name|size
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/// Decode an FSE header as defined in the Zstandard format specification and
end_comment

begin_comment
comment|/// use the decoded frequencies to initialize a decoding table.
end_comment

begin_function
specifier|static
name|void
name|FSE_decode_header
parameter_list|(
name|FSE_dtable
modifier|*
specifier|const
name|dtable
parameter_list|,
name|istream_t
modifier|*
specifier|const
name|in
parameter_list|,
specifier|const
name|int
name|max_accuracy_log
parameter_list|)
block|{
comment|// "An FSE distribution table describes the probabilities of all symbols
comment|// from 0 to the last present one (included) on a normalized scale of 1<<
comment|// Accuracy_Log .
comment|//
comment|// It's a bitstream which is read forward, in little-endian fashion. It's
comment|// not necessary to know its exact size, since it will be discovered and
comment|// reported by the decoding process.
if|if
condition|(
name|max_accuracy_log
operator|>
name|FSE_MAX_ACCURACY_LOG
condition|)
block|{
name|ERROR
argument_list|(
literal|"FSE accuracy too large"
argument_list|)
expr_stmt|;
block|}
comment|// The bitstream starts by reporting on which scale it operates.
comment|// Accuracy_Log = low4bits + 5. Note that maximum Accuracy_Log for literal
comment|// and match lengths is 9, and for offsets is 8. Higher values are
comment|// considered errors."
specifier|const
name|int
name|accuracy_log
init|=
literal|5
operator|+
name|IO_read_bits
argument_list|(
name|in
argument_list|,
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
name|accuracy_log
operator|>
name|max_accuracy_log
condition|)
block|{
name|ERROR
argument_list|(
literal|"FSE accuracy too large"
argument_list|)
expr_stmt|;
block|}
comment|// "Then follows each symbol value, from 0 to last present one. The number
comment|// of bits used by each field is variable. It depends on :
comment|//
comment|// Remaining probabilities + 1 : example : Presuming an Accuracy_Log of 8,
comment|// and presuming 100 probabilities points have already been distributed, the
comment|// decoder may read any value from 0 to 255 - 100 + 1 == 156 (inclusive).
comment|// Therefore, it must read log2sup(156) == 8 bits.
comment|//
comment|// Value decoded : small values use 1 less bit : example : Presuming values
comment|// from 0 to 156 (inclusive) are possible, 255-156 = 99 values are remaining
comment|// in an 8-bits field. They are used this way : first 99 values (hence from
comment|// 0 to 98) use only 7 bits, values from 99 to 156 use 8 bits. "
name|i32
name|remaining
init|=
literal|1
operator|<<
name|accuracy_log
decl_stmt|;
name|i16
name|frequencies
index|[
name|FSE_MAX_SYMBS
index|]
decl_stmt|;
name|int
name|symb
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|remaining
operator|>
literal|0
operator|&&
name|symb
operator|<
name|FSE_MAX_SYMBS
condition|)
block|{
comment|// Log of the number of possible values we could read
name|int
name|bits
init|=
name|highest_set_bit
argument_list|(
name|remaining
operator|+
literal|1
argument_list|)
operator|+
literal|1
decl_stmt|;
name|u16
name|val
init|=
name|IO_read_bits
argument_list|(
name|in
argument_list|,
name|bits
argument_list|)
decl_stmt|;
comment|// Try to mask out the lower bits to see if it qualifies for the "small
comment|// value" threshold
specifier|const
name|u16
name|lower_mask
init|=
operator|(
operator|(
name|u16
operator|)
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
decl_stmt|;
specifier|const
name|u16
name|threshold
init|=
operator|(
operator|(
name|u16
operator|)
literal|1
operator|<<
name|bits
operator|)
operator|-
literal|1
operator|-
operator|(
name|remaining
operator|+
literal|1
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|lower_mask
operator|)
operator|<
name|threshold
condition|)
block|{
name|IO_rewind_bits
argument_list|(
name|in
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|val
operator|=
name|val
operator|&
name|lower_mask
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|>
name|lower_mask
condition|)
block|{
name|val
operator|=
name|val
operator|-
name|threshold
expr_stmt|;
block|}
comment|// "Probability is obtained from Value decoded by following formula :
comment|// Proba = value - 1"
specifier|const
name|i16
name|proba
init|=
operator|(
name|i16
operator|)
name|val
operator|-
literal|1
decl_stmt|;
comment|// "It means value 0 becomes negative probability -1. -1 is a special
comment|// probability, which means "less than 1". Its effect on distribution
comment|// table is described in next paragraph. For the purpose of calculating
comment|// cumulated distribution, it counts as one."
name|remaining
operator|-=
name|proba
operator|<
literal|0
condition|?
operator|-
name|proba
else|:
name|proba
expr_stmt|;
name|frequencies
index|[
name|symb
index|]
operator|=
name|proba
expr_stmt|;
name|symb
operator|++
expr_stmt|;
comment|// "When a symbol has a probability of zero, it is followed by a 2-bits
comment|// repeat flag. This repeat flag tells how many probabilities of zeroes
comment|// follow the current one. It provides a number ranging from 0 to 3. If
comment|// it is a 3, another 2-bits repeat flag follows, and so on."
if|if
condition|(
name|proba
operator|==
literal|0
condition|)
block|{
comment|// Read the next two bits to see how many more 0s
name|int
name|repeat
init|=
name|IO_read_bits
argument_list|(
name|in
argument_list|,
literal|2
argument_list|)
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|repeat
operator|&&
name|symb
operator|<
name|FSE_MAX_SYMBS
condition|;
name|i
operator|++
control|)
block|{
name|frequencies
index|[
name|symb
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|repeat
operator|==
literal|3
condition|)
block|{
name|repeat
operator|=
name|IO_read_bits
argument_list|(
name|in
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
block|}
block|}
name|IO_align_stream
argument_list|(
name|in
argument_list|)
expr_stmt|;
comment|// "When last symbol reaches cumulated total of 1<< Accuracy_Log, decoding
comment|// is complete. If the last symbol makes cumulated total go above 1<<
comment|// Accuracy_Log, distribution is considered corrupted."
if|if
condition|(
name|remaining
operator|!=
literal|0
operator|||
name|symb
operator|>=
name|FSE_MAX_SYMBS
condition|)
block|{
name|CORRUPTION
argument_list|()
expr_stmt|;
block|}
comment|// Initialize the decoding table using the determined weights
name|FSE_init_dtable
argument_list|(
name|dtable
argument_list|,
name|frequencies
argument_list|,
name|symb
argument_list|,
name|accuracy_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|FSE_init_dtable_rle
parameter_list|(
name|FSE_dtable
modifier|*
specifier|const
name|dtable
parameter_list|,
specifier|const
name|u8
name|symb
parameter_list|)
block|{
name|dtable
operator|->
name|symbols
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|u8
argument_list|)
argument_list|)
expr_stmt|;
name|dtable
operator|->
name|num_bits
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|u8
argument_list|)
argument_list|)
expr_stmt|;
name|dtable
operator|->
name|new_state_base
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|u16
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dtable
operator|->
name|symbols
operator|||
operator|!
name|dtable
operator|->
name|num_bits
operator|||
operator|!
name|dtable
operator|->
name|new_state_base
condition|)
block|{
name|BAD_ALLOC
argument_list|()
expr_stmt|;
block|}
comment|// This setup will always have a state of 0, always return symbol `symb`,
comment|// and never consume any bits
name|dtable
operator|->
name|symbols
index|[
literal|0
index|]
operator|=
name|symb
expr_stmt|;
name|dtable
operator|->
name|num_bits
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|dtable
operator|->
name|new_state_base
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|dtable
operator|->
name|accuracy_log
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|FSE_free_dtable
parameter_list|(
name|FSE_dtable
modifier|*
specifier|const
name|dtable
parameter_list|)
block|{
name|free
argument_list|(
name|dtable
operator|->
name|symbols
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dtable
operator|->
name|num_bits
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dtable
operator|->
name|new_state_base
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|dtable
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|FSE_dtable
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|FSE_copy_dtable
parameter_list|(
name|FSE_dtable
modifier|*
specifier|const
name|dst
parameter_list|,
specifier|const
name|FSE_dtable
modifier|*
specifier|const
name|src
parameter_list|)
block|{
if|if
condition|(
name|src
operator|->
name|accuracy_log
operator|==
literal|0
condition|)
block|{
name|memset
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|FSE_dtable
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|size_t
name|size
init|=
operator|(
name|size_t
operator|)
literal|1
operator|<<
name|src
operator|->
name|accuracy_log
decl_stmt|;
name|dst
operator|->
name|accuracy_log
operator|=
name|src
operator|->
name|accuracy_log
expr_stmt|;
name|dst
operator|->
name|symbols
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|dst
operator|->
name|num_bits
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|dst
operator|->
name|new_state_base
operator|=
name|malloc
argument_list|(
name|size
operator|*
sizeof|sizeof
argument_list|(
name|u16
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dst
operator|->
name|symbols
operator|||
operator|!
name|dst
operator|->
name|num_bits
operator|||
operator|!
name|dst
operator|->
name|new_state_base
condition|)
block|{
name|BAD_ALLOC
argument_list|()
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|dst
operator|->
name|symbols
argument_list|,
name|src
operator|->
name|symbols
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dst
operator|->
name|num_bits
argument_list|,
name|src
operator|->
name|num_bits
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dst
operator|->
name|new_state_base
argument_list|,
name|src
operator|->
name|new_state_base
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|u16
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******* END FSE PRIMITIVES ***************************************************/
end_comment

end_unit

