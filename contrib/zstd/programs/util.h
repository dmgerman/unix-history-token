begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * util.h - utility functions  *  * Copyright (c) 2016-present, Przemyslaw Skibinski, Yann Collet, Facebook, Inc.  * All rights reserved.  *  * This source code is licensed under the BSD-style license found in the  * LICENSE file in the root directory of this source tree. An additional grant  * of patent rights can be found in the PATENTS file in the same directory.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|UTIL_H_MODULE
end_ifndef

begin_define
define|#
directive|define
name|UTIL_H_MODULE
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/*-**************************************** *  Dependencies ******************************************/
include|#
directive|include
file|"platform.h"
comment|/* PLATFORM_POSIX_VERSION */
include|#
directive|include
file|<stdlib.h>
comment|/* malloc */
include|#
directive|include
file|<stddef.h>
comment|/* size_t, ptrdiff_t */
include|#
directive|include
file|<stdio.h>
comment|/* fprintf */
include|#
directive|include
file|<string.h>
comment|/* strncmp */
include|#
directive|include
file|<sys/types.h>
comment|/* stat, utime */
include|#
directive|include
file|<sys/stat.h>
comment|/* stat */
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
include|#
directive|include
file|<sys/utime.h>
comment|/* utime */
include|#
directive|include
file|<io.h>
comment|/* _chmod */
else|#
directive|else
include|#
directive|include
file|<unistd.h>
comment|/* chown, stat */
include|#
directive|include
file|<utime.h>
comment|/* utime */
endif|#
directive|endif
include|#
directive|include
file|<time.h>
comment|/* time */
include|#
directive|include
file|<errno.h>
include|#
directive|include
file|"mem.h"
comment|/* U32, U64 */
comment|/* ************************************************************ * Avoid fseek()'s 2GiB barrier with MSVC, MacOS, *BSD, MinGW ***************************************************************/
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
operator|(
name|_MSC_VER
operator|>=
literal|1400
operator|)
define|#
directive|define
name|UTIL_fseek
value|_fseeki64
elif|#
directive|elif
operator|!
name|defined
argument_list|(
name|__64BIT__
argument_list|)
operator|&&
operator|(
name|PLATFORM_POSIX_VERSION
operator|>=
literal|200112L
operator|)
comment|/* No point defining Large file for 64 bit */
define|#
directive|define
name|UTIL_fseek
value|fseeko
elif|#
directive|elif
name|defined
argument_list|(
name|__MINGW32__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__MSVCRT__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__STRICT_ANSI__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__NO_MINGW_LFS
argument_list|)
define|#
directive|define
name|UTIL_fseek
value|fseeko64
else|#
directive|else
define|#
directive|define
name|UTIL_fseek
value|fseek
endif|#
directive|endif
comment|/*-**************************************** *  Sleep functions: Windows - Posix - others ******************************************/
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
include|#
directive|include
file|<windows.h>
define|#
directive|define
name|SET_REALTIME_PRIORITY
value|SetPriorityClass(GetCurrentProcess(), REALTIME_PRIORITY_CLASS)
define|#
directive|define
name|UTIL_sleep
parameter_list|(
name|s
parameter_list|)
value|Sleep(1000*s)
define|#
directive|define
name|UTIL_sleepMilli
parameter_list|(
name|milli
parameter_list|)
value|Sleep(milli)
elif|#
directive|elif
name|PLATFORM_POSIX_VERSION
operator|>=
literal|0
comment|/* Unix-like operating system */
include|#
directive|include
file|<unistd.h>
include|#
directive|include
file|<sys/resource.h>
comment|/* setpriority */
include|#
directive|include
file|<time.h>
comment|/* clock_t, nanosleep, clock, CLOCKS_PER_SEC */
if|#
directive|if
name|defined
argument_list|(
name|PRIO_PROCESS
argument_list|)
define|#
directive|define
name|SET_REALTIME_PRIORITY
value|setpriority(PRIO_PROCESS, 0, -20)
else|#
directive|else
define|#
directive|define
name|SET_REALTIME_PRIORITY
comment|/* disabled */
endif|#
directive|endif
define|#
directive|define
name|UTIL_sleep
parameter_list|(
name|s
parameter_list|)
value|sleep(s)
if|#
directive|if
operator|(
name|defined
argument_list|(
name|__linux__
argument_list|)
operator|&&
operator|(
name|PLATFORM_POSIX_VERSION
operator|>=
literal|199309L
operator|)
operator|)
operator|||
operator|(
name|PLATFORM_POSIX_VERSION
operator|>=
literal|200112L
operator|)
comment|/* nanosleep requires POSIX.1-2001 */
define|#
directive|define
name|UTIL_sleepMilli
parameter_list|(
name|milli
parameter_list|)
value|{ struct timespec t; t.tv_sec=0; t.tv_nsec=milli*1000000ULL; nanosleep(&t, NULL); }
else|#
directive|else
define|#
directive|define
name|UTIL_sleepMilli
parameter_list|(
name|milli
parameter_list|)
comment|/* disabled */
endif|#
directive|endif
else|#
directive|else
define|#
directive|define
name|SET_REALTIME_PRIORITY
comment|/* disabled */
define|#
directive|define
name|UTIL_sleep
parameter_list|(
name|s
parameter_list|)
comment|/* disabled */
define|#
directive|define
name|UTIL_sleepMilli
parameter_list|(
name|milli
parameter_list|)
comment|/* disabled */
endif|#
directive|endif
comment|/* ************************************* *  Constants ***************************************/
define|#
directive|define
name|LIST_SIZE_INCREASE
value|(8*1024)
comment|/*-**************************************** *  Compiler specifics ******************************************/
if|#
directive|if
name|defined
argument_list|(
name|__INTEL_COMPILER
argument_list|)
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|177
name|)
comment|/* disable: message #177: function was declared but never referenced, useful with UTIL_STATIC */
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
define|#
directive|define
name|UTIL_STATIC
value|static __attribute__((unused))
elif|#
directive|elif
name|defined
argument_list|(
name|__cplusplus
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|__STDC_VERSION__
argument_list|)
operator|&&
operator|(
name|__STDC_VERSION__
operator|>=
literal|199901L
operator|)
comment|/* C99 */
operator|)
define|#
directive|define
name|UTIL_STATIC
value|static inline
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
define|#
directive|define
name|UTIL_STATIC
value|static __inline
else|#
directive|else
define|#
directive|define
name|UTIL_STATIC
value|static
comment|/* this version may generate warnings for unused static functions; disable the relevant warning */
endif|#
directive|endif
comment|/*-**************************************** *  Time functions ******************************************/
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
comment|/* Windows */
typedef|typedef
name|LARGE_INTEGER
name|UTIL_freq_t
typedef|;
typedef|typedef
name|LARGE_INTEGER
name|UTIL_time_t
typedef|;
name|UTIL_STATIC
name|void
name|UTIL_initTimer
parameter_list|(
name|UTIL_freq_t
modifier|*
name|ticksPerSecond
parameter_list|)
block|{
if|if
condition|(
operator|!
name|QueryPerformanceFrequency
argument_list|(
name|ticksPerSecond
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: QueryPerformance not present\n"
argument_list|)
expr_stmt|;
block|}
name|UTIL_STATIC
name|void
name|UTIL_getTime
parameter_list|(
name|UTIL_time_t
modifier|*
name|x
parameter_list|)
block|{
name|QueryPerformanceCounter
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|UTIL_STATIC
name|U64
name|UTIL_getSpanTimeMicro
parameter_list|(
name|UTIL_freq_t
name|ticksPerSecond
parameter_list|,
name|UTIL_time_t
name|clockStart
parameter_list|,
name|UTIL_time_t
name|clockEnd
parameter_list|)
block|{
return|return
literal|1000000ULL
operator|*
operator|(
name|clockEnd
operator|.
name|QuadPart
operator|-
name|clockStart
operator|.
name|QuadPart
operator|)
operator|/
name|ticksPerSecond
operator|.
name|QuadPart
return|;
block|}
name|UTIL_STATIC
name|U64
name|UTIL_getSpanTimeNano
parameter_list|(
name|UTIL_freq_t
name|ticksPerSecond
parameter_list|,
name|UTIL_time_t
name|clockStart
parameter_list|,
name|UTIL_time_t
name|clockEnd
parameter_list|)
block|{
return|return
literal|1000000000ULL
operator|*
operator|(
name|clockEnd
operator|.
name|QuadPart
operator|-
name|clockStart
operator|.
name|QuadPart
operator|)
operator|/
name|ticksPerSecond
operator|.
name|QuadPart
return|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__MACH__
argument_list|)
include|#
directive|include
file|<mach/mach_time.h>
typedef|typedef
name|mach_timebase_info_data_t
name|UTIL_freq_t
typedef|;
typedef|typedef
name|U64
name|UTIL_time_t
typedef|;
name|UTIL_STATIC
name|void
name|UTIL_initTimer
parameter_list|(
name|UTIL_freq_t
modifier|*
name|rate
parameter_list|)
block|{
name|mach_timebase_info
argument_list|(
name|rate
argument_list|)
expr_stmt|;
block|}
name|UTIL_STATIC
name|void
name|UTIL_getTime
parameter_list|(
name|UTIL_time_t
modifier|*
name|x
parameter_list|)
block|{
operator|*
name|x
operator|=
name|mach_absolute_time
argument_list|()
expr_stmt|;
block|}
name|UTIL_STATIC
name|U64
name|UTIL_getSpanTimeMicro
parameter_list|(
name|UTIL_freq_t
name|rate
parameter_list|,
name|UTIL_time_t
name|clockStart
parameter_list|,
name|UTIL_time_t
name|clockEnd
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|clockEnd
operator|-
name|clockStart
operator|)
operator|*
operator|(
name|U64
operator|)
name|rate
operator|.
name|numer
operator|)
operator|/
operator|(
operator|(
name|U64
operator|)
name|rate
operator|.
name|denom
operator|)
operator|)
operator|/
literal|1000ULL
return|;
block|}
name|UTIL_STATIC
name|U64
name|UTIL_getSpanTimeNano
parameter_list|(
name|UTIL_freq_t
name|rate
parameter_list|,
name|UTIL_time_t
name|clockStart
parameter_list|,
name|UTIL_time_t
name|clockEnd
parameter_list|)
block|{
return|return
operator|(
operator|(
name|clockEnd
operator|-
name|clockStart
operator|)
operator|*
operator|(
name|U64
operator|)
name|rate
operator|.
name|numer
operator|)
operator|/
operator|(
operator|(
name|U64
operator|)
name|rate
operator|.
name|denom
operator|)
return|;
block|}
elif|#
directive|elif
operator|(
name|PLATFORM_POSIX_VERSION
operator|>=
literal|200112L
operator|)
include|#
directive|include
file|<sys/times.h>
comment|/* times */
typedef|typedef
name|U64
name|UTIL_freq_t
typedef|;
typedef|typedef
name|U64
name|UTIL_time_t
typedef|;
name|UTIL_STATIC
name|void
name|UTIL_initTimer
parameter_list|(
name|UTIL_freq_t
modifier|*
name|ticksPerSecond
parameter_list|)
block|{
operator|*
name|ticksPerSecond
operator|=
name|sysconf
argument_list|(
name|_SC_CLK_TCK
argument_list|)
expr_stmt|;
block|}
name|UTIL_STATIC
name|void
name|UTIL_getTime
parameter_list|(
name|UTIL_time_t
modifier|*
name|x
parameter_list|)
block|{
name|struct
name|tms
name|junk
decl_stmt|;
name|clock_t
name|newTicks
init|=
operator|(
name|clock_t
operator|)
name|times
argument_list|(
operator|&
name|junk
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|junk
expr_stmt|;
operator|*
name|x
operator|=
operator|(
name|UTIL_time_t
operator|)
name|newTicks
expr_stmt|;
block|}
name|UTIL_STATIC
name|U64
name|UTIL_getSpanTimeMicro
parameter_list|(
name|UTIL_freq_t
name|ticksPerSecond
parameter_list|,
name|UTIL_time_t
name|clockStart
parameter_list|,
name|UTIL_time_t
name|clockEnd
parameter_list|)
block|{
return|return
literal|1000000ULL
operator|*
operator|(
name|clockEnd
operator|-
name|clockStart
operator|)
operator|/
name|ticksPerSecond
return|;
block|}
name|UTIL_STATIC
name|U64
name|UTIL_getSpanTimeNano
parameter_list|(
name|UTIL_freq_t
name|ticksPerSecond
parameter_list|,
name|UTIL_time_t
name|clockStart
parameter_list|,
name|UTIL_time_t
name|clockEnd
parameter_list|)
block|{
return|return
literal|1000000000ULL
operator|*
operator|(
name|clockEnd
operator|-
name|clockStart
operator|)
operator|/
name|ticksPerSecond
return|;
block|}
else|#
directive|else
comment|/* relies on standard C (note : clock_t measurements can be wrong when using multi-threading) */
typedef|typedef
name|clock_t
name|UTIL_freq_t
typedef|;
typedef|typedef
name|clock_t
name|UTIL_time_t
typedef|;
name|UTIL_STATIC
name|void
name|UTIL_initTimer
parameter_list|(
name|UTIL_freq_t
modifier|*
name|ticksPerSecond
parameter_list|)
block|{
operator|*
name|ticksPerSecond
operator|=
literal|0
expr_stmt|;
block|}
name|UTIL_STATIC
name|void
name|UTIL_getTime
parameter_list|(
name|UTIL_time_t
modifier|*
name|x
parameter_list|)
block|{
operator|*
name|x
operator|=
name|clock
argument_list|()
expr_stmt|;
block|}
name|UTIL_STATIC
name|U64
name|UTIL_getSpanTimeMicro
parameter_list|(
name|UTIL_freq_t
name|ticksPerSecond
parameter_list|,
name|UTIL_time_t
name|clockStart
parameter_list|,
name|UTIL_time_t
name|clockEnd
parameter_list|)
block|{
operator|(
name|void
operator|)
name|ticksPerSecond
expr_stmt|;
return|return
literal|1000000ULL
operator|*
operator|(
name|clockEnd
operator|-
name|clockStart
operator|)
operator|/
name|CLOCKS_PER_SEC
return|;
block|}
name|UTIL_STATIC
name|U64
name|UTIL_getSpanTimeNano
parameter_list|(
name|UTIL_freq_t
name|ticksPerSecond
parameter_list|,
name|UTIL_time_t
name|clockStart
parameter_list|,
name|UTIL_time_t
name|clockEnd
parameter_list|)
block|{
operator|(
name|void
operator|)
name|ticksPerSecond
expr_stmt|;
return|return
literal|1000000000ULL
operator|*
operator|(
name|clockEnd
operator|-
name|clockStart
operator|)
operator|/
name|CLOCKS_PER_SEC
return|;
block|}
endif|#
directive|endif
comment|/* returns time span in microseconds */
name|UTIL_STATIC
name|U64
name|UTIL_clockSpanMicro
parameter_list|(
name|UTIL_time_t
name|clockStart
parameter_list|,
name|UTIL_freq_t
name|ticksPerSecond
parameter_list|)
block|{
name|UTIL_time_t
name|clockEnd
decl_stmt|;
name|UTIL_getTime
argument_list|(
operator|&
name|clockEnd
argument_list|)
expr_stmt|;
return|return
name|UTIL_getSpanTimeMicro
argument_list|(
name|ticksPerSecond
argument_list|,
name|clockStart
argument_list|,
name|clockEnd
argument_list|)
return|;
block|}
name|UTIL_STATIC
name|void
name|UTIL_waitForNextTick
parameter_list|(
name|UTIL_freq_t
name|ticksPerSecond
parameter_list|)
block|{
name|UTIL_time_t
name|clockStart
decl_stmt|,
name|clockEnd
decl_stmt|;
name|UTIL_getTime
argument_list|(
operator|&
name|clockStart
argument_list|)
expr_stmt|;
do|do
block|{
name|UTIL_getTime
argument_list|(
operator|&
name|clockEnd
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|UTIL_getSpanTimeNano
argument_list|(
name|ticksPerSecond
argument_list|,
name|clockStart
argument_list|,
name|clockEnd
argument_list|)
operator|==
literal|0
condition|)
do|;
block|}
comment|/*-**************************************** *  File functions ******************************************/
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
define|#
directive|define
name|chmod
value|_chmod
typedef|typedef
name|struct
name|__stat64
name|stat_t
typedef|;
else|#
directive|else
typedef|typedef
name|struct
name|stat
name|stat_t
typedef|;
endif|#
directive|endif
name|UTIL_STATIC
name|int
name|UTIL_setFileStat
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|stat_t
modifier|*
name|statbuf
parameter_list|)
block|{
name|int
name|res
init|=
literal|0
decl_stmt|;
name|struct
name|utimbuf
name|timebuf
decl_stmt|;
name|timebuf
operator|.
name|actime
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|timebuf
operator|.
name|modtime
operator|=
name|statbuf
operator|->
name|st_mtime
expr_stmt|;
name|res
operator|+=
name|utime
argument_list|(
name|filename
argument_list|,
operator|&
name|timebuf
argument_list|)
expr_stmt|;
comment|/* set access and modification times */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
name|res
operator|+=
name|chown
argument_list|(
name|filename
argument_list|,
name|statbuf
operator|->
name|st_uid
argument_list|,
name|statbuf
operator|->
name|st_gid
argument_list|)
expr_stmt|;
comment|/* Copy ownership */
endif|#
directive|endif
name|res
operator|+=
name|chmod
argument_list|(
name|filename
argument_list|,
name|statbuf
operator|->
name|st_mode
operator|&
literal|07777
argument_list|)
expr_stmt|;
comment|/* Copy file permissions */
name|errno
operator|=
literal|0
expr_stmt|;
return|return
operator|-
name|res
return|;
comment|/* number of errors is returned */
block|}
name|UTIL_STATIC
name|int
name|UTIL_getFileStat
parameter_list|(
specifier|const
name|char
modifier|*
name|infilename
parameter_list|,
name|stat_t
modifier|*
name|statbuf
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
name|r
operator|=
name|_stat64
argument_list|(
name|infilename
argument_list|,
name|statbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|||
operator|!
operator|(
name|statbuf
operator|->
name|st_mode
operator|&
name|S_IFREG
operator|)
condition|)
return|return
literal|0
return|;
comment|/* No good... */
else|#
directive|else
name|r
operator|=
name|stat
argument_list|(
name|infilename
argument_list|,
name|statbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|||
operator|!
name|S_ISREG
argument_list|(
name|statbuf
operator|->
name|st_mode
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* No good... */
endif|#
directive|endif
return|return
literal|1
return|;
block|}
name|UTIL_STATIC
name|int
name|UTIL_isRegFile
parameter_list|(
specifier|const
name|char
modifier|*
name|infilename
parameter_list|)
block|{
name|stat_t
name|statbuf
decl_stmt|;
return|return
name|UTIL_getFileStat
argument_list|(
name|infilename
argument_list|,
operator|&
name|statbuf
argument_list|)
return|;
comment|/* Only need to know whether it is a regular file */
block|}
name|UTIL_STATIC
name|U32
name|UTIL_isDirectory
parameter_list|(
specifier|const
name|char
modifier|*
name|infilename
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|stat_t
name|statbuf
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
name|r
operator|=
name|_stat64
argument_list|(
name|infilename
argument_list|,
operator|&
name|statbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
operator|&&
operator|(
name|statbuf
operator|.
name|st_mode
operator|&
name|_S_IFDIR
operator|)
condition|)
return|return
literal|1
return|;
else|#
directive|else
name|r
operator|=
name|stat
argument_list|(
name|infilename
argument_list|,
operator|&
name|statbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
operator|&&
name|S_ISDIR
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
name|UTIL_STATIC
name|U32
name|UTIL_isLink
parameter_list|(
specifier|const
name|char
modifier|*
name|infilename
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
comment|/* no symlinks on windows */
operator|(
name|void
operator|)
name|infilename
expr_stmt|;
else|#
directive|else
name|int
name|r
decl_stmt|;
name|stat_t
name|statbuf
decl_stmt|;
name|r
operator|=
name|lstat
argument_list|(
name|infilename
argument_list|,
operator|&
name|statbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
operator|&&
name|S_ISLNK
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
name|UTIL_STATIC
name|U64
name|UTIL_getFileSize
parameter_list|(
specifier|const
name|char
modifier|*
name|infilename
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
name|struct
name|__stat64
name|statbuf
decl_stmt|;
name|r
operator|=
name|_stat64
argument_list|(
name|infilename
argument_list|,
operator|&
name|statbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|||
operator|!
operator|(
name|statbuf
operator|.
name|st_mode
operator|&
name|S_IFREG
operator|)
condition|)
return|return
literal|0
return|;
comment|/* No good... */
elif|#
directive|elif
name|defined
argument_list|(
name|__MINGW32__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__MSVCRT__
argument_list|)
name|struct
name|_stati64
name|statbuf
decl_stmt|;
name|r
operator|=
name|_stati64
argument_list|(
name|infilename
argument_list|,
operator|&
name|statbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|||
operator|!
operator|(
name|statbuf
operator|.
name|st_mode
operator|&
name|S_IFREG
operator|)
condition|)
return|return
literal|0
return|;
comment|/* No good... */
else|#
directive|else
name|struct
name|stat
name|statbuf
decl_stmt|;
name|r
operator|=
name|stat
argument_list|(
name|infilename
argument_list|,
operator|&
name|statbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|||
operator|!
name|S_ISREG
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* No good... */
endif|#
directive|endif
return|return
operator|(
name|U64
operator|)
name|statbuf
operator|.
name|st_size
return|;
block|}
name|UTIL_STATIC
name|U64
name|UTIL_getTotalFileSize
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|fileNamesTable
parameter_list|,
name|unsigned
name|nbFiles
parameter_list|)
block|{
name|U64
name|total
init|=
literal|0
decl_stmt|;
name|unsigned
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nbFiles
condition|;
name|n
operator|++
control|)
name|total
operator|+=
name|UTIL_getFileSize
argument_list|(
name|fileNamesTable
index|[
name|n
index|]
argument_list|)
expr_stmt|;
return|return
name|total
return|;
block|}
comment|/*  * A modified version of realloc().  * If UTIL_realloc() fails the original block is freed. */
name|UTIL_STATIC
name|void
modifier|*
name|UTIL_realloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|newptr
init|=
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|newptr
condition|)
return|return
name|newptr
return|;
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
specifier|static
name|int
name|g_utilDisplayLevel
decl_stmt|;
define|#
directive|define
name|UTIL_DISPLAY
parameter_list|(
modifier|...
parameter_list|)
value|fprintf(stderr, __VA_ARGS__)
define|#
directive|define
name|UTIL_DISPLAYLEVEL
parameter_list|(
name|l
parameter_list|,
modifier|...
parameter_list|)
value|{ if (g_utilDisplayLevel>=l) { UTIL_DISPLAY(__VA_ARGS__); } }
ifdef|#
directive|ifdef
name|_WIN32
define|#
directive|define
name|UTIL_HAS_CREATEFILELIST
name|UTIL_STATIC
name|int
name|UTIL_prepareFileList
parameter_list|(
specifier|const
name|char
modifier|*
name|dirName
parameter_list|,
name|char
modifier|*
modifier|*
name|bufStart
parameter_list|,
name|size_t
modifier|*
name|pos
parameter_list|,
name|char
modifier|*
modifier|*
name|bufEnd
parameter_list|,
name|int
name|followLinks
parameter_list|)
block|{
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|dirLength
decl_stmt|,
name|fnameLength
decl_stmt|,
name|pathLength
decl_stmt|,
name|nbFiles
init|=
literal|0
decl_stmt|;
name|WIN32_FIND_DATAA
name|cFile
decl_stmt|;
name|HANDLE
name|hFile
decl_stmt|;
name|dirLength
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|dirName
argument_list|)
expr_stmt|;
name|path
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|dirLength
operator|+
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|path
condition|)
return|return
literal|0
return|;
name|memcpy
argument_list|(
name|path
argument_list|,
name|dirName
argument_list|,
name|dirLength
argument_list|)
expr_stmt|;
name|path
index|[
name|dirLength
index|]
operator|=
literal|'\\'
expr_stmt|;
name|path
index|[
name|dirLength
operator|+
literal|1
index|]
operator|=
literal|'*'
expr_stmt|;
name|path
index|[
name|dirLength
operator|+
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|hFile
operator|=
name|FindFirstFileA
argument_list|(
name|path
argument_list|,
operator|&
name|cFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|hFile
operator|==
name|INVALID_HANDLE_VALUE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot open directory '%s'\n"
argument_list|,
name|dirName
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
do|do
block|{
name|fnameLength
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|cFile
operator|.
name|cFileName
argument_list|)
expr_stmt|;
name|path
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|dirLength
operator|+
name|fnameLength
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|path
condition|)
block|{
name|FindClose
argument_list|(
name|hFile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|memcpy
argument_list|(
name|path
argument_list|,
name|dirName
argument_list|,
name|dirLength
argument_list|)
expr_stmt|;
name|path
index|[
name|dirLength
index|]
operator|=
literal|'\\'
expr_stmt|;
name|memcpy
argument_list|(
name|path
operator|+
name|dirLength
operator|+
literal|1
argument_list|,
name|cFile
operator|.
name|cFileName
argument_list|,
name|fnameLength
argument_list|)
expr_stmt|;
name|pathLength
operator|=
name|dirLength
operator|+
literal|1
operator|+
name|fnameLength
expr_stmt|;
name|path
index|[
name|pathLength
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cFile
operator|.
name|dwFileAttributes
operator|&
name|FILE_ATTRIBUTE_DIRECTORY
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|cFile
operator|.
name|cFileName
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|cFile
operator|.
name|cFileName
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|nbFiles
operator|+=
name|UTIL_prepareFileList
argument_list|(
name|path
argument_list|,
name|bufStart
argument_list|,
name|pos
argument_list|,
name|bufEnd
argument_list|,
name|followLinks
argument_list|)
expr_stmt|;
comment|/* Recursively call "UTIL_prepareFileList" with the new path. */
if|if
condition|(
operator|*
name|bufStart
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|FindClose
argument_list|(
name|hFile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|cFile
operator|.
name|dwFileAttributes
operator|&
name|FILE_ATTRIBUTE_NORMAL
operator|)
operator|||
operator|(
name|cFile
operator|.
name|dwFileAttributes
operator|&
name|FILE_ATTRIBUTE_ARCHIVE
operator|)
operator|||
operator|(
name|cFile
operator|.
name|dwFileAttributes
operator|&
name|FILE_ATTRIBUTE_COMPRESSED
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|bufStart
operator|+
operator|*
name|pos
operator|+
name|pathLength
operator|>=
operator|*
name|bufEnd
condition|)
block|{
name|ptrdiff_t
name|newListSize
init|=
operator|(
operator|*
name|bufEnd
operator|-
operator|*
name|bufStart
operator|)
operator|+
name|LIST_SIZE_INCREASE
decl_stmt|;
operator|*
name|bufStart
operator|=
operator|(
name|char
operator|*
operator|)
name|UTIL_realloc
argument_list|(
operator|*
name|bufStart
argument_list|,
name|newListSize
argument_list|)
expr_stmt|;
operator|*
name|bufEnd
operator|=
operator|*
name|bufStart
operator|+
name|newListSize
expr_stmt|;
if|if
condition|(
operator|*
name|bufStart
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|FindClose
argument_list|(
name|hFile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
operator|*
name|bufStart
operator|+
operator|*
name|pos
operator|+
name|pathLength
operator|<
operator|*
name|bufEnd
condition|)
block|{
name|strncpy
argument_list|(
operator|*
name|bufStart
operator|+
operator|*
name|pos
argument_list|,
name|path
argument_list|,
operator|*
name|bufEnd
operator|-
operator|(
operator|*
name|bufStart
operator|+
operator|*
name|pos
operator|)
argument_list|)
expr_stmt|;
operator|*
name|pos
operator|+=
name|pathLength
operator|+
literal|1
expr_stmt|;
name|nbFiles
operator|++
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|FindNextFileA
argument_list|(
name|hFile
argument_list|,
operator|&
name|cFile
argument_list|)
condition|)
do|;
name|FindClose
argument_list|(
name|hFile
argument_list|)
expr_stmt|;
return|return
name|nbFiles
return|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|__linux__
argument_list|)
operator|||
operator|(
name|PLATFORM_POSIX_VERSION
operator|>=
literal|200112L
operator|)
comment|/* opendir, readdir require POSIX.1-2001 */
define|#
directive|define
name|UTIL_HAS_CREATEFILELIST
include|#
directive|include
file|<dirent.h>
comment|/* opendir, readdir */
include|#
directive|include
file|<string.h>
comment|/* strerror, memcpy */
name|UTIL_STATIC
name|int
name|UTIL_prepareFileList
parameter_list|(
specifier|const
name|char
modifier|*
name|dirName
parameter_list|,
name|char
modifier|*
modifier|*
name|bufStart
parameter_list|,
name|size_t
modifier|*
name|pos
parameter_list|,
name|char
modifier|*
modifier|*
name|bufEnd
parameter_list|,
name|int
name|followLinks
parameter_list|)
block|{
name|DIR
modifier|*
name|dir
decl_stmt|;
name|struct
name|dirent
modifier|*
name|entry
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|dirLength
decl_stmt|,
name|fnameLength
decl_stmt|,
name|pathLength
decl_stmt|,
name|nbFiles
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|dir
operator|=
name|opendir
argument_list|(
name|dirName
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot open directory '%s': %s\n"
argument_list|,
name|dirName
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|dirLength
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|dirName
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|entry
operator|=
name|readdir
argument_list|(
name|dir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|entry
operator|->
name|d_name
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|entry
operator|->
name|d_name
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|fnameLength
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|entry
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|path
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|dirLength
operator|+
name|fnameLength
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|path
condition|)
block|{
name|closedir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|memcpy
argument_list|(
name|path
argument_list|,
name|dirName
argument_list|,
name|dirLength
argument_list|)
expr_stmt|;
name|path
index|[
name|dirLength
index|]
operator|=
literal|'/'
expr_stmt|;
name|memcpy
argument_list|(
name|path
operator|+
name|dirLength
operator|+
literal|1
argument_list|,
name|entry
operator|->
name|d_name
argument_list|,
name|fnameLength
argument_list|)
expr_stmt|;
name|pathLength
operator|=
name|dirLength
operator|+
literal|1
operator|+
name|fnameLength
expr_stmt|;
name|path
index|[
name|pathLength
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|followLinks
operator|&&
name|UTIL_isLink
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|UTIL_DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"Warning : %s is a symbolic link, ignoring\n"
argument_list|,
name|path
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|UTIL_isDirectory
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|nbFiles
operator|+=
name|UTIL_prepareFileList
argument_list|(
name|path
argument_list|,
name|bufStart
argument_list|,
name|pos
argument_list|,
name|bufEnd
argument_list|,
name|followLinks
argument_list|)
expr_stmt|;
comment|/* Recursively call "UTIL_prepareFileList" with the new path. */
if|if
condition|(
operator|*
name|bufStart
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|closedir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|*
name|bufStart
operator|+
operator|*
name|pos
operator|+
name|pathLength
operator|>=
operator|*
name|bufEnd
condition|)
block|{
name|ptrdiff_t
name|newListSize
init|=
operator|(
operator|*
name|bufEnd
operator|-
operator|*
name|bufStart
operator|)
operator|+
name|LIST_SIZE_INCREASE
decl_stmt|;
operator|*
name|bufStart
operator|=
operator|(
name|char
operator|*
operator|)
name|UTIL_realloc
argument_list|(
operator|*
name|bufStart
argument_list|,
name|newListSize
argument_list|)
expr_stmt|;
operator|*
name|bufEnd
operator|=
operator|*
name|bufStart
operator|+
name|newListSize
expr_stmt|;
if|if
condition|(
operator|*
name|bufStart
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|closedir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
operator|*
name|bufStart
operator|+
operator|*
name|pos
operator|+
name|pathLength
operator|<
operator|*
name|bufEnd
condition|)
block|{
name|strncpy
argument_list|(
operator|*
name|bufStart
operator|+
operator|*
name|pos
argument_list|,
name|path
argument_list|,
operator|*
name|bufEnd
operator|-
operator|(
operator|*
name|bufStart
operator|+
operator|*
name|pos
operator|)
argument_list|)
expr_stmt|;
operator|*
name|pos
operator|+=
name|pathLength
operator|+
literal|1
expr_stmt|;
name|nbFiles
operator|++
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* clear errno after UTIL_isDirectory, UTIL_prepareFileList */
block|}
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"readdir(%s) error: %s\n"
argument_list|,
name|dirName
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|*
name|bufStart
argument_list|)
expr_stmt|;
operator|*
name|bufStart
operator|=
name|NULL
expr_stmt|;
block|}
name|closedir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return
name|nbFiles
return|;
block|}
else|#
directive|else
name|UTIL_STATIC
name|int
name|UTIL_prepareFileList
parameter_list|(
specifier|const
name|char
modifier|*
name|dirName
parameter_list|,
name|char
modifier|*
modifier|*
name|bufStart
parameter_list|,
name|size_t
modifier|*
name|pos
parameter_list|,
name|char
modifier|*
modifier|*
name|bufEnd
parameter_list|,
name|int
name|followLinks
parameter_list|)
block|{
operator|(
name|void
operator|)
name|bufStart
expr_stmt|;
operator|(
name|void
operator|)
name|bufEnd
expr_stmt|;
operator|(
name|void
operator|)
name|pos
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Directory %s ignored (compiled without _WIN32 or _POSIX_C_SOURCE)\n"
argument_list|,
name|dirName
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* #ifdef _WIN32 */
comment|/*  * UTIL_createFileList - takes a list of files and directories (params: inputNames, inputNamesNb), scans directories,  *                       and returns a new list of files (params: return value, allocatedBuffer, allocatedNamesNb).  * After finishing usage of the list the structures should be freed with UTIL_freeFileList(params: return value, allocatedBuffer)  * In case of error UTIL_createFileList returns NULL and UTIL_freeFileList should not be called.  */
name|UTIL_STATIC
specifier|const
name|char
modifier|*
modifier|*
name|UTIL_createFileList
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|inputNames
parameter_list|,
name|unsigned
name|inputNamesNb
parameter_list|,
name|char
modifier|*
modifier|*
name|allocatedBuffer
parameter_list|,
name|unsigned
modifier|*
name|allocatedNamesNb
parameter_list|,
name|int
name|followLinks
parameter_list|)
block|{
name|size_t
name|pos
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|nbFiles
decl_stmt|;
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|LIST_SIZE_INCREASE
argument_list|)
decl_stmt|;
name|char
modifier|*
name|bufend
init|=
name|buf
operator|+
name|LIST_SIZE_INCREASE
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|fileTable
decl_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|pos
operator|=
literal|0
operator|,
name|nbFiles
operator|=
literal|0
init|;
name|i
operator|<
name|inputNamesNb
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|UTIL_isDirectory
argument_list|(
name|inputNames
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|size_t
specifier|const
name|len
init|=
name|strlen
argument_list|(
name|inputNames
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|buf
operator|+
name|pos
operator|+
name|len
operator|>=
name|bufend
condition|)
block|{
name|ptrdiff_t
name|newListSize
init|=
operator|(
name|bufend
operator|-
name|buf
operator|)
operator|+
name|LIST_SIZE_INCREASE
decl_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|UTIL_realloc
argument_list|(
name|buf
argument_list|,
name|newListSize
argument_list|)
expr_stmt|;
name|bufend
operator|=
name|buf
operator|+
name|newListSize
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|buf
operator|+
name|pos
operator|+
name|len
operator|<
name|bufend
condition|)
block|{
name|strncpy
argument_list|(
name|buf
operator|+
name|pos
argument_list|,
name|inputNames
index|[
name|i
index|]
argument_list|,
name|bufend
operator|-
operator|(
name|buf
operator|+
name|pos
operator|)
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
name|nbFiles
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|nbFiles
operator|+=
name|UTIL_prepareFileList
argument_list|(
name|inputNames
index|[
name|i
index|]
argument_list|,
operator|&
name|buf
argument_list|,
operator|&
name|pos
argument_list|,
operator|&
name|bufend
argument_list|,
name|followLinks
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
block|}
if|if
condition|(
name|nbFiles
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|fileTable
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|nbFiles
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fileTable
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|pos
operator|=
literal|0
init|;
name|i
operator|<
name|nbFiles
condition|;
name|i
operator|++
control|)
block|{
name|fileTable
index|[
name|i
index|]
operator|=
name|buf
operator|+
name|pos
expr_stmt|;
name|pos
operator|+=
name|strlen
argument_list|(
name|fileTable
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|buf
operator|+
name|pos
operator|>
name|bufend
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|fileTable
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|allocatedBuffer
operator|=
name|buf
expr_stmt|;
operator|*
name|allocatedNamesNb
operator|=
name|nbFiles
expr_stmt|;
return|return
name|fileTable
return|;
block|}
name|UTIL_STATIC
name|void
name|UTIL_freeFileList
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|filenameTable
parameter_list|,
name|char
modifier|*
name|allocatedBuffer
parameter_list|)
block|{
if|if
condition|(
name|allocatedBuffer
condition|)
name|free
argument_list|(
name|allocatedBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|filenameTable
condition|)
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|filenameTable
argument_list|)
expr_stmt|;
block|}
comment|/* count the number of physical cores */
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|WIN32
argument_list|)
include|#
directive|include
file|<windows.h>
typedef|typedef
name|BOOL
function_decl|(
name|WINAPI
modifier|*
name|LPFN_GLPI
function_decl|)
parameter_list|(
name|PSYSTEM_LOGICAL_PROCESSOR_INFORMATION
parameter_list|,
name|PDWORD
parameter_list|)
function_decl|;
name|UTIL_STATIC
name|int
name|UTIL_countPhysicalCores
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|numPhysicalCores
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|numPhysicalCores
operator|!=
literal|0
condition|)
return|return
name|numPhysicalCores
return|;
block|{
name|LPFN_GLPI
name|glpi
decl_stmt|;
name|BOOL
name|done
init|=
name|FALSE
decl_stmt|;
name|PSYSTEM_LOGICAL_PROCESSOR_INFORMATION
name|buffer
init|=
name|NULL
decl_stmt|;
name|PSYSTEM_LOGICAL_PROCESSOR_INFORMATION
name|ptr
init|=
name|NULL
decl_stmt|;
name|DWORD
name|returnLength
init|=
literal|0
decl_stmt|;
name|size_t
name|byteOffset
init|=
literal|0
decl_stmt|;
name|glpi
operator|=
operator|(
name|LPFN_GLPI
operator|)
name|GetProcAddress
argument_list|(
name|GetModuleHandle
argument_list|(
name|TEXT
argument_list|(
literal|"kernel32"
argument_list|)
argument_list|)
argument_list|,
literal|"GetLogicalProcessorInformation"
argument_list|)
expr_stmt|;
if|if
condition|(
name|glpi
operator|==
name|NULL
condition|)
block|{
goto|goto
name|failed
goto|;
block|}
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|DWORD
name|rc
init|=
name|glpi
argument_list|(
name|buffer
argument_list|,
operator|&
name|returnLength
argument_list|)
decl_stmt|;
if|if
condition|(
name|FALSE
operator|==
name|rc
condition|)
block|{
if|if
condition|(
name|GetLastError
argument_list|()
operator|==
name|ERROR_INSUFFICIENT_BUFFER
condition|)
block|{
if|if
condition|(
name|buffer
condition|)
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|buffer
operator|=
operator|(
name|PSYSTEM_LOGICAL_PROCESSOR_INFORMATION
operator|)
name|malloc
argument_list|(
name|returnLength
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"zstd"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* some other error */
goto|goto
name|failed
goto|;
block|}
block|}
else|else
block|{
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|ptr
operator|=
name|buffer
expr_stmt|;
while|while
condition|(
name|byteOffset
operator|+
sizeof|sizeof
argument_list|(
name|SYSTEM_LOGICAL_PROCESSOR_INFORMATION
argument_list|)
operator|<=
name|returnLength
condition|)
block|{
if|if
condition|(
name|ptr
operator|->
name|Relationship
operator|==
name|RelationProcessorCore
condition|)
block|{
name|numPhysicalCores
operator|++
expr_stmt|;
block|}
name|ptr
operator|++
expr_stmt|;
name|byteOffset
operator|+=
sizeof|sizeof
argument_list|(
name|SYSTEM_LOGICAL_PROCESSOR_INFORMATION
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|numPhysicalCores
return|;
block|}
name|failed
label|:
comment|/* try to fall back on GetSystemInfo */
block|{
name|SYSTEM_INFO
name|sysinfo
decl_stmt|;
name|GetSystemInfo
argument_list|(
operator|&
name|sysinfo
argument_list|)
expr_stmt|;
name|numPhysicalCores
operator|=
name|sysinfo
operator|.
name|dwNumberOfProcessors
expr_stmt|;
if|if
condition|(
name|numPhysicalCores
operator|==
literal|0
condition|)
name|numPhysicalCores
operator|=
literal|1
expr_stmt|;
comment|/* just in case */
block|}
return|return
name|numPhysicalCores
return|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|__APPLE__
argument_list|)
include|#
directive|include
file|<sys/sysctl.h>
comment|/* Use apple-provided syscall  * see: man 3 sysctl */
name|UTIL_STATIC
name|int
name|UTIL_countPhysicalCores
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|S32
name|numPhysicalCores
init|=
literal|0
decl_stmt|;
comment|/* apple specifies int32_t */
if|if
condition|(
name|numPhysicalCores
operator|!=
literal|0
condition|)
return|return
name|numPhysicalCores
return|;
block|{
name|size_t
name|size
init|=
sizeof|sizeof
argument_list|(
name|S32
argument_list|)
decl_stmt|;
name|int
specifier|const
name|ret
init|=
name|sysctlbyname
argument_list|(
literal|"hw.physicalcpu"
argument_list|,
operator|&
name|numPhysicalCores
argument_list|,
operator|&
name|size
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
comment|/* entry not present, fall back on 1 */
name|numPhysicalCores
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|perror
argument_list|(
literal|"zstd: can't get number of physical cpus"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|numPhysicalCores
return|;
block|}
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|__linux__
argument_list|)
comment|/* parse /proc/cpuinfo  * siblings / cpu cores should give hyperthreading ratio  * otherwise fall back on sysconf */
name|UTIL_STATIC
name|int
name|UTIL_countPhysicalCores
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|numPhysicalCores
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|numPhysicalCores
operator|!=
literal|0
condition|)
return|return
name|numPhysicalCores
return|;
name|numPhysicalCores
operator|=
operator|(
name|int
operator|)
name|sysconf
argument_list|(
name|_SC_NPROCESSORS_ONLN
argument_list|)
expr_stmt|;
if|if
condition|(
name|numPhysicalCores
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* value not queryable, fall back on 1 */
return|return
name|numPhysicalCores
operator|=
literal|1
return|;
block|}
comment|/* try to determine if there's hyperthreading */
block|{
name|FILE
modifier|*
specifier|const
name|cpuinfo
init|=
name|fopen
argument_list|(
literal|"/proc/cpuinfo"
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|BUF_SIZE
init|=
literal|80
decl_stmt|;
name|char
name|buff
index|[
name|BUF_SIZE
index|]
decl_stmt|;
name|int
name|siblings
init|=
literal|0
decl_stmt|;
name|int
name|cpu_cores
init|=
literal|0
decl_stmt|;
name|int
name|ratio
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|cpuinfo
operator|==
name|NULL
condition|)
block|{
comment|/* fall back on the sysconf value */
return|return
name|numPhysicalCores
return|;
block|}
comment|/* assume the cpu cores/siblings values will be constant across all          * present processors */
while|while
condition|(
operator|!
name|feof
argument_list|(
name|cpuinfo
argument_list|)
condition|)
block|{
if|if
condition|(
name|fgets
argument_list|(
name|buff
argument_list|,
name|BUF_SIZE
argument_list|,
name|cpuinfo
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|buff
argument_list|,
literal|"siblings"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
specifier|const
name|sep
init|=
name|strchr
argument_list|(
name|buff
argument_list|,
literal|':'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|sep
operator|==
literal|'\0'
condition|)
block|{
comment|/* formatting was broken? */
goto|goto
name|failed
goto|;
block|}
name|siblings
operator|=
name|atoi
argument_list|(
name|sep
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|buff
argument_list|,
literal|"cpu cores"
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
specifier|const
name|sep
init|=
name|strchr
argument_list|(
name|buff
argument_list|,
literal|':'
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|sep
operator|==
literal|'\0'
condition|)
block|{
comment|/* formatting was broken? */
goto|goto
name|failed
goto|;
block|}
name|cpu_cores
operator|=
name|atoi
argument_list|(
name|sep
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ferror
argument_list|(
name|cpuinfo
argument_list|)
condition|)
block|{
comment|/* fall back on the sysconf value */
goto|goto
name|failed
goto|;
block|}
block|}
if|if
condition|(
name|siblings
operator|&&
name|cpu_cores
condition|)
block|{
name|ratio
operator|=
name|siblings
operator|/
name|cpu_cores
expr_stmt|;
block|}
name|failed
label|:
name|fclose
argument_list|(
name|cpuinfo
argument_list|)
expr_stmt|;
return|return
name|numPhysicalCores
operator|=
name|numPhysicalCores
operator|/
name|ratio
return|;
block|}
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__DragonFly__
argument_list|)
comment|/* Use apple-provided syscall  * see: man 3 sysctl */
name|UTIL_STATIC
name|int
name|UTIL_countPhysicalCores
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|numPhysicalCores
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|numPhysicalCores
operator|!=
literal|0
condition|)
return|return
name|numPhysicalCores
return|;
name|numPhysicalCores
operator|=
operator|(
name|int
operator|)
name|sysconf
argument_list|(
name|_SC_NPROCESSORS_ONLN
argument_list|)
expr_stmt|;
if|if
condition|(
name|numPhysicalCores
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* value not queryable, fall back on 1 */
return|return
name|numPhysicalCores
operator|=
literal|1
return|;
block|}
return|return
name|numPhysicalCores
return|;
block|}
else|#
directive|else
name|UTIL_STATIC
name|int
name|UTIL_countPhysicalCores
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* assume 1 */
return|return
literal|1
return|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UTIL_H_MODULE */
end_comment

end_unit

