begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright (c) 2016-present, Yann Collet, Facebook, Inc.  * All rights reserved.  *  * This source code is licensed under the BSD-style license found in the  * LICENSE file in the root directory of this source tree. An additional grant  * of patent rights can be found in the PATENTS file in the same directory.  */
end_comment

begin_comment
comment|/* ************************************** *  Tuning parameters ****************************************/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BMK_TIMETEST_DEFAULT_S
end_ifndef

begin_comment
comment|/* default minimum time per test */
end_comment

begin_define
define|#
directive|define
name|BMK_TIMETEST_DEFAULT_S
value|3
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ************************************** *  Compiler Warnings ****************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4127
name|)
end_pragma

begin_comment
comment|/* disable: C4127: conditional expression is constant */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ************************************* *  Includes ***************************************/
end_comment

begin_include
include|#
directive|include
file|"platform.h"
end_include

begin_comment
comment|/* Large Files support */
end_comment

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_comment
comment|/* UTIL_getFileSize, UTIL_sleep */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* malloc, free */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* memset */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* fprintf, fopen */
end_comment

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_comment
comment|/* clock_t, clock, CLOCKS_PER_SEC */
end_comment

begin_include
include|#
directive|include
file|"mem.h"
end_include

begin_define
define|#
directive|define
name|ZSTD_STATIC_LINKING_ONLY
end_define

begin_include
include|#
directive|include
file|"zstd.h"
end_include

begin_include
include|#
directive|include
file|"datagen.h"
end_include

begin_comment
comment|/* RDG_genBuffer */
end_comment

begin_include
include|#
directive|include
file|"xxhash.h"
end_include

begin_include
include|#
directive|include
file|"zstdmt_compress.h"
end_include

begin_comment
comment|/* ************************************* *  Constants ***************************************/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ZSTD_GIT_COMMIT
end_ifndef

begin_define
define|#
directive|define
name|ZSTD_GIT_COMMIT_STRING
value|""
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ZSTD_GIT_COMMIT_STRING
value|ZSTD_EXPAND_AND_QUOTE(ZSTD_GIT_COMMIT)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|TIMELOOP_MICROSEC
value|1*1000000ULL
end_define

begin_comment
comment|/* 1 second */
end_comment

begin_define
define|#
directive|define
name|ACTIVEPERIOD_MICROSEC
value|70*1000000ULL
end_define

begin_comment
comment|/* 70 seconds */
end_comment

begin_define
define|#
directive|define
name|COOLPERIOD_SEC
value|10
end_define

begin_define
define|#
directive|define
name|KB
value|*(1<<10)
end_define

begin_define
define|#
directive|define
name|MB
value|*(1<<20)
end_define

begin_define
define|#
directive|define
name|GB
value|*(1U<<30)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|size_t
name|maxMemory
init|=
operator|(
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|==
literal|4
operator|)
condition|?
operator|(
literal|2
name|GB
operator|-
literal|64
name|MB
operator|)
else|:
call|(
name|size_t
call|)
argument_list|(
literal|1ULL
operator|<<
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|*
literal|8
operator|)
operator|-
literal|31
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|U32
name|g_compressibilityDefault
init|=
literal|50
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ************************************* *  console display ***************************************/
end_comment

begin_define
define|#
directive|define
name|DISPLAY
parameter_list|(
modifier|...
parameter_list|)
value|fprintf(stderr, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|DISPLAYLEVEL
parameter_list|(
name|l
parameter_list|,
modifier|...
parameter_list|)
value|if (g_displayLevel>=l) { DISPLAY(__VA_ARGS__); }
end_define

begin_decl_stmt
specifier|static
name|int
name|g_displayLevel
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 : no display;   1: errors;   2 : + result + interaction + warnings;   3 : + progression;   4 : + information */
end_comment

begin_define
define|#
directive|define
name|DISPLAYUPDATE
parameter_list|(
name|l
parameter_list|,
modifier|...
parameter_list|)
value|if (g_displayLevel>=l) { \             if ((clock() - g_time> refreshRate) || (g_displayLevel>=4)) \             { g_time = clock(); DISPLAY(__VA_ARGS__); \             if (g_displayLevel>=4) fflush(stderr); } }
end_define

begin_decl_stmt
specifier|static
specifier|const
name|clock_t
name|refreshRate
init|=
name|CLOCKS_PER_SEC
operator|*
literal|15
operator|/
literal|100
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|clock_t
name|g_time
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ************************************* *  Exceptions ***************************************/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG
end_ifndef

begin_define
define|#
directive|define
name|DEBUG
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DEBUGOUTPUT
parameter_list|(
modifier|...
parameter_list|)
value|if (DEBUG) DISPLAY(__VA_ARGS__);
end_define

begin_define
define|#
directive|define
name|EXM_THROW
parameter_list|(
name|error
parameter_list|,
modifier|...
parameter_list|)
define|\
value|{                                                                         \     DEBUGOUTPUT("%s: %i: \n", __FILE__, __LINE__); \     DISPLAYLEVEL(1, "Error %i : ", error);                                \     DISPLAYLEVEL(1, __VA_ARGS__);                                         \     DISPLAYLEVEL(1, " \n");                                               \     exit(error);                                                          \ }
end_define

begin_comment
comment|/* ************************************* *  Benchmark Parameters ***************************************/
end_comment

begin_decl_stmt
specifier|static
name|int
name|g_additionalParam
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|U32
name|g_decodeOnly
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|BMK_setNotificationLevel
parameter_list|(
name|unsigned
name|level
parameter_list|)
block|{
name|g_displayLevel
operator|=
name|level
expr_stmt|;
block|}
end_function

begin_function
name|void
name|BMK_setAdditionalParam
parameter_list|(
name|int
name|additionalParam
parameter_list|)
block|{
name|g_additionalParam
operator|=
name|additionalParam
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|U32
name|g_nbSeconds
init|=
name|BMK_TIMETEST_DEFAULT_S
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|BMK_setNbSeconds
parameter_list|(
name|unsigned
name|nbSeconds
parameter_list|)
block|{
name|g_nbSeconds
operator|=
name|nbSeconds
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|3
argument_list|,
literal|"- test>= %u seconds per compression / decompression - \n"
argument_list|,
name|g_nbSeconds
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|size_t
name|g_blockSize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|BMK_setBlockSize
parameter_list|(
name|size_t
name|blockSize
parameter_list|)
block|{
name|g_blockSize
operator|=
name|blockSize
expr_stmt|;
if|if
condition|(
name|g_blockSize
condition|)
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"using blocks of size %u KB \n"
argument_list|,
call|(
name|U32
call|)
argument_list|(
name|blockSize
operator|>>
literal|10
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|BMK_setDecodeOnlyMode
parameter_list|(
name|unsigned
name|decodeFlag
parameter_list|)
block|{
name|g_decodeOnly
operator|=
operator|(
name|decodeFlag
operator|>
literal|0
operator|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|U32
name|g_nbThreads
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|BMK_setNbThreads
parameter_list|(
name|unsigned
name|nbThreads
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|ZSTD_MULTITHREAD
if|if
condition|(
name|nbThreads
operator|>
literal|1
condition|)
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"Note : multi-threading is disabled \n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|g_nbThreads
operator|=
name|nbThreads
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ******************************************************** *  Bench functions **********************************************************/
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|void
modifier|*
name|srcPtr
decl_stmt|;
name|size_t
name|srcSize
decl_stmt|;
name|void
modifier|*
name|cPtr
decl_stmt|;
name|size_t
name|cRoom
decl_stmt|;
name|size_t
name|cSize
decl_stmt|;
name|void
modifier|*
name|resPtr
decl_stmt|;
name|size_t
name|resSize
decl_stmt|;
block|}
name|blockParam_t
typedef|;
end_typedef

begin_undef
undef|#
directive|undef
name|MIN
end_undef

begin_undef
undef|#
directive|undef
name|MAX
end_undef

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_function
specifier|static
name|int
name|BMK_benchMem
parameter_list|(
specifier|const
name|void
modifier|*
name|srcBuffer
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
specifier|const
name|char
modifier|*
name|displayName
parameter_list|,
name|int
name|cLevel
parameter_list|,
specifier|const
name|size_t
modifier|*
name|fileSizes
parameter_list|,
name|U32
name|nbFiles
parameter_list|,
specifier|const
name|void
modifier|*
name|dictBuffer
parameter_list|,
name|size_t
name|dictBufferSize
parameter_list|,
specifier|const
name|ZSTD_compressionParameters
modifier|*
name|comprParams
parameter_list|)
block|{
name|size_t
specifier|const
name|blockSize
init|=
operator|(
operator|(
name|g_blockSize
operator|>=
literal|32
operator|&&
operator|!
name|g_decodeOnly
operator|)
condition|?
name|g_blockSize
else|:
name|srcSize
operator|)
operator|+
operator|(
operator|!
name|srcSize
operator|)
comment|/* avoid div by 0 */
decl_stmt|;
name|size_t
specifier|const
name|avgSize
init|=
name|MIN
argument_list|(
name|blockSize
argument_list|,
operator|(
name|srcSize
operator|/
name|nbFiles
operator|)
argument_list|)
decl_stmt|;
name|U32
specifier|const
name|maxNbBlocks
init|=
call|(
name|U32
call|)
argument_list|(
operator|(
name|srcSize
operator|+
operator|(
name|blockSize
operator|-
literal|1
operator|)
operator|)
operator|/
name|blockSize
argument_list|)
operator|+
name|nbFiles
decl_stmt|;
name|blockParam_t
modifier|*
specifier|const
name|blockTable
init|=
operator|(
name|blockParam_t
operator|*
operator|)
name|malloc
argument_list|(
name|maxNbBlocks
operator|*
sizeof|sizeof
argument_list|(
name|blockParam_t
argument_list|)
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|maxCompressedSize
init|=
name|ZSTD_compressBound
argument_list|(
name|srcSize
argument_list|)
operator|+
operator|(
name|maxNbBlocks
operator|*
literal|1024
operator|)
decl_stmt|;
comment|/* add some room for safety */
name|void
modifier|*
specifier|const
name|compressedBuffer
init|=
name|malloc
argument_list|(
name|maxCompressedSize
argument_list|)
decl_stmt|;
name|void
modifier|*
name|resultBuffer
init|=
name|malloc
argument_list|(
name|srcSize
argument_list|)
decl_stmt|;
name|ZSTDMT_CCtx
modifier|*
specifier|const
name|mtctx
init|=
name|ZSTDMT_createCCtx
argument_list|(
name|g_nbThreads
argument_list|)
decl_stmt|;
name|ZSTD_CCtx
modifier|*
specifier|const
name|ctx
init|=
name|ZSTD_createCCtx
argument_list|()
decl_stmt|;
name|ZSTD_DCtx
modifier|*
specifier|const
name|dctx
init|=
name|ZSTD_createDCtx
argument_list|()
decl_stmt|;
name|size_t
specifier|const
name|loadedCompressedSize
init|=
name|srcSize
decl_stmt|;
name|size_t
name|cSize
init|=
literal|0
decl_stmt|;
name|double
name|ratio
init|=
literal|0.
decl_stmt|;
name|U32
name|nbBlocks
decl_stmt|;
name|UTIL_freq_t
name|ticksPerSecond
decl_stmt|;
comment|/* checks */
if|if
condition|(
operator|!
name|compressedBuffer
operator|||
operator|!
name|resultBuffer
operator|||
operator|!
name|blockTable
operator|||
operator|!
name|ctx
operator|||
operator|!
name|dctx
condition|)
name|EXM_THROW
argument_list|(
literal|31
argument_list|,
literal|"allocation error : not enough memory"
argument_list|)
expr_stmt|;
comment|/* init */
if|if
condition|(
name|strlen
argument_list|(
name|displayName
argument_list|)
operator|>
literal|17
condition|)
name|displayName
operator|+=
name|strlen
argument_list|(
name|displayName
argument_list|)
operator|-
literal|17
expr_stmt|;
comment|/* display last 17 characters */
name|UTIL_initTimer
argument_list|(
operator|&
name|ticksPerSecond
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_decodeOnly
condition|)
block|{
comment|/* benchmark only decompression : source must be already compressed */
specifier|const
name|char
modifier|*
name|srcPtr
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|srcBuffer
decl_stmt|;
name|U64
name|totalDSize64
init|=
literal|0
decl_stmt|;
name|U32
name|fileNb
decl_stmt|;
for|for
control|(
name|fileNb
operator|=
literal|0
init|;
name|fileNb
operator|<
name|nbFiles
condition|;
name|fileNb
operator|++
control|)
block|{
name|U64
specifier|const
name|fSize64
init|=
name|ZSTD_findDecompressedSize
argument_list|(
name|srcPtr
argument_list|,
name|fileSizes
index|[
name|fileNb
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|fSize64
operator|==
literal|0
condition|)
name|EXM_THROW
argument_list|(
literal|32
argument_list|,
literal|"Impossible to determine original size "
argument_list|)
expr_stmt|;
name|totalDSize64
operator|+=
name|fSize64
expr_stmt|;
name|srcPtr
operator|+=
name|fileSizes
index|[
name|fileNb
index|]
expr_stmt|;
block|}
block|{
name|size_t
specifier|const
name|decodedSize
init|=
operator|(
name|size_t
operator|)
name|totalDSize64
decl_stmt|;
if|if
condition|(
name|totalDSize64
operator|>
name|decodedSize
condition|)
name|EXM_THROW
argument_list|(
literal|32
argument_list|,
literal|"original size is too large"
argument_list|)
expr_stmt|;
comment|/* size_t overflow */
name|free
argument_list|(
name|resultBuffer
argument_list|)
expr_stmt|;
name|resultBuffer
operator|=
name|malloc
argument_list|(
name|decodedSize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|resultBuffer
condition|)
name|EXM_THROW
argument_list|(
literal|33
argument_list|,
literal|"not enough memory"
argument_list|)
expr_stmt|;
name|cSize
operator|=
name|srcSize
expr_stmt|;
name|srcSize
operator|=
name|decodedSize
expr_stmt|;
name|ratio
operator|=
operator|(
name|double
operator|)
name|srcSize
operator|/
operator|(
name|double
operator|)
name|cSize
expr_stmt|;
block|}
block|}
comment|/* Init blockTable data */
block|{
specifier|const
name|char
modifier|*
name|srcPtr
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|srcBuffer
decl_stmt|;
name|char
modifier|*
name|cPtr
init|=
operator|(
name|char
operator|*
operator|)
name|compressedBuffer
decl_stmt|;
name|char
modifier|*
name|resPtr
init|=
operator|(
name|char
operator|*
operator|)
name|resultBuffer
decl_stmt|;
name|U32
name|fileNb
decl_stmt|;
for|for
control|(
name|nbBlocks
operator|=
literal|0
operator|,
name|fileNb
operator|=
literal|0
init|;
name|fileNb
operator|<
name|nbFiles
condition|;
name|fileNb
operator|++
control|)
block|{
name|size_t
name|remaining
init|=
name|fileSizes
index|[
name|fileNb
index|]
decl_stmt|;
name|U32
specifier|const
name|nbBlocksforThisFile
init|=
name|g_decodeOnly
condition|?
literal|1
else|:
call|(
name|U32
call|)
argument_list|(
operator|(
name|remaining
operator|+
operator|(
name|blockSize
operator|-
literal|1
operator|)
operator|)
operator|/
name|blockSize
argument_list|)
decl_stmt|;
name|U32
specifier|const
name|blockEnd
init|=
name|nbBlocks
operator|+
name|nbBlocksforThisFile
decl_stmt|;
for|for
control|(
init|;
name|nbBlocks
operator|<
name|blockEnd
condition|;
name|nbBlocks
operator|++
control|)
block|{
name|size_t
specifier|const
name|thisBlockSize
init|=
name|MIN
argument_list|(
name|remaining
argument_list|,
name|blockSize
argument_list|)
decl_stmt|;
name|blockTable
index|[
name|nbBlocks
index|]
operator|.
name|srcPtr
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
name|srcPtr
expr_stmt|;
name|blockTable
index|[
name|nbBlocks
index|]
operator|.
name|srcSize
operator|=
name|thisBlockSize
expr_stmt|;
name|blockTable
index|[
name|nbBlocks
index|]
operator|.
name|cPtr
operator|=
operator|(
name|void
operator|*
operator|)
name|cPtr
expr_stmt|;
name|blockTable
index|[
name|nbBlocks
index|]
operator|.
name|cRoom
operator|=
name|g_decodeOnly
condition|?
name|thisBlockSize
else|:
name|ZSTD_compressBound
argument_list|(
name|thisBlockSize
argument_list|)
expr_stmt|;
name|blockTable
index|[
name|nbBlocks
index|]
operator|.
name|cSize
operator|=
name|blockTable
index|[
name|nbBlocks
index|]
operator|.
name|cRoom
expr_stmt|;
name|blockTable
index|[
name|nbBlocks
index|]
operator|.
name|resPtr
operator|=
operator|(
name|void
operator|*
operator|)
name|resPtr
expr_stmt|;
name|blockTable
index|[
name|nbBlocks
index|]
operator|.
name|resSize
operator|=
name|g_decodeOnly
condition|?
operator|(
name|size_t
operator|)
name|ZSTD_findDecompressedSize
argument_list|(
name|srcPtr
argument_list|,
name|thisBlockSize
argument_list|)
else|:
name|thisBlockSize
expr_stmt|;
name|srcPtr
operator|+=
name|thisBlockSize
expr_stmt|;
name|cPtr
operator|+=
name|blockTable
index|[
name|nbBlocks
index|]
operator|.
name|cRoom
expr_stmt|;
name|resPtr
operator|+=
name|thisBlockSize
expr_stmt|;
name|remaining
operator|-=
name|thisBlockSize
expr_stmt|;
block|}
block|}
block|}
comment|/* warmimg up memory */
name|RDG_genBuffer
argument_list|(
name|compressedBuffer
argument_list|,
name|maxCompressedSize
argument_list|,
literal|0.10
argument_list|,
literal|0.50
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Bench */
block|{
name|U64
name|fastestC
init|=
call|(
name|U64
call|)
argument_list|(
operator|-
literal|1LL
argument_list|)
decl_stmt|,
name|fastestD
init|=
call|(
name|U64
call|)
argument_list|(
operator|-
literal|1LL
argument_list|)
decl_stmt|;
name|U64
specifier|const
name|crcOrig
init|=
name|g_decodeOnly
condition|?
literal|0
else|:
name|XXH64
argument_list|(
name|srcBuffer
argument_list|,
name|srcSize
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|UTIL_time_t
name|coolTime
decl_stmt|;
name|U64
specifier|const
name|maxTime
init|=
operator|(
name|g_nbSeconds
operator|*
name|TIMELOOP_MICROSEC
operator|)
operator|+
literal|1
decl_stmt|;
name|U64
name|totalCTime
init|=
literal|0
decl_stmt|,
name|totalDTime
init|=
literal|0
decl_stmt|;
name|U32
name|cCompleted
init|=
name|g_decodeOnly
decl_stmt|,
name|dCompleted
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|NB_MARKS
value|4
specifier|const
name|char
modifier|*
specifier|const
name|marks
index|[
name|NB_MARKS
index|]
init|=
block|{
literal|" |"
block|,
literal|" /"
block|,
literal|" ="
block|,
literal|"\\"
block|}
decl_stmt|;
name|U32
name|markNb
init|=
literal|0
decl_stmt|;
name|UTIL_getTime
argument_list|(
operator|&
name|coolTime
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"\r%79s\r"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|cCompleted
operator|||
operator|!
name|dCompleted
condition|)
block|{
comment|/* overheat protection */
if|if
condition|(
name|UTIL_clockSpanMicro
argument_list|(
name|coolTime
argument_list|,
name|ticksPerSecond
argument_list|)
operator|>
name|ACTIVEPERIOD_MICROSEC
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"\rcooling down ...    \r"
argument_list|)
expr_stmt|;
name|UTIL_sleep
argument_list|(
name|COOLPERIOD_SEC
argument_list|)
expr_stmt|;
name|UTIL_getTime
argument_list|(
operator|&
name|coolTime
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|g_decodeOnly
condition|)
block|{
name|UTIL_time_t
name|clockStart
decl_stmt|;
comment|/* Compression */
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"%2s-%-17.17s :%10u ->\r"
argument_list|,
name|marks
index|[
name|markNb
index|]
argument_list|,
name|displayName
argument_list|,
operator|(
name|U32
operator|)
name|srcSize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cCompleted
condition|)
name|memset
argument_list|(
name|compressedBuffer
argument_list|,
literal|0xE5
argument_list|,
name|maxCompressedSize
argument_list|)
expr_stmt|;
comment|/* warm up and erase result buffer */
name|UTIL_sleepMilli
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* give processor time to other processes */
name|UTIL_waitForNextTick
argument_list|(
name|ticksPerSecond
argument_list|)
expr_stmt|;
name|UTIL_getTime
argument_list|(
operator|&
name|clockStart
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cCompleted
condition|)
block|{
comment|/* still some time to do compression tests */
name|ZSTD_customMem
specifier|const
name|cmem
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
name|U64
specifier|const
name|clockLoop
init|=
name|g_nbSeconds
condition|?
name|TIMELOOP_MICROSEC
else|:
literal|1
decl_stmt|;
name|U32
name|nbLoops
init|=
literal|0
decl_stmt|;
name|ZSTD_parameters
name|zparams
init|=
name|ZSTD_getParams
argument_list|(
name|cLevel
argument_list|,
name|avgSize
argument_list|,
name|dictBufferSize
argument_list|)
decl_stmt|;
name|ZSTD_CDict
modifier|*
name|cdict
decl_stmt|;
if|if
condition|(
name|comprParams
operator|->
name|windowLog
condition|)
name|zparams
operator|.
name|cParams
operator|.
name|windowLog
operator|=
name|comprParams
operator|->
name|windowLog
expr_stmt|;
if|if
condition|(
name|comprParams
operator|->
name|chainLog
condition|)
name|zparams
operator|.
name|cParams
operator|.
name|chainLog
operator|=
name|comprParams
operator|->
name|chainLog
expr_stmt|;
if|if
condition|(
name|comprParams
operator|->
name|hashLog
condition|)
name|zparams
operator|.
name|cParams
operator|.
name|hashLog
operator|=
name|comprParams
operator|->
name|hashLog
expr_stmt|;
if|if
condition|(
name|comprParams
operator|->
name|searchLog
condition|)
name|zparams
operator|.
name|cParams
operator|.
name|searchLog
operator|=
name|comprParams
operator|->
name|searchLog
expr_stmt|;
if|if
condition|(
name|comprParams
operator|->
name|searchLength
condition|)
name|zparams
operator|.
name|cParams
operator|.
name|searchLength
operator|=
name|comprParams
operator|->
name|searchLength
expr_stmt|;
if|if
condition|(
name|comprParams
operator|->
name|targetLength
condition|)
name|zparams
operator|.
name|cParams
operator|.
name|targetLength
operator|=
name|comprParams
operator|->
name|targetLength
expr_stmt|;
if|if
condition|(
name|comprParams
operator|->
name|strategy
condition|)
name|zparams
operator|.
name|cParams
operator|.
name|strategy
operator|=
call|(
name|ZSTD_strategy
call|)
argument_list|(
name|comprParams
operator|->
name|strategy
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cdict
operator|=
name|ZSTD_createCDict_advanced
argument_list|(
name|dictBuffer
argument_list|,
name|dictBufferSize
argument_list|,
literal|1
argument_list|,
name|zparams
operator|.
name|cParams
argument_list|,
name|cmem
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdict
operator|==
name|NULL
condition|)
name|EXM_THROW
argument_list|(
literal|1
argument_list|,
literal|"ZSTD_createCDict_advanced() allocation failure"
argument_list|)
expr_stmt|;
do|do
block|{
name|U32
name|blockNb
decl_stmt|;
name|size_t
name|rSize
decl_stmt|;
for|for
control|(
name|blockNb
operator|=
literal|0
init|;
name|blockNb
operator|<
name|nbBlocks
condition|;
name|blockNb
operator|++
control|)
block|{
if|if
condition|(
name|dictBufferSize
condition|)
block|{
name|rSize
operator|=
name|ZSTD_compress_usingCDict
argument_list|(
name|ctx
argument_list|,
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|cPtr
argument_list|,
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|cRoom
argument_list|,
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|srcPtr
argument_list|,
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|srcSize
argument_list|,
name|cdict
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|ZSTD_MULTITHREAD
comment|/* note : limitation : MT single-pass does not support compression with dictionary */
name|rSize
operator|=
name|ZSTDMT_compressCCtx
argument_list|(
name|mtctx
argument_list|,
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|cPtr
argument_list|,
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|cRoom
argument_list|,
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|srcPtr
argument_list|,
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|srcSize
argument_list|,
name|cLevel
argument_list|)
expr_stmt|;
else|#
directive|else
name|rSize
operator|=
name|ZSTD_compress_advanced
argument_list|(
name|ctx
argument_list|,
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|cPtr
argument_list|,
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|cRoom
argument_list|,
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|srcPtr
argument_list|,
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|srcSize
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|zparams
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|rSize
argument_list|)
condition|)
name|EXM_THROW
argument_list|(
literal|1
argument_list|,
literal|"ZSTD_compress_usingCDict() failed : %s"
argument_list|,
name|ZSTD_getErrorName
argument_list|(
name|rSize
argument_list|)
argument_list|)
expr_stmt|;
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|cSize
operator|=
name|rSize
expr_stmt|;
block|}
name|nbLoops
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|UTIL_clockSpanMicro
argument_list|(
name|clockStart
argument_list|,
name|ticksPerSecond
argument_list|)
operator|<
name|clockLoop
condition|)
do|;
name|ZSTD_freeCDict
argument_list|(
name|cdict
argument_list|)
expr_stmt|;
block|{
name|U64
specifier|const
name|clockSpanMicro
init|=
name|UTIL_clockSpanMicro
argument_list|(
name|clockStart
argument_list|,
name|ticksPerSecond
argument_list|)
decl_stmt|;
if|if
condition|(
name|clockSpanMicro
operator|<
name|fastestC
operator|*
name|nbLoops
condition|)
name|fastestC
operator|=
name|clockSpanMicro
operator|/
name|nbLoops
expr_stmt|;
name|totalCTime
operator|+=
name|clockSpanMicro
expr_stmt|;
name|cCompleted
operator|=
operator|(
name|totalCTime
operator|>=
name|maxTime
operator|)
expr_stmt|;
block|}
block|}
name|cSize
operator|=
literal|0
expr_stmt|;
block|{
name|U32
name|blockNb
decl_stmt|;
for|for
control|(
name|blockNb
operator|=
literal|0
init|;
name|blockNb
operator|<
name|nbBlocks
condition|;
name|blockNb
operator|++
control|)
name|cSize
operator|+=
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|cSize
expr_stmt|;
block|}
name|ratio
operator|=
operator|(
name|double
operator|)
name|srcSize
operator|/
operator|(
name|double
operator|)
name|cSize
expr_stmt|;
name|markNb
operator|=
operator|(
name|markNb
operator|+
literal|1
operator|)
operator|%
name|NB_MARKS
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"%2s-%-17.17s :%10u ->%10u (%5.3f),%6.1f MB/s\r"
argument_list|,
name|marks
index|[
name|markNb
index|]
argument_list|,
name|displayName
argument_list|,
operator|(
name|U32
operator|)
name|srcSize
argument_list|,
operator|(
name|U32
operator|)
name|cSize
argument_list|,
name|ratio
argument_list|,
operator|(
name|double
operator|)
name|srcSize
operator|/
name|fastestC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* g_decodeOnly */
name|memcpy
argument_list|(
name|compressedBuffer
argument_list|,
name|srcBuffer
argument_list|,
name|loadedCompressedSize
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* disable decompression test */
block|dCompleted=1;             (void)totalDTime; (void)fastestD; (void)crcOrig;
comment|/*  unused when decompression disabled */
else|#
directive|else
comment|/* Decompression */
if|if
condition|(
operator|!
name|dCompleted
condition|)
name|memset
argument_list|(
name|resultBuffer
argument_list|,
literal|0xD6
argument_list|,
name|srcSize
argument_list|)
expr_stmt|;
comment|/* warm result buffer */
name|UTIL_sleepMilli
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* give processor time to other processes */
name|UTIL_waitForNextTick
argument_list|(
name|ticksPerSecond
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dCompleted
condition|)
block|{
name|U64
name|clockLoop
init|=
name|g_nbSeconds
condition|?
name|TIMELOOP_MICROSEC
else|:
literal|1
decl_stmt|;
name|U32
name|nbLoops
init|=
literal|0
decl_stmt|;
name|UTIL_time_t
name|clockStart
decl_stmt|;
name|ZSTD_DDict
modifier|*
specifier|const
name|ddict
init|=
name|ZSTD_createDDict
argument_list|(
name|dictBuffer
argument_list|,
name|dictBufferSize
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ddict
condition|)
name|EXM_THROW
argument_list|(
literal|2
argument_list|,
literal|"ZSTD_createDDict() allocation failure"
argument_list|)
expr_stmt|;
name|UTIL_getTime
argument_list|(
operator|&
name|clockStart
argument_list|)
expr_stmt|;
do|do
block|{
name|U32
name|blockNb
decl_stmt|;
for|for
control|(
name|blockNb
operator|=
literal|0
init|;
name|blockNb
operator|<
name|nbBlocks
condition|;
name|blockNb
operator|++
control|)
block|{
name|size_t
specifier|const
name|regenSize
init|=
name|ZSTD_decompress_usingDDict
argument_list|(
name|dctx
argument_list|,
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|resPtr
argument_list|,
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|resSize
argument_list|,
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|cPtr
argument_list|,
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|cSize
argument_list|,
name|ddict
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|regenSize
argument_list|)
condition|)
block|{
name|DISPLAY
argument_list|(
literal|"ZSTD_decompress_usingDDict() failed on block %u of size %u : %s  \n"
argument_list|,
name|blockNb
argument_list|,
operator|(
name|U32
operator|)
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|cSize
argument_list|,
name|ZSTD_getErrorName
argument_list|(
name|regenSize
argument_list|)
argument_list|)
expr_stmt|;
name|clockLoop
operator|=
literal|0
expr_stmt|;
comment|/* force immediate test end */
break|break;
block|}
name|blockTable
index|[
name|blockNb
index|]
operator|.
name|resSize
operator|=
name|regenSize
expr_stmt|;
block|}
name|nbLoops
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|UTIL_clockSpanMicro
argument_list|(
name|clockStart
argument_list|,
name|ticksPerSecond
argument_list|)
operator|<
name|clockLoop
condition|)
do|;
name|ZSTD_freeDDict
argument_list|(
name|ddict
argument_list|)
expr_stmt|;
block|{
name|U64
specifier|const
name|clockSpanMicro
init|=
name|UTIL_clockSpanMicro
argument_list|(
name|clockStart
argument_list|,
name|ticksPerSecond
argument_list|)
decl_stmt|;
if|if
condition|(
name|clockSpanMicro
operator|<
name|fastestD
operator|*
name|nbLoops
condition|)
name|fastestD
operator|=
name|clockSpanMicro
operator|/
name|nbLoops
expr_stmt|;
name|totalDTime
operator|+=
name|clockSpanMicro
expr_stmt|;
name|dCompleted
operator|=
operator|(
name|totalDTime
operator|>=
name|maxTime
operator|)
expr_stmt|;
block|}
block|}
name|markNb
operator|=
operator|(
name|markNb
operator|+
literal|1
operator|)
operator|%
name|NB_MARKS
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"%2s-%-17.17s :%10u ->%10u (%5.3f),%6.1f MB/s ,%6.1f MB/s\r"
argument_list|,
name|marks
index|[
name|markNb
index|]
argument_list|,
name|displayName
argument_list|,
operator|(
name|U32
operator|)
name|srcSize
argument_list|,
operator|(
name|U32
operator|)
name|cSize
argument_list|,
name|ratio
argument_list|,
operator|(
name|double
operator|)
name|srcSize
operator|/
name|fastestC
argument_list|,
operator|(
name|double
operator|)
name|srcSize
operator|/
name|fastestD
argument_list|)
expr_stmt|;
comment|/* CRC Checking */
block|{
name|U64
specifier|const
name|crcCheck
init|=
name|XXH64
argument_list|(
name|resultBuffer
argument_list|,
name|srcSize
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|g_decodeOnly
operator|&&
operator|(
name|crcOrig
operator|!=
name|crcCheck
operator|)
condition|)
block|{
name|size_t
name|u
decl_stmt|;
name|DISPLAY
argument_list|(
literal|"!!! WARNING !!! %14s : Invalid Checksum : %x != %x   \n"
argument_list|,
name|displayName
argument_list|,
operator|(
name|unsigned
operator|)
name|crcOrig
argument_list|,
operator|(
name|unsigned
operator|)
name|crcCheck
argument_list|)
expr_stmt|;
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|srcSize
condition|;
name|u
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|srcBuffer
operator|)
index|[
name|u
index|]
operator|!=
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|resultBuffer
operator|)
index|[
name|u
index|]
condition|)
block|{
name|U32
name|segNb
decl_stmt|,
name|bNb
decl_stmt|,
name|pos
decl_stmt|;
name|size_t
name|bacc
init|=
literal|0
decl_stmt|;
name|DISPLAY
argument_list|(
literal|"Decoding error at pos %u "
argument_list|,
operator|(
name|U32
operator|)
name|u
argument_list|)
expr_stmt|;
for|for
control|(
name|segNb
operator|=
literal|0
init|;
name|segNb
operator|<
name|nbBlocks
condition|;
name|segNb
operator|++
control|)
block|{
if|if
condition|(
name|bacc
operator|+
name|blockTable
index|[
name|segNb
index|]
operator|.
name|srcSize
operator|>
name|u
condition|)
break|break;
name|bacc
operator|+=
name|blockTable
index|[
name|segNb
index|]
operator|.
name|srcSize
expr_stmt|;
block|}
name|pos
operator|=
call|(
name|U32
call|)
argument_list|(
name|u
operator|-
name|bacc
argument_list|)
expr_stmt|;
name|bNb
operator|=
name|pos
operator|/
operator|(
literal|128
name|KB
operator|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"(block %u, sub %u, pos %u) \n"
argument_list|,
name|segNb
argument_list|,
name|bNb
argument_list|,
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|>
literal|5
condition|)
block|{
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
operator|-
literal|5
init|;
name|n
operator|<
literal|0
condition|;
name|n
operator|++
control|)
name|DISPLAY
argument_list|(
literal|"%02X "
argument_list|,
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|srcBuffer
operator|)
index|[
name|u
operator|+
name|n
index|]
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" :%02X:  "
argument_list|,
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|srcBuffer
operator|)
index|[
name|u
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|1
init|;
name|n
operator|<
literal|3
condition|;
name|n
operator|++
control|)
name|DISPLAY
argument_list|(
literal|"%02X "
argument_list|,
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|srcBuffer
operator|)
index|[
name|u
operator|+
name|n
index|]
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" \n"
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
operator|-
literal|5
init|;
name|n
operator|<
literal|0
condition|;
name|n
operator|++
control|)
name|DISPLAY
argument_list|(
literal|"%02X "
argument_list|,
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|resultBuffer
operator|)
index|[
name|u
operator|+
name|n
index|]
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" :%02X:  "
argument_list|,
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|resultBuffer
operator|)
index|[
name|u
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|1
init|;
name|n
operator|<
literal|3
condition|;
name|n
operator|++
control|)
name|DISPLAY
argument_list|(
literal|"%02X "
argument_list|,
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|resultBuffer
operator|)
index|[
name|u
operator|+
name|n
index|]
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" \n"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|u
operator|==
name|srcSize
operator|-
literal|1
condition|)
block|{
comment|/* should never happen */
name|DISPLAY
argument_list|(
literal|"no difference detected\n"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
comment|/* CRC Checking */
endif|#
directive|endif
block|}
comment|/* for (testNb = 1; testNb<= (g_nbSeconds + !g_nbSeconds); testNb++) */
if|if
condition|(
name|g_displayLevel
operator|==
literal|1
condition|)
block|{
name|double
name|cSpeed
init|=
operator|(
name|double
operator|)
name|srcSize
operator|/
name|fastestC
decl_stmt|;
name|double
name|dSpeed
init|=
operator|(
name|double
operator|)
name|srcSize
operator|/
name|fastestD
decl_stmt|;
if|if
condition|(
name|g_additionalParam
condition|)
name|DISPLAY
argument_list|(
literal|"-%-3i%11i (%5.3f) %6.2f MB/s %6.1f MB/s  %s (param=%d)\n"
argument_list|,
name|cLevel
argument_list|,
operator|(
name|int
operator|)
name|cSize
argument_list|,
name|ratio
argument_list|,
name|cSpeed
argument_list|,
name|dSpeed
argument_list|,
name|displayName
argument_list|,
name|g_additionalParam
argument_list|)
expr_stmt|;
else|else
name|DISPLAY
argument_list|(
literal|"-%-3i%11i (%5.3f) %6.2f MB/s %6.1f MB/s  %s\n"
argument_list|,
name|cLevel
argument_list|,
operator|(
name|int
operator|)
name|cSize
argument_list|,
name|ratio
argument_list|,
name|cSpeed
argument_list|,
name|dSpeed
argument_list|,
name|displayName
argument_list|)
expr_stmt|;
block|}
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"%2i#\n"
argument_list|,
name|cLevel
argument_list|)
expr_stmt|;
block|}
comment|/* Bench */
comment|/* clean up */
name|free
argument_list|(
name|blockTable
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|compressedBuffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|resultBuffer
argument_list|)
expr_stmt|;
name|ZSTDMT_freeCCtx
argument_list|(
name|mtctx
argument_list|)
expr_stmt|;
name|ZSTD_freeCCtx
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|ZSTD_freeDCtx
argument_list|(
name|dctx
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|BMK_findMaxMem
parameter_list|(
name|U64
name|requiredMem
parameter_list|)
block|{
name|size_t
specifier|const
name|step
init|=
literal|64
name|MB
decl_stmt|;
name|BYTE
modifier|*
name|testmem
init|=
name|NULL
decl_stmt|;
name|requiredMem
operator|=
operator|(
operator|(
operator|(
name|requiredMem
operator|>>
literal|26
operator|)
operator|+
literal|1
operator|)
operator|<<
literal|26
operator|)
expr_stmt|;
name|requiredMem
operator|+=
name|step
expr_stmt|;
if|if
condition|(
name|requiredMem
operator|>
name|maxMemory
condition|)
name|requiredMem
operator|=
name|maxMemory
expr_stmt|;
do|do
block|{
name|testmem
operator|=
operator|(
name|BYTE
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|size_t
operator|)
name|requiredMem
argument_list|)
expr_stmt|;
name|requiredMem
operator|-=
name|step
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|testmem
condition|)
do|;
name|free
argument_list|(
name|testmem
argument_list|)
expr_stmt|;
return|return
call|(
name|size_t
call|)
argument_list|(
name|requiredMem
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|BMK_benchCLevel
parameter_list|(
name|void
modifier|*
name|srcBuffer
parameter_list|,
name|size_t
name|benchedSize
parameter_list|,
specifier|const
name|char
modifier|*
name|displayName
parameter_list|,
name|int
name|cLevel
parameter_list|,
name|int
name|cLevelLast
parameter_list|,
specifier|const
name|size_t
modifier|*
name|fileSizes
parameter_list|,
name|unsigned
name|nbFiles
parameter_list|,
specifier|const
name|void
modifier|*
name|dictBuffer
parameter_list|,
name|size_t
name|dictBufferSize
parameter_list|,
name|ZSTD_compressionParameters
modifier|*
name|compressionParams
parameter_list|,
name|int
name|setRealTimePrio
parameter_list|)
block|{
name|int
name|l
decl_stmt|;
specifier|const
name|char
modifier|*
name|pch
init|=
name|strrchr
argument_list|(
name|displayName
argument_list|,
literal|'\\'
argument_list|)
decl_stmt|;
comment|/* Windows */
if|if
condition|(
operator|!
name|pch
condition|)
name|pch
operator|=
name|strrchr
argument_list|(
name|displayName
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
comment|/* Linux */
if|if
condition|(
name|pch
condition|)
name|displayName
operator|=
name|pch
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|setRealTimePrio
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"Note : switching to a real-time priority \n"
argument_list|)
expr_stmt|;
name|SET_REALTIME_PRIORITY
expr_stmt|;
block|}
if|if
condition|(
name|g_displayLevel
operator|==
literal|1
operator|&&
operator|!
name|g_additionalParam
condition|)
name|DISPLAY
argument_list|(
literal|"bench %s %s: input %u bytes, %u seconds, %u KB blocks\n"
argument_list|,
name|ZSTD_VERSION_STRING
argument_list|,
name|ZSTD_GIT_COMMIT_STRING
argument_list|,
operator|(
name|U32
operator|)
name|benchedSize
argument_list|,
name|g_nbSeconds
argument_list|,
call|(
name|U32
call|)
argument_list|(
name|g_blockSize
operator|>>
literal|10
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cLevelLast
operator|<
name|cLevel
condition|)
name|cLevelLast
operator|=
name|cLevel
expr_stmt|;
for|for
control|(
name|l
operator|=
name|cLevel
init|;
name|l
operator|<=
name|cLevelLast
condition|;
name|l
operator|++
control|)
block|{
name|BMK_benchMem
argument_list|(
name|srcBuffer
argument_list|,
name|benchedSize
argument_list|,
name|displayName
argument_list|,
name|l
argument_list|,
name|fileSizes
argument_list|,
name|nbFiles
argument_list|,
name|dictBuffer
argument_list|,
name|dictBufferSize
argument_list|,
name|compressionParams
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*! BMK_loadFiles() :     Loads `buffer` with content of files listed within `fileNamesTable`.     At most, fills `buffer` entirely */
end_comment

begin_function
specifier|static
name|void
name|BMK_loadFiles
parameter_list|(
name|void
modifier|*
name|buffer
parameter_list|,
name|size_t
name|bufferSize
parameter_list|,
name|size_t
modifier|*
name|fileSizes
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|fileNamesTable
parameter_list|,
name|unsigned
name|nbFiles
parameter_list|)
block|{
name|size_t
name|pos
init|=
literal|0
decl_stmt|,
name|totalSize
init|=
literal|0
decl_stmt|;
name|unsigned
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nbFiles
condition|;
name|n
operator|++
control|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|U64
name|fileSize
init|=
name|UTIL_getFileSize
argument_list|(
name|fileNamesTable
index|[
name|n
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|UTIL_isDirectory
argument_list|(
name|fileNamesTable
index|[
name|n
index|]
argument_list|)
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"Ignoring %s directory...       \n"
argument_list|,
name|fileNamesTable
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|fileSizes
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|f
operator|=
name|fopen
argument_list|(
name|fileNamesTable
index|[
name|n
index|]
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
name|EXM_THROW
argument_list|(
literal|10
argument_list|,
literal|"impossible to open file %s"
argument_list|,
name|fileNamesTable
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|DISPLAYUPDATE
argument_list|(
literal|2
argument_list|,
literal|"Loading %s...       \r"
argument_list|,
name|fileNamesTable
index|[
name|n
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileSize
operator|>
name|bufferSize
operator|-
name|pos
condition|)
name|fileSize
operator|=
name|bufferSize
operator|-
name|pos
operator|,
name|nbFiles
operator|=
name|n
expr_stmt|;
comment|/* buffer too small - stop after this file */
block|{
name|size_t
specifier|const
name|readSize
init|=
name|fread
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|buffer
operator|)
operator|+
name|pos
argument_list|,
literal|1
argument_list|,
operator|(
name|size_t
operator|)
name|fileSize
argument_list|,
name|f
argument_list|)
decl_stmt|;
if|if
condition|(
name|readSize
operator|!=
operator|(
name|size_t
operator|)
name|fileSize
condition|)
name|EXM_THROW
argument_list|(
literal|11
argument_list|,
literal|"could not read %s"
argument_list|,
name|fileNamesTable
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|readSize
expr_stmt|;
block|}
name|fileSizes
index|[
name|n
index|]
operator|=
operator|(
name|size_t
operator|)
name|fileSize
expr_stmt|;
name|totalSize
operator|+=
operator|(
name|size_t
operator|)
name|fileSize
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|totalSize
operator|==
literal|0
condition|)
name|EXM_THROW
argument_list|(
literal|12
argument_list|,
literal|"no data to bench"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|BMK_benchFileTable
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|fileNamesTable
parameter_list|,
name|unsigned
name|nbFiles
parameter_list|,
specifier|const
name|char
modifier|*
name|dictFileName
parameter_list|,
name|int
name|cLevel
parameter_list|,
name|int
name|cLevelLast
parameter_list|,
name|ZSTD_compressionParameters
modifier|*
name|compressionParams
parameter_list|,
name|int
name|setRealTimePrio
parameter_list|)
block|{
name|void
modifier|*
name|srcBuffer
decl_stmt|;
name|size_t
name|benchedSize
decl_stmt|;
name|void
modifier|*
name|dictBuffer
init|=
name|NULL
decl_stmt|;
name|size_t
name|dictBufferSize
init|=
literal|0
decl_stmt|;
name|size_t
modifier|*
name|fileSizes
init|=
operator|(
name|size_t
operator|*
operator|)
name|malloc
argument_list|(
name|nbFiles
operator|*
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
decl_stmt|;
name|U64
specifier|const
name|totalSizeToLoad
init|=
name|UTIL_getTotalFileSize
argument_list|(
name|fileNamesTable
argument_list|,
name|nbFiles
argument_list|)
decl_stmt|;
name|char
name|mfName
index|[
literal|20
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
if|if
condition|(
operator|!
name|fileSizes
condition|)
name|EXM_THROW
argument_list|(
literal|12
argument_list|,
literal|"not enough memory for fileSizes"
argument_list|)
expr_stmt|;
comment|/* Load dictionary */
if|if
condition|(
name|dictFileName
operator|!=
name|NULL
condition|)
block|{
name|U64
name|dictFileSize
init|=
name|UTIL_getFileSize
argument_list|(
name|dictFileName
argument_list|)
decl_stmt|;
if|if
condition|(
name|dictFileSize
operator|>
literal|64
name|MB
condition|)
name|EXM_THROW
argument_list|(
literal|10
argument_list|,
literal|"dictionary file %s too large"
argument_list|,
name|dictFileName
argument_list|)
expr_stmt|;
name|dictBufferSize
operator|=
operator|(
name|size_t
operator|)
name|dictFileSize
expr_stmt|;
name|dictBuffer
operator|=
name|malloc
argument_list|(
name|dictBufferSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|dictBuffer
operator|==
name|NULL
condition|)
name|EXM_THROW
argument_list|(
literal|11
argument_list|,
literal|"not enough memory for dictionary (%u bytes)"
argument_list|,
operator|(
name|U32
operator|)
name|dictBufferSize
argument_list|)
expr_stmt|;
name|BMK_loadFiles
argument_list|(
name|dictBuffer
argument_list|,
name|dictBufferSize
argument_list|,
name|fileSizes
argument_list|,
operator|&
name|dictFileName
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Memory allocation& restrictions */
name|benchedSize
operator|=
name|BMK_findMaxMem
argument_list|(
name|totalSizeToLoad
operator|*
literal|3
argument_list|)
operator|/
literal|3
expr_stmt|;
if|if
condition|(
operator|(
name|U64
operator|)
name|benchedSize
operator|>
name|totalSizeToLoad
condition|)
name|benchedSize
operator|=
operator|(
name|size_t
operator|)
name|totalSizeToLoad
expr_stmt|;
if|if
condition|(
name|benchedSize
operator|<
name|totalSizeToLoad
condition|)
name|DISPLAY
argument_list|(
literal|"Not enough memory; testing %u MB only...\n"
argument_list|,
call|(
name|U32
call|)
argument_list|(
name|benchedSize
operator|>>
literal|20
argument_list|)
argument_list|)
expr_stmt|;
name|srcBuffer
operator|=
name|malloc
argument_list|(
name|benchedSize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|srcBuffer
condition|)
name|EXM_THROW
argument_list|(
literal|12
argument_list|,
literal|"not enough memory"
argument_list|)
expr_stmt|;
comment|/* Load input buffer */
name|BMK_loadFiles
argument_list|(
name|srcBuffer
argument_list|,
name|benchedSize
argument_list|,
name|fileSizes
argument_list|,
name|fileNamesTable
argument_list|,
name|nbFiles
argument_list|)
expr_stmt|;
comment|/* Bench */
name|snprintf
argument_list|(
name|mfName
argument_list|,
sizeof|sizeof
argument_list|(
name|mfName
argument_list|)
argument_list|,
literal|" %u files"
argument_list|,
name|nbFiles
argument_list|)
expr_stmt|;
block|{
specifier|const
name|char
modifier|*
name|displayName
init|=
operator|(
name|nbFiles
operator|>
literal|1
operator|)
condition|?
name|mfName
else|:
name|fileNamesTable
index|[
literal|0
index|]
decl_stmt|;
name|BMK_benchCLevel
argument_list|(
name|srcBuffer
argument_list|,
name|benchedSize
argument_list|,
name|displayName
argument_list|,
name|cLevel
argument_list|,
name|cLevelLast
argument_list|,
name|fileSizes
argument_list|,
name|nbFiles
argument_list|,
name|dictBuffer
argument_list|,
name|dictBufferSize
argument_list|,
name|compressionParams
argument_list|,
name|setRealTimePrio
argument_list|)
expr_stmt|;
block|}
comment|/* clean up */
name|free
argument_list|(
name|srcBuffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dictBuffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fileSizes
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|BMK_syntheticTest
parameter_list|(
name|int
name|cLevel
parameter_list|,
name|int
name|cLevelLast
parameter_list|,
name|double
name|compressibility
parameter_list|,
name|ZSTD_compressionParameters
modifier|*
name|compressionParams
parameter_list|,
name|int
name|setRealTimePrio
parameter_list|)
block|{
name|char
name|name
index|[
literal|20
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|size_t
name|benchedSize
init|=
literal|10000000
decl_stmt|;
name|void
modifier|*
specifier|const
name|srcBuffer
init|=
name|malloc
argument_list|(
name|benchedSize
argument_list|)
decl_stmt|;
comment|/* Memory allocation */
if|if
condition|(
operator|!
name|srcBuffer
condition|)
name|EXM_THROW
argument_list|(
literal|21
argument_list|,
literal|"not enough memory"
argument_list|)
expr_stmt|;
comment|/* Fill input buffer */
name|RDG_genBuffer
argument_list|(
name|srcBuffer
argument_list|,
name|benchedSize
argument_list|,
name|compressibility
argument_list|,
literal|0.0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Bench */
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"Synthetic %2u%%"
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|compressibility
operator|*
literal|100
argument_list|)
argument_list|)
expr_stmt|;
name|BMK_benchCLevel
argument_list|(
name|srcBuffer
argument_list|,
name|benchedSize
argument_list|,
name|name
argument_list|,
name|cLevel
argument_list|,
name|cLevelLast
argument_list|,
operator|&
name|benchedSize
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|compressionParams
argument_list|,
name|setRealTimePrio
argument_list|)
expr_stmt|;
comment|/* clean up */
name|free
argument_list|(
name|srcBuffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|BMK_benchFiles
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|fileNamesTable
parameter_list|,
name|unsigned
name|nbFiles
parameter_list|,
specifier|const
name|char
modifier|*
name|dictFileName
parameter_list|,
name|int
name|cLevel
parameter_list|,
name|int
name|cLevelLast
parameter_list|,
name|ZSTD_compressionParameters
modifier|*
name|compressionParams
parameter_list|,
name|int
name|setRealTimePrio
parameter_list|)
block|{
name|double
specifier|const
name|compressibility
init|=
operator|(
name|double
operator|)
name|g_compressibilityDefault
operator|/
literal|100
decl_stmt|;
if|if
condition|(
name|cLevel
operator|<
literal|1
condition|)
name|cLevel
operator|=
literal|1
expr_stmt|;
comment|/* minimum compression level */
if|if
condition|(
name|cLevel
operator|>
name|ZSTD_maxCLevel
argument_list|()
condition|)
name|cLevel
operator|=
name|ZSTD_maxCLevel
argument_list|()
expr_stmt|;
if|if
condition|(
name|cLevelLast
operator|>
name|ZSTD_maxCLevel
argument_list|()
condition|)
name|cLevelLast
operator|=
name|ZSTD_maxCLevel
argument_list|()
expr_stmt|;
if|if
condition|(
name|cLevelLast
operator|<
name|cLevel
condition|)
name|cLevelLast
operator|=
name|cLevel
expr_stmt|;
if|if
condition|(
name|cLevelLast
operator|>
name|cLevel
condition|)
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"Benchmarking levels from %d to %d\n"
argument_list|,
name|cLevel
argument_list|,
name|cLevelLast
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbFiles
operator|==
literal|0
condition|)
name|BMK_syntheticTest
argument_list|(
name|cLevel
argument_list|,
name|cLevelLast
argument_list|,
name|compressibility
argument_list|,
name|compressionParams
argument_list|,
name|setRealTimePrio
argument_list|)
expr_stmt|;
else|else
name|BMK_benchFileTable
argument_list|(
name|fileNamesTable
argument_list|,
name|nbFiles
argument_list|,
name|dictFileName
argument_list|,
name|cLevel
argument_list|,
name|cLevelLast
argument_list|,
name|compressionParams
argument_list|,
name|setRealTimePrio
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

