begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright (c) 2016-present, Yann Collet, Facebook, Inc.  * All rights reserved.  *  * This source code is licensed under the BSD-style license found in the  * LICENSE file in the root directory of this source tree. An additional grant  * of patent rights can be found in the PATENTS file in the same directory.  */
end_comment

begin_comment
comment|/* ************************************* *  Compiler Options ***************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_comment
comment|/* Visual */
end_comment

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4127
name|)
end_pragma

begin_comment
comment|/* disable: C4127: conditional expression is constant */
end_comment

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4204
name|)
end_pragma

begin_comment
comment|/* non-constant aggregate initializer */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__MINGW32__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_POSIX_SOURCE
argument_list|)
end_if

begin_define
define|#
directive|define
name|_POSIX_SOURCE
value|1
end_define

begin_comment
comment|/* disable %llu warnings with MinGW on Windows */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*-************************************* *  Includes ***************************************/
end_comment

begin_include
include|#
directive|include
file|"platform.h"
end_include

begin_comment
comment|/* Large Files support, SET_BINARY_MODE */
end_comment

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_comment
comment|/* UTIL_getFileSize */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* fprintf, fopen, fread, _fileno, stdin, stdout */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* malloc, free */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* strcmp, strlen */
end_comment

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_comment
comment|/* clock */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* errno */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"mem.h"
end_include

begin_include
include|#
directive|include
file|"fileio.h"
end_include

begin_define
define|#
directive|define
name|ZSTD_STATIC_LINKING_ONLY
end_define

begin_comment
comment|/* ZSTD_magicNumber, ZSTD_frameHeaderSize_max */
end_comment

begin_include
include|#
directive|include
file|"zstd.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ZSTD_MULTITHREAD
end_ifdef

begin_include
include|#
directive|include
file|"zstdmt_compress.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|ZSTD_GZCOMPRESS
argument_list|)
operator|||
name|defined
argument_list|(
name|ZSTD_GZDECOMPRESS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<zlib.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|z_const
argument_list|)
end_if

begin_define
define|#
directive|define
name|z_const
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|ZSTD_LZMACOMPRESS
argument_list|)
operator|||
name|defined
argument_list|(
name|ZSTD_LZMADECOMPRESS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<lzma.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|LZ4_MAGICNUMBER
value|0x184D2204
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|ZSTD_LZ4COMPRESS
argument_list|)
operator|||
name|defined
argument_list|(
name|ZSTD_LZ4DECOMPRESS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<lz4frame.h>
end_include

begin_include
include|#
directive|include
file|<lz4.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*-************************************* *  Constants ***************************************/
end_comment

begin_define
define|#
directive|define
name|KB
value|*(1<<10)
end_define

begin_define
define|#
directive|define
name|MB
value|*(1<<20)
end_define

begin_define
define|#
directive|define
name|GB
value|*(1U<<30)
end_define

begin_define
define|#
directive|define
name|_1BIT
value|0x01
end_define

begin_define
define|#
directive|define
name|_2BITS
value|0x03
end_define

begin_define
define|#
directive|define
name|_3BITS
value|0x07
end_define

begin_define
define|#
directive|define
name|_4BITS
value|0x0F
end_define

begin_define
define|#
directive|define
name|_6BITS
value|0x3F
end_define

begin_define
define|#
directive|define
name|_8BITS
value|0xFF
end_define

begin_define
define|#
directive|define
name|BLOCKSIZE
value|(128 KB)
end_define

begin_define
define|#
directive|define
name|ROLLBUFFERSIZE
value|(BLOCKSIZE*8*64)
end_define

begin_define
define|#
directive|define
name|FIO_FRAMEHEADERSIZE
value|5
end_define

begin_comment
comment|/* as a define, because needed to allocated table on stack */
end_comment

begin_define
define|#
directive|define
name|FSE_CHECKSUM_SEED
value|0
end_define

begin_define
define|#
directive|define
name|CACHELINE
value|64
end_define

begin_define
define|#
directive|define
name|DICTSIZE_MAX
value|(32 MB)
end_define

begin_comment
comment|/* protection against large input (attack scenario) */
end_comment

begin_define
define|#
directive|define
name|FNSPACE
value|30
end_define

begin_comment
comment|/*-************************************* *  Macros ***************************************/
end_comment

begin_define
define|#
directive|define
name|DISPLAY
parameter_list|(
modifier|...
parameter_list|)
value|fprintf(stderr, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|DISPLAYLEVEL
parameter_list|(
name|l
parameter_list|,
modifier|...
parameter_list|)
value|{ if (g_displayLevel>=l) { DISPLAY(__VA_ARGS__); } }
end_define

begin_decl_stmt
specifier|static
name|int
name|g_displayLevel
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 : no display;   1: errors;   2 : + result + interaction + warnings;   3 : + progression;   4 : + information */
end_comment

begin_function
name|void
name|FIO_setNotificationLevel
parameter_list|(
name|unsigned
name|level
parameter_list|)
block|{
name|g_displayLevel
operator|=
name|level
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|DISPLAYUPDATE
parameter_list|(
name|l
parameter_list|,
modifier|...
parameter_list|)
value|{ if (g_displayLevel>=l) { \             if ((clock() - g_time> refreshRate) || (g_displayLevel>=4)) \             { g_time = clock(); DISPLAY(__VA_ARGS__); \             if (g_displayLevel>=4) fflush(stderr); } } }
end_define

begin_decl_stmt
specifier|static
specifier|const
name|clock_t
name|refreshRate
init|=
name|CLOCKS_PER_SEC
operator|*
literal|15
operator|/
literal|100
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|clock_t
name|g_time
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|MIN
end_undef

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_comment
comment|/* ************************************************************ * Avoid fseek()'s 2GiB barrier with MSVC, MacOS, *BSD, MinGW ***************************************************************/
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|_MSC_VER
operator|>=
literal|1400
end_if

begin_define
define|#
directive|define
name|LONG_SEEK
value|_fseeki64
end_define

begin_elif
elif|#
directive|elif
operator|!
name|defined
argument_list|(
name|__64BIT__
argument_list|)
operator|&&
operator|(
name|PLATFORM_POSIX_VERSION
operator|>=
literal|200112L
operator|)
end_elif

begin_comment
comment|/* No point defining Large file for 64 bit */
end_comment

begin_define
define|#
directive|define
name|LONG_SEEK
value|fseeko
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__MINGW32__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__STRICT_ANSI__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__NO_MINGW_LFS
argument_list|)
operator|&&
name|defined
argument_list|(
name|__MSVCRT__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|LONG_SEEK
value|fseeko64
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__DJGPP__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_function
specifier|static
name|int
name|LONG_SEEK
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|__int64
name|offset
parameter_list|,
name|int
name|origin
parameter_list|)
block|{
name|LARGE_INTEGER
name|off
decl_stmt|;
name|DWORD
name|method
decl_stmt|;
name|off
operator|.
name|QuadPart
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|origin
operator|==
name|SEEK_END
condition|)
name|method
operator|=
name|FILE_END
expr_stmt|;
elseif|else
if|if
condition|(
name|origin
operator|==
name|SEEK_CUR
condition|)
name|method
operator|=
name|FILE_CURRENT
expr_stmt|;
else|else
name|method
operator|=
name|FILE_BEGIN
expr_stmt|;
if|if
condition|(
name|SetFilePointerEx
argument_list|(
operator|(
name|HANDLE
operator|)
name|_get_osfhandle
argument_list|(
name|_fileno
argument_list|(
name|file
argument_list|)
argument_list|)
argument_list|,
name|off
argument_list|,
name|NULL
argument_list|,
name|method
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LONG_SEEK
value|fseek
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*-************************************* *  Local Parameters - Not thread safe ***************************************/
end_comment

begin_decl_stmt
specifier|static
name|FIO_compressionType_t
name|g_compressionType
init|=
name|FIO_zstdCompression
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|FIO_setCompressionType
parameter_list|(
name|FIO_compressionType_t
name|compressionType
parameter_list|)
block|{
name|g_compressionType
operator|=
name|compressionType
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|U32
name|g_overwrite
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|FIO_overwriteMode
parameter_list|(
name|void
parameter_list|)
block|{
name|g_overwrite
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|U32
name|g_sparseFileSupport
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 : no sparse allowed; 1: auto (file yes, stdout no); 2: force sparse */
end_comment

begin_function
name|void
name|FIO_setSparseWrite
parameter_list|(
name|unsigned
name|sparse
parameter_list|)
block|{
name|g_sparseFileSupport
operator|=
name|sparse
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|U32
name|g_dictIDFlag
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|FIO_setDictIDFlag
parameter_list|(
name|unsigned
name|dictIDFlag
parameter_list|)
block|{
name|g_dictIDFlag
operator|=
name|dictIDFlag
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|U32
name|g_checksumFlag
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|FIO_setChecksumFlag
parameter_list|(
name|unsigned
name|checksumFlag
parameter_list|)
block|{
name|g_checksumFlag
operator|=
name|checksumFlag
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|U32
name|g_removeSrcFile
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|FIO_setRemoveSrcFile
parameter_list|(
name|unsigned
name|flag
parameter_list|)
block|{
name|g_removeSrcFile
operator|=
operator|(
name|flag
operator|>
literal|0
operator|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|U32
name|g_memLimit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|FIO_setMemLimit
parameter_list|(
name|unsigned
name|memLimit
parameter_list|)
block|{
name|g_memLimit
operator|=
name|memLimit
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|U32
name|g_nbThreads
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|FIO_setNbThreads
parameter_list|(
name|unsigned
name|nbThreads
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|ZSTD_MULTITHREAD
if|if
condition|(
name|nbThreads
operator|>
literal|1
condition|)
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"Note : multi-threading is disabled \n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|g_nbThreads
operator|=
name|nbThreads
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|U32
name|g_blockSize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|FIO_setBlockSize
parameter_list|(
name|unsigned
name|blockSize
parameter_list|)
block|{
if|if
condition|(
name|blockSize
operator|&&
name|g_nbThreads
operator|==
literal|1
condition|)
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"Setting block size is useless in single-thread mode \n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ZSTD_MULTITHREAD
if|if
condition|(
name|blockSize
operator|-
literal|1
operator|<
name|ZSTDMT_SECTION_SIZE_MIN
operator|-
literal|1
condition|)
comment|/* intentional underflow */
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"Note : minimum block size is %u KB \n"
argument_list|,
operator|(
name|ZSTDMT_SECTION_SIZE_MIN
operator|>>
literal|10
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|g_blockSize
operator|=
name|blockSize
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|FIO_OVERLAP_LOG_NOTSET
value|9999
end_define

begin_decl_stmt
specifier|static
name|U32
name|g_overlapLog
init|=
name|FIO_OVERLAP_LOG_NOTSET
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|FIO_setOverlapLog
parameter_list|(
name|unsigned
name|overlapLog
parameter_list|)
block|{
if|if
condition|(
name|overlapLog
operator|&&
name|g_nbThreads
operator|==
literal|1
condition|)
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"Setting overlapLog is useless in single-thread mode \n"
argument_list|)
expr_stmt|;
name|g_overlapLog
operator|=
name|overlapLog
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-************************************* *  Exceptions ***************************************/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG
end_ifndef

begin_define
define|#
directive|define
name|DEBUG
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DEBUGOUTPUT
parameter_list|(
modifier|...
parameter_list|)
value|if (DEBUG) DISPLAY(__VA_ARGS__);
end_define

begin_define
define|#
directive|define
name|EXM_THROW
parameter_list|(
name|error
parameter_list|,
modifier|...
parameter_list|)
define|\
value|{                                                                         \     DEBUGOUTPUT("Error defined at %s, line %i : \n", __FILE__, __LINE__); \     DISPLAYLEVEL(1, "Error %i : ", error);                                \     DISPLAYLEVEL(1, __VA_ARGS__);                                         \     DISPLAYLEVEL(1, " \n");                                               \     exit(error);                                                          \ }
end_define

begin_comment
comment|/*-************************************* *  Functions ***************************************/
end_comment

begin_comment
comment|/** FIO_remove() :  * @result : Unlink `fileName`, even if it's read-only */
end_comment

begin_function
specifier|static
name|int
name|FIO_remove
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|WIN32
argument_list|)
comment|/* windows doesn't allow remove read-only files, so try to make it      * writable first */
name|chmod
argument_list|(
name|path
argument_list|,
name|_S_IWRITE
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|remove
argument_list|(
name|path
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/** FIO_openSrcFile() :  * condition : `dstFileName` must be non-NULL.  * @result : FILE* to `dstFileName`, or NULL if it fails */
end_comment

begin_function
specifier|static
name|FILE
modifier|*
name|FIO_openSrcFile
parameter_list|(
specifier|const
name|char
modifier|*
name|srcFileName
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|srcFileName
argument_list|,
name|stdinmark
argument_list|)
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|4
argument_list|,
literal|"Using stdin for input\n"
argument_list|)
expr_stmt|;
name|f
operator|=
name|stdin
expr_stmt|;
name|SET_BINARY_MODE
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|UTIL_isRegFile
argument_list|(
name|srcFileName
argument_list|)
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"zstd: %s is not a regular file -- ignored \n"
argument_list|,
name|srcFileName
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|f
operator|=
name|fopen
argument_list|(
name|srcFileName
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"zstd: %s: %s \n"
argument_list|,
name|srcFileName
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|f
return|;
block|}
end_function

begin_comment
comment|/** FIO_openDstFile() :  * condition : `dstFileName` must be non-NULL.  * @result : FILE* to `dstFileName`, or NULL if it fails */
end_comment

begin_function
specifier|static
name|FILE
modifier|*
name|FIO_openDstFile
parameter_list|(
specifier|const
name|char
modifier|*
name|dstFileName
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|dstFileName
argument_list|,
name|stdoutmark
argument_list|)
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|4
argument_list|,
literal|"Using stdout for output\n"
argument_list|)
expr_stmt|;
name|f
operator|=
name|stdout
expr_stmt|;
name|SET_BINARY_MODE
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_sparseFileSupport
operator|==
literal|1
condition|)
block|{
name|g_sparseFileSupport
operator|=
literal|0
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|4
argument_list|,
literal|"Sparse File Support is automatically disabled on stdout ; try --sparse \n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|g_sparseFileSupport
operator|==
literal|1
condition|)
block|{
name|g_sparseFileSupport
operator|=
name|ZSTD_SPARSE_DEFAULT
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|dstFileName
argument_list|,
name|nulmark
argument_list|)
condition|)
block|{
comment|/* Check if destination file already exists */
name|f
operator|=
name|fopen
argument_list|(
name|dstFileName
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|!=
literal|0
condition|)
block|{
comment|/* dest file exists, prompt for overwrite authorization */
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|g_overwrite
condition|)
block|{
if|if
condition|(
name|g_displayLevel
operator|<=
literal|1
condition|)
block|{
comment|/* No interaction possible */
name|DISPLAY
argument_list|(
literal|"zstd: %s already exists; not overwritten  \n"
argument_list|,
name|dstFileName
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|DISPLAY
argument_list|(
literal|"zstd: %s already exists; do you wish to overwrite (y/N) ? "
argument_list|,
name|dstFileName
argument_list|)
expr_stmt|;
block|{
name|int
name|ch
init|=
name|getchar
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|ch
operator|!=
literal|'Y'
operator|)
operator|&&
operator|(
name|ch
operator|!=
literal|'y'
operator|)
condition|)
block|{
name|DISPLAY
argument_list|(
literal|"    not overwritten  \n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
while|while
condition|(
operator|(
name|ch
operator|!=
name|EOF
operator|)
operator|&&
operator|(
name|ch
operator|!=
literal|'\n'
operator|)
condition|)
name|ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/* flush rest of input line */
block|}
block|}
comment|/* need to unlink */
name|FIO_remove
argument_list|(
name|dstFileName
argument_list|)
expr_stmt|;
block|}
block|}
name|f
operator|=
name|fopen
argument_list|(
name|dstFileName
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"zstd: %s: %s\n"
argument_list|,
name|dstFileName
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|f
return|;
block|}
end_function

begin_comment
comment|/*! FIO_createDictBuffer() :  *  creates a buffer, pointed by `*bufferPtr`,  *  loads `filename` content into it, up to DICTSIZE_MAX bytes.  *  @return : loaded size  *  if fileName==NULL, returns 0 and a NULL pointer  */
end_comment

begin_function
specifier|static
name|size_t
name|FIO_createDictBuffer
parameter_list|(
name|void
modifier|*
modifier|*
name|bufferPtr
parameter_list|,
specifier|const
name|char
modifier|*
name|fileName
parameter_list|)
block|{
name|FILE
modifier|*
name|fileHandle
decl_stmt|;
name|U64
name|fileSize
decl_stmt|;
operator|*
name|bufferPtr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fileName
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|DISPLAYLEVEL
argument_list|(
literal|4
argument_list|,
literal|"Loading %s as dictionary \n"
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
name|fileHandle
operator|=
name|fopen
argument_list|(
name|fileName
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileHandle
operator|==
literal|0
condition|)
name|EXM_THROW
argument_list|(
literal|31
argument_list|,
literal|"zstd: %s: %s"
argument_list|,
name|fileName
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fileSize
operator|=
name|UTIL_getFileSize
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileSize
operator|>
name|DICTSIZE_MAX
condition|)
name|EXM_THROW
argument_list|(
literal|32
argument_list|,
literal|"Dictionary file %s is too large (> %u MB)"
argument_list|,
name|fileName
argument_list|,
name|DICTSIZE_MAX
operator|>>
literal|20
argument_list|)
expr_stmt|;
comment|/* avoid extreme cases */
operator|*
name|bufferPtr
operator|=
name|malloc
argument_list|(
operator|(
name|size_t
operator|)
name|fileSize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bufferPtr
operator|==
name|NULL
condition|)
name|EXM_THROW
argument_list|(
literal|34
argument_list|,
literal|"zstd: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|size_t
specifier|const
name|readSize
init|=
name|fread
argument_list|(
operator|*
name|bufferPtr
argument_list|,
literal|1
argument_list|,
operator|(
name|size_t
operator|)
name|fileSize
argument_list|,
name|fileHandle
argument_list|)
decl_stmt|;
if|if
condition|(
name|readSize
operator|!=
name|fileSize
condition|)
name|EXM_THROW
argument_list|(
literal|35
argument_list|,
literal|"Error reading dictionary file %s"
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fileHandle
argument_list|)
expr_stmt|;
return|return
operator|(
name|size_t
operator|)
name|fileSize
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|ZSTD_NOCOMPRESS
end_ifndef

begin_comment
comment|/*-********************************************************************** *  Compression ************************************************************************/
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|FILE
modifier|*
name|srcFile
decl_stmt|;
name|FILE
modifier|*
name|dstFile
decl_stmt|;
name|void
modifier|*
name|srcBuffer
decl_stmt|;
name|size_t
name|srcBufferSize
decl_stmt|;
name|void
modifier|*
name|dstBuffer
decl_stmt|;
name|size_t
name|dstBufferSize
decl_stmt|;
ifdef|#
directive|ifdef
name|ZSTD_MULTITHREAD
name|ZSTDMT_CCtx
modifier|*
name|cctx
decl_stmt|;
else|#
directive|else
name|ZSTD_CStream
modifier|*
name|cctx
decl_stmt|;
endif|#
directive|endif
block|}
name|cRess_t
typedef|;
end_typedef

begin_function
specifier|static
name|cRess_t
name|FIO_createCResources
parameter_list|(
specifier|const
name|char
modifier|*
name|dictFileName
parameter_list|,
name|int
name|cLevel
parameter_list|,
name|U64
name|srcSize
parameter_list|,
name|int
name|srcRegFile
parameter_list|,
name|ZSTD_compressionParameters
modifier|*
name|comprParams
parameter_list|)
block|{
name|cRess_t
name|ress
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ress
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ress
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ZSTD_MULTITHREAD
name|ress
operator|.
name|cctx
operator|=
name|ZSTDMT_createCCtx
argument_list|(
name|g_nbThreads
argument_list|)
expr_stmt|;
if|if
condition|(
name|ress
operator|.
name|cctx
operator|==
name|NULL
condition|)
name|EXM_THROW
argument_list|(
literal|30
argument_list|,
literal|"zstd: allocation error : can't create ZSTD_CStream"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cLevel
operator|==
name|ZSTD_maxCLevel
argument_list|()
operator|)
operator|&&
operator|(
name|g_overlapLog
operator|==
name|FIO_OVERLAP_LOG_NOTSET
operator|)
condition|)
name|ZSTDMT_setMTCtxParameter
argument_list|(
name|ress
operator|.
name|cctx
argument_list|,
name|ZSTDMT_p_overlapSectionLog
argument_list|,
literal|9
argument_list|)
expr_stmt|;
comment|/* use complete window for overlap */
if|if
condition|(
name|g_overlapLog
operator|!=
name|FIO_OVERLAP_LOG_NOTSET
condition|)
name|ZSTDMT_setMTCtxParameter
argument_list|(
name|ress
operator|.
name|cctx
argument_list|,
name|ZSTDMT_p_overlapSectionLog
argument_list|,
name|g_overlapLog
argument_list|)
expr_stmt|;
else|#
directive|else
name|ress
operator|.
name|cctx
operator|=
name|ZSTD_createCStream
argument_list|()
expr_stmt|;
if|if
condition|(
name|ress
operator|.
name|cctx
operator|==
name|NULL
condition|)
name|EXM_THROW
argument_list|(
literal|30
argument_list|,
literal|"zstd: allocation error : can't create ZSTD_CStream"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ress
operator|.
name|srcBufferSize
operator|=
name|ZSTD_CStreamInSize
argument_list|()
expr_stmt|;
name|ress
operator|.
name|srcBuffer
operator|=
name|malloc
argument_list|(
name|ress
operator|.
name|srcBufferSize
argument_list|)
expr_stmt|;
name|ress
operator|.
name|dstBufferSize
operator|=
name|ZSTD_CStreamOutSize
argument_list|()
expr_stmt|;
name|ress
operator|.
name|dstBuffer
operator|=
name|malloc
argument_list|(
name|ress
operator|.
name|dstBufferSize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ress
operator|.
name|srcBuffer
operator|||
operator|!
name|ress
operator|.
name|dstBuffer
condition|)
name|EXM_THROW
argument_list|(
literal|31
argument_list|,
literal|"zstd: allocation error : not enough memory"
argument_list|)
expr_stmt|;
comment|/* dictionary */
block|{
name|void
modifier|*
name|dictBuffer
decl_stmt|;
name|size_t
specifier|const
name|dictBuffSize
init|=
name|FIO_createDictBuffer
argument_list|(
operator|&
name|dictBuffer
argument_list|,
name|dictFileName
argument_list|)
decl_stmt|;
comment|/* works with dictFileName==NULL */
if|if
condition|(
name|dictFileName
operator|&&
operator|(
name|dictBuffer
operator|==
name|NULL
operator|)
condition|)
name|EXM_THROW
argument_list|(
literal|32
argument_list|,
literal|"zstd: allocation error : can't create dictBuffer"
argument_list|)
expr_stmt|;
block|{
name|ZSTD_parameters
name|params
init|=
name|ZSTD_getParams
argument_list|(
name|cLevel
argument_list|,
name|srcSize
argument_list|,
name|dictBuffSize
argument_list|)
decl_stmt|;
name|params
operator|.
name|fParams
operator|.
name|contentSizeFlag
operator|=
name|srcRegFile
expr_stmt|;
name|params
operator|.
name|fParams
operator|.
name|checksumFlag
operator|=
name|g_checksumFlag
expr_stmt|;
name|params
operator|.
name|fParams
operator|.
name|noDictIDFlag
operator|=
operator|!
name|g_dictIDFlag
expr_stmt|;
if|if
condition|(
name|comprParams
operator|->
name|windowLog
condition|)
name|params
operator|.
name|cParams
operator|.
name|windowLog
operator|=
name|comprParams
operator|->
name|windowLog
expr_stmt|;
if|if
condition|(
name|comprParams
operator|->
name|chainLog
condition|)
name|params
operator|.
name|cParams
operator|.
name|chainLog
operator|=
name|comprParams
operator|->
name|chainLog
expr_stmt|;
if|if
condition|(
name|comprParams
operator|->
name|hashLog
condition|)
name|params
operator|.
name|cParams
operator|.
name|hashLog
operator|=
name|comprParams
operator|->
name|hashLog
expr_stmt|;
if|if
condition|(
name|comprParams
operator|->
name|searchLog
condition|)
name|params
operator|.
name|cParams
operator|.
name|searchLog
operator|=
name|comprParams
operator|->
name|searchLog
expr_stmt|;
if|if
condition|(
name|comprParams
operator|->
name|searchLength
condition|)
name|params
operator|.
name|cParams
operator|.
name|searchLength
operator|=
name|comprParams
operator|->
name|searchLength
expr_stmt|;
if|if
condition|(
name|comprParams
operator|->
name|targetLength
condition|)
name|params
operator|.
name|cParams
operator|.
name|targetLength
operator|=
name|comprParams
operator|->
name|targetLength
expr_stmt|;
if|if
condition|(
name|comprParams
operator|->
name|strategy
condition|)
name|params
operator|.
name|cParams
operator|.
name|strategy
operator|=
call|(
name|ZSTD_strategy
call|)
argument_list|(
name|comprParams
operator|->
name|strategy
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 0 means : do not change */
ifdef|#
directive|ifdef
name|ZSTD_MULTITHREAD
block|{
name|size_t
specifier|const
name|errorCode
init|=
name|ZSTDMT_initCStream_advanced
argument_list|(
name|ress
operator|.
name|cctx
argument_list|,
name|dictBuffer
argument_list|,
name|dictBuffSize
argument_list|,
name|params
argument_list|,
name|srcSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
name|EXM_THROW
argument_list|(
literal|33
argument_list|,
literal|"Error initializing CStream : %s"
argument_list|,
name|ZSTD_getErrorName
argument_list|(
name|errorCode
argument_list|)
argument_list|)
expr_stmt|;
name|ZSTDMT_setMTCtxParameter
argument_list|(
name|ress
operator|.
name|cctx
argument_list|,
name|ZSTDMT_p_sectionSize
argument_list|,
name|g_blockSize
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
name|size_t
specifier|const
name|errorCode
init|=
name|ZSTD_initCStream_advanced
argument_list|(
name|ress
operator|.
name|cctx
argument_list|,
name|dictBuffer
argument_list|,
name|dictBuffSize
argument_list|,
name|params
argument_list|,
name|srcSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
name|EXM_THROW
argument_list|(
literal|33
argument_list|,
literal|"Error initializing CStream : %s"
argument_list|,
name|ZSTD_getErrorName
argument_list|(
name|errorCode
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|free
argument_list|(
name|dictBuffer
argument_list|)
expr_stmt|;
block|}
return|return
name|ress
return|;
block|}
specifier|static
name|void
name|FIO_freeCResources
parameter_list|(
name|cRess_t
name|ress
parameter_list|)
block|{
name|free
argument_list|(
name|ress
operator|.
name|srcBuffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ress
operator|.
name|dstBuffer
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ZSTD_MULTITHREAD
name|ZSTDMT_freeCCtx
argument_list|(
name|ress
operator|.
name|cctx
argument_list|)
expr_stmt|;
else|#
directive|else
name|ZSTD_freeCStream
argument_list|(
name|ress
operator|.
name|cctx
argument_list|)
expr_stmt|;
comment|/* never fails */
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|ZSTD_GZCOMPRESS
specifier|static
name|unsigned
name|long
name|long
name|FIO_compressGzFrame
parameter_list|(
name|cRess_t
modifier|*
name|ress
parameter_list|,
specifier|const
name|char
modifier|*
name|srcFileName
parameter_list|,
name|U64
specifier|const
name|srcFileSize
parameter_list|,
name|int
name|compressionLevel
parameter_list|,
name|U64
modifier|*
name|readsize
parameter_list|)
block|{
name|unsigned
name|long
name|long
name|inFileSize
init|=
literal|0
decl_stmt|,
name|outFileSize
init|=
literal|0
decl_stmt|;
name|z_stream
name|strm
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|compressionLevel
operator|>
name|Z_BEST_COMPRESSION
condition|)
name|compressionLevel
operator|=
name|Z_BEST_COMPRESSION
expr_stmt|;
name|strm
operator|.
name|zalloc
operator|=
name|Z_NULL
expr_stmt|;
name|strm
operator|.
name|zfree
operator|=
name|Z_NULL
expr_stmt|;
name|strm
operator|.
name|opaque
operator|=
name|Z_NULL
expr_stmt|;
name|ret
operator|=
name|deflateInit2
argument_list|(
operator|&
name|strm
argument_list|,
name|compressionLevel
argument_list|,
name|Z_DEFLATED
argument_list|,
literal|15
comment|/* maxWindowLogSize */
operator|+
literal|16
comment|/* gzip only */
argument_list|,
literal|8
argument_list|,
name|Z_DEFAULT_STRATEGY
argument_list|)
expr_stmt|;
comment|/* see http://www.zlib.net/manual.html */
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
name|EXM_THROW
argument_list|(
literal|71
argument_list|,
literal|"zstd: %s: deflateInit2 error %d \n"
argument_list|,
name|srcFileName
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|strm
operator|.
name|next_in
operator|=
literal|0
expr_stmt|;
name|strm
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
name|strm
operator|.
name|next_out
operator|=
operator|(
name|Bytef
operator|*
operator|)
name|ress
operator|->
name|dstBuffer
expr_stmt|;
name|strm
operator|.
name|avail_out
operator|=
operator|(
name|uInt
operator|)
name|ress
operator|->
name|dstBufferSize
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|strm
operator|.
name|avail_in
operator|==
literal|0
condition|)
block|{
name|size_t
specifier|const
name|inSize
init|=
name|fread
argument_list|(
name|ress
operator|->
name|srcBuffer
argument_list|,
literal|1
argument_list|,
name|ress
operator|->
name|srcBufferSize
argument_list|,
name|ress
operator|->
name|srcFile
argument_list|)
decl_stmt|;
if|if
condition|(
name|inSize
operator|==
literal|0
condition|)
break|break;
name|inFileSize
operator|+=
name|inSize
expr_stmt|;
name|strm
operator|.
name|next_in
operator|=
operator|(
name|z_const
name|unsigned
name|char
operator|*
operator|)
name|ress
operator|->
name|srcBuffer
expr_stmt|;
name|strm
operator|.
name|avail_in
operator|=
operator|(
name|uInt
operator|)
name|inSize
expr_stmt|;
block|}
name|ret
operator|=
name|deflate
argument_list|(
operator|&
name|strm
argument_list|,
name|Z_NO_FLUSH
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
name|EXM_THROW
argument_list|(
literal|72
argument_list|,
literal|"zstd: %s: deflate error %d \n"
argument_list|,
name|srcFileName
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|{
name|size_t
specifier|const
name|decompBytes
init|=
name|ress
operator|->
name|dstBufferSize
operator|-
name|strm
operator|.
name|avail_out
decl_stmt|;
if|if
condition|(
name|decompBytes
condition|)
block|{
if|if
condition|(
name|fwrite
argument_list|(
name|ress
operator|->
name|dstBuffer
argument_list|,
literal|1
argument_list|,
name|decompBytes
argument_list|,
name|ress
operator|->
name|dstFile
argument_list|)
operator|!=
name|decompBytes
condition|)
name|EXM_THROW
argument_list|(
literal|73
argument_list|,
literal|"Write error : cannot write to output file"
argument_list|)
expr_stmt|;
name|outFileSize
operator|+=
name|decompBytes
expr_stmt|;
name|strm
operator|.
name|next_out
operator|=
operator|(
name|Bytef
operator|*
operator|)
name|ress
operator|->
name|dstBuffer
expr_stmt|;
name|strm
operator|.
name|avail_out
operator|=
operator|(
name|uInt
operator|)
name|ress
operator|->
name|dstBufferSize
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|srcFileSize
condition|)
name|DISPLAYUPDATE
argument_list|(
literal|2
argument_list|,
literal|"\rRead : %u MB ==> %.2f%%"
argument_list|,
argument|(U32)(inFileSize>>
literal|20
argument|)
argument_list|,
argument|(double)outFileSize/inFileSize*
literal|100
argument_list|)
else|else
name|DISPLAYUPDATE
argument_list|(
literal|2
argument_list|,
literal|"\rRead : %u / %u MB ==> %.2f%%"
argument_list|,
call|(
name|U32
call|)
argument_list|(
name|inFileSize
operator|>>
literal|20
argument_list|)
argument_list|,
call|(
name|U32
call|)
argument_list|(
name|srcFileSize
operator|>>
literal|20
argument_list|)
argument_list|,
operator|(
name|double
operator|)
name|outFileSize
operator|/
name|inFileSize
operator|*
literal|100
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|ret
operator|=
name|deflate
argument_list|(
operator|&
name|strm
argument_list|,
name|Z_FINISH
argument_list|)
expr_stmt|;
block|{
name|size_t
specifier|const
name|decompBytes
init|=
name|ress
operator|->
name|dstBufferSize
operator|-
name|strm
operator|.
name|avail_out
decl_stmt|;
if|if
condition|(
name|decompBytes
condition|)
block|{
if|if
condition|(
name|fwrite
argument_list|(
name|ress
operator|->
name|dstBuffer
argument_list|,
literal|1
argument_list|,
name|decompBytes
argument_list|,
name|ress
operator|->
name|dstFile
argument_list|)
operator|!=
name|decompBytes
condition|)
name|EXM_THROW
argument_list|(
literal|75
argument_list|,
literal|"Write error : cannot write to output file"
argument_list|)
expr_stmt|;
name|outFileSize
operator|+=
name|decompBytes
expr_stmt|;
name|strm
operator|.
name|next_out
operator|=
operator|(
name|Bytef
operator|*
operator|)
name|ress
operator|->
name|dstBuffer
expr_stmt|;
name|strm
operator|.
name|avail_out
operator|=
operator|(
name|uInt
operator|)
name|ress
operator|->
name|dstBufferSize
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ret
operator|==
name|Z_STREAM_END
condition|)
break|break;
if|if
condition|(
name|ret
operator|!=
name|Z_BUF_ERROR
condition|)
name|EXM_THROW
argument_list|(
literal|77
argument_list|,
literal|"zstd: %s: deflate error %d \n"
argument_list|,
name|srcFileName
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|deflateEnd
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
name|EXM_THROW
argument_list|(
literal|79
argument_list|,
literal|"zstd: %s: deflateEnd error %d \n"
argument_list|,
name|srcFileName
argument_list|,
name|ret
argument_list|)
expr_stmt|;
operator|*
name|readsize
operator|=
name|inFileSize
expr_stmt|;
return|return
name|outFileSize
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ZSTD_LZMACOMPRESS
specifier|static
name|unsigned
name|long
name|long
name|FIO_compressLzmaFrame
parameter_list|(
name|cRess_t
modifier|*
name|ress
parameter_list|,
specifier|const
name|char
modifier|*
name|srcFileName
parameter_list|,
name|U64
specifier|const
name|srcFileSize
parameter_list|,
name|int
name|compressionLevel
parameter_list|,
name|U64
modifier|*
name|readsize
parameter_list|,
name|int
name|plain_lzma
parameter_list|)
block|{
name|unsigned
name|long
name|long
name|inFileSize
init|=
literal|0
decl_stmt|,
name|outFileSize
init|=
literal|0
decl_stmt|;
name|lzma_stream
name|strm
init|=
name|LZMA_STREAM_INIT
decl_stmt|;
name|lzma_action
name|action
init|=
name|LZMA_RUN
decl_stmt|;
name|lzma_ret
name|ret
decl_stmt|;
if|if
condition|(
name|compressionLevel
operator|<
literal|0
condition|)
name|compressionLevel
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|compressionLevel
operator|>
literal|9
condition|)
name|compressionLevel
operator|=
literal|9
expr_stmt|;
if|if
condition|(
name|plain_lzma
condition|)
block|{
name|lzma_options_lzma
name|opt_lzma
decl_stmt|;
if|if
condition|(
name|lzma_lzma_preset
argument_list|(
operator|&
name|opt_lzma
argument_list|,
name|compressionLevel
argument_list|)
condition|)
name|EXM_THROW
argument_list|(
literal|71
argument_list|,
literal|"zstd: %s: lzma_lzma_preset error"
argument_list|,
name|srcFileName
argument_list|)
expr_stmt|;
name|ret
operator|=
name|lzma_alone_encoder
argument_list|(
operator|&
name|strm
argument_list|,
operator|&
name|opt_lzma
argument_list|)
expr_stmt|;
comment|/* LZMA */
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
name|EXM_THROW
argument_list|(
literal|71
argument_list|,
literal|"zstd: %s: lzma_alone_encoder error %d"
argument_list|,
name|srcFileName
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|lzma_easy_encoder
argument_list|(
operator|&
name|strm
argument_list|,
name|compressionLevel
argument_list|,
name|LZMA_CHECK_CRC64
argument_list|)
expr_stmt|;
comment|/* XZ */
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
name|EXM_THROW
argument_list|(
literal|71
argument_list|,
literal|"zstd: %s: lzma_easy_encoder error %d"
argument_list|,
name|srcFileName
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
name|strm
operator|.
name|next_in
operator|=
literal|0
expr_stmt|;
name|strm
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
name|strm
operator|.
name|next_out
operator|=
name|ress
operator|->
name|dstBuffer
expr_stmt|;
name|strm
operator|.
name|avail_out
operator|=
name|ress
operator|->
name|dstBufferSize
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|strm
operator|.
name|avail_in
operator|==
literal|0
condition|)
block|{
name|size_t
specifier|const
name|inSize
init|=
name|fread
argument_list|(
name|ress
operator|->
name|srcBuffer
argument_list|,
literal|1
argument_list|,
name|ress
operator|->
name|srcBufferSize
argument_list|,
name|ress
operator|->
name|srcFile
argument_list|)
decl_stmt|;
if|if
condition|(
name|inSize
operator|==
literal|0
condition|)
name|action
operator|=
name|LZMA_FINISH
expr_stmt|;
name|inFileSize
operator|+=
name|inSize
expr_stmt|;
name|strm
operator|.
name|next_in
operator|=
name|ress
operator|->
name|srcBuffer
expr_stmt|;
name|strm
operator|.
name|avail_in
operator|=
name|inSize
expr_stmt|;
block|}
name|ret
operator|=
name|lzma_code
argument_list|(
operator|&
name|strm
argument_list|,
name|action
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
operator|&&
name|ret
operator|!=
name|LZMA_STREAM_END
condition|)
name|EXM_THROW
argument_list|(
literal|72
argument_list|,
literal|"zstd: %s: lzma_code encoding error %d"
argument_list|,
name|srcFileName
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|{
name|size_t
specifier|const
name|compBytes
init|=
name|ress
operator|->
name|dstBufferSize
operator|-
name|strm
operator|.
name|avail_out
decl_stmt|;
if|if
condition|(
name|compBytes
condition|)
block|{
if|if
condition|(
name|fwrite
argument_list|(
name|ress
operator|->
name|dstBuffer
argument_list|,
literal|1
argument_list|,
name|compBytes
argument_list|,
name|ress
operator|->
name|dstFile
argument_list|)
operator|!=
name|compBytes
condition|)
name|EXM_THROW
argument_list|(
literal|73
argument_list|,
literal|"Write error : cannot write to output file"
argument_list|)
expr_stmt|;
name|outFileSize
operator|+=
name|compBytes
expr_stmt|;
name|strm
operator|.
name|next_out
operator|=
name|ress
operator|->
name|dstBuffer
expr_stmt|;
name|strm
operator|.
name|avail_out
operator|=
name|ress
operator|->
name|dstBufferSize
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|srcFileSize
condition|)
name|DISPLAYUPDATE
argument_list|(
literal|2
argument_list|,
literal|"\rRead : %u MB ==> %.2f%%"
argument_list|,
argument|(U32)(inFileSize>>
literal|20
argument|)
argument_list|,
argument|(double)outFileSize/inFileSize*
literal|100
argument_list|)
else|else
name|DISPLAYUPDATE
argument_list|(
literal|2
argument_list|,
literal|"\rRead : %u / %u MB ==> %.2f%%"
argument_list|,
call|(
name|U32
call|)
argument_list|(
name|inFileSize
operator|>>
literal|20
argument_list|)
argument_list|,
call|(
name|U32
call|)
argument_list|(
name|srcFileSize
operator|>>
literal|20
argument_list|)
argument_list|,
operator|(
name|double
operator|)
name|outFileSize
operator|/
name|inFileSize
operator|*
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|LZMA_STREAM_END
condition|)
break|break;
block|}
name|lzma_end
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
operator|*
name|readsize
operator|=
name|inFileSize
expr_stmt|;
return|return
name|outFileSize
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ZSTD_LZ4COMPRESS
specifier|static
name|int
name|FIO_LZ4_GetBlockSize_FromBlockId
parameter_list|(
name|int
name|id
parameter_list|)
block|{
return|return
operator|(
literal|1
operator|<<
operator|(
literal|8
operator|+
operator|(
literal|2
operator|*
name|id
operator|)
operator|)
operator|)
return|;
block|}
specifier|static
name|unsigned
name|long
name|long
name|FIO_compressLz4Frame
parameter_list|(
name|cRess_t
modifier|*
name|ress
parameter_list|,
specifier|const
name|char
modifier|*
name|srcFileName
parameter_list|,
name|U64
specifier|const
name|srcFileSize
parameter_list|,
name|int
name|compressionLevel
parameter_list|,
name|U64
modifier|*
name|readsize
parameter_list|)
block|{
name|unsigned
name|long
name|long
name|inFileSize
init|=
literal|0
decl_stmt|,
name|outFileSize
init|=
literal|0
decl_stmt|;
name|LZ4F_preferences_t
name|prefs
decl_stmt|;
name|LZ4F_compressionContext_t
name|ctx
decl_stmt|;
name|LZ4F_errorCode_t
specifier|const
name|errorCode
init|=
name|LZ4F_createCompressionContext
argument_list|(
operator|&
name|ctx
argument_list|,
name|LZ4F_VERSION
argument_list|)
decl_stmt|;
if|if
condition|(
name|LZ4F_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
name|EXM_THROW
argument_list|(
literal|31
argument_list|,
literal|"zstd: failed to create lz4 compression context"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|prefs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|prefs
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|LZ4_VERSION_NUMBER
operator|<=
literal|10600
define|#
directive|define
name|LZ4F_blockIndependent
value|blockIndependent
define|#
directive|define
name|LZ4F_max4MB
value|max4MB
endif|#
directive|endif
name|prefs
operator|.
name|autoFlush
operator|=
literal|1
expr_stmt|;
name|prefs
operator|.
name|compressionLevel
operator|=
name|compressionLevel
expr_stmt|;
name|prefs
operator|.
name|frameInfo
operator|.
name|blockMode
operator|=
name|LZ4F_blockIndependent
expr_stmt|;
comment|/* stick to defaults for lz4 cli */
name|prefs
operator|.
name|frameInfo
operator|.
name|blockSizeID
operator|=
name|LZ4F_max4MB
expr_stmt|;
name|prefs
operator|.
name|frameInfo
operator|.
name|contentChecksumFlag
operator|=
operator|(
name|contentChecksum_t
operator|)
name|g_checksumFlag
expr_stmt|;
if|#
directive|if
name|LZ4_VERSION_NUMBER
operator|>=
literal|10600
name|prefs
operator|.
name|frameInfo
operator|.
name|contentSize
operator|=
name|srcFileSize
expr_stmt|;
endif|#
directive|endif
block|{
name|size_t
name|blockSize
init|=
name|FIO_LZ4_GetBlockSize_FromBlockId
argument_list|(
name|LZ4F_max4MB
argument_list|)
decl_stmt|;
name|size_t
name|readSize
decl_stmt|;
name|size_t
name|headerSize
init|=
name|LZ4F_compressBegin
argument_list|(
name|ctx
argument_list|,
name|ress
operator|->
name|dstBuffer
argument_list|,
name|ress
operator|->
name|dstBufferSize
argument_list|,
operator|&
name|prefs
argument_list|)
decl_stmt|;
if|if
condition|(
name|LZ4F_isError
argument_list|(
name|headerSize
argument_list|)
condition|)
name|EXM_THROW
argument_list|(
literal|33
argument_list|,
literal|"File header generation failed : %s"
argument_list|,
name|LZ4F_getErrorName
argument_list|(
name|headerSize
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|size_t
specifier|const
name|sizeCheck
init|=
name|fwrite
argument_list|(
name|ress
operator|->
name|dstBuffer
argument_list|,
literal|1
argument_list|,
name|headerSize
argument_list|,
name|ress
operator|->
name|dstFile
argument_list|)
decl_stmt|;
if|if
condition|(
name|sizeCheck
operator|!=
name|headerSize
condition|)
name|EXM_THROW
argument_list|(
literal|34
argument_list|,
literal|"Write error : cannot write header"
argument_list|)
expr_stmt|;
block|}
name|outFileSize
operator|+=
name|headerSize
expr_stmt|;
comment|/* Read first block */
name|readSize
operator|=
name|fread
argument_list|(
name|ress
operator|->
name|srcBuffer
argument_list|,
operator|(
name|size_t
operator|)
literal|1
argument_list|,
operator|(
name|size_t
operator|)
name|blockSize
argument_list|,
name|ress
operator|->
name|srcFile
argument_list|)
expr_stmt|;
name|inFileSize
operator|+=
name|readSize
expr_stmt|;
comment|/* Main Loop */
while|while
condition|(
name|readSize
operator|>
literal|0
condition|)
block|{
name|size_t
name|outSize
decl_stmt|;
comment|/* Compress Block */
name|outSize
operator|=
name|LZ4F_compressUpdate
argument_list|(
name|ctx
argument_list|,
name|ress
operator|->
name|dstBuffer
argument_list|,
name|ress
operator|->
name|dstBufferSize
argument_list|,
name|ress
operator|->
name|srcBuffer
argument_list|,
name|readSize
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|LZ4F_isError
argument_list|(
name|outSize
argument_list|)
condition|)
name|EXM_THROW
argument_list|(
literal|35
argument_list|,
literal|"zstd: %s: lz4 compression failed : %s"
argument_list|,
name|srcFileName
argument_list|,
name|LZ4F_getErrorName
argument_list|(
name|outSize
argument_list|)
argument_list|)
expr_stmt|;
name|outFileSize
operator|+=
name|outSize
expr_stmt|;
if|if
condition|(
operator|!
name|srcFileSize
condition|)
name|DISPLAYUPDATE
argument_list|(
literal|2
argument_list|,
literal|"\rRead : %u MB ==> %.2f%%"
argument_list|,
argument|(U32)(inFileSize>>
literal|20
argument|)
argument_list|,
argument|(double)outFileSize/inFileSize*
literal|100
argument_list|)
else|else
name|DISPLAYUPDATE
argument_list|(
literal|2
argument_list|,
literal|"\rRead : %u / %u MB ==> %.2f%%"
argument_list|,
call|(
name|U32
call|)
argument_list|(
name|inFileSize
operator|>>
literal|20
argument_list|)
argument_list|,
call|(
name|U32
call|)
argument_list|(
name|srcFileSize
operator|>>
literal|20
argument_list|)
argument_list|,
operator|(
name|double
operator|)
name|outFileSize
operator|/
name|inFileSize
operator|*
literal|100
argument_list|)
expr_stmt|;
comment|/* Write Block */
block|{
name|size_t
specifier|const
name|sizeCheck
init|=
name|fwrite
argument_list|(
name|ress
operator|->
name|dstBuffer
argument_list|,
literal|1
argument_list|,
name|outSize
argument_list|,
name|ress
operator|->
name|dstFile
argument_list|)
decl_stmt|;
if|if
condition|(
name|sizeCheck
operator|!=
name|outSize
condition|)
name|EXM_THROW
argument_list|(
literal|36
argument_list|,
literal|"Write error : cannot write compressed block"
argument_list|)
expr_stmt|;
block|}
comment|/* Read next block */
name|readSize
operator|=
name|fread
argument_list|(
name|ress
operator|->
name|srcBuffer
argument_list|,
operator|(
name|size_t
operator|)
literal|1
argument_list|,
operator|(
name|size_t
operator|)
name|blockSize
argument_list|,
name|ress
operator|->
name|srcFile
argument_list|)
expr_stmt|;
name|inFileSize
operator|+=
name|readSize
expr_stmt|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|ress
operator|->
name|srcFile
argument_list|)
condition|)
name|EXM_THROW
argument_list|(
literal|37
argument_list|,
literal|"Error reading %s "
argument_list|,
name|srcFileName
argument_list|)
expr_stmt|;
comment|/* End of Stream mark */
name|headerSize
operator|=
name|LZ4F_compressEnd
argument_list|(
name|ctx
argument_list|,
name|ress
operator|->
name|dstBuffer
argument_list|,
name|ress
operator|->
name|dstBufferSize
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|LZ4F_isError
argument_list|(
name|headerSize
argument_list|)
condition|)
name|EXM_THROW
argument_list|(
literal|38
argument_list|,
literal|"zstd: %s: lz4 end of file generation failed : %s"
argument_list|,
name|srcFileName
argument_list|,
name|LZ4F_getErrorName
argument_list|(
name|headerSize
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|size_t
specifier|const
name|sizeCheck
init|=
name|fwrite
argument_list|(
name|ress
operator|->
name|dstBuffer
argument_list|,
literal|1
argument_list|,
name|headerSize
argument_list|,
name|ress
operator|->
name|dstFile
argument_list|)
decl_stmt|;
if|if
condition|(
name|sizeCheck
operator|!=
name|headerSize
condition|)
name|EXM_THROW
argument_list|(
literal|39
argument_list|,
literal|"Write error : cannot write end of stream"
argument_list|)
expr_stmt|;
block|}
name|outFileSize
operator|+=
name|headerSize
expr_stmt|;
block|}
operator|*
name|readsize
operator|=
name|inFileSize
expr_stmt|;
name|LZ4F_freeCompressionContext
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
name|outFileSize
return|;
block|}
endif|#
directive|endif
comment|/*! FIO_compressFilename_internal() :  *  same as FIO_compressFilename_extRess(), with `ress.desFile` already opened.  *  @return : 0 : compression completed correctly,  *            1 : missing or pb opening srcFileName  */
specifier|static
name|int
name|FIO_compressFilename_internal
parameter_list|(
name|cRess_t
name|ress
parameter_list|,
specifier|const
name|char
modifier|*
name|dstFileName
parameter_list|,
specifier|const
name|char
modifier|*
name|srcFileName
parameter_list|,
name|int
name|compressionLevel
parameter_list|)
block|{
name|FILE
modifier|*
specifier|const
name|srcFile
init|=
name|ress
operator|.
name|srcFile
decl_stmt|;
name|FILE
modifier|*
specifier|const
name|dstFile
init|=
name|ress
operator|.
name|dstFile
decl_stmt|;
name|U64
name|readsize
init|=
literal|0
decl_stmt|;
name|U64
name|compressedfilesize
init|=
literal|0
decl_stmt|;
name|U64
specifier|const
name|fileSize
init|=
name|UTIL_getFileSize
argument_list|(
name|srcFileName
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|g_compressionType
condition|)
block|{
case|case
name|FIO_zstdCompression
case|:
break|break;
case|case
name|FIO_gzipCompression
case|:
ifdef|#
directive|ifdef
name|ZSTD_GZCOMPRESS
name|compressedfilesize
operator|=
name|FIO_compressGzFrame
argument_list|(
operator|&
name|ress
argument_list|,
name|srcFileName
argument_list|,
name|fileSize
argument_list|,
name|compressionLevel
argument_list|,
operator|&
name|readsize
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|compressionLevel
expr_stmt|;
name|EXM_THROW
argument_list|(
literal|20
argument_list|,
literal|"zstd: %s: file cannot be compressed as gzip (zstd compiled without ZSTD_GZCOMPRESS) -- ignored \n"
argument_list|,
name|srcFileName
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|finish
goto|;
case|case
name|FIO_xzCompression
case|:
case|case
name|FIO_lzmaCompression
case|:
ifdef|#
directive|ifdef
name|ZSTD_LZMACOMPRESS
name|compressedfilesize
operator|=
name|FIO_compressLzmaFrame
argument_list|(
operator|&
name|ress
argument_list|,
name|srcFileName
argument_list|,
name|fileSize
argument_list|,
name|compressionLevel
argument_list|,
operator|&
name|readsize
argument_list|,
name|g_compressionType
operator|==
name|FIO_lzmaCompression
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|compressionLevel
expr_stmt|;
name|EXM_THROW
argument_list|(
literal|20
argument_list|,
literal|"zstd: %s: file cannot be compressed as xz/lzma (zstd compiled without ZSTD_LZMACOMPRESS) -- ignored \n"
argument_list|,
name|srcFileName
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|finish
goto|;
case|case
name|FIO_lz4Compression
case|:
ifdef|#
directive|ifdef
name|ZSTD_LZ4COMPRESS
name|compressedfilesize
operator|=
name|FIO_compressLz4Frame
argument_list|(
operator|&
name|ress
argument_list|,
name|srcFileName
argument_list|,
name|fileSize
argument_list|,
name|compressionLevel
argument_list|,
operator|&
name|readsize
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|compressionLevel
expr_stmt|;
name|EXM_THROW
argument_list|(
literal|20
argument_list|,
literal|"zstd: %s: file cannot be compressed as lz4 (zstd compiled without ZSTD_LZ4COMPRESS) -- ignored \n"
argument_list|,
name|srcFileName
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|finish
goto|;
block|}
comment|/* init */
ifdef|#
directive|ifdef
name|ZSTD_MULTITHREAD
block|{
name|size_t
specifier|const
name|resetError
init|=
name|ZSTDMT_resetCStream
argument_list|(
name|ress
operator|.
name|cctx
argument_list|,
name|fileSize
argument_list|)
decl_stmt|;
else|#
directive|else
block|{
name|size_t
specifier|const
name|resetError
init|=
name|ZSTD_resetCStream
argument_list|(
name|ress
operator|.
name|cctx
argument_list|,
name|fileSize
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|resetError
argument_list|)
condition|)
name|EXM_THROW
argument_list|(
literal|21
argument_list|,
literal|"Error initializing compression : %s"
argument_list|,
name|ZSTD_getErrorName
argument_list|(
name|resetError
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Main compression loop */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Fill input Buffer */
name|size_t
specifier|const
name|inSize
init|=
name|fread
argument_list|(
name|ress
operator|.
name|srcBuffer
argument_list|,
operator|(
name|size_t
operator|)
literal|1
argument_list|,
name|ress
operator|.
name|srcBufferSize
argument_list|,
name|srcFile
argument_list|)
decl_stmt|;
if|if
condition|(
name|inSize
operator|==
literal|0
condition|)
break|break;
name|readsize
operator|+=
name|inSize
expr_stmt|;
block|{
name|ZSTD_inBuffer
name|inBuff
init|=
block|{
name|ress
operator|.
name|srcBuffer
block|,
name|inSize
block|,
literal|0
block|}
decl_stmt|;
while|while
condition|(
name|inBuff
operator|.
name|pos
operator|!=
name|inBuff
operator|.
name|size
condition|)
block|{
name|ZSTD_outBuffer
name|outBuff
init|=
block|{
name|ress
operator|.
name|dstBuffer
block|,
name|ress
operator|.
name|dstBufferSize
block|,
literal|0
block|}
decl_stmt|;
ifdef|#
directive|ifdef
name|ZSTD_MULTITHREAD
name|size_t
specifier|const
name|result
init|=
name|ZSTDMT_compressStream
argument_list|(
name|ress
operator|.
name|cctx
argument_list|,
operator|&
name|outBuff
argument_list|,
operator|&
name|inBuff
argument_list|)
decl_stmt|;
else|#
directive|else
name|size_t
specifier|const
name|result
init|=
name|ZSTD_compressStream
argument_list|(
name|ress
operator|.
name|cctx
argument_list|,
operator|&
name|outBuff
argument_list|,
operator|&
name|inBuff
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|result
argument_list|)
condition|)
name|EXM_THROW
argument_list|(
literal|23
argument_list|,
literal|"Compression error : %s "
argument_list|,
name|ZSTD_getErrorName
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write compressed stream */
if|if
condition|(
name|outBuff
operator|.
name|pos
condition|)
block|{
name|size_t
specifier|const
name|sizeCheck
init|=
name|fwrite
argument_list|(
name|ress
operator|.
name|dstBuffer
argument_list|,
literal|1
argument_list|,
name|outBuff
operator|.
name|pos
argument_list|,
name|dstFile
argument_list|)
decl_stmt|;
if|if
condition|(
name|sizeCheck
operator|!=
name|outBuff
operator|.
name|pos
condition|)
name|EXM_THROW
argument_list|(
literal|25
argument_list|,
literal|"Write error : cannot write compressed block into %s"
argument_list|,
name|dstFileName
argument_list|)
expr_stmt|;
name|compressedfilesize
operator|+=
name|outBuff
operator|.
name|pos
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|g_nbThreads
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|fileSize
condition|)
name|DISPLAYUPDATE
argument_list|(
literal|2
argument_list|,
literal|"\rRead : %u MB"
argument_list|,
argument|(U32)(readsize>>
literal|20
argument|)
argument_list|)
else|else
name|DISPLAYUPDATE
argument_list|(
literal|2
argument_list|,
literal|"\rRead : %u / %u MB"
argument_list|,
call|(
name|U32
call|)
argument_list|(
name|readsize
operator|>>
literal|20
argument_list|)
argument_list|,
call|(
name|U32
call|)
argument_list|(
name|fileSize
operator|>>
literal|20
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|fileSize
condition|)
name|DISPLAYUPDATE
argument_list|(
literal|2
argument_list|,
literal|"\rRead : %u MB ==> %.2f%%"
argument_list|,
argument|(U32)(readsize>>
literal|20
argument|)
argument_list|,
argument|(double)compressedfilesize/readsize*
literal|100
argument_list|)
else|else
name|DISPLAYUPDATE
argument_list|(
literal|2
argument_list|,
literal|"\rRead : %u / %u MB ==> %.2f%%"
argument_list|,
call|(
name|U32
call|)
argument_list|(
name|readsize
operator|>>
literal|20
argument_list|)
argument_list|,
call|(
name|U32
call|)
argument_list|(
name|fileSize
operator|>>
literal|20
argument_list|)
argument_list|,
operator|(
name|double
operator|)
name|compressedfilesize
operator|/
name|readsize
operator|*
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* End of Frame */
block|{
name|size_t
name|result
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
comment|/* note : is there any possibility of endless loop ? */
name|ZSTD_outBuffer
name|outBuff
init|=
block|{
name|ress
operator|.
name|dstBuffer
block|,
name|ress
operator|.
name|dstBufferSize
block|,
literal|0
block|}
decl_stmt|;
ifdef|#
directive|ifdef
name|ZSTD_MULTITHREAD
name|result
operator|=
name|ZSTDMT_endStream
argument_list|(
name|ress
operator|.
name|cctx
argument_list|,
operator|&
name|outBuff
argument_list|)
expr_stmt|;
else|#
directive|else
name|result
operator|=
name|ZSTD_endStream
argument_list|(
name|ress
operator|.
name|cctx
argument_list|,
operator|&
name|outBuff
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|result
argument_list|)
condition|)
name|EXM_THROW
argument_list|(
literal|26
argument_list|,
literal|"Compression error during frame end : %s"
argument_list|,
name|ZSTD_getErrorName
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|size_t
specifier|const
name|sizeCheck
init|=
name|fwrite
argument_list|(
name|ress
operator|.
name|dstBuffer
argument_list|,
literal|1
argument_list|,
name|outBuff
operator|.
name|pos
argument_list|,
name|dstFile
argument_list|)
decl_stmt|;
if|if
condition|(
name|sizeCheck
operator|!=
name|outBuff
operator|.
name|pos
condition|)
name|EXM_THROW
argument_list|(
literal|27
argument_list|,
literal|"Write error : cannot write frame end into %s"
argument_list|,
name|dstFileName
argument_list|)
expr_stmt|;
block|}
name|compressedfilesize
operator|+=
name|outBuff
operator|.
name|pos
expr_stmt|;
block|}
block|}
name|finish
label|:
comment|/* Status */
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"\r%79s\r"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"%-20s :%6.2f%%   (%6llu => %6llu bytes, %s) \n"
argument_list|,
name|srcFileName
argument_list|,
operator|(
name|double
operator|)
name|compressedfilesize
operator|/
operator|(
name|readsize
operator|+
operator|(
operator|!
name|readsize
operator|)
comment|/* avoid div by zero */
operator|)
operator|*
literal|100
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|readsize
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|compressedfilesize
argument_list|,
name|dstFileName
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*! FIO_compressFilename_srcFile() :  *  note : ress.destFile already opened  *  @return : 0 : compression completed correctly,  *            1 : missing or pb opening srcFileName  */
specifier|static
name|int
name|FIO_compressFilename_srcFile
parameter_list|(
name|cRess_t
name|ress
parameter_list|,
specifier|const
name|char
modifier|*
name|dstFileName
parameter_list|,
specifier|const
name|char
modifier|*
name|srcFileName
parameter_list|,
name|int
name|compressionLevel
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
comment|/* File check */
if|if
condition|(
name|UTIL_isDirectory
argument_list|(
name|srcFileName
argument_list|)
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"zstd: %s is a directory -- ignored \n"
argument_list|,
name|srcFileName
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|ress
operator|.
name|srcFile
operator|=
name|FIO_openSrcFile
argument_list|(
name|srcFileName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ress
operator|.
name|srcFile
condition|)
return|return
literal|1
return|;
comment|/* srcFile could not be opened */
name|result
operator|=
name|FIO_compressFilename_internal
argument_list|(
name|ress
argument_list|,
name|dstFileName
argument_list|,
name|srcFileName
argument_list|,
name|compressionLevel
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|ress
operator|.
name|srcFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_removeSrcFile
comment|/* --rm */
operator|&&
operator|!
name|result
operator|&&
name|strcmp
argument_list|(
name|srcFileName
argument_list|,
name|stdinmark
argument_list|)
condition|)
block|{
if|if
condition|(
name|remove
argument_list|(
name|srcFileName
argument_list|)
condition|)
name|EXM_THROW
argument_list|(
literal|1
argument_list|,
literal|"zstd: %s: %s"
argument_list|,
name|srcFileName
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/*! FIO_compressFilename_dstFile() :  *  @return : 0 : compression completed correctly,  *            1 : pb  */
specifier|static
name|int
name|FIO_compressFilename_dstFile
parameter_list|(
name|cRess_t
name|ress
parameter_list|,
specifier|const
name|char
modifier|*
name|dstFileName
parameter_list|,
specifier|const
name|char
modifier|*
name|srcFileName
parameter_list|,
name|int
name|compressionLevel
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
name|stat_t
name|statbuf
decl_stmt|;
name|int
name|stat_result
init|=
literal|0
decl_stmt|;
name|ress
operator|.
name|dstFile
operator|=
name|FIO_openDstFile
argument_list|(
name|dstFileName
argument_list|)
expr_stmt|;
if|if
condition|(
name|ress
operator|.
name|dstFile
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
comment|/* could not open dstFileName */
if|if
condition|(
name|strcmp
argument_list|(
name|srcFileName
argument_list|,
name|stdinmark
argument_list|)
operator|&&
name|UTIL_getFileStat
argument_list|(
name|srcFileName
argument_list|,
operator|&
name|statbuf
argument_list|)
condition|)
name|stat_result
operator|=
literal|1
expr_stmt|;
name|result
operator|=
name|FIO_compressFilename_srcFile
argument_list|(
name|ress
argument_list|,
name|dstFileName
argument_list|,
name|srcFileName
argument_list|,
name|compressionLevel
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|ress
operator|.
name|dstFile
argument_list|)
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"zstd: %s: %s \n"
argument_list|,
name|dstFileName
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
literal|1
expr_stmt|;
block|}
comment|/* error closing dstFile */
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|remove
argument_list|(
name|dstFileName
argument_list|)
condition|)
name|EXM_THROW
argument_list|(
literal|1
argument_list|,
literal|"zstd: %s: %s"
argument_list|,
name|dstFileName
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* remove operation artefact */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|dstFileName
argument_list|,
name|stdoutmark
argument_list|)
operator|&&
name|stat_result
condition|)
name|UTIL_setFileStat
argument_list|(
name|dstFileName
argument_list|,
operator|&
name|statbuf
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
name|int
name|FIO_compressFilename
parameter_list|(
specifier|const
name|char
modifier|*
name|dstFileName
parameter_list|,
specifier|const
name|char
modifier|*
name|srcFileName
parameter_list|,
specifier|const
name|char
modifier|*
name|dictFileName
parameter_list|,
name|int
name|compressionLevel
parameter_list|,
name|ZSTD_compressionParameters
modifier|*
name|comprParams
parameter_list|)
block|{
name|clock_t
specifier|const
name|start
init|=
name|clock
argument_list|()
decl_stmt|;
name|U64
specifier|const
name|srcSize
init|=
name|UTIL_getFileSize
argument_list|(
name|srcFileName
argument_list|)
decl_stmt|;
name|int
specifier|const
name|regFile
init|=
name|UTIL_isRegFile
argument_list|(
name|srcFileName
argument_list|)
decl_stmt|;
name|cRess_t
specifier|const
name|ress
init|=
name|FIO_createCResources
argument_list|(
name|dictFileName
argument_list|,
name|compressionLevel
argument_list|,
name|srcSize
argument_list|,
name|regFile
argument_list|,
name|comprParams
argument_list|)
decl_stmt|;
name|int
specifier|const
name|result
init|=
name|FIO_compressFilename_dstFile
argument_list|(
name|ress
argument_list|,
name|dstFileName
argument_list|,
name|srcFileName
argument_list|,
name|compressionLevel
argument_list|)
decl_stmt|;
name|double
specifier|const
name|seconds
init|=
call|(
name|double
call|)
argument_list|(
name|clock
argument_list|()
operator|-
name|start
argument_list|)
operator|/
name|CLOCKS_PER_SEC
decl_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|4
argument_list|,
literal|"Completed in %.2f sec \n"
argument_list|,
name|seconds
argument_list|)
expr_stmt|;
name|FIO_freeCResources
argument_list|(
name|ress
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
name|int
name|FIO_compressMultipleFilenames
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|inFileNamesTable
parameter_list|,
name|unsigned
name|nbFiles
parameter_list|,
specifier|const
name|char
modifier|*
name|suffix
parameter_list|,
specifier|const
name|char
modifier|*
name|dictFileName
parameter_list|,
name|int
name|compressionLevel
parameter_list|,
name|ZSTD_compressionParameters
modifier|*
name|comprParams
parameter_list|)
block|{
name|int
name|missed_files
init|=
literal|0
decl_stmt|;
name|size_t
name|dfnSize
init|=
name|FNSPACE
decl_stmt|;
name|char
modifier|*
name|dstFileName
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|FNSPACE
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|suffixSize
init|=
name|suffix
condition|?
name|strlen
argument_list|(
name|suffix
argument_list|)
else|:
literal|0
decl_stmt|;
name|U64
specifier|const
name|srcSize
init|=
operator|(
name|nbFiles
operator|!=
literal|1
operator|)
condition|?
literal|0
else|:
name|UTIL_getFileSize
argument_list|(
name|inFileNamesTable
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|int
specifier|const
name|regFile
init|=
operator|(
name|nbFiles
operator|!=
literal|1
operator|)
condition|?
literal|0
else|:
name|UTIL_isRegFile
argument_list|(
name|inFileNamesTable
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|cRess_t
name|ress
init|=
name|FIO_createCResources
argument_list|(
name|dictFileName
argument_list|,
name|compressionLevel
argument_list|,
name|srcSize
argument_list|,
name|regFile
argument_list|,
name|comprParams
argument_list|)
decl_stmt|;
comment|/* init */
if|if
condition|(
name|dstFileName
operator|==
name|NULL
condition|)
name|EXM_THROW
argument_list|(
literal|27
argument_list|,
literal|"FIO_compressMultipleFilenames : allocation error for dstFileName"
argument_list|)
expr_stmt|;
if|if
condition|(
name|suffix
operator|==
name|NULL
condition|)
name|EXM_THROW
argument_list|(
literal|28
argument_list|,
literal|"FIO_compressMultipleFilenames : dst unknown"
argument_list|)
expr_stmt|;
comment|/* should never happen */
comment|/* loop on each file */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|suffix
argument_list|,
name|stdoutmark
argument_list|)
condition|)
block|{
name|unsigned
name|u
decl_stmt|;
name|ress
operator|.
name|dstFile
operator|=
name|stdout
expr_stmt|;
name|SET_BINARY_MODE
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|nbFiles
condition|;
name|u
operator|++
control|)
name|missed_files
operator|+=
name|FIO_compressFilename_srcFile
argument_list|(
name|ress
argument_list|,
name|stdoutmark
argument_list|,
name|inFileNamesTable
index|[
name|u
index|]
argument_list|,
name|compressionLevel
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|ress
operator|.
name|dstFile
argument_list|)
condition|)
name|EXM_THROW
argument_list|(
literal|29
argument_list|,
literal|"Write error : cannot properly close stdout"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|u
decl_stmt|;
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|nbFiles
condition|;
name|u
operator|++
control|)
block|{
name|size_t
name|ifnSize
init|=
name|strlen
argument_list|(
name|inFileNamesTable
index|[
name|u
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|dfnSize
operator|<=
name|ifnSize
operator|+
name|suffixSize
operator|+
literal|1
condition|)
block|{
name|free
argument_list|(
name|dstFileName
argument_list|)
expr_stmt|;
name|dfnSize
operator|=
name|ifnSize
operator|+
literal|20
expr_stmt|;
name|dstFileName
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|dfnSize
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|dstFileName
argument_list|,
name|inFileNamesTable
index|[
name|u
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dstFileName
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
name|missed_files
operator|+=
name|FIO_compressFilename_dstFile
argument_list|(
name|ress
argument_list|,
name|dstFileName
argument_list|,
name|inFileNamesTable
index|[
name|u
index|]
argument_list|,
name|compressionLevel
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Close& Free */
name|FIO_freeCResources
argument_list|(
name|ress
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dstFileName
argument_list|)
expr_stmt|;
return|return
name|missed_files
return|;
block|}
endif|#
directive|endif
comment|/* #ifndef ZSTD_NOCOMPRESS */
ifndef|#
directive|ifndef
name|ZSTD_NODECOMPRESS
comment|/* ************************************************************************** *  Decompression ****************************************************************************/
typedef|typedef
struct|struct
block|{
name|void
modifier|*
name|srcBuffer
decl_stmt|;
name|size_t
name|srcBufferLoaded
decl_stmt|;
name|size_t
name|srcBufferSize
decl_stmt|;
name|void
modifier|*
name|dstBuffer
decl_stmt|;
name|size_t
name|dstBufferSize
decl_stmt|;
name|ZSTD_DStream
modifier|*
name|dctx
decl_stmt|;
name|FILE
modifier|*
name|dstFile
decl_stmt|;
block|}
name|dRess_t
typedef|;
specifier|static
name|dRess_t
name|FIO_createDResources
parameter_list|(
specifier|const
name|char
modifier|*
name|dictFileName
parameter_list|)
block|{
name|dRess_t
name|ress
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ress
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ress
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocation */
name|ress
operator|.
name|dctx
operator|=
name|ZSTD_createDStream
argument_list|()
expr_stmt|;
if|if
condition|(
name|ress
operator|.
name|dctx
operator|==
name|NULL
condition|)
name|EXM_THROW
argument_list|(
literal|60
argument_list|,
literal|"Can't create ZSTD_DStream"
argument_list|)
expr_stmt|;
name|ZSTD_setDStreamParameter
argument_list|(
name|ress
operator|.
name|dctx
argument_list|,
name|DStream_p_maxWindowSize
argument_list|,
name|g_memLimit
argument_list|)
expr_stmt|;
name|ress
operator|.
name|srcBufferSize
operator|=
name|ZSTD_DStreamInSize
argument_list|()
expr_stmt|;
name|ress
operator|.
name|srcBuffer
operator|=
name|malloc
argument_list|(
name|ress
operator|.
name|srcBufferSize
argument_list|)
expr_stmt|;
name|ress
operator|.
name|dstBufferSize
operator|=
name|ZSTD_DStreamOutSize
argument_list|()
expr_stmt|;
name|ress
operator|.
name|dstBuffer
operator|=
name|malloc
argument_list|(
name|ress
operator|.
name|dstBufferSize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ress
operator|.
name|srcBuffer
operator|||
operator|!
name|ress
operator|.
name|dstBuffer
condition|)
name|EXM_THROW
argument_list|(
literal|61
argument_list|,
literal|"Allocation error : not enough memory"
argument_list|)
expr_stmt|;
comment|/* dictionary */
block|{
name|void
modifier|*
name|dictBuffer
decl_stmt|;
name|size_t
specifier|const
name|dictBufferSize
init|=
name|FIO_createDictBuffer
argument_list|(
operator|&
name|dictBuffer
argument_list|,
name|dictFileName
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|initError
init|=
name|ZSTD_initDStream_usingDict
argument_list|(
name|ress
operator|.
name|dctx
argument_list|,
name|dictBuffer
argument_list|,
name|dictBufferSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|initError
argument_list|)
condition|)
name|EXM_THROW
argument_list|(
literal|61
argument_list|,
literal|"ZSTD_initDStream_usingDict error : %s"
argument_list|,
name|ZSTD_getErrorName
argument_list|(
name|initError
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dictBuffer
argument_list|)
expr_stmt|;
block|}
return|return
name|ress
return|;
block|}
specifier|static
name|void
name|FIO_freeDResources
parameter_list|(
name|dRess_t
name|ress
parameter_list|)
block|{
name|size_t
specifier|const
name|errorCode
init|=
name|ZSTD_freeDStream
argument_list|(
name|ress
operator|.
name|dctx
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
name|EXM_THROW
argument_list|(
literal|69
argument_list|,
literal|"Error : can't free ZSTD_DStream context resource : %s"
argument_list|,
name|ZSTD_getErrorName
argument_list|(
name|errorCode
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ress
operator|.
name|srcBuffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ress
operator|.
name|dstBuffer
argument_list|)
expr_stmt|;
block|}
comment|/** FIO_fwriteSparse() : *   @return : storedSkips, to be provided to next call to FIO_fwriteSparse() of LZ4IO_fwriteSparseEnd() */
specifier|static
name|unsigned
name|FIO_fwriteSparse
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
specifier|const
name|void
modifier|*
name|buffer
parameter_list|,
name|size_t
name|bufferSize
parameter_list|,
name|unsigned
name|storedSkips
parameter_list|)
block|{
specifier|const
name|size_t
modifier|*
specifier|const
name|bufferT
init|=
operator|(
specifier|const
name|size_t
operator|*
operator|)
name|buffer
decl_stmt|;
comment|/* Buffer is supposed malloc'ed, hence aligned on size_t */
name|size_t
name|bufferSizeT
init|=
name|bufferSize
operator|/
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
decl_stmt|;
specifier|const
name|size_t
modifier|*
specifier|const
name|bufferTEnd
init|=
name|bufferT
operator|+
name|bufferSizeT
decl_stmt|;
specifier|const
name|size_t
modifier|*
name|ptrT
init|=
name|bufferT
decl_stmt|;
specifier|static
specifier|const
name|size_t
name|segmentSizeT
init|=
operator|(
literal|32
name|KB
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
decl_stmt|;
comment|/* 0-test re-attempted every 32 KB */
if|if
condition|(
operator|!
name|g_sparseFileSupport
condition|)
block|{
comment|/* normal write */
name|size_t
specifier|const
name|sizeCheck
init|=
name|fwrite
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|bufferSize
argument_list|,
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
name|sizeCheck
operator|!=
name|bufferSize
condition|)
name|EXM_THROW
argument_list|(
literal|70
argument_list|,
literal|"Write error : cannot write decoded block"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* avoid int overflow */
if|if
condition|(
name|storedSkips
operator|>
literal|1
name|GB
condition|)
block|{
name|int
specifier|const
name|seekResult
init|=
name|LONG_SEEK
argument_list|(
name|file
argument_list|,
literal|1
name|GB
argument_list|,
name|SEEK_CUR
argument_list|)
decl_stmt|;
if|if
condition|(
name|seekResult
operator|!=
literal|0
condition|)
name|EXM_THROW
argument_list|(
literal|71
argument_list|,
literal|"1 GB skip error (sparse file support)"
argument_list|)
expr_stmt|;
name|storedSkips
operator|-=
literal|1
name|GB
expr_stmt|;
block|}
while|while
condition|(
name|ptrT
operator|<
name|bufferTEnd
condition|)
block|{
name|size_t
name|seg0SizeT
init|=
name|segmentSizeT
decl_stmt|;
name|size_t
name|nb0T
decl_stmt|;
comment|/* count leading zeros */
if|if
condition|(
name|seg0SizeT
operator|>
name|bufferSizeT
condition|)
name|seg0SizeT
operator|=
name|bufferSizeT
expr_stmt|;
name|bufferSizeT
operator|-=
name|seg0SizeT
expr_stmt|;
for|for
control|(
name|nb0T
operator|=
literal|0
init|;
operator|(
name|nb0T
operator|<
name|seg0SizeT
operator|)
operator|&&
operator|(
name|ptrT
index|[
name|nb0T
index|]
operator|==
literal|0
operator|)
condition|;
name|nb0T
operator|++
control|)
empty_stmt|;
name|storedSkips
operator|+=
call|(
name|unsigned
call|)
argument_list|(
name|nb0T
operator|*
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nb0T
operator|!=
name|seg0SizeT
condition|)
block|{
comment|/* not all 0s */
name|int
specifier|const
name|seekResult
init|=
name|LONG_SEEK
argument_list|(
name|file
argument_list|,
name|storedSkips
argument_list|,
name|SEEK_CUR
argument_list|)
decl_stmt|;
if|if
condition|(
name|seekResult
condition|)
name|EXM_THROW
argument_list|(
literal|72
argument_list|,
literal|"Sparse skip error ; try --no-sparse"
argument_list|)
expr_stmt|;
name|storedSkips
operator|=
literal|0
expr_stmt|;
name|seg0SizeT
operator|-=
name|nb0T
expr_stmt|;
name|ptrT
operator|+=
name|nb0T
expr_stmt|;
block|{
name|size_t
specifier|const
name|sizeCheck
init|=
name|fwrite
argument_list|(
name|ptrT
argument_list|,
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|,
name|seg0SizeT
argument_list|,
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
name|sizeCheck
operator|!=
name|seg0SizeT
condition|)
name|EXM_THROW
argument_list|(
literal|73
argument_list|,
literal|"Write error : cannot write decoded block"
argument_list|)
expr_stmt|;
block|}
block|}
name|ptrT
operator|+=
name|seg0SizeT
expr_stmt|;
block|}
block|{
specifier|static
name|size_t
specifier|const
name|maskT
init|=
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|bufferSize
operator|&
name|maskT
condition|)
block|{
comment|/* size not multiple of sizeof(size_t) : implies end of block */
specifier|const
name|char
modifier|*
specifier|const
name|restStart
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|bufferTEnd
decl_stmt|;
specifier|const
name|char
modifier|*
name|restPtr
init|=
name|restStart
decl_stmt|;
name|size_t
name|restSize
init|=
name|bufferSize
operator|&
name|maskT
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|restEnd
init|=
name|restStart
operator|+
name|restSize
decl_stmt|;
for|for
control|(
init|;
operator|(
name|restPtr
operator|<
name|restEnd
operator|)
operator|&&
operator|(
operator|*
name|restPtr
operator|==
literal|0
operator|)
condition|;
name|restPtr
operator|++
control|)
empty_stmt|;
name|storedSkips
operator|+=
call|(
name|unsigned
call|)
argument_list|(
name|restPtr
operator|-
name|restStart
argument_list|)
expr_stmt|;
if|if
condition|(
name|restPtr
operator|!=
name|restEnd
condition|)
block|{
name|int
name|seekResult
init|=
name|LONG_SEEK
argument_list|(
name|file
argument_list|,
name|storedSkips
argument_list|,
name|SEEK_CUR
argument_list|)
decl_stmt|;
if|if
condition|(
name|seekResult
condition|)
name|EXM_THROW
argument_list|(
literal|74
argument_list|,
literal|"Sparse skip error ; try --no-sparse"
argument_list|)
expr_stmt|;
name|storedSkips
operator|=
literal|0
expr_stmt|;
block|{
name|size_t
specifier|const
name|sizeCheck
init|=
name|fwrite
argument_list|(
name|restPtr
argument_list|,
literal|1
argument_list|,
name|restEnd
operator|-
name|restPtr
argument_list|,
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
name|sizeCheck
operator|!=
call|(
name|size_t
call|)
argument_list|(
name|restEnd
operator|-
name|restPtr
argument_list|)
condition|)
name|EXM_THROW
argument_list|(
literal|75
argument_list|,
literal|"Write error : cannot write decoded end of block"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|storedSkips
return|;
block|}
specifier|static
name|void
name|FIO_fwriteSparseEnd
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|unsigned
name|storedSkips
parameter_list|)
block|{
if|if
condition|(
name|storedSkips
operator|--
operator|>
literal|0
condition|)
block|{
comment|/* implies g_sparseFileSupport>0 */
name|int
specifier|const
name|seekResult
init|=
name|LONG_SEEK
argument_list|(
name|file
argument_list|,
name|storedSkips
argument_list|,
name|SEEK_CUR
argument_list|)
decl_stmt|;
if|if
condition|(
name|seekResult
operator|!=
literal|0
condition|)
name|EXM_THROW
argument_list|(
literal|69
argument_list|,
literal|"Final skip error (sparse file)"
argument_list|)
expr_stmt|;
block|{
specifier|const
name|char
name|lastZeroByte
index|[
literal|1
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|size_t
specifier|const
name|sizeCheck
init|=
name|fwrite
argument_list|(
name|lastZeroByte
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
name|sizeCheck
operator|!=
literal|1
condition|)
name|EXM_THROW
argument_list|(
literal|69
argument_list|,
literal|"Write error : cannot write last zero"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** FIO_passThrough() : just copy input into output, for compatibility with gzip -df mode     @return : 0 (no error) */
specifier|static
name|unsigned
name|FIO_passThrough
parameter_list|(
name|FILE
modifier|*
name|foutput
parameter_list|,
name|FILE
modifier|*
name|finput
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|,
name|size_t
name|bufferSize
parameter_list|,
name|size_t
name|alreadyLoaded
parameter_list|)
block|{
name|size_t
specifier|const
name|blockSize
init|=
name|MIN
argument_list|(
literal|64
name|KB
argument_list|,
name|bufferSize
argument_list|)
decl_stmt|;
name|size_t
name|readFromInput
init|=
literal|1
decl_stmt|;
name|unsigned
name|storedSkips
init|=
literal|0
decl_stmt|;
comment|/* assumption : ress->srcBufferLoaded bytes already loaded and stored within buffer */
block|{
name|size_t
specifier|const
name|sizeCheck
init|=
name|fwrite
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|alreadyLoaded
argument_list|,
name|foutput
argument_list|)
decl_stmt|;
if|if
condition|(
name|sizeCheck
operator|!=
name|alreadyLoaded
condition|)
name|EXM_THROW
argument_list|(
literal|50
argument_list|,
literal|"Pass-through write error"
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|readFromInput
condition|)
block|{
name|readFromInput
operator|=
name|fread
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|blockSize
argument_list|,
name|finput
argument_list|)
expr_stmt|;
name|storedSkips
operator|=
name|FIO_fwriteSparse
argument_list|(
name|foutput
argument_list|,
name|buffer
argument_list|,
name|readFromInput
argument_list|,
name|storedSkips
argument_list|)
expr_stmt|;
block|}
name|FIO_fwriteSparseEnd
argument_list|(
name|foutput
argument_list|,
name|storedSkips
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/** FIO_decompressFrame() :     @return : size of decoded frame */
name|unsigned
name|long
name|long
name|FIO_decompressFrame
parameter_list|(
name|dRess_t
modifier|*
name|ress
parameter_list|,
name|FILE
modifier|*
name|finput
parameter_list|,
name|U64
name|alreadyDecoded
parameter_list|)
block|{
name|U64
name|frameSize
init|=
literal|0
decl_stmt|;
name|U32
name|storedSkips
init|=
literal|0
decl_stmt|;
name|ZSTD_resetDStream
argument_list|(
name|ress
operator|->
name|dctx
argument_list|)
expr_stmt|;
comment|/* Header loading (optional, saves one loop) */
block|{
name|size_t
specifier|const
name|toRead
init|=
literal|9
decl_stmt|;
if|if
condition|(
name|ress
operator|->
name|srcBufferLoaded
operator|<
name|toRead
condition|)
name|ress
operator|->
name|srcBufferLoaded
operator|+=
name|fread
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|ress
operator|->
name|srcBuffer
operator|)
operator|+
name|ress
operator|->
name|srcBufferLoaded
argument_list|,
literal|1
argument_list|,
name|toRead
operator|-
name|ress
operator|->
name|srcBufferLoaded
argument_list|,
name|finput
argument_list|)
expr_stmt|;
block|}
comment|/* Main decompression Loop */
while|while
condition|(
literal|1
condition|)
block|{
name|ZSTD_inBuffer
name|inBuff
init|=
block|{
name|ress
operator|->
name|srcBuffer
block|,
name|ress
operator|->
name|srcBufferLoaded
block|,
literal|0
block|}
decl_stmt|;
name|ZSTD_outBuffer
name|outBuff
init|=
block|{
name|ress
operator|->
name|dstBuffer
block|,
name|ress
operator|->
name|dstBufferSize
block|,
literal|0
block|}
decl_stmt|;
name|size_t
specifier|const
name|readSizeHint
init|=
name|ZSTD_decompressStream
argument_list|(
name|ress
operator|->
name|dctx
argument_list|,
operator|&
name|outBuff
argument_list|,
operator|&
name|inBuff
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|readSizeHint
argument_list|)
condition|)
name|EXM_THROW
argument_list|(
literal|36
argument_list|,
literal|"Decoding error : %s"
argument_list|,
name|ZSTD_getErrorName
argument_list|(
name|readSizeHint
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write block */
name|storedSkips
operator|=
name|FIO_fwriteSparse
argument_list|(
name|ress
operator|->
name|dstFile
argument_list|,
name|ress
operator|->
name|dstBuffer
argument_list|,
name|outBuff
operator|.
name|pos
argument_list|,
name|storedSkips
argument_list|)
expr_stmt|;
name|frameSize
operator|+=
name|outBuff
operator|.
name|pos
expr_stmt|;
name|DISPLAYUPDATE
argument_list|(
literal|2
argument_list|,
literal|"\rDecoded : %u MB...     "
argument_list|,
call|(
name|U32
call|)
argument_list|(
operator|(
name|alreadyDecoded
operator|+
name|frameSize
operator|)
operator|>>
literal|20
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inBuff
operator|.
name|pos
operator|>
literal|0
condition|)
block|{
name|memmove
argument_list|(
name|ress
operator|->
name|srcBuffer
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ress
operator|->
name|srcBuffer
operator|+
name|inBuff
operator|.
name|pos
argument_list|,
name|inBuff
operator|.
name|size
operator|-
name|inBuff
operator|.
name|pos
argument_list|)
expr_stmt|;
name|ress
operator|->
name|srcBufferLoaded
operator|-=
name|inBuff
operator|.
name|pos
expr_stmt|;
block|}
if|if
condition|(
name|readSizeHint
operator|==
literal|0
condition|)
break|break;
comment|/* end of frame */
if|if
condition|(
name|inBuff
operator|.
name|size
operator|!=
name|inBuff
operator|.
name|pos
condition|)
name|EXM_THROW
argument_list|(
literal|37
argument_list|,
literal|"Decoding error : should consume entire input"
argument_list|)
expr_stmt|;
comment|/* Fill input buffer */
block|{
name|size_t
specifier|const
name|toRead
init|=
name|MIN
argument_list|(
name|readSizeHint
argument_list|,
name|ress
operator|->
name|srcBufferSize
argument_list|)
decl_stmt|;
comment|/* support large skippable frames */
if|if
condition|(
name|ress
operator|->
name|srcBufferLoaded
operator|<
name|toRead
condition|)
name|ress
operator|->
name|srcBufferLoaded
operator|+=
name|fread
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|ress
operator|->
name|srcBuffer
operator|)
operator|+
name|ress
operator|->
name|srcBufferLoaded
argument_list|,
literal|1
argument_list|,
name|toRead
operator|-
name|ress
operator|->
name|srcBufferLoaded
argument_list|,
name|finput
argument_list|)
expr_stmt|;
if|if
condition|(
name|ress
operator|->
name|srcBufferLoaded
operator|<
name|toRead
condition|)
name|EXM_THROW
argument_list|(
literal|39
argument_list|,
literal|"Read error : premature end"
argument_list|)
expr_stmt|;
block|}
block|}
name|FIO_fwriteSparseEnd
argument_list|(
name|ress
operator|->
name|dstFile
argument_list|,
name|storedSkips
argument_list|)
expr_stmt|;
return|return
name|frameSize
return|;
block|}
ifdef|#
directive|ifdef
name|ZSTD_GZDECOMPRESS
specifier|static
name|unsigned
name|long
name|long
name|FIO_decompressGzFrame
parameter_list|(
name|dRess_t
modifier|*
name|ress
parameter_list|,
name|FILE
modifier|*
name|srcFile
parameter_list|,
specifier|const
name|char
modifier|*
name|srcFileName
parameter_list|)
block|{
name|unsigned
name|long
name|long
name|outFileSize
init|=
literal|0
decl_stmt|;
name|z_stream
name|strm
decl_stmt|;
name|int
name|flush
init|=
name|Z_NO_FLUSH
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|strm
operator|.
name|zalloc
operator|=
name|Z_NULL
expr_stmt|;
name|strm
operator|.
name|zfree
operator|=
name|Z_NULL
expr_stmt|;
name|strm
operator|.
name|opaque
operator|=
name|Z_NULL
expr_stmt|;
name|strm
operator|.
name|next_in
operator|=
literal|0
expr_stmt|;
name|strm
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inflateInit2
argument_list|(
operator|&
name|strm
argument_list|,
literal|15
comment|/* maxWindowLogSize */
operator|+
literal|16
comment|/* gzip only */
argument_list|)
operator|!=
name|Z_OK
condition|)
return|return
literal|0
return|;
comment|/* see http://www.zlib.net/manual.html */
name|strm
operator|.
name|next_out
operator|=
operator|(
name|Bytef
operator|*
operator|)
name|ress
operator|->
name|dstBuffer
expr_stmt|;
name|strm
operator|.
name|avail_out
operator|=
operator|(
name|uInt
operator|)
name|ress
operator|->
name|dstBufferSize
expr_stmt|;
name|strm
operator|.
name|avail_in
operator|=
operator|(
name|uInt
operator|)
name|ress
operator|->
name|srcBufferLoaded
expr_stmt|;
name|strm
operator|.
name|next_in
operator|=
operator|(
name|z_const
name|unsigned
name|char
operator|*
operator|)
name|ress
operator|->
name|srcBuffer
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|strm
operator|.
name|avail_in
operator|==
literal|0
condition|)
block|{
name|ress
operator|->
name|srcBufferLoaded
operator|=
name|fread
argument_list|(
name|ress
operator|->
name|srcBuffer
argument_list|,
literal|1
argument_list|,
name|ress
operator|->
name|srcBufferSize
argument_list|,
name|srcFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|ress
operator|->
name|srcBufferLoaded
operator|==
literal|0
condition|)
name|flush
operator|=
name|Z_FINISH
expr_stmt|;
name|strm
operator|.
name|next_in
operator|=
operator|(
name|z_const
name|unsigned
name|char
operator|*
operator|)
name|ress
operator|->
name|srcBuffer
expr_stmt|;
name|strm
operator|.
name|avail_in
operator|=
operator|(
name|uInt
operator|)
name|ress
operator|->
name|srcBufferLoaded
expr_stmt|;
block|}
name|ret
operator|=
name|inflate
argument_list|(
operator|&
name|strm
argument_list|,
name|flush
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|Z_BUF_ERROR
condition|)
name|EXM_THROW
argument_list|(
literal|39
argument_list|,
literal|"zstd: %s: premature end"
argument_list|,
name|srcFileName
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_OK
operator|&&
name|ret
operator|!=
name|Z_STREAM_END
condition|)
block|{
name|DISPLAY
argument_list|(
literal|"zstd: %s: inflate error %d \n"
argument_list|,
name|srcFileName
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|{
name|size_t
specifier|const
name|decompBytes
init|=
name|ress
operator|->
name|dstBufferSize
operator|-
name|strm
operator|.
name|avail_out
decl_stmt|;
if|if
condition|(
name|decompBytes
condition|)
block|{
if|if
condition|(
name|fwrite
argument_list|(
name|ress
operator|->
name|dstBuffer
argument_list|,
literal|1
argument_list|,
name|decompBytes
argument_list|,
name|ress
operator|->
name|dstFile
argument_list|)
operator|!=
name|decompBytes
condition|)
name|EXM_THROW
argument_list|(
literal|31
argument_list|,
literal|"Write error : cannot write to output file"
argument_list|)
expr_stmt|;
name|outFileSize
operator|+=
name|decompBytes
expr_stmt|;
name|strm
operator|.
name|next_out
operator|=
operator|(
name|Bytef
operator|*
operator|)
name|ress
operator|->
name|dstBuffer
expr_stmt|;
name|strm
operator|.
name|avail_out
operator|=
operator|(
name|uInt
operator|)
name|ress
operator|->
name|dstBufferSize
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ret
operator|==
name|Z_STREAM_END
condition|)
break|break;
block|}
if|if
condition|(
name|strm
operator|.
name|avail_in
operator|>
literal|0
condition|)
name|memmove
argument_list|(
name|ress
operator|->
name|srcBuffer
argument_list|,
name|strm
operator|.
name|next_in
argument_list|,
name|strm
operator|.
name|avail_in
argument_list|)
expr_stmt|;
name|ress
operator|->
name|srcBufferLoaded
operator|=
name|strm
operator|.
name|avail_in
expr_stmt|;
name|ret
operator|=
name|inflateEnd
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
name|EXM_THROW
argument_list|(
literal|32
argument_list|,
literal|"zstd: %s: inflateEnd error %d"
argument_list|,
name|srcFileName
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|outFileSize
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ZSTD_LZMADECOMPRESS
specifier|static
name|unsigned
name|long
name|long
name|FIO_decompressLzmaFrame
parameter_list|(
name|dRess_t
modifier|*
name|ress
parameter_list|,
name|FILE
modifier|*
name|srcFile
parameter_list|,
specifier|const
name|char
modifier|*
name|srcFileName
parameter_list|,
name|int
name|plain_lzma
parameter_list|)
block|{
name|unsigned
name|long
name|long
name|outFileSize
init|=
literal|0
decl_stmt|;
name|lzma_stream
name|strm
init|=
name|LZMA_STREAM_INIT
decl_stmt|;
name|lzma_action
name|action
init|=
name|LZMA_RUN
decl_stmt|;
name|lzma_ret
name|ret
decl_stmt|;
name|strm
operator|.
name|next_in
operator|=
literal|0
expr_stmt|;
name|strm
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|plain_lzma
condition|)
block|{
name|ret
operator|=
name|lzma_alone_decoder
argument_list|(
operator|&
name|strm
argument_list|,
name|UINT64_MAX
argument_list|)
expr_stmt|;
comment|/* LZMA */
block|}
else|else
block|{
name|ret
operator|=
name|lzma_stream_decoder
argument_list|(
operator|&
name|strm
argument_list|,
name|UINT64_MAX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XZ */
block|}
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
condition|)
name|EXM_THROW
argument_list|(
literal|71
argument_list|,
literal|"zstd: %s: lzma_alone_decoder/lzma_stream_decoder error %d"
argument_list|,
name|srcFileName
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|strm
operator|.
name|next_out
operator|=
name|ress
operator|->
name|dstBuffer
expr_stmt|;
name|strm
operator|.
name|avail_out
operator|=
name|ress
operator|->
name|dstBufferSize
expr_stmt|;
name|strm
operator|.
name|avail_in
operator|=
name|ress
operator|->
name|srcBufferLoaded
expr_stmt|;
name|strm
operator|.
name|next_in
operator|=
name|ress
operator|->
name|srcBuffer
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|strm
operator|.
name|avail_in
operator|==
literal|0
condition|)
block|{
name|ress
operator|->
name|srcBufferLoaded
operator|=
name|fread
argument_list|(
name|ress
operator|->
name|srcBuffer
argument_list|,
literal|1
argument_list|,
name|ress
operator|->
name|srcBufferSize
argument_list|,
name|srcFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|ress
operator|->
name|srcBufferLoaded
operator|==
literal|0
condition|)
name|action
operator|=
name|LZMA_FINISH
expr_stmt|;
name|strm
operator|.
name|next_in
operator|=
name|ress
operator|->
name|srcBuffer
expr_stmt|;
name|strm
operator|.
name|avail_in
operator|=
name|ress
operator|->
name|srcBufferLoaded
expr_stmt|;
block|}
name|ret
operator|=
name|lzma_code
argument_list|(
operator|&
name|strm
argument_list|,
name|action
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|LZMA_BUF_ERROR
condition|)
name|EXM_THROW
argument_list|(
literal|39
argument_list|,
literal|"zstd: %s: premature end"
argument_list|,
name|srcFileName
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|LZMA_OK
operator|&&
name|ret
operator|!=
name|LZMA_STREAM_END
condition|)
block|{
name|DISPLAY
argument_list|(
literal|"zstd: %s: lzma_code decoding error %d \n"
argument_list|,
name|srcFileName
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|{
name|size_t
specifier|const
name|decompBytes
init|=
name|ress
operator|->
name|dstBufferSize
operator|-
name|strm
operator|.
name|avail_out
decl_stmt|;
if|if
condition|(
name|decompBytes
condition|)
block|{
if|if
condition|(
name|fwrite
argument_list|(
name|ress
operator|->
name|dstBuffer
argument_list|,
literal|1
argument_list|,
name|decompBytes
argument_list|,
name|ress
operator|->
name|dstFile
argument_list|)
operator|!=
name|decompBytes
condition|)
name|EXM_THROW
argument_list|(
literal|31
argument_list|,
literal|"Write error : cannot write to output file"
argument_list|)
expr_stmt|;
name|outFileSize
operator|+=
name|decompBytes
expr_stmt|;
name|strm
operator|.
name|next_out
operator|=
name|ress
operator|->
name|dstBuffer
expr_stmt|;
name|strm
operator|.
name|avail_out
operator|=
name|ress
operator|->
name|dstBufferSize
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ret
operator|==
name|LZMA_STREAM_END
condition|)
break|break;
block|}
if|if
condition|(
name|strm
operator|.
name|avail_in
operator|>
literal|0
condition|)
name|memmove
argument_list|(
name|ress
operator|->
name|srcBuffer
argument_list|,
name|strm
operator|.
name|next_in
argument_list|,
name|strm
operator|.
name|avail_in
argument_list|)
expr_stmt|;
name|ress
operator|->
name|srcBufferLoaded
operator|=
name|strm
operator|.
name|avail_in
expr_stmt|;
name|lzma_end
argument_list|(
operator|&
name|strm
argument_list|)
expr_stmt|;
return|return
name|outFileSize
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ZSTD_LZ4DECOMPRESS
specifier|static
name|unsigned
name|long
name|long
name|FIO_decompressLz4Frame
parameter_list|(
name|dRess_t
modifier|*
name|ress
parameter_list|,
name|FILE
modifier|*
name|srcFile
parameter_list|,
specifier|const
name|char
modifier|*
name|srcFileName
parameter_list|)
block|{
name|unsigned
name|long
name|long
name|filesize
init|=
literal|0
decl_stmt|;
name|LZ4F_errorCode_t
name|nextToLoad
decl_stmt|;
name|LZ4F_decompressionContext_t
name|dCtx
decl_stmt|;
name|LZ4F_errorCode_t
specifier|const
name|errorCode
init|=
name|LZ4F_createDecompressionContext
argument_list|(
operator|&
name|dCtx
argument_list|,
name|LZ4F_VERSION
argument_list|)
decl_stmt|;
if|if
condition|(
name|LZ4F_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
name|EXM_THROW
argument_list|(
literal|61
argument_list|,
literal|"zstd: failed to create lz4 decompression context"
argument_list|)
expr_stmt|;
comment|/* Init feed with magic number (already consumed from FILE* sFile) */
block|{
name|size_t
name|inSize
init|=
literal|4
decl_stmt|;
name|size_t
name|outSize
init|=
literal|0
decl_stmt|;
name|MEM_writeLE32
argument_list|(
name|ress
operator|->
name|srcBuffer
argument_list|,
name|LZ4_MAGICNUMBER
argument_list|)
expr_stmt|;
name|nextToLoad
operator|=
name|LZ4F_decompress
argument_list|(
name|dCtx
argument_list|,
name|ress
operator|->
name|dstBuffer
argument_list|,
operator|&
name|outSize
argument_list|,
name|ress
operator|->
name|srcBuffer
argument_list|,
operator|&
name|inSize
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|LZ4F_isError
argument_list|(
name|nextToLoad
argument_list|)
condition|)
name|EXM_THROW
argument_list|(
literal|62
argument_list|,
literal|"zstd: %s: lz4 header error : %s"
argument_list|,
name|srcFileName
argument_list|,
name|LZ4F_getErrorName
argument_list|(
name|nextToLoad
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Main Loop */
for|for
control|(
init|;
name|nextToLoad
condition|;
control|)
block|{
name|size_t
name|readSize
decl_stmt|;
name|size_t
name|pos
init|=
literal|0
decl_stmt|;
name|size_t
name|decodedBytes
init|=
name|ress
operator|->
name|dstBufferSize
decl_stmt|;
comment|/* Read input */
if|if
condition|(
name|nextToLoad
operator|>
name|ress
operator|->
name|srcBufferSize
condition|)
name|nextToLoad
operator|=
name|ress
operator|->
name|srcBufferSize
expr_stmt|;
name|readSize
operator|=
name|fread
argument_list|(
name|ress
operator|->
name|srcBuffer
argument_list|,
literal|1
argument_list|,
name|nextToLoad
argument_list|,
name|srcFile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|readSize
condition|)
break|break;
comment|/* reached end of file or stream */
while|while
condition|(
operator|(
name|pos
operator|<
name|readSize
operator|)
operator|||
operator|(
name|decodedBytes
operator|==
name|ress
operator|->
name|dstBufferSize
operator|)
condition|)
block|{
comment|/* still to read, or still to flush */
comment|/* Decode Input (at least partially) */
name|size_t
name|remaining
init|=
name|readSize
operator|-
name|pos
decl_stmt|;
name|decodedBytes
operator|=
name|ress
operator|->
name|dstBufferSize
expr_stmt|;
name|nextToLoad
operator|=
name|LZ4F_decompress
argument_list|(
name|dCtx
argument_list|,
name|ress
operator|->
name|dstBuffer
argument_list|,
operator|&
name|decodedBytes
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|ress
operator|->
name|srcBuffer
operator|)
operator|+
name|pos
argument_list|,
operator|&
name|remaining
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|LZ4F_isError
argument_list|(
name|nextToLoad
argument_list|)
condition|)
name|EXM_THROW
argument_list|(
literal|66
argument_list|,
literal|"zstd: %s: decompression error : %s"
argument_list|,
name|srcFileName
argument_list|,
name|LZ4F_getErrorName
argument_list|(
name|nextToLoad
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|remaining
expr_stmt|;
comment|/* Write Block */
if|if
condition|(
name|decodedBytes
condition|)
block|{
if|if
condition|(
name|fwrite
argument_list|(
name|ress
operator|->
name|dstBuffer
argument_list|,
literal|1
argument_list|,
name|decodedBytes
argument_list|,
name|ress
operator|->
name|dstFile
argument_list|)
operator|!=
name|decodedBytes
condition|)
name|EXM_THROW
argument_list|(
literal|63
argument_list|,
literal|"Write error : cannot write to output file"
argument_list|)
expr_stmt|;
name|filesize
operator|+=
name|decodedBytes
expr_stmt|;
name|DISPLAYUPDATE
argument_list|(
literal|2
argument_list|,
literal|"\rDecompressed : %u MB  "
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|filesize
operator|>>
literal|20
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nextToLoad
condition|)
break|break;
block|}
block|}
comment|/* can be out because readSize == 0, which could be an fread() error */
if|if
condition|(
name|ferror
argument_list|(
name|srcFile
argument_list|)
condition|)
name|EXM_THROW
argument_list|(
literal|67
argument_list|,
literal|"zstd: %s: read error"
argument_list|,
name|srcFileName
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextToLoad
operator|!=
literal|0
condition|)
name|EXM_THROW
argument_list|(
literal|68
argument_list|,
literal|"zstd: %s: unfinished stream"
argument_list|,
name|srcFileName
argument_list|)
expr_stmt|;
name|LZ4F_freeDecompressionContext
argument_list|(
name|dCtx
argument_list|)
expr_stmt|;
name|ress
operator|->
name|srcBufferLoaded
operator|=
literal|0
expr_stmt|;
comment|/* LZ4F will go to the frame boundary */
return|return
name|filesize
return|;
block|}
endif|#
directive|endif
comment|/** FIO_decompressSrcFile() :     Decompression `srcFileName` into `ress.dstFile`     @return : 0 : OK               1 : operation not started */
specifier|static
name|int
name|FIO_decompressSrcFile
parameter_list|(
name|dRess_t
name|ress
parameter_list|,
specifier|const
name|char
modifier|*
name|dstFileName
parameter_list|,
specifier|const
name|char
modifier|*
name|srcFileName
parameter_list|)
block|{
name|FILE
modifier|*
name|srcFile
decl_stmt|;
name|unsigned
name|readSomething
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|long
name|filesize
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|UTIL_isDirectory
argument_list|(
name|srcFileName
argument_list|)
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"zstd: %s is a directory -- ignored \n"
argument_list|,
name|srcFileName
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|srcFile
operator|=
name|FIO_openSrcFile
argument_list|(
name|srcFileName
argument_list|)
expr_stmt|;
if|if
condition|(
name|srcFile
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
comment|/* for each frame */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* check magic number -> version */
name|size_t
specifier|const
name|toRead
init|=
literal|4
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|buf
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|ress
operator|.
name|srcBuffer
decl_stmt|;
if|if
condition|(
name|ress
operator|.
name|srcBufferLoaded
operator|<
name|toRead
condition|)
name|ress
operator|.
name|srcBufferLoaded
operator|+=
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ress
operator|.
name|srcBuffer
operator|+
name|ress
operator|.
name|srcBufferLoaded
argument_list|,
operator|(
name|size_t
operator|)
literal|1
argument_list|,
name|toRead
operator|-
name|ress
operator|.
name|srcBufferLoaded
argument_list|,
name|srcFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|ress
operator|.
name|srcBufferLoaded
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|readSomething
operator|==
literal|0
condition|)
block|{
name|DISPLAY
argument_list|(
literal|"zstd: %s: unexpected end of file \n"
argument_list|,
name|srcFileName
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|srcFile
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* srcFileName is empty */
break|break;
comment|/* no more input */
block|}
name|readSomething
operator|=
literal|1
expr_stmt|;
comment|/* there is at least>= 4 bytes in srcFile */
if|if
condition|(
name|ress
operator|.
name|srcBufferLoaded
operator|<
name|toRead
condition|)
block|{
name|DISPLAY
argument_list|(
literal|"zstd: %s: unknown header \n"
argument_list|,
name|srcFileName
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|srcFile
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* srcFileName is empty */
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|31
operator|&&
name|buf
index|[
literal|1
index|]
operator|==
literal|139
condition|)
block|{
comment|/* gz magic number */
ifdef|#
directive|ifdef
name|ZSTD_GZDECOMPRESS
name|unsigned
name|long
name|long
specifier|const
name|result
init|=
name|FIO_decompressGzFrame
argument_list|(
operator|&
name|ress
argument_list|,
name|srcFile
argument_list|,
name|srcFileName
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|filesize
operator|+=
name|result
expr_stmt|;
else|#
directive|else
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"zstd: %s: gzip file cannot be uncompressed (zstd compiled without ZSTD_GZDECOMPRESS) -- ignored \n"
argument_list|,
name|srcFileName
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|(
name|buf
index|[
literal|0
index|]
operator|==
literal|0xFD
operator|&&
name|buf
index|[
literal|1
index|]
operator|==
literal|0x37
operator|)
comment|/* xz magic number */
operator|||
operator|(
name|buf
index|[
literal|0
index|]
operator|==
literal|0x5D
operator|&&
name|buf
index|[
literal|1
index|]
operator|==
literal|0x00
operator|)
condition|)
block|{
comment|/* lzma header (no magic number) */
ifdef|#
directive|ifdef
name|ZSTD_LZMADECOMPRESS
name|unsigned
name|long
name|long
specifier|const
name|result
init|=
name|FIO_decompressLzmaFrame
argument_list|(
operator|&
name|ress
argument_list|,
name|srcFile
argument_list|,
name|srcFileName
argument_list|,
name|buf
index|[
literal|0
index|]
operator|!=
literal|0xFD
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|filesize
operator|+=
name|result
expr_stmt|;
else|#
directive|else
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"zstd: %s: xz/lzma file cannot be uncompressed (zstd compiled without ZSTD_LZMADECOMPRESS) -- ignored \n"
argument_list|,
name|srcFileName
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|MEM_readLE32
argument_list|(
name|buf
argument_list|)
operator|==
name|LZ4_MAGICNUMBER
condition|)
block|{
ifdef|#
directive|ifdef
name|ZSTD_LZ4DECOMPRESS
name|unsigned
name|long
name|long
specifier|const
name|result
init|=
name|FIO_decompressLz4Frame
argument_list|(
operator|&
name|ress
argument_list|,
name|srcFile
argument_list|,
name|srcFileName
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|filesize
operator|+=
name|result
expr_stmt|;
else|#
directive|else
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"zstd: %s: lz4 file cannot be uncompressed (zstd compiled without ZSTD_LZ4DECOMPRESS) -- ignored \n"
argument_list|,
name|srcFileName
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ZSTD_isFrame
argument_list|(
name|ress
operator|.
name|srcBuffer
argument_list|,
name|toRead
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|g_overwrite
operator|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|dstFileName
argument_list|,
name|stdoutmark
argument_list|)
condition|)
block|{
comment|/* pass-through mode */
name|unsigned
specifier|const
name|result
init|=
name|FIO_passThrough
argument_list|(
name|ress
operator|.
name|dstFile
argument_list|,
name|srcFile
argument_list|,
name|ress
operator|.
name|srcBuffer
argument_list|,
name|ress
operator|.
name|srcBufferSize
argument_list|,
name|ress
operator|.
name|srcBufferLoaded
argument_list|)
decl_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|srcFile
argument_list|)
condition|)
name|EXM_THROW
argument_list|(
literal|32
argument_list|,
literal|"zstd: %s close error"
argument_list|,
name|srcFileName
argument_list|)
expr_stmt|;
comment|/* error should never happen */
return|return
name|result
return|;
block|}
else|else
block|{
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"zstd: %s: not in zstd format \n"
argument_list|,
name|srcFileName
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|srcFile
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|filesize
operator|+=
name|FIO_decompressFrame
argument_list|(
operator|&
name|ress
argument_list|,
name|srcFile
argument_list|,
name|filesize
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Final Status */
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"\r%79s\r"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"%-20s: %llu bytes \n"
argument_list|,
name|srcFileName
argument_list|,
name|filesize
argument_list|)
expr_stmt|;
comment|/* Close file */
if|if
condition|(
name|fclose
argument_list|(
name|srcFile
argument_list|)
condition|)
name|EXM_THROW
argument_list|(
literal|33
argument_list|,
literal|"zstd: %s close error"
argument_list|,
name|srcFileName
argument_list|)
expr_stmt|;
comment|/* error should never happen */
if|if
condition|(
name|g_removeSrcFile
comment|/* --rm */
operator|&&
name|strcmp
argument_list|(
name|srcFileName
argument_list|,
name|stdinmark
argument_list|)
condition|)
block|{
if|if
condition|(
name|remove
argument_list|(
name|srcFileName
argument_list|)
condition|)
name|EXM_THROW
argument_list|(
literal|34
argument_list|,
literal|"zstd: %s: %s"
argument_list|,
name|srcFileName
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
return|return
literal|0
return|;
block|}
comment|/** FIO_decompressFile_extRess() :     decompress `srcFileName` into `dstFileName`     @return : 0 : OK               1 : operation aborted (src not available, dst already taken, etc.) */
specifier|static
name|int
name|FIO_decompressDstFile
parameter_list|(
name|dRess_t
name|ress
parameter_list|,
specifier|const
name|char
modifier|*
name|dstFileName
parameter_list|,
specifier|const
name|char
modifier|*
name|srcFileName
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
name|stat_t
name|statbuf
decl_stmt|;
name|int
name|stat_result
init|=
literal|0
decl_stmt|;
name|ress
operator|.
name|dstFile
operator|=
name|FIO_openDstFile
argument_list|(
name|dstFileName
argument_list|)
expr_stmt|;
if|if
condition|(
name|ress
operator|.
name|dstFile
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|srcFileName
argument_list|,
name|stdinmark
argument_list|)
operator|&&
name|UTIL_getFileStat
argument_list|(
name|srcFileName
argument_list|,
operator|&
name|statbuf
argument_list|)
condition|)
name|stat_result
operator|=
literal|1
expr_stmt|;
name|result
operator|=
name|FIO_decompressSrcFile
argument_list|(
name|ress
argument_list|,
name|dstFileName
argument_list|,
name|srcFileName
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|ress
operator|.
name|dstFile
argument_list|)
condition|)
name|EXM_THROW
argument_list|(
literal|38
argument_list|,
literal|"Write error : cannot properly close %s"
argument_list|,
name|dstFileName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|result
operator|!=
literal|0
operator|)
operator|&&
name|strcmp
argument_list|(
name|dstFileName
argument_list|,
name|nulmark
argument_list|)
comment|/* special case : don't remove() /dev/null (#316) */
operator|&&
name|remove
argument_list|(
name|dstFileName
argument_list|)
condition|)
name|result
operator|=
literal|1
expr_stmt|;
comment|/* don't do anything special if remove() fails */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|dstFileName
argument_list|,
name|stdoutmark
argument_list|)
operator|&&
name|stat_result
condition|)
name|UTIL_setFileStat
argument_list|(
name|dstFileName
argument_list|,
operator|&
name|statbuf
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
name|int
name|FIO_decompressFilename
parameter_list|(
specifier|const
name|char
modifier|*
name|dstFileName
parameter_list|,
specifier|const
name|char
modifier|*
name|srcFileName
parameter_list|,
specifier|const
name|char
modifier|*
name|dictFileName
parameter_list|)
block|{
name|int
name|missingFiles
init|=
literal|0
decl_stmt|;
name|dRess_t
name|ress
init|=
name|FIO_createDResources
argument_list|(
name|dictFileName
argument_list|)
decl_stmt|;
name|missingFiles
operator|+=
name|FIO_decompressDstFile
argument_list|(
name|ress
argument_list|,
name|dstFileName
argument_list|,
name|srcFileName
argument_list|)
expr_stmt|;
name|FIO_freeDResources
argument_list|(
name|ress
argument_list|)
expr_stmt|;
return|return
name|missingFiles
return|;
block|}
define|#
directive|define
name|MAXSUFFIXSIZE
value|8
name|int
name|FIO_decompressMultipleFilenames
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|srcNamesTable
parameter_list|,
name|unsigned
name|nbFiles
parameter_list|,
specifier|const
name|char
modifier|*
name|suffix
parameter_list|,
specifier|const
name|char
modifier|*
name|dictFileName
parameter_list|)
block|{
name|int
name|skippedFiles
init|=
literal|0
decl_stmt|;
name|int
name|missingFiles
init|=
literal|0
decl_stmt|;
name|dRess_t
name|ress
init|=
name|FIO_createDResources
argument_list|(
name|dictFileName
argument_list|)
decl_stmt|;
if|if
condition|(
name|suffix
operator|==
name|NULL
condition|)
name|EXM_THROW
argument_list|(
literal|70
argument_list|,
literal|"zstd: decompression: unknown dst"
argument_list|)
expr_stmt|;
comment|/* should never happen */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|suffix
argument_list|,
name|stdoutmark
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|suffix
argument_list|,
name|nulmark
argument_list|)
condition|)
block|{
comment|/* special cases : -c or -t */
name|unsigned
name|u
decl_stmt|;
name|ress
operator|.
name|dstFile
operator|=
name|FIO_openDstFile
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|ress
operator|.
name|dstFile
operator|==
literal|0
condition|)
name|EXM_THROW
argument_list|(
literal|71
argument_list|,
literal|"cannot open %s"
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|nbFiles
condition|;
name|u
operator|++
control|)
name|missingFiles
operator|+=
name|FIO_decompressSrcFile
argument_list|(
name|ress
argument_list|,
name|suffix
argument_list|,
name|srcNamesTable
index|[
name|u
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|ress
operator|.
name|dstFile
argument_list|)
condition|)
name|EXM_THROW
argument_list|(
literal|72
argument_list|,
literal|"Write error : cannot properly close stdout"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|suffixSize
decl_stmt|;
name|size_t
name|dfnSize
init|=
name|FNSPACE
decl_stmt|;
name|unsigned
name|u
decl_stmt|;
name|char
modifier|*
name|dstFileName
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|FNSPACE
argument_list|)
decl_stmt|;
if|if
condition|(
name|dstFileName
operator|==
name|NULL
condition|)
name|EXM_THROW
argument_list|(
literal|73
argument_list|,
literal|"not enough memory for dstFileName"
argument_list|)
expr_stmt|;
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|nbFiles
condition|;
name|u
operator|++
control|)
block|{
comment|/* create dstFileName */
specifier|const
name|char
modifier|*
specifier|const
name|srcFileName
init|=
name|srcNamesTable
index|[
name|u
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|suffixPtr
init|=
name|strrchr
argument_list|(
name|srcFileName
argument_list|,
literal|'.'
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|sfnSize
init|=
name|strlen
argument_list|(
name|srcFileName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|suffixPtr
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"zstd: %s: unknown suffix -- ignored \n"
argument_list|,
name|srcFileName
argument_list|)
expr_stmt|;
name|skippedFiles
operator|++
expr_stmt|;
continue|continue;
block|}
name|suffixSize
operator|=
name|strlen
argument_list|(
name|suffixPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dfnSize
operator|+
name|suffixSize
operator|<=
name|sfnSize
operator|+
literal|1
condition|)
block|{
name|free
argument_list|(
name|dstFileName
argument_list|)
expr_stmt|;
name|dfnSize
operator|=
name|sfnSize
operator|+
literal|20
expr_stmt|;
name|dstFileName
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|dfnSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|dstFileName
operator|==
name|NULL
condition|)
name|EXM_THROW
argument_list|(
literal|74
argument_list|,
literal|"not enough memory for dstFileName"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sfnSize
operator|<=
name|suffixSize
operator|||
operator|(
name|strcmp
argument_list|(
name|suffixPtr
argument_list|,
name|GZ_EXTENSION
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|suffixPtr
argument_list|,
name|XZ_EXTENSION
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|suffixPtr
argument_list|,
name|ZSTD_EXTENSION
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|suffixPtr
argument_list|,
name|LZMA_EXTENSION
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|suffixPtr
argument_list|,
name|LZ4_EXTENSION
argument_list|)
operator|)
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"zstd: %s: unknown suffix (%s/%s/%s/%s expected) -- ignored \n"
argument_list|,
name|srcFileName
argument_list|,
name|GZ_EXTENSION
argument_list|,
name|XZ_EXTENSION
argument_list|,
name|ZSTD_EXTENSION
argument_list|,
name|LZMA_EXTENSION
argument_list|)
expr_stmt|;
name|skippedFiles
operator|++
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|dstFileName
argument_list|,
name|srcFileName
argument_list|,
name|sfnSize
operator|-
name|suffixSize
argument_list|)
expr_stmt|;
name|dstFileName
index|[
name|sfnSize
operator|-
name|suffixSize
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|missingFiles
operator|+=
name|FIO_decompressDstFile
argument_list|(
name|ress
argument_list|,
name|dstFileName
argument_list|,
name|srcFileName
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|dstFileName
argument_list|)
expr_stmt|;
block|}
name|FIO_freeDResources
argument_list|(
name|ress
argument_list|)
expr_stmt|;
return|return
name|missingFiles
operator|+
name|skippedFiles
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* #ifndef ZSTD_NODECOMPRESS */
end_comment

end_unit

