begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright (c) 2016-present, Yann Collet, Facebook, Inc.  * All rights reserved.  *  * This source code is licensed under the BSD-style license found in the  * LICENSE file in the root directory of this source tree. An additional grant  * of patent rights can be found in the PATENTS file in the same directory.  */
end_comment

begin_comment
comment|/* ************************************** *  Compiler Warnings ****************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4127
name|)
end_pragma

begin_comment
comment|/* disable: C4127: conditional expression is constant */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*-************************************* *  Includes ***************************************/
end_comment

begin_include
include|#
directive|include
file|"platform.h"
end_include

begin_comment
comment|/* Large Files support */
end_comment

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_comment
comment|/* UTIL_getFileSize, UTIL_getTotalFileSize */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* malloc, free */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* memset */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* fprintf, fopen, ftello64 */
end_comment

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_comment
comment|/* clock_t, clock, CLOCKS_PER_SEC */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* errno */
end_comment

begin_include
include|#
directive|include
file|"mem.h"
end_include

begin_comment
comment|/* read */
end_comment

begin_include
include|#
directive|include
file|"error_private.h"
end_include

begin_include
include|#
directive|include
file|"dibio.h"
end_include

begin_comment
comment|/*-************************************* *  Constants ***************************************/
end_comment

begin_define
define|#
directive|define
name|KB
value|*(1<<10)
end_define

begin_define
define|#
directive|define
name|MB
value|*(1<<20)
end_define

begin_define
define|#
directive|define
name|GB
value|*(1U<<30)
end_define

begin_define
define|#
directive|define
name|SAMPLESIZE_MAX
value|(128 KB)
end_define

begin_define
define|#
directive|define
name|MEMMULT
value|11
end_define

begin_comment
comment|/* rough estimation : memory cost to analyze 1 byte of sample */
end_comment

begin_define
define|#
directive|define
name|COVER_MEMMULT
value|9
end_define

begin_comment
comment|/* rough estimation : memory cost to analyze 1 byte of sample */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|size_t
name|maxMemory
init|=
operator|(
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|==
literal|4
operator|)
condition|?
operator|(
literal|2
name|GB
operator|-
literal|64
name|MB
operator|)
else|:
operator|(
call|(
name|size_t
call|)
argument_list|(
literal|512
name|MB
argument_list|)
operator|<<
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NOISELENGTH
value|32
end_define

begin_comment
comment|/*-************************************* *  Console display ***************************************/
end_comment

begin_define
define|#
directive|define
name|DISPLAY
parameter_list|(
modifier|...
parameter_list|)
value|fprintf(stderr, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|DISPLAYLEVEL
parameter_list|(
name|l
parameter_list|,
modifier|...
parameter_list|)
value|if (g_displayLevel>=l) { DISPLAY(__VA_ARGS__); }
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|g_displayLevel
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 : no display;   1: errors;   2: default;  4: full information */
end_comment

begin_define
define|#
directive|define
name|DISPLAYUPDATE
parameter_list|(
name|l
parameter_list|,
modifier|...
parameter_list|)
value|if (g_displayLevel>=l) { \             if ((DIB_clockSpan(g_time)> refreshRate) || (g_displayLevel>=4)) \             { g_time = clock(); DISPLAY(__VA_ARGS__); \             if (g_displayLevel>=4) fflush(stdout); } }
end_define

begin_decl_stmt
specifier|static
specifier|const
name|clock_t
name|refreshRate
init|=
name|CLOCKS_PER_SEC
operator|*
literal|2
operator|/
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|clock_t
name|g_time
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|clock_t
name|DIB_clockSpan
parameter_list|(
name|clock_t
name|nPrevious
parameter_list|)
block|{
return|return
name|clock
argument_list|()
operator|-
name|nPrevious
return|;
block|}
end_function

begin_comment
comment|/*-************************************* *  Exceptions ***************************************/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG
end_ifndef

begin_define
define|#
directive|define
name|DEBUG
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DEBUGOUTPUT
parameter_list|(
modifier|...
parameter_list|)
value|if (DEBUG) DISPLAY(__VA_ARGS__);
end_define

begin_define
define|#
directive|define
name|EXM_THROW
parameter_list|(
name|error
parameter_list|,
modifier|...
parameter_list|)
define|\
value|{                                                                         \     DEBUGOUTPUT("Error defined at %s, line %i : \n", __FILE__, __LINE__); \     DISPLAYLEVEL(1, "Error %i : ", error);                                \     DISPLAYLEVEL(1, __VA_ARGS__);                                         \     DISPLAYLEVEL(1, "\n");                                                \     exit(error);                                                          \ }
end_define

begin_comment
comment|/* ******************************************************** *  Helper functions **********************************************************/
end_comment

begin_function
name|unsigned
name|DiB_isError
parameter_list|(
name|size_t
name|errorCode
parameter_list|)
block|{
return|return
name|ERR_isError
argument_list|(
name|errorCode
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|DiB_getErrorName
parameter_list|(
name|size_t
name|errorCode
parameter_list|)
block|{
return|return
name|ERR_getErrorName
argument_list|(
name|errorCode
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|( (a)< (b) ? (a) : (b) )
end_define

begin_comment
comment|/* ******************************************************** *  File related operations **********************************************************/
end_comment

begin_comment
comment|/** DiB_loadFiles() : *   @return : nb of files effectively loaded into `buffer` */
end_comment

begin_function
specifier|static
name|unsigned
name|DiB_loadFiles
parameter_list|(
name|void
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|bufferSizePtr
parameter_list|,
name|size_t
modifier|*
name|fileSizes
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|fileNamesTable
parameter_list|,
name|unsigned
name|nbFiles
parameter_list|)
block|{
name|char
modifier|*
specifier|const
name|buff
init|=
operator|(
name|char
operator|*
operator|)
name|buffer
decl_stmt|;
name|size_t
name|pos
init|=
literal|0
decl_stmt|;
name|unsigned
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nbFiles
condition|;
name|n
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
specifier|const
name|fileName
init|=
name|fileNamesTable
index|[
name|n
index|]
decl_stmt|;
name|unsigned
name|long
name|long
specifier|const
name|fs64
init|=
name|UTIL_getFileSize
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|fileSize
init|=
operator|(
name|size_t
operator|)
name|MIN
argument_list|(
name|fs64
argument_list|,
name|SAMPLESIZE_MAX
argument_list|)
decl_stmt|;
if|if
condition|(
name|fileSize
operator|>
operator|*
name|bufferSizePtr
operator|-
name|pos
condition|)
break|break;
block|{
name|FILE
modifier|*
specifier|const
name|f
init|=
name|fopen
argument_list|(
name|fileName
argument_list|,
literal|"rb"
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
name|EXM_THROW
argument_list|(
literal|10
argument_list|,
literal|"zstd: dictBuilder: %s %s "
argument_list|,
name|fileName
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|DISPLAYUPDATE
argument_list|(
literal|2
argument_list|,
literal|"Loading %s...       \r"
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
block|{
name|size_t
specifier|const
name|readSize
init|=
name|fread
argument_list|(
name|buff
operator|+
name|pos
argument_list|,
literal|1
argument_list|,
name|fileSize
argument_list|,
name|f
argument_list|)
decl_stmt|;
if|if
condition|(
name|readSize
operator|!=
name|fileSize
condition|)
name|EXM_THROW
argument_list|(
literal|11
argument_list|,
literal|"Pb reading %s"
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|readSize
expr_stmt|;
block|}
name|fileSizes
index|[
name|n
index|]
operator|=
name|fileSize
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"\r%79s\r"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
operator|*
name|bufferSizePtr
operator|=
name|pos
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_define
define|#
directive|define
name|DiB_rotl32
parameter_list|(
name|x
parameter_list|,
name|r
parameter_list|)
value|((x<< r) | (x>> (32 - r)))
end_define

begin_function
specifier|static
name|U32
name|DiB_rand
parameter_list|(
name|U32
modifier|*
name|src
parameter_list|)
block|{
specifier|static
specifier|const
name|U32
name|prime1
init|=
literal|2654435761U
decl_stmt|;
specifier|static
specifier|const
name|U32
name|prime2
init|=
literal|2246822519U
decl_stmt|;
name|U32
name|rand32
init|=
operator|*
name|src
decl_stmt|;
name|rand32
operator|*=
name|prime1
expr_stmt|;
name|rand32
operator|^=
name|prime2
expr_stmt|;
name|rand32
operator|=
name|DiB_rotl32
argument_list|(
name|rand32
argument_list|,
literal|13
argument_list|)
expr_stmt|;
operator|*
name|src
operator|=
name|rand32
expr_stmt|;
return|return
name|rand32
operator|>>
literal|5
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|DiB_shuffle
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|fileNamesTable
parameter_list|,
name|unsigned
name|nbFiles
parameter_list|)
block|{
comment|/* Initialize the pseudorandom number generator */
name|U32
name|seed
init|=
literal|0xFD2FB528
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|nbFiles
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|unsigned
specifier|const
name|j
init|=
name|DiB_rand
argument_list|(
operator|&
name|seed
argument_list|)
operator|%
operator|(
name|i
operator|+
literal|1
operator|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmp
init|=
name|fileNamesTable
index|[
name|j
index|]
decl_stmt|;
name|fileNamesTable
index|[
name|j
index|]
operator|=
name|fileNamesTable
index|[
name|i
index|]
expr_stmt|;
name|fileNamesTable
index|[
name|i
index|]
operator|=
name|tmp
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-******************************************************** *  Dictionary training functions **********************************************************/
end_comment

begin_function
specifier|static
name|size_t
name|DiB_findMaxMem
parameter_list|(
name|unsigned
name|long
name|long
name|requiredMem
parameter_list|)
block|{
name|size_t
specifier|const
name|step
init|=
literal|8
name|MB
decl_stmt|;
name|void
modifier|*
name|testmem
init|=
name|NULL
decl_stmt|;
name|requiredMem
operator|=
operator|(
operator|(
operator|(
name|requiredMem
operator|>>
literal|23
operator|)
operator|+
literal|1
operator|)
operator|<<
literal|23
operator|)
expr_stmt|;
name|requiredMem
operator|+=
name|step
expr_stmt|;
if|if
condition|(
name|requiredMem
operator|>
name|maxMemory
condition|)
name|requiredMem
operator|=
name|maxMemory
expr_stmt|;
while|while
condition|(
operator|!
name|testmem
condition|)
block|{
name|testmem
operator|=
name|malloc
argument_list|(
operator|(
name|size_t
operator|)
name|requiredMem
argument_list|)
expr_stmt|;
name|requiredMem
operator|-=
name|step
expr_stmt|;
block|}
name|free
argument_list|(
name|testmem
argument_list|)
expr_stmt|;
return|return
operator|(
name|size_t
operator|)
name|requiredMem
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|DiB_fillNoise
parameter_list|(
name|void
modifier|*
name|buffer
parameter_list|,
name|size_t
name|length
parameter_list|)
block|{
name|unsigned
specifier|const
name|prime1
init|=
literal|2654435761U
decl_stmt|;
name|unsigned
specifier|const
name|prime2
init|=
literal|2246822519U
decl_stmt|;
name|unsigned
name|acc
init|=
name|prime1
decl_stmt|;
name|size_t
name|p
init|=
literal|0
decl_stmt|;
empty_stmt|;
for|for
control|(
name|p
operator|=
literal|0
init|;
name|p
operator|<
name|length
condition|;
name|p
operator|++
control|)
block|{
name|acc
operator|*=
name|prime2
expr_stmt|;
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buffer
operator|)
index|[
name|p
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|acc
operator|>>
literal|21
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|DiB_saveDict
parameter_list|(
specifier|const
name|char
modifier|*
name|dictFileName
parameter_list|,
specifier|const
name|void
modifier|*
name|buff
parameter_list|,
name|size_t
name|buffSize
parameter_list|)
block|{
name|FILE
modifier|*
specifier|const
name|f
init|=
name|fopen
argument_list|(
name|dictFileName
argument_list|,
literal|"wb"
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
name|EXM_THROW
argument_list|(
literal|3
argument_list|,
literal|"cannot open %s "
argument_list|,
name|dictFileName
argument_list|)
expr_stmt|;
block|{
name|size_t
specifier|const
name|n
init|=
name|fwrite
argument_list|(
name|buff
argument_list|,
literal|1
argument_list|,
name|buffSize
argument_list|,
name|f
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|!=
name|buffSize
condition|)
name|EXM_THROW
argument_list|(
literal|4
argument_list|,
literal|"%s : write error"
argument_list|,
argument|dictFileName
argument_list|)
block|}
block|{
name|size_t
specifier|const
name|n
init|=
operator|(
name|size_t
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
name|EXM_THROW
argument_list|(
literal|5
argument_list|,
literal|"%s : flush error"
argument_list|,
argument|dictFileName
argument_list|)
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|g_tooLargeSamples
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|U64
name|DiB_getTotalCappedFileSize
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|fileNamesTable
parameter_list|,
name|unsigned
name|nbFiles
parameter_list|)
block|{
name|U64
name|total
init|=
literal|0
decl_stmt|;
name|unsigned
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nbFiles
condition|;
name|n
operator|++
control|)
block|{
name|U64
specifier|const
name|fileSize
init|=
name|UTIL_getFileSize
argument_list|(
name|fileNamesTable
index|[
name|n
index|]
argument_list|)
decl_stmt|;
name|U64
specifier|const
name|cappedFileSize
init|=
name|MIN
argument_list|(
name|fileSize
argument_list|,
name|SAMPLESIZE_MAX
argument_list|)
decl_stmt|;
name|total
operator|+=
name|cappedFileSize
expr_stmt|;
name|g_tooLargeSamples
operator||=
operator|(
name|fileSize
operator|>
literal|2
operator|*
name|SAMPLESIZE_MAX
operator|)
expr_stmt|;
block|}
return|return
name|total
return|;
block|}
end_function

begin_comment
comment|/*! ZDICT_trainFromBuffer_unsafe() :     Strictly Internal use only !!     Same as ZDICT_trainFromBuffer_advanced(), but does not control `samplesBuffer`.     `samplesBuffer` must be followed by noisy guard band to avoid out-of-buffer reads.     @return : size of dictionary stored into `dictBuffer` (<= `dictBufferCapacity`)               or an error code. */
end_comment

begin_function_decl
name|size_t
name|ZDICT_trainFromBuffer_unsafe
parameter_list|(
name|void
modifier|*
name|dictBuffer
parameter_list|,
name|size_t
name|dictBufferCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|samplesBuffer
parameter_list|,
specifier|const
name|size_t
modifier|*
name|samplesSizes
parameter_list|,
name|unsigned
name|nbSamples
parameter_list|,
name|ZDICT_params_t
name|parameters
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|DiB_trainFromFiles
parameter_list|(
specifier|const
name|char
modifier|*
name|dictFileName
parameter_list|,
name|unsigned
name|maxDictSize
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|fileNamesTable
parameter_list|,
name|unsigned
name|nbFiles
parameter_list|,
name|ZDICT_params_t
modifier|*
name|params
parameter_list|,
name|COVER_params_t
modifier|*
name|coverParams
parameter_list|,
name|int
name|optimizeCover
parameter_list|)
block|{
name|void
modifier|*
specifier|const
name|dictBuffer
init|=
name|malloc
argument_list|(
name|maxDictSize
argument_list|)
decl_stmt|;
name|size_t
modifier|*
specifier|const
name|fileSizes
init|=
operator|(
name|size_t
operator|*
operator|)
name|malloc
argument_list|(
name|nbFiles
operator|*
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|long
specifier|const
name|totalSizeToLoad
init|=
name|DiB_getTotalCappedFileSize
argument_list|(
name|fileNamesTable
argument_list|,
name|nbFiles
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|memMult
init|=
name|params
condition|?
name|MEMMULT
else|:
name|COVER_MEMMULT
decl_stmt|;
name|size_t
specifier|const
name|maxMem
init|=
name|DiB_findMaxMem
argument_list|(
name|totalSizeToLoad
operator|*
name|memMult
argument_list|)
operator|/
name|memMult
decl_stmt|;
name|size_t
name|benchedSize
init|=
operator|(
name|size_t
operator|)
name|MIN
argument_list|(
operator|(
name|unsigned
name|long
name|long
operator|)
name|maxMem
argument_list|,
name|totalSizeToLoad
argument_list|)
decl_stmt|;
name|void
modifier|*
specifier|const
name|srcBuffer
init|=
name|malloc
argument_list|(
name|benchedSize
operator|+
name|NOISELENGTH
argument_list|)
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
comment|/* Checks */
if|if
condition|(
name|params
condition|)
name|g_displayLevel
operator|=
name|params
operator|->
name|notificationLevel
expr_stmt|;
elseif|else
if|if
condition|(
name|coverParams
condition|)
name|g_displayLevel
operator|=
name|coverParams
operator|->
name|notificationLevel
expr_stmt|;
else|else
name|EXM_THROW
argument_list|(
literal|13
argument_list|,
literal|"Neither dictionary algorith selected"
argument_list|)
expr_stmt|;
comment|/* should not happen */
if|if
condition|(
operator|(
operator|!
name|fileSizes
operator|)
operator|||
operator|(
operator|!
name|srcBuffer
operator|)
operator|||
operator|(
operator|!
name|dictBuffer
operator|)
condition|)
name|EXM_THROW
argument_list|(
literal|12
argument_list|,
literal|"not enough memory for DiB_trainFiles"
argument_list|)
expr_stmt|;
comment|/* should not happen */
if|if
condition|(
name|g_tooLargeSamples
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"!  Warning : some samples are very large \n"
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"!  Note that dictionary is only useful for small files or beginning of large files. \n"
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"!  As a consequence, only the first %u bytes of each file are loaded \n"
argument_list|,
name|SAMPLESIZE_MAX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|nbFiles
operator|<
literal|5
operator|)
operator|||
operator|(
name|totalSizeToLoad
operator|<
literal|9
operator|*
operator|(
name|unsigned
name|long
name|long
operator|)
name|maxDictSize
operator|)
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"!  Warning : nb of samples too low for proper processing ! \n"
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"!  Please provide _one file per sample_. \n"
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"!  Do not concatenate samples together into a single file, \n"
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"!  as dictBuilder will be unable to find the beginning of each sample, \n"
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"!  resulting in poor dictionary quality. \n"
argument_list|)
expr_stmt|;
block|}
comment|/* init */
if|if
condition|(
name|benchedSize
operator|<
name|totalSizeToLoad
condition|)
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"Not enough memory; training on %u MB only...\n"
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|benchedSize
operator|>>
literal|20
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Load input buffer */
name|DISPLAYLEVEL
argument_list|(
literal|3
argument_list|,
literal|"Shuffling input files\n"
argument_list|)
expr_stmt|;
name|DiB_shuffle
argument_list|(
name|fileNamesTable
argument_list|,
name|nbFiles
argument_list|)
expr_stmt|;
name|nbFiles
operator|=
name|DiB_loadFiles
argument_list|(
name|srcBuffer
argument_list|,
operator|&
name|benchedSize
argument_list|,
name|fileSizes
argument_list|,
name|fileNamesTable
argument_list|,
name|nbFiles
argument_list|)
expr_stmt|;
block|{
name|size_t
name|dictSize
decl_stmt|;
if|if
condition|(
name|params
condition|)
block|{
name|DiB_fillNoise
argument_list|(
operator|(
name|char
operator|*
operator|)
name|srcBuffer
operator|+
name|benchedSize
argument_list|,
name|NOISELENGTH
argument_list|)
expr_stmt|;
comment|/* guard band, for end of buffer condition */
name|dictSize
operator|=
name|ZDICT_trainFromBuffer_unsafe
argument_list|(
name|dictBuffer
argument_list|,
name|maxDictSize
argument_list|,
name|srcBuffer
argument_list|,
name|fileSizes
argument_list|,
name|nbFiles
argument_list|,
operator|*
name|params
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|optimizeCover
condition|)
block|{
name|dictSize
operator|=
name|COVER_optimizeTrainFromBuffer
argument_list|(
name|dictBuffer
argument_list|,
name|maxDictSize
argument_list|,
name|srcBuffer
argument_list|,
name|fileSizes
argument_list|,
name|nbFiles
argument_list|,
name|coverParams
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ZDICT_isError
argument_list|(
name|dictSize
argument_list|)
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"k=%u\nd=%u\nsteps=%u\n"
argument_list|,
name|coverParams
operator|->
name|k
argument_list|,
name|coverParams
operator|->
name|d
argument_list|,
name|coverParams
operator|->
name|steps
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|dictSize
operator|=
name|COVER_trainFromBuffer
argument_list|(
name|dictBuffer
argument_list|,
name|maxDictSize
argument_list|,
name|srcBuffer
argument_list|,
name|fileSizes
argument_list|,
name|nbFiles
argument_list|,
operator|*
name|coverParams
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ZDICT_isError
argument_list|(
name|dictSize
argument_list|)
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"dictionary training failed : %s \n"
argument_list|,
name|ZDICT_getErrorName
argument_list|(
name|dictSize
argument_list|)
argument_list|)
expr_stmt|;
comment|/* should not happen */
name|result
operator|=
literal|1
expr_stmt|;
goto|goto
name|_cleanup
goto|;
block|}
comment|/* save dict */
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"Save dictionary of size %u into file %s \n"
argument_list|,
operator|(
name|U32
operator|)
name|dictSize
argument_list|,
name|dictFileName
argument_list|)
expr_stmt|;
name|DiB_saveDict
argument_list|(
name|dictFileName
argument_list|,
name|dictBuffer
argument_list|,
name|dictSize
argument_list|)
expr_stmt|;
block|}
comment|/* clean up */
name|_cleanup
label|:
name|free
argument_list|(
name|srcBuffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dictBuffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fileSizes
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

end_unit

