begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright (c) 2016-present, Yann Collet, Facebook, Inc.  * All rights reserved.  *  * This source code is licensed under the BSD-style license found in the  * LICENSE file in the root directory of this source tree. An additional grant  * of patent rights can be found in the PATENTS file in the same directory.  */
end_comment

begin_comment
comment|/*-************************************ *  Tuning parameters **************************************/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ZSTDCLI_CLEVEL_DEFAULT
end_ifndef

begin_define
define|#
directive|define
name|ZSTDCLI_CLEVEL_DEFAULT
value|3
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ZSTDCLI_CLEVEL_MAX
end_ifndef

begin_define
define|#
directive|define
name|ZSTDCLI_CLEVEL_MAX
value|19
end_define

begin_comment
comment|/* when not using --ultra */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*-************************************ *  Dependencies **************************************/
end_comment

begin_include
include|#
directive|include
file|"platform.h"
end_include

begin_comment
comment|/* IS_CONSOLE, PLATFORM_POSIX_VERSION */
end_comment

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_comment
comment|/* UTIL_HAS_CREATEFILELIST, UTIL_createFileList */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* strcmp, strlen */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* errno */
end_comment

begin_include
include|#
directive|include
file|"fileio.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|ZSTD_NOBENCH
end_ifndef

begin_include
include|#
directive|include
file|"bench.h"
end_include

begin_comment
comment|/* BMK_benchFiles, BMK_SetNbSeconds */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ZSTD_NODICT
end_ifndef

begin_include
include|#
directive|include
file|"dibio.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ZSTD_STATIC_LINKING_ONLY
end_define

begin_comment
comment|/* ZSTD_maxCLevel */
end_comment

begin_include
include|#
directive|include
file|"zstd.h"
end_include

begin_comment
comment|/* ZSTD_VERSION_STRING */
end_comment

begin_comment
comment|/*-************************************ *  Constants **************************************/
end_comment

begin_define
define|#
directive|define
name|COMPRESSOR_NAME
value|"zstd command line interface"
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|ZSTD_VERSION
end_ifndef

begin_define
define|#
directive|define
name|ZSTD_VERSION
value|"v" ZSTD_VERSION_STRING
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|AUTHOR
value|"Yann Collet"
end_define

begin_define
define|#
directive|define
name|WELCOME_MESSAGE
value|"*** %s %i-bits %s, by %s ***\n", COMPRESSOR_NAME, (int)(sizeof(size_t)*8), ZSTD_VERSION, AUTHOR
end_define

begin_define
define|#
directive|define
name|ZSTD_UNZSTD
value|"unzstd"
end_define

begin_define
define|#
directive|define
name|ZSTD_CAT
value|"zstdcat"
end_define

begin_define
define|#
directive|define
name|ZSTD_GZ
value|"gzip"
end_define

begin_define
define|#
directive|define
name|ZSTD_GUNZIP
value|"gunzip"
end_define

begin_define
define|#
directive|define
name|ZSTD_GZCAT
value|"gzcat"
end_define

begin_define
define|#
directive|define
name|ZSTD_LZMA
value|"lzma"
end_define

begin_define
define|#
directive|define
name|ZSTD_XZ
value|"xz"
end_define

begin_define
define|#
directive|define
name|KB
value|*(1<<10)
end_define

begin_define
define|#
directive|define
name|MB
value|*(1<<20)
end_define

begin_define
define|#
directive|define
name|GB
value|*(1U<<30)
end_define

begin_define
define|#
directive|define
name|DEFAULT_DISPLAY_LEVEL
value|1
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|g_defaultDictName
init|=
literal|"dictionary"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|g_defaultMaxDictSize
init|=
literal|110
name|KB
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|g_defaultDictCLevel
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|g_defaultSelectivityLevel
init|=
literal|9
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|OVERLAP_LOG_DEFAULT
value|9999
end_define

begin_decl_stmt
specifier|static
name|U32
name|g_overlapLog
init|=
name|OVERLAP_LOG_DEFAULT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*-************************************ *  Display Macros **************************************/
end_comment

begin_define
define|#
directive|define
name|DISPLAY
parameter_list|(
modifier|...
parameter_list|)
value|fprintf(displayOut, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|DISPLAYLEVEL
parameter_list|(
name|l
parameter_list|,
modifier|...
parameter_list|)
value|if (displayLevel>=l) { DISPLAY(__VA_ARGS__); }
end_define

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|displayOut
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|displayLevel
init|=
name|DEFAULT_DISPLAY_LEVEL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 : no display,  1: errors,  2 : + result + interaction + warnings,  3 : + progression,  4 : + information */
end_comment

begin_comment
comment|/*-************************************ *  Command Line **************************************/
end_comment

begin_function
specifier|static
name|int
name|usage
parameter_list|(
specifier|const
name|char
modifier|*
name|programName
parameter_list|)
block|{
name|DISPLAY
argument_list|(
literal|"Usage :\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"      %s [args] [FILE(s)] [-o file]\n"
argument_list|,
name|programName
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"FILE    : a filename\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"          with no FILE, or when FILE is - , read standard input\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"Arguments :\n"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ZSTD_NOCOMPRESS
name|DISPLAY
argument_list|(
literal|" -#     : # compression level (1-%d, default:%d) \n"
argument_list|,
name|ZSTDCLI_CLEVEL_MAX
argument_list|,
name|ZSTDCLI_CLEVEL_DEFAULT
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|ZSTD_NODECOMPRESS
name|DISPLAY
argument_list|(
literal|" -d     : decompression \n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DISPLAY
argument_list|(
literal|" -D file: use `file` as Dictionary \n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -o file: result stored into `file` (only if 1 input file) \n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -f     : overwrite output without prompting \n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"--rm    : remove source file(s) after successful de/compression \n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -k     : preserve source file(s) (default) \n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -h/-H  : display help/long help and exit\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|usage_advanced
parameter_list|(
specifier|const
name|char
modifier|*
name|programName
parameter_list|)
block|{
name|DISPLAY
argument_list|(
name|WELCOME_MESSAGE
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|programName
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"Advanced arguments :\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -V     : display Version number and exit\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -v     : verbose mode; specify multiple times to increase log level (default:%d)\n"
argument_list|,
name|DEFAULT_DISPLAY_LEVEL
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -q     : suppress warnings; specify twice to suppress errors too\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -c     : force write to standard output, even if it is the console\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UTIL_HAS_CREATEFILELIST
name|DISPLAY
argument_list|(
literal|" -r     : operate recursively on directories \n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|ZSTD_NOCOMPRESS
name|DISPLAY
argument_list|(
literal|"--ultra : enable levels beyond %i, up to %i (requires more memory)\n"
argument_list|,
name|ZSTDCLI_CLEVEL_MAX
argument_list|,
name|ZSTD_maxCLevel
argument_list|()
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"--no-dictID : don't write dictID into header (dictionary compression)\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"--[no-]check : integrity check (default:enabled) \n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ZSTD_MULTITHREAD
name|DISPLAY
argument_list|(
literal|" -T#    : use # threads for compression (default:1) \n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -B#    : select size of independent sections (default:0==automatic) \n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ZSTD_GZCOMPRESS
name|DISPLAY
argument_list|(
literal|"--format=gzip : compress files to the .gz format \n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ZSTD_LZMACOMPRESS
name|DISPLAY
argument_list|(
literal|"--format=xz : compress files to the .xz format \n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"--format=lzma : compress files to the .lzma format \n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifndef|#
directive|ifndef
name|ZSTD_NODECOMPRESS
name|DISPLAY
argument_list|(
literal|"--test  : test compressed file integrity \n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"--[no-]sparse : sparse mode (default:enabled on file, disabled on stdout)\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DISPLAY
argument_list|(
literal|" -M#    : Set a memory usage limit for decompression \n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"--      : All arguments after \"--\" are treated as files \n"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ZSTD_NODICT
name|DISPLAY
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"Dictionary builder :\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"--train ## : create a dictionary from a training set of files \n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"--cover=k=#,d=# : use the cover algorithm with parameters k and d \n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"--optimize-cover[=steps=#,k=#,d=#] : optimize cover parameters with optional parameters\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -o file : `file` is dictionary name (default: %s) \n"
argument_list|,
name|g_defaultDictName
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"--maxdict ## : limit dictionary to specified size (default : %u) \n"
argument_list|,
name|g_defaultMaxDictSize
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -s#    : dictionary selectivity level (default: %u)\n"
argument_list|,
name|g_defaultSelectivityLevel
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"--dictID ## : force dictionary ID to specified value (default: random)\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|ZSTD_NOBENCH
name|DISPLAY
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"Benchmark arguments :\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -b#    : benchmark file(s), using # compression level (default : 1) \n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -e#    : test all compression levels from -bX to # (default: 1)\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -i#    : minimum evaluation time in seconds (default : 3s)\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|" -B#    : cut file into independent blocks of size # (default: no block)\n"
argument_list|)
expr_stmt|;
name|DISPLAY
argument_list|(
literal|"--priority=rt : set process priority to real-time\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|badusage
parameter_list|(
specifier|const
name|char
modifier|*
name|programName
parameter_list|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"Incorrect parameters\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|displayLevel
operator|>=
literal|1
condition|)
name|usage
argument_list|(
name|programName
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|waitEnter
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|unused
decl_stmt|;
name|DISPLAY
argument_list|(
literal|"Press enter to continue...\n"
argument_list|)
expr_stmt|;
name|unused
operator|=
name|getchar
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|unused
expr_stmt|;
block|}
end_function

begin_comment
comment|/*! readU32FromChar() :     @return : unsigned integer value read from input in `char` format     allows and interprets K, KB, KiB, M, MB and MiB suffix.     Will also modify `*stringPtr`, advancing it to position where it stopped reading.     Note : function result can overflow if digit string> MAX_UINT */
end_comment

begin_function
specifier|static
name|unsigned
name|readU32FromChar
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|stringPtr
parameter_list|)
block|{
name|unsigned
name|result
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
operator|*
operator|*
name|stringPtr
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
operator|*
name|stringPtr
operator|<=
literal|'9'
operator|)
condition|)
name|result
operator|*=
literal|10
operator|,
name|result
operator|+=
operator|*
operator|*
name|stringPtr
operator|-
literal|'0'
operator|,
operator|(
operator|*
name|stringPtr
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|*
operator|*
name|stringPtr
operator|==
literal|'K'
operator|)
operator|||
operator|(
operator|*
operator|*
name|stringPtr
operator|==
literal|'M'
operator|)
condition|)
block|{
name|result
operator|<<=
literal|10
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|stringPtr
operator|==
literal|'M'
condition|)
name|result
operator|<<=
literal|10
expr_stmt|;
operator|(
operator|*
name|stringPtr
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|stringPtr
operator|==
literal|'i'
condition|)
operator|(
operator|*
name|stringPtr
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|stringPtr
operator|==
literal|'B'
condition|)
operator|(
operator|*
name|stringPtr
operator|)
operator|++
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/** longCommandWArg() :  *  check if *stringPtr is the same as longCommand.  *  If yes, @return 1 and advances *stringPtr to the position which immediately follows longCommand.  *  @return 0 and doesn't modify *stringPtr otherwise.  */
end_comment

begin_function
specifier|static
name|unsigned
name|longCommandWArg
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|stringPtr
parameter_list|,
specifier|const
name|char
modifier|*
name|longCommand
parameter_list|)
block|{
name|size_t
specifier|const
name|comSize
init|=
name|strlen
argument_list|(
name|longCommand
argument_list|)
decl_stmt|;
name|int
specifier|const
name|result
init|=
operator|!
name|strncmp
argument_list|(
operator|*
name|stringPtr
argument_list|,
name|longCommand
argument_list|,
name|comSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
condition|)
operator|*
name|stringPtr
operator|+=
name|comSize
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|ZSTD_NODICT
end_ifndef

begin_comment
comment|/**  * parseCoverParameters() :  * reads cover parameters from *stringPtr (e.g. "--cover=smoothing=100,kmin=48,kstep=4,kmax=64,d=8") into *params  * @return 1 means that cover parameters were correct  * @return 0 in case of malformed parameters  */
end_comment

begin_function
specifier|static
name|unsigned
name|parseCoverParameters
parameter_list|(
specifier|const
name|char
modifier|*
name|stringPtr
parameter_list|,
name|COVER_params_t
modifier|*
name|params
parameter_list|)
block|{
name|memset
argument_list|(
name|params
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|params
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|longCommandWArg
argument_list|(
operator|&
name|stringPtr
argument_list|,
literal|"k="
argument_list|)
condition|)
block|{
name|params
operator|->
name|k
operator|=
name|readU32FromChar
argument_list|(
operator|&
name|stringPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|stringPtr
index|[
literal|0
index|]
operator|==
literal|','
condition|)
block|{
name|stringPtr
operator|++
expr_stmt|;
continue|continue;
block|}
else|else
break|break;
block|}
if|if
condition|(
name|longCommandWArg
argument_list|(
operator|&
name|stringPtr
argument_list|,
literal|"d="
argument_list|)
condition|)
block|{
name|params
operator|->
name|d
operator|=
name|readU32FromChar
argument_list|(
operator|&
name|stringPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|stringPtr
index|[
literal|0
index|]
operator|==
literal|','
condition|)
block|{
name|stringPtr
operator|++
expr_stmt|;
continue|continue;
block|}
else|else
break|break;
block|}
if|if
condition|(
name|longCommandWArg
argument_list|(
operator|&
name|stringPtr
argument_list|,
literal|"steps="
argument_list|)
condition|)
block|{
name|params
operator|->
name|steps
operator|=
name|readU32FromChar
argument_list|(
operator|&
name|stringPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|stringPtr
index|[
literal|0
index|]
operator|==
literal|','
condition|)
block|{
name|stringPtr
operator|++
expr_stmt|;
continue|continue;
block|}
else|else
break|break;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|stringPtr
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|DISPLAYLEVEL
argument_list|(
literal|4
argument_list|,
literal|"k=%u\nd=%u\nsteps=%u\n"
argument_list|,
name|params
operator|->
name|k
argument_list|,
name|params
operator|->
name|d
argument_list|,
name|params
operator|->
name|steps
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/** parseCompressionParameters() :  *  reads compression parameters from *stringPtr (e.g. "--zstd=wlog=23,clog=23,hlog=22,slog=6,slen=3,tlen=48,strat=6") into *params  *  @return 1 means that compression parameters were correct  *  @return 0 in case of malformed parameters  */
end_comment

begin_function
specifier|static
name|unsigned
name|parseCompressionParameters
parameter_list|(
specifier|const
name|char
modifier|*
name|stringPtr
parameter_list|,
name|ZSTD_compressionParameters
modifier|*
name|params
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|longCommandWArg
argument_list|(
operator|&
name|stringPtr
argument_list|,
literal|"windowLog="
argument_list|)
operator|||
name|longCommandWArg
argument_list|(
operator|&
name|stringPtr
argument_list|,
literal|"wlog="
argument_list|)
condition|)
block|{
name|params
operator|->
name|windowLog
operator|=
name|readU32FromChar
argument_list|(
operator|&
name|stringPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|stringPtr
index|[
literal|0
index|]
operator|==
literal|','
condition|)
block|{
name|stringPtr
operator|++
expr_stmt|;
continue|continue;
block|}
else|else
break|break;
block|}
if|if
condition|(
name|longCommandWArg
argument_list|(
operator|&
name|stringPtr
argument_list|,
literal|"chainLog="
argument_list|)
operator|||
name|longCommandWArg
argument_list|(
operator|&
name|stringPtr
argument_list|,
literal|"clog="
argument_list|)
condition|)
block|{
name|params
operator|->
name|chainLog
operator|=
name|readU32FromChar
argument_list|(
operator|&
name|stringPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|stringPtr
index|[
literal|0
index|]
operator|==
literal|','
condition|)
block|{
name|stringPtr
operator|++
expr_stmt|;
continue|continue;
block|}
else|else
break|break;
block|}
if|if
condition|(
name|longCommandWArg
argument_list|(
operator|&
name|stringPtr
argument_list|,
literal|"hashLog="
argument_list|)
operator|||
name|longCommandWArg
argument_list|(
operator|&
name|stringPtr
argument_list|,
literal|"hlog="
argument_list|)
condition|)
block|{
name|params
operator|->
name|hashLog
operator|=
name|readU32FromChar
argument_list|(
operator|&
name|stringPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|stringPtr
index|[
literal|0
index|]
operator|==
literal|','
condition|)
block|{
name|stringPtr
operator|++
expr_stmt|;
continue|continue;
block|}
else|else
break|break;
block|}
if|if
condition|(
name|longCommandWArg
argument_list|(
operator|&
name|stringPtr
argument_list|,
literal|"searchLog="
argument_list|)
operator|||
name|longCommandWArg
argument_list|(
operator|&
name|stringPtr
argument_list|,
literal|"slog="
argument_list|)
condition|)
block|{
name|params
operator|->
name|searchLog
operator|=
name|readU32FromChar
argument_list|(
operator|&
name|stringPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|stringPtr
index|[
literal|0
index|]
operator|==
literal|','
condition|)
block|{
name|stringPtr
operator|++
expr_stmt|;
continue|continue;
block|}
else|else
break|break;
block|}
if|if
condition|(
name|longCommandWArg
argument_list|(
operator|&
name|stringPtr
argument_list|,
literal|"searchLength="
argument_list|)
operator|||
name|longCommandWArg
argument_list|(
operator|&
name|stringPtr
argument_list|,
literal|"slen="
argument_list|)
condition|)
block|{
name|params
operator|->
name|searchLength
operator|=
name|readU32FromChar
argument_list|(
operator|&
name|stringPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|stringPtr
index|[
literal|0
index|]
operator|==
literal|','
condition|)
block|{
name|stringPtr
operator|++
expr_stmt|;
continue|continue;
block|}
else|else
break|break;
block|}
if|if
condition|(
name|longCommandWArg
argument_list|(
operator|&
name|stringPtr
argument_list|,
literal|"targetLength="
argument_list|)
operator|||
name|longCommandWArg
argument_list|(
operator|&
name|stringPtr
argument_list|,
literal|"tlen="
argument_list|)
condition|)
block|{
name|params
operator|->
name|targetLength
operator|=
name|readU32FromChar
argument_list|(
operator|&
name|stringPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|stringPtr
index|[
literal|0
index|]
operator|==
literal|','
condition|)
block|{
name|stringPtr
operator|++
expr_stmt|;
continue|continue;
block|}
else|else
break|break;
block|}
if|if
condition|(
name|longCommandWArg
argument_list|(
operator|&
name|stringPtr
argument_list|,
literal|"strategy="
argument_list|)
operator|||
name|longCommandWArg
argument_list|(
operator|&
name|stringPtr
argument_list|,
literal|"strat="
argument_list|)
condition|)
block|{
name|params
operator|->
name|strategy
operator|=
call|(
name|ZSTD_strategy
call|)
argument_list|(
literal|1
operator|+
name|readU32FromChar
argument_list|(
operator|&
name|stringPtr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stringPtr
index|[
literal|0
index|]
operator|==
literal|','
condition|)
block|{
name|stringPtr
operator|++
expr_stmt|;
continue|continue;
block|}
else|else
break|break;
block|}
if|if
condition|(
name|longCommandWArg
argument_list|(
operator|&
name|stringPtr
argument_list|,
literal|"overlapLog="
argument_list|)
operator|||
name|longCommandWArg
argument_list|(
operator|&
name|stringPtr
argument_list|,
literal|"ovlog="
argument_list|)
condition|)
block|{
name|g_overlapLog
operator|=
name|readU32FromChar
argument_list|(
operator|&
name|stringPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|stringPtr
index|[
literal|0
index|]
operator|==
literal|','
condition|)
block|{
name|stringPtr
operator|++
expr_stmt|;
continue|continue;
block|}
else|else
break|break;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|stringPtr
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* check the end of string */
name|DISPLAYLEVEL
argument_list|(
literal|4
argument_list|,
literal|"windowLog=%d\nchainLog=%d\nhashLog=%d\nsearchLog=%d\n"
argument_list|,
name|params
operator|->
name|windowLog
argument_list|,
name|params
operator|->
name|chainLog
argument_list|,
name|params
operator|->
name|hashLog
argument_list|,
name|params
operator|->
name|searchLog
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|4
argument_list|,
literal|"searchLength=%d\ntargetLength=%d\nstrategy=%d\n"
argument_list|,
name|params
operator|->
name|searchLength
argument_list|,
name|params
operator|->
name|targetLength
argument_list|,
name|params
operator|->
name|strategy
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_typedef
typedef|typedef
enum|enum
block|{
name|zom_compress
block|,
name|zom_decompress
block|,
name|zom_test
block|,
name|zom_bench
block|,
name|zom_train
block|}
name|zstd_operation_mode
typedef|;
end_typedef

begin_define
define|#
directive|define
name|CLEAN_RETURN
parameter_list|(
name|i
parameter_list|)
value|{ operationResult = (i); goto _end; }
end_define

begin_function
name|int
name|main
parameter_list|(
name|int
name|argCount
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|argNb
decl_stmt|,
name|forceStdout
init|=
literal|0
decl_stmt|,
name|main_pause
init|=
literal|0
decl_stmt|,
name|nextEntryIsDictionary
init|=
literal|0
decl_stmt|,
name|operationResult
init|=
literal|0
decl_stmt|,
name|nextArgumentIsOutFileName
init|=
literal|0
decl_stmt|,
name|nextArgumentIsMaxDict
init|=
literal|0
decl_stmt|,
name|nextArgumentIsDictID
init|=
literal|0
decl_stmt|,
name|nextArgumentsAreFiles
init|=
literal|0
decl_stmt|,
name|ultra
init|=
literal|0
decl_stmt|,
name|lastCommand
init|=
literal|0
decl_stmt|,
name|nbThreads
init|=
literal|1
decl_stmt|,
name|setRealTimePrio
init|=
literal|0
decl_stmt|;
name|unsigned
name|bench_nbSeconds
init|=
literal|3
decl_stmt|;
comment|/* would be better if this value was synchronized from bench */
name|size_t
name|blockSize
init|=
literal|0
decl_stmt|;
name|zstd_operation_mode
name|operation
init|=
name|zom_compress
decl_stmt|;
name|ZSTD_compressionParameters
name|compressionParams
decl_stmt|;
name|int
name|cLevel
init|=
name|ZSTDCLI_CLEVEL_DEFAULT
decl_stmt|;
name|int
name|cLevelLast
init|=
literal|1
decl_stmt|;
name|unsigned
name|recursive
init|=
literal|0
decl_stmt|;
name|unsigned
name|memLimit
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|filenameTable
init|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|argCount
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
comment|/* argCount>= 1 */
name|unsigned
name|filenameIdx
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|programName
init|=
name|argv
index|[
literal|0
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|outFileName
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|dictFileName
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|suffix
init|=
name|ZSTD_EXTENSION
decl_stmt|;
name|unsigned
name|maxDictSize
init|=
name|g_defaultMaxDictSize
decl_stmt|;
name|unsigned
name|dictID
init|=
literal|0
decl_stmt|;
name|int
name|dictCLevel
init|=
name|g_defaultDictCLevel
decl_stmt|;
name|unsigned
name|dictSelect
init|=
name|g_defaultSelectivityLevel
decl_stmt|;
ifdef|#
directive|ifdef
name|UTIL_HAS_CREATEFILELIST
specifier|const
name|char
modifier|*
modifier|*
name|extendedFileList
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|fileNamesBuf
init|=
name|NULL
decl_stmt|;
name|unsigned
name|fileNamesNb
decl_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|ZSTD_NODICT
name|COVER_params_t
name|coverParams
decl_stmt|;
name|int
name|cover
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* init */
operator|(
name|void
operator|)
name|recursive
expr_stmt|;
operator|(
name|void
operator|)
name|cLevelLast
expr_stmt|;
comment|/* not used when ZSTD_NOBENCH set */
operator|(
name|void
operator|)
name|dictCLevel
expr_stmt|;
operator|(
name|void
operator|)
name|dictSelect
expr_stmt|;
operator|(
name|void
operator|)
name|dictID
expr_stmt|;
operator|(
name|void
operator|)
name|maxDictSize
expr_stmt|;
comment|/* not used when ZSTD_NODICT set */
operator|(
name|void
operator|)
name|ultra
expr_stmt|;
operator|(
name|void
operator|)
name|cLevel
expr_stmt|;
comment|/* not used when ZSTD_NOCOMPRESS set */
operator|(
name|void
operator|)
name|memLimit
expr_stmt|;
comment|/* not used when ZSTD_NODECOMPRESS set */
if|if
condition|(
name|filenameTable
operator|==
name|NULL
condition|)
block|{
name|DISPLAY
argument_list|(
literal|"zstd: %s \n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|filenameTable
index|[
literal|0
index|]
operator|=
name|stdinmark
expr_stmt|;
name|displayOut
operator|=
name|stderr
expr_stmt|;
comment|/* Pick out program name from path. Don't rely on stdlib because of conflicting behavior */
block|{
name|size_t
name|pos
decl_stmt|;
for|for
control|(
name|pos
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|programName
argument_list|)
init|;
name|pos
operator|>
literal|0
condition|;
name|pos
operator|--
control|)
block|{
if|if
condition|(
name|programName
index|[
name|pos
index|]
operator|==
literal|'/'
condition|)
block|{
name|pos
operator|++
expr_stmt|;
break|break;
block|}
block|}
name|programName
operator|+=
name|pos
expr_stmt|;
block|}
comment|/* preset behaviors */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|programName
argument_list|,
name|ZSTD_UNZSTD
argument_list|)
condition|)
name|operation
operator|=
name|zom_decompress
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|programName
argument_list|,
name|ZSTD_CAT
argument_list|)
condition|)
block|{
name|operation
operator|=
name|zom_decompress
expr_stmt|;
name|forceStdout
operator|=
literal|1
expr_stmt|;
name|FIO_overwriteMode
argument_list|()
expr_stmt|;
name|outFileName
operator|=
name|stdoutmark
expr_stmt|;
name|displayLevel
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|programName
argument_list|,
name|ZSTD_GZ
argument_list|)
condition|)
block|{
name|suffix
operator|=
name|GZ_EXTENSION
expr_stmt|;
name|FIO_setCompressionType
argument_list|(
name|FIO_gzipCompression
argument_list|)
expr_stmt|;
name|FIO_setRemoveSrcFile
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* behave like gzip */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|programName
argument_list|,
name|ZSTD_GUNZIP
argument_list|)
condition|)
block|{
name|operation
operator|=
name|zom_decompress
expr_stmt|;
name|FIO_setRemoveSrcFile
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* behave like gunzip */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|programName
argument_list|,
name|ZSTD_GZCAT
argument_list|)
condition|)
block|{
name|operation
operator|=
name|zom_decompress
expr_stmt|;
name|forceStdout
operator|=
literal|1
expr_stmt|;
name|FIO_overwriteMode
argument_list|()
expr_stmt|;
name|outFileName
operator|=
name|stdoutmark
expr_stmt|;
name|displayLevel
operator|=
literal|1
expr_stmt|;
block|}
comment|/* behave like gzcat */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|programName
argument_list|,
name|ZSTD_LZMA
argument_list|)
condition|)
block|{
name|suffix
operator|=
name|LZMA_EXTENSION
expr_stmt|;
name|FIO_setCompressionType
argument_list|(
name|FIO_lzmaCompression
argument_list|)
expr_stmt|;
name|FIO_setRemoveSrcFile
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* behave like lzma */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|programName
argument_list|,
name|ZSTD_XZ
argument_list|)
condition|)
block|{
name|suffix
operator|=
name|XZ_EXTENSION
expr_stmt|;
name|FIO_setCompressionType
argument_list|(
name|FIO_xzCompression
argument_list|)
expr_stmt|;
name|FIO_setRemoveSrcFile
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* behave like xz */
name|memset
argument_list|(
operator|&
name|compressionParams
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|compressionParams
argument_list|)
argument_list|)
expr_stmt|;
comment|/* command switches */
for|for
control|(
name|argNb
operator|=
literal|1
init|;
name|argNb
operator|<
name|argCount
condition|;
name|argNb
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|argument
init|=
name|argv
index|[
name|argNb
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|argument
condition|)
continue|continue;
comment|/* Protection if argument empty */
if|if
condition|(
name|nextArgumentsAreFiles
operator|==
literal|0
condition|)
block|{
comment|/* "-" means stdin/stdout */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argument
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|filenameIdx
condition|)
block|{
name|filenameIdx
operator|=
literal|1
operator|,
name|filenameTable
index|[
literal|0
index|]
operator|=
name|stdinmark
expr_stmt|;
name|outFileName
operator|=
name|stdoutmark
expr_stmt|;
name|displayLevel
operator|-=
operator|(
name|displayLevel
operator|==
literal|2
operator|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* Decode commands (note : aggregated commands are allowed) */
if|if
condition|(
name|argument
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|argument
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
comment|/* long commands (--long-word) */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argument
argument_list|,
literal|"--"
argument_list|)
condition|)
block|{
name|nextArgumentsAreFiles
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* only file names allowed from now on */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argument
argument_list|,
literal|"--compress"
argument_list|)
condition|)
block|{
name|operation
operator|=
name|zom_compress
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argument
argument_list|,
literal|"--decompress"
argument_list|)
condition|)
block|{
name|operation
operator|=
name|zom_decompress
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argument
argument_list|,
literal|"--uncompress"
argument_list|)
condition|)
block|{
name|operation
operator|=
name|zom_decompress
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argument
argument_list|,
literal|"--force"
argument_list|)
condition|)
block|{
name|FIO_overwriteMode
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argument
argument_list|,
literal|"--version"
argument_list|)
condition|)
block|{
name|displayOut
operator|=
name|stdout
expr_stmt|;
name|DISPLAY
argument_list|(
name|WELCOME_MESSAGE
argument_list|)
expr_stmt|;
name|CLEAN_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argument
argument_list|,
literal|"--help"
argument_list|)
condition|)
block|{
name|displayOut
operator|=
name|stdout
expr_stmt|;
name|CLEAN_RETURN
argument_list|(
name|usage_advanced
argument_list|(
name|programName
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argument
argument_list|,
literal|"--verbose"
argument_list|)
condition|)
block|{
name|displayLevel
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argument
argument_list|,
literal|"--quiet"
argument_list|)
condition|)
block|{
name|displayLevel
operator|--
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argument
argument_list|,
literal|"--stdout"
argument_list|)
condition|)
block|{
name|forceStdout
operator|=
literal|1
expr_stmt|;
name|outFileName
operator|=
name|stdoutmark
expr_stmt|;
name|displayLevel
operator|-=
operator|(
name|displayLevel
operator|==
literal|2
operator|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argument
argument_list|,
literal|"--ultra"
argument_list|)
condition|)
block|{
name|ultra
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argument
argument_list|,
literal|"--check"
argument_list|)
condition|)
block|{
name|FIO_setChecksumFlag
argument_list|(
literal|2
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argument
argument_list|,
literal|"--no-check"
argument_list|)
condition|)
block|{
name|FIO_setChecksumFlag
argument_list|(
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argument
argument_list|,
literal|"--sparse"
argument_list|)
condition|)
block|{
name|FIO_setSparseWrite
argument_list|(
literal|2
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argument
argument_list|,
literal|"--no-sparse"
argument_list|)
condition|)
block|{
name|FIO_setSparseWrite
argument_list|(
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argument
argument_list|,
literal|"--test"
argument_list|)
condition|)
block|{
name|operation
operator|=
name|zom_test
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argument
argument_list|,
literal|"--train"
argument_list|)
condition|)
block|{
name|operation
operator|=
name|zom_train
expr_stmt|;
name|outFileName
operator|=
name|g_defaultDictName
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argument
argument_list|,
literal|"--maxdict"
argument_list|)
condition|)
block|{
name|nextArgumentIsMaxDict
operator|=
literal|1
expr_stmt|;
name|lastCommand
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argument
argument_list|,
literal|"--dictID"
argument_list|)
condition|)
block|{
name|nextArgumentIsDictID
operator|=
literal|1
expr_stmt|;
name|lastCommand
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argument
argument_list|,
literal|"--no-dictID"
argument_list|)
condition|)
block|{
name|FIO_setDictIDFlag
argument_list|(
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argument
argument_list|,
literal|"--keep"
argument_list|)
condition|)
block|{
name|FIO_setRemoveSrcFile
argument_list|(
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argument
argument_list|,
literal|"--rm"
argument_list|)
condition|)
block|{
name|FIO_setRemoveSrcFile
argument_list|(
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argument
argument_list|,
literal|"--priority=rt"
argument_list|)
condition|)
block|{
name|setRealTimePrio
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|ZSTD_GZCOMPRESS
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argument
argument_list|,
literal|"--format=gzip"
argument_list|)
condition|)
block|{
name|suffix
operator|=
name|GZ_EXTENSION
expr_stmt|;
name|FIO_setCompressionType
argument_list|(
name|FIO_gzipCompression
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ZSTD_LZMACOMPRESS
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argument
argument_list|,
literal|"--format=lzma"
argument_list|)
condition|)
block|{
name|suffix
operator|=
name|LZMA_EXTENSION
expr_stmt|;
name|FIO_setCompressionType
argument_list|(
name|FIO_lzmaCompression
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argument
argument_list|,
literal|"--format=xz"
argument_list|)
condition|)
block|{
name|suffix
operator|=
name|XZ_EXTENSION
expr_stmt|;
name|FIO_setCompressionType
argument_list|(
name|FIO_xzCompression
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
comment|/* long commands with arguments */
ifndef|#
directive|ifndef
name|ZSTD_NODICT
if|if
condition|(
name|longCommandWArg
argument_list|(
operator|&
name|argument
argument_list|,
literal|"--cover="
argument_list|)
condition|)
block|{
name|cover
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|parseCoverParameters
argument_list|(
name|argument
argument_list|,
operator|&
name|coverParams
argument_list|)
condition|)
name|CLEAN_RETURN
argument_list|(
name|badusage
argument_list|(
name|programName
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|longCommandWArg
argument_list|(
operator|&
name|argument
argument_list|,
literal|"--optimize-cover"
argument_list|)
condition|)
block|{
name|cover
operator|=
literal|2
expr_stmt|;
comment|/* Allow optional arguments following an = */
if|if
condition|(
operator|*
name|argument
operator|==
literal|0
condition|)
block|{
name|memset
argument_list|(
operator|&
name|coverParams
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|coverParams
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|argument
operator|++
operator|!=
literal|'='
condition|)
block|{
name|CLEAN_RETURN
argument_list|(
name|badusage
argument_list|(
name|programName
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parseCoverParameters
argument_list|(
name|argument
argument_list|,
operator|&
name|coverParams
argument_list|)
condition|)
block|{
name|CLEAN_RETURN
argument_list|(
name|badusage
argument_list|(
name|programName
argument_list|)
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
endif|#
directive|endif
if|if
condition|(
name|longCommandWArg
argument_list|(
operator|&
name|argument
argument_list|,
literal|"--memlimit="
argument_list|)
condition|)
block|{
name|memLimit
operator|=
name|readU32FromChar
argument_list|(
operator|&
name|argument
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|longCommandWArg
argument_list|(
operator|&
name|argument
argument_list|,
literal|"--memory="
argument_list|)
condition|)
block|{
name|memLimit
operator|=
name|readU32FromChar
argument_list|(
operator|&
name|argument
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|longCommandWArg
argument_list|(
operator|&
name|argument
argument_list|,
literal|"--memlimit-decompress="
argument_list|)
condition|)
block|{
name|memLimit
operator|=
name|readU32FromChar
argument_list|(
operator|&
name|argument
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|longCommandWArg
argument_list|(
operator|&
name|argument
argument_list|,
literal|"--block-size="
argument_list|)
condition|)
block|{
name|blockSize
operator|=
name|readU32FromChar
argument_list|(
operator|&
name|argument
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|longCommandWArg
argument_list|(
operator|&
name|argument
argument_list|,
literal|"--zstd="
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|parseCompressionParameters
argument_list|(
name|argument
argument_list|,
operator|&
name|compressionParams
argument_list|)
condition|)
name|CLEAN_RETURN
argument_list|(
name|badusage
argument_list|(
name|programName
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* fall-through, will trigger bad_usage() later on */
block|}
name|argument
operator|++
expr_stmt|;
while|while
condition|(
name|argument
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|lastCommand
condition|)
block|{
name|DISPLAY
argument_list|(
literal|"error : command must be followed by argument \n"
argument_list|)
expr_stmt|;
name|CLEAN_RETURN
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|ZSTD_NOCOMPRESS
comment|/* compression Level */
if|if
condition|(
operator|(
operator|*
name|argument
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|argument
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|dictCLevel
operator|=
name|cLevel
operator|=
name|readU32FromChar
argument_list|(
operator|&
name|argument
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|argument
index|[
literal|0
index|]
condition|)
block|{
comment|/* Display help */
case|case
literal|'V'
case|:
name|displayOut
operator|=
name|stdout
expr_stmt|;
name|DISPLAY
argument_list|(
name|WELCOME_MESSAGE
argument_list|)
expr_stmt|;
name|CLEAN_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Version Only */
case|case
literal|'H'
case|:
case|case
literal|'h'
case|:
name|displayOut
operator|=
name|stdout
expr_stmt|;
name|CLEAN_RETURN
argument_list|(
name|usage_advanced
argument_list|(
name|programName
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Compress */
case|case
literal|'z'
case|:
name|operation
operator|=
name|zom_compress
expr_stmt|;
name|argument
operator|++
expr_stmt|;
break|break;
comment|/* Decoding */
case|case
literal|'d'
case|:
ifndef|#
directive|ifndef
name|ZSTD_NOBENCH
if|if
condition|(
name|operation
operator|==
name|zom_bench
condition|)
block|{
name|BMK_setDecodeOnlyMode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|argument
operator|++
expr_stmt|;
break|break;
block|}
comment|/* benchmark decode (hidden option) */
endif|#
directive|endif
name|operation
operator|=
name|zom_decompress
expr_stmt|;
name|argument
operator|++
expr_stmt|;
break|break;
comment|/* Force stdout, even if stdout==console */
case|case
literal|'c'
case|:
name|forceStdout
operator|=
literal|1
expr_stmt|;
name|outFileName
operator|=
name|stdoutmark
expr_stmt|;
name|argument
operator|++
expr_stmt|;
break|break;
comment|/* Use file content as dictionary */
case|case
literal|'D'
case|:
name|nextEntryIsDictionary
operator|=
literal|1
expr_stmt|;
name|lastCommand
operator|=
literal|1
expr_stmt|;
name|argument
operator|++
expr_stmt|;
break|break;
comment|/* Overwrite */
case|case
literal|'f'
case|:
name|FIO_overwriteMode
argument_list|()
expr_stmt|;
name|forceStdout
operator|=
literal|1
expr_stmt|;
name|argument
operator|++
expr_stmt|;
break|break;
comment|/* Verbose mode */
case|case
literal|'v'
case|:
name|displayLevel
operator|++
expr_stmt|;
name|argument
operator|++
expr_stmt|;
break|break;
comment|/* Quiet mode */
case|case
literal|'q'
case|:
name|displayLevel
operator|--
expr_stmt|;
name|argument
operator|++
expr_stmt|;
break|break;
comment|/* keep source file (default); for gzip/xz compatibility */
case|case
literal|'k'
case|:
name|FIO_setRemoveSrcFile
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|argument
operator|++
expr_stmt|;
break|break;
comment|/* Checksum */
case|case
literal|'C'
case|:
name|argument
operator|++
expr_stmt|;
name|FIO_setChecksumFlag
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
comment|/* test compressed file */
case|case
literal|'t'
case|:
name|operation
operator|=
name|zom_test
expr_stmt|;
name|argument
operator|++
expr_stmt|;
break|break;
comment|/* destination file name */
case|case
literal|'o'
case|:
name|nextArgumentIsOutFileName
operator|=
literal|1
expr_stmt|;
name|lastCommand
operator|=
literal|1
expr_stmt|;
name|argument
operator|++
expr_stmt|;
break|break;
comment|/* limit decompression memory */
case|case
literal|'M'
case|:
name|argument
operator|++
expr_stmt|;
name|memLimit
operator|=
name|readU32FromChar
argument_list|(
operator|&
name|argument
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|UTIL_HAS_CREATEFILELIST
comment|/* recursive */
case|case
literal|'r'
case|:
name|recursive
operator|=
literal|1
expr_stmt|;
name|argument
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|ZSTD_NOBENCH
comment|/* Benchmark */
case|case
literal|'b'
case|:
name|operation
operator|=
name|zom_bench
expr_stmt|;
name|argument
operator|++
expr_stmt|;
break|break;
comment|/* range bench (benchmark only) */
case|case
literal|'e'
case|:
comment|/* compression Level */
name|argument
operator|++
expr_stmt|;
name|cLevelLast
operator|=
name|readU32FromChar
argument_list|(
operator|&
name|argument
argument_list|)
expr_stmt|;
break|break;
comment|/* Modify Nb Iterations (benchmark only) */
case|case
literal|'i'
case|:
name|argument
operator|++
expr_stmt|;
name|bench_nbSeconds
operator|=
name|readU32FromChar
argument_list|(
operator|&
name|argument
argument_list|)
expr_stmt|;
break|break;
comment|/* cut input into blocks (benchmark only) */
case|case
literal|'B'
case|:
name|argument
operator|++
expr_stmt|;
name|blockSize
operator|=
name|readU32FromChar
argument_list|(
operator|&
name|argument
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* ZSTD_NOBENCH */
comment|/* nb of threads (hidden option) */
case|case
literal|'T'
case|:
name|argument
operator|++
expr_stmt|;
name|nbThreads
operator|=
name|readU32FromChar
argument_list|(
operator|&
name|argument
argument_list|)
expr_stmt|;
break|break;
comment|/* Dictionary Selection level */
case|case
literal|'s'
case|:
name|argument
operator|++
expr_stmt|;
name|dictSelect
operator|=
name|readU32FromChar
argument_list|(
operator|&
name|argument
argument_list|)
expr_stmt|;
break|break;
comment|/* Pause at the end (-p) or set an additional param (-p#) (hidden option) */
case|case
literal|'p'
case|:
name|argument
operator|++
expr_stmt|;
ifndef|#
directive|ifndef
name|ZSTD_NOBENCH
if|if
condition|(
operator|(
operator|*
name|argument
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|argument
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|BMK_setAdditionalParam
argument_list|(
name|readU32FromChar
argument_list|(
operator|&
name|argument
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|main_pause
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* unknown command */
default|default :
name|CLEAN_RETURN
argument_list|(
name|badusage
argument_list|(
name|programName
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
continue|continue;
block|}
comment|/* if (argument[0]=='-') */
if|if
condition|(
name|nextArgumentIsMaxDict
condition|)
block|{
name|nextArgumentIsMaxDict
operator|=
literal|0
expr_stmt|;
name|lastCommand
operator|=
literal|0
expr_stmt|;
name|maxDictSize
operator|=
name|readU32FromChar
argument_list|(
operator|&
name|argument
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|nextArgumentIsDictID
condition|)
block|{
name|nextArgumentIsDictID
operator|=
literal|0
expr_stmt|;
name|lastCommand
operator|=
literal|0
expr_stmt|;
name|dictID
operator|=
name|readU32FromChar
argument_list|(
operator|&
name|argument
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* if (nextArgumentIsAFile==0) */
if|if
condition|(
name|nextEntryIsDictionary
condition|)
block|{
name|nextEntryIsDictionary
operator|=
literal|0
expr_stmt|;
name|lastCommand
operator|=
literal|0
expr_stmt|;
name|dictFileName
operator|=
name|argument
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|nextArgumentIsOutFileName
condition|)
block|{
name|nextArgumentIsOutFileName
operator|=
literal|0
expr_stmt|;
name|lastCommand
operator|=
literal|0
expr_stmt|;
name|outFileName
operator|=
name|argument
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|outFileName
argument_list|,
literal|"-"
argument_list|)
condition|)
name|outFileName
operator|=
name|stdoutmark
expr_stmt|;
continue|continue;
block|}
comment|/* add filename to list */
name|filenameTable
index|[
name|filenameIdx
operator|++
index|]
operator|=
name|argument
expr_stmt|;
block|}
if|if
condition|(
name|lastCommand
condition|)
block|{
name|DISPLAY
argument_list|(
literal|"error : command must be followed by argument \n"
argument_list|)
expr_stmt|;
name|CLEAN_RETURN
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* forgotten argument */
comment|/* Welcome message (if verbose) */
name|DISPLAYLEVEL
argument_list|(
literal|3
argument_list|,
name|WELCOME_MESSAGE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_POSIX_C_SOURCE
name|DISPLAYLEVEL
argument_list|(
literal|4
argument_list|,
literal|"_POSIX_C_SOURCE defined: %ldL\n"
argument_list|,
operator|(
name|long
operator|)
name|_POSIX_C_SOURCE
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_POSIX_VERSION
name|DISPLAYLEVEL
argument_list|(
literal|4
argument_list|,
literal|"_POSIX_VERSION defined: %ldL\n"
argument_list|,
operator|(
name|long
operator|)
name|_POSIX_VERSION
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PLATFORM_POSIX_VERSION
name|DISPLAYLEVEL
argument_list|(
literal|4
argument_list|,
literal|"PLATFORM_POSIX_VERSION defined: %ldL\n"
argument_list|,
operator|(
name|long
operator|)
name|PLATFORM_POSIX_VERSION
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UTIL_HAS_CREATEFILELIST
if|if
condition|(
name|recursive
condition|)
block|{
comment|/* at this stage, filenameTable is a list of paths, which can contain both files and directories */
name|extendedFileList
operator|=
name|UTIL_createFileList
argument_list|(
name|filenameTable
argument_list|,
name|filenameIdx
argument_list|,
operator|&
name|fileNamesBuf
argument_list|,
operator|&
name|fileNamesNb
argument_list|)
expr_stmt|;
if|if
condition|(
name|extendedFileList
condition|)
block|{
name|unsigned
name|u
decl_stmt|;
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|fileNamesNb
condition|;
name|u
operator|++
control|)
name|DISPLAYLEVEL
argument_list|(
literal|4
argument_list|,
literal|"%u %s\n"
argument_list|,
name|u
argument_list|,
name|extendedFileList
index|[
name|u
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|filenameTable
argument_list|)
expr_stmt|;
name|filenameTable
operator|=
name|extendedFileList
expr_stmt|;
name|filenameIdx
operator|=
name|fileNamesNb
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* Check if benchmark is selected */
if|if
condition|(
name|operation
operator|==
name|zom_bench
condition|)
block|{
ifndef|#
directive|ifndef
name|ZSTD_NOBENCH
name|BMK_setNotificationLevel
argument_list|(
name|displayLevel
argument_list|)
expr_stmt|;
name|BMK_setBlockSize
argument_list|(
name|blockSize
argument_list|)
expr_stmt|;
name|BMK_setNbThreads
argument_list|(
name|nbThreads
argument_list|)
expr_stmt|;
name|BMK_setNbSeconds
argument_list|(
name|bench_nbSeconds
argument_list|)
expr_stmt|;
name|BMK_benchFiles
argument_list|(
name|filenameTable
argument_list|,
name|filenameIdx
argument_list|,
name|dictFileName
argument_list|,
name|cLevel
argument_list|,
name|cLevelLast
argument_list|,
operator|&
name|compressionParams
argument_list|,
name|setRealTimePrio
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|bench_nbSeconds
expr_stmt|;
goto|goto
name|_end
goto|;
block|}
comment|/* Check if dictionary builder is selected */
if|if
condition|(
name|operation
operator|==
name|zom_train
condition|)
block|{
ifndef|#
directive|ifndef
name|ZSTD_NODICT
if|if
condition|(
name|cover
condition|)
block|{
name|coverParams
operator|.
name|nbThreads
operator|=
name|nbThreads
expr_stmt|;
name|coverParams
operator|.
name|compressionLevel
operator|=
name|dictCLevel
expr_stmt|;
name|coverParams
operator|.
name|notificationLevel
operator|=
name|displayLevel
expr_stmt|;
name|coverParams
operator|.
name|dictID
operator|=
name|dictID
expr_stmt|;
name|DiB_trainFromFiles
argument_list|(
name|outFileName
argument_list|,
name|maxDictSize
argument_list|,
name|filenameTable
argument_list|,
name|filenameIdx
argument_list|,
name|NULL
argument_list|,
operator|&
name|coverParams
argument_list|,
name|cover
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ZDICT_params_t
name|dictParams
decl_stmt|;
name|memset
argument_list|(
operator|&
name|dictParams
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dictParams
argument_list|)
argument_list|)
expr_stmt|;
name|dictParams
operator|.
name|compressionLevel
operator|=
name|dictCLevel
expr_stmt|;
name|dictParams
operator|.
name|selectivityLevel
operator|=
name|dictSelect
expr_stmt|;
name|dictParams
operator|.
name|notificationLevel
operator|=
name|displayLevel
expr_stmt|;
name|dictParams
operator|.
name|dictID
operator|=
name|dictID
expr_stmt|;
name|DiB_trainFromFiles
argument_list|(
name|outFileName
argument_list|,
name|maxDictSize
argument_list|,
name|filenameTable
argument_list|,
name|filenameIdx
argument_list|,
operator|&
name|dictParams
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
goto|goto
name|_end
goto|;
block|}
comment|/* No input filename ==> use stdin and stdout */
name|filenameIdx
operator|+=
operator|!
name|filenameIdx
expr_stmt|;
comment|/* filenameTable[0] is stdin by default */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|filenameTable
index|[
literal|0
index|]
argument_list|,
name|stdinmark
argument_list|)
operator|&&
operator|!
name|outFileName
condition|)
name|outFileName
operator|=
name|stdoutmark
expr_stmt|;
comment|/* when input is stdin, default output is stdout */
comment|/* Check if input/output defined as console; trigger an error in this case */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|filenameTable
index|[
literal|0
index|]
argument_list|,
name|stdinmark
argument_list|)
operator|&&
name|IS_CONSOLE
argument_list|(
name|stdin
argument_list|)
condition|)
name|CLEAN_RETURN
argument_list|(
name|badusage
argument_list|(
name|programName
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|outFileName
operator|&&
operator|!
name|strcmp
argument_list|(
name|outFileName
argument_list|,
name|stdoutmark
argument_list|)
operator|&&
name|IS_CONSOLE
argument_list|(
name|stdout
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|filenameTable
index|[
literal|0
index|]
argument_list|,
name|stdinmark
argument_list|)
operator|&&
operator|!
operator|(
name|forceStdout
operator|&&
operator|(
name|operation
operator|==
name|zom_decompress
operator|)
operator|)
condition|)
name|CLEAN_RETURN
argument_list|(
name|badusage
argument_list|(
name|programName
argument_list|)
argument_list|)
expr_stmt|;
comment|/* user-selected output filename, only possible with a single file */
if|if
condition|(
name|outFileName
operator|&&
name|strcmp
argument_list|(
name|outFileName
argument_list|,
name|stdoutmark
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|outFileName
argument_list|,
name|nulmark
argument_list|)
operator|&&
operator|(
name|filenameIdx
operator|>
literal|1
operator|)
condition|)
block|{
name|DISPLAY
argument_list|(
literal|"Too many files (%u) on the command line. \n"
argument_list|,
name|filenameIdx
argument_list|)
expr_stmt|;
name|CLEAN_RETURN
argument_list|(
name|filenameIdx
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|ZSTD_NOCOMPRESS
comment|/* check compression level limits */
block|{
name|int
specifier|const
name|maxCLevel
init|=
name|ultra
condition|?
name|ZSTD_maxCLevel
argument_list|()
else|:
name|ZSTDCLI_CLEVEL_MAX
decl_stmt|;
if|if
condition|(
name|cLevel
operator|>
name|maxCLevel
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"Warning : compression level higher than max, reduced to %i \n"
argument_list|,
name|maxCLevel
argument_list|)
expr_stmt|;
name|cLevel
operator|=
name|maxCLevel
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* No status message in pipe mode (stdin - stdout) or multi-files mode */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|filenameTable
index|[
literal|0
index|]
argument_list|,
name|stdinmark
argument_list|)
operator|&&
name|outFileName
operator|&&
operator|!
name|strcmp
argument_list|(
name|outFileName
argument_list|,
name|stdoutmark
argument_list|)
operator|&&
operator|(
name|displayLevel
operator|==
literal|2
operator|)
condition|)
name|displayLevel
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|filenameIdx
operator|>
literal|1
operator|)
operator|&
operator|(
name|displayLevel
operator|==
literal|2
operator|)
condition|)
name|displayLevel
operator|=
literal|1
expr_stmt|;
comment|/* IO Stream/File */
name|FIO_setNotificationLevel
argument_list|(
name|displayLevel
argument_list|)
expr_stmt|;
if|if
condition|(
name|operation
operator|==
name|zom_compress
condition|)
block|{
ifndef|#
directive|ifndef
name|ZSTD_NOCOMPRESS
name|FIO_setNbThreads
argument_list|(
name|nbThreads
argument_list|)
expr_stmt|;
name|FIO_setBlockSize
argument_list|(
operator|(
name|U32
operator|)
name|blockSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_overlapLog
operator|!=
name|OVERLAP_LOG_DEFAULT
condition|)
name|FIO_setOverlapLog
argument_list|(
name|g_overlapLog
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|filenameIdx
operator|==
literal|1
operator|)
operator|&&
name|outFileName
condition|)
name|operationResult
operator|=
name|FIO_compressFilename
argument_list|(
name|outFileName
argument_list|,
name|filenameTable
index|[
literal|0
index|]
argument_list|,
name|dictFileName
argument_list|,
name|cLevel
argument_list|,
operator|&
name|compressionParams
argument_list|)
expr_stmt|;
else|else
name|operationResult
operator|=
name|FIO_compressMultipleFilenames
argument_list|(
name|filenameTable
argument_list|,
name|filenameIdx
argument_list|,
name|outFileName
condition|?
name|outFileName
else|:
name|suffix
argument_list|,
name|dictFileName
argument_list|,
name|cLevel
argument_list|,
operator|&
name|compressionParams
argument_list|)
expr_stmt|;
else|#
directive|else
name|DISPLAY
argument_list|(
literal|"Compression not supported\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* decompression or test */
ifndef|#
directive|ifndef
name|ZSTD_NODECOMPRESS
if|if
condition|(
name|operation
operator|==
name|zom_test
condition|)
block|{
name|outFileName
operator|=
name|nulmark
expr_stmt|;
name|FIO_setRemoveSrcFile
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* test mode */
name|FIO_setMemLimit
argument_list|(
name|memLimit
argument_list|)
expr_stmt|;
if|if
condition|(
name|filenameIdx
operator|==
literal|1
operator|&&
name|outFileName
condition|)
name|operationResult
operator|=
name|FIO_decompressFilename
argument_list|(
name|outFileName
argument_list|,
name|filenameTable
index|[
literal|0
index|]
argument_list|,
name|dictFileName
argument_list|)
expr_stmt|;
else|else
name|operationResult
operator|=
name|FIO_decompressMultipleFilenames
argument_list|(
name|filenameTable
argument_list|,
name|filenameIdx
argument_list|,
name|outFileName
condition|?
name|outFileName
else|:
name|ZSTD_EXTENSION
argument_list|,
name|dictFileName
argument_list|)
expr_stmt|;
else|#
directive|else
name|DISPLAY
argument_list|(
literal|"Decompression not supported\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|_end
label|:
if|if
condition|(
name|main_pause
condition|)
name|waitEnter
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|UTIL_HAS_CREATEFILELIST
if|if
condition|(
name|extendedFileList
condition|)
name|UTIL_freeFileList
argument_list|(
name|extendedFileList
argument_list|,
name|fileNamesBuf
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|filenameTable
argument_list|)
expr_stmt|;
return|return
name|operationResult
return|;
block|}
end_function

end_unit

