begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright (c) 2016-present, Yann Collet, Facebook, Inc.  * All rights reserved.  *  * This source code is licensed under the BSD-style license found in the  * LICENSE file in the root directory of this source tree. An additional grant  * of patent rights can be found in the PATENTS file in the same directory.  */
end_comment

begin_comment
comment|/* *****************************************************************************  * Constructs a dictionary using a heuristic based on the following paper:  *  * Liao, Petri, Moffat, Wirth  * Effective Construction of Relative Lempel-Ziv Dictionaries  * Published in WWW 2016.  *  * Adapted from code originally written by @ot (Giuseppe Ottaviano).  ******************************************************************************/
end_comment

begin_comment
comment|/*-************************************* *  Dependencies ***************************************/
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* fprintf */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* malloc, free, qsort */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* memset */
end_comment

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_comment
comment|/* clock */
end_comment

begin_include
include|#
directive|include
file|"mem.h"
end_include

begin_comment
comment|/* read */
end_comment

begin_include
include|#
directive|include
file|"pool.h"
end_include

begin_include
include|#
directive|include
file|"threading.h"
end_include

begin_include
include|#
directive|include
file|"zstd_internal.h"
end_include

begin_comment
comment|/* includes zstd.h */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ZDICT_STATIC_LINKING_ONLY
end_ifndef

begin_define
define|#
directive|define
name|ZDICT_STATIC_LINKING_ONLY
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"zdict.h"
end_include

begin_comment
comment|/*-************************************* *  Constants ***************************************/
end_comment

begin_define
define|#
directive|define
name|COVER_MAX_SAMPLES_SIZE
value|(sizeof(size_t) == 8 ? ((U32)-1) : ((U32)1 GB))
end_define

begin_comment
comment|/*-************************************* *  Console display ***************************************/
end_comment

begin_decl_stmt
specifier|static
name|int
name|g_displayLevel
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DISPLAY
parameter_list|(
modifier|...
parameter_list|)
define|\
value|{                                                                            \     fprintf(stderr, __VA_ARGS__);                                              \     fflush(stderr);                                                            \   }
end_define

begin_define
define|#
directive|define
name|LOCALDISPLAYLEVEL
parameter_list|(
name|displayLevel
parameter_list|,
name|l
parameter_list|,
modifier|...
parameter_list|)
define|\
value|if (displayLevel>= l) {                                                     \     DISPLAY(__VA_ARGS__);                                                      \   }
end_define

begin_comment
comment|/* 0 : no display;   1: errors;   2: default;  3: details;  4: debug */
end_comment

begin_define
define|#
directive|define
name|DISPLAYLEVEL
parameter_list|(
name|l
parameter_list|,
modifier|...
parameter_list|)
value|LOCALDISPLAYLEVEL(g_displayLevel, l, __VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|LOCALDISPLAYUPDATE
parameter_list|(
name|displayLevel
parameter_list|,
name|l
parameter_list|,
modifier|...
parameter_list|)
define|\
value|if (displayLevel>= l) {                                                     \     if ((clock() - g_time> refreshRate) || (displayLevel>= 4)) {             \       g_time = clock();                                                        \       DISPLAY(__VA_ARGS__);                                                    \     }                                                                          \   }
end_define

begin_define
define|#
directive|define
name|DISPLAYUPDATE
parameter_list|(
name|l
parameter_list|,
modifier|...
parameter_list|)
value|LOCALDISPLAYUPDATE(g_displayLevel, l, __VA_ARGS__)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|clock_t
name|refreshRate
init|=
name|CLOCKS_PER_SEC
operator|*
literal|15
operator|/
literal|100
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|clock_t
name|g_time
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*-************************************* * Hash table *************************************** * A small specialized hash map for storing activeDmers. * The map does not resize, so if it becomes full it will loop forever. * Thus, the map must be large enough to store every value. * The map implements linear probing and keeps its load less than 0.5. */
end_comment

begin_define
define|#
directive|define
name|MAP_EMPTY_VALUE
value|((U32)-1)
end_define

begin_typedef
typedef|typedef
struct|struct
name|COVER_map_pair_t_s
block|{
name|U32
name|key
decl_stmt|;
name|U32
name|value
decl_stmt|;
block|}
name|COVER_map_pair_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|COVER_map_s
block|{
name|COVER_map_pair_t
modifier|*
name|data
decl_stmt|;
name|U32
name|sizeLog
decl_stmt|;
name|U32
name|size
decl_stmt|;
name|U32
name|sizeMask
decl_stmt|;
block|}
name|COVER_map_t
typedef|;
end_typedef

begin_comment
comment|/**  * Clear the map.  */
end_comment

begin_function
specifier|static
name|void
name|COVER_map_clear
parameter_list|(
name|COVER_map_t
modifier|*
name|map
parameter_list|)
block|{
name|memset
argument_list|(
name|map
operator|->
name|data
argument_list|,
name|MAP_EMPTY_VALUE
argument_list|,
name|map
operator|->
name|size
operator|*
sizeof|sizeof
argument_list|(
name|COVER_map_pair_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Initializes a map of the given size.  * Returns 1 on success and 0 on failure.  * The map must be destroyed with COVER_map_destroy().  * The map is only guaranteed to be large enough to hold size elements.  */
end_comment

begin_function
specifier|static
name|int
name|COVER_map_init
parameter_list|(
name|COVER_map_t
modifier|*
name|map
parameter_list|,
name|U32
name|size
parameter_list|)
block|{
name|map
operator|->
name|sizeLog
operator|=
name|ZSTD_highbit32
argument_list|(
name|size
argument_list|)
operator|+
literal|2
expr_stmt|;
name|map
operator|->
name|size
operator|=
operator|(
name|U32
operator|)
literal|1
operator|<<
name|map
operator|->
name|sizeLog
expr_stmt|;
name|map
operator|->
name|sizeMask
operator|=
name|map
operator|->
name|size
operator|-
literal|1
expr_stmt|;
name|map
operator|->
name|data
operator|=
operator|(
name|COVER_map_pair_t
operator|*
operator|)
name|malloc
argument_list|(
name|map
operator|->
name|size
operator|*
sizeof|sizeof
argument_list|(
name|COVER_map_pair_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|map
operator|->
name|data
condition|)
block|{
name|map
operator|->
name|sizeLog
operator|=
literal|0
expr_stmt|;
name|map
operator|->
name|size
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|COVER_map_clear
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Internal hash function  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|U32
name|prime4bytes
init|=
literal|2654435761U
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|U32
name|COVER_map_hash
parameter_list|(
name|COVER_map_t
modifier|*
name|map
parameter_list|,
name|U32
name|key
parameter_list|)
block|{
return|return
operator|(
name|key
operator|*
name|prime4bytes
operator|)
operator|>>
operator|(
literal|32
operator|-
name|map
operator|->
name|sizeLog
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Helper function that returns the index that a key should be placed into.  */
end_comment

begin_function
specifier|static
name|U32
name|COVER_map_index
parameter_list|(
name|COVER_map_t
modifier|*
name|map
parameter_list|,
name|U32
name|key
parameter_list|)
block|{
specifier|const
name|U32
name|hash
init|=
name|COVER_map_hash
argument_list|(
name|map
argument_list|,
name|key
argument_list|)
decl_stmt|;
name|U32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|hash
init|;
condition|;
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|&
name|map
operator|->
name|sizeMask
control|)
block|{
name|COVER_map_pair_t
modifier|*
name|pos
init|=
operator|&
name|map
operator|->
name|data
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|pos
operator|->
name|value
operator|==
name|MAP_EMPTY_VALUE
condition|)
block|{
return|return
name|i
return|;
block|}
if|if
condition|(
name|pos
operator|->
name|key
operator|==
name|key
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * Returns the pointer to the value for key.  * If key is not in the map, it is inserted and the value is set to 0.  * The map must not be full.  */
end_comment

begin_function
specifier|static
name|U32
modifier|*
name|COVER_map_at
parameter_list|(
name|COVER_map_t
modifier|*
name|map
parameter_list|,
name|U32
name|key
parameter_list|)
block|{
name|COVER_map_pair_t
modifier|*
name|pos
init|=
operator|&
name|map
operator|->
name|data
index|[
name|COVER_map_index
argument_list|(
name|map
argument_list|,
name|key
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|pos
operator|->
name|value
operator|==
name|MAP_EMPTY_VALUE
condition|)
block|{
name|pos
operator|->
name|key
operator|=
name|key
expr_stmt|;
name|pos
operator|->
name|value
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|&
name|pos
operator|->
name|value
return|;
block|}
end_function

begin_comment
comment|/**  * Deletes key from the map if present.  */
end_comment

begin_function
specifier|static
name|void
name|COVER_map_remove
parameter_list|(
name|COVER_map_t
modifier|*
name|map
parameter_list|,
name|U32
name|key
parameter_list|)
block|{
name|U32
name|i
init|=
name|COVER_map_index
argument_list|(
name|map
argument_list|,
name|key
argument_list|)
decl_stmt|;
name|COVER_map_pair_t
modifier|*
name|del
init|=
operator|&
name|map
operator|->
name|data
index|[
name|i
index|]
decl_stmt|;
name|U32
name|shift
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|del
operator|->
name|value
operator|==
name|MAP_EMPTY_VALUE
condition|)
block|{
return|return;
block|}
for|for
control|(
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|&
name|map
operator|->
name|sizeMask
init|;
condition|;
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|&
name|map
operator|->
name|sizeMask
control|)
block|{
name|COVER_map_pair_t
modifier|*
specifier|const
name|pos
init|=
operator|&
name|map
operator|->
name|data
index|[
name|i
index|]
decl_stmt|;
comment|/* If the position is empty we are done */
if|if
condition|(
name|pos
operator|->
name|value
operator|==
name|MAP_EMPTY_VALUE
condition|)
block|{
name|del
operator|->
name|value
operator|=
name|MAP_EMPTY_VALUE
expr_stmt|;
return|return;
block|}
comment|/* If pos can be moved to del do so */
if|if
condition|(
operator|(
operator|(
name|i
operator|-
name|COVER_map_hash
argument_list|(
name|map
argument_list|,
name|pos
operator|->
name|key
argument_list|)
operator|)
operator|&
name|map
operator|->
name|sizeMask
operator|)
operator|>=
name|shift
condition|)
block|{
name|del
operator|->
name|key
operator|=
name|pos
operator|->
name|key
expr_stmt|;
name|del
operator|->
name|value
operator|=
name|pos
operator|->
name|value
expr_stmt|;
name|del
operator|=
name|pos
expr_stmt|;
name|shift
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|++
name|shift
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * Destroyes a map that is inited with COVER_map_init().  */
end_comment

begin_function
specifier|static
name|void
name|COVER_map_destroy
parameter_list|(
name|COVER_map_t
modifier|*
name|map
parameter_list|)
block|{
if|if
condition|(
name|map
operator|->
name|data
condition|)
block|{
name|free
argument_list|(
name|map
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
name|map
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|map
operator|->
name|size
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-************************************* * Context ***************************************/
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|BYTE
modifier|*
name|samples
decl_stmt|;
name|size_t
modifier|*
name|offsets
decl_stmt|;
specifier|const
name|size_t
modifier|*
name|samplesSizes
decl_stmt|;
name|size_t
name|nbSamples
decl_stmt|;
name|U32
modifier|*
name|suffix
decl_stmt|;
name|size_t
name|suffixSize
decl_stmt|;
name|U32
modifier|*
name|freqs
decl_stmt|;
name|U32
modifier|*
name|dmerAt
decl_stmt|;
name|unsigned
name|d
decl_stmt|;
block|}
name|COVER_ctx_t
typedef|;
end_typedef

begin_comment
comment|/* We need a global context for qsort... */
end_comment

begin_decl_stmt
specifier|static
name|COVER_ctx_t
modifier|*
name|g_ctx
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*-************************************* *  Helper functions ***************************************/
end_comment

begin_comment
comment|/**  * Returns the sum of the sample sizes.  */
end_comment

begin_function
specifier|static
name|size_t
name|COVER_sum
parameter_list|(
specifier|const
name|size_t
modifier|*
name|samplesSizes
parameter_list|,
name|unsigned
name|nbSamples
parameter_list|)
block|{
name|size_t
name|sum
init|=
literal|0
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbSamples
condition|;
operator|++
name|i
control|)
block|{
name|sum
operator|+=
name|samplesSizes
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
name|sum
return|;
block|}
end_function

begin_comment
comment|/**  * Returns -1 if the dmer at lp is less than the dmer at rp.  * Return 0 if the dmers at lp and rp are equal.  * Returns 1 if the dmer at lp is greater than the dmer at rp.  */
end_comment

begin_function
specifier|static
name|int
name|COVER_cmp
parameter_list|(
name|COVER_ctx_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|void
modifier|*
name|lp
parameter_list|,
specifier|const
name|void
modifier|*
name|rp
parameter_list|)
block|{
name|U32
specifier|const
name|lhs
init|=
operator|*
operator|(
name|U32
specifier|const
operator|*
operator|)
name|lp
decl_stmt|;
name|U32
specifier|const
name|rhs
init|=
operator|*
operator|(
name|U32
specifier|const
operator|*
operator|)
name|rp
decl_stmt|;
return|return
name|memcmp
argument_list|(
name|ctx
operator|->
name|samples
operator|+
name|lhs
argument_list|,
name|ctx
operator|->
name|samples
operator|+
name|rhs
argument_list|,
name|ctx
operator|->
name|d
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Faster version for d<= 8.  */
end_comment

begin_function
specifier|static
name|int
name|COVER_cmp8
parameter_list|(
name|COVER_ctx_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|void
modifier|*
name|lp
parameter_list|,
specifier|const
name|void
modifier|*
name|rp
parameter_list|)
block|{
name|U64
specifier|const
name|mask
init|=
operator|(
name|ctx
operator|->
name|d
operator|==
literal|8
operator|)
condition|?
operator|(
name|U64
operator|)
operator|-
literal|1
else|:
operator|(
operator|(
operator|(
name|U64
operator|)
literal|1
operator|<<
operator|(
literal|8
operator|*
name|ctx
operator|->
name|d
operator|)
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
name|U64
specifier|const
name|lhs
init|=
name|MEM_readLE64
argument_list|(
name|ctx
operator|->
name|samples
operator|+
operator|*
operator|(
name|U32
specifier|const
operator|*
operator|)
name|lp
argument_list|)
operator|&
name|mask
decl_stmt|;
name|U64
specifier|const
name|rhs
init|=
name|MEM_readLE64
argument_list|(
name|ctx
operator|->
name|samples
operator|+
operator|*
operator|(
name|U32
specifier|const
operator|*
operator|)
name|rp
argument_list|)
operator|&
name|mask
decl_stmt|;
if|if
condition|(
name|lhs
operator|<
name|rhs
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|(
name|lhs
operator|>
name|rhs
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Same as COVER_cmp() except ties are broken by pointer value  * NOTE: g_ctx must be set to call this function.  A global is required because  * qsort doesn't take an opaque pointer.  */
end_comment

begin_function
specifier|static
name|int
name|COVER_strict_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|lp
parameter_list|,
specifier|const
name|void
modifier|*
name|rp
parameter_list|)
block|{
name|int
name|result
init|=
name|COVER_cmp
argument_list|(
name|g_ctx
argument_list|,
name|lp
argument_list|,
name|rp
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|lp
operator|<
name|rp
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**  * Faster version for d<= 8.  */
end_comment

begin_function
specifier|static
name|int
name|COVER_strict_cmp8
parameter_list|(
specifier|const
name|void
modifier|*
name|lp
parameter_list|,
specifier|const
name|void
modifier|*
name|rp
parameter_list|)
block|{
name|int
name|result
init|=
name|COVER_cmp8
argument_list|(
name|g_ctx
argument_list|,
name|lp
argument_list|,
name|rp
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|lp
operator|<
name|rp
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**  * Returns the first pointer in [first, last) whose element does not compare  * less than value.  If no such element exists it returns last.  */
end_comment

begin_function
specifier|static
specifier|const
name|size_t
modifier|*
name|COVER_lower_bound
parameter_list|(
specifier|const
name|size_t
modifier|*
name|first
parameter_list|,
specifier|const
name|size_t
modifier|*
name|last
parameter_list|,
name|size_t
name|value
parameter_list|)
block|{
name|size_t
name|count
init|=
name|last
operator|-
name|first
decl_stmt|;
while|while
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
name|size_t
name|step
init|=
name|count
operator|/
literal|2
decl_stmt|;
specifier|const
name|size_t
modifier|*
name|ptr
init|=
name|first
decl_stmt|;
name|ptr
operator|+=
name|step
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|<
name|value
condition|)
block|{
name|first
operator|=
operator|++
name|ptr
expr_stmt|;
name|count
operator|-=
name|step
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|count
operator|=
name|step
expr_stmt|;
block|}
block|}
return|return
name|first
return|;
block|}
end_function

begin_comment
comment|/**  * Generic groupBy function.  * Groups an array sorted by cmp into groups with equivalent values.  * Calls grp for each group.  */
end_comment

begin_function
specifier|static
name|void
name|COVER_groupBy
parameter_list|(
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|count
parameter_list|,
name|size_t
name|size
parameter_list|,
name|COVER_ctx_t
modifier|*
name|ctx
parameter_list|,
name|int
function_decl|(
modifier|*
name|cmp
function_decl|)
parameter_list|(
name|COVER_ctx_t
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|grp
function_decl|)
parameter_list|(
name|COVER_ctx_t
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|ptr
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|data
decl_stmt|;
name|size_t
name|num
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|num
operator|<
name|count
condition|)
block|{
specifier|const
name|BYTE
modifier|*
name|grpEnd
init|=
name|ptr
operator|+
name|size
decl_stmt|;
operator|++
name|num
expr_stmt|;
while|while
condition|(
name|num
operator|<
name|count
operator|&&
name|cmp
argument_list|(
name|ctx
argument_list|,
name|ptr
argument_list|,
name|grpEnd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|grpEnd
operator|+=
name|size
expr_stmt|;
operator|++
name|num
expr_stmt|;
block|}
name|grp
argument_list|(
name|ctx
argument_list|,
name|ptr
argument_list|,
name|grpEnd
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|grpEnd
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-************************************* *  Cover functions ***************************************/
end_comment

begin_comment
comment|/**  * Called on each group of positions with the same dmer.  * Counts the frequency of each dmer and saves it in the suffix array.  * Fills `ctx->dmerAt`.  */
end_comment

begin_function
specifier|static
name|void
name|COVER_group
parameter_list|(
name|COVER_ctx_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|void
modifier|*
name|group
parameter_list|,
specifier|const
name|void
modifier|*
name|groupEnd
parameter_list|)
block|{
comment|/* The group consists of all the positions with the same first d bytes. */
specifier|const
name|U32
modifier|*
name|grpPtr
init|=
operator|(
specifier|const
name|U32
operator|*
operator|)
name|group
decl_stmt|;
specifier|const
name|U32
modifier|*
name|grpEnd
init|=
operator|(
specifier|const
name|U32
operator|*
operator|)
name|groupEnd
decl_stmt|;
comment|/* The dmerId is how we will reference this dmer.    * This allows us to map the whole dmer space to a much smaller space, the    * size of the suffix array.    */
specifier|const
name|U32
name|dmerId
init|=
call|(
name|U32
call|)
argument_list|(
name|grpPtr
operator|-
name|ctx
operator|->
name|suffix
argument_list|)
decl_stmt|;
comment|/* Count the number of samples this dmer shows up in */
name|U32
name|freq
init|=
literal|0
decl_stmt|;
comment|/* Details */
specifier|const
name|size_t
modifier|*
name|curOffsetPtr
init|=
name|ctx
operator|->
name|offsets
decl_stmt|;
specifier|const
name|size_t
modifier|*
name|offsetsEnd
init|=
name|ctx
operator|->
name|offsets
operator|+
name|ctx
operator|->
name|nbSamples
decl_stmt|;
comment|/* Once *grpPtr>= curSampleEnd this occurrence of the dmer is in a    * different sample than the last.    */
name|size_t
name|curSampleEnd
init|=
name|ctx
operator|->
name|offsets
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
init|;
name|grpPtr
operator|!=
name|grpEnd
condition|;
operator|++
name|grpPtr
control|)
block|{
comment|/* Save the dmerId for this position so we can get back to it. */
name|ctx
operator|->
name|dmerAt
index|[
operator|*
name|grpPtr
index|]
operator|=
name|dmerId
expr_stmt|;
comment|/* Dictionaries only help for the first reference to the dmer.      * After that zstd can reference the match from the previous reference.      * So only count each dmer once for each sample it is in.      */
if|if
condition|(
operator|*
name|grpPtr
operator|<
name|curSampleEnd
condition|)
block|{
continue|continue;
block|}
name|freq
operator|+=
literal|1
expr_stmt|;
comment|/* Binary search to find the end of the sample *grpPtr is in.      * In the common case that grpPtr + 1 == grpEnd we can skip the binary      * search because the loop is over.      */
if|if
condition|(
name|grpPtr
operator|+
literal|1
operator|!=
name|grpEnd
condition|)
block|{
specifier|const
name|size_t
modifier|*
name|sampleEndPtr
init|=
name|COVER_lower_bound
argument_list|(
name|curOffsetPtr
argument_list|,
name|offsetsEnd
argument_list|,
operator|*
name|grpPtr
argument_list|)
decl_stmt|;
name|curSampleEnd
operator|=
operator|*
name|sampleEndPtr
expr_stmt|;
name|curOffsetPtr
operator|=
name|sampleEndPtr
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|/* At this point we are never going to look at this segment of the suffix    * array again.  We take advantage of this fact to save memory.    * We store the frequency of the dmer in the first position of the group,    * which is dmerId.    */
name|ctx
operator|->
name|suffix
index|[
name|dmerId
index|]
operator|=
name|freq
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * A segment is a range in the source as well as the score of the segment.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|U32
name|begin
decl_stmt|;
name|U32
name|end
decl_stmt|;
name|double
name|score
decl_stmt|;
block|}
name|COVER_segment_t
typedef|;
end_typedef

begin_comment
comment|/**  * Selects the best segment in an epoch.  * Segments of are scored according to the function:  *  * Let F(d) be the frequency of dmer d.  * Let S_i be the dmer at position i of segment S which has length k.  *  *     Score(S) = F(S_1) + F(S_2) + ... + F(S_{k-d+1})  *  * Once the dmer d is in the dictionay we set F(d) = 0.  */
end_comment

begin_function
specifier|static
name|COVER_segment_t
name|COVER_selectSegment
parameter_list|(
specifier|const
name|COVER_ctx_t
modifier|*
name|ctx
parameter_list|,
name|U32
modifier|*
name|freqs
parameter_list|,
name|COVER_map_t
modifier|*
name|activeDmers
parameter_list|,
name|U32
name|begin
parameter_list|,
name|U32
name|end
parameter_list|,
name|ZDICT_cover_params_t
name|parameters
parameter_list|)
block|{
comment|/* Constants */
specifier|const
name|U32
name|k
init|=
name|parameters
operator|.
name|k
decl_stmt|;
specifier|const
name|U32
name|d
init|=
name|parameters
operator|.
name|d
decl_stmt|;
specifier|const
name|U32
name|dmersInK
init|=
name|k
operator|-
name|d
operator|+
literal|1
decl_stmt|;
comment|/* Try each segment (activeSegment) and save the best (bestSegment) */
name|COVER_segment_t
name|bestSegment
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|COVER_segment_t
name|activeSegment
decl_stmt|;
comment|/* Reset the activeDmers in the segment */
name|COVER_map_clear
argument_list|(
name|activeDmers
argument_list|)
expr_stmt|;
comment|/* The activeSegment starts at the beginning of the epoch. */
name|activeSegment
operator|.
name|begin
operator|=
name|begin
expr_stmt|;
name|activeSegment
operator|.
name|end
operator|=
name|begin
expr_stmt|;
name|activeSegment
operator|.
name|score
operator|=
literal|0
expr_stmt|;
comment|/* Slide the activeSegment through the whole epoch.    * Save the best segment in bestSegment.    */
while|while
condition|(
name|activeSegment
operator|.
name|end
operator|<
name|end
condition|)
block|{
comment|/* The dmerId for the dmer at the next position */
name|U32
name|newDmer
init|=
name|ctx
operator|->
name|dmerAt
index|[
name|activeSegment
operator|.
name|end
index|]
decl_stmt|;
comment|/* The entry in activeDmers for this dmerId */
name|U32
modifier|*
name|newDmerOcc
init|=
name|COVER_map_at
argument_list|(
name|activeDmers
argument_list|,
name|newDmer
argument_list|)
decl_stmt|;
comment|/* If the dmer isn't already present in the segment add its score. */
if|if
condition|(
operator|*
name|newDmerOcc
operator|==
literal|0
condition|)
block|{
comment|/* The paper suggest using the L-0.5 norm, but experiments show that it        * doesn't help.        */
name|activeSegment
operator|.
name|score
operator|+=
name|freqs
index|[
name|newDmer
index|]
expr_stmt|;
block|}
comment|/* Add the dmer to the segment */
name|activeSegment
operator|.
name|end
operator|+=
literal|1
expr_stmt|;
operator|*
name|newDmerOcc
operator|+=
literal|1
expr_stmt|;
comment|/* If the window is now too large, drop the first position */
if|if
condition|(
name|activeSegment
operator|.
name|end
operator|-
name|activeSegment
operator|.
name|begin
operator|==
name|dmersInK
operator|+
literal|1
condition|)
block|{
name|U32
name|delDmer
init|=
name|ctx
operator|->
name|dmerAt
index|[
name|activeSegment
operator|.
name|begin
index|]
decl_stmt|;
name|U32
modifier|*
name|delDmerOcc
init|=
name|COVER_map_at
argument_list|(
name|activeDmers
argument_list|,
name|delDmer
argument_list|)
decl_stmt|;
name|activeSegment
operator|.
name|begin
operator|+=
literal|1
expr_stmt|;
operator|*
name|delDmerOcc
operator|-=
literal|1
expr_stmt|;
comment|/* If this is the last occurence of the dmer, subtract its score */
if|if
condition|(
operator|*
name|delDmerOcc
operator|==
literal|0
condition|)
block|{
name|COVER_map_remove
argument_list|(
name|activeDmers
argument_list|,
name|delDmer
argument_list|)
expr_stmt|;
name|activeSegment
operator|.
name|score
operator|-=
name|freqs
index|[
name|delDmer
index|]
expr_stmt|;
block|}
block|}
comment|/* If this segment is the best so far save it */
if|if
condition|(
name|activeSegment
operator|.
name|score
operator|>
name|bestSegment
operator|.
name|score
condition|)
block|{
name|bestSegment
operator|=
name|activeSegment
expr_stmt|;
block|}
block|}
block|{
comment|/* Trim off the zero frequency head and tail from the segment. */
name|U32
name|newBegin
init|=
name|bestSegment
operator|.
name|end
decl_stmt|;
name|U32
name|newEnd
init|=
name|bestSegment
operator|.
name|begin
decl_stmt|;
name|U32
name|pos
decl_stmt|;
for|for
control|(
name|pos
operator|=
name|bestSegment
operator|.
name|begin
init|;
name|pos
operator|!=
name|bestSegment
operator|.
name|end
condition|;
operator|++
name|pos
control|)
block|{
name|U32
name|freq
init|=
name|freqs
index|[
name|ctx
operator|->
name|dmerAt
index|[
name|pos
index|]
index|]
decl_stmt|;
if|if
condition|(
name|freq
operator|!=
literal|0
condition|)
block|{
name|newBegin
operator|=
name|MIN
argument_list|(
name|newBegin
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|newEnd
operator|=
name|pos
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|bestSegment
operator|.
name|begin
operator|=
name|newBegin
expr_stmt|;
name|bestSegment
operator|.
name|end
operator|=
name|newEnd
expr_stmt|;
block|}
block|{
comment|/* Zero out the frequency of each dmer covered by the chosen segment. */
name|U32
name|pos
decl_stmt|;
for|for
control|(
name|pos
operator|=
name|bestSegment
operator|.
name|begin
init|;
name|pos
operator|!=
name|bestSegment
operator|.
name|end
condition|;
operator|++
name|pos
control|)
block|{
name|freqs
index|[
name|ctx
operator|->
name|dmerAt
index|[
name|pos
index|]
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|bestSegment
return|;
block|}
end_function

begin_comment
comment|/**  * Check the validity of the parameters.  * Returns non-zero if the parameters are valid and 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|COVER_checkParameters
parameter_list|(
name|ZDICT_cover_params_t
name|parameters
parameter_list|)
block|{
comment|/* k and d are required parameters */
if|if
condition|(
name|parameters
operator|.
name|d
operator|==
literal|0
operator|||
name|parameters
operator|.
name|k
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* d<= k */
if|if
condition|(
name|parameters
operator|.
name|d
operator|>
name|parameters
operator|.
name|k
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Clean up a context initialized with `COVER_ctx_init()`.  */
end_comment

begin_function
specifier|static
name|void
name|COVER_ctx_destroy
parameter_list|(
name|COVER_ctx_t
modifier|*
name|ctx
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ctx
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|ctx
operator|->
name|suffix
condition|)
block|{
name|free
argument_list|(
name|ctx
operator|->
name|suffix
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|suffix
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ctx
operator|->
name|freqs
condition|)
block|{
name|free
argument_list|(
name|ctx
operator|->
name|freqs
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|freqs
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ctx
operator|->
name|dmerAt
condition|)
block|{
name|free
argument_list|(
name|ctx
operator|->
name|dmerAt
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|dmerAt
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ctx
operator|->
name|offsets
condition|)
block|{
name|free
argument_list|(
name|ctx
operator|->
name|offsets
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|offsets
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Prepare a context for dictionary building.  * The context is only dependent on the parameter `d` and can used multiple  * times.  * Returns 1 on success or zero on error.  * The context must be destroyed with `COVER_ctx_destroy()`.  */
end_comment

begin_function
specifier|static
name|int
name|COVER_ctx_init
parameter_list|(
name|COVER_ctx_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|void
modifier|*
name|samplesBuffer
parameter_list|,
specifier|const
name|size_t
modifier|*
name|samplesSizes
parameter_list|,
name|unsigned
name|nbSamples
parameter_list|,
name|unsigned
name|d
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|samples
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|samplesBuffer
decl_stmt|;
specifier|const
name|size_t
name|totalSamplesSize
init|=
name|COVER_sum
argument_list|(
name|samplesSizes
argument_list|,
name|nbSamples
argument_list|)
decl_stmt|;
comment|/* Checks */
if|if
condition|(
name|totalSamplesSize
operator|<
name|MAX
argument_list|(
name|d
argument_list|,
sizeof|sizeof
argument_list|(
name|U64
argument_list|)
argument_list|)
operator|||
name|totalSamplesSize
operator|>=
operator|(
name|size_t
operator|)
name|COVER_MAX_SAMPLES_SIZE
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"Total samples size is too large, maximum size is %u MB\n"
argument_list|,
operator|(
name|COVER_MAX_SAMPLES_SIZE
operator|>>
literal|20
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Zero the context */
name|memset
argument_list|(
name|ctx
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"Training on %u samples of total size %u\n"
argument_list|,
name|nbSamples
argument_list|,
operator|(
name|U32
operator|)
name|totalSamplesSize
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|samples
operator|=
name|samples
expr_stmt|;
name|ctx
operator|->
name|samplesSizes
operator|=
name|samplesSizes
expr_stmt|;
name|ctx
operator|->
name|nbSamples
operator|=
name|nbSamples
expr_stmt|;
comment|/* Partial suffix array */
name|ctx
operator|->
name|suffixSize
operator|=
name|totalSamplesSize
operator|-
name|MAX
argument_list|(
name|d
argument_list|,
sizeof|sizeof
argument_list|(
name|U64
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
name|ctx
operator|->
name|suffix
operator|=
operator|(
name|U32
operator|*
operator|)
name|malloc
argument_list|(
name|ctx
operator|->
name|suffixSize
operator|*
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Maps index to the dmerID */
name|ctx
operator|->
name|dmerAt
operator|=
operator|(
name|U32
operator|*
operator|)
name|malloc
argument_list|(
name|ctx
operator|->
name|suffixSize
operator|*
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The offsets of each file */
name|ctx
operator|->
name|offsets
operator|=
operator|(
name|size_t
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|nbSamples
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|suffix
operator|||
operator|!
name|ctx
operator|->
name|dmerAt
operator|||
operator|!
name|ctx
operator|->
name|offsets
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"Failed to allocate scratch buffers\n"
argument_list|)
expr_stmt|;
name|COVER_ctx_destroy
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ctx
operator|->
name|freqs
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|d
operator|=
name|d
expr_stmt|;
comment|/* Fill offsets from the samlesSizes */
block|{
name|U32
name|i
decl_stmt|;
name|ctx
operator|->
name|offsets
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nbSamples
condition|;
operator|++
name|i
control|)
block|{
name|ctx
operator|->
name|offsets
index|[
name|i
index|]
operator|=
name|ctx
operator|->
name|offsets
index|[
name|i
operator|-
literal|1
index|]
operator|+
name|samplesSizes
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
block|}
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"Constructing partial suffix array\n"
argument_list|)
expr_stmt|;
block|{
comment|/* suffix is a partial suffix array.      * It only sorts suffixes by their first parameters.d bytes.      * The sort is stable, so each dmer group is sorted by position in input.      */
name|U32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ctx
operator|->
name|suffixSize
condition|;
operator|++
name|i
control|)
block|{
name|ctx
operator|->
name|suffix
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
comment|/* qsort doesn't take an opaque pointer, so pass as a global */
name|g_ctx
operator|=
name|ctx
expr_stmt|;
name|qsort
argument_list|(
name|ctx
operator|->
name|suffix
argument_list|,
name|ctx
operator|->
name|suffixSize
argument_list|,
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
argument_list|,
operator|(
name|ctx
operator|->
name|d
operator|<=
literal|8
condition|?
operator|&
name|COVER_strict_cmp8
else|:
operator|&
name|COVER_strict_cmp
operator|)
argument_list|)
expr_stmt|;
block|}
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"Computing frequencies\n"
argument_list|)
expr_stmt|;
comment|/* For each dmer group (group of positions with the same first d bytes):    * 1. For each position we set dmerAt[position] = dmerID.  The dmerID is    *    (groupBeginPtr - suffix).  This allows us to go from position to    *    dmerID so we can look up values in freq.    * 2. We calculate how many samples the dmer occurs in and save it in    *    freqs[dmerId].    */
name|COVER_groupBy
argument_list|(
name|ctx
operator|->
name|suffix
argument_list|,
name|ctx
operator|->
name|suffixSize
argument_list|,
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
argument_list|,
name|ctx
argument_list|,
operator|(
name|ctx
operator|->
name|d
operator|<=
literal|8
condition|?
operator|&
name|COVER_cmp8
else|:
operator|&
name|COVER_cmp
operator|)
argument_list|,
operator|&
name|COVER_group
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|freqs
operator|=
name|ctx
operator|->
name|suffix
expr_stmt|;
name|ctx
operator|->
name|suffix
operator|=
name|NULL
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Given the prepared context build the dictionary.  */
end_comment

begin_function
specifier|static
name|size_t
name|COVER_buildDictionary
parameter_list|(
specifier|const
name|COVER_ctx_t
modifier|*
name|ctx
parameter_list|,
name|U32
modifier|*
name|freqs
parameter_list|,
name|COVER_map_t
modifier|*
name|activeDmers
parameter_list|,
name|void
modifier|*
name|dictBuffer
parameter_list|,
name|size_t
name|dictBufferCapacity
parameter_list|,
name|ZDICT_cover_params_t
name|parameters
parameter_list|)
block|{
name|BYTE
modifier|*
specifier|const
name|dict
init|=
operator|(
name|BYTE
operator|*
operator|)
name|dictBuffer
decl_stmt|;
name|size_t
name|tail
init|=
name|dictBufferCapacity
decl_stmt|;
comment|/* Divide the data up into epochs of equal size.    * We will select at least one segment from each epoch.    */
specifier|const
name|U32
name|epochs
init|=
call|(
name|U32
call|)
argument_list|(
name|dictBufferCapacity
operator|/
name|parameters
operator|.
name|k
argument_list|)
decl_stmt|;
specifier|const
name|U32
name|epochSize
init|=
call|(
name|U32
call|)
argument_list|(
name|ctx
operator|->
name|suffixSize
operator|/
name|epochs
argument_list|)
decl_stmt|;
name|size_t
name|epoch
decl_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"Breaking content into %u epochs of size %u\n"
argument_list|,
name|epochs
argument_list|,
name|epochSize
argument_list|)
expr_stmt|;
comment|/* Loop through the epochs until there are no more segments or the dictionary    * is full.    */
for|for
control|(
name|epoch
operator|=
literal|0
init|;
name|tail
operator|>
literal|0
condition|;
name|epoch
operator|=
operator|(
name|epoch
operator|+
literal|1
operator|)
operator|%
name|epochs
control|)
block|{
specifier|const
name|U32
name|epochBegin
init|=
call|(
name|U32
call|)
argument_list|(
name|epoch
operator|*
name|epochSize
argument_list|)
decl_stmt|;
specifier|const
name|U32
name|epochEnd
init|=
name|epochBegin
operator|+
name|epochSize
decl_stmt|;
name|size_t
name|segmentSize
decl_stmt|;
comment|/* Select a segment */
name|COVER_segment_t
name|segment
init|=
name|COVER_selectSegment
argument_list|(
name|ctx
argument_list|,
name|freqs
argument_list|,
name|activeDmers
argument_list|,
name|epochBegin
argument_list|,
name|epochEnd
argument_list|,
name|parameters
argument_list|)
decl_stmt|;
comment|/* Trim the segment if necessary and if it is empty then we are done */
name|segmentSize
operator|=
name|MIN
argument_list|(
name|segment
operator|.
name|end
operator|-
name|segment
operator|.
name|begin
operator|+
name|parameters
operator|.
name|d
operator|-
literal|1
argument_list|,
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|segmentSize
operator|==
literal|0
condition|)
block|{
break|break;
block|}
comment|/* We fill the dictionary from the back to allow the best segments to be      * referenced with the smallest offsets.      */
name|tail
operator|-=
name|segmentSize
expr_stmt|;
name|memcpy
argument_list|(
name|dict
operator|+
name|tail
argument_list|,
name|ctx
operator|->
name|samples
operator|+
name|segment
operator|.
name|begin
argument_list|,
name|segmentSize
argument_list|)
expr_stmt|;
name|DISPLAYUPDATE
argument_list|(
literal|2
argument_list|,
literal|"\r%u%%       "
argument_list|,
call|(
name|U32
call|)
argument_list|(
operator|(
operator|(
name|dictBufferCapacity
operator|-
name|tail
operator|)
operator|*
literal|100
operator|)
operator|/
name|dictBufferCapacity
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"\r%79s\r"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
name|tail
return|;
block|}
end_function

begin_function
name|ZDICTLIB_API
name|size_t
name|ZDICT_trainFromBuffer_cover
parameter_list|(
name|void
modifier|*
name|dictBuffer
parameter_list|,
name|size_t
name|dictBufferCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|samplesBuffer
parameter_list|,
specifier|const
name|size_t
modifier|*
name|samplesSizes
parameter_list|,
name|unsigned
name|nbSamples
parameter_list|,
name|ZDICT_cover_params_t
name|parameters
parameter_list|)
block|{
name|BYTE
modifier|*
specifier|const
name|dict
init|=
operator|(
name|BYTE
operator|*
operator|)
name|dictBuffer
decl_stmt|;
name|COVER_ctx_t
name|ctx
decl_stmt|;
name|COVER_map_t
name|activeDmers
decl_stmt|;
comment|/* Checks */
if|if
condition|(
operator|!
name|COVER_checkParameters
argument_list|(
name|parameters
argument_list|)
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"Cover parameters incorrect\n"
argument_list|)
expr_stmt|;
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
block|}
if|if
condition|(
name|nbSamples
operator|==
literal|0
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"Cover must have at least one input file\n"
argument_list|)
expr_stmt|;
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
block|}
if|if
condition|(
name|dictBufferCapacity
operator|<
name|ZDICT_DICTSIZE_MIN
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"dictBufferCapacity must be at least %u\n"
argument_list|,
name|ZDICT_DICTSIZE_MIN
argument_list|)
expr_stmt|;
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
block|}
comment|/* Initialize global data */
name|g_displayLevel
operator|=
name|parameters
operator|.
name|zParams
operator|.
name|notificationLevel
expr_stmt|;
comment|/* Initialize context and activeDmers */
if|if
condition|(
operator|!
name|COVER_ctx_init
argument_list|(
operator|&
name|ctx
argument_list|,
name|samplesBuffer
argument_list|,
name|samplesSizes
argument_list|,
name|nbSamples
argument_list|,
name|parameters
operator|.
name|d
argument_list|)
condition|)
block|{
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|COVER_map_init
argument_list|(
operator|&
name|activeDmers
argument_list|,
name|parameters
operator|.
name|k
operator|-
name|parameters
operator|.
name|d
operator|+
literal|1
argument_list|)
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"Failed to allocate dmer map: out of memory\n"
argument_list|)
expr_stmt|;
name|COVER_ctx_destroy
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
block|}
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"Building dictionary\n"
argument_list|)
expr_stmt|;
block|{
specifier|const
name|size_t
name|tail
init|=
name|COVER_buildDictionary
argument_list|(
operator|&
name|ctx
argument_list|,
name|ctx
operator|.
name|freqs
argument_list|,
operator|&
name|activeDmers
argument_list|,
name|dictBuffer
argument_list|,
name|dictBufferCapacity
argument_list|,
name|parameters
argument_list|)
decl_stmt|;
specifier|const
name|size_t
name|dictionarySize
init|=
name|ZDICT_finalizeDictionary
argument_list|(
name|dict
argument_list|,
name|dictBufferCapacity
argument_list|,
name|dict
operator|+
name|tail
argument_list|,
name|dictBufferCapacity
operator|-
name|tail
argument_list|,
name|samplesBuffer
argument_list|,
name|samplesSizes
argument_list|,
name|nbSamples
argument_list|,
name|parameters
operator|.
name|zParams
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ZSTD_isError
argument_list|(
name|dictionarySize
argument_list|)
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"Constructed dictionary of size %u\n"
argument_list|,
operator|(
name|U32
operator|)
name|dictionarySize
argument_list|)
expr_stmt|;
block|}
name|COVER_ctx_destroy
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|COVER_map_destroy
argument_list|(
operator|&
name|activeDmers
argument_list|)
expr_stmt|;
return|return
name|dictionarySize
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * COVER_best_t is used for two purposes:  * 1. Synchronizing threads.  * 2. Saving the best parameters and dictionary.  *  * All of the methods except COVER_best_init() are thread safe if zstd is  * compiled with multithreaded support.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|COVER_best_s
block|{
name|pthread_mutex_t
name|mutex
decl_stmt|;
name|pthread_cond_t
name|cond
decl_stmt|;
name|size_t
name|liveJobs
decl_stmt|;
name|void
modifier|*
name|dict
decl_stmt|;
name|size_t
name|dictSize
decl_stmt|;
name|ZDICT_cover_params_t
name|parameters
decl_stmt|;
name|size_t
name|compressedSize
decl_stmt|;
block|}
name|COVER_best_t
typedef|;
end_typedef

begin_comment
comment|/**  * Initialize the `COVER_best_t`.  */
end_comment

begin_function
specifier|static
name|void
name|COVER_best_init
parameter_list|(
name|COVER_best_t
modifier|*
name|best
parameter_list|)
block|{
if|if
condition|(
operator|!
name|best
condition|)
block|{
return|return;
block|}
name|pthread_mutex_init
argument_list|(
operator|&
name|best
operator|->
name|mutex
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pthread_cond_init
argument_list|(
operator|&
name|best
operator|->
name|cond
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|best
operator|->
name|liveJobs
operator|=
literal|0
expr_stmt|;
name|best
operator|->
name|dict
operator|=
name|NULL
expr_stmt|;
name|best
operator|->
name|dictSize
operator|=
literal|0
expr_stmt|;
name|best
operator|->
name|compressedSize
operator|=
operator|(
name|size_t
operator|)
operator|-
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|&
name|best
operator|->
name|parameters
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|best
operator|->
name|parameters
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Wait until liveJobs == 0.  */
end_comment

begin_function
specifier|static
name|void
name|COVER_best_wait
parameter_list|(
name|COVER_best_t
modifier|*
name|best
parameter_list|)
block|{
if|if
condition|(
operator|!
name|best
condition|)
block|{
return|return;
block|}
name|pthread_mutex_lock
argument_list|(
operator|&
name|best
operator|->
name|mutex
argument_list|)
expr_stmt|;
while|while
condition|(
name|best
operator|->
name|liveJobs
operator|!=
literal|0
condition|)
block|{
name|pthread_cond_wait
argument_list|(
operator|&
name|best
operator|->
name|cond
argument_list|,
operator|&
name|best
operator|->
name|mutex
argument_list|)
expr_stmt|;
block|}
name|pthread_mutex_unlock
argument_list|(
operator|&
name|best
operator|->
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Call COVER_best_wait() and then destroy the COVER_best_t.  */
end_comment

begin_function
specifier|static
name|void
name|COVER_best_destroy
parameter_list|(
name|COVER_best_t
modifier|*
name|best
parameter_list|)
block|{
if|if
condition|(
operator|!
name|best
condition|)
block|{
return|return;
block|}
name|COVER_best_wait
argument_list|(
name|best
argument_list|)
expr_stmt|;
if|if
condition|(
name|best
operator|->
name|dict
condition|)
block|{
name|free
argument_list|(
name|best
operator|->
name|dict
argument_list|)
expr_stmt|;
block|}
name|pthread_mutex_destroy
argument_list|(
operator|&
name|best
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|pthread_cond_destroy
argument_list|(
operator|&
name|best
operator|->
name|cond
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Called when a thread is about to be launched.  * Increments liveJobs.  */
end_comment

begin_function
specifier|static
name|void
name|COVER_best_start
parameter_list|(
name|COVER_best_t
modifier|*
name|best
parameter_list|)
block|{
if|if
condition|(
operator|!
name|best
condition|)
block|{
return|return;
block|}
name|pthread_mutex_lock
argument_list|(
operator|&
name|best
operator|->
name|mutex
argument_list|)
expr_stmt|;
operator|++
name|best
operator|->
name|liveJobs
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
name|best
operator|->
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Called when a thread finishes executing, both on error or success.  * Decrements liveJobs and signals any waiting threads if liveJobs == 0.  * If this dictionary is the best so far save it and its parameters.  */
end_comment

begin_function
specifier|static
name|void
name|COVER_best_finish
parameter_list|(
name|COVER_best_t
modifier|*
name|best
parameter_list|,
name|size_t
name|compressedSize
parameter_list|,
name|ZDICT_cover_params_t
name|parameters
parameter_list|,
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|)
block|{
if|if
condition|(
operator|!
name|best
condition|)
block|{
return|return;
block|}
block|{
name|size_t
name|liveJobs
decl_stmt|;
name|pthread_mutex_lock
argument_list|(
operator|&
name|best
operator|->
name|mutex
argument_list|)
expr_stmt|;
operator|--
name|best
operator|->
name|liveJobs
expr_stmt|;
name|liveJobs
operator|=
name|best
operator|->
name|liveJobs
expr_stmt|;
comment|/* If the new dictionary is better */
if|if
condition|(
name|compressedSize
operator|<
name|best
operator|->
name|compressedSize
condition|)
block|{
comment|/* Allocate space if necessary */
if|if
condition|(
operator|!
name|best
operator|->
name|dict
operator|||
name|best
operator|->
name|dictSize
operator|<
name|dictSize
condition|)
block|{
if|if
condition|(
name|best
operator|->
name|dict
condition|)
block|{
name|free
argument_list|(
name|best
operator|->
name|dict
argument_list|)
expr_stmt|;
block|}
name|best
operator|->
name|dict
operator|=
name|malloc
argument_list|(
name|dictSize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|best
operator|->
name|dict
condition|)
block|{
name|best
operator|->
name|compressedSize
operator|=
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
expr_stmt|;
name|best
operator|->
name|dictSize
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
comment|/* Save the dictionary, parameters, and size */
name|memcpy
argument_list|(
name|best
operator|->
name|dict
argument_list|,
name|dict
argument_list|,
name|dictSize
argument_list|)
expr_stmt|;
name|best
operator|->
name|dictSize
operator|=
name|dictSize
expr_stmt|;
name|best
operator|->
name|parameters
operator|=
name|parameters
expr_stmt|;
name|best
operator|->
name|compressedSize
operator|=
name|compressedSize
expr_stmt|;
block|}
name|pthread_mutex_unlock
argument_list|(
operator|&
name|best
operator|->
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|liveJobs
operator|==
literal|0
condition|)
block|{
name|pthread_cond_broadcast
argument_list|(
operator|&
name|best
operator|->
name|cond
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * Parameters for COVER_tryParameters().  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|COVER_tryParameters_data_s
block|{
specifier|const
name|COVER_ctx_t
modifier|*
name|ctx
decl_stmt|;
name|COVER_best_t
modifier|*
name|best
decl_stmt|;
name|size_t
name|dictBufferCapacity
decl_stmt|;
name|ZDICT_cover_params_t
name|parameters
decl_stmt|;
block|}
name|COVER_tryParameters_data_t
typedef|;
end_typedef

begin_comment
comment|/**  * Tries a set of parameters and upates the COVER_best_t with the results.  * This function is thread safe if zstd is compiled with multithreaded support.  * It takes its parameters as an *OWNING* opaque pointer to support threading.  */
end_comment

begin_function
specifier|static
name|void
name|COVER_tryParameters
parameter_list|(
name|void
modifier|*
name|opaque
parameter_list|)
block|{
comment|/* Save parameters as local variables */
name|COVER_tryParameters_data_t
modifier|*
specifier|const
name|data
init|=
operator|(
name|COVER_tryParameters_data_t
operator|*
operator|)
name|opaque
decl_stmt|;
specifier|const
name|COVER_ctx_t
modifier|*
specifier|const
name|ctx
init|=
name|data
operator|->
name|ctx
decl_stmt|;
specifier|const
name|ZDICT_cover_params_t
name|parameters
init|=
name|data
operator|->
name|parameters
decl_stmt|;
name|size_t
name|dictBufferCapacity
init|=
name|data
operator|->
name|dictBufferCapacity
decl_stmt|;
name|size_t
name|totalCompressedSize
init|=
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
decl_stmt|;
comment|/* Allocate space for hash table, dict, and freqs */
name|COVER_map_t
name|activeDmers
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|dict
init|=
operator|(
name|BYTE
operator|*
specifier|const
operator|)
name|malloc
argument_list|(
name|dictBufferCapacity
argument_list|)
decl_stmt|;
name|U32
modifier|*
name|freqs
init|=
operator|(
name|U32
operator|*
operator|)
name|malloc
argument_list|(
name|ctx
operator|->
name|suffixSize
operator|*
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|COVER_map_init
argument_list|(
operator|&
name|activeDmers
argument_list|,
name|parameters
operator|.
name|k
operator|-
name|parameters
operator|.
name|d
operator|+
literal|1
argument_list|)
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"Failed to allocate dmer map: out of memory\n"
argument_list|)
expr_stmt|;
goto|goto
name|_cleanup
goto|;
block|}
if|if
condition|(
operator|!
name|dict
operator|||
operator|!
name|freqs
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"Failed to allocate buffers: out of memory\n"
argument_list|)
expr_stmt|;
goto|goto
name|_cleanup
goto|;
block|}
comment|/* Copy the frequencies because we need to modify them */
name|memcpy
argument_list|(
name|freqs
argument_list|,
name|ctx
operator|->
name|freqs
argument_list|,
name|ctx
operator|->
name|suffixSize
operator|*
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Build the dictionary */
block|{
specifier|const
name|size_t
name|tail
init|=
name|COVER_buildDictionary
argument_list|(
name|ctx
argument_list|,
name|freqs
argument_list|,
operator|&
name|activeDmers
argument_list|,
name|dict
argument_list|,
name|dictBufferCapacity
argument_list|,
name|parameters
argument_list|)
decl_stmt|;
name|dictBufferCapacity
operator|=
name|ZDICT_finalizeDictionary
argument_list|(
name|dict
argument_list|,
name|dictBufferCapacity
argument_list|,
name|dict
operator|+
name|tail
argument_list|,
name|dictBufferCapacity
operator|-
name|tail
argument_list|,
name|ctx
operator|->
name|samples
argument_list|,
name|ctx
operator|->
name|samplesSizes
argument_list|,
operator|(
name|unsigned
operator|)
name|ctx
operator|->
name|nbSamples
argument_list|,
name|parameters
operator|.
name|zParams
argument_list|)
expr_stmt|;
if|if
condition|(
name|ZDICT_isError
argument_list|(
name|dictBufferCapacity
argument_list|)
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"Failed to finalize dictionary\n"
argument_list|)
expr_stmt|;
goto|goto
name|_cleanup
goto|;
block|}
block|}
comment|/* Check total compressed size */
block|{
comment|/* Pointers */
name|ZSTD_CCtx
modifier|*
name|cctx
decl_stmt|;
name|ZSTD_CDict
modifier|*
name|cdict
decl_stmt|;
name|void
modifier|*
name|dst
decl_stmt|;
comment|/* Local variables */
name|size_t
name|dstCapacity
decl_stmt|;
name|size_t
name|i
decl_stmt|;
comment|/* Allocate dst with enough space to compress the maximum sized sample */
block|{
name|size_t
name|maxSampleSize
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ctx
operator|->
name|nbSamples
condition|;
operator|++
name|i
control|)
block|{
name|maxSampleSize
operator|=
name|MAX
argument_list|(
name|ctx
operator|->
name|samplesSizes
index|[
name|i
index|]
argument_list|,
name|maxSampleSize
argument_list|)
expr_stmt|;
block|}
name|dstCapacity
operator|=
name|ZSTD_compressBound
argument_list|(
name|maxSampleSize
argument_list|)
expr_stmt|;
name|dst
operator|=
name|malloc
argument_list|(
name|dstCapacity
argument_list|)
expr_stmt|;
block|}
comment|/* Create the cctx and cdict */
name|cctx
operator|=
name|ZSTD_createCCtx
argument_list|()
expr_stmt|;
name|cdict
operator|=
name|ZSTD_createCDict
argument_list|(
name|dict
argument_list|,
name|dictBufferCapacity
argument_list|,
name|parameters
operator|.
name|zParams
operator|.
name|compressionLevel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dst
operator|||
operator|!
name|cctx
operator|||
operator|!
name|cdict
condition|)
block|{
goto|goto
name|_compressCleanup
goto|;
block|}
comment|/* Compress each sample and sum their sizes (or error) */
name|totalCompressedSize
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ctx
operator|->
name|nbSamples
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|size_t
name|size
init|=
name|ZSTD_compress_usingCDict
argument_list|(
name|cctx
argument_list|,
name|dst
argument_list|,
name|dstCapacity
argument_list|,
name|ctx
operator|->
name|samples
operator|+
name|ctx
operator|->
name|offsets
index|[
name|i
index|]
argument_list|,
name|ctx
operator|->
name|samplesSizes
index|[
name|i
index|]
argument_list|,
name|cdict
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|size
argument_list|)
condition|)
block|{
name|totalCompressedSize
operator|=
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
expr_stmt|;
goto|goto
name|_compressCleanup
goto|;
block|}
name|totalCompressedSize
operator|+=
name|size
expr_stmt|;
block|}
name|_compressCleanup
label|:
name|ZSTD_freeCCtx
argument_list|(
name|cctx
argument_list|)
expr_stmt|;
name|ZSTD_freeCDict
argument_list|(
name|cdict
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
condition|)
block|{
name|free
argument_list|(
name|dst
argument_list|)
expr_stmt|;
block|}
block|}
name|_cleanup
label|:
name|COVER_best_finish
argument_list|(
name|data
operator|->
name|best
argument_list|,
name|totalCompressedSize
argument_list|,
name|parameters
argument_list|,
name|dict
argument_list|,
name|dictBufferCapacity
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|COVER_map_destroy
argument_list|(
operator|&
name|activeDmers
argument_list|)
expr_stmt|;
if|if
condition|(
name|dict
condition|)
block|{
name|free
argument_list|(
name|dict
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|freqs
condition|)
block|{
name|free
argument_list|(
name|freqs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|ZDICTLIB_API
name|size_t
name|ZDICT_optimizeTrainFromBuffer_cover
parameter_list|(
name|void
modifier|*
name|dictBuffer
parameter_list|,
name|size_t
name|dictBufferCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|samplesBuffer
parameter_list|,
specifier|const
name|size_t
modifier|*
name|samplesSizes
parameter_list|,
name|unsigned
name|nbSamples
parameter_list|,
name|ZDICT_cover_params_t
modifier|*
name|parameters
parameter_list|)
block|{
comment|/* constants */
specifier|const
name|unsigned
name|nbThreads
init|=
name|parameters
operator|->
name|nbThreads
decl_stmt|;
specifier|const
name|unsigned
name|kMinD
init|=
name|parameters
operator|->
name|d
operator|==
literal|0
condition|?
literal|6
else|:
name|parameters
operator|->
name|d
decl_stmt|;
specifier|const
name|unsigned
name|kMaxD
init|=
name|parameters
operator|->
name|d
operator|==
literal|0
condition|?
literal|8
else|:
name|parameters
operator|->
name|d
decl_stmt|;
specifier|const
name|unsigned
name|kMinK
init|=
name|parameters
operator|->
name|k
operator|==
literal|0
condition|?
literal|50
else|:
name|parameters
operator|->
name|k
decl_stmt|;
specifier|const
name|unsigned
name|kMaxK
init|=
name|parameters
operator|->
name|k
operator|==
literal|0
condition|?
literal|2000
else|:
name|parameters
operator|->
name|k
decl_stmt|;
specifier|const
name|unsigned
name|kSteps
init|=
name|parameters
operator|->
name|steps
operator|==
literal|0
condition|?
literal|40
else|:
name|parameters
operator|->
name|steps
decl_stmt|;
specifier|const
name|unsigned
name|kStepSize
init|=
name|MAX
argument_list|(
operator|(
name|kMaxK
operator|-
name|kMinK
operator|)
operator|/
name|kSteps
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|const
name|unsigned
name|kIterations
init|=
operator|(
literal|1
operator|+
operator|(
name|kMaxD
operator|-
name|kMinD
operator|)
operator|/
literal|2
operator|)
operator|*
operator|(
literal|1
operator|+
operator|(
name|kMaxK
operator|-
name|kMinK
operator|)
operator|/
name|kStepSize
operator|)
decl_stmt|;
comment|/* Local variables */
specifier|const
name|int
name|displayLevel
init|=
name|parameters
operator|->
name|zParams
operator|.
name|notificationLevel
decl_stmt|;
name|unsigned
name|iteration
init|=
literal|1
decl_stmt|;
name|unsigned
name|d
decl_stmt|;
name|unsigned
name|k
decl_stmt|;
name|COVER_best_t
name|best
decl_stmt|;
name|POOL_ctx
modifier|*
name|pool
init|=
name|NULL
decl_stmt|;
comment|/* Checks */
if|if
condition|(
name|kMinK
operator|<
name|kMaxD
operator|||
name|kMaxK
operator|<
name|kMinK
condition|)
block|{
name|LOCALDISPLAYLEVEL
argument_list|(
name|displayLevel
argument_list|,
literal|1
argument_list|,
literal|"Incorrect parameters\n"
argument_list|)
expr_stmt|;
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
block|}
if|if
condition|(
name|nbSamples
operator|==
literal|0
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"Cover must have at least one input file\n"
argument_list|)
expr_stmt|;
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
block|}
if|if
condition|(
name|dictBufferCapacity
operator|<
name|ZDICT_DICTSIZE_MIN
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"dictBufferCapacity must be at least %u\n"
argument_list|,
name|ZDICT_DICTSIZE_MIN
argument_list|)
expr_stmt|;
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
block|}
if|if
condition|(
name|nbThreads
operator|>
literal|1
condition|)
block|{
name|pool
operator|=
name|POOL_create
argument_list|(
name|nbThreads
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pool
condition|)
block|{
return|return
name|ERROR
argument_list|(
name|memory_allocation
argument_list|)
return|;
block|}
block|}
comment|/* Initialization */
name|COVER_best_init
argument_list|(
operator|&
name|best
argument_list|)
expr_stmt|;
comment|/* Turn down global display level to clean up display at level 2 and below */
name|g_displayLevel
operator|=
name|parameters
operator|->
name|zParams
operator|.
name|notificationLevel
operator|-
literal|1
expr_stmt|;
comment|/* Loop through d first because each new value needs a new context */
name|LOCALDISPLAYLEVEL
argument_list|(
name|displayLevel
argument_list|,
literal|2
argument_list|,
literal|"Trying %u different sets of parameters\n"
argument_list|,
name|kIterations
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|kMinD
init|;
name|d
operator|<=
name|kMaxD
condition|;
name|d
operator|+=
literal|2
control|)
block|{
comment|/* Initialize the context for this value of d */
name|COVER_ctx_t
name|ctx
decl_stmt|;
name|LOCALDISPLAYLEVEL
argument_list|(
name|displayLevel
argument_list|,
literal|3
argument_list|,
literal|"d=%u\n"
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|COVER_ctx_init
argument_list|(
operator|&
name|ctx
argument_list|,
name|samplesBuffer
argument_list|,
name|samplesSizes
argument_list|,
name|nbSamples
argument_list|,
name|d
argument_list|)
condition|)
block|{
name|LOCALDISPLAYLEVEL
argument_list|(
name|displayLevel
argument_list|,
literal|1
argument_list|,
literal|"Failed to initialize context\n"
argument_list|)
expr_stmt|;
name|COVER_best_destroy
argument_list|(
operator|&
name|best
argument_list|)
expr_stmt|;
name|POOL_free
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
block|}
comment|/* Loop through k reusing the same context */
for|for
control|(
name|k
operator|=
name|kMinK
init|;
name|k
operator|<=
name|kMaxK
condition|;
name|k
operator|+=
name|kStepSize
control|)
block|{
comment|/* Prepare the arguments */
name|COVER_tryParameters_data_t
modifier|*
name|data
init|=
operator|(
name|COVER_tryParameters_data_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|COVER_tryParameters_data_t
argument_list|)
argument_list|)
decl_stmt|;
name|LOCALDISPLAYLEVEL
argument_list|(
name|displayLevel
argument_list|,
literal|3
argument_list|,
literal|"k=%u\n"
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
block|{
name|LOCALDISPLAYLEVEL
argument_list|(
name|displayLevel
argument_list|,
literal|1
argument_list|,
literal|"Failed to allocate parameters\n"
argument_list|)
expr_stmt|;
name|COVER_best_destroy
argument_list|(
operator|&
name|best
argument_list|)
expr_stmt|;
name|COVER_ctx_destroy
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|POOL_free
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
block|}
name|data
operator|->
name|ctx
operator|=
operator|&
name|ctx
expr_stmt|;
name|data
operator|->
name|best
operator|=
operator|&
name|best
expr_stmt|;
name|data
operator|->
name|dictBufferCapacity
operator|=
name|dictBufferCapacity
expr_stmt|;
name|data
operator|->
name|parameters
operator|=
operator|*
name|parameters
expr_stmt|;
name|data
operator|->
name|parameters
operator|.
name|k
operator|=
name|k
expr_stmt|;
name|data
operator|->
name|parameters
operator|.
name|d
operator|=
name|d
expr_stmt|;
name|data
operator|->
name|parameters
operator|.
name|steps
operator|=
name|kSteps
expr_stmt|;
comment|/* Check the parameters */
if|if
condition|(
operator|!
name|COVER_checkParameters
argument_list|(
name|data
operator|->
name|parameters
argument_list|)
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"Cover parameters incorrect\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Call the function and pass ownership of data to it */
name|COVER_best_start
argument_list|(
operator|&
name|best
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool
condition|)
block|{
name|POOL_add
argument_list|(
name|pool
argument_list|,
operator|&
name|COVER_tryParameters
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|COVER_tryParameters
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
comment|/* Print status */
name|LOCALDISPLAYUPDATE
argument_list|(
name|displayLevel
argument_list|,
literal|2
argument_list|,
literal|"\r%u%%       "
argument_list|,
call|(
name|U32
call|)
argument_list|(
operator|(
name|iteration
operator|*
literal|100
operator|)
operator|/
name|kIterations
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|iteration
expr_stmt|;
block|}
name|COVER_best_wait
argument_list|(
operator|&
name|best
argument_list|)
expr_stmt|;
name|COVER_ctx_destroy
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
block|}
name|LOCALDISPLAYLEVEL
argument_list|(
name|displayLevel
argument_list|,
literal|2
argument_list|,
literal|"\r%79s\r"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* Fill the output buffer and parameters with output of the best parameters */
block|{
specifier|const
name|size_t
name|dictSize
init|=
name|best
operator|.
name|dictSize
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|best
operator|.
name|compressedSize
argument_list|)
condition|)
block|{
specifier|const
name|size_t
name|compressedSize
init|=
name|best
operator|.
name|compressedSize
decl_stmt|;
name|COVER_best_destroy
argument_list|(
operator|&
name|best
argument_list|)
expr_stmt|;
name|POOL_free
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|compressedSize
return|;
block|}
operator|*
name|parameters
operator|=
name|best
operator|.
name|parameters
expr_stmt|;
name|memcpy
argument_list|(
name|dictBuffer
argument_list|,
name|best
operator|.
name|dict
argument_list|,
name|dictSize
argument_list|)
expr_stmt|;
name|COVER_best_destroy
argument_list|(
operator|&
name|best
argument_list|)
expr_stmt|;
name|POOL_free
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|dictSize
return|;
block|}
block|}
end_function

end_unit

