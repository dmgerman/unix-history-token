begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright (c) 2016-present, Yann Collet, Facebook, Inc.  * All rights reserved.  *  * This source code is licensed under the BSD-style license found in the  * LICENSE file in the root directory of this source tree. An additional grant  * of patent rights can be found in the PATENTS file in the same directory.  */
end_comment

begin_comment
comment|/****************************************** *  Includes ******************************************/
end_comment

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_comment
comment|/* size_t, ptrdiff_t */
end_comment

begin_include
include|#
directive|include
file|"zstd_v01.h"
end_include

begin_include
include|#
directive|include
file|"error_private.h"
end_include

begin_comment
comment|/****************************************** *  Static allocation ******************************************/
end_comment

begin_comment
comment|/* You can statically allocate FSE CTable/DTable as a table of unsigned using below macro */
end_comment

begin_define
define|#
directive|define
name|FSE_DTABLE_SIZE_U32
parameter_list|(
name|maxTableLog
parameter_list|)
value|(1 + (1<<maxTableLog))
end_define

begin_comment
comment|/* You can statically allocate Huff0 DTable as a table of unsigned short using below macro */
end_comment

begin_define
define|#
directive|define
name|HUF_DTABLE_SIZE_U16
parameter_list|(
name|maxTableLog
parameter_list|)
value|(1 + (1<<maxTableLog))
end_define

begin_define
define|#
directive|define
name|HUF_CREATE_STATIC_DTABLE
parameter_list|(
name|DTable
parameter_list|,
name|maxTableLog
parameter_list|)
define|\
value|unsigned short DTable[HUF_DTABLE_SIZE_U16(maxTableLog)] = { maxTableLog }
end_define

begin_comment
comment|/****************************************** *  Error Management ******************************************/
end_comment

begin_define
define|#
directive|define
name|FSE_LIST_ERRORS
parameter_list|(
name|ITEM
parameter_list|)
define|\
value|ITEM(FSE_OK_NoError) ITEM(FSE_ERROR_GENERIC) \         ITEM(FSE_ERROR_tableLog_tooLarge) ITEM(FSE_ERROR_maxSymbolValue_tooLarge) ITEM(FSE_ERROR_maxSymbolValue_tooSmall) \         ITEM(FSE_ERROR_dstSize_tooSmall) ITEM(FSE_ERROR_srcSize_wrong)\         ITEM(FSE_ERROR_corruptionDetected) \         ITEM(FSE_ERROR_maxCode)
end_define

begin_define
define|#
directive|define
name|FSE_GENERATE_ENUM
parameter_list|(
name|ENUM
parameter_list|)
value|ENUM,
end_define

begin_typedef
typedef|typedef
enum|enum
block|{
name|FSE_LIST_ERRORS
argument_list|(
argument|FSE_GENERATE_ENUM
argument_list|)
block|}
name|FSE_errorCodes
typedef|;
end_typedef

begin_comment
comment|/* enum is exposed, to detect& handle specific errors; compare function result to -enum value */
end_comment

begin_comment
comment|/****************************************** *  FSE symbol compression API ******************************************/
end_comment

begin_comment
comment|/*    This API consists of small unitary functions, which highly benefit from being inlined.    You will want to enable link-time-optimization to ensure these functions are properly inlined in your binary.    Visual seems to do it automatically.    For gcc or clang, you'll need to add -flto flag at compilation and linking stages.    If none of these solutions is applicable, include "fse.c" directly. */
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|FSE_CTable
typedef|;
end_typedef

begin_comment
comment|/* don't allocate that. It's just a way to be more restrictive than void* */
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|FSE_DTable
typedef|;
end_typedef

begin_comment
comment|/* don't allocate that. It's just a way to be more restrictive than void* */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|size_t
name|bitContainer
decl_stmt|;
name|int
name|bitPos
decl_stmt|;
name|char
modifier|*
name|startPtr
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|endPtr
decl_stmt|;
block|}
name|FSE_CStream_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|ptrdiff_t
name|value
decl_stmt|;
specifier|const
name|void
modifier|*
name|stateTable
decl_stmt|;
specifier|const
name|void
modifier|*
name|symbolTT
decl_stmt|;
name|unsigned
name|stateLog
decl_stmt|;
block|}
name|FSE_CState_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|size_t
name|bitContainer
decl_stmt|;
name|unsigned
name|bitsConsumed
decl_stmt|;
specifier|const
name|char
modifier|*
name|ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
block|}
name|FSE_DStream_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|size_t
name|state
decl_stmt|;
specifier|const
name|void
modifier|*
name|table
decl_stmt|;
comment|/* precise table may vary, depending on U16 */
block|}
name|FSE_DState_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|FSE_DStream_unfinished
init|=
literal|0
block|,
name|FSE_DStream_endOfBuffer
init|=
literal|1
block|,
name|FSE_DStream_completed
init|=
literal|2
block|,
name|FSE_DStream_tooFar
init|=
literal|3
block|}
name|FSE_DStream_status
typedef|;
end_typedef

begin_comment
comment|/* result of FSE_reloadDStream() */
end_comment

begin_comment
comment|/* 1,2,4,8 would be better for bitmap combinations, but slows down performance a bit ... ?! */
end_comment

begin_comment
comment|/**************************************************************** *  Tuning parameters ****************************************************************/
end_comment

begin_comment
comment|/* MEMORY_USAGE : *  Memory usage formula : N->2^N Bytes (examples : 10 -> 1KB; 12 -> 4KB ; 16 -> 64KB; 20 -> 1MB; etc.) *  Increasing memory usage improves compression ratio *  Reduced memory usage can improve speed, due to cache effect *  Recommended max value is 14, for 16KB, which nicely fits into Intel x86 L1 cache */
end_comment

begin_define
define|#
directive|define
name|FSE_MAX_MEMORY_USAGE
value|14
end_define

begin_define
define|#
directive|define
name|FSE_DEFAULT_MEMORY_USAGE
value|13
end_define

begin_comment
comment|/* FSE_MAX_SYMBOL_VALUE : *  Maximum symbol value authorized. *  Required for proper stack allocation */
end_comment

begin_define
define|#
directive|define
name|FSE_MAX_SYMBOL_VALUE
value|255
end_define

begin_comment
comment|/**************************************************************** *  template functions type& suffix ****************************************************************/
end_comment

begin_define
define|#
directive|define
name|FSE_FUNCTION_TYPE
value|BYTE
end_define

begin_define
define|#
directive|define
name|FSE_FUNCTION_EXTENSION
end_define

begin_comment
comment|/**************************************************************** *  Byte symbol type ****************************************************************/
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|short
name|newState
decl_stmt|;
name|unsigned
name|char
name|symbol
decl_stmt|;
name|unsigned
name|char
name|nbBits
decl_stmt|;
block|}
name|FSE_decode_t
typedef|;
end_typedef

begin_comment
comment|/* size == U32 */
end_comment

begin_comment
comment|/**************************************************************** *  Compiler specifics ****************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_comment
comment|/* Visual Studio */
end_comment

begin_define
define|#
directive|define
name|FORCE_INLINE
value|static __forceinline
end_define

begin_include
include|#
directive|include
file|<intrin.h>
end_include

begin_comment
comment|/* For Visual 2005 */
end_comment

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4127
name|)
end_pragma

begin_comment
comment|/* disable: C4127: conditional expression is constant */
end_comment

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4214
name|)
end_pragma

begin_comment
comment|/* disable: C4214: non-int bitfields */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|GCC_VERSION
value|(__GNUC__ * 100 + __GNUC_MINOR__)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
operator|||
name|defined
argument_list|(
name|__STDC_VERSION__
argument_list|)
operator|&&
name|__STDC_VERSION__
operator|>=
literal|199901L
end_if

begin_comment
comment|/* C99 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|FORCE_INLINE
value|static inline __attribute__((always_inline))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FORCE_INLINE
value|static inline
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FORCE_INLINE
value|static
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __STDC_VERSION__ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**************************************************************** *  Includes ****************************************************************/
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* malloc, free, qsort */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* memcpy, memset */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* printf (debug) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MEM_ACCESS_MODULE
end_ifndef

begin_define
define|#
directive|define
name|MEM_ACCESS_MODULE
end_define

begin_comment
comment|/**************************************************************** *  Basic Types *****************************************************************/
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC_VERSION__
argument_list|)
operator|&&
name|__STDC_VERSION__
operator|>=
literal|199901L
end_if

begin_comment
comment|/* C99 */
end_comment

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_typedef
typedef|typedef
name|uint8_t
name|BYTE
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|uint16_t
name|U16
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|int16_t
name|S16
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|uint32_t
name|U32
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|int32_t
name|S32
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|uint64_t
name|U64
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|int64_t
name|S64
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|unsigned
name|char
name|BYTE
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|short
name|U16
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|signed
name|short
name|S16
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|int
name|U32
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|signed
name|int
name|S32
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|long
name|long
name|U64
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|signed
name|long
name|long
name|S64
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MEM_ACCESS_MODULE */
end_comment

begin_comment
comment|/**************************************************************** *  Memory I/O *****************************************************************/
end_comment

begin_comment
comment|/* FSE_FORCE_MEMORY_ACCESS  * By default, access to unaligned memory is controlled by `memcpy()`, which is safe and portable.  * Unfortunately, on some target/compiler combinations, the generated assembly is sub-optimal.  * The below switch allow to select different access method for improved performance.  * Method 0 (default) : use `memcpy()`. Safe and portable.  * Method 1 : `__packed` statement. It depends on compiler extension (ie, not portable).  *            This method is safe if your compiler supports it, and *generally* as fast or faster than `memcpy`.  * Method 2 : direct access. This method is portable but violate C standard.  *            It can generate buggy code on targets generating assembly depending on alignment.  *            But in some circumstances, it's the only known way to get the most performance (ie GCC + ARMv6)  * See http://fastcompression.blogspot.fr/2015/08/accessing-unaligned-memory.html for details.  * Prefer these methods in priority order (0> 1> 2)  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FSE_FORCE_MEMORY_ACCESS
end_ifndef

begin_comment
comment|/* can be defined externally, on command line for example */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|__ARM_ARCH_6__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_6J__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_6K__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_6Z__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_6ZK__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_6T2__
argument_list|)
operator|)
end_if

begin_define
define|#
directive|define
name|FSE_FORCE_MEMORY_ACCESS
value|2
end_define

begin_elif
elif|#
directive|elif
operator|(
name|defined
argument_list|(
name|__INTEL_COMPILER
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|)
operator|||
expr|\
operator|(
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|__ARM_ARCH_7__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_7A__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_7R__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_7M__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_7S__
argument_list|)
operator|)
operator|)
end_elif

begin_define
define|#
directive|define
name|FSE_FORCE_MEMORY_ACCESS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|unsigned
name|FSE_32bits
parameter_list|(
name|void
parameter_list|)
block|{
return|return
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|==
literal|4
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|FSE_isLittleEndian
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
union|union
block|{
name|U32
name|i
decl_stmt|;
name|BYTE
name|c
index|[
literal|4
index|]
decl_stmt|;
block|}
name|one
init|=
block|{
literal|1
block|}
union|;
comment|/* don't use static : performance detrimental  */
return|return
name|one
operator|.
name|c
index|[
literal|0
index|]
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|FSE_FORCE_MEMORY_ACCESS
argument_list|)
operator|&&
operator|(
name|FSE_FORCE_MEMORY_ACCESS
operator|==
literal|2
operator|)
end_if

begin_function
specifier|static
name|U16
name|FSE_read16
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
return|return
operator|*
operator|(
specifier|const
name|U16
operator|*
operator|)
name|memPtr
return|;
block|}
end_function

begin_function
specifier|static
name|U32
name|FSE_read32
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
return|return
operator|*
operator|(
specifier|const
name|U32
operator|*
operator|)
name|memPtr
return|;
block|}
end_function

begin_function
specifier|static
name|U64
name|FSE_read64
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
return|return
operator|*
operator|(
specifier|const
name|U64
operator|*
operator|)
name|memPtr
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|FSE_FORCE_MEMORY_ACCESS
argument_list|)
operator|&&
operator|(
name|FSE_FORCE_MEMORY_ACCESS
operator|==
literal|1
operator|)
end_elif

begin_comment
comment|/* __pack instructions are safer, but compiler specific, hence potentially problematic for some compilers */
end_comment

begin_comment
comment|/* currently only defined for gcc and icc */
end_comment

begin_typedef
typedef|typedef
union|union
block|{
name|U16
name|u16
decl_stmt|;
name|U32
name|u32
decl_stmt|;
name|U64
name|u64
decl_stmt|;
block|}
name|__attribute__
typedef|((
name|packed
typedef|))
name|unalign
typedef|;
end_typedef

begin_function
specifier|static
name|U16
name|FSE_read16
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
return|return
operator|(
operator|(
specifier|const
name|unalign
operator|*
operator|)
name|ptr
operator|)
operator|->
name|u16
return|;
block|}
end_function

begin_function
specifier|static
name|U32
name|FSE_read32
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
return|return
operator|(
operator|(
specifier|const
name|unalign
operator|*
operator|)
name|ptr
operator|)
operator|->
name|u32
return|;
block|}
end_function

begin_function
specifier|static
name|U64
name|FSE_read64
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
return|return
operator|(
operator|(
specifier|const
name|unalign
operator|*
operator|)
name|ptr
operator|)
operator|->
name|u64
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|U16
name|FSE_read16
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
name|U16
name|val
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|val
argument_list|,
name|memPtr
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|U32
name|FSE_read32
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
name|U32
name|val
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|val
argument_list|,
name|memPtr
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|U64
name|FSE_read64
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
name|U64
name|val
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|val
argument_list|,
name|memPtr
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// FSE_FORCE_MEMORY_ACCESS
end_comment

begin_function
specifier|static
name|U16
name|FSE_readLE16
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
if|if
condition|(
name|FSE_isLittleEndian
argument_list|()
condition|)
return|return
name|FSE_read16
argument_list|(
name|memPtr
argument_list|)
return|;
else|else
block|{
specifier|const
name|BYTE
modifier|*
name|p
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|memPtr
decl_stmt|;
return|return
call|(
name|U16
call|)
argument_list|(
name|p
index|[
literal|0
index|]
operator|+
operator|(
name|p
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|U32
name|FSE_readLE32
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
if|if
condition|(
name|FSE_isLittleEndian
argument_list|()
condition|)
return|return
name|FSE_read32
argument_list|(
name|memPtr
argument_list|)
return|;
else|else
block|{
specifier|const
name|BYTE
modifier|*
name|p
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|memPtr
decl_stmt|;
return|return
call|(
name|U32
call|)
argument_list|(
operator|(
name|U32
operator|)
name|p
index|[
literal|0
index|]
operator|+
operator|(
operator|(
name|U32
operator|)
name|p
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
operator|(
name|U32
operator|)
name|p
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
operator|(
name|U32
operator|)
name|p
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|U64
name|FSE_readLE64
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
if|if
condition|(
name|FSE_isLittleEndian
argument_list|()
condition|)
return|return
name|FSE_read64
argument_list|(
name|memPtr
argument_list|)
return|;
else|else
block|{
specifier|const
name|BYTE
modifier|*
name|p
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|memPtr
decl_stmt|;
return|return
call|(
name|U64
call|)
argument_list|(
operator|(
name|U64
operator|)
name|p
index|[
literal|0
index|]
operator|+
operator|(
operator|(
name|U64
operator|)
name|p
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
operator|(
name|U64
operator|)
name|p
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
operator|(
name|U64
operator|)
name|p
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator|+
operator|(
operator|(
name|U64
operator|)
name|p
index|[
literal|4
index|]
operator|<<
literal|32
operator|)
operator|+
operator|(
operator|(
name|U64
operator|)
name|p
index|[
literal|5
index|]
operator|<<
literal|40
operator|)
operator|+
operator|(
operator|(
name|U64
operator|)
name|p
index|[
literal|6
index|]
operator|<<
literal|48
operator|)
operator|+
operator|(
operator|(
name|U64
operator|)
name|p
index|[
literal|7
index|]
operator|<<
literal|56
operator|)
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|size_t
name|FSE_readLEST
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
if|if
condition|(
name|FSE_32bits
argument_list|()
condition|)
return|return
operator|(
name|size_t
operator|)
name|FSE_readLE32
argument_list|(
name|memPtr
argument_list|)
return|;
else|else
return|return
operator|(
name|size_t
operator|)
name|FSE_readLE64
argument_list|(
name|memPtr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************** *  Constants *****************************************************************/
end_comment

begin_define
define|#
directive|define
name|FSE_MAX_TABLELOG
value|(FSE_MAX_MEMORY_USAGE-2)
end_define

begin_define
define|#
directive|define
name|FSE_MAX_TABLESIZE
value|(1U<<FSE_MAX_TABLELOG)
end_define

begin_define
define|#
directive|define
name|FSE_MAXTABLESIZE_MASK
value|(FSE_MAX_TABLESIZE-1)
end_define

begin_define
define|#
directive|define
name|FSE_DEFAULT_TABLELOG
value|(FSE_DEFAULT_MEMORY_USAGE-2)
end_define

begin_define
define|#
directive|define
name|FSE_MIN_TABLELOG
value|5
end_define

begin_define
define|#
directive|define
name|FSE_TABLELOG_ABSOLUTE_MAX
value|15
end_define

begin_if
if|#
directive|if
name|FSE_MAX_TABLELOG
operator|>
name|FSE_TABLELOG_ABSOLUTE_MAX
end_if

begin_error
error|#
directive|error
literal|"FSE_MAX_TABLELOG> FSE_TABLELOG_ABSOLUTE_MAX is not supported"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**************************************************************** *  Error Management ****************************************************************/
end_comment

begin_define
define|#
directive|define
name|FSE_STATIC_ASSERT
parameter_list|(
name|c
parameter_list|)
value|{ enum { FSE_static_assert = 1/(int)(!!(c)) }; }
end_define

begin_comment
comment|/* use only *after* variable declarations */
end_comment

begin_comment
comment|/**************************************************************** *  Complex types ****************************************************************/
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|deltaFindState
decl_stmt|;
name|U32
name|deltaNbBits
decl_stmt|;
block|}
name|FSE_symbolCompressionTransform
typedef|;
end_typedef

begin_comment
comment|/* total 8 bytes */
end_comment

begin_typedef
typedef|typedef
name|U32
name|DTable_max_t
index|[
name|FSE_DTABLE_SIZE_U32
argument_list|(
name|FSE_MAX_TABLELOG
argument_list|)
index|]
typedef|;
end_typedef

begin_comment
comment|/**************************************************************** *  Internal functions ****************************************************************/
end_comment

begin_function
name|FORCE_INLINE
name|unsigned
name|FSE_highbit32
parameter_list|(
specifier|register
name|U32
name|val
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
comment|/* Visual */
name|unsigned
name|long
name|r
decl_stmt|;
name|_BitScanReverse
argument_list|(
operator|&
name|r
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|unsigned
operator|)
name|r
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|GCC_VERSION
operator|>=
literal|304
operator|)
comment|/* GCC Intrinsic */
return|return
literal|31
operator|-
name|__builtin_clz
argument_list|(
name|val
argument_list|)
return|;
else|#
directive|else
comment|/* Software version */
specifier|static
specifier|const
name|unsigned
name|DeBruijnClz
index|[
literal|32
index|]
init|=
block|{
literal|0
block|,
literal|9
block|,
literal|1
block|,
literal|10
block|,
literal|13
block|,
literal|21
block|,
literal|2
block|,
literal|29
block|,
literal|11
block|,
literal|14
block|,
literal|16
block|,
literal|18
block|,
literal|22
block|,
literal|25
block|,
literal|3
block|,
literal|30
block|,
literal|8
block|,
literal|12
block|,
literal|20
block|,
literal|28
block|,
literal|15
block|,
literal|17
block|,
literal|24
block|,
literal|7
block|,
literal|19
block|,
literal|27
block|,
literal|23
block|,
literal|6
block|,
literal|26
block|,
literal|5
block|,
literal|4
block|,
literal|31
block|}
decl_stmt|;
name|U32
name|v
init|=
name|val
decl_stmt|;
name|unsigned
name|r
decl_stmt|;
name|v
operator||=
name|v
operator|>>
literal|1
expr_stmt|;
name|v
operator||=
name|v
operator|>>
literal|2
expr_stmt|;
name|v
operator||=
name|v
operator|>>
literal|4
expr_stmt|;
name|v
operator||=
name|v
operator|>>
literal|8
expr_stmt|;
name|v
operator||=
name|v
operator|>>
literal|16
expr_stmt|;
name|r
operator|=
name|DeBruijnClz
index|[
call|(
name|U32
call|)
argument_list|(
name|v
operator|*
literal|0x07C4ACDDU
argument_list|)
operator|>>
literal|27
index|]
expr_stmt|;
return|return
name|r
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/**************************************************************** *  Templates ****************************************************************/
end_comment

begin_comment
comment|/*   designed to be included   for type-specific functions (template emulation in C)   Objective is to write these functions only once, for improved maintenance */
end_comment

begin_comment
comment|/* safety checks */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FSE_FUNCTION_EXTENSION
end_ifndef

begin_error
error|#
directive|error
literal|"FSE_FUNCTION_EXTENSION must be defined"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FSE_FUNCTION_TYPE
end_ifndef

begin_error
error|#
directive|error
literal|"FSE_FUNCTION_TYPE must be defined"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Function names */
end_comment

begin_define
define|#
directive|define
name|FSE_CAT
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|X##Y
end_define

begin_define
define|#
directive|define
name|FSE_FUNCTION_NAME
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|FSE_CAT(X,Y)
end_define

begin_define
define|#
directive|define
name|FSE_TYPE_NAME
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|FSE_CAT(X,Y)
end_define

begin_function
specifier|static
name|U32
name|FSE_tableStep
parameter_list|(
name|U32
name|tableSize
parameter_list|)
block|{
return|return
operator|(
name|tableSize
operator|>>
literal|1
operator|)
operator|+
operator|(
name|tableSize
operator|>>
literal|3
operator|)
operator|+
literal|3
return|;
block|}
end_function

begin_define
define|#
directive|define
name|FSE_DECODE_TYPE
value|FSE_decode_t
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|U16
name|tableLog
decl_stmt|;
name|U16
name|fastMode
decl_stmt|;
block|}
name|FSE_DTableHeader
typedef|;
end_typedef

begin_comment
comment|/* sizeof U32 */
end_comment

begin_function
specifier|static
name|size_t
name|FSE_buildDTable
parameter_list|(
name|FSE_DTable
modifier|*
name|dt
parameter_list|,
specifier|const
name|short
modifier|*
name|normalizedCounter
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|,
name|unsigned
name|tableLog
parameter_list|)
block|{
name|void
modifier|*
name|ptr
init|=
name|dt
decl_stmt|;
name|FSE_DTableHeader
modifier|*
specifier|const
name|DTableH
init|=
operator|(
name|FSE_DTableHeader
operator|*
operator|)
name|ptr
decl_stmt|;
name|FSE_DECODE_TYPE
modifier|*
specifier|const
name|tableDecode
init|=
operator|(
name|FSE_DECODE_TYPE
operator|*
operator|)
operator|(
name|ptr
operator|)
operator|+
literal|1
decl_stmt|;
comment|/* because dt is unsigned, 32-bits aligned on 32-bits */
specifier|const
name|U32
name|tableSize
init|=
literal|1
operator|<<
name|tableLog
decl_stmt|;
specifier|const
name|U32
name|tableMask
init|=
name|tableSize
operator|-
literal|1
decl_stmt|;
specifier|const
name|U32
name|step
init|=
name|FSE_tableStep
argument_list|(
name|tableSize
argument_list|)
decl_stmt|;
name|U16
name|symbolNext
index|[
name|FSE_MAX_SYMBOL_VALUE
operator|+
literal|1
index|]
decl_stmt|;
name|U32
name|position
init|=
literal|0
decl_stmt|;
name|U32
name|highThreshold
init|=
name|tableSize
operator|-
literal|1
decl_stmt|;
specifier|const
name|S16
name|largeLimit
init|=
call|(
name|S16
call|)
argument_list|(
literal|1
operator|<<
operator|(
name|tableLog
operator|-
literal|1
operator|)
argument_list|)
decl_stmt|;
name|U32
name|noLarge
init|=
literal|1
decl_stmt|;
name|U32
name|s
decl_stmt|;
comment|/* Sanity Checks */
if|if
condition|(
name|maxSymbolValue
operator|>
name|FSE_MAX_SYMBOL_VALUE
condition|)
return|return
operator|(
name|size_t
operator|)
operator|-
name|FSE_ERROR_maxSymbolValue_tooLarge
return|;
if|if
condition|(
name|tableLog
operator|>
name|FSE_MAX_TABLELOG
condition|)
return|return
operator|(
name|size_t
operator|)
operator|-
name|FSE_ERROR_tableLog_tooLarge
return|;
comment|/* Init, lay down lowprob symbols */
name|DTableH
index|[
literal|0
index|]
operator|.
name|tableLog
operator|=
operator|(
name|U16
operator|)
name|tableLog
expr_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<=
name|maxSymbolValue
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|normalizedCounter
index|[
name|s
index|]
operator|==
operator|-
literal|1
condition|)
block|{
name|tableDecode
index|[
name|highThreshold
operator|--
index|]
operator|.
name|symbol
operator|=
operator|(
name|FSE_FUNCTION_TYPE
operator|)
name|s
expr_stmt|;
name|symbolNext
index|[
name|s
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|normalizedCounter
index|[
name|s
index|]
operator|>=
name|largeLimit
condition|)
name|noLarge
operator|=
literal|0
expr_stmt|;
name|symbolNext
index|[
name|s
index|]
operator|=
name|normalizedCounter
index|[
name|s
index|]
expr_stmt|;
block|}
block|}
comment|/* Spread symbols */
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<=
name|maxSymbolValue
condition|;
name|s
operator|++
control|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|normalizedCounter
index|[
name|s
index|]
condition|;
name|i
operator|++
control|)
block|{
name|tableDecode
index|[
name|position
index|]
operator|.
name|symbol
operator|=
operator|(
name|FSE_FUNCTION_TYPE
operator|)
name|s
expr_stmt|;
name|position
operator|=
operator|(
name|position
operator|+
name|step
operator|)
operator|&
name|tableMask
expr_stmt|;
while|while
condition|(
name|position
operator|>
name|highThreshold
condition|)
name|position
operator|=
operator|(
name|position
operator|+
name|step
operator|)
operator|&
name|tableMask
expr_stmt|;
comment|/* lowprob area */
block|}
block|}
if|if
condition|(
name|position
operator|!=
literal|0
condition|)
return|return
operator|(
name|size_t
operator|)
operator|-
name|FSE_ERROR_GENERIC
return|;
comment|/* position must reach all cells once, otherwise normalizedCounter is incorrect */
comment|/* Build Decoding table */
block|{
name|U32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tableSize
condition|;
name|i
operator|++
control|)
block|{
name|FSE_FUNCTION_TYPE
name|symbol
init|=
call|(
name|FSE_FUNCTION_TYPE
call|)
argument_list|(
name|tableDecode
index|[
name|i
index|]
operator|.
name|symbol
argument_list|)
decl_stmt|;
name|U16
name|nextState
init|=
name|symbolNext
index|[
name|symbol
index|]
operator|++
decl_stmt|;
name|tableDecode
index|[
name|i
index|]
operator|.
name|nbBits
operator|=
call|(
name|BYTE
call|)
argument_list|(
name|tableLog
operator|-
name|FSE_highbit32
argument_list|(
operator|(
name|U32
operator|)
name|nextState
argument_list|)
argument_list|)
expr_stmt|;
name|tableDecode
index|[
name|i
index|]
operator|.
name|newState
operator|=
call|(
name|U16
call|)
argument_list|(
operator|(
name|nextState
operator|<<
name|tableDecode
index|[
name|i
index|]
operator|.
name|nbBits
operator|)
operator|-
name|tableSize
argument_list|)
expr_stmt|;
block|}
block|}
name|DTableH
operator|->
name|fastMode
operator|=
operator|(
name|U16
operator|)
name|noLarge
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/****************************************** *  FSE byte symbol ******************************************/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FSE_COMMONDEFS_ONLY
end_ifndef

begin_function
specifier|static
name|unsigned
name|FSE_isError
parameter_list|(
name|size_t
name|code
parameter_list|)
block|{
return|return
operator|(
name|code
operator|>
call|(
name|size_t
call|)
argument_list|(
operator|-
name|FSE_ERROR_maxCode
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|short
name|FSE_abs
parameter_list|(
name|short
name|a
parameter_list|)
block|{
return|return
name|a
operator|<
literal|0
condition|?
operator|-
name|a
else|:
name|a
return|;
block|}
end_function

begin_comment
comment|/**************************************************************** *  Header bitstream management ****************************************************************/
end_comment

begin_function
specifier|static
name|size_t
name|FSE_readNCount
parameter_list|(
name|short
modifier|*
name|normalizedCounter
parameter_list|,
name|unsigned
modifier|*
name|maxSVPtr
parameter_list|,
name|unsigned
modifier|*
name|tableLogPtr
parameter_list|,
specifier|const
name|void
modifier|*
name|headerBuffer
parameter_list|,
name|size_t
name|hbSize
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|headerBuffer
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|iend
init|=
name|istart
operator|+
name|hbSize
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|ip
init|=
name|istart
decl_stmt|;
name|int
name|nbBits
decl_stmt|;
name|int
name|remaining
decl_stmt|;
name|int
name|threshold
decl_stmt|;
name|U32
name|bitStream
decl_stmt|;
name|int
name|bitCount
decl_stmt|;
name|unsigned
name|charnum
init|=
literal|0
decl_stmt|;
name|int
name|previous0
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|hbSize
operator|<
literal|4
condition|)
return|return
operator|(
name|size_t
operator|)
operator|-
name|FSE_ERROR_srcSize_wrong
return|;
name|bitStream
operator|=
name|FSE_readLE32
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|nbBits
operator|=
operator|(
name|bitStream
operator|&
literal|0xF
operator|)
operator|+
name|FSE_MIN_TABLELOG
expr_stmt|;
comment|/* extract tableLog */
if|if
condition|(
name|nbBits
operator|>
name|FSE_TABLELOG_ABSOLUTE_MAX
condition|)
return|return
operator|(
name|size_t
operator|)
operator|-
name|FSE_ERROR_tableLog_tooLarge
return|;
name|bitStream
operator|>>=
literal|4
expr_stmt|;
name|bitCount
operator|=
literal|4
expr_stmt|;
operator|*
name|tableLogPtr
operator|=
name|nbBits
expr_stmt|;
name|remaining
operator|=
operator|(
literal|1
operator|<<
name|nbBits
operator|)
operator|+
literal|1
expr_stmt|;
name|threshold
operator|=
literal|1
operator|<<
name|nbBits
expr_stmt|;
name|nbBits
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|remaining
operator|>
literal|1
operator|)
operator|&&
operator|(
name|charnum
operator|<=
operator|*
name|maxSVPtr
operator|)
condition|)
block|{
if|if
condition|(
name|previous0
condition|)
block|{
name|unsigned
name|n0
init|=
name|charnum
decl_stmt|;
while|while
condition|(
operator|(
name|bitStream
operator|&
literal|0xFFFF
operator|)
operator|==
literal|0xFFFF
condition|)
block|{
name|n0
operator|+=
literal|24
expr_stmt|;
if|if
condition|(
name|ip
operator|<
name|iend
operator|-
literal|5
condition|)
block|{
name|ip
operator|+=
literal|2
expr_stmt|;
name|bitStream
operator|=
name|FSE_readLE32
argument_list|(
name|ip
argument_list|)
operator|>>
name|bitCount
expr_stmt|;
block|}
else|else
block|{
name|bitStream
operator|>>=
literal|16
expr_stmt|;
name|bitCount
operator|+=
literal|16
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|(
name|bitStream
operator|&
literal|3
operator|)
operator|==
literal|3
condition|)
block|{
name|n0
operator|+=
literal|3
expr_stmt|;
name|bitStream
operator|>>=
literal|2
expr_stmt|;
name|bitCount
operator|+=
literal|2
expr_stmt|;
block|}
name|n0
operator|+=
name|bitStream
operator|&
literal|3
expr_stmt|;
name|bitCount
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|n0
operator|>
operator|*
name|maxSVPtr
condition|)
return|return
operator|(
name|size_t
operator|)
operator|-
name|FSE_ERROR_maxSymbolValue_tooSmall
return|;
while|while
condition|(
name|charnum
operator|<
name|n0
condition|)
name|normalizedCounter
index|[
name|charnum
operator|++
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ip
operator|<=
name|iend
operator|-
literal|7
operator|)
operator|||
operator|(
name|ip
operator|+
operator|(
name|bitCount
operator|>>
literal|3
operator|)
operator|<=
name|iend
operator|-
literal|4
operator|)
condition|)
block|{
name|ip
operator|+=
name|bitCount
operator|>>
literal|3
expr_stmt|;
name|bitCount
operator|&=
literal|7
expr_stmt|;
name|bitStream
operator|=
name|FSE_readLE32
argument_list|(
name|ip
argument_list|)
operator|>>
name|bitCount
expr_stmt|;
block|}
else|else
name|bitStream
operator|>>=
literal|2
expr_stmt|;
block|}
block|{
specifier|const
name|short
name|max
init|=
call|(
name|short
call|)
argument_list|(
operator|(
literal|2
operator|*
name|threshold
operator|-
literal|1
operator|)
operator|-
name|remaining
argument_list|)
decl_stmt|;
name|short
name|count
decl_stmt|;
if|if
condition|(
operator|(
name|bitStream
operator|&
operator|(
name|threshold
operator|-
literal|1
operator|)
operator|)
operator|<
operator|(
name|U32
operator|)
name|max
condition|)
block|{
name|count
operator|=
call|(
name|short
call|)
argument_list|(
name|bitStream
operator|&
operator|(
name|threshold
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|bitCount
operator|+=
name|nbBits
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|count
operator|=
call|(
name|short
call|)
argument_list|(
name|bitStream
operator|&
operator|(
literal|2
operator|*
name|threshold
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>=
name|threshold
condition|)
name|count
operator|-=
name|max
expr_stmt|;
name|bitCount
operator|+=
name|nbBits
expr_stmt|;
block|}
name|count
operator|--
expr_stmt|;
comment|/* extra accuracy */
name|remaining
operator|-=
name|FSE_abs
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|normalizedCounter
index|[
name|charnum
operator|++
index|]
operator|=
name|count
expr_stmt|;
name|previous0
operator|=
operator|!
name|count
expr_stmt|;
while|while
condition|(
name|remaining
operator|<
name|threshold
condition|)
block|{
name|nbBits
operator|--
expr_stmt|;
name|threshold
operator|>>=
literal|1
expr_stmt|;
block|}
block|{
if|if
condition|(
operator|(
name|ip
operator|<=
name|iend
operator|-
literal|7
operator|)
operator|||
operator|(
name|ip
operator|+
operator|(
name|bitCount
operator|>>
literal|3
operator|)
operator|<=
name|iend
operator|-
literal|4
operator|)
condition|)
block|{
name|ip
operator|+=
name|bitCount
operator|>>
literal|3
expr_stmt|;
name|bitCount
operator|&=
literal|7
expr_stmt|;
block|}
else|else
block|{
name|bitCount
operator|-=
call|(
name|int
call|)
argument_list|(
literal|8
operator|*
operator|(
name|iend
operator|-
literal|4
operator|-
name|ip
operator|)
argument_list|)
expr_stmt|;
name|ip
operator|=
name|iend
operator|-
literal|4
expr_stmt|;
block|}
name|bitStream
operator|=
name|FSE_readLE32
argument_list|(
name|ip
argument_list|)
operator|>>
operator|(
name|bitCount
operator|&
literal|31
operator|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|remaining
operator|!=
literal|1
condition|)
return|return
operator|(
name|size_t
operator|)
operator|-
name|FSE_ERROR_GENERIC
return|;
operator|*
name|maxSVPtr
operator|=
name|charnum
operator|-
literal|1
expr_stmt|;
name|ip
operator|+=
operator|(
name|bitCount
operator|+
literal|7
operator|)
operator|>>
literal|3
expr_stmt|;
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|ip
operator|-
name|istart
argument_list|)
operator|>
name|hbSize
condition|)
return|return
operator|(
name|size_t
operator|)
operator|-
name|FSE_ERROR_srcSize_wrong
return|;
return|return
name|ip
operator|-
name|istart
return|;
block|}
end_function

begin_comment
comment|/********************************************************* *  Decompression (Byte symbols) *********************************************************/
end_comment

begin_function
specifier|static
name|size_t
name|FSE_buildDTable_rle
parameter_list|(
name|FSE_DTable
modifier|*
name|dt
parameter_list|,
name|BYTE
name|symbolValue
parameter_list|)
block|{
name|void
modifier|*
name|ptr
init|=
name|dt
decl_stmt|;
name|FSE_DTableHeader
modifier|*
specifier|const
name|DTableH
init|=
operator|(
name|FSE_DTableHeader
operator|*
operator|)
name|ptr
decl_stmt|;
name|FSE_decode_t
modifier|*
specifier|const
name|cell
init|=
operator|(
name|FSE_decode_t
operator|*
operator|)
operator|(
name|ptr
operator|)
operator|+
literal|1
decl_stmt|;
comment|/* because dt is unsigned */
name|DTableH
operator|->
name|tableLog
operator|=
literal|0
expr_stmt|;
name|DTableH
operator|->
name|fastMode
operator|=
literal|0
expr_stmt|;
name|cell
operator|->
name|newState
operator|=
literal|0
expr_stmt|;
name|cell
operator|->
name|symbol
operator|=
name|symbolValue
expr_stmt|;
name|cell
operator|->
name|nbBits
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|FSE_buildDTable_raw
parameter_list|(
name|FSE_DTable
modifier|*
name|dt
parameter_list|,
name|unsigned
name|nbBits
parameter_list|)
block|{
name|void
modifier|*
name|ptr
init|=
name|dt
decl_stmt|;
name|FSE_DTableHeader
modifier|*
specifier|const
name|DTableH
init|=
operator|(
name|FSE_DTableHeader
operator|*
operator|)
name|ptr
decl_stmt|;
name|FSE_decode_t
modifier|*
specifier|const
name|dinfo
init|=
operator|(
name|FSE_decode_t
operator|*
operator|)
operator|(
name|ptr
operator|)
operator|+
literal|1
decl_stmt|;
comment|/* because dt is unsigned */
specifier|const
name|unsigned
name|tableSize
init|=
literal|1
operator|<<
name|nbBits
decl_stmt|;
specifier|const
name|unsigned
name|tableMask
init|=
name|tableSize
operator|-
literal|1
decl_stmt|;
specifier|const
name|unsigned
name|maxSymbolValue
init|=
name|tableMask
decl_stmt|;
name|unsigned
name|s
decl_stmt|;
comment|/* Sanity checks */
if|if
condition|(
name|nbBits
operator|<
literal|1
condition|)
return|return
operator|(
name|size_t
operator|)
operator|-
name|FSE_ERROR_GENERIC
return|;
comment|/* min size */
comment|/* Build Decoding Table */
name|DTableH
operator|->
name|tableLog
operator|=
operator|(
name|U16
operator|)
name|nbBits
expr_stmt|;
name|DTableH
operator|->
name|fastMode
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<=
name|maxSymbolValue
condition|;
name|s
operator|++
control|)
block|{
name|dinfo
index|[
name|s
index|]
operator|.
name|newState
operator|=
literal|0
expr_stmt|;
name|dinfo
index|[
name|s
index|]
operator|.
name|symbol
operator|=
operator|(
name|BYTE
operator|)
name|s
expr_stmt|;
name|dinfo
index|[
name|s
index|]
operator|.
name|nbBits
operator|=
operator|(
name|BYTE
operator|)
name|nbBits
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* FSE_initDStream  * Initialize a FSE_DStream_t.  * srcBuffer must point at the beginning of an FSE block.  * The function result is the size of the FSE_block (== srcSize).  * If srcSize is too small, the function will return an errorCode;  */
end_comment

begin_function
specifier|static
name|size_t
name|FSE_initDStream
parameter_list|(
name|FSE_DStream_t
modifier|*
name|bitD
parameter_list|,
specifier|const
name|void
modifier|*
name|srcBuffer
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
if|if
condition|(
name|srcSize
operator|<
literal|1
condition|)
return|return
operator|(
name|size_t
operator|)
operator|-
name|FSE_ERROR_srcSize_wrong
return|;
if|if
condition|(
name|srcSize
operator|>=
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
condition|)
block|{
name|U32
name|contain32
decl_stmt|;
name|bitD
operator|->
name|start
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|srcBuffer
expr_stmt|;
name|bitD
operator|->
name|ptr
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|srcBuffer
operator|+
name|srcSize
operator|-
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
expr_stmt|;
name|bitD
operator|->
name|bitContainer
operator|=
name|FSE_readLEST
argument_list|(
name|bitD
operator|->
name|ptr
argument_list|)
expr_stmt|;
name|contain32
operator|=
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|srcBuffer
operator|)
index|[
name|srcSize
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|contain32
operator|==
literal|0
condition|)
return|return
operator|(
name|size_t
operator|)
operator|-
name|FSE_ERROR_GENERIC
return|;
comment|/* stop bit not present */
name|bitD
operator|->
name|bitsConsumed
operator|=
literal|8
operator|-
name|FSE_highbit32
argument_list|(
name|contain32
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|U32
name|contain32
decl_stmt|;
name|bitD
operator|->
name|start
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|srcBuffer
expr_stmt|;
name|bitD
operator|->
name|ptr
operator|=
name|bitD
operator|->
name|start
expr_stmt|;
name|bitD
operator|->
name|bitContainer
operator|=
operator|*
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|bitD
operator|->
name|start
operator|)
expr_stmt|;
switch|switch
condition|(
name|srcSize
condition|)
block|{
case|case
literal|7
case|:
name|bitD
operator|->
name|bitContainer
operator|+=
call|(
name|size_t
call|)
argument_list|(
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|bitD
operator|->
name|start
operator|)
operator|)
index|[
literal|6
index|]
argument_list|)
operator|<<
operator|(
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|*
literal|8
operator|-
literal|16
operator|)
expr_stmt|;
case|case
literal|6
case|:
name|bitD
operator|->
name|bitContainer
operator|+=
call|(
name|size_t
call|)
argument_list|(
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|bitD
operator|->
name|start
operator|)
operator|)
index|[
literal|5
index|]
argument_list|)
operator|<<
operator|(
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|*
literal|8
operator|-
literal|24
operator|)
expr_stmt|;
case|case
literal|5
case|:
name|bitD
operator|->
name|bitContainer
operator|+=
call|(
name|size_t
call|)
argument_list|(
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|bitD
operator|->
name|start
operator|)
operator|)
index|[
literal|4
index|]
argument_list|)
operator|<<
operator|(
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|*
literal|8
operator|-
literal|32
operator|)
expr_stmt|;
case|case
literal|4
case|:
name|bitD
operator|->
name|bitContainer
operator|+=
call|(
name|size_t
call|)
argument_list|(
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|bitD
operator|->
name|start
operator|)
operator|)
index|[
literal|3
index|]
argument_list|)
operator|<<
literal|24
expr_stmt|;
case|case
literal|3
case|:
name|bitD
operator|->
name|bitContainer
operator|+=
call|(
name|size_t
call|)
argument_list|(
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|bitD
operator|->
name|start
operator|)
operator|)
index|[
literal|2
index|]
argument_list|)
operator|<<
literal|16
expr_stmt|;
case|case
literal|2
case|:
name|bitD
operator|->
name|bitContainer
operator|+=
call|(
name|size_t
call|)
argument_list|(
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|bitD
operator|->
name|start
operator|)
operator|)
index|[
literal|1
index|]
argument_list|)
operator|<<
literal|8
expr_stmt|;
default|default:
empty_stmt|;
block|}
name|contain32
operator|=
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|srcBuffer
operator|)
index|[
name|srcSize
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|contain32
operator|==
literal|0
condition|)
return|return
operator|(
name|size_t
operator|)
operator|-
name|FSE_ERROR_GENERIC
return|;
comment|/* stop bit not present */
name|bitD
operator|->
name|bitsConsumed
operator|=
literal|8
operator|-
name|FSE_highbit32
argument_list|(
name|contain32
argument_list|)
expr_stmt|;
name|bitD
operator|->
name|bitsConsumed
operator|+=
call|(
name|U32
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|-
name|srcSize
argument_list|)
operator|*
literal|8
expr_stmt|;
block|}
return|return
name|srcSize
return|;
block|}
end_function

begin_comment
comment|/*!FSE_lookBits  * Provides next n bits from the bitContainer.  * bitContainer is not modified (bits are still present for next read/look)  * On 32-bits, maxNbBits==25  * On 64-bits, maxNbBits==57  * return : value extracted.  */
end_comment

begin_function
specifier|static
name|size_t
name|FSE_lookBits
parameter_list|(
name|FSE_DStream_t
modifier|*
name|bitD
parameter_list|,
name|U32
name|nbBits
parameter_list|)
block|{
specifier|const
name|U32
name|bitMask
init|=
sizeof|sizeof
argument_list|(
name|bitD
operator|->
name|bitContainer
argument_list|)
operator|*
literal|8
operator|-
literal|1
decl_stmt|;
return|return
operator|(
operator|(
name|bitD
operator|->
name|bitContainer
operator|<<
operator|(
name|bitD
operator|->
name|bitsConsumed
operator|&
name|bitMask
operator|)
operator|)
operator|>>
literal|1
operator|)
operator|>>
operator|(
operator|(
name|bitMask
operator|-
name|nbBits
operator|)
operator|&
name|bitMask
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|FSE_lookBitsFast
parameter_list|(
name|FSE_DStream_t
modifier|*
name|bitD
parameter_list|,
name|U32
name|nbBits
parameter_list|)
comment|/* only if nbBits>= 1 !! */
block|{
specifier|const
name|U32
name|bitMask
init|=
sizeof|sizeof
argument_list|(
name|bitD
operator|->
name|bitContainer
argument_list|)
operator|*
literal|8
operator|-
literal|1
decl_stmt|;
return|return
operator|(
name|bitD
operator|->
name|bitContainer
operator|<<
operator|(
name|bitD
operator|->
name|bitsConsumed
operator|&
name|bitMask
operator|)
operator|)
operator|>>
operator|(
operator|(
operator|(
name|bitMask
operator|+
literal|1
operator|)
operator|-
name|nbBits
operator|)
operator|&
name|bitMask
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|FSE_skipBits
parameter_list|(
name|FSE_DStream_t
modifier|*
name|bitD
parameter_list|,
name|U32
name|nbBits
parameter_list|)
block|{
name|bitD
operator|->
name|bitsConsumed
operator|+=
name|nbBits
expr_stmt|;
block|}
end_function

begin_comment
comment|/*!FSE_readBits  * Read next n bits from the bitContainer.  * On 32-bits, don't read more than maxNbBits==25  * On 64-bits, don't read more than maxNbBits==57  * Use the fast variant *only* if n>= 1.  * return : value extracted.  */
end_comment

begin_function
specifier|static
name|size_t
name|FSE_readBits
parameter_list|(
name|FSE_DStream_t
modifier|*
name|bitD
parameter_list|,
name|U32
name|nbBits
parameter_list|)
block|{
name|size_t
name|value
init|=
name|FSE_lookBits
argument_list|(
name|bitD
argument_list|,
name|nbBits
argument_list|)
decl_stmt|;
name|FSE_skipBits
argument_list|(
name|bitD
argument_list|,
name|nbBits
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|FSE_readBitsFast
parameter_list|(
name|FSE_DStream_t
modifier|*
name|bitD
parameter_list|,
name|U32
name|nbBits
parameter_list|)
comment|/* only if nbBits>= 1 !! */
block|{
name|size_t
name|value
init|=
name|FSE_lookBitsFast
argument_list|(
name|bitD
argument_list|,
name|nbBits
argument_list|)
decl_stmt|;
name|FSE_skipBits
argument_list|(
name|bitD
argument_list|,
name|nbBits
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|FSE_reloadDStream
parameter_list|(
name|FSE_DStream_t
modifier|*
name|bitD
parameter_list|)
block|{
if|if
condition|(
name|bitD
operator|->
name|bitsConsumed
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|bitD
operator|->
name|bitContainer
argument_list|)
operator|*
literal|8
operator|)
condition|)
comment|/* should never happen */
return|return
name|FSE_DStream_tooFar
return|;
if|if
condition|(
name|bitD
operator|->
name|ptr
operator|>=
name|bitD
operator|->
name|start
operator|+
sizeof|sizeof
argument_list|(
name|bitD
operator|->
name|bitContainer
argument_list|)
condition|)
block|{
name|bitD
operator|->
name|ptr
operator|-=
name|bitD
operator|->
name|bitsConsumed
operator|>>
literal|3
expr_stmt|;
name|bitD
operator|->
name|bitsConsumed
operator|&=
literal|7
expr_stmt|;
name|bitD
operator|->
name|bitContainer
operator|=
name|FSE_readLEST
argument_list|(
name|bitD
operator|->
name|ptr
argument_list|)
expr_stmt|;
return|return
name|FSE_DStream_unfinished
return|;
block|}
if|if
condition|(
name|bitD
operator|->
name|ptr
operator|==
name|bitD
operator|->
name|start
condition|)
block|{
if|if
condition|(
name|bitD
operator|->
name|bitsConsumed
operator|<
sizeof|sizeof
argument_list|(
name|bitD
operator|->
name|bitContainer
argument_list|)
operator|*
literal|8
condition|)
return|return
name|FSE_DStream_endOfBuffer
return|;
return|return
name|FSE_DStream_completed
return|;
block|}
block|{
name|U32
name|nbBytes
init|=
name|bitD
operator|->
name|bitsConsumed
operator|>>
literal|3
decl_stmt|;
name|U32
name|result
init|=
name|FSE_DStream_unfinished
decl_stmt|;
if|if
condition|(
name|bitD
operator|->
name|ptr
operator|-
name|nbBytes
operator|<
name|bitD
operator|->
name|start
condition|)
block|{
name|nbBytes
operator|=
call|(
name|U32
call|)
argument_list|(
name|bitD
operator|->
name|ptr
operator|-
name|bitD
operator|->
name|start
argument_list|)
expr_stmt|;
comment|/* ptr> start */
name|result
operator|=
name|FSE_DStream_endOfBuffer
expr_stmt|;
block|}
name|bitD
operator|->
name|ptr
operator|-=
name|nbBytes
expr_stmt|;
name|bitD
operator|->
name|bitsConsumed
operator|-=
name|nbBytes
operator|*
literal|8
expr_stmt|;
name|bitD
operator|->
name|bitContainer
operator|=
name|FSE_readLEST
argument_list|(
name|bitD
operator|->
name|ptr
argument_list|)
expr_stmt|;
comment|/* reminder : srcSize> sizeof(bitD) */
return|return
name|result
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|FSE_initDState
parameter_list|(
name|FSE_DState_t
modifier|*
name|DStatePtr
parameter_list|,
name|FSE_DStream_t
modifier|*
name|bitD
parameter_list|,
specifier|const
name|FSE_DTable
modifier|*
name|dt
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|ptr
init|=
name|dt
decl_stmt|;
specifier|const
name|FSE_DTableHeader
modifier|*
specifier|const
name|DTableH
init|=
operator|(
specifier|const
name|FSE_DTableHeader
operator|*
operator|)
name|ptr
decl_stmt|;
name|DStatePtr
operator|->
name|state
operator|=
name|FSE_readBits
argument_list|(
name|bitD
argument_list|,
name|DTableH
operator|->
name|tableLog
argument_list|)
expr_stmt|;
name|FSE_reloadDStream
argument_list|(
name|bitD
argument_list|)
expr_stmt|;
name|DStatePtr
operator|->
name|table
operator|=
name|dt
operator|+
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|BYTE
name|FSE_decodeSymbol
parameter_list|(
name|FSE_DState_t
modifier|*
name|DStatePtr
parameter_list|,
name|FSE_DStream_t
modifier|*
name|bitD
parameter_list|)
block|{
specifier|const
name|FSE_decode_t
name|DInfo
init|=
operator|(
operator|(
specifier|const
name|FSE_decode_t
operator|*
operator|)
operator|(
name|DStatePtr
operator|->
name|table
operator|)
operator|)
index|[
name|DStatePtr
operator|->
name|state
index|]
decl_stmt|;
specifier|const
name|U32
name|nbBits
init|=
name|DInfo
operator|.
name|nbBits
decl_stmt|;
name|BYTE
name|symbol
init|=
name|DInfo
operator|.
name|symbol
decl_stmt|;
name|size_t
name|lowBits
init|=
name|FSE_readBits
argument_list|(
name|bitD
argument_list|,
name|nbBits
argument_list|)
decl_stmt|;
name|DStatePtr
operator|->
name|state
operator|=
name|DInfo
operator|.
name|newState
operator|+
name|lowBits
expr_stmt|;
return|return
name|symbol
return|;
block|}
end_function

begin_function
specifier|static
name|BYTE
name|FSE_decodeSymbolFast
parameter_list|(
name|FSE_DState_t
modifier|*
name|DStatePtr
parameter_list|,
name|FSE_DStream_t
modifier|*
name|bitD
parameter_list|)
block|{
specifier|const
name|FSE_decode_t
name|DInfo
init|=
operator|(
operator|(
specifier|const
name|FSE_decode_t
operator|*
operator|)
operator|(
name|DStatePtr
operator|->
name|table
operator|)
operator|)
index|[
name|DStatePtr
operator|->
name|state
index|]
decl_stmt|;
specifier|const
name|U32
name|nbBits
init|=
name|DInfo
operator|.
name|nbBits
decl_stmt|;
name|BYTE
name|symbol
init|=
name|DInfo
operator|.
name|symbol
decl_stmt|;
name|size_t
name|lowBits
init|=
name|FSE_readBitsFast
argument_list|(
name|bitD
argument_list|,
name|nbBits
argument_list|)
decl_stmt|;
name|DStatePtr
operator|->
name|state
operator|=
name|DInfo
operator|.
name|newState
operator|+
name|lowBits
expr_stmt|;
return|return
name|symbol
return|;
block|}
end_function

begin_comment
comment|/* FSE_endOfDStream    Tells if bitD has reached end of bitStream or not */
end_comment

begin_function
specifier|static
name|unsigned
name|FSE_endOfDStream
parameter_list|(
specifier|const
name|FSE_DStream_t
modifier|*
name|bitD
parameter_list|)
block|{
return|return
operator|(
operator|(
name|bitD
operator|->
name|ptr
operator|==
name|bitD
operator|->
name|start
operator|)
operator|&&
operator|(
name|bitD
operator|->
name|bitsConsumed
operator|==
sizeof|sizeof
argument_list|(
name|bitD
operator|->
name|bitContainer
argument_list|)
operator|*
literal|8
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|FSE_endOfDState
parameter_list|(
specifier|const
name|FSE_DState_t
modifier|*
name|DStatePtr
parameter_list|)
block|{
return|return
name|DStatePtr
operator|->
name|state
operator|==
literal|0
return|;
block|}
end_function

begin_function
name|FORCE_INLINE
name|size_t
name|FSE_decompress_usingDTable_generic
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|FSE_DTable
modifier|*
name|dt
parameter_list|,
specifier|const
name|unsigned
name|fast
parameter_list|)
block|{
name|BYTE
modifier|*
specifier|const
name|ostart
init|=
operator|(
name|BYTE
operator|*
operator|)
name|dst
decl_stmt|;
name|BYTE
modifier|*
name|op
init|=
name|ostart
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|omax
init|=
name|op
operator|+
name|maxDstSize
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|olimit
init|=
name|omax
operator|-
literal|3
decl_stmt|;
name|FSE_DStream_t
name|bitD
decl_stmt|;
name|FSE_DState_t
name|state1
decl_stmt|;
name|FSE_DState_t
name|state2
decl_stmt|;
name|size_t
name|errorCode
decl_stmt|;
comment|/* Init */
name|errorCode
operator|=
name|FSE_initDStream
argument_list|(
operator|&
name|bitD
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|)
expr_stmt|;
comment|/* replaced last arg by maxCompressed Size */
if|if
condition|(
name|FSE_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
name|FSE_initDState
argument_list|(
operator|&
name|state1
argument_list|,
operator|&
name|bitD
argument_list|,
name|dt
argument_list|)
expr_stmt|;
name|FSE_initDState
argument_list|(
operator|&
name|state2
argument_list|,
operator|&
name|bitD
argument_list|,
name|dt
argument_list|)
expr_stmt|;
define|#
directive|define
name|FSE_GETSYMBOL
parameter_list|(
name|statePtr
parameter_list|)
value|fast ? FSE_decodeSymbolFast(statePtr,&bitD) : FSE_decodeSymbol(statePtr,&bitD)
comment|/* 4 symbols per loop */
for|for
control|(
init|;
operator|(
name|FSE_reloadDStream
argument_list|(
operator|&
name|bitD
argument_list|)
operator|==
name|FSE_DStream_unfinished
operator|)
operator|&&
operator|(
name|op
operator|<
name|olimit
operator|)
condition|;
name|op
operator|+=
literal|4
control|)
block|{
name|op
index|[
literal|0
index|]
operator|=
name|FSE_GETSYMBOL
argument_list|(
operator|&
name|state1
argument_list|)
expr_stmt|;
if|if
condition|(
name|FSE_MAX_TABLELOG
operator|*
literal|2
operator|+
literal|7
operator|>
sizeof|sizeof
argument_list|(
name|bitD
operator|.
name|bitContainer
argument_list|)
operator|*
literal|8
condition|)
comment|/* This test must be static */
name|FSE_reloadDStream
argument_list|(
operator|&
name|bitD
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|FSE_GETSYMBOL
argument_list|(
operator|&
name|state2
argument_list|)
expr_stmt|;
if|if
condition|(
name|FSE_MAX_TABLELOG
operator|*
literal|4
operator|+
literal|7
operator|>
sizeof|sizeof
argument_list|(
name|bitD
operator|.
name|bitContainer
argument_list|)
operator|*
literal|8
condition|)
comment|/* This test must be static */
block|{
if|if
condition|(
name|FSE_reloadDStream
argument_list|(
operator|&
name|bitD
argument_list|)
operator|>
name|FSE_DStream_unfinished
condition|)
block|{
name|op
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
block|}
name|op
index|[
literal|2
index|]
operator|=
name|FSE_GETSYMBOL
argument_list|(
operator|&
name|state1
argument_list|)
expr_stmt|;
if|if
condition|(
name|FSE_MAX_TABLELOG
operator|*
literal|2
operator|+
literal|7
operator|>
sizeof|sizeof
argument_list|(
name|bitD
operator|.
name|bitContainer
argument_list|)
operator|*
literal|8
condition|)
comment|/* This test must be static */
name|FSE_reloadDStream
argument_list|(
operator|&
name|bitD
argument_list|)
expr_stmt|;
name|op
index|[
literal|3
index|]
operator|=
name|FSE_GETSYMBOL
argument_list|(
operator|&
name|state2
argument_list|)
expr_stmt|;
block|}
comment|/* tail */
comment|/* note : FSE_reloadDStream(&bitD)>= FSE_DStream_partiallyFilled; Ends at exactly FSE_DStream_completed */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|FSE_reloadDStream
argument_list|(
operator|&
name|bitD
argument_list|)
operator|>
name|FSE_DStream_completed
operator|)
operator|||
operator|(
name|op
operator|==
name|omax
operator|)
operator|||
operator|(
name|FSE_endOfDStream
argument_list|(
operator|&
name|bitD
argument_list|)
operator|&&
operator|(
name|fast
operator|||
name|FSE_endOfDState
argument_list|(
operator|&
name|state1
argument_list|)
operator|)
operator|)
condition|)
break|break;
operator|*
name|op
operator|++
operator|=
name|FSE_GETSYMBOL
argument_list|(
operator|&
name|state1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|FSE_reloadDStream
argument_list|(
operator|&
name|bitD
argument_list|)
operator|>
name|FSE_DStream_completed
operator|)
operator|||
operator|(
name|op
operator|==
name|omax
operator|)
operator|||
operator|(
name|FSE_endOfDStream
argument_list|(
operator|&
name|bitD
argument_list|)
operator|&&
operator|(
name|fast
operator|||
name|FSE_endOfDState
argument_list|(
operator|&
name|state2
argument_list|)
operator|)
operator|)
condition|)
break|break;
operator|*
name|op
operator|++
operator|=
name|FSE_GETSYMBOL
argument_list|(
operator|&
name|state2
argument_list|)
expr_stmt|;
block|}
comment|/* end ? */
if|if
condition|(
name|FSE_endOfDStream
argument_list|(
operator|&
name|bitD
argument_list|)
operator|&&
name|FSE_endOfDState
argument_list|(
operator|&
name|state1
argument_list|)
operator|&&
name|FSE_endOfDState
argument_list|(
operator|&
name|state2
argument_list|)
condition|)
return|return
name|op
operator|-
name|ostart
return|;
if|if
condition|(
name|op
operator|==
name|omax
condition|)
return|return
operator|(
name|size_t
operator|)
operator|-
name|FSE_ERROR_dstSize_tooSmall
return|;
comment|/* dst buffer is full, but cSrc unfinished */
return|return
operator|(
name|size_t
operator|)
operator|-
name|FSE_ERROR_corruptionDetected
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|FSE_decompress_usingDTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|originalSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|FSE_DTable
modifier|*
name|dt
parameter_list|)
block|{
name|FSE_DTableHeader
name|DTableH
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|DTableH
argument_list|,
name|dt
argument_list|,
sizeof|sizeof
argument_list|(
name|DTableH
argument_list|)
argument_list|)
expr_stmt|;
comment|/* memcpy() into local variable, to avoid strict aliasing warning */
comment|/* select fast mode (static) */
if|if
condition|(
name|DTableH
operator|.
name|fastMode
condition|)
return|return
name|FSE_decompress_usingDTable_generic
argument_list|(
name|dst
argument_list|,
name|originalSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|,
name|dt
argument_list|,
literal|1
argument_list|)
return|;
return|return
name|FSE_decompress_usingDTable_generic
argument_list|(
name|dst
argument_list|,
name|originalSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|,
name|dt
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|FSE_decompress
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|cSrc
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|ip
init|=
name|istart
decl_stmt|;
name|short
name|counting
index|[
name|FSE_MAX_SYMBOL_VALUE
operator|+
literal|1
index|]
decl_stmt|;
name|DTable_max_t
name|dt
decl_stmt|;
comment|/* Static analyzer seems unable to understand this table will be properly initialized later */
name|unsigned
name|tableLog
decl_stmt|;
name|unsigned
name|maxSymbolValue
init|=
name|FSE_MAX_SYMBOL_VALUE
decl_stmt|;
name|size_t
name|errorCode
decl_stmt|;
if|if
condition|(
name|cSrcSize
operator|<
literal|2
condition|)
return|return
operator|(
name|size_t
operator|)
operator|-
name|FSE_ERROR_srcSize_wrong
return|;
comment|/* too small input size */
comment|/* normal FSE decoding mode */
name|errorCode
operator|=
name|FSE_readNCount
argument_list|(
name|counting
argument_list|,
operator|&
name|maxSymbolValue
argument_list|,
operator|&
name|tableLog
argument_list|,
name|istart
argument_list|,
name|cSrcSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|FSE_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
if|if
condition|(
name|errorCode
operator|>=
name|cSrcSize
condition|)
return|return
operator|(
name|size_t
operator|)
operator|-
name|FSE_ERROR_srcSize_wrong
return|;
comment|/* too small input size */
name|ip
operator|+=
name|errorCode
expr_stmt|;
name|cSrcSize
operator|-=
name|errorCode
expr_stmt|;
name|errorCode
operator|=
name|FSE_buildDTable
argument_list|(
name|dt
argument_list|,
name|counting
argument_list|,
name|maxSymbolValue
argument_list|,
name|tableLog
argument_list|)
expr_stmt|;
if|if
condition|(
name|FSE_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
comment|/* always return, even if it is an error code */
return|return
name|FSE_decompress_usingDTable
argument_list|(
name|dst
argument_list|,
name|maxDstSize
argument_list|,
name|ip
argument_list|,
name|cSrcSize
argument_list|,
name|dt
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ******************************************************* *  Huff0 : Huffman block compression *********************************************************/
end_comment

begin_define
define|#
directive|define
name|HUF_MAX_SYMBOL_VALUE
value|255
end_define

begin_define
define|#
directive|define
name|HUF_DEFAULT_TABLELOG
value|12
end_define

begin_comment
comment|/* used by default, when not specified */
end_comment

begin_define
define|#
directive|define
name|HUF_MAX_TABLELOG
value|12
end_define

begin_comment
comment|/* max possible tableLog; for allocation purpose; can be modified */
end_comment

begin_define
define|#
directive|define
name|HUF_ABSOLUTEMAX_TABLELOG
value|16
end_define

begin_comment
comment|/* absolute limit of HUF_MAX_TABLELOG. Beyond that value, code does not work */
end_comment

begin_if
if|#
directive|if
operator|(
name|HUF_MAX_TABLELOG
operator|>
name|HUF_ABSOLUTEMAX_TABLELOG
operator|)
end_if

begin_error
error|#
directive|error
literal|"HUF_MAX_TABLELOG is too large !"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
struct|struct
name|HUF_CElt_s
block|{
name|U16
name|val
decl_stmt|;
name|BYTE
name|nbBits
decl_stmt|;
block|}
name|HUF_CElt
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|nodeElt_s
block|{
name|U32
name|count
decl_stmt|;
name|U16
name|parent
decl_stmt|;
name|BYTE
name|byte
decl_stmt|;
name|BYTE
name|nbBits
decl_stmt|;
block|}
name|nodeElt
typedef|;
end_typedef

begin_comment
comment|/* ******************************************************* *  Huff0 : Huffman block decompression *********************************************************/
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|BYTE
name|byte
decl_stmt|;
name|BYTE
name|nbBits
decl_stmt|;
block|}
name|HUF_DElt
typedef|;
end_typedef

begin_function
specifier|static
name|size_t
name|HUF_readDTable
parameter_list|(
name|U16
modifier|*
name|DTable
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
name|BYTE
name|huffWeight
index|[
name|HUF_MAX_SYMBOL_VALUE
operator|+
literal|1
index|]
decl_stmt|;
name|U32
name|rankVal
index|[
name|HUF_ABSOLUTEMAX_TABLELOG
operator|+
literal|1
index|]
decl_stmt|;
comment|/* large enough for values from 0 to 16 */
name|U32
name|weightTotal
decl_stmt|;
name|U32
name|maxBits
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
decl_stmt|;
name|size_t
name|iSize
decl_stmt|;
name|size_t
name|oSize
decl_stmt|;
name|U32
name|n
decl_stmt|;
name|U32
name|nextRankStart
decl_stmt|;
name|void
modifier|*
name|ptr
init|=
name|DTable
operator|+
literal|1
decl_stmt|;
name|HUF_DElt
modifier|*
specifier|const
name|dt
init|=
operator|(
name|HUF_DElt
operator|*
operator|)
name|ptr
decl_stmt|;
if|if
condition|(
operator|!
name|srcSize
condition|)
return|return
operator|(
name|size_t
operator|)
operator|-
name|FSE_ERROR_srcSize_wrong
return|;
name|iSize
operator|=
name|ip
index|[
literal|0
index|]
expr_stmt|;
name|FSE_STATIC_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|HUF_DElt
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|U16
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if compilation fails here, assertion is false */
comment|//memset(huffWeight, 0, sizeof(huffWeight));   /* should not be necessary, but some analyzer complain ... */
if|if
condition|(
name|iSize
operator|>=
literal|128
condition|)
comment|/* special header */
block|{
if|if
condition|(
name|iSize
operator|>=
operator|(
literal|242
operator|)
condition|)
comment|/* RLE */
block|{
specifier|static
name|int
name|l
index|[
literal|14
index|]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|7
block|,
literal|8
block|,
literal|15
block|,
literal|16
block|,
literal|31
block|,
literal|32
block|,
literal|63
block|,
literal|64
block|,
literal|127
block|,
literal|128
block|}
decl_stmt|;
name|oSize
operator|=
name|l
index|[
name|iSize
operator|-
literal|242
index|]
expr_stmt|;
name|memset
argument_list|(
name|huffWeight
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|huffWeight
argument_list|)
argument_list|)
expr_stmt|;
name|iSize
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* Incompressible */
block|{
name|oSize
operator|=
name|iSize
operator|-
literal|127
expr_stmt|;
name|iSize
operator|=
operator|(
operator|(
name|oSize
operator|+
literal|1
operator|)
operator|/
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|iSize
operator|+
literal|1
operator|>
name|srcSize
condition|)
return|return
operator|(
name|size_t
operator|)
operator|-
name|FSE_ERROR_srcSize_wrong
return|;
name|ip
operator|+=
literal|1
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|oSize
condition|;
name|n
operator|+=
literal|2
control|)
block|{
name|huffWeight
index|[
name|n
index|]
operator|=
name|ip
index|[
name|n
operator|/
literal|2
index|]
operator|>>
literal|4
expr_stmt|;
name|huffWeight
index|[
name|n
operator|+
literal|1
index|]
operator|=
name|ip
index|[
name|n
operator|/
literal|2
index|]
operator|&
literal|15
expr_stmt|;
block|}
block|}
block|}
else|else
comment|/* header compressed with FSE (normal case) */
block|{
if|if
condition|(
name|iSize
operator|+
literal|1
operator|>
name|srcSize
condition|)
return|return
operator|(
name|size_t
operator|)
operator|-
name|FSE_ERROR_srcSize_wrong
return|;
name|oSize
operator|=
name|FSE_decompress
argument_list|(
name|huffWeight
argument_list|,
name|HUF_MAX_SYMBOL_VALUE
argument_list|,
name|ip
operator|+
literal|1
argument_list|,
name|iSize
argument_list|)
expr_stmt|;
comment|/* max 255 values decoded, last one is implied */
if|if
condition|(
name|FSE_isError
argument_list|(
name|oSize
argument_list|)
condition|)
return|return
name|oSize
return|;
block|}
comment|/* collect weight stats */
name|memset
argument_list|(
name|rankVal
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rankVal
argument_list|)
argument_list|)
expr_stmt|;
name|weightTotal
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|oSize
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|huffWeight
index|[
name|n
index|]
operator|>=
name|HUF_ABSOLUTEMAX_TABLELOG
condition|)
return|return
operator|(
name|size_t
operator|)
operator|-
name|FSE_ERROR_corruptionDetected
return|;
name|rankVal
index|[
name|huffWeight
index|[
name|n
index|]
index|]
operator|++
expr_stmt|;
name|weightTotal
operator|+=
operator|(
literal|1
operator|<<
name|huffWeight
index|[
name|n
index|]
operator|)
operator|>>
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|weightTotal
operator|==
literal|0
condition|)
return|return
operator|(
name|size_t
operator|)
operator|-
name|FSE_ERROR_corruptionDetected
return|;
comment|/* get last non-null symbol weight (implied, total must be 2^n) */
name|maxBits
operator|=
name|FSE_highbit32
argument_list|(
name|weightTotal
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|maxBits
operator|>
name|DTable
index|[
literal|0
index|]
condition|)
return|return
operator|(
name|size_t
operator|)
operator|-
name|FSE_ERROR_tableLog_tooLarge
return|;
comment|/* DTable is too small */
name|DTable
index|[
literal|0
index|]
operator|=
operator|(
name|U16
operator|)
name|maxBits
expr_stmt|;
block|{
name|U32
name|total
init|=
literal|1
operator|<<
name|maxBits
decl_stmt|;
name|U32
name|rest
init|=
name|total
operator|-
name|weightTotal
decl_stmt|;
name|U32
name|verif
init|=
literal|1
operator|<<
name|FSE_highbit32
argument_list|(
name|rest
argument_list|)
decl_stmt|;
name|U32
name|lastWeight
init|=
name|FSE_highbit32
argument_list|(
name|rest
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|verif
operator|!=
name|rest
condition|)
return|return
operator|(
name|size_t
operator|)
operator|-
name|FSE_ERROR_corruptionDetected
return|;
comment|/* last value must be a clean power of 2 */
name|huffWeight
index|[
name|oSize
index|]
operator|=
operator|(
name|BYTE
operator|)
name|lastWeight
expr_stmt|;
name|rankVal
index|[
name|lastWeight
index|]
operator|++
expr_stmt|;
block|}
comment|/* check tree construction validity */
if|if
condition|(
operator|(
name|rankVal
index|[
literal|1
index|]
operator|<
literal|2
operator|)
operator|||
operator|(
name|rankVal
index|[
literal|1
index|]
operator|&
literal|1
operator|)
condition|)
return|return
operator|(
name|size_t
operator|)
operator|-
name|FSE_ERROR_corruptionDetected
return|;
comment|/* by construction : at least 2 elts of rank 1, must be even */
comment|/* Prepare ranks */
name|nextRankStart
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|1
init|;
name|n
operator|<=
name|maxBits
condition|;
name|n
operator|++
control|)
block|{
name|U32
name|current
init|=
name|nextRankStart
decl_stmt|;
name|nextRankStart
operator|+=
operator|(
name|rankVal
index|[
name|n
index|]
operator|<<
operator|(
name|n
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|rankVal
index|[
name|n
index|]
operator|=
name|current
expr_stmt|;
block|}
comment|/* fill DTable */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<=
name|oSize
condition|;
name|n
operator|++
control|)
block|{
specifier|const
name|U32
name|w
init|=
name|huffWeight
index|[
name|n
index|]
decl_stmt|;
specifier|const
name|U32
name|length
init|=
operator|(
literal|1
operator|<<
name|w
operator|)
operator|>>
literal|1
decl_stmt|;
name|U32
name|i
decl_stmt|;
name|HUF_DElt
name|D
decl_stmt|;
name|D
operator|.
name|byte
operator|=
operator|(
name|BYTE
operator|)
name|n
expr_stmt|;
name|D
operator|.
name|nbBits
operator|=
call|(
name|BYTE
call|)
argument_list|(
name|maxBits
operator|+
literal|1
operator|-
name|w
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|rankVal
index|[
name|w
index|]
init|;
name|i
operator|<
name|rankVal
index|[
name|w
index|]
operator|+
name|length
condition|;
name|i
operator|++
control|)
name|dt
index|[
name|i
index|]
operator|=
name|D
expr_stmt|;
name|rankVal
index|[
name|w
index|]
operator|+=
name|length
expr_stmt|;
block|}
return|return
name|iSize
operator|+
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|BYTE
name|HUF_decodeSymbol
parameter_list|(
name|FSE_DStream_t
modifier|*
name|Dstream
parameter_list|,
specifier|const
name|HUF_DElt
modifier|*
name|dt
parameter_list|,
specifier|const
name|U32
name|dtLog
parameter_list|)
block|{
specifier|const
name|size_t
name|val
init|=
name|FSE_lookBitsFast
argument_list|(
name|Dstream
argument_list|,
name|dtLog
argument_list|)
decl_stmt|;
comment|/* note : dtLog>= 1 */
specifier|const
name|BYTE
name|c
init|=
name|dt
index|[
name|val
index|]
operator|.
name|byte
decl_stmt|;
name|FSE_skipBits
argument_list|(
name|Dstream
argument_list|,
name|dt
index|[
name|val
index|]
operator|.
name|nbBits
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|HUF_decompress_usingDTable
parameter_list|(
comment|/* -3% slower when non static */
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|U16
modifier|*
name|DTable
parameter_list|)
block|{
name|BYTE
modifier|*
specifier|const
name|ostart
init|=
operator|(
name|BYTE
operator|*
operator|)
name|dst
decl_stmt|;
name|BYTE
modifier|*
name|op
init|=
name|ostart
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|omax
init|=
name|op
operator|+
name|maxDstSize
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|olimit
init|=
name|omax
operator|-
literal|15
decl_stmt|;
specifier|const
name|void
modifier|*
name|ptr
init|=
name|DTable
decl_stmt|;
specifier|const
name|HUF_DElt
modifier|*
specifier|const
name|dt
init|=
operator|(
specifier|const
name|HUF_DElt
operator|*
operator|)
operator|(
name|ptr
operator|)
operator|+
literal|1
decl_stmt|;
specifier|const
name|U32
name|dtLog
init|=
name|DTable
index|[
literal|0
index|]
decl_stmt|;
name|size_t
name|errorCode
decl_stmt|;
name|U32
name|reloadStatus
decl_stmt|;
comment|/* Init */
specifier|const
name|U16
modifier|*
name|jumpTable
init|=
operator|(
specifier|const
name|U16
operator|*
operator|)
name|cSrc
decl_stmt|;
specifier|const
name|size_t
name|length1
init|=
name|FSE_readLE16
argument_list|(
name|jumpTable
argument_list|)
decl_stmt|;
specifier|const
name|size_t
name|length2
init|=
name|FSE_readLE16
argument_list|(
name|jumpTable
operator|+
literal|1
argument_list|)
decl_stmt|;
specifier|const
name|size_t
name|length3
init|=
name|FSE_readLE16
argument_list|(
name|jumpTable
operator|+
literal|2
argument_list|)
decl_stmt|;
specifier|const
name|size_t
name|length4
init|=
name|cSrcSize
operator|-
literal|6
operator|-
name|length1
operator|-
name|length2
operator|-
name|length3
decl_stmt|;
comment|// check coherency !!
specifier|const
name|char
modifier|*
specifier|const
name|start1
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|cSrc
operator|)
operator|+
literal|6
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|start2
init|=
name|start1
operator|+
name|length1
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|start3
init|=
name|start2
operator|+
name|length2
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|start4
init|=
name|start3
operator|+
name|length3
decl_stmt|;
name|FSE_DStream_t
name|bitD1
decl_stmt|,
name|bitD2
decl_stmt|,
name|bitD3
decl_stmt|,
name|bitD4
decl_stmt|;
if|if
condition|(
name|length1
operator|+
name|length2
operator|+
name|length3
operator|+
literal|6
operator|>=
name|cSrcSize
condition|)
return|return
operator|(
name|size_t
operator|)
operator|-
name|FSE_ERROR_srcSize_wrong
return|;
name|errorCode
operator|=
name|FSE_initDStream
argument_list|(
operator|&
name|bitD1
argument_list|,
name|start1
argument_list|,
name|length1
argument_list|)
expr_stmt|;
if|if
condition|(
name|FSE_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
name|errorCode
operator|=
name|FSE_initDStream
argument_list|(
operator|&
name|bitD2
argument_list|,
name|start2
argument_list|,
name|length2
argument_list|)
expr_stmt|;
if|if
condition|(
name|FSE_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
name|errorCode
operator|=
name|FSE_initDStream
argument_list|(
operator|&
name|bitD3
argument_list|,
name|start3
argument_list|,
name|length3
argument_list|)
expr_stmt|;
if|if
condition|(
name|FSE_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
name|errorCode
operator|=
name|FSE_initDStream
argument_list|(
operator|&
name|bitD4
argument_list|,
name|start4
argument_list|,
name|length4
argument_list|)
expr_stmt|;
if|if
condition|(
name|FSE_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
name|reloadStatus
operator|=
name|FSE_reloadDStream
argument_list|(
operator|&
name|bitD2
argument_list|)
expr_stmt|;
comment|/* 16 symbols per loop */
for|for
control|(
init|;
operator|(
name|reloadStatus
operator|<
name|FSE_DStream_completed
operator|)
operator|&&
operator|(
name|op
operator|<
name|olimit
operator|)
condition|;
comment|/* D2-3-4 are supposed to be synchronized and finish together */
name|op
operator|+=
literal|16
operator|,
name|reloadStatus
operator|=
name|FSE_reloadDStream
argument_list|(
operator|&
name|bitD2
argument_list|)
operator||
name|FSE_reloadDStream
argument_list|(
operator|&
name|bitD3
argument_list|)
operator||
name|FSE_reloadDStream
argument_list|(
operator|&
name|bitD4
argument_list|)
operator|,
name|FSE_reloadDStream
argument_list|(
operator|&
name|bitD1
argument_list|)
control|)
block|{
define|#
directive|define
name|HUF_DECODE_SYMBOL_0
parameter_list|(
name|n
parameter_list|,
name|Dstream
parameter_list|)
define|\
value|op[n] = HUF_decodeSymbol(&Dstream, dt, dtLog);
define|#
directive|define
name|HUF_DECODE_SYMBOL_1
parameter_list|(
name|n
parameter_list|,
name|Dstream
parameter_list|)
define|\
value|op[n] = HUF_decodeSymbol(&Dstream, dt, dtLog); \         if (FSE_32bits()&& (HUF_MAX_TABLELOG>12)) FSE_reloadDStream(&Dstream)
define|#
directive|define
name|HUF_DECODE_SYMBOL_2
parameter_list|(
name|n
parameter_list|,
name|Dstream
parameter_list|)
define|\
value|op[n] = HUF_decodeSymbol(&Dstream, dt, dtLog); \         if (FSE_32bits()) FSE_reloadDStream(&Dstream)
name|HUF_DECODE_SYMBOL_1
argument_list|(
literal|0
argument_list|,
name|bitD1
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOL_1
argument_list|(
literal|1
argument_list|,
name|bitD2
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOL_1
argument_list|(
literal|2
argument_list|,
name|bitD3
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOL_1
argument_list|(
literal|3
argument_list|,
name|bitD4
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOL_2
argument_list|(
literal|4
argument_list|,
name|bitD1
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOL_2
argument_list|(
literal|5
argument_list|,
name|bitD2
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOL_2
argument_list|(
literal|6
argument_list|,
name|bitD3
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOL_2
argument_list|(
literal|7
argument_list|,
name|bitD4
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOL_1
argument_list|(
literal|8
argument_list|,
name|bitD1
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOL_1
argument_list|(
literal|9
argument_list|,
name|bitD2
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOL_1
argument_list|(
literal|10
argument_list|,
name|bitD3
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOL_1
argument_list|(
literal|11
argument_list|,
name|bitD4
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOL_0
argument_list|(
literal|12
argument_list|,
name|bitD1
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOL_0
argument_list|(
literal|13
argument_list|,
name|bitD2
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOL_0
argument_list|(
literal|14
argument_list|,
name|bitD3
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOL_0
argument_list|(
literal|15
argument_list|,
name|bitD4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reloadStatus
operator|!=
name|FSE_DStream_completed
condition|)
comment|/* not complete : some bitStream might be FSE_DStream_unfinished */
return|return
operator|(
name|size_t
operator|)
operator|-
name|FSE_ERROR_corruptionDetected
return|;
comment|/* tail */
block|{
comment|// bitTail = bitD1;   // *much* slower : -20% !??!
name|FSE_DStream_t
name|bitTail
decl_stmt|;
name|bitTail
operator|.
name|ptr
operator|=
name|bitD1
operator|.
name|ptr
expr_stmt|;
name|bitTail
operator|.
name|bitsConsumed
operator|=
name|bitD1
operator|.
name|bitsConsumed
expr_stmt|;
name|bitTail
operator|.
name|bitContainer
operator|=
name|bitD1
operator|.
name|bitContainer
expr_stmt|;
comment|// required in case of FSE_DStream_endOfBuffer
name|bitTail
operator|.
name|start
operator|=
name|start1
expr_stmt|;
for|for
control|(
init|;
operator|(
name|FSE_reloadDStream
argument_list|(
operator|&
name|bitTail
argument_list|)
operator|<
name|FSE_DStream_completed
operator|)
operator|&&
operator|(
name|op
operator|<
name|omax
operator|)
condition|;
name|op
operator|++
control|)
block|{
name|HUF_DECODE_SYMBOL_0
argument_list|(
literal|0
argument_list|,
name|bitTail
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|FSE_endOfDStream
argument_list|(
operator|&
name|bitTail
argument_list|)
condition|)
return|return
name|op
operator|-
name|ostart
return|;
block|}
if|if
condition|(
name|op
operator|==
name|omax
condition|)
return|return
operator|(
name|size_t
operator|)
operator|-
name|FSE_ERROR_dstSize_tooSmall
return|;
comment|/* dst buffer is full, but cSrc unfinished */
return|return
operator|(
name|size_t
operator|)
operator|-
name|FSE_ERROR_corruptionDetected
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|HUF_decompress
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
block|{
name|HUF_CREATE_STATIC_DTABLE
argument_list|(
name|DTable
argument_list|,
name|HUF_MAX_TABLELOG
argument_list|)
expr_stmt|;
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|cSrc
decl_stmt|;
name|size_t
name|errorCode
decl_stmt|;
name|errorCode
operator|=
name|HUF_readDTable
argument_list|(
name|DTable
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|FSE_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
if|if
condition|(
name|errorCode
operator|>=
name|cSrcSize
condition|)
return|return
operator|(
name|size_t
operator|)
operator|-
name|FSE_ERROR_srcSize_wrong
return|;
name|ip
operator|+=
name|errorCode
expr_stmt|;
name|cSrcSize
operator|-=
name|errorCode
expr_stmt|;
return|return
name|HUF_decompress_usingDTable
argument_list|(
name|dst
argument_list|,
name|maxDstSize
argument_list|,
name|ip
argument_list|,
name|cSrcSize
argument_list|,
name|DTable
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FSE_COMMONDEFS_ONLY */
end_comment

begin_comment
comment|/*     zstd - standard compression library     Copyright (C) 2014-2015, Yann Collet.      BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)      Redistribution and use in source and binary forms, with or without     modification, are permitted provided that the following conditions are     met:     * Redistributions of source code must retain the above copyright     notice, this list of conditions and the following disclaimer.     * Redistributions in binary form must reproduce the above     copyright notice, this list of conditions and the following disclaimer     in the documentation and/or other materials provided with the     distribution.     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS     "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR     A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT     OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT     LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY     THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE     OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.      You can contact the author at :     - zstd source repository : https://github.com/Cyan4973/zstd     - ztsd public forum : https://groups.google.com/forum/#!forum/lz4c */
end_comment

begin_comment
comment|/**************************************************************** *  Tuning parameters *****************************************************************/
end_comment

begin_comment
comment|/* MEMORY_USAGE : *  Memory usage formula : N->2^N Bytes (examples : 10 -> 1KB; 12 -> 4KB ; 16 -> 64KB; 20 -> 1MB; etc.) *  Increasing memory usage improves compression ratio *  Reduced memory usage can improve speed, due to cache effect */
end_comment

begin_define
define|#
directive|define
name|ZSTD_MEMORY_USAGE
value|17
end_define

begin_comment
comment|/**************************************    CPU Feature Detection **************************************/
end_comment

begin_comment
comment|/*  * Automated efficient unaligned memory access detection  * Based on known hardware architectures  * This list will be updated thanks to feedbacks  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CPU_HAS_EFFICIENT_UNALIGNED_MEMORY_ACCESS
argument_list|)
expr|\
operator|||
name|defined
argument_list|(
name|__ARM_FEATURE_UNALIGNED
argument_list|)
expr|\
operator|||
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__x86_64__
argument_list|)
expr|\
operator|||
name|defined
argument_list|(
name|_M_IX86
argument_list|)
operator|||
name|defined
argument_list|(
name|_M_X64
argument_list|)
expr|\
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_7__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_8__
argument_list|)
expr|\
operator|||
operator|(
name|defined
argument_list|(
name|_M_ARM
argument_list|)
operator|&&
operator|(
name|_M_ARM
operator|>=
literal|7
operator|)
operator|)
end_if

begin_define
define|#
directive|define
name|ZSTD_UNALIGNED_ACCESS
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ZSTD_UNALIGNED_ACCESS
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/******************************************************** *  Includes *********************************************************/
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* calloc */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* memcpy, memmove */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* debug : printf */
end_comment

begin_comment
comment|/******************************************************** *  Compiler specifics *********************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__AVX2__
end_ifdef

begin_include
include|#
directive|include
file|<immintrin.h>
end_include

begin_comment
comment|/* AVX2 intrinsics */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_comment
comment|/* Visual Studio */
end_comment

begin_include
include|#
directive|include
file|<intrin.h>
end_include

begin_comment
comment|/* For Visual 2005 */
end_comment

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4127
name|)
end_pragma

begin_comment
comment|/* disable: C4127: conditional expression is constant */
end_comment

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4324
name|)
end_pragma

begin_comment
comment|/* disable: C4324: padded structure */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MEM_ACCESS_MODULE
end_ifndef

begin_define
define|#
directive|define
name|MEM_ACCESS_MODULE
end_define

begin_comment
comment|/******************************************************** *  Basic Types *********************************************************/
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC_VERSION__
argument_list|)
operator|&&
name|__STDC_VERSION__
operator|>=
literal|199901L
end_if

begin_comment
comment|/* C99 */
end_comment

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_typedef
typedef|typedef
name|uint8_t
name|BYTE
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|uint16_t
name|U16
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|int16_t
name|S16
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|uint32_t
name|U32
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|int32_t
name|S32
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|uint64_t
name|U64
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|unsigned
name|char
name|BYTE
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|short
name|U16
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|signed
name|short
name|S16
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|int
name|U32
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|signed
name|int
name|S32
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|long
name|long
name|U64
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MEM_ACCESS_MODULE */
end_comment

begin_comment
comment|/******************************************************** *  Constants *********************************************************/
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|U32
name|ZSTD_magicNumber
init|=
literal|0xFD2FB51E
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 3rd version : seqNb header */
end_comment

begin_define
define|#
directive|define
name|HASH_LOG
value|(ZSTD_MEMORY_USAGE - 2)
end_define

begin_define
define|#
directive|define
name|HASH_TABLESIZE
value|(1<< HASH_LOG)
end_define

begin_define
define|#
directive|define
name|HASH_MASK
value|(HASH_TABLESIZE - 1)
end_define

begin_define
define|#
directive|define
name|KNUTH
value|2654435761
end_define

begin_define
define|#
directive|define
name|BIT7
value|128
end_define

begin_define
define|#
directive|define
name|BIT6
value|64
end_define

begin_define
define|#
directive|define
name|BIT5
value|32
end_define

begin_define
define|#
directive|define
name|BIT4
value|16
end_define

begin_define
define|#
directive|define
name|KB
value|*(1<<10)
end_define

begin_define
define|#
directive|define
name|MB
value|*(1<<20)
end_define

begin_define
define|#
directive|define
name|GB
value|*(1U<<30)
end_define

begin_define
define|#
directive|define
name|BLOCKSIZE
value|(128 KB)
end_define

begin_comment
comment|/* define, for static allocation */
end_comment

begin_define
define|#
directive|define
name|WORKPLACESIZE
value|(BLOCKSIZE*3)
end_define

begin_define
define|#
directive|define
name|MINMATCH
value|4
end_define

begin_define
define|#
directive|define
name|MLbits
value|7
end_define

begin_define
define|#
directive|define
name|LLbits
value|6
end_define

begin_define
define|#
directive|define
name|Offbits
value|5
end_define

begin_define
define|#
directive|define
name|MaxML
value|((1<<MLbits )-1)
end_define

begin_define
define|#
directive|define
name|MaxLL
value|((1<<LLbits )-1)
end_define

begin_define
define|#
directive|define
name|MaxOff
value|((1<<Offbits)-1)
end_define

begin_define
define|#
directive|define
name|LitFSELog
value|11
end_define

begin_define
define|#
directive|define
name|MLFSELog
value|10
end_define

begin_define
define|#
directive|define
name|LLFSELog
value|10
end_define

begin_define
define|#
directive|define
name|OffFSELog
value|9
end_define

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)<(b)?(b):(a))
end_define

begin_define
define|#
directive|define
name|MaxSeq
value|MAX(MaxLL, MaxML)
end_define

begin_define
define|#
directive|define
name|LITERAL_NOENTROPY
value|63
end_define

begin_define
define|#
directive|define
name|COMMAND_NOENTROPY
value|7
end_define

begin_comment
comment|/* to remove */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|size_t
name|ZSTD_blockHeaderSize
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|size_t
name|ZSTD_frameHeaderSize
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/******************************************************** *  Memory operations *********************************************************/
end_comment

begin_function
specifier|static
name|unsigned
name|ZSTD_32bits
parameter_list|(
name|void
parameter_list|)
block|{
return|return
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|==
literal|4
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|ZSTD_isLittleEndian
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
union|union
block|{
name|U32
name|i
decl_stmt|;
name|BYTE
name|c
index|[
literal|4
index|]
decl_stmt|;
block|}
name|one
init|=
block|{
literal|1
block|}
union|;
comment|/* don't use static : performance detrimental  */
return|return
name|one
operator|.
name|c
index|[
literal|0
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|U16
name|ZSTD_read16
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
name|U16
name|r
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|r
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|U32
name|ZSTD_read32
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
name|U32
name|r
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|r
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ZSTD_copy4
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|)
block|{
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ZSTD_copy8
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|)
block|{
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|COPY8
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|)
value|{ ZSTD_copy8(d,s); d+=8; s+=8; }
end_define

begin_function
specifier|static
name|void
name|ZSTD_wildcopy
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|ptrdiff_t
name|length
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
decl_stmt|;
name|BYTE
modifier|*
name|op
init|=
operator|(
name|BYTE
operator|*
operator|)
name|dst
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|oend
init|=
name|op
operator|+
name|length
decl_stmt|;
while|while
condition|(
name|op
operator|<
name|oend
condition|)
name|COPY8
argument_list|(
name|op
argument_list|,
name|ip
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|U16
name|ZSTD_readLE16
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
if|if
condition|(
name|ZSTD_isLittleEndian
argument_list|()
condition|)
return|return
name|ZSTD_read16
argument_list|(
name|memPtr
argument_list|)
return|;
else|else
block|{
specifier|const
name|BYTE
modifier|*
name|p
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|memPtr
decl_stmt|;
return|return
call|(
name|U16
call|)
argument_list|(
operator|(
name|U16
operator|)
name|p
index|[
literal|0
index|]
operator|+
operator|(
operator|(
name|U16
operator|)
name|p
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|U32
name|ZSTD_readLE32
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
if|if
condition|(
name|ZSTD_isLittleEndian
argument_list|()
condition|)
return|return
name|ZSTD_read32
argument_list|(
name|memPtr
argument_list|)
return|;
else|else
block|{
specifier|const
name|BYTE
modifier|*
name|p
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|memPtr
decl_stmt|;
return|return
call|(
name|U32
call|)
argument_list|(
operator|(
name|U32
operator|)
name|p
index|[
literal|0
index|]
operator|+
operator|(
operator|(
name|U32
operator|)
name|p
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
operator|(
name|U32
operator|)
name|p
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
operator|(
name|U32
operator|)
name|p
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|U32
name|ZSTD_readBE32
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|p
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|memPtr
decl_stmt|;
return|return
call|(
name|U32
call|)
argument_list|(
operator|(
operator|(
name|U32
operator|)
name|p
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator|+
operator|(
operator|(
name|U32
operator|)
name|p
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
operator|(
name|U32
operator|)
name|p
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
operator|(
name|U32
operator|)
name|p
index|[
literal|3
index|]
operator|<<
literal|0
operator|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/************************************** *  Local structures ***************************************/
end_comment

begin_typedef
typedef|typedef
name|struct
name|ZSTD_Cctx_s
name|ZSTD_Cctx
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|bt_compressed
block|,
name|bt_raw
block|,
name|bt_rle
block|,
name|bt_end
block|}
name|blockType_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|blockType_t
name|blockType
decl_stmt|;
name|U32
name|origSize
decl_stmt|;
block|}
name|blockProperties_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|void
modifier|*
name|buffer
decl_stmt|;
name|U32
modifier|*
name|offsetStart
decl_stmt|;
name|U32
modifier|*
name|offset
decl_stmt|;
name|BYTE
modifier|*
name|offCodeStart
decl_stmt|;
name|BYTE
modifier|*
name|offCode
decl_stmt|;
name|BYTE
modifier|*
name|litStart
decl_stmt|;
name|BYTE
modifier|*
name|lit
decl_stmt|;
name|BYTE
modifier|*
name|litLengthStart
decl_stmt|;
name|BYTE
modifier|*
name|litLength
decl_stmt|;
name|BYTE
modifier|*
name|matchLengthStart
decl_stmt|;
name|BYTE
modifier|*
name|matchLength
decl_stmt|;
name|BYTE
modifier|*
name|dumpsStart
decl_stmt|;
name|BYTE
modifier|*
name|dumps
decl_stmt|;
block|}
name|seqStore_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|ZSTD_Cctx_s
block|{
specifier|const
name|BYTE
modifier|*
name|base
decl_stmt|;
name|U32
name|current
decl_stmt|;
name|U32
name|nextUpdate
decl_stmt|;
name|seqStore_t
name|seqStore
decl_stmt|;
ifdef|#
directive|ifdef
name|__AVX2__
name|__m256i
name|hashTable
index|[
name|HASH_TABLESIZE
operator|>>
literal|3
index|]
expr_stmt|;
else|#
directive|else
name|U32
name|hashTable
index|[
name|HASH_TABLESIZE
index|]
decl_stmt|;
endif|#
directive|endif
name|BYTE
name|buffer
index|[
name|WORKPLACESIZE
index|]
decl_stmt|;
block|}
name|cctxi_t
typedef|;
end_typedef

begin_comment
comment|/************************************** *  Error Management **************************************/
end_comment

begin_comment
comment|/* published entry point */
end_comment

begin_function
name|unsigned
name|ZSTDv01_isError
parameter_list|(
name|size_t
name|code
parameter_list|)
block|{
return|return
name|ERR_isError
argument_list|(
name|code
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/************************************** *  Tool functions **************************************/
end_comment

begin_define
define|#
directive|define
name|ZSTD_VERSION_MAJOR
value|0
end_define

begin_comment
comment|/* for breaking interface changes  */
end_comment

begin_define
define|#
directive|define
name|ZSTD_VERSION_MINOR
value|1
end_define

begin_comment
comment|/* for new (non-breaking) interface capabilities */
end_comment

begin_define
define|#
directive|define
name|ZSTD_VERSION_RELEASE
value|3
end_define

begin_comment
comment|/* for tweaks, bug-fixes, or development */
end_comment

begin_define
define|#
directive|define
name|ZSTD_VERSION_NUMBER
value|(ZSTD_VERSION_MAJOR *100*100 + ZSTD_VERSION_MINOR *100 + ZSTD_VERSION_RELEASE)
end_define

begin_comment
comment|/************************************************************** *   Decompression code **************************************************************/
end_comment

begin_function
name|size_t
name|ZSTDv01_getcBlockSize
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|blockProperties_t
modifier|*
name|bpPtr
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|in
init|=
operator|(
specifier|const
name|BYTE
operator|*
specifier|const
operator|)
name|src
decl_stmt|;
name|BYTE
name|headerFlags
decl_stmt|;
name|U32
name|cSize
decl_stmt|;
if|if
condition|(
name|srcSize
operator|<
literal|3
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|headerFlags
operator|=
operator|*
name|in
expr_stmt|;
name|cSize
operator|=
name|in
index|[
literal|2
index|]
operator|+
operator|(
name|in
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
operator|(
name|in
index|[
literal|0
index|]
operator|&
literal|7
operator|)
operator|<<
literal|16
operator|)
expr_stmt|;
name|bpPtr
operator|->
name|blockType
operator|=
call|(
name|blockType_t
call|)
argument_list|(
name|headerFlags
operator|>>
literal|6
argument_list|)
expr_stmt|;
name|bpPtr
operator|->
name|origSize
operator|=
operator|(
name|bpPtr
operator|->
name|blockType
operator|==
name|bt_rle
operator|)
condition|?
name|cSize
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|bpPtr
operator|->
name|blockType
operator|==
name|bt_end
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|bpPtr
operator|->
name|blockType
operator|==
name|bt_rle
condition|)
return|return
literal|1
return|;
return|return
name|cSize
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|ZSTD_copyUncompressedBlock
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
if|if
condition|(
name|srcSize
operator|>
name|maxDstSize
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
expr_stmt|;
return|return
name|srcSize
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|ZSTD_decompressLiterals
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
name|BYTE
modifier|*
name|op
init|=
operator|(
name|BYTE
operator|*
operator|)
name|dst
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|oend
init|=
name|op
operator|+
name|maxDstSize
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
decl_stmt|;
name|size_t
name|errorCode
decl_stmt|;
name|size_t
name|litSize
decl_stmt|;
comment|/* check : minimum 2, for litSize, +1, for content */
if|if
condition|(
name|srcSize
operator|<=
literal|3
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
name|litSize
operator|=
name|ip
index|[
literal|1
index|]
operator|+
operator|(
name|ip
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|litSize
operator|+=
operator|(
operator|(
name|ip
index|[
operator|-
literal|3
index|]
operator|>>
literal|3
operator|)
operator|&
literal|7
operator|)
operator|<<
literal|16
expr_stmt|;
comment|// mmmmh....
name|op
operator|=
name|oend
operator|-
name|litSize
expr_stmt|;
operator|(
name|void
operator|)
name|ctx
expr_stmt|;
if|if
condition|(
name|litSize
operator|>
name|maxDstSize
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
name|errorCode
operator|=
name|HUF_decompress
argument_list|(
name|op
argument_list|,
name|litSize
argument_list|,
name|ip
operator|+
literal|2
argument_list|,
name|srcSize
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|FSE_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
return|return
name|litSize
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTDv01_decodeLiteralsBlock
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|BYTE
modifier|*
modifier|*
name|litStart
parameter_list|,
name|size_t
modifier|*
name|litSize
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart
init|=
operator|(
specifier|const
name|BYTE
operator|*
specifier|const
operator|)
name|src
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|ip
init|=
name|istart
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|ostart
init|=
operator|(
name|BYTE
operator|*
specifier|const
operator|)
name|dst
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|oend
init|=
name|ostart
operator|+
name|maxDstSize
decl_stmt|;
name|blockProperties_t
name|litbp
decl_stmt|;
name|size_t
name|litcSize
init|=
name|ZSTDv01_getcBlockSize
argument_list|(
name|src
argument_list|,
name|srcSize
argument_list|,
operator|&
name|litbp
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTDv01_isError
argument_list|(
name|litcSize
argument_list|)
condition|)
return|return
name|litcSize
return|;
if|if
condition|(
name|litcSize
operator|>
name|srcSize
operator|-
name|ZSTD_blockHeaderSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|ip
operator|+=
name|ZSTD_blockHeaderSize
expr_stmt|;
switch|switch
condition|(
name|litbp
operator|.
name|blockType
condition|)
block|{
case|case
name|bt_raw
case|:
operator|*
name|litStart
operator|=
name|ip
expr_stmt|;
name|ip
operator|+=
name|litcSize
expr_stmt|;
operator|*
name|litSize
operator|=
name|litcSize
expr_stmt|;
break|break;
case|case
name|bt_rle
case|:
block|{
name|size_t
name|rleSize
init|=
name|litbp
operator|.
name|origSize
decl_stmt|;
if|if
condition|(
name|rleSize
operator|>
name|maxDstSize
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
if|if
condition|(
operator|!
name|srcSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|memset
argument_list|(
name|oend
operator|-
name|rleSize
argument_list|,
operator|*
name|ip
argument_list|,
name|rleSize
argument_list|)
expr_stmt|;
operator|*
name|litStart
operator|=
name|oend
operator|-
name|rleSize
expr_stmt|;
operator|*
name|litSize
operator|=
name|rleSize
expr_stmt|;
name|ip
operator|++
expr_stmt|;
break|break;
block|}
case|case
name|bt_compressed
case|:
block|{
name|size_t
name|decodedLitSize
init|=
name|ZSTD_decompressLiterals
argument_list|(
name|ctx
argument_list|,
name|dst
argument_list|,
name|maxDstSize
argument_list|,
name|ip
argument_list|,
name|litcSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTDv01_isError
argument_list|(
name|decodedLitSize
argument_list|)
condition|)
return|return
name|decodedLitSize
return|;
operator|*
name|litStart
operator|=
name|oend
operator|-
name|decodedLitSize
expr_stmt|;
operator|*
name|litSize
operator|=
name|decodedLitSize
expr_stmt|;
name|ip
operator|+=
name|litcSize
expr_stmt|;
break|break;
block|}
case|case
name|bt_end
case|:
default|default:
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
block|}
return|return
name|ip
operator|-
name|istart
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTDv01_decodeSeqHeaders
parameter_list|(
name|int
modifier|*
name|nbSeq
parameter_list|,
specifier|const
name|BYTE
modifier|*
modifier|*
name|dumpsPtr
parameter_list|,
name|size_t
modifier|*
name|dumpsLengthPtr
parameter_list|,
name|FSE_DTable
modifier|*
name|DTableLL
parameter_list|,
name|FSE_DTable
modifier|*
name|DTableML
parameter_list|,
name|FSE_DTable
modifier|*
name|DTableOffb
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart
init|=
operator|(
specifier|const
name|BYTE
operator|*
specifier|const
operator|)
name|src
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|ip
init|=
name|istart
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|iend
init|=
name|istart
operator|+
name|srcSize
decl_stmt|;
name|U32
name|LLtype
decl_stmt|,
name|Offtype
decl_stmt|,
name|MLtype
decl_stmt|;
name|U32
name|LLlog
decl_stmt|,
name|Offlog
decl_stmt|,
name|MLlog
decl_stmt|;
name|size_t
name|dumpsLength
decl_stmt|;
comment|/* check */
if|if
condition|(
name|srcSize
operator|<
literal|5
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
comment|/* SeqHead */
operator|*
name|nbSeq
operator|=
name|ZSTD_readLE16
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|ip
operator|+=
literal|2
expr_stmt|;
name|LLtype
operator|=
operator|*
name|ip
operator|>>
literal|6
expr_stmt|;
name|Offtype
operator|=
operator|(
operator|*
name|ip
operator|>>
literal|4
operator|)
operator|&
literal|3
expr_stmt|;
name|MLtype
operator|=
operator|(
operator|*
name|ip
operator|>>
literal|2
operator|)
operator|&
literal|3
expr_stmt|;
if|if
condition|(
operator|*
name|ip
operator|&
literal|2
condition|)
block|{
name|dumpsLength
operator|=
name|ip
index|[
literal|2
index|]
expr_stmt|;
name|dumpsLength
operator|+=
name|ip
index|[
literal|1
index|]
operator|<<
literal|8
expr_stmt|;
name|ip
operator|+=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|dumpsLength
operator|=
name|ip
index|[
literal|1
index|]
expr_stmt|;
name|dumpsLength
operator|+=
operator|(
name|ip
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|<<
literal|8
expr_stmt|;
name|ip
operator|+=
literal|2
expr_stmt|;
block|}
operator|*
name|dumpsPtr
operator|=
name|ip
expr_stmt|;
name|ip
operator|+=
name|dumpsLength
expr_stmt|;
operator|*
name|dumpsLengthPtr
operator|=
name|dumpsLength
expr_stmt|;
comment|/* check */
if|if
condition|(
name|ip
operator|>
name|iend
operator|-
literal|3
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
comment|/* min : all 3 are "raw", hence no header, but at least xxLog bits per type */
comment|/* sequences */
block|{
name|S16
name|norm
index|[
name|MaxML
operator|+
literal|1
index|]
decl_stmt|;
comment|/* assumption : MaxML>= MaxLL and MaxOff */
name|size_t
name|headerSize
decl_stmt|;
comment|/* Build DTables */
switch|switch
condition|(
name|LLtype
condition|)
block|{
case|case
name|bt_rle
case|:
name|LLlog
operator|=
literal|0
expr_stmt|;
name|FSE_buildDTable_rle
argument_list|(
name|DTableLL
argument_list|,
operator|*
name|ip
operator|++
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_raw
case|:
name|LLlog
operator|=
name|LLbits
expr_stmt|;
name|FSE_buildDTable_raw
argument_list|(
name|DTableLL
argument_list|,
name|LLbits
argument_list|)
expr_stmt|;
break|break;
default|default :
block|{
name|U32
name|max
init|=
name|MaxLL
decl_stmt|;
name|headerSize
operator|=
name|FSE_readNCount
argument_list|(
name|norm
argument_list|,
operator|&
name|max
argument_list|,
operator|&
name|LLlog
argument_list|,
name|ip
argument_list|,
name|iend
operator|-
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|FSE_isError
argument_list|(
name|headerSize
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
if|if
condition|(
name|LLlog
operator|>
name|LLFSELog
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
name|ip
operator|+=
name|headerSize
expr_stmt|;
name|FSE_buildDTable
argument_list|(
name|DTableLL
argument_list|,
name|norm
argument_list|,
name|max
argument_list|,
name|LLlog
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|Offtype
condition|)
block|{
case|case
name|bt_rle
case|:
name|Offlog
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ip
operator|>
name|iend
operator|-
literal|2
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
comment|/* min : "raw", hence no header, but at least xxLog bits */
name|FSE_buildDTable_rle
argument_list|(
name|DTableOffb
argument_list|,
operator|*
name|ip
operator|++
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_raw
case|:
name|Offlog
operator|=
name|Offbits
expr_stmt|;
name|FSE_buildDTable_raw
argument_list|(
name|DTableOffb
argument_list|,
name|Offbits
argument_list|)
expr_stmt|;
break|break;
default|default :
block|{
name|U32
name|max
init|=
name|MaxOff
decl_stmt|;
name|headerSize
operator|=
name|FSE_readNCount
argument_list|(
name|norm
argument_list|,
operator|&
name|max
argument_list|,
operator|&
name|Offlog
argument_list|,
name|ip
argument_list|,
name|iend
operator|-
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|FSE_isError
argument_list|(
name|headerSize
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
if|if
condition|(
name|Offlog
operator|>
name|OffFSELog
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
name|ip
operator|+=
name|headerSize
expr_stmt|;
name|FSE_buildDTable
argument_list|(
name|DTableOffb
argument_list|,
name|norm
argument_list|,
name|max
argument_list|,
name|Offlog
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|MLtype
condition|)
block|{
case|case
name|bt_rle
case|:
name|MLlog
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ip
operator|>
name|iend
operator|-
literal|2
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
comment|/* min : "raw", hence no header, but at least xxLog bits */
name|FSE_buildDTable_rle
argument_list|(
name|DTableML
argument_list|,
operator|*
name|ip
operator|++
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_raw
case|:
name|MLlog
operator|=
name|MLbits
expr_stmt|;
name|FSE_buildDTable_raw
argument_list|(
name|DTableML
argument_list|,
name|MLbits
argument_list|)
expr_stmt|;
break|break;
default|default :
block|{
name|U32
name|max
init|=
name|MaxML
decl_stmt|;
name|headerSize
operator|=
name|FSE_readNCount
argument_list|(
name|norm
argument_list|,
operator|&
name|max
argument_list|,
operator|&
name|MLlog
argument_list|,
name|ip
argument_list|,
name|iend
operator|-
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|FSE_isError
argument_list|(
name|headerSize
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
if|if
condition|(
name|MLlog
operator|>
name|MLFSELog
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
name|ip
operator|+=
name|headerSize
expr_stmt|;
name|FSE_buildDTable
argument_list|(
name|DTableML
argument_list|,
name|norm
argument_list|,
name|max
argument_list|,
name|MLlog
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|ip
operator|-
name|istart
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
block|{
name|size_t
name|litLength
decl_stmt|;
name|size_t
name|offset
decl_stmt|;
name|size_t
name|matchLength
decl_stmt|;
block|}
name|seq_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|FSE_DStream_t
name|DStream
decl_stmt|;
name|FSE_DState_t
name|stateLL
decl_stmt|;
name|FSE_DState_t
name|stateOffb
decl_stmt|;
name|FSE_DState_t
name|stateML
decl_stmt|;
name|size_t
name|prevOffset
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|dumps
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|dumpsEnd
decl_stmt|;
block|}
name|seqState_t
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|ZSTD_decodeSequence
parameter_list|(
name|seq_t
modifier|*
name|seq
parameter_list|,
name|seqState_t
modifier|*
name|seqState
parameter_list|)
block|{
name|size_t
name|litLength
decl_stmt|;
name|size_t
name|prevOffset
decl_stmt|;
name|size_t
name|offset
decl_stmt|;
name|size_t
name|matchLength
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|dumps
init|=
name|seqState
operator|->
name|dumps
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|de
init|=
name|seqState
operator|->
name|dumpsEnd
decl_stmt|;
comment|/* Literal length */
name|litLength
operator|=
name|FSE_decodeSymbol
argument_list|(
operator|&
operator|(
name|seqState
operator|->
name|stateLL
operator|)
argument_list|,
operator|&
operator|(
name|seqState
operator|->
name|DStream
operator|)
argument_list|)
expr_stmt|;
name|prevOffset
operator|=
name|litLength
condition|?
name|seq
operator|->
name|offset
else|:
name|seqState
operator|->
name|prevOffset
expr_stmt|;
name|seqState
operator|->
name|prevOffset
operator|=
name|seq
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|litLength
operator|==
name|MaxLL
condition|)
block|{
name|U32
name|add
init|=
name|dumps
operator|<
name|de
condition|?
operator|*
name|dumps
operator|++
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|add
operator|<
literal|255
condition|)
name|litLength
operator|+=
name|add
expr_stmt|;
else|else
block|{
if|if
condition|(
name|dumps
operator|<=
operator|(
name|de
operator|-
literal|3
operator|)
condition|)
block|{
name|litLength
operator|=
name|ZSTD_readLE32
argument_list|(
name|dumps
argument_list|)
operator|&
literal|0xFFFFFF
expr_stmt|;
comment|/* no pb : dumps is always followed by seq tables> 1 byte */
name|dumps
operator|+=
literal|3
expr_stmt|;
block|}
block|}
block|}
comment|/* Offset */
block|{
name|U32
name|offsetCode
decl_stmt|,
name|nbBits
decl_stmt|;
name|offsetCode
operator|=
name|FSE_decodeSymbol
argument_list|(
operator|&
operator|(
name|seqState
operator|->
name|stateOffb
operator|)
argument_list|,
operator|&
operator|(
name|seqState
operator|->
name|DStream
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ZSTD_32bits
argument_list|()
condition|)
name|FSE_reloadDStream
argument_list|(
operator|&
operator|(
name|seqState
operator|->
name|DStream
operator|)
argument_list|)
expr_stmt|;
name|nbBits
operator|=
name|offsetCode
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|offsetCode
operator|==
literal|0
condition|)
name|nbBits
operator|=
literal|0
expr_stmt|;
comment|/* cmove */
name|offset
operator|=
operator|(
operator|(
name|size_t
operator|)
literal|1
operator|<<
operator|(
name|nbBits
operator|&
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|offset
argument_list|)
operator|*
literal|8
operator|)
operator|-
literal|1
operator|)
operator|)
operator|)
operator|+
name|FSE_readBits
argument_list|(
operator|&
operator|(
name|seqState
operator|->
name|DStream
operator|)
argument_list|,
name|nbBits
argument_list|)
expr_stmt|;
if|if
condition|(
name|ZSTD_32bits
argument_list|()
condition|)
name|FSE_reloadDStream
argument_list|(
operator|&
operator|(
name|seqState
operator|->
name|DStream
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|offsetCode
operator|==
literal|0
condition|)
name|offset
operator|=
name|prevOffset
expr_stmt|;
block|}
comment|/* MatchLength */
name|matchLength
operator|=
name|FSE_decodeSymbol
argument_list|(
operator|&
operator|(
name|seqState
operator|->
name|stateML
operator|)
argument_list|,
operator|&
operator|(
name|seqState
operator|->
name|DStream
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|matchLength
operator|==
name|MaxML
condition|)
block|{
name|U32
name|add
init|=
name|dumps
operator|<
name|de
condition|?
operator|*
name|dumps
operator|++
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|add
operator|<
literal|255
condition|)
name|matchLength
operator|+=
name|add
expr_stmt|;
else|else
block|{
if|if
condition|(
name|dumps
operator|<=
operator|(
name|de
operator|-
literal|3
operator|)
condition|)
block|{
name|matchLength
operator|=
name|ZSTD_readLE32
argument_list|(
name|dumps
argument_list|)
operator|&
literal|0xFFFFFF
expr_stmt|;
comment|/* no pb : dumps is always followed by seq tables> 1 byte */
name|dumps
operator|+=
literal|3
expr_stmt|;
block|}
block|}
block|}
name|matchLength
operator|+=
name|MINMATCH
expr_stmt|;
comment|/* save result */
name|seq
operator|->
name|litLength
operator|=
name|litLength
expr_stmt|;
name|seq
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|seq
operator|->
name|matchLength
operator|=
name|matchLength
expr_stmt|;
name|seqState
operator|->
name|dumps
operator|=
name|dumps
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|ZSTD_execSequence
parameter_list|(
name|BYTE
modifier|*
name|op
parameter_list|,
name|seq_t
name|sequence
parameter_list|,
specifier|const
name|BYTE
modifier|*
modifier|*
name|litPtr
parameter_list|,
specifier|const
name|BYTE
modifier|*
specifier|const
name|litLimit
parameter_list|,
name|BYTE
modifier|*
specifier|const
name|base
parameter_list|,
name|BYTE
modifier|*
specifier|const
name|oend
parameter_list|)
block|{
specifier|static
specifier|const
name|int
name|dec32table
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|}
decl_stmt|;
comment|/* added */
specifier|static
specifier|const
name|int
name|dec64table
index|[]
init|=
block|{
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|}
decl_stmt|;
comment|/* substracted */
specifier|const
name|BYTE
modifier|*
specifier|const
name|ostart
init|=
name|op
decl_stmt|;
specifier|const
name|size_t
name|litLength
init|=
name|sequence
operator|.
name|litLength
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|endMatch
init|=
name|op
operator|+
name|litLength
operator|+
name|sequence
operator|.
name|matchLength
decl_stmt|;
comment|/* risk : address space overflow (32-bits) */
specifier|const
name|BYTE
modifier|*
specifier|const
name|litEnd
init|=
operator|*
name|litPtr
operator|+
name|litLength
decl_stmt|;
comment|/* check */
if|if
condition|(
name|endMatch
operator|>
name|oend
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
comment|/* overwrite beyond dst buffer */
if|if
condition|(
name|litEnd
operator|>
name|litLimit
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
if|if
condition|(
name|sequence
operator|.
name|matchLength
operator|>
call|(
name|size_t
call|)
argument_list|(
operator|*
name|litPtr
operator|-
name|op
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
comment|/* overwrite literal segment */
comment|/* copy Literals */
if|if
condition|(
operator|(
call|(
name|size_t
call|)
argument_list|(
operator|*
name|litPtr
operator|-
name|op
argument_list|)
operator|<
literal|8
operator|)
operator|||
operator|(
call|(
name|size_t
call|)
argument_list|(
name|oend
operator|-
name|litEnd
argument_list|)
operator|<
literal|8
operator|)
operator|||
operator|(
name|op
operator|+
name|litLength
operator|>
name|oend
operator|-
literal|8
operator|)
condition|)
name|memmove
argument_list|(
name|op
argument_list|,
operator|*
name|litPtr
argument_list|,
name|litLength
argument_list|)
expr_stmt|;
comment|/* overwrite risk */
else|else
name|ZSTD_wildcopy
argument_list|(
name|op
argument_list|,
operator|*
name|litPtr
argument_list|,
name|litLength
argument_list|)
expr_stmt|;
name|op
operator|+=
name|litLength
expr_stmt|;
operator|*
name|litPtr
operator|=
name|litEnd
expr_stmt|;
comment|/* update for next sequence */
comment|/* check : last match must be at a minimum distance of 8 from end of dest buffer */
if|if
condition|(
name|oend
operator|-
name|op
operator|<
literal|8
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
comment|/* copy Match */
block|{
specifier|const
name|U32
name|overlapRisk
init|=
operator|(
operator|(
call|(
name|size_t
call|)
argument_list|(
name|litEnd
operator|-
name|endMatch
argument_list|)
operator|)
operator|<
literal|12
operator|)
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|match
init|=
name|op
operator|-
name|sequence
operator|.
name|offset
decl_stmt|;
comment|/* possible underflow at op - offset ? */
name|size_t
name|qutt
init|=
literal|12
decl_stmt|;
name|U64
name|saved
index|[
literal|2
index|]
decl_stmt|;
comment|/* check */
if|if
condition|(
name|match
operator|<
name|base
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
if|if
condition|(
name|sequence
operator|.
name|offset
operator|>
operator|(
name|size_t
operator|)
name|base
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* save beginning of literal sequence, in case of write overlap */
if|if
condition|(
name|overlapRisk
condition|)
block|{
if|if
condition|(
operator|(
name|endMatch
operator|+
name|qutt
operator|)
operator|>
name|oend
condition|)
name|qutt
operator|=
name|oend
operator|-
name|endMatch
expr_stmt|;
name|memcpy
argument_list|(
name|saved
argument_list|,
name|endMatch
argument_list|,
name|qutt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sequence
operator|.
name|offset
operator|<
literal|8
condition|)
block|{
specifier|const
name|int
name|dec64
init|=
name|dec64table
index|[
name|sequence
operator|.
name|offset
index|]
decl_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|match
index|[
literal|0
index|]
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|match
index|[
literal|1
index|]
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|match
index|[
literal|2
index|]
expr_stmt|;
name|op
index|[
literal|3
index|]
operator|=
name|match
index|[
literal|3
index|]
expr_stmt|;
name|match
operator|+=
name|dec32table
index|[
name|sequence
operator|.
name|offset
index|]
expr_stmt|;
name|ZSTD_copy4
argument_list|(
name|op
operator|+
literal|4
argument_list|,
name|match
argument_list|)
expr_stmt|;
name|match
operator|-=
name|dec64
expr_stmt|;
block|}
else|else
block|{
name|ZSTD_copy8
argument_list|(
name|op
argument_list|,
name|match
argument_list|)
expr_stmt|;
block|}
name|op
operator|+=
literal|8
expr_stmt|;
name|match
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|endMatch
operator|>
name|oend
operator|-
operator|(
literal|16
operator|-
name|MINMATCH
operator|)
condition|)
block|{
if|if
condition|(
name|op
operator|<
name|oend
operator|-
literal|8
condition|)
block|{
name|ZSTD_wildcopy
argument_list|(
name|op
argument_list|,
name|match
argument_list|,
operator|(
name|oend
operator|-
literal|8
operator|)
operator|-
name|op
argument_list|)
expr_stmt|;
name|match
operator|+=
operator|(
name|oend
operator|-
literal|8
operator|)
operator|-
name|op
expr_stmt|;
name|op
operator|=
name|oend
operator|-
literal|8
expr_stmt|;
block|}
while|while
condition|(
name|op
operator|<
name|endMatch
condition|)
operator|*
name|op
operator|++
operator|=
operator|*
name|match
operator|++
expr_stmt|;
block|}
else|else
name|ZSTD_wildcopy
argument_list|(
name|op
argument_list|,
name|match
argument_list|,
operator|(
name|ptrdiff_t
operator|)
name|sequence
operator|.
name|matchLength
operator|-
literal|8
argument_list|)
expr_stmt|;
comment|/* works even if matchLength< 8 */
comment|/* restore, in case of overlap */
if|if
condition|(
name|overlapRisk
condition|)
name|memcpy
argument_list|(
name|endMatch
argument_list|,
name|saved
argument_list|,
name|qutt
argument_list|)
expr_stmt|;
block|}
return|return
name|endMatch
operator|-
name|ostart
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|ZSTDv01_Dctx_s
block|{
name|U32
name|LLTable
index|[
name|FSE_DTABLE_SIZE_U32
argument_list|(
name|LLFSELog
argument_list|)
index|]
decl_stmt|;
name|U32
name|OffTable
index|[
name|FSE_DTABLE_SIZE_U32
argument_list|(
name|OffFSELog
argument_list|)
index|]
decl_stmt|;
name|U32
name|MLTable
index|[
name|FSE_DTABLE_SIZE_U32
argument_list|(
name|MLFSELog
argument_list|)
index|]
decl_stmt|;
name|void
modifier|*
name|previousDstEnd
decl_stmt|;
name|void
modifier|*
name|base
decl_stmt|;
name|size_t
name|expected
decl_stmt|;
name|blockType_t
name|bType
decl_stmt|;
name|U32
name|phase
decl_stmt|;
block|}
name|dctx_t
typedef|;
end_typedef

begin_function
specifier|static
name|size_t
name|ZSTD_decompressSequences
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|seqStart
parameter_list|,
name|size_t
name|seqSize
parameter_list|,
specifier|const
name|BYTE
modifier|*
name|litStart
parameter_list|,
name|size_t
name|litSize
parameter_list|)
block|{
name|dctx_t
modifier|*
name|dctx
init|=
operator|(
name|dctx_t
operator|*
operator|)
name|ctx
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|seqStart
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|iend
init|=
name|ip
operator|+
name|seqSize
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|ostart
init|=
operator|(
name|BYTE
operator|*
specifier|const
operator|)
name|dst
decl_stmt|;
name|BYTE
modifier|*
name|op
init|=
name|ostart
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|oend
init|=
name|ostart
operator|+
name|maxDstSize
decl_stmt|;
name|size_t
name|errorCode
decl_stmt|,
name|dumpsLength
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|litPtr
init|=
name|litStart
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|litEnd
init|=
name|litStart
operator|+
name|litSize
decl_stmt|;
name|int
name|nbSeq
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|dumps
decl_stmt|;
name|U32
modifier|*
name|DTableLL
init|=
name|dctx
operator|->
name|LLTable
decl_stmt|;
name|U32
modifier|*
name|DTableML
init|=
name|dctx
operator|->
name|MLTable
decl_stmt|;
name|U32
modifier|*
name|DTableOffb
init|=
name|dctx
operator|->
name|OffTable
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|base
init|=
operator|(
name|BYTE
operator|*
operator|)
operator|(
name|dctx
operator|->
name|base
operator|)
decl_stmt|;
comment|/* Build Decoding Tables */
name|errorCode
operator|=
name|ZSTDv01_decodeSeqHeaders
argument_list|(
operator|&
name|nbSeq
argument_list|,
operator|&
name|dumps
argument_list|,
operator|&
name|dumpsLength
argument_list|,
name|DTableLL
argument_list|,
name|DTableML
argument_list|,
name|DTableOffb
argument_list|,
name|ip
argument_list|,
name|iend
operator|-
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|ZSTDv01_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
name|ip
operator|+=
name|errorCode
expr_stmt|;
comment|/* Regen sequences */
block|{
name|seq_t
name|sequence
decl_stmt|;
name|seqState_t
name|seqState
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sequence
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sequence
argument_list|)
argument_list|)
expr_stmt|;
name|seqState
operator|.
name|dumps
operator|=
name|dumps
expr_stmt|;
name|seqState
operator|.
name|dumpsEnd
operator|=
name|dumps
operator|+
name|dumpsLength
expr_stmt|;
name|seqState
operator|.
name|prevOffset
operator|=
literal|1
expr_stmt|;
name|errorCode
operator|=
name|FSE_initDStream
argument_list|(
operator|&
operator|(
name|seqState
operator|.
name|DStream
operator|)
argument_list|,
name|ip
argument_list|,
name|iend
operator|-
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|FSE_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
name|FSE_initDState
argument_list|(
operator|&
operator|(
name|seqState
operator|.
name|stateLL
operator|)
argument_list|,
operator|&
operator|(
name|seqState
operator|.
name|DStream
operator|)
argument_list|,
name|DTableLL
argument_list|)
expr_stmt|;
name|FSE_initDState
argument_list|(
operator|&
operator|(
name|seqState
operator|.
name|stateOffb
operator|)
argument_list|,
operator|&
operator|(
name|seqState
operator|.
name|DStream
operator|)
argument_list|,
name|DTableOffb
argument_list|)
expr_stmt|;
name|FSE_initDState
argument_list|(
operator|&
operator|(
name|seqState
operator|.
name|stateML
operator|)
argument_list|,
operator|&
operator|(
name|seqState
operator|.
name|DStream
operator|)
argument_list|,
name|DTableML
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|(
name|FSE_reloadDStream
argument_list|(
operator|&
operator|(
name|seqState
operator|.
name|DStream
operator|)
argument_list|)
operator|<=
name|FSE_DStream_completed
operator|)
operator|&&
operator|(
name|nbSeq
operator|>
literal|0
operator|)
condition|;
control|)
block|{
name|size_t
name|oneSeqSize
decl_stmt|;
name|nbSeq
operator|--
expr_stmt|;
name|ZSTD_decodeSequence
argument_list|(
operator|&
name|sequence
argument_list|,
operator|&
name|seqState
argument_list|)
expr_stmt|;
name|oneSeqSize
operator|=
name|ZSTD_execSequence
argument_list|(
name|op
argument_list|,
name|sequence
argument_list|,
operator|&
name|litPtr
argument_list|,
name|litEnd
argument_list|,
name|base
argument_list|,
name|oend
argument_list|)
expr_stmt|;
if|if
condition|(
name|ZSTDv01_isError
argument_list|(
name|oneSeqSize
argument_list|)
condition|)
return|return
name|oneSeqSize
return|;
name|op
operator|+=
name|oneSeqSize
expr_stmt|;
block|}
comment|/* check if reached exact end */
if|if
condition|(
operator|!
name|FSE_endOfDStream
argument_list|(
operator|&
operator|(
name|seqState
operator|.
name|DStream
operator|)
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* requested too much : data is corrupted */
if|if
condition|(
name|nbSeq
operator|<
literal|0
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* requested too many sequences : data is corrupted */
comment|/* last literal segment */
block|{
name|size_t
name|lastLLSize
init|=
name|litEnd
operator|-
name|litPtr
decl_stmt|;
if|if
condition|(
name|op
operator|+
name|lastLLSize
operator|>
name|oend
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
if|if
condition|(
name|op
operator|!=
name|litPtr
condition|)
name|memmove
argument_list|(
name|op
argument_list|,
name|litPtr
argument_list|,
name|lastLLSize
argument_list|)
expr_stmt|;
name|op
operator|+=
name|lastLLSize
expr_stmt|;
block|}
block|}
return|return
name|op
operator|-
name|ostart
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|ZSTD_decompressBlock
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
comment|/* blockType == blockCompressed, srcSize is trusted */
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|litPtr
init|=
name|NULL
decl_stmt|;
name|size_t
name|litSize
init|=
literal|0
decl_stmt|;
name|size_t
name|errorCode
decl_stmt|;
comment|/* Decode literals sub-block */
name|errorCode
operator|=
name|ZSTDv01_decodeLiteralsBlock
argument_list|(
name|ctx
argument_list|,
name|dst
argument_list|,
name|maxDstSize
argument_list|,
operator|&
name|litPtr
argument_list|,
operator|&
name|litSize
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ZSTDv01_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
name|ip
operator|+=
name|errorCode
expr_stmt|;
name|srcSize
operator|-=
name|errorCode
expr_stmt|;
return|return
name|ZSTD_decompressSequences
argument_list|(
name|ctx
argument_list|,
name|dst
argument_list|,
name|maxDstSize
argument_list|,
name|ip
argument_list|,
name|srcSize
argument_list|,
name|litPtr
argument_list|,
name|litSize
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTDv01_decompressDCtx
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|iend
init|=
name|ip
operator|+
name|srcSize
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|ostart
init|=
operator|(
name|BYTE
operator|*
specifier|const
operator|)
name|dst
decl_stmt|;
name|BYTE
modifier|*
name|op
init|=
name|ostart
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|oend
init|=
name|ostart
operator|+
name|maxDstSize
decl_stmt|;
name|size_t
name|remainingSize
init|=
name|srcSize
decl_stmt|;
name|U32
name|magicNumber
decl_stmt|;
name|size_t
name|errorCode
init|=
literal|0
decl_stmt|;
name|blockProperties_t
name|blockProperties
decl_stmt|;
comment|/* Frame Header */
if|if
condition|(
name|srcSize
operator|<
name|ZSTD_frameHeaderSize
operator|+
name|ZSTD_blockHeaderSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|magicNumber
operator|=
name|ZSTD_readBE32
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|magicNumber
operator|!=
name|ZSTD_magicNumber
condition|)
return|return
name|ERROR
argument_list|(
name|prefix_unknown
argument_list|)
return|;
name|ip
operator|+=
name|ZSTD_frameHeaderSize
expr_stmt|;
name|remainingSize
operator|-=
name|ZSTD_frameHeaderSize
expr_stmt|;
comment|/* Loop on each block */
while|while
condition|(
literal|1
condition|)
block|{
name|size_t
name|blockSize
init|=
name|ZSTDv01_getcBlockSize
argument_list|(
name|ip
argument_list|,
name|iend
operator|-
name|ip
argument_list|,
operator|&
name|blockProperties
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTDv01_isError
argument_list|(
name|blockSize
argument_list|)
condition|)
return|return
name|blockSize
return|;
name|ip
operator|+=
name|ZSTD_blockHeaderSize
expr_stmt|;
name|remainingSize
operator|-=
name|ZSTD_blockHeaderSize
expr_stmt|;
if|if
condition|(
name|blockSize
operator|>
name|remainingSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
switch|switch
condition|(
name|blockProperties
operator|.
name|blockType
condition|)
block|{
case|case
name|bt_compressed
case|:
name|errorCode
operator|=
name|ZSTD_decompressBlock
argument_list|(
name|ctx
argument_list|,
name|op
argument_list|,
name|oend
operator|-
name|op
argument_list|,
name|ip
argument_list|,
name|blockSize
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_raw
case|:
name|errorCode
operator|=
name|ZSTD_copyUncompressedBlock
argument_list|(
name|op
argument_list|,
name|oend
operator|-
name|op
argument_list|,
name|ip
argument_list|,
name|blockSize
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_rle
case|:
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
comment|/* not yet supported */
break|break;
case|case
name|bt_end
case|:
comment|/* end of frame */
if|if
condition|(
name|remainingSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
break|break;
default|default:
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
block|}
if|if
condition|(
name|blockSize
operator|==
literal|0
condition|)
break|break;
comment|/* bt_end */
if|if
condition|(
name|ZSTDv01_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
name|op
operator|+=
name|errorCode
expr_stmt|;
name|ip
operator|+=
name|blockSize
expr_stmt|;
name|remainingSize
operator|-=
name|blockSize
expr_stmt|;
block|}
return|return
name|op
operator|-
name|ostart
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTDv01_decompress
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
name|dctx_t
name|ctx
decl_stmt|;
name|ctx
operator|.
name|base
operator|=
name|dst
expr_stmt|;
return|return
name|ZSTDv01_decompressDCtx
argument_list|(
operator|&
name|ctx
argument_list|,
name|dst
argument_list|,
name|maxDstSize
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTDv01_findFrameCompressedSize
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
decl_stmt|;
name|size_t
name|remainingSize
init|=
name|srcSize
decl_stmt|;
name|U32
name|magicNumber
decl_stmt|;
name|blockProperties_t
name|blockProperties
decl_stmt|;
comment|/* Frame Header */
if|if
condition|(
name|srcSize
operator|<
name|ZSTD_frameHeaderSize
operator|+
name|ZSTD_blockHeaderSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|magicNumber
operator|=
name|ZSTD_readBE32
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|magicNumber
operator|!=
name|ZSTD_magicNumber
condition|)
return|return
name|ERROR
argument_list|(
name|prefix_unknown
argument_list|)
return|;
name|ip
operator|+=
name|ZSTD_frameHeaderSize
expr_stmt|;
name|remainingSize
operator|-=
name|ZSTD_frameHeaderSize
expr_stmt|;
comment|/* Loop on each block */
while|while
condition|(
literal|1
condition|)
block|{
name|size_t
name|blockSize
init|=
name|ZSTDv01_getcBlockSize
argument_list|(
name|ip
argument_list|,
name|remainingSize
argument_list|,
operator|&
name|blockProperties
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTDv01_isError
argument_list|(
name|blockSize
argument_list|)
condition|)
return|return
name|blockSize
return|;
name|ip
operator|+=
name|ZSTD_blockHeaderSize
expr_stmt|;
name|remainingSize
operator|-=
name|ZSTD_blockHeaderSize
expr_stmt|;
if|if
condition|(
name|blockSize
operator|>
name|remainingSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
if|if
condition|(
name|blockSize
operator|==
literal|0
condition|)
break|break;
comment|/* bt_end */
name|ip
operator|+=
name|blockSize
expr_stmt|;
name|remainingSize
operator|-=
name|blockSize
expr_stmt|;
block|}
return|return
name|ip
operator|-
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
return|;
block|}
end_function

begin_comment
comment|/******************************* *  Streaming Decompression API *******************************/
end_comment

begin_function
name|size_t
name|ZSTDv01_resetDCtx
parameter_list|(
name|ZSTDv01_Dctx
modifier|*
name|dctx
parameter_list|)
block|{
name|dctx
operator|->
name|expected
operator|=
name|ZSTD_frameHeaderSize
expr_stmt|;
name|dctx
operator|->
name|phase
operator|=
literal|0
expr_stmt|;
name|dctx
operator|->
name|previousDstEnd
operator|=
name|NULL
expr_stmt|;
name|dctx
operator|->
name|base
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|ZSTDv01_Dctx
modifier|*
name|ZSTDv01_createDCtx
parameter_list|(
name|void
parameter_list|)
block|{
name|ZSTDv01_Dctx
modifier|*
name|dctx
init|=
operator|(
name|ZSTDv01_Dctx
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ZSTDv01_Dctx
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|dctx
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|ZSTDv01_resetDCtx
argument_list|(
name|dctx
argument_list|)
expr_stmt|;
return|return
name|dctx
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTDv01_freeDCtx
parameter_list|(
name|ZSTDv01_Dctx
modifier|*
name|dctx
parameter_list|)
block|{
name|free
argument_list|(
name|dctx
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTDv01_nextSrcSizeToDecompress
parameter_list|(
name|ZSTDv01_Dctx
modifier|*
name|dctx
parameter_list|)
block|{
return|return
operator|(
operator|(
name|dctx_t
operator|*
operator|)
name|dctx
operator|)
operator|->
name|expected
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTDv01_decompressContinue
parameter_list|(
name|ZSTDv01_Dctx
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
name|dctx_t
modifier|*
name|ctx
init|=
operator|(
name|dctx_t
operator|*
operator|)
name|dctx
decl_stmt|;
comment|/* Sanity check */
if|if
condition|(
name|srcSize
operator|!=
name|ctx
operator|->
name|expected
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
if|if
condition|(
name|dst
operator|!=
name|ctx
operator|->
name|previousDstEnd
condition|)
comment|/* not contiguous */
name|ctx
operator|->
name|base
operator|=
name|dst
expr_stmt|;
comment|/* Decompress : frame header */
if|if
condition|(
name|ctx
operator|->
name|phase
operator|==
literal|0
condition|)
block|{
comment|/* Check frame magic header */
name|U32
name|magicNumber
init|=
name|ZSTD_readBE32
argument_list|(
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
name|magicNumber
operator|!=
name|ZSTD_magicNumber
condition|)
return|return
name|ERROR
argument_list|(
name|prefix_unknown
argument_list|)
return|;
name|ctx
operator|->
name|phase
operator|=
literal|1
expr_stmt|;
name|ctx
operator|->
name|expected
operator|=
name|ZSTD_blockHeaderSize
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Decompress : block header */
if|if
condition|(
name|ctx
operator|->
name|phase
operator|==
literal|1
condition|)
block|{
name|blockProperties_t
name|bp
decl_stmt|;
name|size_t
name|blockSize
init|=
name|ZSTDv01_getcBlockSize
argument_list|(
name|src
argument_list|,
name|ZSTD_blockHeaderSize
argument_list|,
operator|&
name|bp
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTDv01_isError
argument_list|(
name|blockSize
argument_list|)
condition|)
return|return
name|blockSize
return|;
if|if
condition|(
name|bp
operator|.
name|blockType
operator|==
name|bt_end
condition|)
block|{
name|ctx
operator|->
name|expected
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|phase
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ctx
operator|->
name|expected
operator|=
name|blockSize
expr_stmt|;
name|ctx
operator|->
name|bType
operator|=
name|bp
operator|.
name|blockType
expr_stmt|;
name|ctx
operator|->
name|phase
operator|=
literal|2
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/* Decompress : block content */
block|{
name|size_t
name|rSize
decl_stmt|;
switch|switch
condition|(
name|ctx
operator|->
name|bType
condition|)
block|{
case|case
name|bt_compressed
case|:
name|rSize
operator|=
name|ZSTD_decompressBlock
argument_list|(
name|ctx
argument_list|,
name|dst
argument_list|,
name|maxDstSize
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_raw
case|:
name|rSize
operator|=
name|ZSTD_copyUncompressedBlock
argument_list|(
name|dst
argument_list|,
name|maxDstSize
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_rle
case|:
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
comment|/* not yet handled */
break|break;
case|case
name|bt_end
case|:
comment|/* should never happen (filtered at phase 1) */
name|rSize
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
block|}
name|ctx
operator|->
name|phase
operator|=
literal|1
expr_stmt|;
name|ctx
operator|->
name|expected
operator|=
name|ZSTD_blockHeaderSize
expr_stmt|;
name|ctx
operator|->
name|previousDstEnd
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|dst
operator|)
operator|+
name|rSize
operator|)
expr_stmt|;
return|return
name|rSize
return|;
block|}
block|}
end_function

end_unit

