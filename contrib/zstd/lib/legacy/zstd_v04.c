begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright (c) 2016-present, Yann Collet, Facebook, Inc.  * All rights reserved.  *  * This source code is licensed under the BSD-style license found in the  * LICENSE file in the root directory of this source tree. An additional grant  * of patent rights can be found in the PATENTS file in the same directory.  */
end_comment

begin_comment
comment|/*- Dependencies -*/
end_comment

begin_include
include|#
directive|include
file|"zstd_v04.h"
end_include

begin_include
include|#
directive|include
file|"error_private.h"
end_include

begin_comment
comment|/* ******************************************************************    mem.h    low-level memory access routines    Copyright (C) 2013-2015, Yann Collet.     BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)     Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are    met:         * Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer.        * Redistributions in binary form must reproduce the above    copyright notice, this list of conditions and the following disclaimer    in the documentation and/or other materials provided with the    distribution.     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.      You can contact the author at :     - FSE source repository : https://github.com/Cyan4973/FiniteStateEntropy     - Public forum : https://groups.google.com/forum/#!forum/lz4c ****************************************************************** */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MEM_H_MODULE
end_ifndef

begin_define
define|#
directive|define
name|MEM_H_MODULE
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/****************************************** *  Includes ******************************************/
include|#
directive|include
file|<stddef.h>
comment|/* size_t, ptrdiff_t */
include|#
directive|include
file|<string.h>
comment|/* memcpy */
comment|/****************************************** *  Compiler-specific ******************************************/
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
comment|/* Visual Studio */
include|#
directive|include
file|<stdlib.h>
comment|/* _byteswap_ulong */
include|#
directive|include
file|<intrin.h>
comment|/* _byteswap_* */
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
define|#
directive|define
name|MEM_STATIC
value|static __attribute__((unused))
elif|#
directive|elif
name|defined
argument_list|(
name|__cplusplus
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|__STDC_VERSION__
argument_list|)
operator|&&
operator|(
name|__STDC_VERSION__
operator|>=
literal|199901L
operator|)
comment|/* C99 */
operator|)
define|#
directive|define
name|MEM_STATIC
value|static inline
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
define|#
directive|define
name|MEM_STATIC
value|static __inline
else|#
directive|else
define|#
directive|define
name|MEM_STATIC
value|static
comment|/* this version may generate warnings for unused static functions; disable the relevant warning */
endif|#
directive|endif
comment|/**************************************************************** *  Basic Types *****************************************************************/
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|__STDC_VERSION__
argument_list|)
operator|&&
operator|(
name|__STDC_VERSION__
operator|>=
literal|199901L
operator|)
comment|/* C99 */
operator|)
include|#
directive|include
file|<stdint.h>
typedef|typedef
name|uint8_t
name|BYTE
typedef|;
typedef|typedef
name|uint16_t
name|U16
typedef|;
typedef|typedef
name|int16_t
name|S16
typedef|;
typedef|typedef
name|uint32_t
name|U32
typedef|;
typedef|typedef
name|int32_t
name|S32
typedef|;
typedef|typedef
name|uint64_t
name|U64
typedef|;
typedef|typedef
name|int64_t
name|S64
typedef|;
else|#
directive|else
typedef|typedef
name|unsigned
name|char
name|BYTE
typedef|;
typedef|typedef
name|unsigned
name|short
name|U16
typedef|;
typedef|typedef
name|signed
name|short
name|S16
typedef|;
typedef|typedef
name|unsigned
name|int
name|U32
typedef|;
typedef|typedef
name|signed
name|int
name|S32
typedef|;
typedef|typedef
name|unsigned
name|long
name|long
name|U64
typedef|;
typedef|typedef
name|signed
name|long
name|long
name|S64
typedef|;
endif|#
directive|endif
comment|/**************************************************************** *  Memory I/O *****************************************************************/
comment|/* MEM_FORCE_MEMORY_ACCESS  * By default, access to unaligned memory is controlled by `memcpy()`, which is safe and portable.  * Unfortunately, on some target/compiler combinations, the generated assembly is sub-optimal.  * The below switch allow to select different access method for improved performance.  * Method 0 (default) : use `memcpy()`. Safe and portable.  * Method 1 : `__packed` statement. It depends on compiler extension (ie, not portable).  *            This method is safe if your compiler supports it, and *generally* as fast or faster than `memcpy`.  * Method 2 : direct access. This method is portable but violate C standard.  *            It can generate buggy code on targets generating assembly depending on alignment.  *            But in some circumstances, it's the only known way to get the most performance (ie GCC + ARMv6)  * See http://fastcompression.blogspot.fr/2015/08/accessing-unaligned-memory.html for details.  * Prefer these methods in priority order (0> 1> 2)  */
ifndef|#
directive|ifndef
name|MEM_FORCE_MEMORY_ACCESS
comment|/* can be defined externally, on command line for example */
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|__ARM_ARCH_6__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_6J__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_6K__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_6Z__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_6ZK__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_6T2__
argument_list|)
operator|)
define|#
directive|define
name|MEM_FORCE_MEMORY_ACCESS
value|2
elif|#
directive|elif
operator|(
name|defined
argument_list|(
name|__INTEL_COMPILER
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|)
operator|||
expr|\
operator|(
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|__ARM_ARCH_7__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_7A__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_7R__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_7M__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_7S__
argument_list|)
operator|)
operator|)
define|#
directive|define
name|MEM_FORCE_MEMORY_ACCESS
value|1
endif|#
directive|endif
endif|#
directive|endif
name|MEM_STATIC
name|unsigned
name|MEM_32bits
parameter_list|(
name|void
parameter_list|)
block|{
return|return
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|==
literal|4
return|;
block|}
name|MEM_STATIC
name|unsigned
name|MEM_64bits
parameter_list|(
name|void
parameter_list|)
block|{
return|return
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|==
literal|8
return|;
block|}
name|MEM_STATIC
name|unsigned
name|MEM_isLittleEndian
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
union|union
block|{
name|U32
name|u
decl_stmt|;
name|BYTE
name|c
index|[
literal|4
index|]
decl_stmt|;
block|}
name|one
init|=
block|{
literal|1
block|}
union|;
comment|/* don't use static : performance detrimental  */
return|return
name|one
operator|.
name|c
index|[
literal|0
index|]
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|MEM_FORCE_MEMORY_ACCESS
argument_list|)
operator|&&
operator|(
name|MEM_FORCE_MEMORY_ACCESS
operator|==
literal|2
operator|)
comment|/* violates C standard on structure alignment. Only use if no other choice to achieve best performance on target platform */
name|MEM_STATIC
name|U16
name|MEM_read16
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
return|return
operator|*
operator|(
specifier|const
name|U16
operator|*
operator|)
name|memPtr
return|;
block|}
name|MEM_STATIC
name|U32
name|MEM_read32
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
return|return
operator|*
operator|(
specifier|const
name|U32
operator|*
operator|)
name|memPtr
return|;
block|}
name|MEM_STATIC
name|U64
name|MEM_read64
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
return|return
operator|*
operator|(
specifier|const
name|U64
operator|*
operator|)
name|memPtr
return|;
block|}
name|MEM_STATIC
name|void
name|MEM_write16
parameter_list|(
name|void
modifier|*
name|memPtr
parameter_list|,
name|U16
name|value
parameter_list|)
block|{
operator|*
operator|(
name|U16
operator|*
operator|)
name|memPtr
operator|=
name|value
expr_stmt|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|MEM_FORCE_MEMORY_ACCESS
argument_list|)
operator|&&
operator|(
name|MEM_FORCE_MEMORY_ACCESS
operator|==
literal|1
operator|)
comment|/* __pack instructions are safer, but compiler specific, hence potentially problematic for some compilers */
comment|/* currently only defined for gcc and icc */
typedef|typedef
union|union
block|{
name|U16
name|u16
decl_stmt|;
name|U32
name|u32
decl_stmt|;
name|U64
name|u64
decl_stmt|;
block|}
name|__attribute__
typedef|((
name|packed
typedef|))
name|unalign
typedef|;
name|MEM_STATIC
name|U16
name|MEM_read16
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
return|return
operator|(
operator|(
specifier|const
name|unalign
operator|*
operator|)
name|ptr
operator|)
operator|->
name|u16
return|;
block|}
name|MEM_STATIC
name|U32
name|MEM_read32
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
return|return
operator|(
operator|(
specifier|const
name|unalign
operator|*
operator|)
name|ptr
operator|)
operator|->
name|u32
return|;
block|}
name|MEM_STATIC
name|U64
name|MEM_read64
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
return|return
operator|(
operator|(
specifier|const
name|unalign
operator|*
operator|)
name|ptr
operator|)
operator|->
name|u64
return|;
block|}
name|MEM_STATIC
name|void
name|MEM_write16
parameter_list|(
name|void
modifier|*
name|memPtr
parameter_list|,
name|U16
name|value
parameter_list|)
block|{
operator|(
operator|(
name|unalign
operator|*
operator|)
name|memPtr
operator|)
operator|->
name|u16
operator|=
name|value
expr_stmt|;
block|}
else|#
directive|else
comment|/* default method, safe and standard.    can sometimes prove slower */
name|MEM_STATIC
name|U16
name|MEM_read16
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
name|U16
name|val
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|val
argument_list|,
name|memPtr
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
name|MEM_STATIC
name|U32
name|MEM_read32
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
name|U32
name|val
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|val
argument_list|,
name|memPtr
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
name|MEM_STATIC
name|U64
name|MEM_read64
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
name|U64
name|val
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|val
argument_list|,
name|memPtr
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
name|MEM_STATIC
name|void
name|MEM_write16
parameter_list|(
name|void
modifier|*
name|memPtr
parameter_list|,
name|U16
name|value
parameter_list|)
block|{
name|memcpy
argument_list|(
name|memPtr
argument_list|,
operator|&
name|value
argument_list|,
sizeof|sizeof
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// MEM_FORCE_MEMORY_ACCESS
name|MEM_STATIC
name|U16
name|MEM_readLE16
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
if|if
condition|(
name|MEM_isLittleEndian
argument_list|()
condition|)
return|return
name|MEM_read16
argument_list|(
name|memPtr
argument_list|)
return|;
else|else
block|{
specifier|const
name|BYTE
modifier|*
name|p
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|memPtr
decl_stmt|;
return|return
call|(
name|U16
call|)
argument_list|(
name|p
index|[
literal|0
index|]
operator|+
operator|(
name|p
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
argument_list|)
return|;
block|}
block|}
name|MEM_STATIC
name|void
name|MEM_writeLE16
parameter_list|(
name|void
modifier|*
name|memPtr
parameter_list|,
name|U16
name|val
parameter_list|)
block|{
if|if
condition|(
name|MEM_isLittleEndian
argument_list|()
condition|)
block|{
name|MEM_write16
argument_list|(
name|memPtr
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BYTE
modifier|*
name|p
init|=
operator|(
name|BYTE
operator|*
operator|)
name|memPtr
decl_stmt|;
name|p
index|[
literal|0
index|]
operator|=
operator|(
name|BYTE
operator|)
name|val
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
call|(
name|BYTE
call|)
argument_list|(
name|val
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
name|MEM_STATIC
name|U32
name|MEM_readLE32
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
if|if
condition|(
name|MEM_isLittleEndian
argument_list|()
condition|)
return|return
name|MEM_read32
argument_list|(
name|memPtr
argument_list|)
return|;
else|else
block|{
specifier|const
name|BYTE
modifier|*
name|p
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|memPtr
decl_stmt|;
return|return
call|(
name|U32
call|)
argument_list|(
operator|(
name|U32
operator|)
name|p
index|[
literal|0
index|]
operator|+
operator|(
operator|(
name|U32
operator|)
name|p
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
operator|(
name|U32
operator|)
name|p
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
operator|(
name|U32
operator|)
name|p
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
argument_list|)
return|;
block|}
block|}
name|MEM_STATIC
name|U64
name|MEM_readLE64
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
if|if
condition|(
name|MEM_isLittleEndian
argument_list|()
condition|)
return|return
name|MEM_read64
argument_list|(
name|memPtr
argument_list|)
return|;
else|else
block|{
specifier|const
name|BYTE
modifier|*
name|p
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|memPtr
decl_stmt|;
return|return
call|(
name|U64
call|)
argument_list|(
operator|(
name|U64
operator|)
name|p
index|[
literal|0
index|]
operator|+
operator|(
operator|(
name|U64
operator|)
name|p
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
operator|(
name|U64
operator|)
name|p
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
operator|(
name|U64
operator|)
name|p
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator|+
operator|(
operator|(
name|U64
operator|)
name|p
index|[
literal|4
index|]
operator|<<
literal|32
operator|)
operator|+
operator|(
operator|(
name|U64
operator|)
name|p
index|[
literal|5
index|]
operator|<<
literal|40
operator|)
operator|+
operator|(
operator|(
name|U64
operator|)
name|p
index|[
literal|6
index|]
operator|<<
literal|48
operator|)
operator|+
operator|(
operator|(
name|U64
operator|)
name|p
index|[
literal|7
index|]
operator|<<
literal|56
operator|)
argument_list|)
return|;
block|}
block|}
name|MEM_STATIC
name|size_t
name|MEM_readLEST
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
if|if
condition|(
name|MEM_32bits
argument_list|()
condition|)
return|return
operator|(
name|size_t
operator|)
name|MEM_readLE32
argument_list|(
name|memPtr
argument_list|)
return|;
else|else
return|return
operator|(
name|size_t
operator|)
name|MEM_readLE64
argument_list|(
name|memPtr
argument_list|)
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MEM_H_MODULE */
end_comment

begin_comment
comment|/*     zstd - standard compression library     Header File for static linking only     Copyright (C) 2014-2015, Yann Collet.      BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)      Redistribution and use in source and binary forms, with or without     modification, are permitted provided that the following conditions are     met:     * Redistributions of source code must retain the above copyright     notice, this list of conditions and the following disclaimer.     * Redistributions in binary form must reproduce the above     copyright notice, this list of conditions and the following disclaimer     in the documentation and/or other materials provided with the     distribution.     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS     "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR     A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT     OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT     LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY     THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE     OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.      You can contact the author at :     - zstd source repository : https://github.com/Cyan4973/zstd     - ztsd public forum : https://groups.google.com/forum/#!forum/lz4c */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ZSTD_STATIC_H
end_ifndef

begin_define
define|#
directive|define
name|ZSTD_STATIC_H
end_define

begin_comment
comment|/* The objects defined into this file shall be considered experimental.  * They are not considered stable, as their prototype may change in the future.  * You can use them for tests, provide feedback, or if you can endure risks of future changes.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/* ************************************* *  Types ***************************************/
define|#
directive|define
name|ZSTD_WINDOWLOG_MAX
value|26
define|#
directive|define
name|ZSTD_WINDOWLOG_MIN
value|18
define|#
directive|define
name|ZSTD_WINDOWLOG_ABSOLUTEMIN
value|11
define|#
directive|define
name|ZSTD_CONTENTLOG_MAX
value|(ZSTD_WINDOWLOG_MAX+1)
define|#
directive|define
name|ZSTD_CONTENTLOG_MIN
value|4
define|#
directive|define
name|ZSTD_HASHLOG_MAX
value|28
define|#
directive|define
name|ZSTD_HASHLOG_MIN
value|4
define|#
directive|define
name|ZSTD_SEARCHLOG_MAX
value|(ZSTD_CONTENTLOG_MAX-1)
define|#
directive|define
name|ZSTD_SEARCHLOG_MIN
value|1
define|#
directive|define
name|ZSTD_SEARCHLENGTH_MAX
value|7
define|#
directive|define
name|ZSTD_SEARCHLENGTH_MIN
value|4
comment|/** from faster to stronger */
typedef|typedef
enum|enum
block|{
name|ZSTD_fast
block|,
name|ZSTD_greedy
block|,
name|ZSTD_lazy
block|,
name|ZSTD_lazy2
block|,
name|ZSTD_btlazy2
block|}
name|ZSTD_strategy
typedef|;
typedef|typedef
struct|struct
block|{
name|U64
name|srcSize
decl_stmt|;
comment|/* optional : tells how much bytes are present in the frame. Use 0 if not known. */
name|U32
name|windowLog
decl_stmt|;
comment|/* largest match distance : larger == more compression, more memory needed during decompression */
name|U32
name|contentLog
decl_stmt|;
comment|/* full search segment : larger == more compression, slower, more memory (useless for fast) */
name|U32
name|hashLog
decl_stmt|;
comment|/* dispatch table : larger == more memory, faster */
name|U32
name|searchLog
decl_stmt|;
comment|/* nb of searches : larger == more compression, slower */
name|U32
name|searchLength
decl_stmt|;
comment|/* size of matches : larger == faster decompression, sometimes less compression */
name|ZSTD_strategy
name|strategy
decl_stmt|;
block|}
name|ZSTD_parameters
typedef|;
typedef|typedef
name|ZSTDv04_Dctx
name|ZSTD_DCtx
typedef|;
comment|/* ************************************* *  Advanced functions ***************************************/
comment|/** ZSTD_decompress_usingDict *   Same as ZSTD_decompressDCtx, using a Dictionary content as prefix *   Note : dict can be NULL, in which case, it's equivalent to ZSTD_decompressDCtx() */
specifier|static
name|size_t
name|ZSTD_decompress_usingDict
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|ctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|)
function_decl|;
comment|/* ************************************** *  Streaming functions (direct mode) ****************************************/
specifier|static
name|size_t
name|ZSTD_resetDCtx
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|)
function_decl|;
specifier|static
name|size_t
name|ZSTD_getFrameParams
parameter_list|(
name|ZSTD_parameters
modifier|*
name|params
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
specifier|static
name|void
name|ZSTD_decompress_insertDictionary
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
specifier|static
name|size_t
name|ZSTD_nextSrcSizeToDecompress
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|)
function_decl|;
specifier|static
name|size_t
name|ZSTD_decompressContinue
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
comment|/**   Streaming decompression, bufferless mode    A ZSTD_DCtx object is required to track streaming operations.   Use ZSTD_createDCtx() / ZSTD_freeDCtx() to manage it.   A ZSTD_DCtx object can be re-used multiple times. Use ZSTD_resetDCtx() to return to fresh status.    First operation is to retrieve frame parameters, using ZSTD_getFrameParams().   This function doesn't consume its input. It needs enough input data to properly decode the frame header.   Objective is to retrieve *params.windowlog, to know minimum amount of memory required during decoding.   Result : 0 when successful, it means the ZSTD_parameters structure has been filled.>0 : means there is not enough data into src. Provides the expected size to successfully decode header.            errorCode, which can be tested using ZSTD_isError() (For example, if it's not a ZSTD header)    Then, you can optionally insert a dictionary.   This operation must mimic the compressor behavior, otherwise decompression will fail or be corrupted.    Then it's possible to start decompression.   Use ZSTD_nextSrcSizeToDecompress() and ZSTD_decompressContinue() alternatively.   ZSTD_nextSrcSizeToDecompress() tells how much bytes to provide as 'srcSize' to ZSTD_decompressContinue().   ZSTD_decompressContinue() requires this exact amount of bytes, or it will fail.   ZSTD_decompressContinue() needs previous data blocks during decompression, up to (1<< windowlog).   They should preferably be located contiguously, prior to current block. Alternatively, a round buffer is also possible.    @result of ZSTD_decompressContinue() is the number of bytes regenerated within 'dst'.   It can be zero, which is not an error; it just means ZSTD_decompressContinue() has decoded some header.    A frame is fully decoded when ZSTD_nextSrcSizeToDecompress() returns zero.   Context can then be reset to start a new decompression. */
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ZSTD_STATIC_H */
end_comment

begin_comment
comment|/*     zstd_internal - common functions to include     Header File for include     Copyright (C) 2014-2015, Yann Collet.      BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)      Redistribution and use in source and binary forms, with or without     modification, are permitted provided that the following conditions are     met:     * Redistributions of source code must retain the above copyright     notice, this list of conditions and the following disclaimer.     * Redistributions in binary form must reproduce the above     copyright notice, this list of conditions and the following disclaimer     in the documentation and/or other materials provided with the     distribution.     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS     "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR     A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT     OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT     LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY     THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE     OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.      You can contact the author at :     - zstd source repository : https://github.com/Cyan4973/zstd     - ztsd public forum : https://groups.google.com/forum/#!forum/lz4c */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ZSTD_CCOMMON_H_MODULE
end_ifndef

begin_define
define|#
directive|define
name|ZSTD_CCOMMON_H_MODULE
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/* ************************************* *  Common macros ***************************************/
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)<(b) ? (a) : (b))
define|#
directive|define
name|MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)>(b) ? (a) : (b))
comment|/* ************************************* *  Common constants ***************************************/
define|#
directive|define
name|ZSTD_MAGICNUMBER
value|0xFD2FB524
comment|/* v0.4 */
define|#
directive|define
name|KB
value|*(1<<10)
define|#
directive|define
name|MB
value|*(1<<20)
define|#
directive|define
name|GB
value|*(1U<<30)
define|#
directive|define
name|BLOCKSIZE
value|(128 KB)
comment|/* define, for static allocation */
specifier|static
specifier|const
name|size_t
name|ZSTD_blockHeaderSize
init|=
literal|3
decl_stmt|;
specifier|static
specifier|const
name|size_t
name|ZSTD_frameHeaderSize_min
init|=
literal|5
decl_stmt|;
define|#
directive|define
name|ZSTD_frameHeaderSize_max
value|5
comment|/* define, for static allocation */
define|#
directive|define
name|BIT7
value|128
define|#
directive|define
name|BIT6
value|64
define|#
directive|define
name|BIT5
value|32
define|#
directive|define
name|BIT4
value|16
define|#
directive|define
name|BIT1
value|2
define|#
directive|define
name|BIT0
value|1
define|#
directive|define
name|IS_RAW
value|BIT0
define|#
directive|define
name|IS_RLE
value|BIT1
define|#
directive|define
name|MINMATCH
value|4
define|#
directive|define
name|REPCODE_STARTVALUE
value|4
define|#
directive|define
name|MLbits
value|7
define|#
directive|define
name|LLbits
value|6
define|#
directive|define
name|Offbits
value|5
define|#
directive|define
name|MaxML
value|((1<<MLbits) - 1)
define|#
directive|define
name|MaxLL
value|((1<<LLbits) - 1)
define|#
directive|define
name|MaxOff
value|((1<<Offbits)- 1)
define|#
directive|define
name|MLFSELog
value|10
define|#
directive|define
name|LLFSELog
value|10
define|#
directive|define
name|OffFSELog
value|9
define|#
directive|define
name|MaxSeq
value|MAX(MaxLL, MaxML)
define|#
directive|define
name|MIN_SEQUENCES_SIZE
value|(2
comment|/*seqNb*/
value|+ 2
comment|/*dumps*/
value|+ 3
comment|/*seqTables*/
value|+ 1
comment|/*bitStream*/
value|)
define|#
directive|define
name|MIN_CBLOCK_SIZE
value|(3
comment|/*litCSize*/
value|+ MIN_SEQUENCES_SIZE)
typedef|typedef
enum|enum
block|{
name|bt_compressed
block|,
name|bt_raw
block|,
name|bt_rle
block|,
name|bt_end
block|}
name|blockType_t
typedef|;
comment|/* ****************************************** *  Shared functions to include for inlining ********************************************/
specifier|static
name|void
name|ZSTD_copy8
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|)
block|{
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
define|#
directive|define
name|COPY8
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|)
value|{ ZSTD_copy8(d,s); d+=8; s+=8; }
comment|/*! ZSTD_wildcopy : custom version of memcpy(), can copy up to 7-8 bytes too many */
specifier|static
name|void
name|ZSTD_wildcopy
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|ptrdiff_t
name|length
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
decl_stmt|;
name|BYTE
modifier|*
name|op
init|=
operator|(
name|BYTE
operator|*
operator|)
name|dst
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|oend
init|=
name|op
operator|+
name|length
decl_stmt|;
do|do
name|COPY8
argument_list|(
argument|op
argument_list|,
argument|ip
argument_list|)
while|while
condition|(
name|op
operator|<
name|oend
condition|)
empty_stmt|;
do|}
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
block|}
endif|#
directive|endif
comment|/* ******************************************************************    FSE : Finite State Entropy coder    header file    Copyright (C) 2013-2015, Yann Collet.     BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)     Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are    met:         * Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer.        * Redistributions in binary form must reproduce the above    copyright notice, this list of conditions and the following disclaimer    in the documentation and/or other materials provided with the    distribution.     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     You can contact the author at :    - Source repository : https://github.com/Cyan4973/FiniteStateEntropy    - Public forum : https://groups.google.com/forum/#!forum/lz4c ****************************************************************** */
ifndef|#
directive|ifndef
name|FSE_H
define|#
directive|define
name|FSE_H
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/* ***************************************** *  Includes ******************************************/
include|#
directive|include
file|<stddef.h>
comment|/* size_t, ptrdiff_t */
comment|/* ***************************************** *  FSE simple functions ******************************************/
specifier|static
name|size_t
name|FSE_decompress
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
function_decl|;
comment|/*! FSE_decompress():     Decompress FSE data from buffer 'cSrc', of size 'cSrcSize',     into already allocated destination buffer 'dst', of size 'maxDstSize'.     return : size of regenerated data (<= maxDstSize)              or an error code, which can be tested using FSE_isError()      ** Important ** : FSE_decompress() doesn't decompress non-compressible nor RLE data !!!     Why ? : making this distinction requires a header.     Header management is intentionally delegated to the user layer, which can better manage special cases. */
comment|/* ***************************************** *  Tool functions ******************************************/
comment|/* Error Management */
specifier|static
name|unsigned
name|FSE_isError
parameter_list|(
name|size_t
name|code
parameter_list|)
function_decl|;
comment|/* tells if a return value is an error code */
comment|/* ***************************************** *  FSE detailed API ******************************************/
comment|/*! FSE_compress() does the following: 1. count symbol occurrence from source[] into table count[] 2. normalize counters so that sum(count[]) == Power_of_2 (2^tableLog) 3. save normalized counters to memory buffer using writeNCount() 4. build encoding table 'CTable' from normalized counters 5. encode the data stream using encoding table 'CTable'  FSE_decompress() does the following: 1. read normalized counters with readNCount() 2. build decoding table 'DTable' from normalized counters 3. decode the data stream using decoding table 'DTable'  The following API allows targeting specific sub-functions for advanced tasks. For example, it's possible to compress several blocks using the same 'CTable', or to save and provide normalized distribution using external method. */
comment|/* *** DECOMPRESSION *** */
comment|/*! FSE_readNCount():    Read compactly saved 'normalizedCounter' from 'rBuffer'.    return : size read from 'rBuffer'             or an errorCode, which can be tested using FSE_isError()             maxSymbolValuePtr[0] and tableLogPtr[0] will also be updated with their respective values */
specifier|static
name|size_t
name|FSE_readNCount
parameter_list|(
name|short
modifier|*
name|normalizedCounter
parameter_list|,
name|unsigned
modifier|*
name|maxSymbolValuePtr
parameter_list|,
name|unsigned
modifier|*
name|tableLogPtr
parameter_list|,
specifier|const
name|void
modifier|*
name|rBuffer
parameter_list|,
name|size_t
name|rBuffSize
parameter_list|)
function_decl|;
comment|/*! Constructor and Destructor of type FSE_DTable     Note that its size depends on 'tableLog' */
typedef|typedef
name|unsigned
name|FSE_DTable
typedef|;
comment|/* don't allocate that. It's just a way to be more restrictive than void* */
comment|/*! FSE_buildDTable():    Builds 'dt', which must be already allocated, using FSE_createDTable()    return : 0,             or an errorCode, which can be tested using FSE_isError() */
specifier|static
name|size_t
name|FSE_buildDTable
parameter_list|(
name|FSE_DTable
modifier|*
name|dt
parameter_list|,
specifier|const
name|short
modifier|*
name|normalizedCounter
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|,
name|unsigned
name|tableLog
parameter_list|)
function_decl|;
comment|/*! FSE_decompress_usingDTable():    Decompress compressed source 'cSrc' of size 'cSrcSize' using 'dt'    into 'dst' which must be already allocated.    return : size of regenerated data (necessarily<= maxDstSize)             or an errorCode, which can be tested using FSE_isError() */
specifier|static
name|size_t
name|FSE_decompress_usingDTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|FSE_DTable
modifier|*
name|dt
parameter_list|)
function_decl|;
comment|/*! Tutorial : ---------- (Note : these functions only decompress FSE-compressed blocks.  If block is uncompressed, use memcpy() instead  If block is a single repeated byte, use memset() instead )  The first step is to obtain the normalized frequencies of symbols. This can be performed by FSE_readNCount() if it was saved using FSE_writeNCount(). 'normalizedCounter' must be already allocated, and have at least 'maxSymbolValuePtr[0]+1' cells of signed short. In practice, that means it's necessary to know 'maxSymbolValue' beforehand, or size the table to handle worst case situations (typically 256). FSE_readNCount() will provide 'tableLog' and 'maxSymbolValue'. The result of FSE_readNCount() is the number of bytes read from 'rBuffer'. Note that 'rBufferSize' must be at least 4 bytes, even if useful information is less than that. If there is an error, the function will return an error code, which can be tested using FSE_isError().  The next step is to build the decompression tables 'FSE_DTable' from 'normalizedCounter'. This is performed by the function FSE_buildDTable(). The space required by 'FSE_DTable' must be already allocated using FSE_createDTable(). If there is an error, the function will return an error code, which can be tested using FSE_isError().  'FSE_DTable' can then be used to decompress 'cSrc', with FSE_decompress_usingDTable(). 'cSrcSize' must be strictly correct, otherwise decompression will fail. FSE_decompress_usingDTable() result will tell how many bytes were regenerated (<=maxDstSize). If there is an error, the function will return an error code, which can be tested using FSE_isError(). (ex: dst buffer too small) */
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* FSE_H */
comment|/* ******************************************************************    bitstream    Part of NewGen Entropy library    header file (to include)    Copyright (C) 2013-2015, Yann Collet.     BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)     Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are    met:         * Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer.        * Redistributions in binary form must reproduce the above    copyright notice, this list of conditions and the following disclaimer    in the documentation and/or other materials provided with the    distribution.     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     You can contact the author at :    - Source repository : https://github.com/Cyan4973/FiniteStateEntropy    - Public forum : https://groups.google.com/forum/#!forum/lz4c ****************************************************************** */
ifndef|#
directive|ifndef
name|BITSTREAM_H_MODULE
define|#
directive|define
name|BITSTREAM_H_MODULE
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/* *  This API consists of small unitary functions, which highly benefit from being inlined. *  Since link-time-optimization is not available for all compilers, *  these functions are defined into a .h to be included. */
comment|/********************************************** *  bitStream decompression API (read backward) **********************************************/
typedef|typedef
struct|struct
block|{
name|size_t
name|bitContainer
decl_stmt|;
name|unsigned
name|bitsConsumed
decl_stmt|;
specifier|const
name|char
modifier|*
name|ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
block|}
name|BIT_DStream_t
typedef|;
typedef|typedef
enum|enum
block|{
name|BIT_DStream_unfinished
init|=
literal|0
block|,
name|BIT_DStream_endOfBuffer
init|=
literal|1
block|,
name|BIT_DStream_completed
init|=
literal|2
block|,
name|BIT_DStream_overflow
init|=
literal|3
block|}
name|BIT_DStream_status
typedef|;
comment|/* result of BIT_reloadDStream() */
comment|/* 1,2,4,8 would be better for bitmap combinations, but slows down performance a bit ... :( */
name|MEM_STATIC
name|size_t
name|BIT_initDStream
parameter_list|(
name|BIT_DStream_t
modifier|*
name|bitD
parameter_list|,
specifier|const
name|void
modifier|*
name|srcBuffer
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
name|MEM_STATIC
name|size_t
name|BIT_readBits
parameter_list|(
name|BIT_DStream_t
modifier|*
name|bitD
parameter_list|,
name|unsigned
name|nbBits
parameter_list|)
function_decl|;
name|MEM_STATIC
name|BIT_DStream_status
name|BIT_reloadDStream
parameter_list|(
name|BIT_DStream_t
modifier|*
name|bitD
parameter_list|)
function_decl|;
name|MEM_STATIC
name|unsigned
name|BIT_endOfDStream
parameter_list|(
specifier|const
name|BIT_DStream_t
modifier|*
name|bitD
parameter_list|)
function_decl|;
comment|/* * Start by invoking BIT_initDStream(). * A chunk of the bitStream is then stored into a local register. * Local register size is 64-bits on 64-bits systems, 32-bits on 32-bits systems (size_t). * You can then retrieve bitFields stored into the local register, **in reverse order**. * Local register is manually filled from memory by the BIT_reloadDStream() method. * A reload guarantee a minimum of ((8*sizeof(size_t))-7) bits when its result is BIT_DStream_unfinished. * Otherwise, it can be less than that, so proceed accordingly. * Checking if DStream has reached its end can be performed with BIT_endOfDStream() */
comment|/****************************************** *  unsafe API ******************************************/
name|MEM_STATIC
name|size_t
name|BIT_readBitsFast
parameter_list|(
name|BIT_DStream_t
modifier|*
name|bitD
parameter_list|,
name|unsigned
name|nbBits
parameter_list|)
function_decl|;
comment|/* faster, but works only if nbBits>= 1 */
comment|/**************************************************************** *  Helper functions ****************************************************************/
name|MEM_STATIC
name|unsigned
name|BIT_highbit32
parameter_list|(
specifier|register
name|U32
name|val
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
comment|/* Visual */
name|unsigned
name|long
name|r
init|=
literal|0
decl_stmt|;
name|_BitScanReverse
argument_list|(
operator|&
name|r
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|unsigned
operator|)
name|r
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|__GNUC__
operator|>=
literal|3
operator|)
comment|/* Use GCC Intrinsic */
return|return
literal|31
operator|-
name|__builtin_clz
argument_list|(
name|val
argument_list|)
return|;
else|#
directive|else
comment|/* Software version */
specifier|static
specifier|const
name|unsigned
name|DeBruijnClz
index|[
literal|32
index|]
init|=
block|{
literal|0
block|,
literal|9
block|,
literal|1
block|,
literal|10
block|,
literal|13
block|,
literal|21
block|,
literal|2
block|,
literal|29
block|,
literal|11
block|,
literal|14
block|,
literal|16
block|,
literal|18
block|,
literal|22
block|,
literal|25
block|,
literal|3
block|,
literal|30
block|,
literal|8
block|,
literal|12
block|,
literal|20
block|,
literal|28
block|,
literal|15
block|,
literal|17
block|,
literal|24
block|,
literal|7
block|,
literal|19
block|,
literal|27
block|,
literal|23
block|,
literal|6
block|,
literal|26
block|,
literal|5
block|,
literal|4
block|,
literal|31
block|}
decl_stmt|;
name|U32
name|v
init|=
name|val
decl_stmt|;
name|unsigned
name|r
decl_stmt|;
name|v
operator||=
name|v
operator|>>
literal|1
expr_stmt|;
name|v
operator||=
name|v
operator|>>
literal|2
expr_stmt|;
name|v
operator||=
name|v
operator|>>
literal|4
expr_stmt|;
name|v
operator||=
name|v
operator|>>
literal|8
expr_stmt|;
name|v
operator||=
name|v
operator|>>
literal|16
expr_stmt|;
name|r
operator|=
name|DeBruijnClz
index|[
call|(
name|U32
call|)
argument_list|(
name|v
operator|*
literal|0x07C4ACDDU
argument_list|)
operator|>>
literal|27
index|]
expr_stmt|;
return|return
name|r
return|;
endif|#
directive|endif
block|}
comment|/********************************************************** * bitStream decoding **********************************************************/
comment|/*!BIT_initDStream *  Initialize a BIT_DStream_t. *  @bitD : a pointer to an already allocated BIT_DStream_t structure *  @srcBuffer must point at the beginning of a bitStream *  @srcSize must be the exact size of the bitStream *  @result : size of stream (== srcSize) or an errorCode if a problem is detected */
name|MEM_STATIC
name|size_t
name|BIT_initDStream
parameter_list|(
name|BIT_DStream_t
modifier|*
name|bitD
parameter_list|,
specifier|const
name|void
modifier|*
name|srcBuffer
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
if|if
condition|(
name|srcSize
operator|<
literal|1
condition|)
block|{
name|memset
argument_list|(
name|bitD
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bitD
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
block|}
if|if
condition|(
name|srcSize
operator|>=
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
condition|)
comment|/* normal case */
block|{
name|U32
name|contain32
decl_stmt|;
name|bitD
operator|->
name|start
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|srcBuffer
expr_stmt|;
name|bitD
operator|->
name|ptr
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|srcBuffer
operator|+
name|srcSize
operator|-
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
expr_stmt|;
name|bitD
operator|->
name|bitContainer
operator|=
name|MEM_readLEST
argument_list|(
name|bitD
operator|->
name|ptr
argument_list|)
expr_stmt|;
name|contain32
operator|=
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|srcBuffer
operator|)
index|[
name|srcSize
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|contain32
operator|==
literal|0
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
comment|/* endMark not present */
name|bitD
operator|->
name|bitsConsumed
operator|=
literal|8
operator|-
name|BIT_highbit32
argument_list|(
name|contain32
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|U32
name|contain32
decl_stmt|;
name|bitD
operator|->
name|start
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|srcBuffer
expr_stmt|;
name|bitD
operator|->
name|ptr
operator|=
name|bitD
operator|->
name|start
expr_stmt|;
name|bitD
operator|->
name|bitContainer
operator|=
operator|*
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|bitD
operator|->
name|start
operator|)
expr_stmt|;
switch|switch
condition|(
name|srcSize
condition|)
block|{
case|case
literal|7
case|:
name|bitD
operator|->
name|bitContainer
operator|+=
call|(
name|size_t
call|)
argument_list|(
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|bitD
operator|->
name|start
operator|)
operator|)
index|[
literal|6
index|]
argument_list|)
operator|<<
operator|(
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|*
literal|8
operator|-
literal|16
operator|)
expr_stmt|;
case|case
literal|6
case|:
name|bitD
operator|->
name|bitContainer
operator|+=
call|(
name|size_t
call|)
argument_list|(
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|bitD
operator|->
name|start
operator|)
operator|)
index|[
literal|5
index|]
argument_list|)
operator|<<
operator|(
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|*
literal|8
operator|-
literal|24
operator|)
expr_stmt|;
case|case
literal|5
case|:
name|bitD
operator|->
name|bitContainer
operator|+=
call|(
name|size_t
call|)
argument_list|(
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|bitD
operator|->
name|start
operator|)
operator|)
index|[
literal|4
index|]
argument_list|)
operator|<<
operator|(
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|*
literal|8
operator|-
literal|32
operator|)
expr_stmt|;
case|case
literal|4
case|:
name|bitD
operator|->
name|bitContainer
operator|+=
call|(
name|size_t
call|)
argument_list|(
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|bitD
operator|->
name|start
operator|)
operator|)
index|[
literal|3
index|]
argument_list|)
operator|<<
literal|24
expr_stmt|;
case|case
literal|3
case|:
name|bitD
operator|->
name|bitContainer
operator|+=
call|(
name|size_t
call|)
argument_list|(
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|bitD
operator|->
name|start
operator|)
operator|)
index|[
literal|2
index|]
argument_list|)
operator|<<
literal|16
expr_stmt|;
case|case
literal|2
case|:
name|bitD
operator|->
name|bitContainer
operator|+=
call|(
name|size_t
call|)
argument_list|(
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|bitD
operator|->
name|start
operator|)
operator|)
index|[
literal|1
index|]
argument_list|)
operator|<<
literal|8
expr_stmt|;
default|default:
empty_stmt|;
block|}
name|contain32
operator|=
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|srcBuffer
operator|)
index|[
name|srcSize
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|contain32
operator|==
literal|0
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
comment|/* endMark not present */
name|bitD
operator|->
name|bitsConsumed
operator|=
literal|8
operator|-
name|BIT_highbit32
argument_list|(
name|contain32
argument_list|)
expr_stmt|;
name|bitD
operator|->
name|bitsConsumed
operator|+=
call|(
name|U32
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|-
name|srcSize
argument_list|)
operator|*
literal|8
expr_stmt|;
block|}
return|return
name|srcSize
return|;
block|}
comment|/*!BIT_lookBits  * Provides next n bits from local register  * local register is not modified (bits are still present for next read/look)  * On 32-bits, maxNbBits==25  * On 64-bits, maxNbBits==57  * @return : value extracted  */
name|MEM_STATIC
name|size_t
name|BIT_lookBits
parameter_list|(
name|BIT_DStream_t
modifier|*
name|bitD
parameter_list|,
name|U32
name|nbBits
parameter_list|)
block|{
specifier|const
name|U32
name|bitMask
init|=
sizeof|sizeof
argument_list|(
name|bitD
operator|->
name|bitContainer
argument_list|)
operator|*
literal|8
operator|-
literal|1
decl_stmt|;
return|return
operator|(
operator|(
name|bitD
operator|->
name|bitContainer
operator|<<
operator|(
name|bitD
operator|->
name|bitsConsumed
operator|&
name|bitMask
operator|)
operator|)
operator|>>
literal|1
operator|)
operator|>>
operator|(
operator|(
name|bitMask
operator|-
name|nbBits
operator|)
operator|&
name|bitMask
operator|)
return|;
block|}
comment|/*! BIT_lookBitsFast : *   unsafe version; only works only if nbBits>= 1 */
name|MEM_STATIC
name|size_t
name|BIT_lookBitsFast
parameter_list|(
name|BIT_DStream_t
modifier|*
name|bitD
parameter_list|,
name|U32
name|nbBits
parameter_list|)
block|{
specifier|const
name|U32
name|bitMask
init|=
sizeof|sizeof
argument_list|(
name|bitD
operator|->
name|bitContainer
argument_list|)
operator|*
literal|8
operator|-
literal|1
decl_stmt|;
return|return
operator|(
name|bitD
operator|->
name|bitContainer
operator|<<
operator|(
name|bitD
operator|->
name|bitsConsumed
operator|&
name|bitMask
operator|)
operator|)
operator|>>
operator|(
operator|(
operator|(
name|bitMask
operator|+
literal|1
operator|)
operator|-
name|nbBits
operator|)
operator|&
name|bitMask
operator|)
return|;
block|}
name|MEM_STATIC
name|void
name|BIT_skipBits
parameter_list|(
name|BIT_DStream_t
modifier|*
name|bitD
parameter_list|,
name|U32
name|nbBits
parameter_list|)
block|{
name|bitD
operator|->
name|bitsConsumed
operator|+=
name|nbBits
expr_stmt|;
block|}
comment|/*!BIT_readBits  * Read next n bits from local register.  * pay attention to not read more than nbBits contained into local register.  * @return : extracted value.  */
name|MEM_STATIC
name|size_t
name|BIT_readBits
parameter_list|(
name|BIT_DStream_t
modifier|*
name|bitD
parameter_list|,
name|U32
name|nbBits
parameter_list|)
block|{
name|size_t
name|value
init|=
name|BIT_lookBits
argument_list|(
name|bitD
argument_list|,
name|nbBits
argument_list|)
decl_stmt|;
name|BIT_skipBits
argument_list|(
name|bitD
argument_list|,
name|nbBits
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
comment|/*!BIT_readBitsFast : *  unsafe version; only works only if nbBits>= 1 */
name|MEM_STATIC
name|size_t
name|BIT_readBitsFast
parameter_list|(
name|BIT_DStream_t
modifier|*
name|bitD
parameter_list|,
name|U32
name|nbBits
parameter_list|)
block|{
name|size_t
name|value
init|=
name|BIT_lookBitsFast
argument_list|(
name|bitD
argument_list|,
name|nbBits
argument_list|)
decl_stmt|;
name|BIT_skipBits
argument_list|(
name|bitD
argument_list|,
name|nbBits
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
name|MEM_STATIC
name|BIT_DStream_status
name|BIT_reloadDStream
parameter_list|(
name|BIT_DStream_t
modifier|*
name|bitD
parameter_list|)
block|{
if|if
condition|(
name|bitD
operator|->
name|bitsConsumed
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|bitD
operator|->
name|bitContainer
argument_list|)
operator|*
literal|8
operator|)
condition|)
comment|/* should never happen */
return|return
name|BIT_DStream_overflow
return|;
if|if
condition|(
name|bitD
operator|->
name|ptr
operator|>=
name|bitD
operator|->
name|start
operator|+
sizeof|sizeof
argument_list|(
name|bitD
operator|->
name|bitContainer
argument_list|)
condition|)
block|{
name|bitD
operator|->
name|ptr
operator|-=
name|bitD
operator|->
name|bitsConsumed
operator|>>
literal|3
expr_stmt|;
name|bitD
operator|->
name|bitsConsumed
operator|&=
literal|7
expr_stmt|;
name|bitD
operator|->
name|bitContainer
operator|=
name|MEM_readLEST
argument_list|(
name|bitD
operator|->
name|ptr
argument_list|)
expr_stmt|;
return|return
name|BIT_DStream_unfinished
return|;
block|}
if|if
condition|(
name|bitD
operator|->
name|ptr
operator|==
name|bitD
operator|->
name|start
condition|)
block|{
if|if
condition|(
name|bitD
operator|->
name|bitsConsumed
operator|<
sizeof|sizeof
argument_list|(
name|bitD
operator|->
name|bitContainer
argument_list|)
operator|*
literal|8
condition|)
return|return
name|BIT_DStream_endOfBuffer
return|;
return|return
name|BIT_DStream_completed
return|;
block|}
block|{
name|U32
name|nbBytes
init|=
name|bitD
operator|->
name|bitsConsumed
operator|>>
literal|3
decl_stmt|;
name|BIT_DStream_status
name|result
init|=
name|BIT_DStream_unfinished
decl_stmt|;
if|if
condition|(
name|bitD
operator|->
name|ptr
operator|-
name|nbBytes
operator|<
name|bitD
operator|->
name|start
condition|)
block|{
name|nbBytes
operator|=
call|(
name|U32
call|)
argument_list|(
name|bitD
operator|->
name|ptr
operator|-
name|bitD
operator|->
name|start
argument_list|)
expr_stmt|;
comment|/* ptr> start */
name|result
operator|=
name|BIT_DStream_endOfBuffer
expr_stmt|;
block|}
name|bitD
operator|->
name|ptr
operator|-=
name|nbBytes
expr_stmt|;
name|bitD
operator|->
name|bitsConsumed
operator|-=
name|nbBytes
operator|*
literal|8
expr_stmt|;
name|bitD
operator|->
name|bitContainer
operator|=
name|MEM_readLEST
argument_list|(
name|bitD
operator|->
name|ptr
argument_list|)
expr_stmt|;
comment|/* reminder : srcSize> sizeof(bitD) */
return|return
name|result
return|;
block|}
block|}
comment|/*! BIT_endOfDStream *   @return Tells if DStream has reached its exact end */
name|MEM_STATIC
name|unsigned
name|BIT_endOfDStream
parameter_list|(
specifier|const
name|BIT_DStream_t
modifier|*
name|DStream
parameter_list|)
block|{
return|return
operator|(
operator|(
name|DStream
operator|->
name|ptr
operator|==
name|DStream
operator|->
name|start
operator|)
operator|&&
operator|(
name|DStream
operator|->
name|bitsConsumed
operator|==
sizeof|sizeof
argument_list|(
name|DStream
operator|->
name|bitContainer
argument_list|)
operator|*
literal|8
operator|)
operator|)
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* BITSTREAM_H_MODULE */
comment|/* ******************************************************************    FSE : Finite State Entropy coder    header file for static linking (only)    Copyright (C) 2013-2015, Yann Collet     BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)     Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are    met:         * Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer.        * Redistributions in binary form must reproduce the above    copyright notice, this list of conditions and the following disclaimer    in the documentation and/or other materials provided with the    distribution.     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     You can contact the author at :    - Source repository : https://github.com/Cyan4973/FiniteStateEntropy    - Public forum : https://groups.google.com/forum/#!forum/lz4c ****************************************************************** */
ifndef|#
directive|ifndef
name|FSE_STATIC_H
define|#
directive|define
name|FSE_STATIC_H
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/* ***************************************** *  Static allocation *******************************************/
comment|/* FSE buffer bounds */
define|#
directive|define
name|FSE_NCOUNTBOUND
value|512
define|#
directive|define
name|FSE_BLOCKBOUND
parameter_list|(
name|size
parameter_list|)
value|(size + (size>>7))
define|#
directive|define
name|FSE_COMPRESSBOUND
parameter_list|(
name|size
parameter_list|)
value|(FSE_NCOUNTBOUND + FSE_BLOCKBOUND(size))
comment|/* Macro version, useful for static allocation */
comment|/* It is possible to statically allocate FSE CTable/DTable as a table of unsigned using below macros */
define|#
directive|define
name|FSE_CTABLE_SIZE_U32
parameter_list|(
name|maxTableLog
parameter_list|,
name|maxSymbolValue
parameter_list|)
value|(1 + (1<<(maxTableLog-1)) + ((maxSymbolValue+1)*2))
define|#
directive|define
name|FSE_DTABLE_SIZE_U32
parameter_list|(
name|maxTableLog
parameter_list|)
value|(1 + (1<<maxTableLog))
comment|/* ***************************************** *  FSE advanced API *******************************************/
specifier|static
name|size_t
name|FSE_buildDTable_raw
parameter_list|(
name|FSE_DTable
modifier|*
name|dt
parameter_list|,
name|unsigned
name|nbBits
parameter_list|)
function_decl|;
comment|/* build a fake FSE_DTable, designed to read an uncompressed bitstream where each symbol uses nbBits */
specifier|static
name|size_t
name|FSE_buildDTable_rle
parameter_list|(
name|FSE_DTable
modifier|*
name|dt
parameter_list|,
name|unsigned
name|char
name|symbolValue
parameter_list|)
function_decl|;
comment|/* build a fake FSE_DTable, designed to always generate the same symbolValue */
comment|/* ***************************************** *  FSE symbol decompression API *******************************************/
typedef|typedef
struct|struct
block|{
name|size_t
name|state
decl_stmt|;
specifier|const
name|void
modifier|*
name|table
decl_stmt|;
comment|/* precise table may vary, depending on U16 */
block|}
name|FSE_DState_t
typedef|;
specifier|static
name|void
name|FSE_initDState
parameter_list|(
name|FSE_DState_t
modifier|*
name|DStatePtr
parameter_list|,
name|BIT_DStream_t
modifier|*
name|bitD
parameter_list|,
specifier|const
name|FSE_DTable
modifier|*
name|dt
parameter_list|)
function_decl|;
specifier|static
name|unsigned
name|char
name|FSE_decodeSymbol
parameter_list|(
name|FSE_DState_t
modifier|*
name|DStatePtr
parameter_list|,
name|BIT_DStream_t
modifier|*
name|bitD
parameter_list|)
function_decl|;
specifier|static
name|unsigned
name|FSE_endOfDState
parameter_list|(
specifier|const
name|FSE_DState_t
modifier|*
name|DStatePtr
parameter_list|)
function_decl|;
comment|/*! Let's now decompose FSE_decompress_usingDTable() into its unitary components. You will decode FSE-encoded symbols from the bitStream, and also any other bitFields you put in, **in reverse order**.  You will need a few variables to track your bitStream. They are :  BIT_DStream_t DStream;    // Stream context FSE_DState_t  DState;     // State context. Multiple ones are possible FSE_DTable*   DTablePtr;  // Decoding table, provided by FSE_buildDTable()  The first thing to do is to init the bitStream.     errorCode = BIT_initDStream(&DStream, srcBuffer, srcSize);  You should then retrieve your initial state(s) (in reverse flushing order if you have several ones) :     errorCode = FSE_initDState(&DState,&DStream, DTablePtr);  You can then decode your data, symbol after symbol. For information the maximum number of bits read by FSE_decodeSymbol() is 'tableLog'. Keep in mind that symbols are decoded in reverse order, like a LIFO stack (last in, first out).     unsigned char symbol = FSE_decodeSymbol(&DState,&DStream);  You can retrieve any bitfield you eventually stored into the bitStream (in reverse order) Note : maximum allowed nbBits is 25, for 32-bits compatibility     size_t bitField = BIT_readBits(&DStream, nbBits);  All above operations only read from local register (which size depends on size_t). Refueling the register from memory is manually performed by the reload method.     endSignal = FSE_reloadDStream(&DStream);  BIT_reloadDStream() result tells if there is still some more data to read from DStream. BIT_DStream_unfinished : there is still some data left into the DStream. BIT_DStream_endOfBuffer : Dstream reached end of buffer. Its container may no longer be completely filled. BIT_DStream_completed : Dstream reached its exact end, corresponding in general to decompression completed. BIT_DStream_tooFar : Dstream went too far. Decompression result is corrupted.  When reaching end of buffer (BIT_DStream_endOfBuffer), progress slowly, notably if you decode multiple symbols per loop, to properly detect the exact end of stream. After each decoded symbol, check if DStream is fully consumed using this simple test :     BIT_reloadDStream(&DStream)>= BIT_DStream_completed  When it's done, verify decompression is fully completed, by checking both DStream and the relevant states. Checking if DStream has reached its end is performed by :     BIT_endOfDStream(&DStream); Check also the states. There might be some symbols left there, if some high probability ones (>50%) are possible.     FSE_endOfDState(&DState); */
comment|/* ***************************************** *  FSE unsafe API *******************************************/
specifier|static
name|unsigned
name|char
name|FSE_decodeSymbolFast
parameter_list|(
name|FSE_DState_t
modifier|*
name|DStatePtr
parameter_list|,
name|BIT_DStream_t
modifier|*
name|bitD
parameter_list|)
function_decl|;
comment|/* faster, but works only if nbBits is always>= 1 (otherwise, result will be corrupted) */
comment|/* ***************************************** *  Implementation of inlined functions *******************************************/
comment|/* decompression */
typedef|typedef
struct|struct
block|{
name|U16
name|tableLog
decl_stmt|;
name|U16
name|fastMode
decl_stmt|;
block|}
name|FSE_DTableHeader
typedef|;
comment|/* sizeof U32 */
typedef|typedef
struct|struct
block|{
name|unsigned
name|short
name|newState
decl_stmt|;
name|unsigned
name|char
name|symbol
decl_stmt|;
name|unsigned
name|char
name|nbBits
decl_stmt|;
block|}
name|FSE_decode_t
typedef|;
comment|/* size == U32 */
name|MEM_STATIC
name|void
name|FSE_initDState
parameter_list|(
name|FSE_DState_t
modifier|*
name|DStatePtr
parameter_list|,
name|BIT_DStream_t
modifier|*
name|bitD
parameter_list|,
specifier|const
name|FSE_DTable
modifier|*
name|dt
parameter_list|)
block|{
name|FSE_DTableHeader
name|DTableH
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|DTableH
argument_list|,
name|dt
argument_list|,
sizeof|sizeof
argument_list|(
name|DTableH
argument_list|)
argument_list|)
expr_stmt|;
name|DStatePtr
operator|->
name|state
operator|=
name|BIT_readBits
argument_list|(
name|bitD
argument_list|,
name|DTableH
operator|.
name|tableLog
argument_list|)
expr_stmt|;
name|BIT_reloadDStream
argument_list|(
name|bitD
argument_list|)
expr_stmt|;
name|DStatePtr
operator|->
name|table
operator|=
name|dt
operator|+
literal|1
expr_stmt|;
block|}
name|MEM_STATIC
name|BYTE
name|FSE_decodeSymbol
parameter_list|(
name|FSE_DState_t
modifier|*
name|DStatePtr
parameter_list|,
name|BIT_DStream_t
modifier|*
name|bitD
parameter_list|)
block|{
specifier|const
name|FSE_decode_t
name|DInfo
init|=
operator|(
operator|(
specifier|const
name|FSE_decode_t
operator|*
operator|)
operator|(
name|DStatePtr
operator|->
name|table
operator|)
operator|)
index|[
name|DStatePtr
operator|->
name|state
index|]
decl_stmt|;
specifier|const
name|U32
name|nbBits
init|=
name|DInfo
operator|.
name|nbBits
decl_stmt|;
name|BYTE
name|symbol
init|=
name|DInfo
operator|.
name|symbol
decl_stmt|;
name|size_t
name|lowBits
init|=
name|BIT_readBits
argument_list|(
name|bitD
argument_list|,
name|nbBits
argument_list|)
decl_stmt|;
name|DStatePtr
operator|->
name|state
operator|=
name|DInfo
operator|.
name|newState
operator|+
name|lowBits
expr_stmt|;
return|return
name|symbol
return|;
block|}
name|MEM_STATIC
name|BYTE
name|FSE_decodeSymbolFast
parameter_list|(
name|FSE_DState_t
modifier|*
name|DStatePtr
parameter_list|,
name|BIT_DStream_t
modifier|*
name|bitD
parameter_list|)
block|{
specifier|const
name|FSE_decode_t
name|DInfo
init|=
operator|(
operator|(
specifier|const
name|FSE_decode_t
operator|*
operator|)
operator|(
name|DStatePtr
operator|->
name|table
operator|)
operator|)
index|[
name|DStatePtr
operator|->
name|state
index|]
decl_stmt|;
specifier|const
name|U32
name|nbBits
init|=
name|DInfo
operator|.
name|nbBits
decl_stmt|;
name|BYTE
name|symbol
init|=
name|DInfo
operator|.
name|symbol
decl_stmt|;
name|size_t
name|lowBits
init|=
name|BIT_readBitsFast
argument_list|(
name|bitD
argument_list|,
name|nbBits
argument_list|)
decl_stmt|;
name|DStatePtr
operator|->
name|state
operator|=
name|DInfo
operator|.
name|newState
operator|+
name|lowBits
expr_stmt|;
return|return
name|symbol
return|;
block|}
name|MEM_STATIC
name|unsigned
name|FSE_endOfDState
parameter_list|(
specifier|const
name|FSE_DState_t
modifier|*
name|DStatePtr
parameter_list|)
block|{
return|return
name|DStatePtr
operator|->
name|state
operator|==
literal|0
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* FSE_STATIC_H */
comment|/* ******************************************************************    FSE : Finite State Entropy coder    Copyright (C) 2013-2015, Yann Collet.     BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)     Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are    met:         * Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer.        * Redistributions in binary form must reproduce the above    copyright notice, this list of conditions and the following disclaimer    in the documentation and/or other materials provided with the    distribution.     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.      You can contact the author at :     - FSE source repository : https://github.com/Cyan4973/FiniteStateEntropy     - Public forum : https://groups.google.com/forum/#!forum/lz4c ****************************************************************** */
ifndef|#
directive|ifndef
name|FSE_COMMONDEFS_ONLY
comment|/* ************************************************************** *  Tuning parameters ****************************************************************/
comment|/*!MEMORY_USAGE : *  Memory usage formula : N->2^N Bytes (examples : 10 -> 1KB; 12 -> 4KB ; 16 -> 64KB; 20 -> 1MB; etc.) *  Increasing memory usage improves compression ratio *  Reduced memory usage can improve speed, due to cache effect *  Recommended max value is 14, for 16KB, which nicely fits into Intel x86 L1 cache */
define|#
directive|define
name|FSE_MAX_MEMORY_USAGE
value|14
define|#
directive|define
name|FSE_DEFAULT_MEMORY_USAGE
value|13
comment|/*!FSE_MAX_SYMBOL_VALUE : *  Maximum symbol value authorized. *  Required for proper stack allocation */
define|#
directive|define
name|FSE_MAX_SYMBOL_VALUE
value|255
comment|/* ************************************************************** *  template functions type& suffix ****************************************************************/
define|#
directive|define
name|FSE_FUNCTION_TYPE
value|BYTE
define|#
directive|define
name|FSE_FUNCTION_EXTENSION
define|#
directive|define
name|FSE_DECODE_TYPE
value|FSE_decode_t
endif|#
directive|endif
comment|/* !FSE_COMMONDEFS_ONLY */
comment|/* ************************************************************** *  Compiler specifics ****************************************************************/
ifdef|#
directive|ifdef
name|_MSC_VER
comment|/* Visual Studio */
define|#
directive|define
name|FORCE_INLINE
value|static __forceinline
include|#
directive|include
file|<intrin.h>
comment|/* For Visual 2005 */
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4127
name|)
comment|/* disable: C4127: conditional expression is constant */
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4214
name|)
comment|/* disable: C4214: non-int bitfields */
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
operator|||
name|defined
argument_list|(
name|__STDC_VERSION__
argument_list|)
operator|&&
name|__STDC_VERSION__
operator|>=
literal|199901L
comment|/* C99 */
ifdef|#
directive|ifdef
name|__GNUC__
define|#
directive|define
name|FORCE_INLINE
value|static inline __attribute__((always_inline))
else|#
directive|else
define|#
directive|define
name|FORCE_INLINE
value|static inline
endif|#
directive|endif
else|#
directive|else
define|#
directive|define
name|FORCE_INLINE
value|static
endif|#
directive|endif
comment|/* __STDC_VERSION__ */
endif|#
directive|endif
comment|/* ************************************************************** *  Dependencies ****************************************************************/
include|#
directive|include
file|<stdlib.h>
comment|/* malloc, free, qsort */
include|#
directive|include
file|<string.h>
comment|/* memcpy, memset */
include|#
directive|include
file|<stdio.h>
comment|/* printf (debug) */
comment|/* *************************************************************** *  Constants *****************************************************************/
define|#
directive|define
name|FSE_MAX_TABLELOG
value|(FSE_MAX_MEMORY_USAGE-2)
define|#
directive|define
name|FSE_MAX_TABLESIZE
value|(1U<<FSE_MAX_TABLELOG)
define|#
directive|define
name|FSE_MAXTABLESIZE_MASK
value|(FSE_MAX_TABLESIZE-1)
define|#
directive|define
name|FSE_DEFAULT_TABLELOG
value|(FSE_DEFAULT_MEMORY_USAGE-2)
define|#
directive|define
name|FSE_MIN_TABLELOG
value|5
define|#
directive|define
name|FSE_TABLELOG_ABSOLUTE_MAX
value|15
if|#
directive|if
name|FSE_MAX_TABLELOG
operator|>
name|FSE_TABLELOG_ABSOLUTE_MAX
error|#
directive|error
literal|"FSE_MAX_TABLELOG> FSE_TABLELOG_ABSOLUTE_MAX is not supported"
endif|#
directive|endif
comment|/* ************************************************************** *  Error Management ****************************************************************/
define|#
directive|define
name|FSE_STATIC_ASSERT
parameter_list|(
name|c
parameter_list|)
value|{ enum { FSE_static_assert = 1/(int)(!!(c)) }; }
comment|/* use only *after* variable declarations */
comment|/* ************************************************************** *  Complex types ****************************************************************/
typedef|typedef
name|U32
name|DTable_max_t
index|[
name|FSE_DTABLE_SIZE_U32
argument_list|(
name|FSE_MAX_TABLELOG
argument_list|)
index|]
typedef|;
comment|/*-************************************************************** *  Templates ****************************************************************/
comment|/*   designed to be included   for type-specific functions (template emulation in C)   Objective is to write these functions only once, for improved maintenance */
comment|/* safety checks */
ifndef|#
directive|ifndef
name|FSE_FUNCTION_EXTENSION
error|#
directive|error
literal|"FSE_FUNCTION_EXTENSION must be defined"
endif|#
directive|endif
ifndef|#
directive|ifndef
name|FSE_FUNCTION_TYPE
error|#
directive|error
literal|"FSE_FUNCTION_TYPE must be defined"
endif|#
directive|endif
comment|/* Function names */
define|#
directive|define
name|FSE_CAT
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|X##Y
define|#
directive|define
name|FSE_FUNCTION_NAME
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|FSE_CAT(X,Y)
define|#
directive|define
name|FSE_TYPE_NAME
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|FSE_CAT(X,Y)
specifier|static
name|U32
name|FSE_tableStep
parameter_list|(
name|U32
name|tableSize
parameter_list|)
block|{
return|return
operator|(
name|tableSize
operator|>>
literal|1
operator|)
operator|+
operator|(
name|tableSize
operator|>>
literal|3
operator|)
operator|+
literal|3
return|;
block|}
specifier|static
name|size_t
name|FSE_buildDTable
parameter_list|(
name|FSE_DTable
modifier|*
name|dt
parameter_list|,
specifier|const
name|short
modifier|*
name|normalizedCounter
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|,
name|unsigned
name|tableLog
parameter_list|)
block|{
name|FSE_DTableHeader
name|DTableH
decl_stmt|;
name|void
modifier|*
specifier|const
name|tdPtr
init|=
name|dt
operator|+
literal|1
decl_stmt|;
comment|/* because dt is unsigned, 32-bits aligned on 32-bits */
name|FSE_DECODE_TYPE
modifier|*
specifier|const
name|tableDecode
init|=
operator|(
name|FSE_DECODE_TYPE
operator|*
operator|)
operator|(
name|tdPtr
operator|)
decl_stmt|;
specifier|const
name|U32
name|tableSize
init|=
literal|1
operator|<<
name|tableLog
decl_stmt|;
specifier|const
name|U32
name|tableMask
init|=
name|tableSize
operator|-
literal|1
decl_stmt|;
specifier|const
name|U32
name|step
init|=
name|FSE_tableStep
argument_list|(
name|tableSize
argument_list|)
decl_stmt|;
name|U16
name|symbolNext
index|[
name|FSE_MAX_SYMBOL_VALUE
operator|+
literal|1
index|]
decl_stmt|;
name|U32
name|position
init|=
literal|0
decl_stmt|;
name|U32
name|highThreshold
init|=
name|tableSize
operator|-
literal|1
decl_stmt|;
specifier|const
name|S16
name|largeLimit
init|=
call|(
name|S16
call|)
argument_list|(
literal|1
operator|<<
operator|(
name|tableLog
operator|-
literal|1
operator|)
argument_list|)
decl_stmt|;
name|U32
name|noLarge
init|=
literal|1
decl_stmt|;
name|U32
name|s
decl_stmt|;
comment|/* Sanity Checks */
if|if
condition|(
name|maxSymbolValue
operator|>
name|FSE_MAX_SYMBOL_VALUE
condition|)
return|return
name|ERROR
argument_list|(
name|maxSymbolValue_tooLarge
argument_list|)
return|;
if|if
condition|(
name|tableLog
operator|>
name|FSE_MAX_TABLELOG
condition|)
return|return
name|ERROR
argument_list|(
name|tableLog_tooLarge
argument_list|)
return|;
comment|/* Init, lay down lowprob symbols */
name|DTableH
operator|.
name|tableLog
operator|=
operator|(
name|U16
operator|)
name|tableLog
expr_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<=
name|maxSymbolValue
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|normalizedCounter
index|[
name|s
index|]
operator|==
operator|-
literal|1
condition|)
block|{
name|tableDecode
index|[
name|highThreshold
operator|--
index|]
operator|.
name|symbol
operator|=
operator|(
name|FSE_FUNCTION_TYPE
operator|)
name|s
expr_stmt|;
name|symbolNext
index|[
name|s
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|normalizedCounter
index|[
name|s
index|]
operator|>=
name|largeLimit
condition|)
name|noLarge
operator|=
literal|0
expr_stmt|;
name|symbolNext
index|[
name|s
index|]
operator|=
name|normalizedCounter
index|[
name|s
index|]
expr_stmt|;
block|}
block|}
comment|/* Spread symbols */
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<=
name|maxSymbolValue
condition|;
name|s
operator|++
control|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|normalizedCounter
index|[
name|s
index|]
condition|;
name|i
operator|++
control|)
block|{
name|tableDecode
index|[
name|position
index|]
operator|.
name|symbol
operator|=
operator|(
name|FSE_FUNCTION_TYPE
operator|)
name|s
expr_stmt|;
name|position
operator|=
operator|(
name|position
operator|+
name|step
operator|)
operator|&
name|tableMask
expr_stmt|;
while|while
condition|(
name|position
operator|>
name|highThreshold
condition|)
name|position
operator|=
operator|(
name|position
operator|+
name|step
operator|)
operator|&
name|tableMask
expr_stmt|;
comment|/* lowprob area */
block|}
block|}
if|if
condition|(
name|position
operator|!=
literal|0
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
comment|/* position must reach all cells once, otherwise normalizedCounter is incorrect */
comment|/* Build Decoding table */
block|{
name|U32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tableSize
condition|;
name|i
operator|++
control|)
block|{
name|FSE_FUNCTION_TYPE
name|symbol
init|=
call|(
name|FSE_FUNCTION_TYPE
call|)
argument_list|(
name|tableDecode
index|[
name|i
index|]
operator|.
name|symbol
argument_list|)
decl_stmt|;
name|U16
name|nextState
init|=
name|symbolNext
index|[
name|symbol
index|]
operator|++
decl_stmt|;
name|tableDecode
index|[
name|i
index|]
operator|.
name|nbBits
operator|=
call|(
name|BYTE
call|)
argument_list|(
name|tableLog
operator|-
name|BIT_highbit32
argument_list|(
operator|(
name|U32
operator|)
name|nextState
argument_list|)
argument_list|)
expr_stmt|;
name|tableDecode
index|[
name|i
index|]
operator|.
name|newState
operator|=
call|(
name|U16
call|)
argument_list|(
operator|(
name|nextState
operator|<<
name|tableDecode
index|[
name|i
index|]
operator|.
name|nbBits
operator|)
operator|-
name|tableSize
argument_list|)
expr_stmt|;
block|}
block|}
name|DTableH
operator|.
name|fastMode
operator|=
operator|(
name|U16
operator|)
name|noLarge
expr_stmt|;
name|memcpy
argument_list|(
name|dt
argument_list|,
operator|&
name|DTableH
argument_list|,
sizeof|sizeof
argument_list|(
name|DTableH
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
ifndef|#
directive|ifndef
name|FSE_COMMONDEFS_ONLY
comment|/****************************************** *  FSE helper functions ******************************************/
specifier|static
name|unsigned
name|FSE_isError
parameter_list|(
name|size_t
name|code
parameter_list|)
block|{
return|return
name|ERR_isError
argument_list|(
name|code
argument_list|)
return|;
block|}
comment|/**************************************************************** *  FSE NCount encoding-decoding ****************************************************************/
specifier|static
name|short
name|FSE_abs
parameter_list|(
name|short
name|a
parameter_list|)
block|{
return|return
name|a
operator|<
literal|0
condition|?
operator|-
name|a
else|:
name|a
return|;
block|}
specifier|static
name|size_t
name|FSE_readNCount
parameter_list|(
name|short
modifier|*
name|normalizedCounter
parameter_list|,
name|unsigned
modifier|*
name|maxSVPtr
parameter_list|,
name|unsigned
modifier|*
name|tableLogPtr
parameter_list|,
specifier|const
name|void
modifier|*
name|headerBuffer
parameter_list|,
name|size_t
name|hbSize
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|headerBuffer
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|iend
init|=
name|istart
operator|+
name|hbSize
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|ip
init|=
name|istart
decl_stmt|;
name|int
name|nbBits
decl_stmt|;
name|int
name|remaining
decl_stmt|;
name|int
name|threshold
decl_stmt|;
name|U32
name|bitStream
decl_stmt|;
name|int
name|bitCount
decl_stmt|;
name|unsigned
name|charnum
init|=
literal|0
decl_stmt|;
name|int
name|previous0
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|hbSize
operator|<
literal|4
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|bitStream
operator|=
name|MEM_readLE32
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|nbBits
operator|=
operator|(
name|bitStream
operator|&
literal|0xF
operator|)
operator|+
name|FSE_MIN_TABLELOG
expr_stmt|;
comment|/* extract tableLog */
if|if
condition|(
name|nbBits
operator|>
name|FSE_TABLELOG_ABSOLUTE_MAX
condition|)
return|return
name|ERROR
argument_list|(
name|tableLog_tooLarge
argument_list|)
return|;
name|bitStream
operator|>>=
literal|4
expr_stmt|;
name|bitCount
operator|=
literal|4
expr_stmt|;
operator|*
name|tableLogPtr
operator|=
name|nbBits
expr_stmt|;
name|remaining
operator|=
operator|(
literal|1
operator|<<
name|nbBits
operator|)
operator|+
literal|1
expr_stmt|;
name|threshold
operator|=
literal|1
operator|<<
name|nbBits
expr_stmt|;
name|nbBits
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|remaining
operator|>
literal|1
operator|)
operator|&&
operator|(
name|charnum
operator|<=
operator|*
name|maxSVPtr
operator|)
condition|)
block|{
if|if
condition|(
name|previous0
condition|)
block|{
name|unsigned
name|n0
init|=
name|charnum
decl_stmt|;
while|while
condition|(
operator|(
name|bitStream
operator|&
literal|0xFFFF
operator|)
operator|==
literal|0xFFFF
condition|)
block|{
name|n0
operator|+=
literal|24
expr_stmt|;
if|if
condition|(
name|ip
operator|<
name|iend
operator|-
literal|5
condition|)
block|{
name|ip
operator|+=
literal|2
expr_stmt|;
name|bitStream
operator|=
name|MEM_readLE32
argument_list|(
name|ip
argument_list|)
operator|>>
name|bitCount
expr_stmt|;
block|}
else|else
block|{
name|bitStream
operator|>>=
literal|16
expr_stmt|;
name|bitCount
operator|+=
literal|16
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|(
name|bitStream
operator|&
literal|3
operator|)
operator|==
literal|3
condition|)
block|{
name|n0
operator|+=
literal|3
expr_stmt|;
name|bitStream
operator|>>=
literal|2
expr_stmt|;
name|bitCount
operator|+=
literal|2
expr_stmt|;
block|}
name|n0
operator|+=
name|bitStream
operator|&
literal|3
expr_stmt|;
name|bitCount
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|n0
operator|>
operator|*
name|maxSVPtr
condition|)
return|return
name|ERROR
argument_list|(
name|maxSymbolValue_tooSmall
argument_list|)
return|;
while|while
condition|(
name|charnum
operator|<
name|n0
condition|)
name|normalizedCounter
index|[
name|charnum
operator|++
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ip
operator|<=
name|iend
operator|-
literal|7
operator|)
operator|||
operator|(
name|ip
operator|+
operator|(
name|bitCount
operator|>>
literal|3
operator|)
operator|<=
name|iend
operator|-
literal|4
operator|)
condition|)
block|{
name|ip
operator|+=
name|bitCount
operator|>>
literal|3
expr_stmt|;
name|bitCount
operator|&=
literal|7
expr_stmt|;
name|bitStream
operator|=
name|MEM_readLE32
argument_list|(
name|ip
argument_list|)
operator|>>
name|bitCount
expr_stmt|;
block|}
else|else
name|bitStream
operator|>>=
literal|2
expr_stmt|;
block|}
block|{
specifier|const
name|short
name|max
init|=
call|(
name|short
call|)
argument_list|(
operator|(
literal|2
operator|*
name|threshold
operator|-
literal|1
operator|)
operator|-
name|remaining
argument_list|)
decl_stmt|;
name|short
name|count
decl_stmt|;
if|if
condition|(
operator|(
name|bitStream
operator|&
operator|(
name|threshold
operator|-
literal|1
operator|)
operator|)
operator|<
operator|(
name|U32
operator|)
name|max
condition|)
block|{
name|count
operator|=
call|(
name|short
call|)
argument_list|(
name|bitStream
operator|&
operator|(
name|threshold
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|bitCount
operator|+=
name|nbBits
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|count
operator|=
call|(
name|short
call|)
argument_list|(
name|bitStream
operator|&
operator|(
literal|2
operator|*
name|threshold
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>=
name|threshold
condition|)
name|count
operator|-=
name|max
expr_stmt|;
name|bitCount
operator|+=
name|nbBits
expr_stmt|;
block|}
name|count
operator|--
expr_stmt|;
comment|/* extra accuracy */
name|remaining
operator|-=
name|FSE_abs
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|normalizedCounter
index|[
name|charnum
operator|++
index|]
operator|=
name|count
expr_stmt|;
name|previous0
operator|=
operator|!
name|count
expr_stmt|;
while|while
condition|(
name|remaining
operator|<
name|threshold
condition|)
block|{
name|nbBits
operator|--
expr_stmt|;
name|threshold
operator|>>=
literal|1
expr_stmt|;
block|}
block|{
if|if
condition|(
operator|(
name|ip
operator|<=
name|iend
operator|-
literal|7
operator|)
operator|||
operator|(
name|ip
operator|+
operator|(
name|bitCount
operator|>>
literal|3
operator|)
operator|<=
name|iend
operator|-
literal|4
operator|)
condition|)
block|{
name|ip
operator|+=
name|bitCount
operator|>>
literal|3
expr_stmt|;
name|bitCount
operator|&=
literal|7
expr_stmt|;
block|}
else|else
block|{
name|bitCount
operator|-=
call|(
name|int
call|)
argument_list|(
literal|8
operator|*
operator|(
name|iend
operator|-
literal|4
operator|-
name|ip
operator|)
argument_list|)
expr_stmt|;
name|ip
operator|=
name|iend
operator|-
literal|4
expr_stmt|;
block|}
name|bitStream
operator|=
name|MEM_readLE32
argument_list|(
name|ip
argument_list|)
operator|>>
operator|(
name|bitCount
operator|&
literal|31
operator|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|remaining
operator|!=
literal|1
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
operator|*
name|maxSVPtr
operator|=
name|charnum
operator|-
literal|1
expr_stmt|;
name|ip
operator|+=
operator|(
name|bitCount
operator|+
literal|7
operator|)
operator|>>
literal|3
expr_stmt|;
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|ip
operator|-
name|istart
argument_list|)
operator|>
name|hbSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
return|return
name|ip
operator|-
name|istart
return|;
block|}
comment|/********************************************************* *  Decompression (Byte symbols) *********************************************************/
specifier|static
name|size_t
name|FSE_buildDTable_rle
parameter_list|(
name|FSE_DTable
modifier|*
name|dt
parameter_list|,
name|BYTE
name|symbolValue
parameter_list|)
block|{
name|void
modifier|*
name|ptr
init|=
name|dt
decl_stmt|;
name|FSE_DTableHeader
modifier|*
specifier|const
name|DTableH
init|=
operator|(
name|FSE_DTableHeader
operator|*
operator|)
name|ptr
decl_stmt|;
name|void
modifier|*
name|dPtr
init|=
name|dt
operator|+
literal|1
decl_stmt|;
name|FSE_decode_t
modifier|*
specifier|const
name|cell
init|=
operator|(
name|FSE_decode_t
operator|*
operator|)
name|dPtr
decl_stmt|;
name|DTableH
operator|->
name|tableLog
operator|=
literal|0
expr_stmt|;
name|DTableH
operator|->
name|fastMode
operator|=
literal|0
expr_stmt|;
name|cell
operator|->
name|newState
operator|=
literal|0
expr_stmt|;
name|cell
operator|->
name|symbol
operator|=
name|symbolValue
expr_stmt|;
name|cell
operator|->
name|nbBits
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
specifier|static
name|size_t
name|FSE_buildDTable_raw
parameter_list|(
name|FSE_DTable
modifier|*
name|dt
parameter_list|,
name|unsigned
name|nbBits
parameter_list|)
block|{
name|void
modifier|*
name|ptr
init|=
name|dt
decl_stmt|;
name|FSE_DTableHeader
modifier|*
specifier|const
name|DTableH
init|=
operator|(
name|FSE_DTableHeader
operator|*
operator|)
name|ptr
decl_stmt|;
name|void
modifier|*
name|dPtr
init|=
name|dt
operator|+
literal|1
decl_stmt|;
name|FSE_decode_t
modifier|*
specifier|const
name|dinfo
init|=
operator|(
name|FSE_decode_t
operator|*
operator|)
name|dPtr
decl_stmt|;
specifier|const
name|unsigned
name|tableSize
init|=
literal|1
operator|<<
name|nbBits
decl_stmt|;
specifier|const
name|unsigned
name|tableMask
init|=
name|tableSize
operator|-
literal|1
decl_stmt|;
specifier|const
name|unsigned
name|maxSymbolValue
init|=
name|tableMask
decl_stmt|;
name|unsigned
name|s
decl_stmt|;
comment|/* Sanity checks */
if|if
condition|(
name|nbBits
operator|<
literal|1
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
comment|/* min size */
comment|/* Build Decoding Table */
name|DTableH
operator|->
name|tableLog
operator|=
operator|(
name|U16
operator|)
name|nbBits
expr_stmt|;
name|DTableH
operator|->
name|fastMode
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<=
name|maxSymbolValue
condition|;
name|s
operator|++
control|)
block|{
name|dinfo
index|[
name|s
index|]
operator|.
name|newState
operator|=
literal|0
expr_stmt|;
name|dinfo
index|[
name|s
index|]
operator|.
name|symbol
operator|=
operator|(
name|BYTE
operator|)
name|s
expr_stmt|;
name|dinfo
index|[
name|s
index|]
operator|.
name|nbBits
operator|=
operator|(
name|BYTE
operator|)
name|nbBits
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|FORCE_INLINE
name|size_t
name|FSE_decompress_usingDTable_generic
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|FSE_DTable
modifier|*
name|dt
parameter_list|,
specifier|const
name|unsigned
name|fast
parameter_list|)
block|{
name|BYTE
modifier|*
specifier|const
name|ostart
init|=
operator|(
name|BYTE
operator|*
operator|)
name|dst
decl_stmt|;
name|BYTE
modifier|*
name|op
init|=
name|ostart
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|omax
init|=
name|op
operator|+
name|maxDstSize
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|olimit
init|=
name|omax
operator|-
literal|3
decl_stmt|;
name|BIT_DStream_t
name|bitD
decl_stmt|;
name|FSE_DState_t
name|state1
decl_stmt|;
name|FSE_DState_t
name|state2
decl_stmt|;
name|size_t
name|errorCode
decl_stmt|;
comment|/* Init */
name|errorCode
operator|=
name|BIT_initDStream
argument_list|(
operator|&
name|bitD
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|)
expr_stmt|;
comment|/* replaced last arg by maxCompressed Size */
if|if
condition|(
name|FSE_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
name|FSE_initDState
argument_list|(
operator|&
name|state1
argument_list|,
operator|&
name|bitD
argument_list|,
name|dt
argument_list|)
expr_stmt|;
name|FSE_initDState
argument_list|(
operator|&
name|state2
argument_list|,
operator|&
name|bitD
argument_list|,
name|dt
argument_list|)
expr_stmt|;
define|#
directive|define
name|FSE_GETSYMBOL
parameter_list|(
name|statePtr
parameter_list|)
value|fast ? FSE_decodeSymbolFast(statePtr,&bitD) : FSE_decodeSymbol(statePtr,&bitD)
comment|/* 4 symbols per loop */
for|for
control|(
init|;
operator|(
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD
argument_list|)
operator|==
name|BIT_DStream_unfinished
operator|)
operator|&&
operator|(
name|op
operator|<
name|olimit
operator|)
condition|;
name|op
operator|+=
literal|4
control|)
block|{
name|op
index|[
literal|0
index|]
operator|=
name|FSE_GETSYMBOL
argument_list|(
operator|&
name|state1
argument_list|)
expr_stmt|;
if|if
condition|(
name|FSE_MAX_TABLELOG
operator|*
literal|2
operator|+
literal|7
operator|>
sizeof|sizeof
argument_list|(
name|bitD
operator|.
name|bitContainer
argument_list|)
operator|*
literal|8
condition|)
comment|/* This test must be static */
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|FSE_GETSYMBOL
argument_list|(
operator|&
name|state2
argument_list|)
expr_stmt|;
if|if
condition|(
name|FSE_MAX_TABLELOG
operator|*
literal|4
operator|+
literal|7
operator|>
sizeof|sizeof
argument_list|(
name|bitD
operator|.
name|bitContainer
argument_list|)
operator|*
literal|8
condition|)
comment|/* This test must be static */
block|{
if|if
condition|(
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD
argument_list|)
operator|>
name|BIT_DStream_unfinished
condition|)
block|{
name|op
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
block|}
name|op
index|[
literal|2
index|]
operator|=
name|FSE_GETSYMBOL
argument_list|(
operator|&
name|state1
argument_list|)
expr_stmt|;
if|if
condition|(
name|FSE_MAX_TABLELOG
operator|*
literal|2
operator|+
literal|7
operator|>
sizeof|sizeof
argument_list|(
name|bitD
operator|.
name|bitContainer
argument_list|)
operator|*
literal|8
condition|)
comment|/* This test must be static */
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD
argument_list|)
expr_stmt|;
name|op
index|[
literal|3
index|]
operator|=
name|FSE_GETSYMBOL
argument_list|(
operator|&
name|state2
argument_list|)
expr_stmt|;
block|}
comment|/* tail */
comment|/* note : BIT_reloadDStream(&bitD)>= FSE_DStream_partiallyFilled; Ends at exactly BIT_DStream_completed */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD
argument_list|)
operator|>
name|BIT_DStream_completed
operator|)
operator|||
operator|(
name|op
operator|==
name|omax
operator|)
operator|||
operator|(
name|BIT_endOfDStream
argument_list|(
operator|&
name|bitD
argument_list|)
operator|&&
operator|(
name|fast
operator|||
name|FSE_endOfDState
argument_list|(
operator|&
name|state1
argument_list|)
operator|)
operator|)
condition|)
break|break;
operator|*
name|op
operator|++
operator|=
name|FSE_GETSYMBOL
argument_list|(
operator|&
name|state1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD
argument_list|)
operator|>
name|BIT_DStream_completed
operator|)
operator|||
operator|(
name|op
operator|==
name|omax
operator|)
operator|||
operator|(
name|BIT_endOfDStream
argument_list|(
operator|&
name|bitD
argument_list|)
operator|&&
operator|(
name|fast
operator|||
name|FSE_endOfDState
argument_list|(
operator|&
name|state2
argument_list|)
operator|)
operator|)
condition|)
break|break;
operator|*
name|op
operator|++
operator|=
name|FSE_GETSYMBOL
argument_list|(
operator|&
name|state2
argument_list|)
expr_stmt|;
block|}
comment|/* end ? */
if|if
condition|(
name|BIT_endOfDStream
argument_list|(
operator|&
name|bitD
argument_list|)
operator|&&
name|FSE_endOfDState
argument_list|(
operator|&
name|state1
argument_list|)
operator|&&
name|FSE_endOfDState
argument_list|(
operator|&
name|state2
argument_list|)
condition|)
return|return
name|op
operator|-
name|ostart
return|;
if|if
condition|(
name|op
operator|==
name|omax
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
comment|/* dst buffer is full, but cSrc unfinished */
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
block|}
specifier|static
name|size_t
name|FSE_decompress_usingDTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|originalSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|FSE_DTable
modifier|*
name|dt
parameter_list|)
block|{
name|FSE_DTableHeader
name|DTableH
decl_stmt|;
name|U32
name|fastMode
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|DTableH
argument_list|,
name|dt
argument_list|,
sizeof|sizeof
argument_list|(
name|DTableH
argument_list|)
argument_list|)
expr_stmt|;
name|fastMode
operator|=
name|DTableH
operator|.
name|fastMode
expr_stmt|;
comment|/* select fast mode (static) */
if|if
condition|(
name|fastMode
condition|)
return|return
name|FSE_decompress_usingDTable_generic
argument_list|(
name|dst
argument_list|,
name|originalSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|,
name|dt
argument_list|,
literal|1
argument_list|)
return|;
return|return
name|FSE_decompress_usingDTable_generic
argument_list|(
name|dst
argument_list|,
name|originalSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|,
name|dt
argument_list|,
literal|0
argument_list|)
return|;
block|}
specifier|static
name|size_t
name|FSE_decompress
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|cSrc
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|ip
init|=
name|istart
decl_stmt|;
name|short
name|counting
index|[
name|FSE_MAX_SYMBOL_VALUE
operator|+
literal|1
index|]
decl_stmt|;
name|DTable_max_t
name|dt
decl_stmt|;
comment|/* Static analyzer seems unable to understand this table will be properly initialized later */
name|unsigned
name|tableLog
decl_stmt|;
name|unsigned
name|maxSymbolValue
init|=
name|FSE_MAX_SYMBOL_VALUE
decl_stmt|;
name|size_t
name|errorCode
decl_stmt|;
if|if
condition|(
name|cSrcSize
operator|<
literal|2
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
comment|/* too small input size */
comment|/* normal FSE decoding mode */
name|errorCode
operator|=
name|FSE_readNCount
argument_list|(
name|counting
argument_list|,
operator|&
name|maxSymbolValue
argument_list|,
operator|&
name|tableLog
argument_list|,
name|istart
argument_list|,
name|cSrcSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|FSE_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
if|if
condition|(
name|errorCode
operator|>=
name|cSrcSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
comment|/* too small input size */
name|ip
operator|+=
name|errorCode
expr_stmt|;
name|cSrcSize
operator|-=
name|errorCode
expr_stmt|;
name|errorCode
operator|=
name|FSE_buildDTable
argument_list|(
name|dt
argument_list|,
name|counting
argument_list|,
name|maxSymbolValue
argument_list|,
name|tableLog
argument_list|)
expr_stmt|;
if|if
condition|(
name|FSE_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
comment|/* always return, even if it is an error code */
return|return
name|FSE_decompress_usingDTable
argument_list|(
name|dst
argument_list|,
name|maxDstSize
argument_list|,
name|ip
argument_list|,
name|cSrcSize
argument_list|,
name|dt
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|/* FSE_COMMONDEFS_ONLY */
comment|/* ******************************************************************    Huff0 : Huffman coder, part of New Generation Entropy library    header file    Copyright (C) 2013-2015, Yann Collet.     BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)     Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are    met:         * Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer.        * Redistributions in binary form must reproduce the above    copyright notice, this list of conditions and the following disclaimer    in the documentation and/or other materials provided with the    distribution.     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     You can contact the author at :    - Source repository : https://github.com/Cyan4973/FiniteStateEntropy    - Public forum : https://groups.google.com/forum/#!forum/lz4c ****************************************************************** */
ifndef|#
directive|ifndef
name|HUFF0_H
define|#
directive|define
name|HUFF0_H
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/* **************************************** *  Dependency ******************************************/
include|#
directive|include
file|<stddef.h>
comment|/* size_t */
comment|/* **************************************** *  Huff0 simple functions ******************************************/
specifier|static
name|size_t
name|HUF_decompress
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
function_decl|;
comment|/*! HUF_decompress():     Decompress Huff0 data from buffer 'cSrc', of size 'cSrcSize',     into already allocated destination buffer 'dst', of size 'dstSize'.     'dstSize' must be the exact size of original (uncompressed) data.     Note : in contrast with FSE, HUF_decompress can regenerate RLE (cSrcSize==1) and uncompressed (cSrcSize==dstSize) data, because it knows size to regenerate.     @return : size of regenerated data (== dstSize)               or an error code, which can be tested using HUF_isError() */
comment|/* **************************************** *  Tool functions ******************************************/
comment|/* Error Management */
specifier|static
name|unsigned
name|HUF_isError
parameter_list|(
name|size_t
name|code
parameter_list|)
function_decl|;
comment|/* tells if a return value is an error code */
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* HUFF0_H */
comment|/* ******************************************************************    Huff0 : Huffman coder, part of New Generation Entropy library    header file for static linking (only)    Copyright (C) 2013-2015, Yann Collet     BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)     Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are    met:         * Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer.        * Redistributions in binary form must reproduce the above    copyright notice, this list of conditions and the following disclaimer    in the documentation and/or other materials provided with the    distribution.     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     You can contact the author at :    - Source repository : https://github.com/Cyan4973/FiniteStateEntropy    - Public forum : https://groups.google.com/forum/#!forum/lz4c ****************************************************************** */
ifndef|#
directive|ifndef
name|HUFF0_STATIC_H
define|#
directive|define
name|HUFF0_STATIC_H
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/* **************************************** *  Static allocation macros ******************************************/
comment|/* static allocation of Huff0's DTable */
define|#
directive|define
name|HUF_DTABLE_SIZE
parameter_list|(
name|maxTableLog
parameter_list|)
value|(1 + (1<<maxTableLog))
comment|/* nb Cells; use unsigned short for X2, unsigned int for X4 */
define|#
directive|define
name|HUF_CREATE_STATIC_DTABLEX2
parameter_list|(
name|DTable
parameter_list|,
name|maxTableLog
parameter_list|)
define|\
value|unsigned short DTable[HUF_DTABLE_SIZE(maxTableLog)] = { maxTableLog }
define|#
directive|define
name|HUF_CREATE_STATIC_DTABLEX4
parameter_list|(
name|DTable
parameter_list|,
name|maxTableLog
parameter_list|)
define|\
value|unsigned int DTable[HUF_DTABLE_SIZE(maxTableLog)] = { maxTableLog }
define|#
directive|define
name|HUF_CREATE_STATIC_DTABLEX6
parameter_list|(
name|DTable
parameter_list|,
name|maxTableLog
parameter_list|)
define|\
value|unsigned int DTable[HUF_DTABLE_SIZE(maxTableLog) * 3 / 2] = { maxTableLog }
comment|/* **************************************** *  Advanced decompression functions ******************************************/
specifier|static
name|size_t
name|HUF_decompress4X2
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
function_decl|;
comment|/* single-symbol decoder */
specifier|static
name|size_t
name|HUF_decompress4X4
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
function_decl|;
comment|/* double-symbols decoder */
comment|/* **************************************** *  Huff0 detailed API ******************************************/
comment|/*! HUF_decompress() does the following: 1. select the decompression algorithm (X2, X4, X6) based on pre-computed heuristics 2. build Huffman table from save, using HUF_readDTableXn() 3. decode 1 or 4 segments in parallel using HUF_decompressSXn_usingDTable  */
specifier|static
name|size_t
name|HUF_readDTableX2
parameter_list|(
name|unsigned
name|short
modifier|*
name|DTable
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
specifier|static
name|size_t
name|HUF_readDTableX4
parameter_list|(
name|unsigned
modifier|*
name|DTable
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
specifier|static
name|size_t
name|HUF_decompress4X2_usingDTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|unsigned
name|short
modifier|*
name|DTable
parameter_list|)
function_decl|;
specifier|static
name|size_t
name|HUF_decompress4X4_usingDTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|unsigned
modifier|*
name|DTable
parameter_list|)
function_decl|;
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* HUFF0_STATIC_H */
comment|/* ******************************************************************    Huff0 : Huffman coder, part of New Generation Entropy library    Copyright (C) 2013-2015, Yann Collet.     BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)     Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are    met:         * Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer.        * Redistributions in binary form must reproduce the above    copyright notice, this list of conditions and the following disclaimer    in the documentation and/or other materials provided with the    distribution.     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.      You can contact the author at :     - FSE+Huff0 source repository : https://github.com/Cyan4973/FiniteStateEntropy ****************************************************************** */
comment|/* ************************************************************** *  Compiler specifics ****************************************************************/
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|__STDC_VERSION__
argument_list|)
operator|&&
operator|(
name|__STDC_VERSION__
operator|>=
literal|199901L
operator|)
comment|/* C99 */
operator|)
comment|/* inline is defined */
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
define|#
directive|define
name|inline
value|__inline
else|#
directive|else
define|#
directive|define
name|inline
comment|/* disable inline */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_MSC_VER
comment|/* Visual Studio */
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4127
name|)
comment|/* disable: C4127: conditional expression is constant */
endif|#
directive|endif
comment|/* ************************************************************** *  Includes ****************************************************************/
include|#
directive|include
file|<stdlib.h>
comment|/* malloc, free, qsort */
include|#
directive|include
file|<string.h>
comment|/* memcpy, memset */
include|#
directive|include
file|<stdio.h>
comment|/* printf (debug) */
comment|/* ************************************************************** *  Constants ****************************************************************/
define|#
directive|define
name|HUF_ABSOLUTEMAX_TABLELOG
value|16
comment|/* absolute limit of HUF_MAX_TABLELOG. Beyond that value, code does not work */
define|#
directive|define
name|HUF_MAX_TABLELOG
value|12
comment|/* max configured tableLog (for static allocation); can be modified up to HUF_ABSOLUTEMAX_TABLELOG */
define|#
directive|define
name|HUF_DEFAULT_TABLELOG
value|HUF_MAX_TABLELOG
comment|/* tableLog by default, when not specified */
define|#
directive|define
name|HUF_MAX_SYMBOL_VALUE
value|255
if|#
directive|if
operator|(
name|HUF_MAX_TABLELOG
operator|>
name|HUF_ABSOLUTEMAX_TABLELOG
operator|)
error|#
directive|error
literal|"HUF_MAX_TABLELOG is too large !"
endif|#
directive|endif
comment|/* ************************************************************** *  Error Management ****************************************************************/
specifier|static
name|unsigned
name|HUF_isError
parameter_list|(
name|size_t
name|code
parameter_list|)
block|{
return|return
name|ERR_isError
argument_list|(
name|code
argument_list|)
return|;
block|}
define|#
directive|define
name|HUF_STATIC_ASSERT
parameter_list|(
name|c
parameter_list|)
value|{ enum { HUF_static_assert = 1/(int)(!!(c)) }; }
comment|/* use only *after* variable declarations */
comment|/*-******************************************************* *  Huff0 : Huffman block decompression *********************************************************/
typedef|typedef
struct|struct
block|{
name|BYTE
name|byte
decl_stmt|;
name|BYTE
name|nbBits
decl_stmt|;
block|}
name|HUF_DEltX2
typedef|;
comment|/* single-symbol decoding */
typedef|typedef
struct|struct
block|{
name|U16
name|sequence
decl_stmt|;
name|BYTE
name|nbBits
decl_stmt|;
name|BYTE
name|length
decl_stmt|;
block|}
name|HUF_DEltX4
typedef|;
comment|/* double-symbols decoding */
typedef|typedef
struct|struct
block|{
name|BYTE
name|symbol
decl_stmt|;
name|BYTE
name|weight
decl_stmt|;
block|}
name|sortedSymbol_t
typedef|;
comment|/*! HUF_readStats     Read compact Huffman tree, saved by HUF_writeCTable     @huffWeight : destination buffer     @return : size read from `src` */
specifier|static
name|size_t
name|HUF_readStats
parameter_list|(
name|BYTE
modifier|*
name|huffWeight
parameter_list|,
name|size_t
name|hwSize
parameter_list|,
name|U32
modifier|*
name|rankStats
parameter_list|,
name|U32
modifier|*
name|nbSymbolsPtr
parameter_list|,
name|U32
modifier|*
name|tableLogPtr
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
name|U32
name|weightTotal
decl_stmt|;
name|U32
name|tableLog
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
decl_stmt|;
name|size_t
name|iSize
decl_stmt|;
name|size_t
name|oSize
decl_stmt|;
name|U32
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|srcSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|iSize
operator|=
name|ip
index|[
literal|0
index|]
expr_stmt|;
comment|//memset(huffWeight, 0, hwSize);   /* is not necessary, even though some analyzer complain ... */
if|if
condition|(
name|iSize
operator|>=
literal|128
condition|)
comment|/* special header */
block|{
if|if
condition|(
name|iSize
operator|>=
operator|(
literal|242
operator|)
condition|)
comment|/* RLE */
block|{
specifier|static
name|int
name|l
index|[
literal|14
index|]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|7
block|,
literal|8
block|,
literal|15
block|,
literal|16
block|,
literal|31
block|,
literal|32
block|,
literal|63
block|,
literal|64
block|,
literal|127
block|,
literal|128
block|}
decl_stmt|;
name|oSize
operator|=
name|l
index|[
name|iSize
operator|-
literal|242
index|]
expr_stmt|;
name|memset
argument_list|(
name|huffWeight
argument_list|,
literal|1
argument_list|,
name|hwSize
argument_list|)
expr_stmt|;
name|iSize
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* Incompressible */
block|{
name|oSize
operator|=
name|iSize
operator|-
literal|127
expr_stmt|;
name|iSize
operator|=
operator|(
operator|(
name|oSize
operator|+
literal|1
operator|)
operator|/
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|iSize
operator|+
literal|1
operator|>
name|srcSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
if|if
condition|(
name|oSize
operator|>=
name|hwSize
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
name|ip
operator|+=
literal|1
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|oSize
condition|;
name|n
operator|+=
literal|2
control|)
block|{
name|huffWeight
index|[
name|n
index|]
operator|=
name|ip
index|[
name|n
operator|/
literal|2
index|]
operator|>>
literal|4
expr_stmt|;
name|huffWeight
index|[
name|n
operator|+
literal|1
index|]
operator|=
name|ip
index|[
name|n
operator|/
literal|2
index|]
operator|&
literal|15
expr_stmt|;
block|}
block|}
block|}
else|else
comment|/* header compressed with FSE (normal case) */
block|{
if|if
condition|(
name|iSize
operator|+
literal|1
operator|>
name|srcSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|oSize
operator|=
name|FSE_decompress
argument_list|(
name|huffWeight
argument_list|,
name|hwSize
operator|-
literal|1
argument_list|,
name|ip
operator|+
literal|1
argument_list|,
name|iSize
argument_list|)
expr_stmt|;
comment|/* max (hwSize-1) values decoded, as last one is implied */
if|if
condition|(
name|FSE_isError
argument_list|(
name|oSize
argument_list|)
condition|)
return|return
name|oSize
return|;
block|}
comment|/* collect weight stats */
name|memset
argument_list|(
name|rankStats
argument_list|,
literal|0
argument_list|,
operator|(
name|HUF_ABSOLUTEMAX_TABLELOG
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
argument_list|)
expr_stmt|;
name|weightTotal
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|oSize
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|huffWeight
index|[
name|n
index|]
operator|>=
name|HUF_ABSOLUTEMAX_TABLELOG
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
name|rankStats
index|[
name|huffWeight
index|[
name|n
index|]
index|]
operator|++
expr_stmt|;
name|weightTotal
operator|+=
operator|(
literal|1
operator|<<
name|huffWeight
index|[
name|n
index|]
operator|)
operator|>>
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|weightTotal
operator|==
literal|0
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* get last non-null symbol weight (implied, total must be 2^n) */
name|tableLog
operator|=
name|BIT_highbit32
argument_list|(
name|weightTotal
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|tableLog
operator|>
name|HUF_ABSOLUTEMAX_TABLELOG
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
block|{
name|U32
name|total
init|=
literal|1
operator|<<
name|tableLog
decl_stmt|;
name|U32
name|rest
init|=
name|total
operator|-
name|weightTotal
decl_stmt|;
name|U32
name|verif
init|=
literal|1
operator|<<
name|BIT_highbit32
argument_list|(
name|rest
argument_list|)
decl_stmt|;
name|U32
name|lastWeight
init|=
name|BIT_highbit32
argument_list|(
name|rest
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|verif
operator|!=
name|rest
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* last value must be a clean power of 2 */
name|huffWeight
index|[
name|oSize
index|]
operator|=
operator|(
name|BYTE
operator|)
name|lastWeight
expr_stmt|;
name|rankStats
index|[
name|lastWeight
index|]
operator|++
expr_stmt|;
block|}
comment|/* check tree construction validity */
if|if
condition|(
operator|(
name|rankStats
index|[
literal|1
index|]
operator|<
literal|2
operator|)
operator|||
operator|(
name|rankStats
index|[
literal|1
index|]
operator|&
literal|1
operator|)
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* by construction : at least 2 elts of rank 1, must be even */
comment|/* results */
operator|*
name|nbSymbolsPtr
operator|=
call|(
name|U32
call|)
argument_list|(
name|oSize
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|tableLogPtr
operator|=
name|tableLog
expr_stmt|;
return|return
name|iSize
operator|+
literal|1
return|;
block|}
comment|/**************************/
comment|/* single-symbol decoding */
comment|/**************************/
specifier|static
name|size_t
name|HUF_readDTableX2
parameter_list|(
name|U16
modifier|*
name|DTable
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
name|BYTE
name|huffWeight
index|[
name|HUF_MAX_SYMBOL_VALUE
operator|+
literal|1
index|]
decl_stmt|;
name|U32
name|rankVal
index|[
name|HUF_ABSOLUTEMAX_TABLELOG
operator|+
literal|1
index|]
decl_stmt|;
comment|/* large enough for values from 0 to 16 */
name|U32
name|tableLog
init|=
literal|0
decl_stmt|;
name|size_t
name|iSize
decl_stmt|;
name|U32
name|nbSymbols
init|=
literal|0
decl_stmt|;
name|U32
name|n
decl_stmt|;
name|U32
name|nextRankStart
decl_stmt|;
name|void
modifier|*
specifier|const
name|dtPtr
init|=
name|DTable
operator|+
literal|1
decl_stmt|;
name|HUF_DEltX2
modifier|*
specifier|const
name|dt
init|=
operator|(
name|HUF_DEltX2
operator|*
operator|)
name|dtPtr
decl_stmt|;
name|HUF_STATIC_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|HUF_DEltX2
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|U16
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if compilation fails here, assertion is false */
comment|//memset(huffWeight, 0, sizeof(huffWeight));   /* is not necessary, even though some analyzer complain ... */
name|iSize
operator|=
name|HUF_readStats
argument_list|(
name|huffWeight
argument_list|,
name|HUF_MAX_SYMBOL_VALUE
operator|+
literal|1
argument_list|,
name|rankVal
argument_list|,
operator|&
name|nbSymbols
argument_list|,
operator|&
name|tableLog
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|HUF_isError
argument_list|(
name|iSize
argument_list|)
condition|)
return|return
name|iSize
return|;
comment|/* check result */
if|if
condition|(
name|tableLog
operator|>
name|DTable
index|[
literal|0
index|]
condition|)
return|return
name|ERROR
argument_list|(
name|tableLog_tooLarge
argument_list|)
return|;
comment|/* DTable is too small */
name|DTable
index|[
literal|0
index|]
operator|=
operator|(
name|U16
operator|)
name|tableLog
expr_stmt|;
comment|/* maybe should separate sizeof DTable, as allocated, from used size of DTable, in case of DTable re-use */
comment|/* Prepare ranks */
name|nextRankStart
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|1
init|;
name|n
operator|<=
name|tableLog
condition|;
name|n
operator|++
control|)
block|{
name|U32
name|current
init|=
name|nextRankStart
decl_stmt|;
name|nextRankStart
operator|+=
operator|(
name|rankVal
index|[
name|n
index|]
operator|<<
operator|(
name|n
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|rankVal
index|[
name|n
index|]
operator|=
name|current
expr_stmt|;
block|}
comment|/* fill DTable */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nbSymbols
condition|;
name|n
operator|++
control|)
block|{
specifier|const
name|U32
name|w
init|=
name|huffWeight
index|[
name|n
index|]
decl_stmt|;
specifier|const
name|U32
name|length
init|=
operator|(
literal|1
operator|<<
name|w
operator|)
operator|>>
literal|1
decl_stmt|;
name|U32
name|i
decl_stmt|;
name|HUF_DEltX2
name|D
decl_stmt|;
name|D
operator|.
name|byte
operator|=
operator|(
name|BYTE
operator|)
name|n
expr_stmt|;
name|D
operator|.
name|nbBits
operator|=
call|(
name|BYTE
call|)
argument_list|(
name|tableLog
operator|+
literal|1
operator|-
name|w
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|rankVal
index|[
name|w
index|]
init|;
name|i
operator|<
name|rankVal
index|[
name|w
index|]
operator|+
name|length
condition|;
name|i
operator|++
control|)
name|dt
index|[
name|i
index|]
operator|=
name|D
expr_stmt|;
name|rankVal
index|[
name|w
index|]
operator|+=
name|length
expr_stmt|;
block|}
return|return
name|iSize
return|;
block|}
specifier|static
name|BYTE
name|HUF_decodeSymbolX2
parameter_list|(
name|BIT_DStream_t
modifier|*
name|Dstream
parameter_list|,
specifier|const
name|HUF_DEltX2
modifier|*
name|dt
parameter_list|,
specifier|const
name|U32
name|dtLog
parameter_list|)
block|{
specifier|const
name|size_t
name|val
init|=
name|BIT_lookBitsFast
argument_list|(
name|Dstream
argument_list|,
name|dtLog
argument_list|)
decl_stmt|;
comment|/* note : dtLog>= 1 */
specifier|const
name|BYTE
name|c
init|=
name|dt
index|[
name|val
index|]
operator|.
name|byte
decl_stmt|;
name|BIT_skipBits
argument_list|(
name|Dstream
argument_list|,
name|dt
index|[
name|val
index|]
operator|.
name|nbBits
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
define|#
directive|define
name|HUF_DECODE_SYMBOLX2_0
parameter_list|(
name|ptr
parameter_list|,
name|DStreamPtr
parameter_list|)
define|\
value|*ptr++ = HUF_decodeSymbolX2(DStreamPtr, dt, dtLog)
define|#
directive|define
name|HUF_DECODE_SYMBOLX2_1
parameter_list|(
name|ptr
parameter_list|,
name|DStreamPtr
parameter_list|)
define|\
value|if (MEM_64bits() || (HUF_MAX_TABLELOG<=12)) \         HUF_DECODE_SYMBOLX2_0(ptr, DStreamPtr)
define|#
directive|define
name|HUF_DECODE_SYMBOLX2_2
parameter_list|(
name|ptr
parameter_list|,
name|DStreamPtr
parameter_list|)
define|\
value|if (MEM_64bits()) \         HUF_DECODE_SYMBOLX2_0(ptr, DStreamPtr)
specifier|static
specifier|inline
name|size_t
name|HUF_decodeStreamX2
parameter_list|(
name|BYTE
modifier|*
name|p
parameter_list|,
name|BIT_DStream_t
modifier|*
specifier|const
name|bitDPtr
parameter_list|,
name|BYTE
modifier|*
specifier|const
name|pEnd
parameter_list|,
specifier|const
name|HUF_DEltX2
modifier|*
specifier|const
name|dt
parameter_list|,
specifier|const
name|U32
name|dtLog
parameter_list|)
block|{
name|BYTE
modifier|*
specifier|const
name|pStart
init|=
name|p
decl_stmt|;
comment|/* up to 4 symbols at a time */
while|while
condition|(
operator|(
name|BIT_reloadDStream
argument_list|(
name|bitDPtr
argument_list|)
operator|==
name|BIT_DStream_unfinished
operator|)
operator|&&
operator|(
name|p
operator|<=
name|pEnd
operator|-
literal|4
operator|)
condition|)
block|{
name|HUF_DECODE_SYMBOLX2_2
argument_list|(
name|p
argument_list|,
name|bitDPtr
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX2_1
argument_list|(
name|p
argument_list|,
name|bitDPtr
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX2_2
argument_list|(
name|p
argument_list|,
name|bitDPtr
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX2_0
argument_list|(
name|p
argument_list|,
name|bitDPtr
argument_list|)
expr_stmt|;
block|}
comment|/* closer to the end */
while|while
condition|(
operator|(
name|BIT_reloadDStream
argument_list|(
name|bitDPtr
argument_list|)
operator|==
name|BIT_DStream_unfinished
operator|)
operator|&&
operator|(
name|p
operator|<
name|pEnd
operator|)
condition|)
name|HUF_DECODE_SYMBOLX2_0
argument_list|(
name|p
argument_list|,
name|bitDPtr
argument_list|)
expr_stmt|;
comment|/* no more data to retrieve from bitstream, hence no need to reload */
while|while
condition|(
name|p
operator|<
name|pEnd
condition|)
name|HUF_DECODE_SYMBOLX2_0
argument_list|(
name|p
argument_list|,
name|bitDPtr
argument_list|)
expr_stmt|;
return|return
name|pEnd
operator|-
name|pStart
return|;
block|}
specifier|static
name|size_t
name|HUF_decompress4X2_usingDTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|U16
modifier|*
name|DTable
parameter_list|)
block|{
if|if
condition|(
name|cSrcSize
operator|<
literal|10
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* strict minimum : jump table + 1 byte per stream */
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|cSrc
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|ostart
init|=
operator|(
name|BYTE
operator|*
operator|)
name|dst
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|oend
init|=
name|ostart
operator|+
name|dstSize
decl_stmt|;
specifier|const
name|void
modifier|*
specifier|const
name|dtPtr
init|=
name|DTable
decl_stmt|;
specifier|const
name|HUF_DEltX2
modifier|*
specifier|const
name|dt
init|=
operator|(
operator|(
specifier|const
name|HUF_DEltX2
operator|*
operator|)
name|dtPtr
operator|)
operator|+
literal|1
decl_stmt|;
specifier|const
name|U32
name|dtLog
init|=
name|DTable
index|[
literal|0
index|]
decl_stmt|;
name|size_t
name|errorCode
decl_stmt|;
comment|/* Init */
name|BIT_DStream_t
name|bitD1
decl_stmt|;
name|BIT_DStream_t
name|bitD2
decl_stmt|;
name|BIT_DStream_t
name|bitD3
decl_stmt|;
name|BIT_DStream_t
name|bitD4
decl_stmt|;
specifier|const
name|size_t
name|length1
init|=
name|MEM_readLE16
argument_list|(
name|istart
argument_list|)
decl_stmt|;
specifier|const
name|size_t
name|length2
init|=
name|MEM_readLE16
argument_list|(
name|istart
operator|+
literal|2
argument_list|)
decl_stmt|;
specifier|const
name|size_t
name|length3
init|=
name|MEM_readLE16
argument_list|(
name|istart
operator|+
literal|4
argument_list|)
decl_stmt|;
name|size_t
name|length4
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart1
init|=
name|istart
operator|+
literal|6
decl_stmt|;
comment|/* jumpTable */
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart2
init|=
name|istart1
operator|+
name|length1
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart3
init|=
name|istart2
operator|+
name|length2
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart4
init|=
name|istart3
operator|+
name|length3
decl_stmt|;
specifier|const
name|size_t
name|segmentSize
init|=
operator|(
name|dstSize
operator|+
literal|3
operator|)
operator|/
literal|4
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|opStart2
init|=
name|ostart
operator|+
name|segmentSize
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|opStart3
init|=
name|opStart2
operator|+
name|segmentSize
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|opStart4
init|=
name|opStart3
operator|+
name|segmentSize
decl_stmt|;
name|BYTE
modifier|*
name|op1
init|=
name|ostart
decl_stmt|;
name|BYTE
modifier|*
name|op2
init|=
name|opStart2
decl_stmt|;
name|BYTE
modifier|*
name|op3
init|=
name|opStart3
decl_stmt|;
name|BYTE
modifier|*
name|op4
init|=
name|opStart4
decl_stmt|;
name|U32
name|endSignal
decl_stmt|;
name|length4
operator|=
name|cSrcSize
operator|-
operator|(
name|length1
operator|+
name|length2
operator|+
name|length3
operator|+
literal|6
operator|)
expr_stmt|;
if|if
condition|(
name|length4
operator|>
name|cSrcSize
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* overflow */
name|errorCode
operator|=
name|BIT_initDStream
argument_list|(
operator|&
name|bitD1
argument_list|,
name|istart1
argument_list|,
name|length1
argument_list|)
expr_stmt|;
if|if
condition|(
name|HUF_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
name|errorCode
operator|=
name|BIT_initDStream
argument_list|(
operator|&
name|bitD2
argument_list|,
name|istart2
argument_list|,
name|length2
argument_list|)
expr_stmt|;
if|if
condition|(
name|HUF_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
name|errorCode
operator|=
name|BIT_initDStream
argument_list|(
operator|&
name|bitD3
argument_list|,
name|istart3
argument_list|,
name|length3
argument_list|)
expr_stmt|;
if|if
condition|(
name|HUF_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
name|errorCode
operator|=
name|BIT_initDStream
argument_list|(
operator|&
name|bitD4
argument_list|,
name|istart4
argument_list|,
name|length4
argument_list|)
expr_stmt|;
if|if
condition|(
name|HUF_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
comment|/* 16-32 symbols per loop (4-8 symbols per stream) */
name|endSignal
operator|=
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD1
argument_list|)
operator||
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD2
argument_list|)
operator||
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD3
argument_list|)
operator||
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD4
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|(
name|endSignal
operator|==
name|BIT_DStream_unfinished
operator|)
operator|&&
operator|(
name|op4
operator|<
operator|(
name|oend
operator|-
literal|7
operator|)
operator|)
condition|;
control|)
block|{
name|HUF_DECODE_SYMBOLX2_2
argument_list|(
name|op1
argument_list|,
operator|&
name|bitD1
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX2_2
argument_list|(
name|op2
argument_list|,
operator|&
name|bitD2
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX2_2
argument_list|(
name|op3
argument_list|,
operator|&
name|bitD3
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX2_2
argument_list|(
name|op4
argument_list|,
operator|&
name|bitD4
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX2_1
argument_list|(
name|op1
argument_list|,
operator|&
name|bitD1
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX2_1
argument_list|(
name|op2
argument_list|,
operator|&
name|bitD2
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX2_1
argument_list|(
name|op3
argument_list|,
operator|&
name|bitD3
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX2_1
argument_list|(
name|op4
argument_list|,
operator|&
name|bitD4
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX2_2
argument_list|(
name|op1
argument_list|,
operator|&
name|bitD1
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX2_2
argument_list|(
name|op2
argument_list|,
operator|&
name|bitD2
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX2_2
argument_list|(
name|op3
argument_list|,
operator|&
name|bitD3
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX2_2
argument_list|(
name|op4
argument_list|,
operator|&
name|bitD4
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX2_0
argument_list|(
name|op1
argument_list|,
operator|&
name|bitD1
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX2_0
argument_list|(
name|op2
argument_list|,
operator|&
name|bitD2
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX2_0
argument_list|(
name|op3
argument_list|,
operator|&
name|bitD3
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX2_0
argument_list|(
name|op4
argument_list|,
operator|&
name|bitD4
argument_list|)
expr_stmt|;
name|endSignal
operator|=
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD1
argument_list|)
operator||
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD2
argument_list|)
operator||
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD3
argument_list|)
operator||
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD4
argument_list|)
expr_stmt|;
block|}
comment|/* check corruption */
if|if
condition|(
name|op1
operator|>
name|opStart2
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
if|if
condition|(
name|op2
operator|>
name|opStart3
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
if|if
condition|(
name|op3
operator|>
name|opStart4
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* note : op4 supposed already verified within main loop */
comment|/* finish bitStreams one by one */
name|HUF_decodeStreamX2
argument_list|(
name|op1
argument_list|,
operator|&
name|bitD1
argument_list|,
name|opStart2
argument_list|,
name|dt
argument_list|,
name|dtLog
argument_list|)
expr_stmt|;
name|HUF_decodeStreamX2
argument_list|(
name|op2
argument_list|,
operator|&
name|bitD2
argument_list|,
name|opStart3
argument_list|,
name|dt
argument_list|,
name|dtLog
argument_list|)
expr_stmt|;
name|HUF_decodeStreamX2
argument_list|(
name|op3
argument_list|,
operator|&
name|bitD3
argument_list|,
name|opStart4
argument_list|,
name|dt
argument_list|,
name|dtLog
argument_list|)
expr_stmt|;
name|HUF_decodeStreamX2
argument_list|(
name|op4
argument_list|,
operator|&
name|bitD4
argument_list|,
name|oend
argument_list|,
name|dt
argument_list|,
name|dtLog
argument_list|)
expr_stmt|;
comment|/* check */
name|endSignal
operator|=
name|BIT_endOfDStream
argument_list|(
operator|&
name|bitD1
argument_list|)
operator|&
name|BIT_endOfDStream
argument_list|(
operator|&
name|bitD2
argument_list|)
operator|&
name|BIT_endOfDStream
argument_list|(
operator|&
name|bitD3
argument_list|)
operator|&
name|BIT_endOfDStream
argument_list|(
operator|&
name|bitD4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|endSignal
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* decoded size */
return|return
name|dstSize
return|;
block|}
block|}
specifier|static
name|size_t
name|HUF_decompress4X2
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
block|{
name|HUF_CREATE_STATIC_DTABLEX2
argument_list|(
name|DTable
argument_list|,
name|HUF_MAX_TABLELOG
argument_list|)
expr_stmt|;
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|cSrc
decl_stmt|;
name|size_t
name|errorCode
decl_stmt|;
name|errorCode
operator|=
name|HUF_readDTableX2
argument_list|(
name|DTable
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|HUF_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
if|if
condition|(
name|errorCode
operator|>=
name|cSrcSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|ip
operator|+=
name|errorCode
expr_stmt|;
name|cSrcSize
operator|-=
name|errorCode
expr_stmt|;
return|return
name|HUF_decompress4X2_usingDTable
argument_list|(
name|dst
argument_list|,
name|dstSize
argument_list|,
name|ip
argument_list|,
name|cSrcSize
argument_list|,
name|DTable
argument_list|)
return|;
block|}
comment|/***************************/
comment|/* double-symbols decoding */
comment|/***************************/
specifier|static
name|void
name|HUF_fillDTableX4Level2
parameter_list|(
name|HUF_DEltX4
modifier|*
name|DTable
parameter_list|,
name|U32
name|sizeLog
parameter_list|,
specifier|const
name|U32
name|consumed
parameter_list|,
specifier|const
name|U32
modifier|*
name|rankValOrigin
parameter_list|,
specifier|const
name|int
name|minWeight
parameter_list|,
specifier|const
name|sortedSymbol_t
modifier|*
name|sortedSymbols
parameter_list|,
specifier|const
name|U32
name|sortedListSize
parameter_list|,
name|U32
name|nbBitsBaseline
parameter_list|,
name|U16
name|baseSeq
parameter_list|)
block|{
name|HUF_DEltX4
name|DElt
decl_stmt|;
name|U32
name|rankVal
index|[
name|HUF_ABSOLUTEMAX_TABLELOG
operator|+
literal|1
index|]
decl_stmt|;
name|U32
name|s
decl_stmt|;
comment|/* get pre-calculated rankVal */
name|memcpy
argument_list|(
name|rankVal
argument_list|,
name|rankValOrigin
argument_list|,
sizeof|sizeof
argument_list|(
name|rankVal
argument_list|)
argument_list|)
expr_stmt|;
comment|/* fill skipped values */
if|if
condition|(
name|minWeight
operator|>
literal|1
condition|)
block|{
name|U32
name|i
decl_stmt|,
name|skipSize
init|=
name|rankVal
index|[
name|minWeight
index|]
decl_stmt|;
name|MEM_writeLE16
argument_list|(
operator|&
operator|(
name|DElt
operator|.
name|sequence
operator|)
argument_list|,
name|baseSeq
argument_list|)
expr_stmt|;
name|DElt
operator|.
name|nbBits
operator|=
call|(
name|BYTE
call|)
argument_list|(
name|consumed
argument_list|)
expr_stmt|;
name|DElt
operator|.
name|length
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|skipSize
condition|;
name|i
operator|++
control|)
name|DTable
index|[
name|i
index|]
operator|=
name|DElt
expr_stmt|;
block|}
comment|/* fill DTable */
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|sortedListSize
condition|;
name|s
operator|++
control|)
comment|/* note : sortedSymbols already skipped */
block|{
specifier|const
name|U32
name|symbol
init|=
name|sortedSymbols
index|[
name|s
index|]
operator|.
name|symbol
decl_stmt|;
specifier|const
name|U32
name|weight
init|=
name|sortedSymbols
index|[
name|s
index|]
operator|.
name|weight
decl_stmt|;
specifier|const
name|U32
name|nbBits
init|=
name|nbBitsBaseline
operator|-
name|weight
decl_stmt|;
specifier|const
name|U32
name|length
init|=
literal|1
operator|<<
operator|(
name|sizeLog
operator|-
name|nbBits
operator|)
decl_stmt|;
specifier|const
name|U32
name|start
init|=
name|rankVal
index|[
name|weight
index|]
decl_stmt|;
name|U32
name|i
init|=
name|start
decl_stmt|;
specifier|const
name|U32
name|end
init|=
name|start
operator|+
name|length
decl_stmt|;
name|MEM_writeLE16
argument_list|(
operator|&
operator|(
name|DElt
operator|.
name|sequence
operator|)
argument_list|,
call|(
name|U16
call|)
argument_list|(
name|baseSeq
operator|+
operator|(
name|symbol
operator|<<
literal|8
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|DElt
operator|.
name|nbBits
operator|=
call|(
name|BYTE
call|)
argument_list|(
name|nbBits
operator|+
name|consumed
argument_list|)
expr_stmt|;
name|DElt
operator|.
name|length
operator|=
literal|2
expr_stmt|;
do|do
block|{
name|DTable
index|[
name|i
operator|++
index|]
operator|=
name|DElt
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|<
name|end
condition|)
do|;
comment|/* since length>= 1 */
name|rankVal
index|[
name|weight
index|]
operator|+=
name|length
expr_stmt|;
block|}
block|}
typedef|typedef
name|U32
name|rankVal_t
index|[
name|HUF_ABSOLUTEMAX_TABLELOG
index|]
index|[
name|HUF_ABSOLUTEMAX_TABLELOG
operator|+
literal|1
index|]
typedef|;
specifier|static
name|void
name|HUF_fillDTableX4
parameter_list|(
name|HUF_DEltX4
modifier|*
name|DTable
parameter_list|,
specifier|const
name|U32
name|targetLog
parameter_list|,
specifier|const
name|sortedSymbol_t
modifier|*
name|sortedList
parameter_list|,
specifier|const
name|U32
name|sortedListSize
parameter_list|,
specifier|const
name|U32
modifier|*
name|rankStart
parameter_list|,
name|rankVal_t
name|rankValOrigin
parameter_list|,
specifier|const
name|U32
name|maxWeight
parameter_list|,
specifier|const
name|U32
name|nbBitsBaseline
parameter_list|)
block|{
name|U32
name|rankVal
index|[
name|HUF_ABSOLUTEMAX_TABLELOG
operator|+
literal|1
index|]
decl_stmt|;
specifier|const
name|int
name|scaleLog
init|=
name|nbBitsBaseline
operator|-
name|targetLog
decl_stmt|;
comment|/* note : targetLog>= srcLog, hence scaleLog<= 1 */
specifier|const
name|U32
name|minBits
init|=
name|nbBitsBaseline
operator|-
name|maxWeight
decl_stmt|;
name|U32
name|s
decl_stmt|;
name|memcpy
argument_list|(
name|rankVal
argument_list|,
name|rankValOrigin
argument_list|,
sizeof|sizeof
argument_list|(
name|rankVal
argument_list|)
argument_list|)
expr_stmt|;
comment|/* fill DTable */
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|sortedListSize
condition|;
name|s
operator|++
control|)
block|{
specifier|const
name|U16
name|symbol
init|=
name|sortedList
index|[
name|s
index|]
operator|.
name|symbol
decl_stmt|;
specifier|const
name|U32
name|weight
init|=
name|sortedList
index|[
name|s
index|]
operator|.
name|weight
decl_stmt|;
specifier|const
name|U32
name|nbBits
init|=
name|nbBitsBaseline
operator|-
name|weight
decl_stmt|;
specifier|const
name|U32
name|start
init|=
name|rankVal
index|[
name|weight
index|]
decl_stmt|;
specifier|const
name|U32
name|length
init|=
literal|1
operator|<<
operator|(
name|targetLog
operator|-
name|nbBits
operator|)
decl_stmt|;
if|if
condition|(
name|targetLog
operator|-
name|nbBits
operator|>=
name|minBits
condition|)
comment|/* enough room for a second symbol */
block|{
name|U32
name|sortedRank
decl_stmt|;
name|int
name|minWeight
init|=
name|nbBits
operator|+
name|scaleLog
decl_stmt|;
if|if
condition|(
name|minWeight
operator|<
literal|1
condition|)
name|minWeight
operator|=
literal|1
expr_stmt|;
name|sortedRank
operator|=
name|rankStart
index|[
name|minWeight
index|]
expr_stmt|;
name|HUF_fillDTableX4Level2
argument_list|(
name|DTable
operator|+
name|start
argument_list|,
name|targetLog
operator|-
name|nbBits
argument_list|,
name|nbBits
argument_list|,
name|rankValOrigin
index|[
name|nbBits
index|]
argument_list|,
name|minWeight
argument_list|,
name|sortedList
operator|+
name|sortedRank
argument_list|,
name|sortedListSize
operator|-
name|sortedRank
argument_list|,
name|nbBitsBaseline
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|U32
name|i
decl_stmt|;
specifier|const
name|U32
name|end
init|=
name|start
operator|+
name|length
decl_stmt|;
name|HUF_DEltX4
name|DElt
decl_stmt|;
name|MEM_writeLE16
argument_list|(
operator|&
operator|(
name|DElt
operator|.
name|sequence
operator|)
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|DElt
operator|.
name|nbBits
operator|=
call|(
name|BYTE
call|)
argument_list|(
name|nbBits
argument_list|)
expr_stmt|;
name|DElt
operator|.
name|length
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
name|DTable
index|[
name|i
index|]
operator|=
name|DElt
expr_stmt|;
block|}
name|rankVal
index|[
name|weight
index|]
operator|+=
name|length
expr_stmt|;
block|}
block|}
specifier|static
name|size_t
name|HUF_readDTableX4
parameter_list|(
name|U32
modifier|*
name|DTable
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
name|BYTE
name|weightList
index|[
name|HUF_MAX_SYMBOL_VALUE
operator|+
literal|1
index|]
decl_stmt|;
name|sortedSymbol_t
name|sortedSymbol
index|[
name|HUF_MAX_SYMBOL_VALUE
operator|+
literal|1
index|]
decl_stmt|;
name|U32
name|rankStats
index|[
name|HUF_ABSOLUTEMAX_TABLELOG
operator|+
literal|1
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|U32
name|rankStart0
index|[
name|HUF_ABSOLUTEMAX_TABLELOG
operator|+
literal|2
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|U32
modifier|*
specifier|const
name|rankStart
init|=
name|rankStart0
operator|+
literal|1
decl_stmt|;
name|rankVal_t
name|rankVal
decl_stmt|;
name|U32
name|tableLog
decl_stmt|,
name|maxW
decl_stmt|,
name|sizeOfSort
decl_stmt|,
name|nbSymbols
decl_stmt|;
specifier|const
name|U32
name|memLog
init|=
name|DTable
index|[
literal|0
index|]
decl_stmt|;
name|size_t
name|iSize
decl_stmt|;
name|void
modifier|*
name|dtPtr
init|=
name|DTable
decl_stmt|;
name|HUF_DEltX4
modifier|*
specifier|const
name|dt
init|=
operator|(
operator|(
name|HUF_DEltX4
operator|*
operator|)
name|dtPtr
operator|)
operator|+
literal|1
decl_stmt|;
name|HUF_STATIC_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|HUF_DEltX4
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if compilation fails here, assertion is false */
if|if
condition|(
name|memLog
operator|>
name|HUF_ABSOLUTEMAX_TABLELOG
condition|)
return|return
name|ERROR
argument_list|(
name|tableLog_tooLarge
argument_list|)
return|;
comment|//memset(weightList, 0, sizeof(weightList));   /* is not necessary, even though some analyzer complain ... */
name|iSize
operator|=
name|HUF_readStats
argument_list|(
name|weightList
argument_list|,
name|HUF_MAX_SYMBOL_VALUE
operator|+
literal|1
argument_list|,
name|rankStats
argument_list|,
operator|&
name|nbSymbols
argument_list|,
operator|&
name|tableLog
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|HUF_isError
argument_list|(
name|iSize
argument_list|)
condition|)
return|return
name|iSize
return|;
comment|/* check result */
if|if
condition|(
name|tableLog
operator|>
name|memLog
condition|)
return|return
name|ERROR
argument_list|(
name|tableLog_tooLarge
argument_list|)
return|;
comment|/* DTable can't fit code depth */
comment|/* find maxWeight */
for|for
control|(
name|maxW
operator|=
name|tableLog
init|;
name|rankStats
index|[
name|maxW
index|]
operator|==
literal|0
condition|;
name|maxW
operator|--
control|)
block|{
if|if
condition|(
operator|!
name|maxW
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
block|}
comment|/* necessarily finds a solution before maxW==0 */
comment|/* Get start index of each weight */
block|{
name|U32
name|w
decl_stmt|,
name|nextRankStart
init|=
literal|0
decl_stmt|;
for|for
control|(
name|w
operator|=
literal|1
init|;
name|w
operator|<=
name|maxW
condition|;
name|w
operator|++
control|)
block|{
name|U32
name|current
init|=
name|nextRankStart
decl_stmt|;
name|nextRankStart
operator|+=
name|rankStats
index|[
name|w
index|]
expr_stmt|;
name|rankStart
index|[
name|w
index|]
operator|=
name|current
expr_stmt|;
block|}
name|rankStart
index|[
literal|0
index|]
operator|=
name|nextRankStart
expr_stmt|;
comment|/* put all 0w symbols at the end of sorted list*/
name|sizeOfSort
operator|=
name|nextRankStart
expr_stmt|;
block|}
comment|/* sort symbols by weight */
block|{
name|U32
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|nbSymbols
condition|;
name|s
operator|++
control|)
block|{
name|U32
name|w
init|=
name|weightList
index|[
name|s
index|]
decl_stmt|;
name|U32
name|r
init|=
name|rankStart
index|[
name|w
index|]
operator|++
decl_stmt|;
name|sortedSymbol
index|[
name|r
index|]
operator|.
name|symbol
operator|=
operator|(
name|BYTE
operator|)
name|s
expr_stmt|;
name|sortedSymbol
index|[
name|r
index|]
operator|.
name|weight
operator|=
operator|(
name|BYTE
operator|)
name|w
expr_stmt|;
block|}
name|rankStart
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* forget 0w symbols; this is beginning of weight(1) */
block|}
comment|/* Build rankVal */
block|{
specifier|const
name|U32
name|minBits
init|=
name|tableLog
operator|+
literal|1
operator|-
name|maxW
decl_stmt|;
name|U32
name|nextRankVal
init|=
literal|0
decl_stmt|;
name|U32
name|w
decl_stmt|,
name|consumed
decl_stmt|;
specifier|const
name|int
name|rescale
init|=
operator|(
name|memLog
operator|-
name|tableLog
operator|)
operator|-
literal|1
decl_stmt|;
comment|/* tableLog<= memLog */
name|U32
modifier|*
name|rankVal0
init|=
name|rankVal
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|w
operator|=
literal|1
init|;
name|w
operator|<=
name|maxW
condition|;
name|w
operator|++
control|)
block|{
name|U32
name|current
init|=
name|nextRankVal
decl_stmt|;
name|nextRankVal
operator|+=
name|rankStats
index|[
name|w
index|]
operator|<<
operator|(
name|w
operator|+
name|rescale
operator|)
expr_stmt|;
name|rankVal0
index|[
name|w
index|]
operator|=
name|current
expr_stmt|;
block|}
for|for
control|(
name|consumed
operator|=
name|minBits
init|;
name|consumed
operator|<=
name|memLog
operator|-
name|minBits
condition|;
name|consumed
operator|++
control|)
block|{
name|U32
modifier|*
name|rankValPtr
init|=
name|rankVal
index|[
name|consumed
index|]
decl_stmt|;
for|for
control|(
name|w
operator|=
literal|1
init|;
name|w
operator|<=
name|maxW
condition|;
name|w
operator|++
control|)
block|{
name|rankValPtr
index|[
name|w
index|]
operator|=
name|rankVal0
index|[
name|w
index|]
operator|>>
name|consumed
expr_stmt|;
block|}
block|}
block|}
name|HUF_fillDTableX4
argument_list|(
name|dt
argument_list|,
name|memLog
argument_list|,
name|sortedSymbol
argument_list|,
name|sizeOfSort
argument_list|,
name|rankStart0
argument_list|,
name|rankVal
argument_list|,
name|maxW
argument_list|,
name|tableLog
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|iSize
return|;
block|}
specifier|static
name|U32
name|HUF_decodeSymbolX4
parameter_list|(
name|void
modifier|*
name|op
parameter_list|,
name|BIT_DStream_t
modifier|*
name|DStream
parameter_list|,
specifier|const
name|HUF_DEltX4
modifier|*
name|dt
parameter_list|,
specifier|const
name|U32
name|dtLog
parameter_list|)
block|{
specifier|const
name|size_t
name|val
init|=
name|BIT_lookBitsFast
argument_list|(
name|DStream
argument_list|,
name|dtLog
argument_list|)
decl_stmt|;
comment|/* note : dtLog>= 1 */
name|memcpy
argument_list|(
name|op
argument_list|,
name|dt
operator|+
name|val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|BIT_skipBits
argument_list|(
name|DStream
argument_list|,
name|dt
index|[
name|val
index|]
operator|.
name|nbBits
argument_list|)
expr_stmt|;
return|return
name|dt
index|[
name|val
index|]
operator|.
name|length
return|;
block|}
specifier|static
name|U32
name|HUF_decodeLastSymbolX4
parameter_list|(
name|void
modifier|*
name|op
parameter_list|,
name|BIT_DStream_t
modifier|*
name|DStream
parameter_list|,
specifier|const
name|HUF_DEltX4
modifier|*
name|dt
parameter_list|,
specifier|const
name|U32
name|dtLog
parameter_list|)
block|{
specifier|const
name|size_t
name|val
init|=
name|BIT_lookBitsFast
argument_list|(
name|DStream
argument_list|,
name|dtLog
argument_list|)
decl_stmt|;
comment|/* note : dtLog>= 1 */
name|memcpy
argument_list|(
name|op
argument_list|,
name|dt
operator|+
name|val
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|dt
index|[
name|val
index|]
operator|.
name|length
operator|==
literal|1
condition|)
name|BIT_skipBits
argument_list|(
name|DStream
argument_list|,
name|dt
index|[
name|val
index|]
operator|.
name|nbBits
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|DStream
operator|->
name|bitsConsumed
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|DStream
operator|->
name|bitContainer
argument_list|)
operator|*
literal|8
operator|)
condition|)
block|{
name|BIT_skipBits
argument_list|(
name|DStream
argument_list|,
name|dt
index|[
name|val
index|]
operator|.
name|nbBits
argument_list|)
expr_stmt|;
if|if
condition|(
name|DStream
operator|->
name|bitsConsumed
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|DStream
operator|->
name|bitContainer
argument_list|)
operator|*
literal|8
operator|)
condition|)
name|DStream
operator|->
name|bitsConsumed
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|DStream
operator|->
name|bitContainer
argument_list|)
operator|*
literal|8
operator|)
expr_stmt|;
comment|/* ugly hack; works only because it's the last symbol. Note : can't easily extract nbBits from just this symbol */
block|}
block|}
return|return
literal|1
return|;
block|}
define|#
directive|define
name|HUF_DECODE_SYMBOLX4_0
parameter_list|(
name|ptr
parameter_list|,
name|DStreamPtr
parameter_list|)
define|\
value|ptr += HUF_decodeSymbolX4(ptr, DStreamPtr, dt, dtLog)
define|#
directive|define
name|HUF_DECODE_SYMBOLX4_1
parameter_list|(
name|ptr
parameter_list|,
name|DStreamPtr
parameter_list|)
define|\
value|if (MEM_64bits() || (HUF_MAX_TABLELOG<=12)) \         ptr += HUF_decodeSymbolX4(ptr, DStreamPtr, dt, dtLog)
define|#
directive|define
name|HUF_DECODE_SYMBOLX4_2
parameter_list|(
name|ptr
parameter_list|,
name|DStreamPtr
parameter_list|)
define|\
value|if (MEM_64bits()) \         ptr += HUF_decodeSymbolX4(ptr, DStreamPtr, dt, dtLog)
specifier|static
specifier|inline
name|size_t
name|HUF_decodeStreamX4
parameter_list|(
name|BYTE
modifier|*
name|p
parameter_list|,
name|BIT_DStream_t
modifier|*
name|bitDPtr
parameter_list|,
name|BYTE
modifier|*
specifier|const
name|pEnd
parameter_list|,
specifier|const
name|HUF_DEltX4
modifier|*
specifier|const
name|dt
parameter_list|,
specifier|const
name|U32
name|dtLog
parameter_list|)
block|{
name|BYTE
modifier|*
specifier|const
name|pStart
init|=
name|p
decl_stmt|;
comment|/* up to 8 symbols at a time */
while|while
condition|(
operator|(
name|BIT_reloadDStream
argument_list|(
name|bitDPtr
argument_list|)
operator|==
name|BIT_DStream_unfinished
operator|)
operator|&&
operator|(
name|p
operator|<
name|pEnd
operator|-
literal|7
operator|)
condition|)
block|{
name|HUF_DECODE_SYMBOLX4_2
argument_list|(
name|p
argument_list|,
name|bitDPtr
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX4_1
argument_list|(
name|p
argument_list|,
name|bitDPtr
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX4_2
argument_list|(
name|p
argument_list|,
name|bitDPtr
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX4_0
argument_list|(
name|p
argument_list|,
name|bitDPtr
argument_list|)
expr_stmt|;
block|}
comment|/* closer to the end */
while|while
condition|(
operator|(
name|BIT_reloadDStream
argument_list|(
name|bitDPtr
argument_list|)
operator|==
name|BIT_DStream_unfinished
operator|)
operator|&&
operator|(
name|p
operator|<=
name|pEnd
operator|-
literal|2
operator|)
condition|)
name|HUF_DECODE_SYMBOLX4_0
argument_list|(
name|p
argument_list|,
name|bitDPtr
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|<=
name|pEnd
operator|-
literal|2
condition|)
name|HUF_DECODE_SYMBOLX4_0
argument_list|(
name|p
argument_list|,
name|bitDPtr
argument_list|)
expr_stmt|;
comment|/* no need to reload : reached the end of DStream */
if|if
condition|(
name|p
operator|<
name|pEnd
condition|)
name|p
operator|+=
name|HUF_decodeLastSymbolX4
argument_list|(
name|p
argument_list|,
name|bitDPtr
argument_list|,
name|dt
argument_list|,
name|dtLog
argument_list|)
expr_stmt|;
return|return
name|p
operator|-
name|pStart
return|;
block|}
specifier|static
name|size_t
name|HUF_decompress4X4_usingDTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|U32
modifier|*
name|DTable
parameter_list|)
block|{
if|if
condition|(
name|cSrcSize
operator|<
literal|10
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* strict minimum : jump table + 1 byte per stream */
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|cSrc
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|ostart
init|=
operator|(
name|BYTE
operator|*
operator|)
name|dst
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|oend
init|=
name|ostart
operator|+
name|dstSize
decl_stmt|;
specifier|const
name|void
modifier|*
specifier|const
name|dtPtr
init|=
name|DTable
decl_stmt|;
specifier|const
name|HUF_DEltX4
modifier|*
specifier|const
name|dt
init|=
operator|(
operator|(
specifier|const
name|HUF_DEltX4
operator|*
operator|)
name|dtPtr
operator|)
operator|+
literal|1
decl_stmt|;
specifier|const
name|U32
name|dtLog
init|=
name|DTable
index|[
literal|0
index|]
decl_stmt|;
name|size_t
name|errorCode
decl_stmt|;
comment|/* Init */
name|BIT_DStream_t
name|bitD1
decl_stmt|;
name|BIT_DStream_t
name|bitD2
decl_stmt|;
name|BIT_DStream_t
name|bitD3
decl_stmt|;
name|BIT_DStream_t
name|bitD4
decl_stmt|;
specifier|const
name|size_t
name|length1
init|=
name|MEM_readLE16
argument_list|(
name|istart
argument_list|)
decl_stmt|;
specifier|const
name|size_t
name|length2
init|=
name|MEM_readLE16
argument_list|(
name|istart
operator|+
literal|2
argument_list|)
decl_stmt|;
specifier|const
name|size_t
name|length3
init|=
name|MEM_readLE16
argument_list|(
name|istart
operator|+
literal|4
argument_list|)
decl_stmt|;
name|size_t
name|length4
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart1
init|=
name|istart
operator|+
literal|6
decl_stmt|;
comment|/* jumpTable */
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart2
init|=
name|istart1
operator|+
name|length1
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart3
init|=
name|istart2
operator|+
name|length2
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart4
init|=
name|istart3
operator|+
name|length3
decl_stmt|;
specifier|const
name|size_t
name|segmentSize
init|=
operator|(
name|dstSize
operator|+
literal|3
operator|)
operator|/
literal|4
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|opStart2
init|=
name|ostart
operator|+
name|segmentSize
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|opStart3
init|=
name|opStart2
operator|+
name|segmentSize
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|opStart4
init|=
name|opStart3
operator|+
name|segmentSize
decl_stmt|;
name|BYTE
modifier|*
name|op1
init|=
name|ostart
decl_stmt|;
name|BYTE
modifier|*
name|op2
init|=
name|opStart2
decl_stmt|;
name|BYTE
modifier|*
name|op3
init|=
name|opStart3
decl_stmt|;
name|BYTE
modifier|*
name|op4
init|=
name|opStart4
decl_stmt|;
name|U32
name|endSignal
decl_stmt|;
name|length4
operator|=
name|cSrcSize
operator|-
operator|(
name|length1
operator|+
name|length2
operator|+
name|length3
operator|+
literal|6
operator|)
expr_stmt|;
if|if
condition|(
name|length4
operator|>
name|cSrcSize
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* overflow */
name|errorCode
operator|=
name|BIT_initDStream
argument_list|(
operator|&
name|bitD1
argument_list|,
name|istart1
argument_list|,
name|length1
argument_list|)
expr_stmt|;
if|if
condition|(
name|HUF_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
name|errorCode
operator|=
name|BIT_initDStream
argument_list|(
operator|&
name|bitD2
argument_list|,
name|istart2
argument_list|,
name|length2
argument_list|)
expr_stmt|;
if|if
condition|(
name|HUF_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
name|errorCode
operator|=
name|BIT_initDStream
argument_list|(
operator|&
name|bitD3
argument_list|,
name|istart3
argument_list|,
name|length3
argument_list|)
expr_stmt|;
if|if
condition|(
name|HUF_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
name|errorCode
operator|=
name|BIT_initDStream
argument_list|(
operator|&
name|bitD4
argument_list|,
name|istart4
argument_list|,
name|length4
argument_list|)
expr_stmt|;
if|if
condition|(
name|HUF_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
comment|/* 16-32 symbols per loop (4-8 symbols per stream) */
name|endSignal
operator|=
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD1
argument_list|)
operator||
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD2
argument_list|)
operator||
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD3
argument_list|)
operator||
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD4
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|(
name|endSignal
operator|==
name|BIT_DStream_unfinished
operator|)
operator|&&
operator|(
name|op4
operator|<
operator|(
name|oend
operator|-
literal|7
operator|)
operator|)
condition|;
control|)
block|{
name|HUF_DECODE_SYMBOLX4_2
argument_list|(
name|op1
argument_list|,
operator|&
name|bitD1
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX4_2
argument_list|(
name|op2
argument_list|,
operator|&
name|bitD2
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX4_2
argument_list|(
name|op3
argument_list|,
operator|&
name|bitD3
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX4_2
argument_list|(
name|op4
argument_list|,
operator|&
name|bitD4
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX4_1
argument_list|(
name|op1
argument_list|,
operator|&
name|bitD1
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX4_1
argument_list|(
name|op2
argument_list|,
operator|&
name|bitD2
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX4_1
argument_list|(
name|op3
argument_list|,
operator|&
name|bitD3
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX4_1
argument_list|(
name|op4
argument_list|,
operator|&
name|bitD4
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX4_2
argument_list|(
name|op1
argument_list|,
operator|&
name|bitD1
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX4_2
argument_list|(
name|op2
argument_list|,
operator|&
name|bitD2
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX4_2
argument_list|(
name|op3
argument_list|,
operator|&
name|bitD3
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX4_2
argument_list|(
name|op4
argument_list|,
operator|&
name|bitD4
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX4_0
argument_list|(
name|op1
argument_list|,
operator|&
name|bitD1
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX4_0
argument_list|(
name|op2
argument_list|,
operator|&
name|bitD2
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX4_0
argument_list|(
name|op3
argument_list|,
operator|&
name|bitD3
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX4_0
argument_list|(
name|op4
argument_list|,
operator|&
name|bitD4
argument_list|)
expr_stmt|;
name|endSignal
operator|=
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD1
argument_list|)
operator||
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD2
argument_list|)
operator||
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD3
argument_list|)
operator||
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD4
argument_list|)
expr_stmt|;
block|}
comment|/* check corruption */
if|if
condition|(
name|op1
operator|>
name|opStart2
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
if|if
condition|(
name|op2
operator|>
name|opStart3
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
if|if
condition|(
name|op3
operator|>
name|opStart4
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* note : op4 supposed already verified within main loop */
comment|/* finish bitStreams one by one */
name|HUF_decodeStreamX4
argument_list|(
name|op1
argument_list|,
operator|&
name|bitD1
argument_list|,
name|opStart2
argument_list|,
name|dt
argument_list|,
name|dtLog
argument_list|)
expr_stmt|;
name|HUF_decodeStreamX4
argument_list|(
name|op2
argument_list|,
operator|&
name|bitD2
argument_list|,
name|opStart3
argument_list|,
name|dt
argument_list|,
name|dtLog
argument_list|)
expr_stmt|;
name|HUF_decodeStreamX4
argument_list|(
name|op3
argument_list|,
operator|&
name|bitD3
argument_list|,
name|opStart4
argument_list|,
name|dt
argument_list|,
name|dtLog
argument_list|)
expr_stmt|;
name|HUF_decodeStreamX4
argument_list|(
name|op4
argument_list|,
operator|&
name|bitD4
argument_list|,
name|oend
argument_list|,
name|dt
argument_list|,
name|dtLog
argument_list|)
expr_stmt|;
comment|/* check */
name|endSignal
operator|=
name|BIT_endOfDStream
argument_list|(
operator|&
name|bitD1
argument_list|)
operator|&
name|BIT_endOfDStream
argument_list|(
operator|&
name|bitD2
argument_list|)
operator|&
name|BIT_endOfDStream
argument_list|(
operator|&
name|bitD3
argument_list|)
operator|&
name|BIT_endOfDStream
argument_list|(
operator|&
name|bitD4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|endSignal
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* decoded size */
return|return
name|dstSize
return|;
block|}
block|}
specifier|static
name|size_t
name|HUF_decompress4X4
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
block|{
name|HUF_CREATE_STATIC_DTABLEX4
argument_list|(
name|DTable
argument_list|,
name|HUF_MAX_TABLELOG
argument_list|)
expr_stmt|;
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|cSrc
decl_stmt|;
name|size_t
name|hSize
init|=
name|HUF_readDTableX4
argument_list|(
name|DTable
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|HUF_isError
argument_list|(
name|hSize
argument_list|)
condition|)
return|return
name|hSize
return|;
if|if
condition|(
name|hSize
operator|>=
name|cSrcSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|ip
operator|+=
name|hSize
expr_stmt|;
name|cSrcSize
operator|-=
name|hSize
expr_stmt|;
return|return
name|HUF_decompress4X4_usingDTable
argument_list|(
name|dst
argument_list|,
name|dstSize
argument_list|,
name|ip
argument_list|,
name|cSrcSize
argument_list|,
name|DTable
argument_list|)
return|;
block|}
comment|/**********************************/
comment|/* Generic decompression selector */
comment|/**********************************/
typedef|typedef
struct|struct
block|{
name|U32
name|tableTime
decl_stmt|;
name|U32
name|decode256Time
decl_stmt|;
block|}
name|algo_time_t
typedef|;
specifier|static
specifier|const
name|algo_time_t
name|algoTime
index|[
literal|16
comment|/* Quantization */
index|]
index|[
literal|3
comment|/* single, double, quad */
index|]
init|=
block|{
comment|/* single, double, quad */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|2
block|,
literal|2
block|}
block|}
block|,
comment|/* Q==0 : impossible */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|2
block|,
literal|2
block|}
block|}
block|,
comment|/* Q==1 : impossible */
block|{
block|{
literal|38
block|,
literal|130
block|}
block|,
block|{
literal|1313
block|,
literal|74
block|}
block|,
block|{
literal|2151
block|,
literal|38
block|}
block|}
block|,
comment|/* Q == 2 : 12-18% */
block|{
block|{
literal|448
block|,
literal|128
block|}
block|,
block|{
literal|1353
block|,
literal|74
block|}
block|,
block|{
literal|2238
block|,
literal|41
block|}
block|}
block|,
comment|/* Q == 3 : 18-25% */
block|{
block|{
literal|556
block|,
literal|128
block|}
block|,
block|{
literal|1353
block|,
literal|74
block|}
block|,
block|{
literal|2238
block|,
literal|47
block|}
block|}
block|,
comment|/* Q == 4 : 25-32% */
block|{
block|{
literal|714
block|,
literal|128
block|}
block|,
block|{
literal|1418
block|,
literal|74
block|}
block|,
block|{
literal|2436
block|,
literal|53
block|}
block|}
block|,
comment|/* Q == 5 : 32-38% */
block|{
block|{
literal|883
block|,
literal|128
block|}
block|,
block|{
literal|1437
block|,
literal|74
block|}
block|,
block|{
literal|2464
block|,
literal|61
block|}
block|}
block|,
comment|/* Q == 6 : 38-44% */
block|{
block|{
literal|897
block|,
literal|128
block|}
block|,
block|{
literal|1515
block|,
literal|75
block|}
block|,
block|{
literal|2622
block|,
literal|68
block|}
block|}
block|,
comment|/* Q == 7 : 44-50% */
block|{
block|{
literal|926
block|,
literal|128
block|}
block|,
block|{
literal|1613
block|,
literal|75
block|}
block|,
block|{
literal|2730
block|,
literal|75
block|}
block|}
block|,
comment|/* Q == 8 : 50-56% */
block|{
block|{
literal|947
block|,
literal|128
block|}
block|,
block|{
literal|1729
block|,
literal|77
block|}
block|,
block|{
literal|3359
block|,
literal|77
block|}
block|}
block|,
comment|/* Q == 9 : 56-62% */
block|{
block|{
literal|1107
block|,
literal|128
block|}
block|,
block|{
literal|2083
block|,
literal|81
block|}
block|,
block|{
literal|4006
block|,
literal|84
block|}
block|}
block|,
comment|/* Q ==10 : 62-69% */
block|{
block|{
literal|1177
block|,
literal|128
block|}
block|,
block|{
literal|2379
block|,
literal|87
block|}
block|,
block|{
literal|4785
block|,
literal|88
block|}
block|}
block|,
comment|/* Q ==11 : 69-75% */
block|{
block|{
literal|1242
block|,
literal|128
block|}
block|,
block|{
literal|2415
block|,
literal|93
block|}
block|,
block|{
literal|5155
block|,
literal|84
block|}
block|}
block|,
comment|/* Q ==12 : 75-81% */
block|{
block|{
literal|1349
block|,
literal|128
block|}
block|,
block|{
literal|2644
block|,
literal|106
block|}
block|,
block|{
literal|5260
block|,
literal|106
block|}
block|}
block|,
comment|/* Q ==13 : 81-87% */
block|{
block|{
literal|1455
block|,
literal|128
block|}
block|,
block|{
literal|2422
block|,
literal|124
block|}
block|,
block|{
literal|4174
block|,
literal|124
block|}
block|}
block|,
comment|/* Q ==14 : 87-93% */
block|{
block|{
literal|722
block|,
literal|128
block|}
block|,
block|{
literal|1891
block|,
literal|145
block|}
block|,
block|{
literal|1936
block|,
literal|146
block|}
block|}
block|,
comment|/* Q ==15 : 93-99% */
block|}
decl_stmt|;
typedef|typedef
name|size_t
function_decl|(
modifier|*
name|decompressionAlgo
function_decl|)
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
function_decl|;
specifier|static
name|size_t
name|HUF_decompress
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
block|{
specifier|static
specifier|const
name|decompressionAlgo
name|decompress
index|[
literal|3
index|]
init|=
block|{
name|HUF_decompress4X2
block|,
name|HUF_decompress4X4
block|,
name|NULL
block|}
decl_stmt|;
comment|/* estimate decompression time */
name|U32
name|Q
decl_stmt|;
specifier|const
name|U32
name|D256
init|=
call|(
name|U32
call|)
argument_list|(
name|dstSize
operator|>>
literal|8
argument_list|)
decl_stmt|;
name|U32
name|Dtime
index|[
literal|3
index|]
decl_stmt|;
name|U32
name|algoNb
init|=
literal|0
decl_stmt|;
name|int
name|n
decl_stmt|;
comment|/* validation checks */
if|if
condition|(
name|dstSize
operator|==
literal|0
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
if|if
condition|(
name|cSrcSize
operator|>
name|dstSize
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* invalid */
if|if
condition|(
name|cSrcSize
operator|==
name|dstSize
condition|)
block|{
name|memcpy
argument_list|(
name|dst
argument_list|,
name|cSrc
argument_list|,
name|dstSize
argument_list|)
expr_stmt|;
return|return
name|dstSize
return|;
block|}
comment|/* not compressed */
if|if
condition|(
name|cSrcSize
operator|==
literal|1
condition|)
block|{
name|memset
argument_list|(
name|dst
argument_list|,
operator|*
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|cSrc
argument_list|,
name|dstSize
argument_list|)
expr_stmt|;
return|return
name|dstSize
return|;
block|}
comment|/* RLE */
comment|/* decoder timing evaluation */
name|Q
operator|=
call|(
name|U32
call|)
argument_list|(
name|cSrcSize
operator|*
literal|16
operator|/
name|dstSize
argument_list|)
expr_stmt|;
comment|/* Q< 16 since dstSize> cSrcSize */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|3
condition|;
name|n
operator|++
control|)
name|Dtime
index|[
name|n
index|]
operator|=
name|algoTime
index|[
name|Q
index|]
index|[
name|n
index|]
operator|.
name|tableTime
operator|+
operator|(
name|algoTime
index|[
name|Q
index|]
index|[
name|n
index|]
operator|.
name|decode256Time
operator|*
name|D256
operator|)
expr_stmt|;
name|Dtime
index|[
literal|1
index|]
operator|+=
name|Dtime
index|[
literal|1
index|]
operator|>>
literal|4
expr_stmt|;
name|Dtime
index|[
literal|2
index|]
operator|+=
name|Dtime
index|[
literal|2
index|]
operator|>>
literal|3
expr_stmt|;
comment|/* advantage to algorithms using less memory, for cache eviction */
if|if
condition|(
name|Dtime
index|[
literal|1
index|]
operator|<
name|Dtime
index|[
literal|0
index|]
condition|)
name|algoNb
operator|=
literal|1
expr_stmt|;
return|return
name|decompress
index|[
name|algoNb
index|]
operator|(
name|dst
operator|,
name|dstSize
operator|,
name|cSrc
operator|,
name|cSrcSize
operator|)
return|;
comment|//return HUF_decompress4X2(dst, dstSize, cSrc, cSrcSize);   /* multi-streams single-symbol decoding */
comment|//return HUF_decompress4X4(dst, dstSize, cSrc, cSrcSize);   /* multi-streams double-symbols decoding */
comment|//return HUF_decompress4X6(dst, dstSize, cSrc, cSrcSize);   /* multi-streams quad-symbols decoding */
block|}
endif|#
directive|endif
comment|/* ZSTD_CCOMMON_H_MODULE */
comment|/*     zstd - decompression module fo v0.4 legacy format     Copyright (C) 2015-2016, Yann Collet.      BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)      Redistribution and use in source and binary forms, with or without     modification, are permitted provided that the following conditions are     met:     * Redistributions of source code must retain the above copyright     notice, this list of conditions and the following disclaimer.     * Redistributions in binary form must reproduce the above     copyright notice, this list of conditions and the following disclaimer     in the documentation and/or other materials provided with the     distribution.     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS     "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR     A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT     OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT     LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY     THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE     OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.      You can contact the author at :     - zstd source repository : https://github.com/Cyan4973/zstd     - ztsd public forum : https://groups.google.com/forum/#!forum/lz4c */
comment|/* *************************************************************** *  Tuning parameters *****************************************************************/
comment|/*!  * HEAPMODE :  * Select how default decompression function ZSTD_decompress() will allocate memory,  * in memory stack (0), or in memory heap (1, requires malloc())  */
ifndef|#
directive|ifndef
name|ZSTD_HEAPMODE
define|#
directive|define
name|ZSTD_HEAPMODE
value|1
endif|#
directive|endif
comment|/* ******************************************************* *  Includes *********************************************************/
include|#
directive|include
file|<stdlib.h>
comment|/* calloc */
include|#
directive|include
file|<string.h>
comment|/* memcpy, memmove */
include|#
directive|include
file|<stdio.h>
comment|/* debug : printf */
comment|/* ******************************************************* *  Compiler specifics *********************************************************/
ifdef|#
directive|ifdef
name|_MSC_VER
comment|/* Visual Studio */
include|#
directive|include
file|<intrin.h>
comment|/* For Visual 2005 */
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4127
name|)
comment|/* disable: C4127: conditional expression is constant */
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4324
name|)
comment|/* disable: C4324: padded structure */
endif|#
directive|endif
comment|/* ************************************* *  Local types ***************************************/
typedef|typedef
struct|struct
block|{
name|blockType_t
name|blockType
decl_stmt|;
name|U32
name|origSize
decl_stmt|;
block|}
name|blockProperties_t
typedef|;
comment|/* ******************************************************* *  Memory operations **********************************************************/
specifier|static
name|void
name|ZSTD_copy4
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|)
block|{
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* ************************************* *  Error Management ***************************************/
comment|/*! ZSTD_isError *   tells if a return value is an error code */
specifier|static
name|unsigned
name|ZSTD_isError
parameter_list|(
name|size_t
name|code
parameter_list|)
block|{
return|return
name|ERR_isError
argument_list|(
name|code
argument_list|)
return|;
block|}
comment|/* ************************************************************* *   Context management ***************************************************************/
typedef|typedef
enum|enum
block|{
name|ZSTDds_getFrameHeaderSize
block|,
name|ZSTDds_decodeFrameHeader
block|,
name|ZSTDds_decodeBlockHeader
block|,
name|ZSTDds_decompressBlock
block|}
name|ZSTD_dStage
typedef|;
struct|struct
name|ZSTDv04_Dctx_s
block|{
name|U32
name|LLTable
index|[
name|FSE_DTABLE_SIZE_U32
argument_list|(
name|LLFSELog
argument_list|)
index|]
decl_stmt|;
name|U32
name|OffTable
index|[
name|FSE_DTABLE_SIZE_U32
argument_list|(
name|OffFSELog
argument_list|)
index|]
decl_stmt|;
name|U32
name|MLTable
index|[
name|FSE_DTABLE_SIZE_U32
argument_list|(
name|MLFSELog
argument_list|)
index|]
decl_stmt|;
specifier|const
name|void
modifier|*
name|previousDstEnd
decl_stmt|;
specifier|const
name|void
modifier|*
name|base
decl_stmt|;
specifier|const
name|void
modifier|*
name|vBase
decl_stmt|;
specifier|const
name|void
modifier|*
name|dictEnd
decl_stmt|;
name|size_t
name|expected
decl_stmt|;
name|size_t
name|headerSize
decl_stmt|;
name|ZSTD_parameters
name|params
decl_stmt|;
name|blockType_t
name|bType
decl_stmt|;
name|ZSTD_dStage
name|stage
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|litPtr
decl_stmt|;
name|size_t
name|litSize
decl_stmt|;
name|BYTE
name|litBuffer
index|[
name|BLOCKSIZE
operator|+
literal|8
comment|/* margin for wildcopy */
index|]
decl_stmt|;
name|BYTE
name|headerBuffer
index|[
name|ZSTD_frameHeaderSize_max
index|]
decl_stmt|;
block|}
struct|;
comment|/* typedef'd to ZSTD_DCtx within "zstd_static.h" */
specifier|static
name|size_t
name|ZSTD_resetDCtx
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|)
block|{
name|dctx
operator|->
name|expected
operator|=
name|ZSTD_frameHeaderSize_min
expr_stmt|;
name|dctx
operator|->
name|stage
operator|=
name|ZSTDds_getFrameHeaderSize
expr_stmt|;
name|dctx
operator|->
name|previousDstEnd
operator|=
name|NULL
expr_stmt|;
name|dctx
operator|->
name|base
operator|=
name|NULL
expr_stmt|;
name|dctx
operator|->
name|vBase
operator|=
name|NULL
expr_stmt|;
name|dctx
operator|->
name|dictEnd
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
specifier|static
name|ZSTD_DCtx
modifier|*
name|ZSTD_createDCtx
parameter_list|(
name|void
parameter_list|)
block|{
name|ZSTD_DCtx
modifier|*
name|dctx
init|=
operator|(
name|ZSTD_DCtx
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ZSTD_DCtx
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|dctx
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|ZSTD_resetDCtx
argument_list|(
name|dctx
argument_list|)
expr_stmt|;
return|return
name|dctx
return|;
block|}
specifier|static
name|size_t
name|ZSTD_freeDCtx
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|)
block|{
name|free
argument_list|(
name|dctx
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* ************************************************************* *   Decompression section ***************************************************************/
comment|/** ZSTD_decodeFrameHeader_Part1 *   decode the 1st part of the Frame Header, which tells Frame Header size. *   srcSize must be == ZSTD_frameHeaderSize_min *   @return : the full size of the Frame Header */
specifier|static
name|size_t
name|ZSTD_decodeFrameHeader_Part1
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|zc
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
name|U32
name|magicNumber
decl_stmt|;
if|if
condition|(
name|srcSize
operator|!=
name|ZSTD_frameHeaderSize_min
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|magicNumber
operator|=
name|MEM_readLE32
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|magicNumber
operator|!=
name|ZSTD_MAGICNUMBER
condition|)
return|return
name|ERROR
argument_list|(
name|prefix_unknown
argument_list|)
return|;
name|zc
operator|->
name|headerSize
operator|=
name|ZSTD_frameHeaderSize_min
expr_stmt|;
return|return
name|zc
operator|->
name|headerSize
return|;
block|}
specifier|static
name|size_t
name|ZSTD_getFrameParams
parameter_list|(
name|ZSTD_parameters
modifier|*
name|params
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
name|U32
name|magicNumber
decl_stmt|;
if|if
condition|(
name|srcSize
operator|<
name|ZSTD_frameHeaderSize_min
condition|)
return|return
name|ZSTD_frameHeaderSize_max
return|;
name|magicNumber
operator|=
name|MEM_readLE32
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|magicNumber
operator|!=
name|ZSTD_MAGICNUMBER
condition|)
return|return
name|ERROR
argument_list|(
name|prefix_unknown
argument_list|)
return|;
name|memset
argument_list|(
name|params
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|params
argument_list|)
argument_list|)
expr_stmt|;
name|params
operator|->
name|windowLog
operator|=
operator|(
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
operator|)
index|[
literal|4
index|]
operator|&
literal|15
operator|)
operator|+
name|ZSTD_WINDOWLOG_ABSOLUTEMIN
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
operator|)
index|[
literal|4
index|]
operator|>>
literal|4
operator|)
operator|!=
literal|0
condition|)
return|return
name|ERROR
argument_list|(
name|frameParameter_unsupported
argument_list|)
return|;
comment|/* reserved bits */
return|return
literal|0
return|;
block|}
comment|/** ZSTD_decodeFrameHeader_Part2 *   decode the full Frame Header *   srcSize must be the size provided by ZSTD_decodeFrameHeader_Part1 *   @return : 0, or an error code, which can be tested using ZSTD_isError() */
specifier|static
name|size_t
name|ZSTD_decodeFrameHeader_Part2
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|zc
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
name|size_t
name|result
decl_stmt|;
if|if
condition|(
name|srcSize
operator|!=
name|zc
operator|->
name|headerSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|result
operator|=
name|ZSTD_getFrameParams
argument_list|(
operator|&
operator|(
name|zc
operator|->
name|params
operator|)
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|MEM_32bits
argument_list|()
operator|)
operator|&&
operator|(
name|zc
operator|->
name|params
operator|.
name|windowLog
operator|>
literal|25
operator|)
condition|)
return|return
name|ERROR
argument_list|(
name|frameParameter_unsupportedBy32bits
argument_list|)
return|;
return|return
name|result
return|;
block|}
specifier|static
name|size_t
name|ZSTD_getcBlockSize
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|blockProperties_t
modifier|*
name|bpPtr
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|in
init|=
operator|(
specifier|const
name|BYTE
operator|*
specifier|const
operator|)
name|src
decl_stmt|;
name|BYTE
name|headerFlags
decl_stmt|;
name|U32
name|cSize
decl_stmt|;
if|if
condition|(
name|srcSize
operator|<
literal|3
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|headerFlags
operator|=
operator|*
name|in
expr_stmt|;
name|cSize
operator|=
name|in
index|[
literal|2
index|]
operator|+
operator|(
name|in
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
operator|(
name|in
index|[
literal|0
index|]
operator|&
literal|7
operator|)
operator|<<
literal|16
operator|)
expr_stmt|;
name|bpPtr
operator|->
name|blockType
operator|=
call|(
name|blockType_t
call|)
argument_list|(
name|headerFlags
operator|>>
literal|6
argument_list|)
expr_stmt|;
name|bpPtr
operator|->
name|origSize
operator|=
operator|(
name|bpPtr
operator|->
name|blockType
operator|==
name|bt_rle
operator|)
condition|?
name|cSize
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|bpPtr
operator|->
name|blockType
operator|==
name|bt_end
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|bpPtr
operator|->
name|blockType
operator|==
name|bt_rle
condition|)
return|return
literal|1
return|;
return|return
name|cSize
return|;
block|}
specifier|static
name|size_t
name|ZSTD_copyRawBlock
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
if|if
condition|(
name|srcSize
operator|>
name|maxDstSize
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
expr_stmt|;
return|return
name|srcSize
return|;
block|}
comment|/** ZSTD_decompressLiterals     @return : nb of bytes read from src, or an error code*/
specifier|static
name|size_t
name|ZSTD_decompressLiterals
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
modifier|*
name|maxDstSizePtr
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
decl_stmt|;
specifier|const
name|size_t
name|litSize
init|=
operator|(
name|MEM_readLE32
argument_list|(
name|src
argument_list|)
operator|&
literal|0x1FFFFF
operator|)
operator|>>
literal|2
decl_stmt|;
comment|/* no buffer issue : srcSize>= MIN_CBLOCK_SIZE */
specifier|const
name|size_t
name|litCSize
init|=
operator|(
name|MEM_readLE32
argument_list|(
name|ip
operator|+
literal|2
argument_list|)
operator|&
literal|0xFFFFFF
operator|)
operator|>>
literal|5
decl_stmt|;
comment|/* no buffer issue : srcSize>= MIN_CBLOCK_SIZE */
if|if
condition|(
name|litSize
operator|>
operator|*
name|maxDstSizePtr
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
if|if
condition|(
name|litCSize
operator|+
literal|5
operator|>
name|srcSize
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
if|if
condition|(
name|HUF_isError
argument_list|(
name|HUF_decompress
argument_list|(
name|dst
argument_list|,
name|litSize
argument_list|,
name|ip
operator|+
literal|5
argument_list|,
name|litCSize
argument_list|)
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
operator|*
name|maxDstSizePtr
operator|=
name|litSize
expr_stmt|;
return|return
name|litCSize
operator|+
literal|5
return|;
block|}
comment|/** ZSTD_decodeLiteralsBlock     @return : nb of bytes read from src (< srcSize ) */
specifier|static
name|size_t
name|ZSTD_decodeLiteralsBlock
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
comment|/* note : srcSize< BLOCKSIZE */
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
decl_stmt|;
comment|/* any compressed block with literals segment must be at least this size */
if|if
condition|(
name|srcSize
operator|<
name|MIN_CBLOCK_SIZE
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
switch|switch
condition|(
operator|*
name|istart
operator|&
literal|3
condition|)
block|{
comment|/* compressed */
case|case
literal|0
case|:
block|{
name|size_t
name|litSize
init|=
name|BLOCKSIZE
decl_stmt|;
specifier|const
name|size_t
name|readSize
init|=
name|ZSTD_decompressLiterals
argument_list|(
name|dctx
operator|->
name|litBuffer
argument_list|,
operator|&
name|litSize
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
decl_stmt|;
name|dctx
operator|->
name|litPtr
operator|=
name|dctx
operator|->
name|litBuffer
expr_stmt|;
name|dctx
operator|->
name|litSize
operator|=
name|litSize
expr_stmt|;
name|memset
argument_list|(
name|dctx
operator|->
name|litBuffer
operator|+
name|dctx
operator|->
name|litSize
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
return|return
name|readSize
return|;
comment|/* works if it's an error too */
block|}
case|case
name|IS_RAW
case|:
block|{
specifier|const
name|size_t
name|litSize
init|=
operator|(
name|MEM_readLE32
argument_list|(
name|istart
argument_list|)
operator|&
literal|0xFFFFFF
operator|)
operator|>>
literal|2
decl_stmt|;
comment|/* no buffer issue : srcSize>= MIN_CBLOCK_SIZE */
if|if
condition|(
name|litSize
operator|>
name|srcSize
operator|-
literal|11
condition|)
comment|/* risk of reading too far with wildcopy */
block|{
if|if
condition|(
name|litSize
operator|>
name|srcSize
operator|-
literal|3
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
name|memcpy
argument_list|(
name|dctx
operator|->
name|litBuffer
argument_list|,
name|istart
argument_list|,
name|litSize
argument_list|)
expr_stmt|;
name|dctx
operator|->
name|litPtr
operator|=
name|dctx
operator|->
name|litBuffer
expr_stmt|;
name|dctx
operator|->
name|litSize
operator|=
name|litSize
expr_stmt|;
name|memset
argument_list|(
name|dctx
operator|->
name|litBuffer
operator|+
name|dctx
operator|->
name|litSize
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
return|return
name|litSize
operator|+
literal|3
return|;
block|}
comment|/* direct reference into compressed stream */
name|dctx
operator|->
name|litPtr
operator|=
name|istart
operator|+
literal|3
expr_stmt|;
name|dctx
operator|->
name|litSize
operator|=
name|litSize
expr_stmt|;
return|return
name|litSize
operator|+
literal|3
return|;
block|}
case|case
name|IS_RLE
case|:
block|{
specifier|const
name|size_t
name|litSize
init|=
operator|(
name|MEM_readLE32
argument_list|(
name|istart
argument_list|)
operator|&
literal|0xFFFFFF
operator|)
operator|>>
literal|2
decl_stmt|;
comment|/* no buffer issue : srcSize>= MIN_CBLOCK_SIZE */
if|if
condition|(
name|litSize
operator|>
name|BLOCKSIZE
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
name|memset
argument_list|(
name|dctx
operator|->
name|litBuffer
argument_list|,
name|istart
index|[
literal|3
index|]
argument_list|,
name|litSize
operator|+
literal|8
argument_list|)
expr_stmt|;
name|dctx
operator|->
name|litPtr
operator|=
name|dctx
operator|->
name|litBuffer
expr_stmt|;
name|dctx
operator|->
name|litSize
operator|=
name|litSize
expr_stmt|;
return|return
literal|4
return|;
block|}
default|default:
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* forbidden nominal case */
block|}
block|}
specifier|static
name|size_t
name|ZSTD_decodeSeqHeaders
parameter_list|(
name|int
modifier|*
name|nbSeq
parameter_list|,
specifier|const
name|BYTE
modifier|*
modifier|*
name|dumpsPtr
parameter_list|,
name|size_t
modifier|*
name|dumpsLengthPtr
parameter_list|,
name|FSE_DTable
modifier|*
name|DTableLL
parameter_list|,
name|FSE_DTable
modifier|*
name|DTableML
parameter_list|,
name|FSE_DTable
modifier|*
name|DTableOffb
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart
init|=
operator|(
specifier|const
name|BYTE
operator|*
specifier|const
operator|)
name|src
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|ip
init|=
name|istart
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|iend
init|=
name|istart
operator|+
name|srcSize
decl_stmt|;
name|U32
name|LLtype
decl_stmt|,
name|Offtype
decl_stmt|,
name|MLtype
decl_stmt|;
name|U32
name|LLlog
decl_stmt|,
name|Offlog
decl_stmt|,
name|MLlog
decl_stmt|;
name|size_t
name|dumpsLength
decl_stmt|;
comment|/* check */
if|if
condition|(
name|srcSize
operator|<
literal|5
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
comment|/* SeqHead */
operator|*
name|nbSeq
operator|=
name|MEM_readLE16
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|ip
operator|+=
literal|2
expr_stmt|;
name|LLtype
operator|=
operator|*
name|ip
operator|>>
literal|6
expr_stmt|;
name|Offtype
operator|=
operator|(
operator|*
name|ip
operator|>>
literal|4
operator|)
operator|&
literal|3
expr_stmt|;
name|MLtype
operator|=
operator|(
operator|*
name|ip
operator|>>
literal|2
operator|)
operator|&
literal|3
expr_stmt|;
if|if
condition|(
operator|*
name|ip
operator|&
literal|2
condition|)
block|{
name|dumpsLength
operator|=
name|ip
index|[
literal|2
index|]
expr_stmt|;
name|dumpsLength
operator|+=
name|ip
index|[
literal|1
index|]
operator|<<
literal|8
expr_stmt|;
name|ip
operator|+=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|dumpsLength
operator|=
name|ip
index|[
literal|1
index|]
expr_stmt|;
name|dumpsLength
operator|+=
operator|(
name|ip
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|<<
literal|8
expr_stmt|;
name|ip
operator|+=
literal|2
expr_stmt|;
block|}
operator|*
name|dumpsPtr
operator|=
name|ip
expr_stmt|;
name|ip
operator|+=
name|dumpsLength
expr_stmt|;
operator|*
name|dumpsLengthPtr
operator|=
name|dumpsLength
expr_stmt|;
comment|/* check */
if|if
condition|(
name|ip
operator|>
name|iend
operator|-
literal|3
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
comment|/* min : all 3 are "raw", hence no header, but at least xxLog bits per type */
comment|/* sequences */
block|{
name|S16
name|norm
index|[
name|MaxML
operator|+
literal|1
index|]
decl_stmt|;
comment|/* assumption : MaxML>= MaxLL>= MaxOff */
name|size_t
name|headerSize
decl_stmt|;
comment|/* Build DTables */
switch|switch
condition|(
name|LLtype
condition|)
block|{
case|case
name|bt_rle
case|:
name|LLlog
operator|=
literal|0
expr_stmt|;
name|FSE_buildDTable_rle
argument_list|(
name|DTableLL
argument_list|,
operator|*
name|ip
operator|++
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_raw
case|:
name|LLlog
operator|=
name|LLbits
expr_stmt|;
name|FSE_buildDTable_raw
argument_list|(
name|DTableLL
argument_list|,
name|LLbits
argument_list|)
expr_stmt|;
break|break;
default|default :
block|{
name|U32
name|max
init|=
name|MaxLL
decl_stmt|;
name|headerSize
operator|=
name|FSE_readNCount
argument_list|(
name|norm
argument_list|,
operator|&
name|max
argument_list|,
operator|&
name|LLlog
argument_list|,
name|ip
argument_list|,
name|iend
operator|-
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|FSE_isError
argument_list|(
name|headerSize
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
if|if
condition|(
name|LLlog
operator|>
name|LLFSELog
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
name|ip
operator|+=
name|headerSize
expr_stmt|;
name|FSE_buildDTable
argument_list|(
name|DTableLL
argument_list|,
name|norm
argument_list|,
name|max
argument_list|,
name|LLlog
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|Offtype
condition|)
block|{
case|case
name|bt_rle
case|:
name|Offlog
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ip
operator|>
name|iend
operator|-
literal|2
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
comment|/* min : "raw", hence no header, but at least xxLog bits */
name|FSE_buildDTable_rle
argument_list|(
name|DTableOffb
argument_list|,
operator|*
name|ip
operator|++
operator|&
name|MaxOff
argument_list|)
expr_stmt|;
comment|/* if *ip> MaxOff, data is corrupted */
break|break;
case|case
name|bt_raw
case|:
name|Offlog
operator|=
name|Offbits
expr_stmt|;
name|FSE_buildDTable_raw
argument_list|(
name|DTableOffb
argument_list|,
name|Offbits
argument_list|)
expr_stmt|;
break|break;
default|default :
block|{
name|U32
name|max
init|=
name|MaxOff
decl_stmt|;
name|headerSize
operator|=
name|FSE_readNCount
argument_list|(
name|norm
argument_list|,
operator|&
name|max
argument_list|,
operator|&
name|Offlog
argument_list|,
name|ip
argument_list|,
name|iend
operator|-
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|FSE_isError
argument_list|(
name|headerSize
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
if|if
condition|(
name|Offlog
operator|>
name|OffFSELog
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
name|ip
operator|+=
name|headerSize
expr_stmt|;
name|FSE_buildDTable
argument_list|(
name|DTableOffb
argument_list|,
name|norm
argument_list|,
name|max
argument_list|,
name|Offlog
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|MLtype
condition|)
block|{
case|case
name|bt_rle
case|:
name|MLlog
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ip
operator|>
name|iend
operator|-
literal|2
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
comment|/* min : "raw", hence no header, but at least xxLog bits */
name|FSE_buildDTable_rle
argument_list|(
name|DTableML
argument_list|,
operator|*
name|ip
operator|++
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_raw
case|:
name|MLlog
operator|=
name|MLbits
expr_stmt|;
name|FSE_buildDTable_raw
argument_list|(
name|DTableML
argument_list|,
name|MLbits
argument_list|)
expr_stmt|;
break|break;
default|default :
block|{
name|U32
name|max
init|=
name|MaxML
decl_stmt|;
name|headerSize
operator|=
name|FSE_readNCount
argument_list|(
name|norm
argument_list|,
operator|&
name|max
argument_list|,
operator|&
name|MLlog
argument_list|,
name|ip
argument_list|,
name|iend
operator|-
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|FSE_isError
argument_list|(
name|headerSize
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
if|if
condition|(
name|MLlog
operator|>
name|MLFSELog
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
name|ip
operator|+=
name|headerSize
expr_stmt|;
name|FSE_buildDTable
argument_list|(
name|DTableML
argument_list|,
name|norm
argument_list|,
name|max
argument_list|,
name|MLlog
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|ip
operator|-
name|istart
return|;
block|}
typedef|typedef
struct|struct
block|{
name|size_t
name|litLength
decl_stmt|;
name|size_t
name|offset
decl_stmt|;
name|size_t
name|matchLength
decl_stmt|;
block|}
name|seq_t
typedef|;
typedef|typedef
struct|struct
block|{
name|BIT_DStream_t
name|DStream
decl_stmt|;
name|FSE_DState_t
name|stateLL
decl_stmt|;
name|FSE_DState_t
name|stateOffb
decl_stmt|;
name|FSE_DState_t
name|stateML
decl_stmt|;
name|size_t
name|prevOffset
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|dumps
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|dumpsEnd
decl_stmt|;
block|}
name|seqState_t
typedef|;
specifier|static
name|void
name|ZSTD_decodeSequence
parameter_list|(
name|seq_t
modifier|*
name|seq
parameter_list|,
name|seqState_t
modifier|*
name|seqState
parameter_list|)
block|{
name|size_t
name|litLength
decl_stmt|;
name|size_t
name|prevOffset
decl_stmt|;
name|size_t
name|offset
decl_stmt|;
name|size_t
name|matchLength
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|dumps
init|=
name|seqState
operator|->
name|dumps
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|de
init|=
name|seqState
operator|->
name|dumpsEnd
decl_stmt|;
comment|/* Literal length */
name|litLength
operator|=
name|FSE_decodeSymbol
argument_list|(
operator|&
operator|(
name|seqState
operator|->
name|stateLL
operator|)
argument_list|,
operator|&
operator|(
name|seqState
operator|->
name|DStream
operator|)
argument_list|)
expr_stmt|;
name|prevOffset
operator|=
name|litLength
condition|?
name|seq
operator|->
name|offset
else|:
name|seqState
operator|->
name|prevOffset
expr_stmt|;
if|if
condition|(
name|litLength
operator|==
name|MaxLL
condition|)
block|{
name|U32
name|add
init|=
operator|*
name|dumps
operator|++
decl_stmt|;
if|if
condition|(
name|add
operator|<
literal|255
condition|)
name|litLength
operator|+=
name|add
expr_stmt|;
else|else
block|{
name|litLength
operator|=
name|dumps
index|[
literal|0
index|]
operator|+
operator|(
name|dumps
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|dumps
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
expr_stmt|;
name|dumps
operator|+=
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|dumps
operator|>
name|de
condition|)
block|{
name|litLength
operator|=
name|MaxLL
operator|+
literal|255
expr_stmt|;
block|}
comment|/* late correction, to avoid using uninitialized memory */
if|if
condition|(
name|dumps
operator|>=
name|de
condition|)
block|{
name|dumps
operator|=
name|de
operator|-
literal|1
expr_stmt|;
block|}
comment|/* late correction, to avoid read overflow (data is now corrupted anyway) */
block|}
comment|/* Offset */
block|{
specifier|static
specifier|const
name|U32
name|offsetPrefix
index|[
name|MaxOff
operator|+
literal|1
index|]
init|=
block|{
literal|1
comment|/*fake*/
block|,
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|8
block|,
literal|16
block|,
literal|32
block|,
literal|64
block|,
literal|128
block|,
literal|256
block|,
literal|512
block|,
literal|1024
block|,
literal|2048
block|,
literal|4096
block|,
literal|8192
block|,
literal|16384
block|,
literal|32768
block|,
literal|65536
block|,
literal|131072
block|,
literal|262144
block|,
literal|524288
block|,
literal|1048576
block|,
literal|2097152
block|,
literal|4194304
block|,
literal|8388608
block|,
literal|16777216
block|,
literal|33554432
block|,
comment|/*fake*/
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
name|U32
name|offsetCode
decl_stmt|,
name|nbBits
decl_stmt|;
name|offsetCode
operator|=
name|FSE_decodeSymbol
argument_list|(
operator|&
operator|(
name|seqState
operator|->
name|stateOffb
operator|)
argument_list|,
operator|&
operator|(
name|seqState
operator|->
name|DStream
operator|)
argument_list|)
expr_stmt|;
comment|/*<= maxOff, by table construction */
if|if
condition|(
name|MEM_32bits
argument_list|()
condition|)
name|BIT_reloadDStream
argument_list|(
operator|&
operator|(
name|seqState
operator|->
name|DStream
operator|)
argument_list|)
expr_stmt|;
name|nbBits
operator|=
name|offsetCode
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|offsetCode
operator|==
literal|0
condition|)
name|nbBits
operator|=
literal|0
expr_stmt|;
comment|/* cmove */
name|offset
operator|=
name|offsetPrefix
index|[
name|offsetCode
index|]
operator|+
name|BIT_readBits
argument_list|(
operator|&
operator|(
name|seqState
operator|->
name|DStream
operator|)
argument_list|,
name|nbBits
argument_list|)
expr_stmt|;
if|if
condition|(
name|MEM_32bits
argument_list|()
condition|)
name|BIT_reloadDStream
argument_list|(
operator|&
operator|(
name|seqState
operator|->
name|DStream
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|offsetCode
operator|==
literal|0
condition|)
name|offset
operator|=
name|prevOffset
expr_stmt|;
comment|/* cmove */
if|if
condition|(
name|offsetCode
operator||
operator|!
name|litLength
condition|)
name|seqState
operator|->
name|prevOffset
operator|=
name|seq
operator|->
name|offset
expr_stmt|;
comment|/* cmove */
block|}
comment|/* MatchLength */
name|matchLength
operator|=
name|FSE_decodeSymbol
argument_list|(
operator|&
operator|(
name|seqState
operator|->
name|stateML
operator|)
argument_list|,
operator|&
operator|(
name|seqState
operator|->
name|DStream
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|matchLength
operator|==
name|MaxML
condition|)
block|{
name|U32
name|add
init|=
operator|*
name|dumps
operator|++
decl_stmt|;
if|if
condition|(
name|add
operator|<
literal|255
condition|)
name|matchLength
operator|+=
name|add
expr_stmt|;
else|else
block|{
name|matchLength
operator|=
name|dumps
index|[
literal|0
index|]
operator|+
operator|(
name|dumps
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|dumps
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
expr_stmt|;
name|dumps
operator|+=
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|dumps
operator|>
name|de
condition|)
block|{
name|matchLength
operator|=
name|MaxML
operator|+
literal|255
expr_stmt|;
block|}
comment|/* late correction, to avoid using uninitialized memory */
if|if
condition|(
name|dumps
operator|>=
name|de
condition|)
block|{
name|dumps
operator|=
name|de
operator|-
literal|1
expr_stmt|;
block|}
comment|/* late correction, to avoid read overflow (data is now corrupted anyway) */
block|}
name|matchLength
operator|+=
name|MINMATCH
expr_stmt|;
comment|/* save result */
name|seq
operator|->
name|litLength
operator|=
name|litLength
expr_stmt|;
name|seq
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|seq
operator|->
name|matchLength
operator|=
name|matchLength
expr_stmt|;
name|seqState
operator|->
name|dumps
operator|=
name|dumps
expr_stmt|;
block|}
specifier|static
name|size_t
name|ZSTD_execSequence
parameter_list|(
name|BYTE
modifier|*
name|op
parameter_list|,
name|BYTE
modifier|*
specifier|const
name|oend
parameter_list|,
name|seq_t
name|sequence
parameter_list|,
specifier|const
name|BYTE
modifier|*
modifier|*
name|litPtr
parameter_list|,
specifier|const
name|BYTE
modifier|*
specifier|const
name|litLimit
parameter_list|,
specifier|const
name|BYTE
modifier|*
specifier|const
name|base
parameter_list|,
specifier|const
name|BYTE
modifier|*
specifier|const
name|vBase
parameter_list|,
specifier|const
name|BYTE
modifier|*
specifier|const
name|dictEnd
parameter_list|)
block|{
specifier|static
specifier|const
name|int
name|dec32table
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|}
decl_stmt|;
comment|/* added */
specifier|static
specifier|const
name|int
name|dec64table
index|[]
init|=
block|{
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|}
decl_stmt|;
comment|/* substracted */
name|BYTE
modifier|*
specifier|const
name|oLitEnd
init|=
name|op
operator|+
name|sequence
operator|.
name|litLength
decl_stmt|;
specifier|const
name|size_t
name|sequenceLength
init|=
name|sequence
operator|.
name|litLength
operator|+
name|sequence
operator|.
name|matchLength
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|oMatchEnd
init|=
name|op
operator|+
name|sequenceLength
decl_stmt|;
comment|/* risk : address space overflow (32-bits) */
name|BYTE
modifier|*
specifier|const
name|oend_8
init|=
name|oend
operator|-
literal|8
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|litEnd
init|=
operator|*
name|litPtr
operator|+
name|sequence
operator|.
name|litLength
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|match
init|=
name|oLitEnd
operator|-
name|sequence
operator|.
name|offset
decl_stmt|;
comment|/* check */
if|if
condition|(
name|oLitEnd
operator|>
name|oend_8
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
comment|/* last match must start at a minimum distance of 8 from oend */
if|if
condition|(
name|oMatchEnd
operator|>
name|oend
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
comment|/* overwrite beyond dst buffer */
if|if
condition|(
name|litEnd
operator|>
name|litLimit
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* risk read beyond lit buffer */
comment|/* copy Literals */
name|ZSTD_wildcopy
argument_list|(
name|op
argument_list|,
operator|*
name|litPtr
argument_list|,
name|sequence
operator|.
name|litLength
argument_list|)
expr_stmt|;
comment|/* note : oLitEnd<= oend-8 : no risk of overwrite beyond oend */
name|op
operator|=
name|oLitEnd
expr_stmt|;
operator|*
name|litPtr
operator|=
name|litEnd
expr_stmt|;
comment|/* update for next sequence */
comment|/* copy Match */
if|if
condition|(
name|sequence
operator|.
name|offset
operator|>
call|(
name|size_t
call|)
argument_list|(
name|oLitEnd
operator|-
name|base
argument_list|)
condition|)
block|{
comment|/* offset beyond prefix */
if|if
condition|(
name|sequence
operator|.
name|offset
operator|>
call|(
name|size_t
call|)
argument_list|(
name|oLitEnd
operator|-
name|vBase
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
name|match
operator|=
name|dictEnd
operator|-
operator|(
name|base
operator|-
name|match
operator|)
expr_stmt|;
if|if
condition|(
name|match
operator|+
name|sequence
operator|.
name|matchLength
operator|<=
name|dictEnd
condition|)
block|{
name|memmove
argument_list|(
name|oLitEnd
argument_list|,
name|match
argument_list|,
name|sequence
operator|.
name|matchLength
argument_list|)
expr_stmt|;
return|return
name|sequenceLength
return|;
block|}
comment|/* span extDict& currentPrefixSegment */
block|{
name|size_t
name|length1
init|=
name|dictEnd
operator|-
name|match
decl_stmt|;
name|memmove
argument_list|(
name|oLitEnd
argument_list|,
name|match
argument_list|,
name|length1
argument_list|)
expr_stmt|;
name|op
operator|=
name|oLitEnd
operator|+
name|length1
expr_stmt|;
name|sequence
operator|.
name|matchLength
operator|-=
name|length1
expr_stmt|;
name|match
operator|=
name|base
expr_stmt|;
if|if
condition|(
name|op
operator|>
name|oend_8
operator|||
name|sequence
operator|.
name|matchLength
operator|<
name|MINMATCH
condition|)
block|{
while|while
condition|(
name|op
operator|<
name|oMatchEnd
condition|)
operator|*
name|op
operator|++
operator|=
operator|*
name|match
operator|++
expr_stmt|;
return|return
name|sequenceLength
return|;
block|}
block|}
block|}
comment|/* Requirement: op<= oend_8 */
comment|/* match within prefix */
if|if
condition|(
name|sequence
operator|.
name|offset
operator|<
literal|8
condition|)
block|{
comment|/* close range match, overlap */
specifier|const
name|int
name|sub2
init|=
name|dec64table
index|[
name|sequence
operator|.
name|offset
index|]
decl_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|match
index|[
literal|0
index|]
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|match
index|[
literal|1
index|]
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|match
index|[
literal|2
index|]
expr_stmt|;
name|op
index|[
literal|3
index|]
operator|=
name|match
index|[
literal|3
index|]
expr_stmt|;
name|match
operator|+=
name|dec32table
index|[
name|sequence
operator|.
name|offset
index|]
expr_stmt|;
name|ZSTD_copy4
argument_list|(
name|op
operator|+
literal|4
argument_list|,
name|match
argument_list|)
expr_stmt|;
name|match
operator|-=
name|sub2
expr_stmt|;
block|}
else|else
block|{
name|ZSTD_copy8
argument_list|(
name|op
argument_list|,
name|match
argument_list|)
expr_stmt|;
block|}
name|op
operator|+=
literal|8
expr_stmt|;
name|match
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|oMatchEnd
operator|>
name|oend
operator|-
operator|(
literal|16
operator|-
name|MINMATCH
operator|)
condition|)
block|{
if|if
condition|(
name|op
operator|<
name|oend_8
condition|)
block|{
name|ZSTD_wildcopy
argument_list|(
name|op
argument_list|,
name|match
argument_list|,
name|oend_8
operator|-
name|op
argument_list|)
expr_stmt|;
name|match
operator|+=
name|oend_8
operator|-
name|op
expr_stmt|;
name|op
operator|=
name|oend_8
expr_stmt|;
block|}
while|while
condition|(
name|op
operator|<
name|oMatchEnd
condition|)
operator|*
name|op
operator|++
operator|=
operator|*
name|match
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ZSTD_wildcopy
argument_list|(
name|op
argument_list|,
name|match
argument_list|,
operator|(
name|ptrdiff_t
operator|)
name|sequence
operator|.
name|matchLength
operator|-
literal|8
argument_list|)
expr_stmt|;
comment|/* works even if matchLength< 8 */
block|}
return|return
name|sequenceLength
return|;
block|}
specifier|static
name|size_t
name|ZSTD_decompressSequences
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|seqStart
parameter_list|,
name|size_t
name|seqSize
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|seqStart
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|iend
init|=
name|ip
operator|+
name|seqSize
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|ostart
init|=
operator|(
name|BYTE
operator|*
specifier|const
operator|)
name|dst
decl_stmt|;
name|BYTE
modifier|*
name|op
init|=
name|ostart
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|oend
init|=
name|ostart
operator|+
name|maxDstSize
decl_stmt|;
name|size_t
name|errorCode
decl_stmt|,
name|dumpsLength
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|litPtr
init|=
name|dctx
operator|->
name|litPtr
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|litEnd
init|=
name|litPtr
operator|+
name|dctx
operator|->
name|litSize
decl_stmt|;
name|int
name|nbSeq
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|dumps
decl_stmt|;
name|U32
modifier|*
name|DTableLL
init|=
name|dctx
operator|->
name|LLTable
decl_stmt|;
name|U32
modifier|*
name|DTableML
init|=
name|dctx
operator|->
name|MLTable
decl_stmt|;
name|U32
modifier|*
name|DTableOffb
init|=
name|dctx
operator|->
name|OffTable
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|base
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|dctx
operator|->
name|base
operator|)
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|vBase
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|dctx
operator|->
name|vBase
operator|)
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|dictEnd
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|dctx
operator|->
name|dictEnd
operator|)
decl_stmt|;
comment|/* Build Decoding Tables */
name|errorCode
operator|=
name|ZSTD_decodeSeqHeaders
argument_list|(
operator|&
name|nbSeq
argument_list|,
operator|&
name|dumps
argument_list|,
operator|&
name|dumpsLength
argument_list|,
name|DTableLL
argument_list|,
name|DTableML
argument_list|,
name|DTableOffb
argument_list|,
name|ip
argument_list|,
name|iend
operator|-
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
name|ip
operator|+=
name|errorCode
expr_stmt|;
comment|/* Regen sequences */
block|{
name|seq_t
name|sequence
decl_stmt|;
name|seqState_t
name|seqState
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sequence
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sequence
argument_list|)
argument_list|)
expr_stmt|;
name|sequence
operator|.
name|offset
operator|=
literal|4
expr_stmt|;
name|seqState
operator|.
name|dumps
operator|=
name|dumps
expr_stmt|;
name|seqState
operator|.
name|dumpsEnd
operator|=
name|dumps
operator|+
name|dumpsLength
expr_stmt|;
name|seqState
operator|.
name|prevOffset
operator|=
literal|4
expr_stmt|;
name|errorCode
operator|=
name|BIT_initDStream
argument_list|(
operator|&
operator|(
name|seqState
operator|.
name|DStream
operator|)
argument_list|,
name|ip
argument_list|,
name|iend
operator|-
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|ERR_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
name|FSE_initDState
argument_list|(
operator|&
operator|(
name|seqState
operator|.
name|stateLL
operator|)
argument_list|,
operator|&
operator|(
name|seqState
operator|.
name|DStream
operator|)
argument_list|,
name|DTableLL
argument_list|)
expr_stmt|;
name|FSE_initDState
argument_list|(
operator|&
operator|(
name|seqState
operator|.
name|stateOffb
operator|)
argument_list|,
operator|&
operator|(
name|seqState
operator|.
name|DStream
operator|)
argument_list|,
name|DTableOffb
argument_list|)
expr_stmt|;
name|FSE_initDState
argument_list|(
operator|&
operator|(
name|seqState
operator|.
name|stateML
operator|)
argument_list|,
operator|&
operator|(
name|seqState
operator|.
name|DStream
operator|)
argument_list|,
name|DTableML
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|(
name|BIT_reloadDStream
argument_list|(
operator|&
operator|(
name|seqState
operator|.
name|DStream
operator|)
argument_list|)
operator|<=
name|BIT_DStream_completed
operator|)
operator|&&
name|nbSeq
condition|;
control|)
block|{
name|size_t
name|oneSeqSize
decl_stmt|;
name|nbSeq
operator|--
expr_stmt|;
name|ZSTD_decodeSequence
argument_list|(
operator|&
name|sequence
argument_list|,
operator|&
name|seqState
argument_list|)
expr_stmt|;
name|oneSeqSize
operator|=
name|ZSTD_execSequence
argument_list|(
name|op
argument_list|,
name|oend
argument_list|,
name|sequence
argument_list|,
operator|&
name|litPtr
argument_list|,
name|litEnd
argument_list|,
name|base
argument_list|,
name|vBase
argument_list|,
name|dictEnd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|oneSeqSize
argument_list|)
condition|)
return|return
name|oneSeqSize
return|;
name|op
operator|+=
name|oneSeqSize
expr_stmt|;
block|}
comment|/* check if reached exact end */
if|if
condition|(
operator|!
name|BIT_endOfDStream
argument_list|(
operator|&
operator|(
name|seqState
operator|.
name|DStream
operator|)
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* DStream should be entirely and exactly consumed; otherwise data is corrupted */
comment|/* last literal segment */
block|{
name|size_t
name|lastLLSize
init|=
name|litEnd
operator|-
name|litPtr
decl_stmt|;
if|if
condition|(
name|litPtr
operator|>
name|litEnd
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
if|if
condition|(
name|op
operator|+
name|lastLLSize
operator|>
name|oend
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
if|if
condition|(
name|op
operator|!=
name|litPtr
condition|)
name|memcpy
argument_list|(
name|op
argument_list|,
name|litPtr
argument_list|,
name|lastLLSize
argument_list|)
expr_stmt|;
name|op
operator|+=
name|lastLLSize
expr_stmt|;
block|}
block|}
return|return
name|op
operator|-
name|ostart
return|;
block|}
specifier|static
name|void
name|ZSTD_checkContinuity
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
specifier|const
name|void
modifier|*
name|dst
parameter_list|)
block|{
if|if
condition|(
name|dst
operator|!=
name|dctx
operator|->
name|previousDstEnd
condition|)
comment|/* not contiguous */
block|{
name|dctx
operator|->
name|dictEnd
operator|=
name|dctx
operator|->
name|previousDstEnd
expr_stmt|;
name|dctx
operator|->
name|vBase
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|dst
operator|-
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|dctx
operator|->
name|previousDstEnd
operator|)
operator|-
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|dctx
operator|->
name|base
operator|)
operator|)
expr_stmt|;
name|dctx
operator|->
name|base
operator|=
name|dst
expr_stmt|;
name|dctx
operator|->
name|previousDstEnd
operator|=
name|dst
expr_stmt|;
block|}
block|}
specifier|static
name|size_t
name|ZSTD_decompressBlock_internal
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
comment|/* blockType == blockCompressed */
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
decl_stmt|;
comment|/* Decode literals sub-block */
name|size_t
name|litCSize
init|=
name|ZSTD_decodeLiteralsBlock
argument_list|(
name|dctx
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|litCSize
argument_list|)
condition|)
return|return
name|litCSize
return|;
name|ip
operator|+=
name|litCSize
expr_stmt|;
name|srcSize
operator|-=
name|litCSize
expr_stmt|;
return|return
name|ZSTD_decompressSequences
argument_list|(
name|dctx
argument_list|,
name|dst
argument_list|,
name|maxDstSize
argument_list|,
name|ip
argument_list|,
name|srcSize
argument_list|)
return|;
block|}
specifier|static
name|size_t
name|ZSTD_decompress_usingDict
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|ctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|iend
init|=
name|ip
operator|+
name|srcSize
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|ostart
init|=
operator|(
name|BYTE
operator|*
specifier|const
operator|)
name|dst
decl_stmt|;
name|BYTE
modifier|*
name|op
init|=
name|ostart
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|oend
init|=
name|ostart
operator|+
name|maxDstSize
decl_stmt|;
name|size_t
name|remainingSize
init|=
name|srcSize
decl_stmt|;
name|blockProperties_t
name|blockProperties
decl_stmt|;
comment|/* init */
name|ZSTD_resetDCtx
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dict
condition|)
block|{
name|ZSTD_decompress_insertDictionary
argument_list|(
name|ctx
argument_list|,
name|dict
argument_list|,
name|dictSize
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|dictEnd
operator|=
name|ctx
operator|->
name|previousDstEnd
expr_stmt|;
name|ctx
operator|->
name|vBase
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|dst
operator|-
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|ctx
operator|->
name|previousDstEnd
operator|)
operator|-
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|ctx
operator|->
name|base
operator|)
operator|)
expr_stmt|;
name|ctx
operator|->
name|base
operator|=
name|dst
expr_stmt|;
block|}
else|else
block|{
name|ctx
operator|->
name|vBase
operator|=
name|ctx
operator|->
name|base
operator|=
name|ctx
operator|->
name|dictEnd
operator|=
name|dst
expr_stmt|;
block|}
comment|/* Frame Header */
block|{
name|size_t
name|frameHeaderSize
decl_stmt|;
if|if
condition|(
name|srcSize
operator|<
name|ZSTD_frameHeaderSize_min
operator|+
name|ZSTD_blockHeaderSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|frameHeaderSize
operator|=
name|ZSTD_decodeFrameHeader_Part1
argument_list|(
name|ctx
argument_list|,
name|src
argument_list|,
name|ZSTD_frameHeaderSize_min
argument_list|)
expr_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|frameHeaderSize
argument_list|)
condition|)
return|return
name|frameHeaderSize
return|;
if|if
condition|(
name|srcSize
operator|<
name|frameHeaderSize
operator|+
name|ZSTD_blockHeaderSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|ip
operator|+=
name|frameHeaderSize
expr_stmt|;
name|remainingSize
operator|-=
name|frameHeaderSize
expr_stmt|;
name|frameHeaderSize
operator|=
name|ZSTD_decodeFrameHeader_Part2
argument_list|(
name|ctx
argument_list|,
name|src
argument_list|,
name|frameHeaderSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|frameHeaderSize
argument_list|)
condition|)
return|return
name|frameHeaderSize
return|;
block|}
comment|/* Loop on each block */
while|while
condition|(
literal|1
condition|)
block|{
name|size_t
name|decodedSize
init|=
literal|0
decl_stmt|;
name|size_t
name|cBlockSize
init|=
name|ZSTD_getcBlockSize
argument_list|(
name|ip
argument_list|,
name|iend
operator|-
name|ip
argument_list|,
operator|&
name|blockProperties
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|cBlockSize
argument_list|)
condition|)
return|return
name|cBlockSize
return|;
name|ip
operator|+=
name|ZSTD_blockHeaderSize
expr_stmt|;
name|remainingSize
operator|-=
name|ZSTD_blockHeaderSize
expr_stmt|;
if|if
condition|(
name|cBlockSize
operator|>
name|remainingSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
switch|switch
condition|(
name|blockProperties
operator|.
name|blockType
condition|)
block|{
case|case
name|bt_compressed
case|:
name|decodedSize
operator|=
name|ZSTD_decompressBlock_internal
argument_list|(
name|ctx
argument_list|,
name|op
argument_list|,
name|oend
operator|-
name|op
argument_list|,
name|ip
argument_list|,
name|cBlockSize
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_raw
case|:
name|decodedSize
operator|=
name|ZSTD_copyRawBlock
argument_list|(
name|op
argument_list|,
name|oend
operator|-
name|op
argument_list|,
name|ip
argument_list|,
name|cBlockSize
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_rle
case|:
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
comment|/* not yet supported */
break|break;
case|case
name|bt_end
case|:
comment|/* end of frame */
if|if
condition|(
name|remainingSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
break|break;
default|default:
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
comment|/* impossible */
block|}
if|if
condition|(
name|cBlockSize
operator|==
literal|0
condition|)
break|break;
comment|/* bt_end */
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|decodedSize
argument_list|)
condition|)
return|return
name|decodedSize
return|;
name|op
operator|+=
name|decodedSize
expr_stmt|;
name|ip
operator|+=
name|cBlockSize
expr_stmt|;
name|remainingSize
operator|-=
name|cBlockSize
expr_stmt|;
block|}
return|return
name|op
operator|-
name|ostart
return|;
block|}
specifier|static
name|size_t
name|ZSTD_findFrameCompressedSize
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
decl_stmt|;
name|size_t
name|remainingSize
init|=
name|srcSize
decl_stmt|;
name|blockProperties_t
name|blockProperties
decl_stmt|;
comment|/* Frame Header */
if|if
condition|(
name|srcSize
operator|<
name|ZSTD_frameHeaderSize_min
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
if|if
condition|(
name|MEM_readLE32
argument_list|(
name|src
argument_list|)
operator|!=
name|ZSTD_MAGICNUMBER
condition|)
return|return
name|ERROR
argument_list|(
name|prefix_unknown
argument_list|)
return|;
name|ip
operator|+=
name|ZSTD_frameHeaderSize_min
expr_stmt|;
name|remainingSize
operator|-=
name|ZSTD_frameHeaderSize_min
expr_stmt|;
comment|/* Loop on each block */
while|while
condition|(
literal|1
condition|)
block|{
name|size_t
name|cBlockSize
init|=
name|ZSTD_getcBlockSize
argument_list|(
name|ip
argument_list|,
name|remainingSize
argument_list|,
operator|&
name|blockProperties
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|cBlockSize
argument_list|)
condition|)
return|return
name|cBlockSize
return|;
name|ip
operator|+=
name|ZSTD_blockHeaderSize
expr_stmt|;
name|remainingSize
operator|-=
name|ZSTD_blockHeaderSize
expr_stmt|;
if|if
condition|(
name|cBlockSize
operator|>
name|remainingSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
if|if
condition|(
name|cBlockSize
operator|==
literal|0
condition|)
break|break;
comment|/* bt_end */
name|ip
operator|+=
name|cBlockSize
expr_stmt|;
name|remainingSize
operator|-=
name|cBlockSize
expr_stmt|;
block|}
return|return
name|ip
operator|-
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
return|;
block|}
comment|/* ****************************** *  Streaming Decompression API ********************************/
specifier|static
name|size_t
name|ZSTD_nextSrcSizeToDecompress
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|)
block|{
return|return
name|dctx
operator|->
name|expected
return|;
block|}
specifier|static
name|size_t
name|ZSTD_decompressContinue
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|ctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
comment|/* Sanity check */
if|if
condition|(
name|srcSize
operator|!=
name|ctx
operator|->
name|expected
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|ZSTD_checkContinuity
argument_list|(
name|ctx
argument_list|,
name|dst
argument_list|)
expr_stmt|;
comment|/* Decompress : frame header; part 1 */
switch|switch
condition|(
name|ctx
operator|->
name|stage
condition|)
block|{
case|case
name|ZSTDds_getFrameHeaderSize
case|:
comment|/* get frame header size */
if|if
condition|(
name|srcSize
operator|!=
name|ZSTD_frameHeaderSize_min
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
comment|/* impossible */
name|ctx
operator|->
name|headerSize
operator|=
name|ZSTD_decodeFrameHeader_Part1
argument_list|(
name|ctx
argument_list|,
name|src
argument_list|,
name|ZSTD_frameHeaderSize_min
argument_list|)
expr_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|ctx
operator|->
name|headerSize
argument_list|)
condition|)
return|return
name|ctx
operator|->
name|headerSize
return|;
name|memcpy
argument_list|(
name|ctx
operator|->
name|headerBuffer
argument_list|,
name|src
argument_list|,
name|ZSTD_frameHeaderSize_min
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|headerSize
operator|>
name|ZSTD_frameHeaderSize_min
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
comment|/* impossible */
name|ctx
operator|->
name|expected
operator|=
literal|0
expr_stmt|;
comment|/* not necessary to copy more */
comment|/* fallthrough */
case|case
name|ZSTDds_decodeFrameHeader
case|:
comment|/* get frame header */
block|{
name|size_t
specifier|const
name|result
init|=
name|ZSTD_decodeFrameHeader_Part2
argument_list|(
name|ctx
argument_list|,
name|ctx
operator|->
name|headerBuffer
argument_list|,
name|ctx
operator|->
name|headerSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|result
argument_list|)
condition|)
return|return
name|result
return|;
name|ctx
operator|->
name|expected
operator|=
name|ZSTD_blockHeaderSize
expr_stmt|;
name|ctx
operator|->
name|stage
operator|=
name|ZSTDds_decodeBlockHeader
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
name|ZSTDds_decodeBlockHeader
case|:
comment|/* Decode block header */
block|{
name|blockProperties_t
name|bp
decl_stmt|;
name|size_t
specifier|const
name|blockSize
init|=
name|ZSTD_getcBlockSize
argument_list|(
name|src
argument_list|,
name|ZSTD_blockHeaderSize
argument_list|,
operator|&
name|bp
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|blockSize
argument_list|)
condition|)
return|return
name|blockSize
return|;
if|if
condition|(
name|bp
operator|.
name|blockType
operator|==
name|bt_end
condition|)
block|{
name|ctx
operator|->
name|expected
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|stage
operator|=
name|ZSTDds_getFrameHeaderSize
expr_stmt|;
block|}
else|else
block|{
name|ctx
operator|->
name|expected
operator|=
name|blockSize
expr_stmt|;
name|ctx
operator|->
name|bType
operator|=
name|bp
operator|.
name|blockType
expr_stmt|;
name|ctx
operator|->
name|stage
operator|=
name|ZSTDds_decompressBlock
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
case|case
name|ZSTDds_decompressBlock
case|:
block|{
comment|/* Decompress : block content */
name|size_t
name|rSize
decl_stmt|;
switch|switch
condition|(
name|ctx
operator|->
name|bType
condition|)
block|{
case|case
name|bt_compressed
case|:
name|rSize
operator|=
name|ZSTD_decompressBlock_internal
argument_list|(
name|ctx
argument_list|,
name|dst
argument_list|,
name|maxDstSize
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_raw
case|:
name|rSize
operator|=
name|ZSTD_copyRawBlock
argument_list|(
name|dst
argument_list|,
name|maxDstSize
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_rle
case|:
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
comment|/* not yet handled */
break|break;
case|case
name|bt_end
case|:
comment|/* should never happen (filtered at phase 1) */
name|rSize
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
block|}
name|ctx
operator|->
name|stage
operator|=
name|ZSTDds_decodeBlockHeader
expr_stmt|;
name|ctx
operator|->
name|expected
operator|=
name|ZSTD_blockHeaderSize
expr_stmt|;
name|ctx
operator|->
name|previousDstEnd
operator|=
operator|(
name|char
operator|*
operator|)
name|dst
operator|+
name|rSize
expr_stmt|;
return|return
name|rSize
return|;
block|}
default|default:
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
comment|/* impossible */
block|}
block|}
specifier|static
name|void
name|ZSTD_decompress_insertDictionary
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|)
block|{
name|ctx
operator|->
name|dictEnd
operator|=
name|ctx
operator|->
name|previousDstEnd
expr_stmt|;
name|ctx
operator|->
name|vBase
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|dict
operator|-
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|ctx
operator|->
name|previousDstEnd
operator|)
operator|-
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|ctx
operator|->
name|base
operator|)
operator|)
expr_stmt|;
name|ctx
operator|->
name|base
operator|=
name|dict
expr_stmt|;
name|ctx
operator|->
name|previousDstEnd
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|dict
operator|+
name|dictSize
expr_stmt|;
block|}
comment|/*     Buffered version of Zstd compression library     Copyright (C) 2015, Yann Collet.      BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)      Redistribution and use in source and binary forms, with or without     modification, are permitted provided that the following conditions are     met:     * Redistributions of source code must retain the above copyright     notice, this list of conditions and the following disclaimer.     * Redistributions in binary form must reproduce the above     copyright notice, this list of conditions and the following disclaimer     in the documentation and/or other materials provided with the     distribution.     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS     "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR     A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT     OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT     LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY     THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE     OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.      You can contact the author at :     - zstd source repository : https://github.com/Cyan4973/zstd     - ztsd public forum : https://groups.google.com/forum/#!forum/lz4c */
comment|/* The objects defined into this file should be considered experimental.  * They are not labelled stable, as their prototype may change in the future.  * You can use them for tests, provide feedback, or if you can endure risk of future changes.  */
comment|/* ************************************* *  Includes ***************************************/
include|#
directive|include
file|<stdlib.h>
comment|/** ************************************************ *  Streaming decompression * *  A ZBUFF_DCtx object is required to track streaming operation. *  Use ZBUFF_createDCtx() and ZBUFF_freeDCtx() to create/release resources. *  Use ZBUFF_decompressInit() to start a new decompression operation. *  ZBUFF_DCtx objects can be reused multiple times. * *  Use ZBUFF_decompressContinue() repetitively to consume your input. *  *srcSizePtr and *maxDstSizePtr can be any size. *  The function will report how many bytes were read or written by modifying *srcSizePtr and *maxDstSizePtr. *  Note that it may not consume the entire input, in which case it's up to the caller to call again the function with remaining input. *  The content of dst will be overwritten (up to *maxDstSizePtr) at each function call, so save its content if it matters or change dst . *  return : a hint to preferred nb of bytes to use as input for next function call (it's only a hint, to improve latency) *            or 0 when a frame is completely decoded *            or an error code, which can be tested using ZBUFF_isError(). * *  Hint : recommended buffer sizes (not compulsory) *  output : 128 KB block size is the internal unit, it ensures it's always possible to write a full block when it's decoded. *  input : just follow indications from ZBUFF_decompressContinue() to minimize latency. It should always be<= 128 KB + 3 . * **************************************************/
typedef|typedef
enum|enum
block|{
name|ZBUFFds_init
block|,
name|ZBUFFds_readHeader
block|,
name|ZBUFFds_loadHeader
block|,
name|ZBUFFds_decodeHeader
block|,
name|ZBUFFds_read
block|,
name|ZBUFFds_load
block|,
name|ZBUFFds_flush
block|}
name|ZBUFF_dStage
typedef|;
comment|/* *** Resource management *** */
define|#
directive|define
name|ZSTD_frameHeaderSize_max
value|5
comment|/* too magical, should come from reference */
struct|struct
name|ZBUFFv04_DCtx_s
block|{
name|ZSTD_DCtx
modifier|*
name|zc
decl_stmt|;
name|ZSTD_parameters
name|params
decl_stmt|;
name|char
modifier|*
name|inBuff
decl_stmt|;
name|size_t
name|inBuffSize
decl_stmt|;
name|size_t
name|inPos
decl_stmt|;
name|char
modifier|*
name|outBuff
decl_stmt|;
name|size_t
name|outBuffSize
decl_stmt|;
name|size_t
name|outStart
decl_stmt|;
name|size_t
name|outEnd
decl_stmt|;
name|size_t
name|hPos
decl_stmt|;
specifier|const
name|char
modifier|*
name|dict
decl_stmt|;
name|size_t
name|dictSize
decl_stmt|;
name|ZBUFF_dStage
name|stage
decl_stmt|;
name|unsigned
name|char
name|headerBuffer
index|[
name|ZSTD_frameHeaderSize_max
index|]
decl_stmt|;
block|}
struct|;
comment|/* typedef'd to ZBUFF_DCtx within "zstd_buffered.h" */
typedef|typedef
name|ZBUFFv04_DCtx
name|ZBUFF_DCtx
typedef|;
specifier|static
name|ZBUFF_DCtx
modifier|*
name|ZBUFF_createDCtx
parameter_list|(
name|void
parameter_list|)
block|{
name|ZBUFF_DCtx
modifier|*
name|zbc
init|=
operator|(
name|ZBUFF_DCtx
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ZBUFF_DCtx
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|zbc
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|zbc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|zbc
argument_list|)
argument_list|)
expr_stmt|;
name|zbc
operator|->
name|zc
operator|=
name|ZSTD_createDCtx
argument_list|()
expr_stmt|;
name|zbc
operator|->
name|stage
operator|=
name|ZBUFFds_init
expr_stmt|;
return|return
name|zbc
return|;
block|}
specifier|static
name|size_t
name|ZBUFF_freeDCtx
parameter_list|(
name|ZBUFF_DCtx
modifier|*
name|zbc
parameter_list|)
block|{
if|if
condition|(
name|zbc
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* support free on null */
name|ZSTD_freeDCtx
argument_list|(
name|zbc
operator|->
name|zc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zbc
operator|->
name|inBuff
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zbc
operator|->
name|outBuff
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zbc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* *** Initialization *** */
specifier|static
name|size_t
name|ZBUFF_decompressInit
parameter_list|(
name|ZBUFF_DCtx
modifier|*
name|zbc
parameter_list|)
block|{
name|zbc
operator|->
name|stage
operator|=
name|ZBUFFds_readHeader
expr_stmt|;
name|zbc
operator|->
name|hPos
operator|=
name|zbc
operator|->
name|inPos
operator|=
name|zbc
operator|->
name|outStart
operator|=
name|zbc
operator|->
name|outEnd
operator|=
name|zbc
operator|->
name|dictSize
operator|=
literal|0
expr_stmt|;
return|return
name|ZSTD_resetDCtx
argument_list|(
name|zbc
operator|->
name|zc
argument_list|)
return|;
block|}
specifier|static
name|size_t
name|ZBUFF_decompressWithDictionary
parameter_list|(
name|ZBUFF_DCtx
modifier|*
name|zbc
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
name|zbc
operator|->
name|dict
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|src
expr_stmt|;
name|zbc
operator|->
name|dictSize
operator|=
name|srcSize
expr_stmt|;
return|return
literal|0
return|;
block|}
specifier|static
name|size_t
name|ZBUFF_limitCopy
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
name|size_t
name|length
init|=
name|MIN
argument_list|(
name|maxDstSize
argument_list|,
name|srcSize
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
comment|/* *** Decompression *** */
specifier|static
name|size_t
name|ZBUFF_decompressContinue
parameter_list|(
name|ZBUFF_DCtx
modifier|*
name|zbc
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
modifier|*
name|maxDstSizePtr
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
modifier|*
name|srcSizePtr
parameter_list|)
block|{
specifier|const
name|char
modifier|*
specifier|const
name|istart
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|src
decl_stmt|;
specifier|const
name|char
modifier|*
name|ip
init|=
name|istart
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|iend
init|=
name|istart
operator|+
operator|*
name|srcSizePtr
decl_stmt|;
name|char
modifier|*
specifier|const
name|ostart
init|=
operator|(
name|char
operator|*
operator|)
name|dst
decl_stmt|;
name|char
modifier|*
name|op
init|=
name|ostart
decl_stmt|;
name|char
modifier|*
specifier|const
name|oend
init|=
name|ostart
operator|+
operator|*
name|maxDstSizePtr
decl_stmt|;
name|U32
name|notDone
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|notDone
condition|)
block|{
switch|switch
condition|(
name|zbc
operator|->
name|stage
condition|)
block|{
case|case
name|ZBUFFds_init
case|:
return|return
name|ERROR
argument_list|(
name|init_missing
argument_list|)
return|;
case|case
name|ZBUFFds_readHeader
case|:
comment|/* read header from src */
block|{
name|size_t
specifier|const
name|headerSize
init|=
name|ZSTD_getFrameParams
argument_list|(
operator|&
operator|(
name|zbc
operator|->
name|params
operator|)
argument_list|,
name|src
argument_list|,
operator|*
name|srcSizePtr
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|headerSize
argument_list|)
condition|)
return|return
name|headerSize
return|;
if|if
condition|(
name|headerSize
condition|)
block|{
comment|/* not enough input to decode header : tell how many bytes would be necessary */
name|memcpy
argument_list|(
name|zbc
operator|->
name|headerBuffer
operator|+
name|zbc
operator|->
name|hPos
argument_list|,
name|src
argument_list|,
operator|*
name|srcSizePtr
argument_list|)
expr_stmt|;
name|zbc
operator|->
name|hPos
operator|+=
operator|*
name|srcSizePtr
expr_stmt|;
operator|*
name|maxDstSizePtr
operator|=
literal|0
expr_stmt|;
name|zbc
operator|->
name|stage
operator|=
name|ZBUFFds_loadHeader
expr_stmt|;
return|return
name|headerSize
operator|-
name|zbc
operator|->
name|hPos
return|;
block|}
name|zbc
operator|->
name|stage
operator|=
name|ZBUFFds_decodeHeader
expr_stmt|;
break|break;
block|}
case|case
name|ZBUFFds_loadHeader
case|:
comment|/* complete header from src */
block|{
name|size_t
name|headerSize
init|=
name|ZBUFF_limitCopy
argument_list|(
name|zbc
operator|->
name|headerBuffer
operator|+
name|zbc
operator|->
name|hPos
argument_list|,
name|ZSTD_frameHeaderSize_max
operator|-
name|zbc
operator|->
name|hPos
argument_list|,
name|src
argument_list|,
operator|*
name|srcSizePtr
argument_list|)
decl_stmt|;
name|zbc
operator|->
name|hPos
operator|+=
name|headerSize
expr_stmt|;
name|ip
operator|+=
name|headerSize
expr_stmt|;
name|headerSize
operator|=
name|ZSTD_getFrameParams
argument_list|(
operator|&
operator|(
name|zbc
operator|->
name|params
operator|)
argument_list|,
name|zbc
operator|->
name|headerBuffer
argument_list|,
name|zbc
operator|->
name|hPos
argument_list|)
expr_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|headerSize
argument_list|)
condition|)
return|return
name|headerSize
return|;
if|if
condition|(
name|headerSize
condition|)
block|{
comment|/* not enough input to decode header : tell how many bytes would be necessary */
operator|*
name|maxDstSizePtr
operator|=
literal|0
expr_stmt|;
return|return
name|headerSize
operator|-
name|zbc
operator|->
name|hPos
return|;
block|}
block|}
comment|/* intentional fallthrough */
case|case
name|ZBUFFds_decodeHeader
case|:
comment|/* apply header to create / resize buffers */
block|{
name|size_t
specifier|const
name|neededOutSize
init|=
operator|(
name|size_t
operator|)
literal|1
operator|<<
name|zbc
operator|->
name|params
operator|.
name|windowLog
decl_stmt|;
name|size_t
specifier|const
name|neededInSize
init|=
name|BLOCKSIZE
decl_stmt|;
comment|/* a block is never> BLOCKSIZE */
if|if
condition|(
name|zbc
operator|->
name|inBuffSize
operator|<
name|neededInSize
condition|)
block|{
name|free
argument_list|(
name|zbc
operator|->
name|inBuff
argument_list|)
expr_stmt|;
name|zbc
operator|->
name|inBuffSize
operator|=
name|neededInSize
expr_stmt|;
name|zbc
operator|->
name|inBuff
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|neededInSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|zbc
operator|->
name|inBuff
operator|==
name|NULL
condition|)
return|return
name|ERROR
argument_list|(
name|memory_allocation
argument_list|)
return|;
block|}
if|if
condition|(
name|zbc
operator|->
name|outBuffSize
operator|<
name|neededOutSize
condition|)
block|{
name|free
argument_list|(
name|zbc
operator|->
name|outBuff
argument_list|)
expr_stmt|;
name|zbc
operator|->
name|outBuffSize
operator|=
name|neededOutSize
expr_stmt|;
name|zbc
operator|->
name|outBuff
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|neededOutSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|zbc
operator|->
name|outBuff
operator|==
name|NULL
condition|)
return|return
name|ERROR
argument_list|(
name|memory_allocation
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|zbc
operator|->
name|dictSize
condition|)
name|ZSTD_decompress_insertDictionary
argument_list|(
name|zbc
operator|->
name|zc
argument_list|,
name|zbc
operator|->
name|dict
argument_list|,
name|zbc
operator|->
name|dictSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|zbc
operator|->
name|hPos
condition|)
block|{
comment|/* some data already loaded into headerBuffer : transfer into inBuff */
name|memcpy
argument_list|(
name|zbc
operator|->
name|inBuff
argument_list|,
name|zbc
operator|->
name|headerBuffer
argument_list|,
name|zbc
operator|->
name|hPos
argument_list|)
expr_stmt|;
name|zbc
operator|->
name|inPos
operator|=
name|zbc
operator|->
name|hPos
expr_stmt|;
name|zbc
operator|->
name|hPos
operator|=
literal|0
expr_stmt|;
name|zbc
operator|->
name|stage
operator|=
name|ZBUFFds_load
expr_stmt|;
break|break;
block|}
name|zbc
operator|->
name|stage
operator|=
name|ZBUFFds_read
expr_stmt|;
case|case
name|ZBUFFds_read
case|:
block|{
name|size_t
name|neededInSize
init|=
name|ZSTD_nextSrcSizeToDecompress
argument_list|(
name|zbc
operator|->
name|zc
argument_list|)
decl_stmt|;
if|if
condition|(
name|neededInSize
operator|==
literal|0
condition|)
comment|/* end of frame */
block|{
name|zbc
operator|->
name|stage
operator|=
name|ZBUFFds_init
expr_stmt|;
name|notDone
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|iend
operator|-
name|ip
argument_list|)
operator|>=
name|neededInSize
condition|)
block|{
comment|/* directly decode from src */
name|size_t
name|decodedSize
init|=
name|ZSTD_decompressContinue
argument_list|(
name|zbc
operator|->
name|zc
argument_list|,
name|zbc
operator|->
name|outBuff
operator|+
name|zbc
operator|->
name|outStart
argument_list|,
name|zbc
operator|->
name|outBuffSize
operator|-
name|zbc
operator|->
name|outStart
argument_list|,
name|ip
argument_list|,
name|neededInSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|decodedSize
argument_list|)
condition|)
return|return
name|decodedSize
return|;
name|ip
operator|+=
name|neededInSize
expr_stmt|;
if|if
condition|(
operator|!
name|decodedSize
condition|)
break|break;
comment|/* this was just a header */
name|zbc
operator|->
name|outEnd
operator|=
name|zbc
operator|->
name|outStart
operator|+
name|decodedSize
expr_stmt|;
name|zbc
operator|->
name|stage
operator|=
name|ZBUFFds_flush
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ip
operator|==
name|iend
condition|)
block|{
name|notDone
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* no more input */
name|zbc
operator|->
name|stage
operator|=
name|ZBUFFds_load
expr_stmt|;
block|}
case|case
name|ZBUFFds_load
case|:
block|{
name|size_t
name|neededInSize
init|=
name|ZSTD_nextSrcSizeToDecompress
argument_list|(
name|zbc
operator|->
name|zc
argument_list|)
decl_stmt|;
name|size_t
name|toLoad
init|=
name|neededInSize
operator|-
name|zbc
operator|->
name|inPos
decl_stmt|;
comment|/* should always be<= remaining space within inBuff */
name|size_t
name|loadedSize
decl_stmt|;
if|if
condition|(
name|toLoad
operator|>
name|zbc
operator|->
name|inBuffSize
operator|-
name|zbc
operator|->
name|inPos
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* should never happen */
name|loadedSize
operator|=
name|ZBUFF_limitCopy
argument_list|(
name|zbc
operator|->
name|inBuff
operator|+
name|zbc
operator|->
name|inPos
argument_list|,
name|toLoad
argument_list|,
name|ip
argument_list|,
name|iend
operator|-
name|ip
argument_list|)
expr_stmt|;
name|ip
operator|+=
name|loadedSize
expr_stmt|;
name|zbc
operator|->
name|inPos
operator|+=
name|loadedSize
expr_stmt|;
if|if
condition|(
name|loadedSize
operator|<
name|toLoad
condition|)
block|{
name|notDone
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* not enough input, wait for more */
block|{
name|size_t
name|decodedSize
init|=
name|ZSTD_decompressContinue
argument_list|(
name|zbc
operator|->
name|zc
argument_list|,
name|zbc
operator|->
name|outBuff
operator|+
name|zbc
operator|->
name|outStart
argument_list|,
name|zbc
operator|->
name|outBuffSize
operator|-
name|zbc
operator|->
name|outStart
argument_list|,
name|zbc
operator|->
name|inBuff
argument_list|,
name|neededInSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|decodedSize
argument_list|)
condition|)
return|return
name|decodedSize
return|;
name|zbc
operator|->
name|inPos
operator|=
literal|0
expr_stmt|;
comment|/* input is consumed */
if|if
condition|(
operator|!
name|decodedSize
condition|)
block|{
name|zbc
operator|->
name|stage
operator|=
name|ZBUFFds_read
expr_stmt|;
break|break;
block|}
comment|/* this was just a header */
name|zbc
operator|->
name|outEnd
operator|=
name|zbc
operator|->
name|outStart
operator|+
name|decodedSize
expr_stmt|;
name|zbc
operator|->
name|stage
operator|=
name|ZBUFFds_flush
expr_stmt|;
comment|// break; /* ZBUFFds_flush follows */
block|}
block|}
case|case
name|ZBUFFds_flush
case|:
block|{
name|size_t
name|toFlushSize
init|=
name|zbc
operator|->
name|outEnd
operator|-
name|zbc
operator|->
name|outStart
decl_stmt|;
name|size_t
name|flushedSize
init|=
name|ZBUFF_limitCopy
argument_list|(
name|op
argument_list|,
name|oend
operator|-
name|op
argument_list|,
name|zbc
operator|->
name|outBuff
operator|+
name|zbc
operator|->
name|outStart
argument_list|,
name|toFlushSize
argument_list|)
decl_stmt|;
name|op
operator|+=
name|flushedSize
expr_stmt|;
name|zbc
operator|->
name|outStart
operator|+=
name|flushedSize
expr_stmt|;
if|if
condition|(
name|flushedSize
operator|==
name|toFlushSize
condition|)
block|{
name|zbc
operator|->
name|stage
operator|=
name|ZBUFFds_read
expr_stmt|;
if|if
condition|(
name|zbc
operator|->
name|outStart
operator|+
name|BLOCKSIZE
operator|>
name|zbc
operator|->
name|outBuffSize
condition|)
name|zbc
operator|->
name|outStart
operator|=
name|zbc
operator|->
name|outEnd
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* cannot flush everything */
name|notDone
operator|=
literal|0
expr_stmt|;
break|break;
block|}
default|default:
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
comment|/* impossible */
block|}
block|}
operator|*
name|srcSizePtr
operator|=
name|ip
operator|-
name|istart
expr_stmt|;
operator|*
name|maxDstSizePtr
operator|=
name|op
operator|-
name|ostart
expr_stmt|;
block|{
name|size_t
name|nextSrcSizeHint
init|=
name|ZSTD_nextSrcSizeToDecompress
argument_list|(
name|zbc
operator|->
name|zc
argument_list|)
decl_stmt|;
if|if
condition|(
name|nextSrcSizeHint
operator|>
literal|3
condition|)
name|nextSrcSizeHint
operator|+=
literal|3
expr_stmt|;
comment|/* get the next block header while at it */
name|nextSrcSizeHint
operator|-=
name|zbc
operator|->
name|inPos
expr_stmt|;
comment|/* already loaded*/
return|return
name|nextSrcSizeHint
return|;
block|}
block|}
comment|/* ************************************* *  Tool functions ***************************************/
name|unsigned
name|ZBUFFv04_isError
parameter_list|(
name|size_t
name|errorCode
parameter_list|)
block|{
return|return
name|ERR_isError
argument_list|(
name|errorCode
argument_list|)
return|;
block|}
specifier|const
name|char
modifier|*
name|ZBUFFv04_getErrorName
parameter_list|(
name|size_t
name|errorCode
parameter_list|)
block|{
return|return
name|ERR_getErrorName
argument_list|(
name|errorCode
argument_list|)
return|;
block|}
name|size_t
name|ZBUFFv04_recommendedDInSize
parameter_list|()
block|{
return|return
name|BLOCKSIZE
operator|+
literal|3
return|;
block|}
name|size_t
name|ZBUFFv04_recommendedDOutSize
parameter_list|()
block|{
return|return
name|BLOCKSIZE
return|;
block|}
comment|/*- ========================================================================= -*/
comment|/* final wrapping stage */
name|size_t
name|ZSTDv04_decompressDCtx
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
return|return
name|ZSTD_decompress_usingDict
argument_list|(
name|dctx
argument_list|,
name|dst
argument_list|,
name|maxDstSize
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|size_t
name|ZSTDv04_decompress
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|ZSTD_HEAPMODE
argument_list|)
operator|&&
operator|(
name|ZSTD_HEAPMODE
operator|==
literal|1
operator|)
name|size_t
name|regenSize
decl_stmt|;
name|ZSTD_DCtx
modifier|*
name|dctx
init|=
name|ZSTD_createDCtx
argument_list|()
decl_stmt|;
if|if
condition|(
name|dctx
operator|==
name|NULL
condition|)
return|return
name|ERROR
argument_list|(
name|memory_allocation
argument_list|)
return|;
name|regenSize
operator|=
name|ZSTDv04_decompressDCtx
argument_list|(
name|dctx
argument_list|,
name|dst
argument_list|,
name|maxDstSize
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
expr_stmt|;
name|ZSTD_freeDCtx
argument_list|(
name|dctx
argument_list|)
expr_stmt|;
return|return
name|regenSize
return|;
else|#
directive|else
name|ZSTD_DCtx
name|dctx
decl_stmt|;
return|return
name|ZSTDv04_decompressDCtx
argument_list|(
operator|&
name|dctx
argument_list|,
name|dst
argument_list|,
name|maxDstSize
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
return|;
endif|#
directive|endif
block|}
name|size_t
name|ZSTDv04_findFrameCompressedSize
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
return|return
name|ZSTD_findFrameCompressedSize
argument_list|(
name|src
argument_list|,
name|srcSize
argument_list|)
return|;
block|}
name|size_t
name|ZSTDv04_resetDCtx
parameter_list|(
name|ZSTDv04_Dctx
modifier|*
name|dctx
parameter_list|)
block|{
return|return
name|ZSTD_resetDCtx
argument_list|(
name|dctx
argument_list|)
return|;
block|}
name|size_t
name|ZSTDv04_nextSrcSizeToDecompress
parameter_list|(
name|ZSTDv04_Dctx
modifier|*
name|dctx
parameter_list|)
block|{
return|return
name|ZSTD_nextSrcSizeToDecompress
argument_list|(
name|dctx
argument_list|)
return|;
block|}
name|size_t
name|ZSTDv04_decompressContinue
parameter_list|(
name|ZSTDv04_Dctx
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
return|return
name|ZSTD_decompressContinue
argument_list|(
name|dctx
argument_list|,
name|dst
argument_list|,
name|maxDstSize
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
return|;
block|}
name|ZBUFFv04_DCtx
modifier|*
name|ZBUFFv04_createDCtx
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|ZBUFF_createDCtx
argument_list|()
return|;
block|}
name|size_t
name|ZBUFFv04_freeDCtx
parameter_list|(
name|ZBUFFv04_DCtx
modifier|*
name|dctx
parameter_list|)
block|{
return|return
name|ZBUFF_freeDCtx
argument_list|(
name|dctx
argument_list|)
return|;
block|}
name|size_t
name|ZBUFFv04_decompressInit
parameter_list|(
name|ZBUFFv04_DCtx
modifier|*
name|dctx
parameter_list|)
block|{
return|return
name|ZBUFF_decompressInit
argument_list|(
name|dctx
argument_list|)
return|;
block|}
name|size_t
name|ZBUFFv04_decompressWithDictionary
parameter_list|(
name|ZBUFFv04_DCtx
modifier|*
name|dctx
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
return|return
name|ZBUFF_decompressWithDictionary
argument_list|(
name|dctx
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
return|;
block|}
name|size_t
name|ZBUFFv04_decompressContinue
parameter_list|(
name|ZBUFFv04_DCtx
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
modifier|*
name|maxDstSizePtr
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
modifier|*
name|srcSizePtr
parameter_list|)
block|{
return|return
name|ZBUFF_decompressContinue
argument_list|(
name|dctx
argument_list|,
name|dst
argument_list|,
name|maxDstSizePtr
argument_list|,
name|src
argument_list|,
name|srcSizePtr
argument_list|)
return|;
block|}
name|ZSTD_DCtx
modifier|*
name|ZSTDv04_createDCtx
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|ZSTD_createDCtx
argument_list|()
return|;
block|}
name|size_t
name|ZSTDv04_freeDCtx
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|)
block|{
return|return
name|ZSTD_freeDCtx
argument_list|(
name|dctx
argument_list|)
return|;
block|}
name|size_t
name|ZSTDv04_getFrameParams
parameter_list|(
name|ZSTD_parameters
modifier|*
name|params
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
return|return
name|ZSTD_getFrameParams
argument_list|(
name|params
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
return|;
block|}
end_extern

end_unit

