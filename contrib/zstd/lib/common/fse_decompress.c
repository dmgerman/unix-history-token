begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ******************************************************************    FSE : Finite State Entropy decoder    Copyright (C) 2013-2015, Yann Collet.     BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)     Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are    met:         * Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer.        * Redistributions in binary form must reproduce the above    copyright notice, this list of conditions and the following disclaimer    in the documentation and/or other materials provided with the    distribution.     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.      You can contact the author at :     - FSE source repository : https://github.com/Cyan4973/FiniteStateEntropy     - Public forum : https://groups.google.com/forum/#!forum/lz4c ****************************************************************** */
end_comment

begin_comment
comment|/* ************************************************************** *  Compiler specifics ****************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_comment
comment|/* Visual Studio */
end_comment

begin_define
define|#
directive|define
name|FORCE_INLINE
value|static __forceinline
end_define

begin_include
include|#
directive|include
file|<intrin.h>
end_include

begin_comment
comment|/* For Visual 2005 */
end_comment

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4127
name|)
end_pragma

begin_comment
comment|/* disable: C4127: conditional expression is constant */
end_comment

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4214
name|)
end_pragma

begin_comment
comment|/* disable: C4214: non-int bitfields */
end_comment

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
operator|||
name|defined
argument_list|(
name|__STDC_VERSION__
argument_list|)
operator|&&
name|__STDC_VERSION__
operator|>=
literal|199901L
end_if

begin_comment
comment|/* C99 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|FORCE_INLINE
value|static inline __attribute__((always_inline))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FORCE_INLINE
value|static inline
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FORCE_INLINE
value|static
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __STDC_VERSION__ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ************************************************************** *  Includes ****************************************************************/
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* malloc, free, qsort */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* memcpy, memset */
end_comment

begin_include
include|#
directive|include
file|"bitstream.h"
end_include

begin_define
define|#
directive|define
name|FSE_STATIC_LINKING_ONLY
end_define

begin_include
include|#
directive|include
file|"fse.h"
end_include

begin_comment
comment|/* ************************************************************** *  Error Management ****************************************************************/
end_comment

begin_define
define|#
directive|define
name|FSE_isError
value|ERR_isError
end_define

begin_define
define|#
directive|define
name|FSE_STATIC_ASSERT
parameter_list|(
name|c
parameter_list|)
value|{ enum { FSE_static_assert = 1/(int)(!!(c)) }; }
end_define

begin_comment
comment|/* use only *after* variable declarations */
end_comment

begin_comment
comment|/* check and forward error code */
end_comment

begin_define
define|#
directive|define
name|CHECK_F
parameter_list|(
name|f
parameter_list|)
value|{ size_t const e = f; if (FSE_isError(e)) return e; }
end_define

begin_comment
comment|/* ************************************************************** *  Templates ****************************************************************/
end_comment

begin_comment
comment|/*   designed to be included   for type-specific functions (template emulation in C)   Objective is to write these functions only once, for improved maintenance */
end_comment

begin_comment
comment|/* safety checks */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FSE_FUNCTION_EXTENSION
end_ifndef

begin_error
error|#
directive|error
literal|"FSE_FUNCTION_EXTENSION must be defined"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FSE_FUNCTION_TYPE
end_ifndef

begin_error
error|#
directive|error
literal|"FSE_FUNCTION_TYPE must be defined"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Function names */
end_comment

begin_define
define|#
directive|define
name|FSE_CAT
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|X##Y
end_define

begin_define
define|#
directive|define
name|FSE_FUNCTION_NAME
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|FSE_CAT(X,Y)
end_define

begin_define
define|#
directive|define
name|FSE_TYPE_NAME
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|FSE_CAT(X,Y)
end_define

begin_comment
comment|/* Function templates */
end_comment

begin_function
name|FSE_DTable
modifier|*
name|FSE_createDTable
parameter_list|(
name|unsigned
name|tableLog
parameter_list|)
block|{
if|if
condition|(
name|tableLog
operator|>
name|FSE_TABLELOG_ABSOLUTE_MAX
condition|)
name|tableLog
operator|=
name|FSE_TABLELOG_ABSOLUTE_MAX
expr_stmt|;
return|return
operator|(
name|FSE_DTable
operator|*
operator|)
name|malloc
argument_list|(
name|FSE_DTABLE_SIZE_U32
argument_list|(
name|tableLog
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|FSE_freeDTable
parameter_list|(
name|FSE_DTable
modifier|*
name|dt
parameter_list|)
block|{
name|free
argument_list|(
name|dt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|size_t
name|FSE_buildDTable
parameter_list|(
name|FSE_DTable
modifier|*
name|dt
parameter_list|,
specifier|const
name|short
modifier|*
name|normalizedCounter
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|,
name|unsigned
name|tableLog
parameter_list|)
block|{
name|void
modifier|*
specifier|const
name|tdPtr
init|=
name|dt
operator|+
literal|1
decl_stmt|;
comment|/* because *dt is unsigned, 32-bits aligned on 32-bits */
name|FSE_DECODE_TYPE
modifier|*
specifier|const
name|tableDecode
init|=
operator|(
name|FSE_DECODE_TYPE
operator|*
operator|)
operator|(
name|tdPtr
operator|)
decl_stmt|;
name|U16
name|symbolNext
index|[
name|FSE_MAX_SYMBOL_VALUE
operator|+
literal|1
index|]
decl_stmt|;
name|U32
specifier|const
name|maxSV1
init|=
name|maxSymbolValue
operator|+
literal|1
decl_stmt|;
name|U32
specifier|const
name|tableSize
init|=
literal|1
operator|<<
name|tableLog
decl_stmt|;
name|U32
name|highThreshold
init|=
name|tableSize
operator|-
literal|1
decl_stmt|;
comment|/* Sanity Checks */
if|if
condition|(
name|maxSymbolValue
operator|>
name|FSE_MAX_SYMBOL_VALUE
condition|)
return|return
name|ERROR
argument_list|(
name|maxSymbolValue_tooLarge
argument_list|)
return|;
if|if
condition|(
name|tableLog
operator|>
name|FSE_MAX_TABLELOG
condition|)
return|return
name|ERROR
argument_list|(
name|tableLog_tooLarge
argument_list|)
return|;
comment|/* Init, lay down lowprob symbols */
block|{
name|FSE_DTableHeader
name|DTableH
decl_stmt|;
name|DTableH
operator|.
name|tableLog
operator|=
operator|(
name|U16
operator|)
name|tableLog
expr_stmt|;
name|DTableH
operator|.
name|fastMode
operator|=
literal|1
expr_stmt|;
block|{
name|S16
specifier|const
name|largeLimit
init|=
call|(
name|S16
call|)
argument_list|(
literal|1
operator|<<
operator|(
name|tableLog
operator|-
literal|1
operator|)
argument_list|)
decl_stmt|;
name|U32
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|maxSV1
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|normalizedCounter
index|[
name|s
index|]
operator|==
operator|-
literal|1
condition|)
block|{
name|tableDecode
index|[
name|highThreshold
operator|--
index|]
operator|.
name|symbol
operator|=
operator|(
name|FSE_FUNCTION_TYPE
operator|)
name|s
expr_stmt|;
name|symbolNext
index|[
name|s
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|normalizedCounter
index|[
name|s
index|]
operator|>=
name|largeLimit
condition|)
name|DTableH
operator|.
name|fastMode
operator|=
literal|0
expr_stmt|;
name|symbolNext
index|[
name|s
index|]
operator|=
name|normalizedCounter
index|[
name|s
index|]
expr_stmt|;
block|}
block|}
block|}
name|memcpy
argument_list|(
name|dt
argument_list|,
operator|&
name|DTableH
argument_list|,
sizeof|sizeof
argument_list|(
name|DTableH
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Spread symbols */
block|{
name|U32
specifier|const
name|tableMask
init|=
name|tableSize
operator|-
literal|1
decl_stmt|;
name|U32
specifier|const
name|step
init|=
name|FSE_TABLESTEP
argument_list|(
name|tableSize
argument_list|)
decl_stmt|;
name|U32
name|s
decl_stmt|,
name|position
init|=
literal|0
decl_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|maxSV1
condition|;
name|s
operator|++
control|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|normalizedCounter
index|[
name|s
index|]
condition|;
name|i
operator|++
control|)
block|{
name|tableDecode
index|[
name|position
index|]
operator|.
name|symbol
operator|=
operator|(
name|FSE_FUNCTION_TYPE
operator|)
name|s
expr_stmt|;
name|position
operator|=
operator|(
name|position
operator|+
name|step
operator|)
operator|&
name|tableMask
expr_stmt|;
while|while
condition|(
name|position
operator|>
name|highThreshold
condition|)
name|position
operator|=
operator|(
name|position
operator|+
name|step
operator|)
operator|&
name|tableMask
expr_stmt|;
comment|/* lowprob area */
block|}
block|}
if|if
condition|(
name|position
operator|!=
literal|0
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
comment|/* position must reach all cells once, otherwise normalizedCounter is incorrect */
block|}
comment|/* Build Decoding table */
block|{
name|U32
name|u
decl_stmt|;
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|tableSize
condition|;
name|u
operator|++
control|)
block|{
name|FSE_FUNCTION_TYPE
specifier|const
name|symbol
init|=
call|(
name|FSE_FUNCTION_TYPE
call|)
argument_list|(
name|tableDecode
index|[
name|u
index|]
operator|.
name|symbol
argument_list|)
decl_stmt|;
name|U16
name|nextState
init|=
name|symbolNext
index|[
name|symbol
index|]
operator|++
decl_stmt|;
name|tableDecode
index|[
name|u
index|]
operator|.
name|nbBits
operator|=
call|(
name|BYTE
call|)
argument_list|(
name|tableLog
operator|-
name|BIT_highbit32
argument_list|(
operator|(
name|U32
operator|)
name|nextState
argument_list|)
argument_list|)
expr_stmt|;
name|tableDecode
index|[
name|u
index|]
operator|.
name|newState
operator|=
call|(
name|U16
call|)
argument_list|(
operator|(
name|nextState
operator|<<
name|tableDecode
index|[
name|u
index|]
operator|.
name|nbBits
operator|)
operator|-
name|tableSize
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|FSE_COMMONDEFS_ONLY
end_ifndef

begin_comment
comment|/*-******************************************************* *  Decompression (Byte symbols) *********************************************************/
end_comment

begin_function
name|size_t
name|FSE_buildDTable_rle
parameter_list|(
name|FSE_DTable
modifier|*
name|dt
parameter_list|,
name|BYTE
name|symbolValue
parameter_list|)
block|{
name|void
modifier|*
name|ptr
init|=
name|dt
decl_stmt|;
name|FSE_DTableHeader
modifier|*
specifier|const
name|DTableH
init|=
operator|(
name|FSE_DTableHeader
operator|*
operator|)
name|ptr
decl_stmt|;
name|void
modifier|*
name|dPtr
init|=
name|dt
operator|+
literal|1
decl_stmt|;
name|FSE_decode_t
modifier|*
specifier|const
name|cell
init|=
operator|(
name|FSE_decode_t
operator|*
operator|)
name|dPtr
decl_stmt|;
name|DTableH
operator|->
name|tableLog
operator|=
literal|0
expr_stmt|;
name|DTableH
operator|->
name|fastMode
operator|=
literal|0
expr_stmt|;
name|cell
operator|->
name|newState
operator|=
literal|0
expr_stmt|;
name|cell
operator|->
name|symbol
operator|=
name|symbolValue
expr_stmt|;
name|cell
operator|->
name|nbBits
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|size_t
name|FSE_buildDTable_raw
parameter_list|(
name|FSE_DTable
modifier|*
name|dt
parameter_list|,
name|unsigned
name|nbBits
parameter_list|)
block|{
name|void
modifier|*
name|ptr
init|=
name|dt
decl_stmt|;
name|FSE_DTableHeader
modifier|*
specifier|const
name|DTableH
init|=
operator|(
name|FSE_DTableHeader
operator|*
operator|)
name|ptr
decl_stmt|;
name|void
modifier|*
name|dPtr
init|=
name|dt
operator|+
literal|1
decl_stmt|;
name|FSE_decode_t
modifier|*
specifier|const
name|dinfo
init|=
operator|(
name|FSE_decode_t
operator|*
operator|)
name|dPtr
decl_stmt|;
specifier|const
name|unsigned
name|tableSize
init|=
literal|1
operator|<<
name|nbBits
decl_stmt|;
specifier|const
name|unsigned
name|tableMask
init|=
name|tableSize
operator|-
literal|1
decl_stmt|;
specifier|const
name|unsigned
name|maxSV1
init|=
name|tableMask
operator|+
literal|1
decl_stmt|;
name|unsigned
name|s
decl_stmt|;
comment|/* Sanity checks */
if|if
condition|(
name|nbBits
operator|<
literal|1
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
comment|/* min size */
comment|/* Build Decoding Table */
name|DTableH
operator|->
name|tableLog
operator|=
operator|(
name|U16
operator|)
name|nbBits
expr_stmt|;
name|DTableH
operator|->
name|fastMode
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|maxSV1
condition|;
name|s
operator|++
control|)
block|{
name|dinfo
index|[
name|s
index|]
operator|.
name|newState
operator|=
literal|0
expr_stmt|;
name|dinfo
index|[
name|s
index|]
operator|.
name|symbol
operator|=
operator|(
name|BYTE
operator|)
name|s
expr_stmt|;
name|dinfo
index|[
name|s
index|]
operator|.
name|nbBits
operator|=
operator|(
name|BYTE
operator|)
name|nbBits
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|FORCE_INLINE
name|size_t
name|FSE_decompress_usingDTable_generic
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|FSE_DTable
modifier|*
name|dt
parameter_list|,
specifier|const
name|unsigned
name|fast
parameter_list|)
block|{
name|BYTE
modifier|*
specifier|const
name|ostart
init|=
operator|(
name|BYTE
operator|*
operator|)
name|dst
decl_stmt|;
name|BYTE
modifier|*
name|op
init|=
name|ostart
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|omax
init|=
name|op
operator|+
name|maxDstSize
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|olimit
init|=
name|omax
operator|-
literal|3
decl_stmt|;
name|BIT_DStream_t
name|bitD
decl_stmt|;
name|FSE_DState_t
name|state1
decl_stmt|;
name|FSE_DState_t
name|state2
decl_stmt|;
comment|/* Init */
name|CHECK_F
argument_list|(
name|BIT_initDStream
argument_list|(
operator|&
name|bitD
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|)
argument_list|)
expr_stmt|;
name|FSE_initDState
argument_list|(
operator|&
name|state1
argument_list|,
operator|&
name|bitD
argument_list|,
name|dt
argument_list|)
expr_stmt|;
name|FSE_initDState
argument_list|(
operator|&
name|state2
argument_list|,
operator|&
name|bitD
argument_list|,
name|dt
argument_list|)
expr_stmt|;
define|#
directive|define
name|FSE_GETSYMBOL
parameter_list|(
name|statePtr
parameter_list|)
value|fast ? FSE_decodeSymbolFast(statePtr,&bitD) : FSE_decodeSymbol(statePtr,&bitD)
comment|/* 4 symbols per loop */
for|for
control|(
init|;
operator|(
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD
argument_list|)
operator|==
name|BIT_DStream_unfinished
operator|)
operator|&
operator|(
name|op
operator|<
name|olimit
operator|)
condition|;
name|op
operator|+=
literal|4
control|)
block|{
name|op
index|[
literal|0
index|]
operator|=
name|FSE_GETSYMBOL
argument_list|(
operator|&
name|state1
argument_list|)
expr_stmt|;
if|if
condition|(
name|FSE_MAX_TABLELOG
operator|*
literal|2
operator|+
literal|7
operator|>
sizeof|sizeof
argument_list|(
name|bitD
operator|.
name|bitContainer
argument_list|)
operator|*
literal|8
condition|)
comment|/* This test must be static */
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD
argument_list|)
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|FSE_GETSYMBOL
argument_list|(
operator|&
name|state2
argument_list|)
expr_stmt|;
if|if
condition|(
name|FSE_MAX_TABLELOG
operator|*
literal|4
operator|+
literal|7
operator|>
sizeof|sizeof
argument_list|(
name|bitD
operator|.
name|bitContainer
argument_list|)
operator|*
literal|8
condition|)
comment|/* This test must be static */
block|{
if|if
condition|(
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD
argument_list|)
operator|>
name|BIT_DStream_unfinished
condition|)
block|{
name|op
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
block|}
name|op
index|[
literal|2
index|]
operator|=
name|FSE_GETSYMBOL
argument_list|(
operator|&
name|state1
argument_list|)
expr_stmt|;
if|if
condition|(
name|FSE_MAX_TABLELOG
operator|*
literal|2
operator|+
literal|7
operator|>
sizeof|sizeof
argument_list|(
name|bitD
operator|.
name|bitContainer
argument_list|)
operator|*
literal|8
condition|)
comment|/* This test must be static */
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD
argument_list|)
expr_stmt|;
name|op
index|[
literal|3
index|]
operator|=
name|FSE_GETSYMBOL
argument_list|(
operator|&
name|state2
argument_list|)
expr_stmt|;
block|}
comment|/* tail */
comment|/* note : BIT_reloadDStream(&bitD)>= FSE_DStream_partiallyFilled; Ends at exactly BIT_DStream_completed */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|op
operator|>
operator|(
name|omax
operator|-
literal|2
operator|)
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
operator|*
name|op
operator|++
operator|=
name|FSE_GETSYMBOL
argument_list|(
operator|&
name|state1
argument_list|)
expr_stmt|;
if|if
condition|(
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD
argument_list|)
operator|==
name|BIT_DStream_overflow
condition|)
block|{
operator|*
name|op
operator|++
operator|=
name|FSE_GETSYMBOL
argument_list|(
operator|&
name|state2
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|op
operator|>
operator|(
name|omax
operator|-
literal|2
operator|)
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
operator|*
name|op
operator|++
operator|=
name|FSE_GETSYMBOL
argument_list|(
operator|&
name|state2
argument_list|)
expr_stmt|;
if|if
condition|(
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD
argument_list|)
operator|==
name|BIT_DStream_overflow
condition|)
block|{
operator|*
name|op
operator|++
operator|=
name|FSE_GETSYMBOL
argument_list|(
operator|&
name|state1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|op
operator|-
name|ostart
return|;
block|}
end_function

begin_function
name|size_t
name|FSE_decompress_usingDTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|originalSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|FSE_DTable
modifier|*
name|dt
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|ptr
init|=
name|dt
decl_stmt|;
specifier|const
name|FSE_DTableHeader
modifier|*
name|DTableH
init|=
operator|(
specifier|const
name|FSE_DTableHeader
operator|*
operator|)
name|ptr
decl_stmt|;
specifier|const
name|U32
name|fastMode
init|=
name|DTableH
operator|->
name|fastMode
decl_stmt|;
comment|/* select fast mode (static) */
if|if
condition|(
name|fastMode
condition|)
return|return
name|FSE_decompress_usingDTable_generic
argument_list|(
name|dst
argument_list|,
name|originalSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|,
name|dt
argument_list|,
literal|1
argument_list|)
return|;
return|return
name|FSE_decompress_usingDTable_generic
argument_list|(
name|dst
argument_list|,
name|originalSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|,
name|dt
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|FSE_decompress_wksp
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
name|FSE_DTable
modifier|*
name|workSpace
parameter_list|,
name|unsigned
name|maxLog
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|cSrc
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|ip
init|=
name|istart
decl_stmt|;
name|short
name|counting
index|[
name|FSE_MAX_SYMBOL_VALUE
operator|+
literal|1
index|]
decl_stmt|;
name|unsigned
name|tableLog
decl_stmt|;
name|unsigned
name|maxSymbolValue
init|=
name|FSE_MAX_SYMBOL_VALUE
decl_stmt|;
comment|/* normal FSE decoding mode */
name|size_t
specifier|const
name|NCountLength
init|=
name|FSE_readNCount
argument_list|(
name|counting
argument_list|,
operator|&
name|maxSymbolValue
argument_list|,
operator|&
name|tableLog
argument_list|,
name|istart
argument_list|,
name|cSrcSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|FSE_isError
argument_list|(
name|NCountLength
argument_list|)
condition|)
return|return
name|NCountLength
return|;
comment|//if (NCountLength>= cSrcSize) return ERROR(srcSize_wrong);   /* too small input size; supposed to be already checked in NCountLength, only remaining case : NCountLength==cSrcSize */
if|if
condition|(
name|tableLog
operator|>
name|maxLog
condition|)
return|return
name|ERROR
argument_list|(
name|tableLog_tooLarge
argument_list|)
return|;
name|ip
operator|+=
name|NCountLength
expr_stmt|;
name|cSrcSize
operator|-=
name|NCountLength
expr_stmt|;
name|CHECK_F
argument_list|(
name|FSE_buildDTable
argument_list|(
name|workSpace
argument_list|,
name|counting
argument_list|,
name|maxSymbolValue
argument_list|,
name|tableLog
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FSE_decompress_usingDTable
argument_list|(
name|dst
argument_list|,
name|dstCapacity
argument_list|,
name|ip
argument_list|,
name|cSrcSize
argument_list|,
name|workSpace
argument_list|)
return|;
comment|/* always return, even if it is an error code */
block|}
end_function

begin_typedef
typedef|typedef
name|FSE_DTable
name|DTable_max_t
index|[
name|FSE_DTABLE_SIZE_U32
argument_list|(
name|FSE_MAX_TABLELOG
argument_list|)
index|]
typedef|;
end_typedef

begin_function
name|size_t
name|FSE_decompress
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
block|{
name|DTable_max_t
name|dt
decl_stmt|;
comment|/* Static analyzer seems unable to understand this table will be properly initialized later */
return|return
name|FSE_decompress_wksp
argument_list|(
name|dst
argument_list|,
name|dstCapacity
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|,
name|dt
argument_list|,
name|FSE_MAX_TABLELOG
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FSE_COMMONDEFS_ONLY */
end_comment

end_unit

