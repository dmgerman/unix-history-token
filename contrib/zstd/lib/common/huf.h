begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ******************************************************************    Huffman coder, part of New Generation Entropy library    header file    Copyright (C) 2013-2016, Yann Collet.     BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)     Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are    met:         * Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer.        * Redistributions in binary form must reproduce the above    copyright notice, this list of conditions and the following disclaimer    in the documentation and/or other materials provided with the    distribution.     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     You can contact the author at :    - Source repository : https://github.com/Cyan4973/FiniteStateEntropy ****************************************************************** */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HUF_H_298734234
end_ifndef

begin_define
define|#
directive|define
name|HUF_H_298734234
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/* *** Dependencies *** */
include|#
directive|include
file|<stddef.h>
comment|/* size_t */
comment|/* *** simple functions *** */
comment|/** HUF_compress() :     Compress content from buffer 'src', of size 'srcSize', into buffer 'dst'.     'dst' buffer must be already allocated.     Compression runs faster if `dstCapacity`>= HUF_compressBound(srcSize).     `srcSize` must be<= `HUF_BLOCKSIZE_MAX` == 128 KB.     @return : size of compressed data (<= `dstCapacity`).     Special values : if return == 0, srcData is not compressible => Nothing is stored within dst !!!                      if return == 1, srcData is a single repeated byte symbol (RLE compression).                      if HUF_isError(return), compression failed (more details using HUF_getErrorName()) */
name|size_t
name|HUF_compress
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
comment|/** HUF_decompress() :     Decompress HUF data from buffer 'cSrc', of size 'cSrcSize',     into already allocated buffer 'dst', of minimum size 'dstSize'.     `originalSize` : **must** be the ***exact*** size of original (uncompressed) data.     Note : in contrast with FSE, HUF_decompress can regenerate            RLE (cSrcSize==1) and uncompressed (cSrcSize==dstSize) data,            because it knows size to regenerate.     @return : size of regenerated data (== originalSize),               or an error code, which can be tested using HUF_isError() */
name|size_t
name|HUF_decompress
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|originalSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
function_decl|;
comment|/* ***   Tool functions *** */
define|#
directive|define
name|HUF_BLOCKSIZE_MAX
value|(128 * 1024)
comment|/**< maximum input size for a single block compressed with HUF_compress */
name|size_t
name|HUF_compressBound
parameter_list|(
name|size_t
name|size
parameter_list|)
function_decl|;
comment|/**< maximum compressed size (worst case) */
comment|/* Error Management */
name|unsigned
name|HUF_isError
parameter_list|(
name|size_t
name|code
parameter_list|)
function_decl|;
comment|/**< tells if a return value is an error code */
specifier|const
name|char
modifier|*
name|HUF_getErrorName
parameter_list|(
name|size_t
name|code
parameter_list|)
function_decl|;
comment|/**< provides error code string (useful for debugging) */
comment|/* ***   Advanced function   *** */
comment|/** HUF_compress2() :  *   Same as HUF_compress(), but offers direct control over `maxSymbolValue` and `tableLog` .  *   `tableLog` must be `<= HUF_TABLELOG_MAX` . */
name|size_t
name|HUF_compress2
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|,
name|unsigned
name|tableLog
parameter_list|)
function_decl|;
comment|/** HUF_compress4X_wksp() : *   Same as HUF_compress2(), but uses externally allocated `workSpace`, which must be a table of>= 1024 unsigned */
name|size_t
name|HUF_compress4X_wksp
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|,
name|unsigned
name|tableLog
parameter_list|,
name|void
modifier|*
name|workSpace
parameter_list|,
name|size_t
name|wkspSize
parameter_list|)
function_decl|;
comment|/**< `workSpace` must be a table of at least HUF_WORKSPACE_SIZE_U32 unsigned */
ifdef|#
directive|ifdef
name|HUF_STATIC_LINKING_ONLY
comment|/* *** Dependencies *** */
include|#
directive|include
file|"mem.h"
comment|/* U32 */
comment|/* *** Constants *** */
define|#
directive|define
name|HUF_TABLELOG_MAX
value|12
comment|/* max configured tableLog (for static allocation); can be modified up to HUF_ABSOLUTEMAX_TABLELOG */
define|#
directive|define
name|HUF_TABLELOG_DEFAULT
value|11
comment|/* tableLog by default, when not specified */
define|#
directive|define
name|HUF_SYMBOLVALUE_MAX
value|255
define|#
directive|define
name|HUF_TABLELOG_ABSOLUTEMAX
value|15
comment|/* absolute limit of HUF_MAX_TABLELOG. Beyond that value, code does not work */
if|#
directive|if
operator|(
name|HUF_TABLELOG_MAX
operator|>
name|HUF_TABLELOG_ABSOLUTEMAX
operator|)
error|#
directive|error
literal|"HUF_TABLELOG_MAX is too large !"
endif|#
directive|endif
comment|/* **************************************** *  Static allocation ******************************************/
comment|/* HUF buffer bounds */
define|#
directive|define
name|HUF_CTABLEBOUND
value|129
define|#
directive|define
name|HUF_BLOCKBOUND
parameter_list|(
name|size
parameter_list|)
value|(size + (size>>8) + 8)
comment|/* only true if incompressible pre-filtered with fast heuristic */
define|#
directive|define
name|HUF_COMPRESSBOUND
parameter_list|(
name|size
parameter_list|)
value|(HUF_CTABLEBOUND + HUF_BLOCKBOUND(size))
comment|/* Macro version, useful for static allocation */
comment|/* static allocation of HUF's Compression Table */
define|#
directive|define
name|HUF_CREATE_STATIC_CTABLE
parameter_list|(
name|name
parameter_list|,
name|maxSymbolValue
parameter_list|)
define|\
value|U32 name##hb[maxSymbolValue+1]; \     void* name##hv =&(name##hb); \     HUF_CElt* name = (HUF_CElt*)(name##hv)
comment|/* no final ; */
comment|/* static allocation of HUF's DTable */
typedef|typedef
name|U32
name|HUF_DTable
typedef|;
define|#
directive|define
name|HUF_DTABLE_SIZE
parameter_list|(
name|maxTableLog
parameter_list|)
value|(1 + (1<<(maxTableLog)))
define|#
directive|define
name|HUF_CREATE_STATIC_DTABLEX2
parameter_list|(
name|DTable
parameter_list|,
name|maxTableLog
parameter_list|)
define|\
value|HUF_DTable DTable[HUF_DTABLE_SIZE((maxTableLog)-1)] = { ((U32)((maxTableLog)-1) * 0x01000001) }
define|#
directive|define
name|HUF_CREATE_STATIC_DTABLEX4
parameter_list|(
name|DTable
parameter_list|,
name|maxTableLog
parameter_list|)
define|\
value|HUF_DTable DTable[HUF_DTABLE_SIZE(maxTableLog)] = { ((U32)(maxTableLog) * 0x01000001) }
comment|/* The workspace must have alignment at least 4 and be at least this large */
define|#
directive|define
name|HUF_WORKSPACE_SIZE
value|(6<< 10)
define|#
directive|define
name|HUF_WORKSPACE_SIZE_U32
value|(HUF_WORKSPACE_SIZE / sizeof(U32))
comment|/* **************************************** *  Advanced decompression functions ******************************************/
name|size_t
name|HUF_decompress4X2
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
function_decl|;
comment|/**< single-symbol decoder */
name|size_t
name|HUF_decompress4X4
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
function_decl|;
comment|/**< double-symbols decoder */
name|size_t
name|HUF_decompress4X_DCtx
parameter_list|(
name|HUF_DTable
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
function_decl|;
comment|/**< decodes RLE and uncompressed */
name|size_t
name|HUF_decompress4X_hufOnly
parameter_list|(
name|HUF_DTable
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
function_decl|;
comment|/**< considers RLE and uncompressed as errors */
name|size_t
name|HUF_decompress4X2_DCtx
parameter_list|(
name|HUF_DTable
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
function_decl|;
comment|/**< single-symbol decoder */
name|size_t
name|HUF_decompress4X4_DCtx
parameter_list|(
name|HUF_DTable
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
function_decl|;
comment|/**< double-symbols decoder */
comment|/* **************************************** *  HUF detailed API ******************************************/
comment|/*! HUF_compress() does the following: 1. count symbol occurrence from source[] into table count[] using FSE_count() 2. (optional) refine tableLog using HUF_optimalTableLog() 3. build Huffman table from count using HUF_buildCTable() 4. save Huffman table to memory buffer using HUF_writeCTable() 5. encode the data stream using HUF_compress4X_usingCTable()  The following API allows targeting specific sub-functions for advanced tasks. For example, it's possible to compress several blocks using the same 'CTable', or to save and regenerate 'CTable' using external methods. */
comment|/* FSE_count() : find it within "fse.h" */
name|unsigned
name|HUF_optimalTableLog
parameter_list|(
name|unsigned
name|maxTableLog
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|)
function_decl|;
typedef|typedef
name|struct
name|HUF_CElt_s
name|HUF_CElt
typedef|;
comment|/* incomplete type */
name|size_t
name|HUF_buildCTable
parameter_list|(
name|HUF_CElt
modifier|*
name|CTable
parameter_list|,
specifier|const
name|unsigned
modifier|*
name|count
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|,
name|unsigned
name|maxNbBits
parameter_list|)
function_decl|;
name|size_t
name|HUF_writeCTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|HUF_CElt
modifier|*
name|CTable
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|,
name|unsigned
name|huffLog
parameter_list|)
function_decl|;
name|size_t
name|HUF_compress4X_usingCTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
specifier|const
name|HUF_CElt
modifier|*
name|CTable
parameter_list|)
function_decl|;
typedef|typedef
enum|enum
block|{
name|HUF_repeat_none
block|,
comment|/**< Cannot use the previous table */
name|HUF_repeat_check
block|,
comment|/**< Can use the previous table but it must be checked. Note : The previous table must have been constructed by HUF_compress{1, 4}X_repeat */
name|HUF_repeat_valid
comment|/**< Can use the previous table and it is asumed to be valid */
block|}
name|HUF_repeat
typedef|;
comment|/** HUF_compress4X_repeat() : *   Same as HUF_compress4X_wksp(), but considers using hufTable if *repeat != HUF_repeat_none. *   If it uses hufTable it does not modify hufTable or repeat. *   If it doesn't, it sets *repeat = HUF_repeat_none, and it sets hufTable to the table used. *   If preferRepeat then the old table will always be used if valid. */
name|size_t
name|HUF_compress4X_repeat
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|,
name|unsigned
name|tableLog
parameter_list|,
name|void
modifier|*
name|workSpace
parameter_list|,
name|size_t
name|wkspSize
parameter_list|,
name|HUF_CElt
modifier|*
name|hufTable
parameter_list|,
name|HUF_repeat
modifier|*
name|repeat
parameter_list|,
name|int
name|preferRepeat
parameter_list|)
function_decl|;
comment|/**< `workSpace` must be a table of at least HUF_WORKSPACE_SIZE_U32 unsigned */
comment|/** HUF_buildCTable_wksp() :  *  Same as HUF_buildCTable(), but using externally allocated scratch buffer.  *  `workSpace` must be aligned on 4-bytes boundaries, and be at least as large as a table of 1024 unsigned.  */
name|size_t
name|HUF_buildCTable_wksp
parameter_list|(
name|HUF_CElt
modifier|*
name|tree
parameter_list|,
specifier|const
name|U32
modifier|*
name|count
parameter_list|,
name|U32
name|maxSymbolValue
parameter_list|,
name|U32
name|maxNbBits
parameter_list|,
name|void
modifier|*
name|workSpace
parameter_list|,
name|size_t
name|wkspSize
parameter_list|)
function_decl|;
comment|/*! HUF_readStats() :     Read compact Huffman tree, saved by HUF_writeCTable().     `huffWeight` is destination buffer.     @return : size read from `src` , or an error Code .     Note : Needed by HUF_readCTable() and HUF_readDTableXn() . */
name|size_t
name|HUF_readStats
parameter_list|(
name|BYTE
modifier|*
name|huffWeight
parameter_list|,
name|size_t
name|hwSize
parameter_list|,
name|U32
modifier|*
name|rankStats
parameter_list|,
name|U32
modifier|*
name|nbSymbolsPtr
parameter_list|,
name|U32
modifier|*
name|tableLogPtr
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
comment|/** HUF_readCTable() : *   Loading a CTable saved with HUF_writeCTable() */
name|size_t
name|HUF_readCTable
parameter_list|(
name|HUF_CElt
modifier|*
name|CTable
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
comment|/* HUF_decompress() does the following: 1. select the decompression algorithm (X2, X4) based on pre-computed heuristics 2. build Huffman table from save, using HUF_readDTableXn() 3. decode 1 or 4 segments in parallel using HUF_decompressSXn_usingDTable */
comment|/** HUF_selectDecoder() : *   Tells which decoder is likely to decode faster, *   based on a set of pre-determined metrics. *   @return : 0==HUF_decompress4X2, 1==HUF_decompress4X4 . *   Assumption : 0< cSrcSize< dstSize<= 128 KB */
name|U32
name|HUF_selectDecoder
parameter_list|(
name|size_t
name|dstSize
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
function_decl|;
name|size_t
name|HUF_readDTableX2
parameter_list|(
name|HUF_DTable
modifier|*
name|DTable
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
name|size_t
name|HUF_readDTableX4
parameter_list|(
name|HUF_DTable
modifier|*
name|DTable
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
name|size_t
name|HUF_decompress4X_usingDTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|HUF_DTable
modifier|*
name|DTable
parameter_list|)
function_decl|;
name|size_t
name|HUF_decompress4X2_usingDTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|HUF_DTable
modifier|*
name|DTable
parameter_list|)
function_decl|;
name|size_t
name|HUF_decompress4X4_usingDTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|HUF_DTable
modifier|*
name|DTable
parameter_list|)
function_decl|;
comment|/* single stream variants */
name|size_t
name|HUF_compress1X
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|,
name|unsigned
name|tableLog
parameter_list|)
function_decl|;
name|size_t
name|HUF_compress1X_wksp
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|,
name|unsigned
name|tableLog
parameter_list|,
name|void
modifier|*
name|workSpace
parameter_list|,
name|size_t
name|wkspSize
parameter_list|)
function_decl|;
comment|/**< `workSpace` must be a table of at least HUF_WORKSPACE_SIZE_U32 unsigned */
name|size_t
name|HUF_compress1X_usingCTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
specifier|const
name|HUF_CElt
modifier|*
name|CTable
parameter_list|)
function_decl|;
comment|/** HUF_compress1X_repeat() : *   Same as HUF_compress1X_wksp(), but considers using hufTable if *repeat != HUF_repeat_none. *   If it uses hufTable it does not modify hufTable or repeat. *   If it doesn't, it sets *repeat = HUF_repeat_none, and it sets hufTable to the table used. *   If preferRepeat then the old table will always be used if valid. */
name|size_t
name|HUF_compress1X_repeat
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|,
name|unsigned
name|tableLog
parameter_list|,
name|void
modifier|*
name|workSpace
parameter_list|,
name|size_t
name|wkspSize
parameter_list|,
name|HUF_CElt
modifier|*
name|hufTable
parameter_list|,
name|HUF_repeat
modifier|*
name|repeat
parameter_list|,
name|int
name|preferRepeat
parameter_list|)
function_decl|;
comment|/**< `workSpace` must be a table of at least HUF_WORKSPACE_SIZE_U32 unsigned */
name|size_t
name|HUF_decompress1X2
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
function_decl|;
comment|/* single-symbol decoder */
name|size_t
name|HUF_decompress1X4
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
function_decl|;
comment|/* double-symbol decoder */
name|size_t
name|HUF_decompress1X_DCtx
parameter_list|(
name|HUF_DTable
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
function_decl|;
name|size_t
name|HUF_decompress1X2_DCtx
parameter_list|(
name|HUF_DTable
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
function_decl|;
comment|/**< single-symbol decoder */
name|size_t
name|HUF_decompress1X4_DCtx
parameter_list|(
name|HUF_DTable
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
function_decl|;
comment|/**< double-symbols decoder */
name|size_t
name|HUF_decompress1X_usingDTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|HUF_DTable
modifier|*
name|DTable
parameter_list|)
function_decl|;
comment|/**< automatic selection of sing or double symbol decoder, based on DTable */
name|size_t
name|HUF_decompress1X2_usingDTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|HUF_DTable
modifier|*
name|DTable
parameter_list|)
function_decl|;
name|size_t
name|HUF_decompress1X4_usingDTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|HUF_DTable
modifier|*
name|DTable
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* HUF_STATIC_LINKING_ONLY */
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HUF_H_298734234 */
end_comment

end_unit

