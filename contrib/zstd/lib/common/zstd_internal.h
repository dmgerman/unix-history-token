begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright (c) 2016-present, Yann Collet, Facebook, Inc.  * All rights reserved.  *  * This source code is licensed under the BSD-style license found in the  * LICENSE file in the root directory of this source tree. An additional grant  * of patent rights can be found in the PATENTS file in the same directory.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ZSTD_CCOMMON_H_MODULE
end_ifndef

begin_define
define|#
directive|define
name|ZSTD_CCOMMON_H_MODULE
end_define

begin_comment
comment|/*-******************************************************* *  Compiler specifics *********************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_comment
comment|/* Visual Studio */
end_comment

begin_define
define|#
directive|define
name|FORCE_INLINE
value|static __forceinline
end_define

begin_include
include|#
directive|include
file|<intrin.h>
end_include

begin_comment
comment|/* For Visual 2005 */
end_comment

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4127
name|)
end_pragma

begin_comment
comment|/* disable: C4127: conditional expression is constant */
end_comment

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4324
name|)
end_pragma

begin_comment
comment|/* disable: C4324: padded structure */
end_comment

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4100
name|)
end_pragma

begin_comment
comment|/* disable: C4100: unreferenced formal parameter */
end_comment

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
operator|||
name|defined
argument_list|(
name|__STDC_VERSION__
argument_list|)
operator|&&
name|__STDC_VERSION__
operator|>=
literal|199901L
end_if

begin_comment
comment|/* C99 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|FORCE_INLINE
value|static inline __attribute__((always_inline))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FORCE_INLINE
value|static inline
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FORCE_INLINE
value|static
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __STDC_VERSION__ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_define
define|#
directive|define
name|FORCE_NOINLINE
value|static __declspec(noinline)
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|FORCE_NOINLINE
value|static __attribute__((__noinline__))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FORCE_NOINLINE
value|static
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*-************************************* *  Dependencies ***************************************/
end_comment

begin_include
include|#
directive|include
file|"mem.h"
end_include

begin_include
include|#
directive|include
file|"error_private.h"
end_include

begin_define
define|#
directive|define
name|ZSTD_STATIC_LINKING_ONLY
end_define

begin_include
include|#
directive|include
file|"zstd.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|XXH_STATIC_LINKING_ONLY
end_ifndef

begin_define
define|#
directive|define
name|XXH_STATIC_LINKING_ONLY
end_define

begin_comment
comment|/* XXH64_state_t */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"xxhash.h"
end_include

begin_comment
comment|/* XXH_reset, update, digest */
end_comment

begin_comment
comment|/*-************************************* *  shared macros ***************************************/
end_comment

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)<(b) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)>(b) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|CHECK_F
parameter_list|(
name|f
parameter_list|)
value|{ size_t const errcod = f; if (ERR_isError(errcod)) return errcod; }
end_define

begin_comment
comment|/* check and Forward error code */
end_comment

begin_define
define|#
directive|define
name|CHECK_E
parameter_list|(
name|f
parameter_list|,
name|e
parameter_list|)
value|{ size_t const errcod = f; if (ERR_isError(errcod)) return ERROR(e); }
end_define

begin_comment
comment|/* check and send Error code */
end_comment

begin_comment
comment|/*-************************************* *  Common constants ***************************************/
end_comment

begin_define
define|#
directive|define
name|ZSTD_OPT_NUM
value|(1<<12)
end_define

begin_define
define|#
directive|define
name|ZSTD_DICT_MAGIC
value|0xEC30A437
end_define

begin_comment
comment|/* v0.7+ */
end_comment

begin_define
define|#
directive|define
name|ZSTD_REP_NUM
value|3
end_define

begin_comment
comment|/* number of repcodes */
end_comment

begin_define
define|#
directive|define
name|ZSTD_REP_CHECK
value|(ZSTD_REP_NUM)
end_define

begin_comment
comment|/* number of repcodes to check by the optimal parser */
end_comment

begin_define
define|#
directive|define
name|ZSTD_REP_MOVE
value|(ZSTD_REP_NUM-1)
end_define

begin_define
define|#
directive|define
name|ZSTD_REP_MOVE_OPT
value|(ZSTD_REP_NUM)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|U32
name|repStartValue
index|[
name|ZSTD_REP_NUM
index|]
init|=
block|{
literal|1
block|,
literal|4
block|,
literal|8
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|KB
value|*(1<<10)
end_define

begin_define
define|#
directive|define
name|MB
value|*(1<<20)
end_define

begin_define
define|#
directive|define
name|GB
value|*(1U<<30)
end_define

begin_define
define|#
directive|define
name|BIT7
value|128
end_define

begin_define
define|#
directive|define
name|BIT6
value|64
end_define

begin_define
define|#
directive|define
name|BIT5
value|32
end_define

begin_define
define|#
directive|define
name|BIT4
value|16
end_define

begin_define
define|#
directive|define
name|BIT1
value|2
end_define

begin_define
define|#
directive|define
name|BIT0
value|1
end_define

begin_define
define|#
directive|define
name|ZSTD_WINDOWLOG_ABSOLUTEMIN
value|10
end_define

begin_decl_stmt
specifier|static
specifier|const
name|size_t
name|ZSTD_fcs_fieldSize
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|2
block|,
literal|4
block|,
literal|8
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|size_t
name|ZSTD_did_fieldSize
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|4
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ZSTD_BLOCKHEADERSIZE
value|3
end_define

begin_comment
comment|/* C standard doesn't allow `static const` variable to be init using another `static const` variable */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|size_t
name|ZSTD_blockHeaderSize
init|=
name|ZSTD_BLOCKHEADERSIZE
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
enum|enum
block|{
name|bt_raw
block|,
name|bt_rle
block|,
name|bt_compressed
block|,
name|bt_reserved
block|}
name|blockType_e
typedef|;
end_typedef

begin_define
define|#
directive|define
name|MIN_SEQUENCES_SIZE
value|1
end_define

begin_comment
comment|/* nbSeq==0 */
end_comment

begin_define
define|#
directive|define
name|MIN_CBLOCK_SIZE
value|(1
comment|/*litCSize*/
value|+ 1
comment|/* RLE or RAW */
value|+ MIN_SEQUENCES_SIZE
comment|/* nbSeq==0 */
value|)
end_define

begin_comment
comment|/* for a non-null block */
end_comment

begin_define
define|#
directive|define
name|HufLog
value|12
end_define

begin_typedef
typedef|typedef
enum|enum
block|{
name|set_basic
block|,
name|set_rle
block|,
name|set_compressed
block|,
name|set_repeat
block|}
name|symbolEncodingType_e
typedef|;
end_typedef

begin_define
define|#
directive|define
name|LONGNBSEQ
value|0x7F00
end_define

begin_define
define|#
directive|define
name|MINMATCH
value|3
end_define

begin_define
define|#
directive|define
name|EQUAL_READ32
value|4
end_define

begin_define
define|#
directive|define
name|Litbits
value|8
end_define

begin_define
define|#
directive|define
name|MaxLit
value|((1<<Litbits) - 1)
end_define

begin_define
define|#
directive|define
name|MaxML
value|52
end_define

begin_define
define|#
directive|define
name|MaxLL
value|35
end_define

begin_define
define|#
directive|define
name|MaxOff
value|28
end_define

begin_define
define|#
directive|define
name|MaxSeq
value|MAX(MaxLL, MaxML)
end_define

begin_comment
comment|/* Assumption : MaxOff< MaxLL,MaxML */
end_comment

begin_define
define|#
directive|define
name|MLFSELog
value|9
end_define

begin_define
define|#
directive|define
name|LLFSELog
value|9
end_define

begin_define
define|#
directive|define
name|OffFSELog
value|8
end_define

begin_decl_stmt
specifier|static
specifier|const
name|U32
name|LL_bits
index|[
name|MaxLL
operator|+
literal|1
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|S16
name|LL_defaultNorm
index|[
name|MaxLL
operator|+
literal|1
index|]
init|=
block|{
literal|4
block|,
literal|3
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LL_DEFAULTNORMLOG
value|6
end_define

begin_comment
comment|/* for static allocation */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|U32
name|LL_defaultNormLog
init|=
name|LL_DEFAULTNORMLOG
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|U32
name|ML_bits
index|[
name|MaxML
operator|+
literal|1
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|S16
name|ML_defaultNorm
index|[
name|MaxML
operator|+
literal|1
index|]
init|=
block|{
literal|1
block|,
literal|4
block|,
literal|3
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ML_DEFAULTNORMLOG
value|6
end_define

begin_comment
comment|/* for static allocation */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|U32
name|ML_defaultNormLog
init|=
name|ML_DEFAULTNORMLOG
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|S16
name|OF_defaultNorm
index|[
name|MaxOff
operator|+
literal|1
index|]
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|OF_DEFAULTNORMLOG
value|5
end_define

begin_comment
comment|/* for static allocation */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|U32
name|OF_defaultNormLog
init|=
name|OF_DEFAULTNORMLOG
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*-******************************************* *  Shared functions to include for inlining *********************************************/
end_comment

begin_function
specifier|static
name|void
name|ZSTD_copy8
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|)
block|{
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|COPY8
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|)
value|{ ZSTD_copy8(d,s); d+=8; s+=8; }
end_define

begin_comment
comment|/*! ZSTD_wildcopy() : *   custom version of memcpy(), can copy up to 7 bytes too many (8 bytes if length==0) */
end_comment

begin_define
define|#
directive|define
name|WILDCOPY_OVERLENGTH
value|8
end_define

begin_function
name|MEM_STATIC
name|void
name|ZSTD_wildcopy
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|ptrdiff_t
name|length
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
decl_stmt|;
name|BYTE
modifier|*
name|op
init|=
operator|(
name|BYTE
operator|*
operator|)
name|dst
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|oend
init|=
name|op
operator|+
name|length
decl_stmt|;
do|do
name|COPY8
argument_list|(
argument|op
argument_list|,
argument|ip
argument_list|)
while|while
condition|(
name|op
operator|<
name|oend
condition|)
empty_stmt|;
do|}
name|MEM_STATIC
name|void
name|ZSTD_wildcopy_e
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|void
modifier|*
name|dstEnd
parameter_list|)
comment|/* should be faster for decoding, but strangely, not verified on all platform */
block|{
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
decl_stmt|;
name|BYTE
modifier|*
name|op
init|=
operator|(
name|BYTE
operator|*
operator|)
name|dst
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|oend
init|=
operator|(
name|BYTE
operator|*
operator|)
name|dstEnd
decl_stmt|;
do|do
name|COPY8
argument_list|(
argument|op
argument_list|,
argument|ip
argument_list|)
while|while
condition|(
name|op
operator|<
name|oend
condition|)
empty_stmt|;
do|}
comment|/*-******************************************* *  Private interfaces *********************************************/
typedef|typedef
name|struct
name|ZSTD_stats_s
name|ZSTD_stats_t
typedef|;
typedef|typedef
struct|struct
block|{
name|U32
name|off
decl_stmt|;
name|U32
name|len
decl_stmt|;
block|}
name|ZSTD_match_t
typedef|;
typedef|typedef
struct|struct
block|{
name|U32
name|price
decl_stmt|;
name|U32
name|off
decl_stmt|;
name|U32
name|mlen
decl_stmt|;
name|U32
name|litlen
decl_stmt|;
name|U32
name|rep
index|[
name|ZSTD_REP_NUM
index|]
decl_stmt|;
block|}
name|ZSTD_optimal_t
typedef|;
typedef|typedef
struct|struct
name|seqDef_s
block|{
name|U32
name|offset
decl_stmt|;
name|U16
name|litLength
decl_stmt|;
name|U16
name|matchLength
decl_stmt|;
block|}
name|seqDef
typedef|;
typedef|typedef
struct|struct
block|{
name|seqDef
modifier|*
name|sequencesStart
decl_stmt|;
name|seqDef
modifier|*
name|sequences
decl_stmt|;
name|BYTE
modifier|*
name|litStart
decl_stmt|;
name|BYTE
modifier|*
name|lit
decl_stmt|;
name|BYTE
modifier|*
name|llCode
decl_stmt|;
name|BYTE
modifier|*
name|mlCode
decl_stmt|;
name|BYTE
modifier|*
name|ofCode
decl_stmt|;
name|U32
name|longLengthID
decl_stmt|;
comment|/* 0 == no longLength; 1 == Lit.longLength; 2 == Match.longLength; */
name|U32
name|longLengthPos
decl_stmt|;
comment|/* opt */
name|ZSTD_optimal_t
modifier|*
name|priceTable
decl_stmt|;
name|ZSTD_match_t
modifier|*
name|matchTable
decl_stmt|;
name|U32
modifier|*
name|matchLengthFreq
decl_stmt|;
name|U32
modifier|*
name|litLengthFreq
decl_stmt|;
name|U32
modifier|*
name|litFreq
decl_stmt|;
name|U32
modifier|*
name|offCodeFreq
decl_stmt|;
name|U32
name|matchLengthSum
decl_stmt|;
name|U32
name|matchSum
decl_stmt|;
name|U32
name|litLengthSum
decl_stmt|;
name|U32
name|litSum
decl_stmt|;
name|U32
name|offCodeSum
decl_stmt|;
name|U32
name|log2matchLengthSum
decl_stmt|;
name|U32
name|log2matchSum
decl_stmt|;
name|U32
name|log2litLengthSum
decl_stmt|;
name|U32
name|log2litSum
decl_stmt|;
name|U32
name|log2offCodeSum
decl_stmt|;
name|U32
name|factor
decl_stmt|;
name|U32
name|staticPrices
decl_stmt|;
name|U32
name|cachedPrice
decl_stmt|;
name|U32
name|cachedLitLength
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|cachedLiterals
decl_stmt|;
block|}
name|seqStore_t
typedef|;
specifier|const
name|seqStore_t
modifier|*
name|ZSTD_getSeqStore
argument_list|(
specifier|const
name|ZSTD_CCtx
operator|*
name|ctx
argument_list|)
decl_stmt|;
name|void
name|ZSTD_seqToCodes
argument_list|(
specifier|const
name|seqStore_t
operator|*
name|seqStorePtr
argument_list|)
decl_stmt|;
name|int
name|ZSTD_isSkipFrame
argument_list|(
name|ZSTD_DCtx
operator|*
name|dctx
argument_list|)
decl_stmt|;
comment|/* custom memory allocation functions */
name|void
modifier|*
name|ZSTD_defaultAllocFunction
argument_list|(
name|void
operator|*
name|opaque
argument_list|,
name|size_t
name|size
argument_list|)
decl_stmt|;
name|void
name|ZSTD_defaultFreeFunction
argument_list|(
name|void
operator|*
name|opaque
argument_list|,
name|void
operator|*
name|address
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|ZSTD_DLL_IMPORT
specifier|static
specifier|const
name|ZSTD_customMem
name|defaultCustomMem
init|=
block|{
name|ZSTD_defaultAllocFunction
block|,
name|ZSTD_defaultFreeFunction
block|,
name|NULL
block|}
decl_stmt|;
endif|#
directive|endif
name|void
modifier|*
name|ZSTD_malloc
argument_list|(
name|size_t
name|size
argument_list|,
name|ZSTD_customMem
name|customMem
argument_list|)
decl_stmt|;
name|void
name|ZSTD_free
argument_list|(
name|void
operator|*
name|ptr
argument_list|,
name|ZSTD_customMem
name|customMem
argument_list|)
decl_stmt|;
comment|/*======  common function  ======*/
name|MEM_STATIC
name|U32
name|ZSTD_highbit32
parameter_list|(
name|U32
name|val
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
comment|/* Visual */
name|unsigned
name|long
name|r
init|=
literal|0
decl_stmt|;
name|_BitScanReverse
argument_list|(
operator|&
name|r
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|unsigned
operator|)
name|r
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|__GNUC__
operator|>=
literal|3
operator|)
comment|/* GCC Intrinsic */
return|return
literal|31
operator|-
name|__builtin_clz
argument_list|(
name|val
argument_list|)
return|;
else|#
directive|else
comment|/* Software version */
specifier|static
specifier|const
name|int
name|DeBruijnClz
index|[
literal|32
index|]
init|=
block|{
literal|0
block|,
literal|9
block|,
literal|1
block|,
literal|10
block|,
literal|13
block|,
literal|21
block|,
literal|2
block|,
literal|29
block|,
literal|11
block|,
literal|14
block|,
literal|16
block|,
literal|18
block|,
literal|22
block|,
literal|25
block|,
literal|3
block|,
literal|30
block|,
literal|8
block|,
literal|12
block|,
literal|20
block|,
literal|28
block|,
literal|15
block|,
literal|17
block|,
literal|24
block|,
literal|7
block|,
literal|19
block|,
literal|27
block|,
literal|23
block|,
literal|6
block|,
literal|26
block|,
literal|5
block|,
literal|4
block|,
literal|31
block|}
decl_stmt|;
name|U32
name|v
init|=
name|val
decl_stmt|;
name|int
name|r
decl_stmt|;
name|v
operator||=
name|v
operator|>>
literal|1
expr_stmt|;
name|v
operator||=
name|v
operator|>>
literal|2
expr_stmt|;
name|v
operator||=
name|v
operator|>>
literal|4
expr_stmt|;
name|v
operator||=
name|v
operator|>>
literal|8
expr_stmt|;
name|v
operator||=
name|v
operator|>>
literal|16
expr_stmt|;
name|r
operator|=
name|DeBruijnClz
index|[
call|(
name|U32
call|)
argument_list|(
name|v
operator|*
literal|0x07C4ACDDU
argument_list|)
operator|>>
literal|27
index|]
expr_stmt|;
return|return
name|r
return|;
endif|#
directive|endif
block|}
comment|/* hidden functions */
comment|/* ZSTD_invalidateRepCodes() :  * ensures next compression will not use repcodes from previous block.  * Note : only works with regular variant;  *        do not use with extDict variant ! */
name|void
name|ZSTD_invalidateRepCodes
argument_list|(
name|ZSTD_CCtx
operator|*
name|cctx
argument_list|)
decl_stmt|;
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ZSTD_CCOMMON_H_MODULE */
end_comment

end_unit

