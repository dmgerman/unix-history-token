begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ******************************************************************    bitstream    Part of FSE library    header file (to include)    Copyright (C) 2013-2017, Yann Collet.     BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)     Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are    met:         * Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer.        * Redistributions in binary form must reproduce the above    copyright notice, this list of conditions and the following disclaimer    in the documentation and/or other materials provided with the    distribution.     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     You can contact the author at :    - Source repository : https://github.com/Cyan4973/FiniteStateEntropy ****************************************************************** */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BITSTREAM_H_MODULE
end_ifndef

begin_define
define|#
directive|define
name|BITSTREAM_H_MODULE
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/* *  This API consists of small unitary functions, which must be inlined for best performance. *  Since link-time-optimization is not available for all compilers, *  these functions are defined into a .h to be included. */
comment|/*-**************************************** *  Dependencies ******************************************/
include|#
directive|include
file|"mem.h"
comment|/* unaligned access routines */
include|#
directive|include
file|"error_private.h"
comment|/* error codes and messages */
comment|/*-************************************* *  Debug ***************************************/
if|#
directive|if
name|defined
argument_list|(
name|BIT_DEBUG
argument_list|)
operator|&&
operator|(
name|BIT_DEBUG
operator|>=
literal|1
operator|)
include|#
directive|include
file|<assert.h>
else|#
directive|else
ifndef|#
directive|ifndef
name|assert
define|#
directive|define
name|assert
parameter_list|(
name|condition
parameter_list|)
value|((void)0)
endif|#
directive|endif
endif|#
directive|endif
comment|/*========================================= *  Target specific =========================================*/
if|#
directive|if
name|defined
argument_list|(
name|__BMI__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__GNUC__
argument_list|)
include|#
directive|include
file|<immintrin.h>
comment|/* support for bextr (experimental) */
endif|#
directive|endif
define|#
directive|define
name|STREAM_ACCUMULATOR_MIN_32
value|25
define|#
directive|define
name|STREAM_ACCUMULATOR_MIN_64
value|57
define|#
directive|define
name|STREAM_ACCUMULATOR_MIN
value|((U32)(MEM_32bits() ? STREAM_ACCUMULATOR_MIN_32 : STREAM_ACCUMULATOR_MIN_64))
comment|/*-****************************************** *  bitStream encoding API (write forward) ********************************************/
comment|/* bitStream can mix input from multiple sources. *  A critical property of these streams is that they encode and decode in **reverse** direction. *  So the first bit sequence you add will be the last to be read, like a LIFO stack. */
typedef|typedef
struct|struct
block|{
name|size_t
name|bitContainer
decl_stmt|;
name|unsigned
name|bitPos
decl_stmt|;
name|char
modifier|*
name|startPtr
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|endPtr
decl_stmt|;
block|}
name|BIT_CStream_t
typedef|;
name|MEM_STATIC
name|size_t
name|BIT_initCStream
parameter_list|(
name|BIT_CStream_t
modifier|*
name|bitC
parameter_list|,
name|void
modifier|*
name|dstBuffer
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|)
function_decl|;
name|MEM_STATIC
name|void
name|BIT_addBits
parameter_list|(
name|BIT_CStream_t
modifier|*
name|bitC
parameter_list|,
name|size_t
name|value
parameter_list|,
name|unsigned
name|nbBits
parameter_list|)
function_decl|;
name|MEM_STATIC
name|void
name|BIT_flushBits
parameter_list|(
name|BIT_CStream_t
modifier|*
name|bitC
parameter_list|)
function_decl|;
name|MEM_STATIC
name|size_t
name|BIT_closeCStream
parameter_list|(
name|BIT_CStream_t
modifier|*
name|bitC
parameter_list|)
function_decl|;
comment|/* Start with initCStream, providing the size of buffer to write into. *  bitStream will never write outside of this buffer. *  `dstCapacity` must be>= sizeof(bitD->bitContainer), otherwise @return will be an error code. * *  bits are first added to a local register. *  Local register is size_t, hence 64-bits on 64-bits systems, or 32-bits on 32-bits systems. *  Writing data into memory is an explicit operation, performed by the flushBits function. *  Hence keep track how many bits are potentially stored into local register to avoid register overflow. *  After a flushBits, a maximum of 7 bits might still be stored into local register. * *  Avoid storing elements of more than 24 bits if you want compatibility with 32-bits bitstream readers. * *  Last operation is to close the bitStream. *  The function returns the final size of CStream in bytes. *  If data couldn't fit into `dstBuffer`, it will return a 0 ( == not storable) */
comment|/*-******************************************** *  bitStream decoding API (read backward) **********************************************/
typedef|typedef
struct|struct
block|{
name|size_t
name|bitContainer
decl_stmt|;
name|unsigned
name|bitsConsumed
decl_stmt|;
specifier|const
name|char
modifier|*
name|ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
specifier|const
name|char
modifier|*
name|limitPtr
decl_stmt|;
block|}
name|BIT_DStream_t
typedef|;
typedef|typedef
enum|enum
block|{
name|BIT_DStream_unfinished
init|=
literal|0
block|,
name|BIT_DStream_endOfBuffer
init|=
literal|1
block|,
name|BIT_DStream_completed
init|=
literal|2
block|,
name|BIT_DStream_overflow
init|=
literal|3
block|}
name|BIT_DStream_status
typedef|;
comment|/* result of BIT_reloadDStream() */
comment|/* 1,2,4,8 would be better for bitmap combinations, but slows down performance a bit ... :( */
name|MEM_STATIC
name|size_t
name|BIT_initDStream
parameter_list|(
name|BIT_DStream_t
modifier|*
name|bitD
parameter_list|,
specifier|const
name|void
modifier|*
name|srcBuffer
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
name|MEM_STATIC
name|size_t
name|BIT_readBits
parameter_list|(
name|BIT_DStream_t
modifier|*
name|bitD
parameter_list|,
name|unsigned
name|nbBits
parameter_list|)
function_decl|;
name|MEM_STATIC
name|BIT_DStream_status
name|BIT_reloadDStream
parameter_list|(
name|BIT_DStream_t
modifier|*
name|bitD
parameter_list|)
function_decl|;
name|MEM_STATIC
name|unsigned
name|BIT_endOfDStream
parameter_list|(
specifier|const
name|BIT_DStream_t
modifier|*
name|bitD
parameter_list|)
function_decl|;
comment|/* Start by invoking BIT_initDStream(). *  A chunk of the bitStream is then stored into a local register. *  Local register size is 64-bits on 64-bits systems, 32-bits on 32-bits systems (size_t). *  You can then retrieve bitFields stored into the local register, **in reverse order**. *  Local register is explicitly reloaded from memory by the BIT_reloadDStream() method. *  A reload guarantee a minimum of ((8*sizeof(bitD->bitContainer))-7) bits when its result is BIT_DStream_unfinished. *  Otherwise, it can be less than that, so proceed accordingly. *  Checking if DStream has reached its end can be performed with BIT_endOfDStream(). */
comment|/*-**************************************** *  unsafe API ******************************************/
name|MEM_STATIC
name|void
name|BIT_addBitsFast
parameter_list|(
name|BIT_CStream_t
modifier|*
name|bitC
parameter_list|,
name|size_t
name|value
parameter_list|,
name|unsigned
name|nbBits
parameter_list|)
function_decl|;
comment|/* faster, but works only if value is "clean", meaning all high bits above nbBits are 0 */
name|MEM_STATIC
name|void
name|BIT_flushBitsFast
parameter_list|(
name|BIT_CStream_t
modifier|*
name|bitC
parameter_list|)
function_decl|;
comment|/* unsafe version; does not check buffer overflow */
name|MEM_STATIC
name|size_t
name|BIT_readBitsFast
parameter_list|(
name|BIT_DStream_t
modifier|*
name|bitD
parameter_list|,
name|unsigned
name|nbBits
parameter_list|)
function_decl|;
comment|/* faster, but works only if nbBits>= 1 */
comment|/*-************************************************************** *  Internal functions ****************************************************************/
name|MEM_STATIC
name|unsigned
name|BIT_highbit32
parameter_list|(
specifier|register
name|U32
name|val
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
comment|/* Visual */
name|unsigned
name|long
name|r
init|=
literal|0
decl_stmt|;
name|_BitScanReverse
argument_list|(
operator|&
name|r
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|unsigned
operator|)
name|r
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|__GNUC__
operator|>=
literal|3
operator|)
comment|/* Use GCC Intrinsic */
return|return
literal|31
operator|-
name|__builtin_clz
argument_list|(
name|val
argument_list|)
return|;
else|#
directive|else
comment|/* Software version */
specifier|static
specifier|const
name|unsigned
name|DeBruijnClz
index|[
literal|32
index|]
init|=
block|{
literal|0
block|,
literal|9
block|,
literal|1
block|,
literal|10
block|,
literal|13
block|,
literal|21
block|,
literal|2
block|,
literal|29
block|,
literal|11
block|,
literal|14
block|,
literal|16
block|,
literal|18
block|,
literal|22
block|,
literal|25
block|,
literal|3
block|,
literal|30
block|,
literal|8
block|,
literal|12
block|,
literal|20
block|,
literal|28
block|,
literal|15
block|,
literal|17
block|,
literal|24
block|,
literal|7
block|,
literal|19
block|,
literal|27
block|,
literal|23
block|,
literal|6
block|,
literal|26
block|,
literal|5
block|,
literal|4
block|,
literal|31
block|}
decl_stmt|;
name|U32
name|v
init|=
name|val
decl_stmt|;
name|v
operator||=
name|v
operator|>>
literal|1
expr_stmt|;
name|v
operator||=
name|v
operator|>>
literal|2
expr_stmt|;
name|v
operator||=
name|v
operator|>>
literal|4
expr_stmt|;
name|v
operator||=
name|v
operator|>>
literal|8
expr_stmt|;
name|v
operator||=
name|v
operator|>>
literal|16
expr_stmt|;
return|return
name|DeBruijnClz
index|[
call|(
name|U32
call|)
argument_list|(
name|v
operator|*
literal|0x07C4ACDDU
argument_list|)
operator|>>
literal|27
index|]
return|;
endif|#
directive|endif
block|}
comment|/*=====    Local Constants   =====*/
specifier|static
specifier|const
name|unsigned
name|BIT_mask
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|7
block|,
literal|0xF
block|,
literal|0x1F
block|,
literal|0x3F
block|,
literal|0x7F
block|,
literal|0xFF
block|,
literal|0x1FF
block|,
literal|0x3FF
block|,
literal|0x7FF
block|,
literal|0xFFF
block|,
literal|0x1FFF
block|,
literal|0x3FFF
block|,
literal|0x7FFF
block|,
literal|0xFFFF
block|,
literal|0x1FFFF
block|,
literal|0x3FFFF
block|,
literal|0x7FFFF
block|,
literal|0xFFFFF
block|,
literal|0x1FFFFF
block|,
literal|0x3FFFFF
block|,
literal|0x7FFFFF
block|,
literal|0xFFFFFF
block|,
literal|0x1FFFFFF
block|,
literal|0x3FFFFFF
block|}
decl_stmt|;
comment|/* up to 26 bits */
comment|/*-************************************************************** *  bitStream encoding ****************************************************************/
comment|/*! BIT_initCStream() :  *  `dstCapacity` must be> sizeof(size_t)  *  @return : 0 if success,               otherwise an error code (can be tested using ERR_isError() ) */
name|MEM_STATIC
name|size_t
name|BIT_initCStream
parameter_list|(
name|BIT_CStream_t
modifier|*
name|bitC
parameter_list|,
name|void
modifier|*
name|startPtr
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|)
block|{
name|bitC
operator|->
name|bitContainer
operator|=
literal|0
expr_stmt|;
name|bitC
operator|->
name|bitPos
operator|=
literal|0
expr_stmt|;
name|bitC
operator|->
name|startPtr
operator|=
operator|(
name|char
operator|*
operator|)
name|startPtr
expr_stmt|;
name|bitC
operator|->
name|ptr
operator|=
name|bitC
operator|->
name|startPtr
expr_stmt|;
name|bitC
operator|->
name|endPtr
operator|=
name|bitC
operator|->
name|startPtr
operator|+
name|dstCapacity
operator|-
sizeof|sizeof
argument_list|(
name|bitC
operator|->
name|bitContainer
argument_list|)
expr_stmt|;
if|if
condition|(
name|dstCapacity
operator|<=
sizeof|sizeof
argument_list|(
name|bitC
operator|->
name|bitContainer
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
return|return
literal|0
return|;
block|}
comment|/*! BIT_addBits() :     can add up to 26 bits into `bitC`.     Does not check for register overflow ! */
name|MEM_STATIC
name|void
name|BIT_addBits
parameter_list|(
name|BIT_CStream_t
modifier|*
name|bitC
parameter_list|,
name|size_t
name|value
parameter_list|,
name|unsigned
name|nbBits
parameter_list|)
block|{
name|bitC
operator|->
name|bitContainer
operator||=
operator|(
name|value
operator|&
name|BIT_mask
index|[
name|nbBits
index|]
operator|)
operator|<<
name|bitC
operator|->
name|bitPos
expr_stmt|;
name|bitC
operator|->
name|bitPos
operator|+=
name|nbBits
expr_stmt|;
block|}
comment|/*! BIT_addBitsFast() :  *  works only if `value` is _clean_, meaning all high bits above nbBits are 0 */
name|MEM_STATIC
name|void
name|BIT_addBitsFast
parameter_list|(
name|BIT_CStream_t
modifier|*
name|bitC
parameter_list|,
name|size_t
name|value
parameter_list|,
name|unsigned
name|nbBits
parameter_list|)
block|{
name|assert
argument_list|(
operator|(
name|value
operator|>>
name|nbBits
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|bitC
operator|->
name|bitContainer
operator||=
name|value
operator|<<
name|bitC
operator|->
name|bitPos
expr_stmt|;
name|bitC
operator|->
name|bitPos
operator|+=
name|nbBits
expr_stmt|;
block|}
comment|/*! BIT_flushBitsFast() :  *  assumption : bitContainer has not overflowed  *  unsafe version; does not check buffer overflow */
name|MEM_STATIC
name|void
name|BIT_flushBitsFast
parameter_list|(
name|BIT_CStream_t
modifier|*
name|bitC
parameter_list|)
block|{
name|size_t
specifier|const
name|nbBytes
init|=
name|bitC
operator|->
name|bitPos
operator|>>
literal|3
decl_stmt|;
name|assert
argument_list|(
name|bitC
operator|->
name|bitPos
operator|<=
operator|(
sizeof|sizeof
argument_list|(
name|bitC
operator|->
name|bitContainer
argument_list|)
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|MEM_writeLEST
argument_list|(
name|bitC
operator|->
name|ptr
argument_list|,
name|bitC
operator|->
name|bitContainer
argument_list|)
expr_stmt|;
name|bitC
operator|->
name|ptr
operator|+=
name|nbBytes
expr_stmt|;
name|assert
argument_list|(
name|bitC
operator|->
name|ptr
operator|<=
name|bitC
operator|->
name|endPtr
argument_list|)
expr_stmt|;
name|bitC
operator|->
name|bitPos
operator|&=
literal|7
expr_stmt|;
name|bitC
operator|->
name|bitContainer
operator|>>=
name|nbBytes
operator|*
literal|8
expr_stmt|;
block|}
comment|/*! BIT_flushBits() :  *  assumption : bitContainer has not overflowed  *  safe version; check for buffer overflow, and prevents it.  *  note : does not signal buffer overflow.  *  overflow will be revealed later on using BIT_closeCStream() */
name|MEM_STATIC
name|void
name|BIT_flushBits
parameter_list|(
name|BIT_CStream_t
modifier|*
name|bitC
parameter_list|)
block|{
name|size_t
specifier|const
name|nbBytes
init|=
name|bitC
operator|->
name|bitPos
operator|>>
literal|3
decl_stmt|;
name|assert
argument_list|(
name|bitC
operator|->
name|bitPos
operator|<=
operator|(
sizeof|sizeof
argument_list|(
name|bitC
operator|->
name|bitContainer
argument_list|)
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|MEM_writeLEST
argument_list|(
name|bitC
operator|->
name|ptr
argument_list|,
name|bitC
operator|->
name|bitContainer
argument_list|)
expr_stmt|;
name|bitC
operator|->
name|ptr
operator|+=
name|nbBytes
expr_stmt|;
if|if
condition|(
name|bitC
operator|->
name|ptr
operator|>
name|bitC
operator|->
name|endPtr
condition|)
name|bitC
operator|->
name|ptr
operator|=
name|bitC
operator|->
name|endPtr
expr_stmt|;
name|bitC
operator|->
name|bitPos
operator|&=
literal|7
expr_stmt|;
name|bitC
operator|->
name|bitContainer
operator|>>=
name|nbBytes
operator|*
literal|8
expr_stmt|;
block|}
comment|/*! BIT_closeCStream() :  *  @return : size of CStream, in bytes,               or 0 if it could not fit into dstBuffer */
name|MEM_STATIC
name|size_t
name|BIT_closeCStream
parameter_list|(
name|BIT_CStream_t
modifier|*
name|bitC
parameter_list|)
block|{
name|BIT_addBitsFast
argument_list|(
name|bitC
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* endMark */
name|BIT_flushBits
argument_list|(
name|bitC
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitC
operator|->
name|ptr
operator|>=
name|bitC
operator|->
name|endPtr
condition|)
return|return
literal|0
return|;
comment|/* overflow detected */
return|return
operator|(
name|bitC
operator|->
name|ptr
operator|-
name|bitC
operator|->
name|startPtr
operator|)
operator|+
operator|(
name|bitC
operator|->
name|bitPos
operator|>
literal|0
operator|)
return|;
block|}
comment|/*-******************************************************** * bitStream decoding **********************************************************/
comment|/*! BIT_initDStream() : *   Initialize a BIT_DStream_t. *   `bitD` : a pointer to an already allocated BIT_DStream_t structure. *   `srcSize` must be the *exact* size of the bitStream, in bytes. *   @return : size of stream (== srcSize) or an errorCode if a problem is detected */
name|MEM_STATIC
name|size_t
name|BIT_initDStream
parameter_list|(
name|BIT_DStream_t
modifier|*
name|bitD
parameter_list|,
specifier|const
name|void
modifier|*
name|srcBuffer
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
if|if
condition|(
name|srcSize
operator|<
literal|1
condition|)
block|{
name|memset
argument_list|(
name|bitD
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bitD
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
block|}
name|bitD
operator|->
name|start
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|srcBuffer
expr_stmt|;
name|bitD
operator|->
name|limitPtr
operator|=
name|bitD
operator|->
name|start
operator|+
sizeof|sizeof
argument_list|(
name|bitD
operator|->
name|bitContainer
argument_list|)
expr_stmt|;
if|if
condition|(
name|srcSize
operator|>=
sizeof|sizeof
argument_list|(
name|bitD
operator|->
name|bitContainer
argument_list|)
condition|)
block|{
comment|/* normal case */
name|bitD
operator|->
name|ptr
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|srcBuffer
operator|+
name|srcSize
operator|-
sizeof|sizeof
argument_list|(
name|bitD
operator|->
name|bitContainer
argument_list|)
expr_stmt|;
name|bitD
operator|->
name|bitContainer
operator|=
name|MEM_readLEST
argument_list|(
name|bitD
operator|->
name|ptr
argument_list|)
expr_stmt|;
block|{
name|BYTE
specifier|const
name|lastByte
init|=
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|srcBuffer
operator|)
index|[
name|srcSize
operator|-
literal|1
index|]
decl_stmt|;
name|bitD
operator|->
name|bitsConsumed
operator|=
name|lastByte
condition|?
literal|8
operator|-
name|BIT_highbit32
argument_list|(
name|lastByte
argument_list|)
else|:
literal|0
expr_stmt|;
comment|/* ensures bitsConsumed is always set */
if|if
condition|(
name|lastByte
operator|==
literal|0
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
comment|/* endMark not present */
block|}
block|}
else|else
block|{
name|bitD
operator|->
name|ptr
operator|=
name|bitD
operator|->
name|start
expr_stmt|;
name|bitD
operator|->
name|bitContainer
operator|=
operator|*
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|bitD
operator|->
name|start
operator|)
expr_stmt|;
switch|switch
condition|(
name|srcSize
condition|)
block|{
case|case
literal|7
case|:
name|bitD
operator|->
name|bitContainer
operator|+=
call|(
name|size_t
call|)
argument_list|(
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|srcBuffer
operator|)
operator|)
index|[
literal|6
index|]
argument_list|)
operator|<<
operator|(
sizeof|sizeof
argument_list|(
name|bitD
operator|->
name|bitContainer
argument_list|)
operator|*
literal|8
operator|-
literal|16
operator|)
expr_stmt|;
comment|/* fall-through */
case|case
literal|6
case|:
name|bitD
operator|->
name|bitContainer
operator|+=
call|(
name|size_t
call|)
argument_list|(
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|srcBuffer
operator|)
operator|)
index|[
literal|5
index|]
argument_list|)
operator|<<
operator|(
sizeof|sizeof
argument_list|(
name|bitD
operator|->
name|bitContainer
argument_list|)
operator|*
literal|8
operator|-
literal|24
operator|)
expr_stmt|;
comment|/* fall-through */
case|case
literal|5
case|:
name|bitD
operator|->
name|bitContainer
operator|+=
call|(
name|size_t
call|)
argument_list|(
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|srcBuffer
operator|)
operator|)
index|[
literal|4
index|]
argument_list|)
operator|<<
operator|(
sizeof|sizeof
argument_list|(
name|bitD
operator|->
name|bitContainer
argument_list|)
operator|*
literal|8
operator|-
literal|32
operator|)
expr_stmt|;
comment|/* fall-through */
case|case
literal|4
case|:
name|bitD
operator|->
name|bitContainer
operator|+=
call|(
name|size_t
call|)
argument_list|(
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|srcBuffer
operator|)
operator|)
index|[
literal|3
index|]
argument_list|)
operator|<<
literal|24
expr_stmt|;
comment|/* fall-through */
case|case
literal|3
case|:
name|bitD
operator|->
name|bitContainer
operator|+=
call|(
name|size_t
call|)
argument_list|(
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|srcBuffer
operator|)
operator|)
index|[
literal|2
index|]
argument_list|)
operator|<<
literal|16
expr_stmt|;
comment|/* fall-through */
case|case
literal|2
case|:
name|bitD
operator|->
name|bitContainer
operator|+=
call|(
name|size_t
call|)
argument_list|(
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|srcBuffer
operator|)
operator|)
index|[
literal|1
index|]
argument_list|)
operator|<<
literal|8
expr_stmt|;
comment|/* fall-through */
default|default:
break|break;
block|}
block|{
name|BYTE
specifier|const
name|lastByte
init|=
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|srcBuffer
operator|)
index|[
name|srcSize
operator|-
literal|1
index|]
decl_stmt|;
name|bitD
operator|->
name|bitsConsumed
operator|=
name|lastByte
condition|?
literal|8
operator|-
name|BIT_highbit32
argument_list|(
name|lastByte
argument_list|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|lastByte
operator|==
literal|0
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
comment|/* endMark not present */
block|}
name|bitD
operator|->
name|bitsConsumed
operator|+=
call|(
name|U32
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|bitD
operator|->
name|bitContainer
argument_list|)
operator|-
name|srcSize
argument_list|)
operator|*
literal|8
expr_stmt|;
block|}
return|return
name|srcSize
return|;
block|}
name|MEM_STATIC
name|size_t
name|BIT_getUpperBits
parameter_list|(
name|size_t
name|bitContainer
parameter_list|,
name|U32
specifier|const
name|start
parameter_list|)
block|{
return|return
name|bitContainer
operator|>>
name|start
return|;
block|}
name|MEM_STATIC
name|size_t
name|BIT_getMiddleBits
parameter_list|(
name|size_t
name|bitContainer
parameter_list|,
name|U32
specifier|const
name|start
parameter_list|,
name|U32
specifier|const
name|nbBits
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__BMI__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
name|__GNUC__
operator|*
literal|1000
operator|+
name|__GNUC_MINOR__
operator|>=
literal|4008
comment|/* experimental */
if|#
directive|if
name|defined
argument_list|(
name|__x86_64__
argument_list|)
if|if
condition|(
sizeof|sizeof
argument_list|(
name|bitContainer
argument_list|)
operator|==
literal|8
condition|)
return|return
name|_bextr_u64
argument_list|(
name|bitContainer
argument_list|,
name|start
argument_list|,
name|nbBits
argument_list|)
return|;
else|else
endif|#
directive|endif
return|return
name|_bextr_u32
argument_list|(
name|bitContainer
argument_list|,
name|start
argument_list|,
name|nbBits
argument_list|)
return|;
else|#
directive|else
return|return
operator|(
name|bitContainer
operator|>>
name|start
operator|)
operator|&
name|BIT_mask
index|[
name|nbBits
index|]
return|;
endif|#
directive|endif
block|}
name|MEM_STATIC
name|size_t
name|BIT_getLowerBits
parameter_list|(
name|size_t
name|bitContainer
parameter_list|,
name|U32
specifier|const
name|nbBits
parameter_list|)
block|{
return|return
name|bitContainer
operator|&
name|BIT_mask
index|[
name|nbBits
index|]
return|;
block|}
comment|/*! BIT_lookBits() :  *  Provides next n bits from local register.  *  local register is not modified.  *  On 32-bits, maxNbBits==24.  *  On 64-bits, maxNbBits==56.  *  @return : value extracted  */
name|MEM_STATIC
name|size_t
name|BIT_lookBits
parameter_list|(
specifier|const
name|BIT_DStream_t
modifier|*
name|bitD
parameter_list|,
name|U32
name|nbBits
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__BMI__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__GNUC__
argument_list|)
comment|/* experimental; fails if bitD->bitsConsumed + nbBits> sizeof(bitD->bitContainer)*8 */
return|return
name|BIT_getMiddleBits
argument_list|(
name|bitD
operator|->
name|bitContainer
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|bitD
operator|->
name|bitContainer
argument_list|)
operator|*
literal|8
operator|)
operator|-
name|bitD
operator|->
name|bitsConsumed
operator|-
name|nbBits
argument_list|,
name|nbBits
argument_list|)
return|;
else|#
directive|else
name|U32
specifier|const
name|regMask
init|=
sizeof|sizeof
argument_list|(
name|bitD
operator|->
name|bitContainer
argument_list|)
operator|*
literal|8
operator|-
literal|1
decl_stmt|;
return|return
operator|(
operator|(
name|bitD
operator|->
name|bitContainer
operator|<<
operator|(
name|bitD
operator|->
name|bitsConsumed
operator|&
name|regMask
operator|)
operator|)
operator|>>
literal|1
operator|)
operator|>>
operator|(
operator|(
name|regMask
operator|-
name|nbBits
operator|)
operator|&
name|regMask
operator|)
return|;
endif|#
directive|endif
block|}
comment|/*! BIT_lookBitsFast() :  *  unsafe version; only works if nbBits>= 1 */
name|MEM_STATIC
name|size_t
name|BIT_lookBitsFast
parameter_list|(
specifier|const
name|BIT_DStream_t
modifier|*
name|bitD
parameter_list|,
name|U32
name|nbBits
parameter_list|)
block|{
name|U32
specifier|const
name|regMask
init|=
sizeof|sizeof
argument_list|(
name|bitD
operator|->
name|bitContainer
argument_list|)
operator|*
literal|8
operator|-
literal|1
decl_stmt|;
name|assert
argument_list|(
name|nbBits
operator|>=
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|bitD
operator|->
name|bitContainer
operator|<<
operator|(
name|bitD
operator|->
name|bitsConsumed
operator|&
name|regMask
operator|)
operator|)
operator|>>
operator|(
operator|(
operator|(
name|regMask
operator|+
literal|1
operator|)
operator|-
name|nbBits
operator|)
operator|&
name|regMask
operator|)
return|;
block|}
name|MEM_STATIC
name|void
name|BIT_skipBits
parameter_list|(
name|BIT_DStream_t
modifier|*
name|bitD
parameter_list|,
name|U32
name|nbBits
parameter_list|)
block|{
name|bitD
operator|->
name|bitsConsumed
operator|+=
name|nbBits
expr_stmt|;
block|}
comment|/*! BIT_readBits() :  *  Read (consume) next n bits from local register and update.  *  Pay attention to not read more than nbBits contained into local register.  *  @return : extracted value.  */
name|MEM_STATIC
name|size_t
name|BIT_readBits
parameter_list|(
name|BIT_DStream_t
modifier|*
name|bitD
parameter_list|,
name|U32
name|nbBits
parameter_list|)
block|{
name|size_t
specifier|const
name|value
init|=
name|BIT_lookBits
argument_list|(
name|bitD
argument_list|,
name|nbBits
argument_list|)
decl_stmt|;
name|BIT_skipBits
argument_list|(
name|bitD
argument_list|,
name|nbBits
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
comment|/*! BIT_readBitsFast() : *   unsafe version; only works only if nbBits>= 1 */
name|MEM_STATIC
name|size_t
name|BIT_readBitsFast
parameter_list|(
name|BIT_DStream_t
modifier|*
name|bitD
parameter_list|,
name|U32
name|nbBits
parameter_list|)
block|{
name|size_t
specifier|const
name|value
init|=
name|BIT_lookBitsFast
argument_list|(
name|bitD
argument_list|,
name|nbBits
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|nbBits
operator|>=
literal|1
argument_list|)
expr_stmt|;
name|BIT_skipBits
argument_list|(
name|bitD
argument_list|,
name|nbBits
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
comment|/*! BIT_reloadDStream() : *   Refill `bitD` from buffer previously set in BIT_initDStream() . *   This function is safe, it guarantees it will not read beyond src buffer. *   @return : status of `BIT_DStream_t` internal register.               if status == BIT_DStream_unfinished, internal register is filled with>= (sizeof(bitD->bitContainer)*8 - 7) bits */
name|MEM_STATIC
name|BIT_DStream_status
name|BIT_reloadDStream
parameter_list|(
name|BIT_DStream_t
modifier|*
name|bitD
parameter_list|)
block|{
if|if
condition|(
name|bitD
operator|->
name|bitsConsumed
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|bitD
operator|->
name|bitContainer
argument_list|)
operator|*
literal|8
operator|)
condition|)
comment|/* overflow detected, like end of stream */
return|return
name|BIT_DStream_overflow
return|;
if|if
condition|(
name|bitD
operator|->
name|ptr
operator|>=
name|bitD
operator|->
name|limitPtr
condition|)
block|{
name|bitD
operator|->
name|ptr
operator|-=
name|bitD
operator|->
name|bitsConsumed
operator|>>
literal|3
expr_stmt|;
name|bitD
operator|->
name|bitsConsumed
operator|&=
literal|7
expr_stmt|;
name|bitD
operator|->
name|bitContainer
operator|=
name|MEM_readLEST
argument_list|(
name|bitD
operator|->
name|ptr
argument_list|)
expr_stmt|;
return|return
name|BIT_DStream_unfinished
return|;
block|}
if|if
condition|(
name|bitD
operator|->
name|ptr
operator|==
name|bitD
operator|->
name|start
condition|)
block|{
if|if
condition|(
name|bitD
operator|->
name|bitsConsumed
operator|<
sizeof|sizeof
argument_list|(
name|bitD
operator|->
name|bitContainer
argument_list|)
operator|*
literal|8
condition|)
return|return
name|BIT_DStream_endOfBuffer
return|;
return|return
name|BIT_DStream_completed
return|;
block|}
comment|/* start< ptr< limitPtr */
block|{
name|U32
name|nbBytes
init|=
name|bitD
operator|->
name|bitsConsumed
operator|>>
literal|3
decl_stmt|;
name|BIT_DStream_status
name|result
init|=
name|BIT_DStream_unfinished
decl_stmt|;
if|if
condition|(
name|bitD
operator|->
name|ptr
operator|-
name|nbBytes
operator|<
name|bitD
operator|->
name|start
condition|)
block|{
name|nbBytes
operator|=
call|(
name|U32
call|)
argument_list|(
name|bitD
operator|->
name|ptr
operator|-
name|bitD
operator|->
name|start
argument_list|)
expr_stmt|;
comment|/* ptr> start */
name|result
operator|=
name|BIT_DStream_endOfBuffer
expr_stmt|;
block|}
name|bitD
operator|->
name|ptr
operator|-=
name|nbBytes
expr_stmt|;
name|bitD
operator|->
name|bitsConsumed
operator|-=
name|nbBytes
operator|*
literal|8
expr_stmt|;
name|bitD
operator|->
name|bitContainer
operator|=
name|MEM_readLEST
argument_list|(
name|bitD
operator|->
name|ptr
argument_list|)
expr_stmt|;
comment|/* reminder : srcSize> sizeof(bitD->bitContainer), otherwise bitD->ptr == bitD->start */
return|return
name|result
return|;
block|}
block|}
comment|/*! BIT_endOfDStream() : *   @return Tells if DStream has exactly reached its end (all bits consumed). */
name|MEM_STATIC
name|unsigned
name|BIT_endOfDStream
parameter_list|(
specifier|const
name|BIT_DStream_t
modifier|*
name|DStream
parameter_list|)
block|{
return|return
operator|(
operator|(
name|DStream
operator|->
name|ptr
operator|==
name|DStream
operator|->
name|start
operator|)
operator|&&
operator|(
name|DStream
operator|->
name|bitsConsumed
operator|==
sizeof|sizeof
argument_list|(
name|DStream
operator|->
name|bitContainer
argument_list|)
operator|*
literal|8
operator|)
operator|)
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BITSTREAM_H_MODULE */
end_comment

end_unit

