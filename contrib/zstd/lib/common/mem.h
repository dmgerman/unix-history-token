begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright (c) 2016-present, Yann Collet, Facebook, Inc.  * All rights reserved.  *  * This source code is licensed under the BSD-style license found in the  * LICENSE file in the root directory of this source tree. An additional grant  * of patent rights can be found in the PATENTS file in the same directory.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MEM_H_MODULE
end_ifndef

begin_define
define|#
directive|define
name|MEM_H_MODULE
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/*-**************************************** *  Dependencies ******************************************/
include|#
directive|include
file|<stddef.h>
comment|/* size_t, ptrdiff_t */
include|#
directive|include
file|<string.h>
comment|/* memcpy */
comment|/*-**************************************** *  Compiler specifics ******************************************/
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
comment|/* Visual Studio */
include|#
directive|include
file|<stdlib.h>
comment|/* _byteswap_ulong */
include|#
directive|include
file|<intrin.h>
comment|/* _byteswap_* */
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
define|#
directive|define
name|MEM_STATIC
value|static __inline __attribute__((unused))
elif|#
directive|elif
name|defined
argument_list|(
name|__cplusplus
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|__STDC_VERSION__
argument_list|)
operator|&&
operator|(
name|__STDC_VERSION__
operator|>=
literal|199901L
operator|)
comment|/* C99 */
operator|)
define|#
directive|define
name|MEM_STATIC
value|static inline
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
define|#
directive|define
name|MEM_STATIC
value|static __inline
else|#
directive|else
define|#
directive|define
name|MEM_STATIC
value|static
comment|/* this version may generate warnings for unused static functions; disable the relevant warning */
endif|#
directive|endif
comment|/* code only tested on 32 and 64 bits systems */
define|#
directive|define
name|MEM_STATIC_ASSERT
parameter_list|(
name|c
parameter_list|)
value|{ enum { MEM_static_assert = 1/(int)(!!(c)) }; }
name|MEM_STATIC
name|void
name|MEM_check
parameter_list|(
name|void
parameter_list|)
block|{
name|MEM_STATIC_ASSERT
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|==
literal|4
operator|)
operator|||
operator|(
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|==
literal|8
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/*-************************************************************** *  Basic Types *****************************************************************/
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__VMS
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|__cplusplus
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|__STDC_VERSION__
argument_list|)
operator|&&
operator|(
name|__STDC_VERSION__
operator|>=
literal|199901L
operator|)
comment|/* C99 */
operator|)
operator|)
include|#
directive|include
file|<stdint.h>
typedef|typedef
name|uint8_t
name|BYTE
typedef|;
typedef|typedef
name|uint16_t
name|U16
typedef|;
typedef|typedef
name|int16_t
name|S16
typedef|;
typedef|typedef
name|uint32_t
name|U32
typedef|;
typedef|typedef
name|int32_t
name|S32
typedef|;
typedef|typedef
name|uint64_t
name|U64
typedef|;
typedef|typedef
name|int64_t
name|S64
typedef|;
typedef|typedef
name|intptr_t
name|iPtrDiff
typedef|;
typedef|typedef
name|uintptr_t
name|uPtrDiff
typedef|;
else|#
directive|else
typedef|typedef
name|unsigned
name|char
name|BYTE
typedef|;
typedef|typedef
name|unsigned
name|short
name|U16
typedef|;
typedef|typedef
name|signed
name|short
name|S16
typedef|;
typedef|typedef
name|unsigned
name|int
name|U32
typedef|;
typedef|typedef
name|signed
name|int
name|S32
typedef|;
typedef|typedef
name|unsigned
name|long
name|long
name|U64
typedef|;
typedef|typedef
name|signed
name|long
name|long
name|S64
typedef|;
typedef|typedef
name|ptrdiff_t
name|iPtrDiff
typedef|;
typedef|typedef
name|size_t
name|uPtrDiff
typedef|;
endif|#
directive|endif
comment|/*-************************************************************** *  Memory I/O *****************************************************************/
comment|/* MEM_FORCE_MEMORY_ACCESS :  * By default, access to unaligned memory is controlled by `memcpy()`, which is safe and portable.  * Unfortunately, on some target/compiler combinations, the generated assembly is sub-optimal.  * The below switch allow to select different access method for improved performance.  * Method 0 (default) : use `memcpy()`. Safe and portable.  * Method 1 : `__packed` statement. It depends on compiler extension (i.e., not portable).  *            This method is safe if your compiler supports it, and *generally* as fast or faster than `memcpy`.  * Method 2 : direct access. This method is portable but violate C standard.  *            It can generate buggy code on targets depending on alignment.  *            In some circumstances, it's the only known way to get the most performance (i.e. GCC + ARMv6)  * See http://fastcompression.blogspot.fr/2015/08/accessing-unaligned-memory.html for details.  * Prefer these methods in priority order (0> 1> 2)  */
ifndef|#
directive|ifndef
name|MEM_FORCE_MEMORY_ACCESS
comment|/* can be defined externally, on command line for example */
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|__ARM_ARCH_6__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_6J__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_6K__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_6Z__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_6ZK__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_6T2__
argument_list|)
operator|)
define|#
directive|define
name|MEM_FORCE_MEMORY_ACCESS
value|2
elif|#
directive|elif
name|defined
argument_list|(
name|__INTEL_COMPILER
argument_list|)
operator|||
name|defined
argument_list|(
name|__GNUC__
argument_list|)
define|#
directive|define
name|MEM_FORCE_MEMORY_ACCESS
value|1
endif|#
directive|endif
endif|#
directive|endif
name|MEM_STATIC
name|unsigned
name|MEM_32bits
parameter_list|(
name|void
parameter_list|)
block|{
return|return
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|==
literal|4
return|;
block|}
name|MEM_STATIC
name|unsigned
name|MEM_64bits
parameter_list|(
name|void
parameter_list|)
block|{
return|return
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|==
literal|8
return|;
block|}
name|MEM_STATIC
name|unsigned
name|MEM_isLittleEndian
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
union|union
block|{
name|U32
name|u
decl_stmt|;
name|BYTE
name|c
index|[
literal|4
index|]
decl_stmt|;
block|}
name|one
init|=
block|{
literal|1
block|}
union|;
comment|/* don't use static : performance detrimental  */
return|return
name|one
operator|.
name|c
index|[
literal|0
index|]
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|MEM_FORCE_MEMORY_ACCESS
argument_list|)
operator|&&
operator|(
name|MEM_FORCE_MEMORY_ACCESS
operator|==
literal|2
operator|)
comment|/* violates C standard, by lying on structure alignment. Only use if no other choice to achieve best performance on target platform */
name|MEM_STATIC
name|U16
name|MEM_read16
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
return|return
operator|*
operator|(
specifier|const
name|U16
operator|*
operator|)
name|memPtr
return|;
block|}
name|MEM_STATIC
name|U32
name|MEM_read32
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
return|return
operator|*
operator|(
specifier|const
name|U32
operator|*
operator|)
name|memPtr
return|;
block|}
name|MEM_STATIC
name|U64
name|MEM_read64
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
return|return
operator|*
operator|(
specifier|const
name|U64
operator|*
operator|)
name|memPtr
return|;
block|}
name|MEM_STATIC
name|U64
name|MEM_readST
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
return|return
operator|*
operator|(
specifier|const
name|size_t
operator|*
operator|)
name|memPtr
return|;
block|}
name|MEM_STATIC
name|void
name|MEM_write16
parameter_list|(
name|void
modifier|*
name|memPtr
parameter_list|,
name|U16
name|value
parameter_list|)
block|{
operator|*
operator|(
name|U16
operator|*
operator|)
name|memPtr
operator|=
name|value
expr_stmt|;
block|}
name|MEM_STATIC
name|void
name|MEM_write32
parameter_list|(
name|void
modifier|*
name|memPtr
parameter_list|,
name|U32
name|value
parameter_list|)
block|{
operator|*
operator|(
name|U32
operator|*
operator|)
name|memPtr
operator|=
name|value
expr_stmt|;
block|}
name|MEM_STATIC
name|void
name|MEM_write64
parameter_list|(
name|void
modifier|*
name|memPtr
parameter_list|,
name|U64
name|value
parameter_list|)
block|{
operator|*
operator|(
name|U64
operator|*
operator|)
name|memPtr
operator|=
name|value
expr_stmt|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|MEM_FORCE_MEMORY_ACCESS
argument_list|)
operator|&&
operator|(
name|MEM_FORCE_MEMORY_ACCESS
operator|==
literal|1
operator|)
comment|/* __pack instructions are safer, but compiler specific, hence potentially problematic for some compilers */
comment|/* currently only defined for gcc and icc */
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|__INTEL_COMPILER
argument_list|)
operator|&&
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|)
name|__pragma
argument_list|(
argument|pack(push,
literal|1
argument|)
argument_list|)
typedef|typedef
union|union
block|{
name|U16
name|u16
decl_stmt|;
name|U32
name|u32
decl_stmt|;
name|U64
name|u64
decl_stmt|;
name|size_t
name|st
decl_stmt|;
block|}
name|unalign
typedef|;
name|__pragma
argument_list|(
argument|pack(pop)
argument_list|)
else|#
directive|else
typedef|typedef
union|union
block|{
name|U16
name|u16
decl_stmt|;
name|U32
name|u32
decl_stmt|;
name|U64
name|u64
decl_stmt|;
name|size_t
name|st
decl_stmt|;
block|}
name|__attribute__
typedef|((
name|packed
typedef|))
name|unalign
typedef|;
endif|#
directive|endif
name|MEM_STATIC
name|U16
name|MEM_read16
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
return|return
operator|(
operator|(
specifier|const
name|unalign
operator|*
operator|)
name|ptr
operator|)
operator|->
name|u16
return|;
block|}
name|MEM_STATIC
name|U32
name|MEM_read32
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
return|return
operator|(
operator|(
specifier|const
name|unalign
operator|*
operator|)
name|ptr
operator|)
operator|->
name|u32
return|;
block|}
name|MEM_STATIC
name|U64
name|MEM_read64
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
return|return
operator|(
operator|(
specifier|const
name|unalign
operator|*
operator|)
name|ptr
operator|)
operator|->
name|u64
return|;
block|}
name|MEM_STATIC
name|U64
name|MEM_readST
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
return|return
operator|(
operator|(
specifier|const
name|unalign
operator|*
operator|)
name|ptr
operator|)
operator|->
name|st
return|;
block|}
name|MEM_STATIC
name|void
name|MEM_write16
parameter_list|(
name|void
modifier|*
name|memPtr
parameter_list|,
name|U16
name|value
parameter_list|)
block|{
operator|(
operator|(
name|unalign
operator|*
operator|)
name|memPtr
operator|)
operator|->
name|u16
operator|=
name|value
expr_stmt|;
block|}
name|MEM_STATIC
name|void
name|MEM_write32
parameter_list|(
name|void
modifier|*
name|memPtr
parameter_list|,
name|U32
name|value
parameter_list|)
block|{
operator|(
operator|(
name|unalign
operator|*
operator|)
name|memPtr
operator|)
operator|->
name|u32
operator|=
name|value
expr_stmt|;
block|}
name|MEM_STATIC
name|void
name|MEM_write64
parameter_list|(
name|void
modifier|*
name|memPtr
parameter_list|,
name|U64
name|value
parameter_list|)
block|{
operator|(
operator|(
name|unalign
operator|*
operator|)
name|memPtr
operator|)
operator|->
name|u64
operator|=
name|value
expr_stmt|;
block|}
else|#
directive|else
comment|/* default method, safe and standard.    can sometimes prove slower */
name|MEM_STATIC
name|U16
name|MEM_read16
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
name|U16
name|val
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|val
argument_list|,
name|memPtr
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
name|MEM_STATIC
name|U32
name|MEM_read32
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
name|U32
name|val
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|val
argument_list|,
name|memPtr
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
name|MEM_STATIC
name|U64
name|MEM_read64
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
name|U64
name|val
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|val
argument_list|,
name|memPtr
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
name|MEM_STATIC
name|size_t
name|MEM_readST
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
name|size_t
name|val
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|val
argument_list|,
name|memPtr
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
name|MEM_STATIC
name|void
name|MEM_write16
parameter_list|(
name|void
modifier|*
name|memPtr
parameter_list|,
name|U16
name|value
parameter_list|)
block|{
name|memcpy
argument_list|(
name|memPtr
argument_list|,
operator|&
name|value
argument_list|,
sizeof|sizeof
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|MEM_STATIC
name|void
name|MEM_write32
parameter_list|(
name|void
modifier|*
name|memPtr
parameter_list|,
name|U32
name|value
parameter_list|)
block|{
name|memcpy
argument_list|(
name|memPtr
argument_list|,
operator|&
name|value
argument_list|,
sizeof|sizeof
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|MEM_STATIC
name|void
name|MEM_write64
parameter_list|(
name|void
modifier|*
name|memPtr
parameter_list|,
name|U64
name|value
parameter_list|)
block|{
name|memcpy
argument_list|(
name|memPtr
argument_list|,
operator|&
name|value
argument_list|,
sizeof|sizeof
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MEM_FORCE_MEMORY_ACCESS */
name|MEM_STATIC
name|U32
name|MEM_swap32
parameter_list|(
name|U32
name|in
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
comment|/* Visual Studio */
return|return
name|_byteswap_ulong
argument_list|(
name|in
argument_list|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|__GNUC__
operator|*
literal|100
operator|+
name|__GNUC_MINOR__
operator|>=
literal|403
operator|)
return|return
name|__builtin_bswap32
argument_list|(
name|in
argument_list|)
return|;
else|#
directive|else
return|return
operator|(
operator|(
name|in
operator|<<
literal|24
operator|)
operator|&
literal|0xff000000
operator|)
operator||
operator|(
operator|(
name|in
operator|<<
literal|8
operator|)
operator|&
literal|0x00ff0000
operator|)
operator||
operator|(
operator|(
name|in
operator|>>
literal|8
operator|)
operator|&
literal|0x0000ff00
operator|)
operator||
operator|(
operator|(
name|in
operator|>>
literal|24
operator|)
operator|&
literal|0x000000ff
operator|)
return|;
endif|#
directive|endif
block|}
name|MEM_STATIC
name|U64
name|MEM_swap64
parameter_list|(
name|U64
name|in
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
comment|/* Visual Studio */
return|return
name|_byteswap_uint64
argument_list|(
name|in
argument_list|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|__GNUC__
operator|*
literal|100
operator|+
name|__GNUC_MINOR__
operator|>=
literal|403
operator|)
return|return
name|__builtin_bswap64
argument_list|(
name|in
argument_list|)
return|;
else|#
directive|else
return|return
operator|(
operator|(
name|in
operator|<<
literal|56
operator|)
operator|&
literal|0xff00000000000000ULL
operator|)
operator||
operator|(
operator|(
name|in
operator|<<
literal|40
operator|)
operator|&
literal|0x00ff000000000000ULL
operator|)
operator||
operator|(
operator|(
name|in
operator|<<
literal|24
operator|)
operator|&
literal|0x0000ff0000000000ULL
operator|)
operator||
operator|(
operator|(
name|in
operator|<<
literal|8
operator|)
operator|&
literal|0x000000ff00000000ULL
operator|)
operator||
operator|(
operator|(
name|in
operator|>>
literal|8
operator|)
operator|&
literal|0x00000000ff000000ULL
operator|)
operator||
operator|(
operator|(
name|in
operator|>>
literal|24
operator|)
operator|&
literal|0x0000000000ff0000ULL
operator|)
operator||
operator|(
operator|(
name|in
operator|>>
literal|40
operator|)
operator|&
literal|0x000000000000ff00ULL
operator|)
operator||
operator|(
operator|(
name|in
operator|>>
literal|56
operator|)
operator|&
literal|0x00000000000000ffULL
operator|)
return|;
endif|#
directive|endif
block|}
name|MEM_STATIC
name|size_t
name|MEM_swapST
parameter_list|(
name|size_t
name|in
parameter_list|)
block|{
if|if
condition|(
name|MEM_32bits
argument_list|()
condition|)
return|return
operator|(
name|size_t
operator|)
name|MEM_swap32
argument_list|(
operator|(
name|U32
operator|)
name|in
argument_list|)
return|;
else|else
return|return
operator|(
name|size_t
operator|)
name|MEM_swap64
argument_list|(
operator|(
name|U64
operator|)
name|in
argument_list|)
return|;
block|}
comment|/*=== Little endian r/w ===*/
name|MEM_STATIC
name|U16
name|MEM_readLE16
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
if|if
condition|(
name|MEM_isLittleEndian
argument_list|()
condition|)
return|return
name|MEM_read16
argument_list|(
name|memPtr
argument_list|)
return|;
else|else
block|{
specifier|const
name|BYTE
modifier|*
name|p
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|memPtr
decl_stmt|;
return|return
call|(
name|U16
call|)
argument_list|(
name|p
index|[
literal|0
index|]
operator|+
operator|(
name|p
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
argument_list|)
return|;
block|}
block|}
name|MEM_STATIC
name|void
name|MEM_writeLE16
parameter_list|(
name|void
modifier|*
name|memPtr
parameter_list|,
name|U16
name|val
parameter_list|)
block|{
if|if
condition|(
name|MEM_isLittleEndian
argument_list|()
condition|)
block|{
name|MEM_write16
argument_list|(
name|memPtr
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BYTE
modifier|*
name|p
init|=
operator|(
name|BYTE
operator|*
operator|)
name|memPtr
decl_stmt|;
name|p
index|[
literal|0
index|]
operator|=
operator|(
name|BYTE
operator|)
name|val
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
call|(
name|BYTE
call|)
argument_list|(
name|val
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
name|MEM_STATIC
name|U32
name|MEM_readLE24
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
return|return
name|MEM_readLE16
argument_list|(
name|memPtr
argument_list|)
operator|+
operator|(
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|memPtr
operator|)
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
return|;
block|}
name|MEM_STATIC
name|void
name|MEM_writeLE24
parameter_list|(
name|void
modifier|*
name|memPtr
parameter_list|,
name|U32
name|val
parameter_list|)
block|{
name|MEM_writeLE16
argument_list|(
name|memPtr
argument_list|,
operator|(
name|U16
operator|)
name|val
argument_list|)
expr_stmt|;
operator|(
operator|(
name|BYTE
operator|*
operator|)
name|memPtr
operator|)
index|[
literal|2
index|]
operator|=
call|(
name|BYTE
call|)
argument_list|(
name|val
operator|>>
literal|16
argument_list|)
expr_stmt|;
block|}
name|MEM_STATIC
name|U32
name|MEM_readLE32
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
if|if
condition|(
name|MEM_isLittleEndian
argument_list|()
condition|)
return|return
name|MEM_read32
argument_list|(
name|memPtr
argument_list|)
return|;
else|else
return|return
name|MEM_swap32
argument_list|(
name|MEM_read32
argument_list|(
name|memPtr
argument_list|)
argument_list|)
return|;
block|}
name|MEM_STATIC
name|void
name|MEM_writeLE32
parameter_list|(
name|void
modifier|*
name|memPtr
parameter_list|,
name|U32
name|val32
parameter_list|)
block|{
if|if
condition|(
name|MEM_isLittleEndian
argument_list|()
condition|)
name|MEM_write32
argument_list|(
name|memPtr
argument_list|,
name|val32
argument_list|)
expr_stmt|;
else|else
name|MEM_write32
argument_list|(
name|memPtr
argument_list|,
name|MEM_swap32
argument_list|(
name|val32
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|MEM_STATIC
name|U64
name|MEM_readLE64
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
if|if
condition|(
name|MEM_isLittleEndian
argument_list|()
condition|)
return|return
name|MEM_read64
argument_list|(
name|memPtr
argument_list|)
return|;
else|else
return|return
name|MEM_swap64
argument_list|(
name|MEM_read64
argument_list|(
name|memPtr
argument_list|)
argument_list|)
return|;
block|}
name|MEM_STATIC
name|void
name|MEM_writeLE64
parameter_list|(
name|void
modifier|*
name|memPtr
parameter_list|,
name|U64
name|val64
parameter_list|)
block|{
if|if
condition|(
name|MEM_isLittleEndian
argument_list|()
condition|)
name|MEM_write64
argument_list|(
name|memPtr
argument_list|,
name|val64
argument_list|)
expr_stmt|;
else|else
name|MEM_write64
argument_list|(
name|memPtr
argument_list|,
name|MEM_swap64
argument_list|(
name|val64
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|MEM_STATIC
name|size_t
name|MEM_readLEST
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
if|if
condition|(
name|MEM_32bits
argument_list|()
condition|)
return|return
operator|(
name|size_t
operator|)
name|MEM_readLE32
argument_list|(
name|memPtr
argument_list|)
return|;
else|else
return|return
operator|(
name|size_t
operator|)
name|MEM_readLE64
argument_list|(
name|memPtr
argument_list|)
return|;
block|}
name|MEM_STATIC
name|void
name|MEM_writeLEST
parameter_list|(
name|void
modifier|*
name|memPtr
parameter_list|,
name|size_t
name|val
parameter_list|)
block|{
if|if
condition|(
name|MEM_32bits
argument_list|()
condition|)
name|MEM_writeLE32
argument_list|(
name|memPtr
argument_list|,
operator|(
name|U32
operator|)
name|val
argument_list|)
expr_stmt|;
else|else
name|MEM_writeLE64
argument_list|(
name|memPtr
argument_list|,
operator|(
name|U64
operator|)
name|val
argument_list|)
expr_stmt|;
block|}
comment|/*=== Big endian r/w ===*/
name|MEM_STATIC
name|U32
name|MEM_readBE32
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
if|if
condition|(
name|MEM_isLittleEndian
argument_list|()
condition|)
return|return
name|MEM_swap32
argument_list|(
name|MEM_read32
argument_list|(
name|memPtr
argument_list|)
argument_list|)
return|;
else|else
return|return
name|MEM_read32
argument_list|(
name|memPtr
argument_list|)
return|;
block|}
name|MEM_STATIC
name|void
name|MEM_writeBE32
parameter_list|(
name|void
modifier|*
name|memPtr
parameter_list|,
name|U32
name|val32
parameter_list|)
block|{
if|if
condition|(
name|MEM_isLittleEndian
argument_list|()
condition|)
name|MEM_write32
argument_list|(
name|memPtr
argument_list|,
name|MEM_swap32
argument_list|(
name|val32
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|MEM_write32
argument_list|(
name|memPtr
argument_list|,
name|val32
argument_list|)
expr_stmt|;
block|}
name|MEM_STATIC
name|U64
name|MEM_readBE64
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
if|if
condition|(
name|MEM_isLittleEndian
argument_list|()
condition|)
return|return
name|MEM_swap64
argument_list|(
name|MEM_read64
argument_list|(
name|memPtr
argument_list|)
argument_list|)
return|;
else|else
return|return
name|MEM_read64
argument_list|(
name|memPtr
argument_list|)
return|;
block|}
name|MEM_STATIC
name|void
name|MEM_writeBE64
parameter_list|(
name|void
modifier|*
name|memPtr
parameter_list|,
name|U64
name|val64
parameter_list|)
block|{
if|if
condition|(
name|MEM_isLittleEndian
argument_list|()
condition|)
name|MEM_write64
argument_list|(
name|memPtr
argument_list|,
name|MEM_swap64
argument_list|(
name|val64
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|MEM_write64
argument_list|(
name|memPtr
argument_list|,
name|val64
argument_list|)
expr_stmt|;
block|}
name|MEM_STATIC
name|size_t
name|MEM_readBEST
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
if|if
condition|(
name|MEM_32bits
argument_list|()
condition|)
return|return
operator|(
name|size_t
operator|)
name|MEM_readBE32
argument_list|(
name|memPtr
argument_list|)
return|;
else|else
return|return
operator|(
name|size_t
operator|)
name|MEM_readBE64
argument_list|(
name|memPtr
argument_list|)
return|;
block|}
name|MEM_STATIC
name|void
name|MEM_writeBEST
parameter_list|(
name|void
modifier|*
name|memPtr
parameter_list|,
name|size_t
name|val
parameter_list|)
block|{
if|if
condition|(
name|MEM_32bits
argument_list|()
condition|)
name|MEM_writeBE32
argument_list|(
name|memPtr
argument_list|,
operator|(
name|U32
operator|)
name|val
argument_list|)
expr_stmt|;
else|else
name|MEM_writeBE64
argument_list|(
name|memPtr
argument_list|,
operator|(
name|U64
operator|)
name|val
argument_list|)
expr_stmt|;
block|}
comment|/* function safe only for comparisons */
name|MEM_STATIC
name|U32
name|MEM_readMINMATCH
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|,
name|U32
name|length
parameter_list|)
block|{
switch|switch
condition|(
name|length
condition|)
block|{
default|default :
case|case
literal|4
case|:
return|return
name|MEM_read32
argument_list|(
name|memPtr
argument_list|)
return|;
case|case
literal|3
case|:
if|if
condition|(
name|MEM_isLittleEndian
argument_list|()
condition|)
return|return
name|MEM_read32
argument_list|(
name|memPtr
argument_list|)
operator|<<
literal|8
return|;
else|else
return|return
name|MEM_read32
argument_list|(
name|memPtr
argument_list|)
operator|>>
literal|8
return|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MEM_H_MODULE */
end_comment

end_unit

