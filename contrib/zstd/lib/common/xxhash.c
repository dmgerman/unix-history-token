begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* *  xxHash - Fast Hash algorithm *  Copyright (C) 2012-2016, Yann Collet * *  BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php) * *  Redistribution and use in source and binary forms, with or without *  modification, are permitted provided that the following conditions are *  met: * *  * Redistributions of source code must retain the above copyright *  notice, this list of conditions and the following disclaimer. *  * Redistributions in binary form must reproduce the above *  copyright notice, this list of conditions and the following disclaimer *  in the documentation and/or other materials provided with the *  distribution. * *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. * *  You can contact the author at : *  - xxHash homepage: http://www.xxhash.com *  - xxHash source repository : https://github.com/Cyan4973/xxHash */
end_comment

begin_comment
comment|/* ************************************* *  Tuning parameters ***************************************/
end_comment

begin_comment
comment|/*!XXH_FORCE_MEMORY_ACCESS :  * By default, access to unaligned memory is controlled by `memcpy()`, which is safe and portable.  * Unfortunately, on some target/compiler combinations, the generated assembly is sub-optimal.  * The below switch allow to select different access method for improved performance.  * Method 0 (default) : use `memcpy()`. Safe and portable.  * Method 1 : `__packed` statement. It depends on compiler extension (ie, not portable).  *            This method is safe if your compiler supports it, and *generally* as fast or faster than `memcpy`.  * Method 2 : direct access. This method doesn't depend on compiler but violate C standard.  *            It can generate buggy code on targets which do not support unaligned memory accesses.  *            But in some circumstances, it's the only known way to get the most performance (ie GCC + ARMv6)  * See http://stackoverflow.com/a/32095106/646947 for details.  * Prefer these methods in priority order (0> 1> 2)  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|XXH_FORCE_MEMORY_ACCESS
end_ifndef

begin_comment
comment|/* can be defined externally, on command line for example */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|__ARM_ARCH_6__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_6J__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_6K__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_6Z__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_6ZK__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_6T2__
argument_list|)
operator|)
end_if

begin_define
define|#
directive|define
name|XXH_FORCE_MEMORY_ACCESS
value|2
end_define

begin_elif
elif|#
directive|elif
operator|(
name|defined
argument_list|(
name|__INTEL_COMPILER
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|)
operator|||
expr|\
operator|(
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|__ARM_ARCH_7__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_7A__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_7R__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_7M__
argument_list|)
operator|||
name|defined
argument_list|(
name|__ARM_ARCH_7S__
argument_list|)
operator|)
operator|)
end_elif

begin_define
define|#
directive|define
name|XXH_FORCE_MEMORY_ACCESS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*!XXH_ACCEPT_NULL_INPUT_POINTER :  * If the input pointer is a null pointer, xxHash default behavior is to trigger a memory access error, since it is a bad pointer.  * When this option is enabled, xxHash output for null input pointers will be the same as a null-length input.  * By default, this option is disabled. To enable it, uncomment below define :  */
end_comment

begin_comment
comment|/* #define XXH_ACCEPT_NULL_INPUT_POINTER 1 */
end_comment

begin_comment
comment|/*!XXH_FORCE_NATIVE_FORMAT :  * By default, xxHash library provides endian-independant Hash values, based on little-endian convention.  * Results are therefore identical for little-endian and big-endian CPU.  * This comes at a performance cost for big-endian CPU, since some swapping is required to emulate little-endian format.  * Should endian-independance be of no importance for your application, you may set the #define below to 1,  * to improve speed for Big-endian CPU.  * This option has no impact on Little_Endian CPU.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|XXH_FORCE_NATIVE_FORMAT
end_ifndef

begin_comment
comment|/* can be defined externally */
end_comment

begin_define
define|#
directive|define
name|XXH_FORCE_NATIVE_FORMAT
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*!XXH_FORCE_ALIGN_CHECK :  * This is a minor performance trick, only useful with lots of very small keys.  * It means : check for aligned/unaligned input.  * The check costs one initial branch per hash; set to 0 when the input data  * is guaranteed to be aligned.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|XXH_FORCE_ALIGN_CHECK
end_ifndef

begin_comment
comment|/* can be defined externally */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386
argument_list|)
operator|||
name|defined
argument_list|(
name|_M_IX86
argument_list|)
operator|||
name|defined
argument_list|(
name|__x86_64__
argument_list|)
operator|||
name|defined
argument_list|(
name|_M_X64
argument_list|)
end_if

begin_define
define|#
directive|define
name|XXH_FORCE_ALIGN_CHECK
value|0
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|XXH_FORCE_ALIGN_CHECK
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ************************************* *  Includes& Memory related functions ***************************************/
end_comment

begin_comment
comment|/* Modify the local functions below should you wish to use some other memory routines */
end_comment

begin_comment
comment|/* for malloc(), free() */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_function
specifier|static
name|void
modifier|*
name|XXH_malloc
parameter_list|(
name|size_t
name|s
parameter_list|)
block|{
return|return
name|malloc
argument_list|(
name|s
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|XXH_free
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* for memcpy() */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_function
specifier|static
name|void
modifier|*
name|XXH_memcpy
parameter_list|(
name|void
modifier|*
name|dest
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
return|return
name|memcpy
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|XXH_STATIC_LINKING_ONLY
end_ifndef

begin_define
define|#
directive|define
name|XXH_STATIC_LINKING_ONLY
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"xxhash.h"
end_include

begin_comment
comment|/* ************************************* *  Compiler Specific Options ***************************************/
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__cplusplus
argument_list|)
operator|||
name|defined
argument_list|(
name|__STDC_VERSION__
argument_list|)
operator|&&
name|__STDC_VERSION__
operator|>=
literal|199901L
end_if

begin_comment
comment|/* C99 */
end_comment

begin_define
define|#
directive|define
name|INLINE_KEYWORD
value|inline
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|INLINE_KEYWORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
end_if

begin_define
define|#
directive|define
name|FORCE_INLINE_ATTR
value|__attribute__((always_inline))
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_elif

begin_define
define|#
directive|define
name|FORCE_INLINE_ATTR
value|__forceinline
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FORCE_INLINE_ATTR
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|FORCE_INLINE_TEMPLATE
value|static INLINE_KEYWORD FORCE_INLINE_ATTR
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4127
name|)
end_pragma

begin_comment
comment|/* disable: C4127: conditional expression is constant */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ************************************* *  Basic Types ***************************************/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MEM_MODULE
end_ifndef

begin_define
define|#
directive|define
name|MEM_MODULE
end_define

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__VMS
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|__cplusplus
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|__STDC_VERSION__
argument_list|)
operator|&&
operator|(
name|__STDC_VERSION__
operator|>=
literal|199901L
operator|)
comment|/* C99 */
operator|)
operator|)
end_if

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_typedef
typedef|typedef
name|uint8_t
name|BYTE
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|uint16_t
name|U16
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|uint32_t
name|U32
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|int32_t
name|S32
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|uint64_t
name|U64
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|unsigned
name|char
name|BYTE
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|short
name|U16
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|int
name|U32
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|signed
name|int
name|S32
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|long
name|long
name|U64
typedef|;
end_typedef

begin_comment
comment|/* if your compiler doesn't support unsigned long long, replace by another 64-bit type here. Note that xxhash.h will also need to be updated. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|XXH_FORCE_MEMORY_ACCESS
argument_list|)
operator|&&
operator|(
name|XXH_FORCE_MEMORY_ACCESS
operator|==
literal|2
operator|)
operator|)
end_if

begin_comment
comment|/* Force direct memory access. Only works on CPU which support unaligned memory access in hardware */
end_comment

begin_function
specifier|static
name|U32
name|XXH_read32
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
return|return
operator|*
operator|(
specifier|const
name|U32
operator|*
operator|)
name|memPtr
return|;
block|}
end_function

begin_function
specifier|static
name|U64
name|XXH_read64
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
return|return
operator|*
operator|(
specifier|const
name|U64
operator|*
operator|)
name|memPtr
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
operator|(
name|defined
argument_list|(
name|XXH_FORCE_MEMORY_ACCESS
argument_list|)
operator|&&
operator|(
name|XXH_FORCE_MEMORY_ACCESS
operator|==
literal|1
operator|)
operator|)
end_elif

begin_comment
comment|/* __pack instructions are safer, but compiler specific, hence potentially problematic for some compilers */
end_comment

begin_comment
comment|/* currently only defined for gcc and icc */
end_comment

begin_typedef
typedef|typedef
union|union
block|{
name|U32
name|u32
decl_stmt|;
name|U64
name|u64
decl_stmt|;
block|}
name|__attribute__
typedef|((
name|packed
typedef|))
name|unalign
typedef|;
end_typedef

begin_function
specifier|static
name|U32
name|XXH_read32
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
return|return
operator|(
operator|(
specifier|const
name|unalign
operator|*
operator|)
name|ptr
operator|)
operator|->
name|u32
return|;
block|}
end_function

begin_function
specifier|static
name|U64
name|XXH_read64
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
return|return
operator|(
operator|(
specifier|const
name|unalign
operator|*
operator|)
name|ptr
operator|)
operator|->
name|u64
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* portable and safe solution. Generally efficient.  * see : http://stackoverflow.com/a/32095106/646947  */
end_comment

begin_function
specifier|static
name|U32
name|XXH_read32
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
name|U32
name|val
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|val
argument_list|,
name|memPtr
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|U64
name|XXH_read64
parameter_list|(
specifier|const
name|void
modifier|*
name|memPtr
parameter_list|)
block|{
name|U64
name|val
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|val
argument_list|,
name|memPtr
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XXH_FORCE_DIRECT_MEMORY_ACCESS */
end_comment

begin_comment
comment|/* **************************************** *  Compiler-specific Functions and Macros ******************************************/
end_comment

begin_define
define|#
directive|define
name|GCC_VERSION
value|(__GNUC__ * 100 + __GNUC_MINOR__)
end_define

begin_comment
comment|/* Note : although _rotl exists for minGW (GCC under windows), performance seems poor */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_if

begin_define
define|#
directive|define
name|XXH_rotl32
parameter_list|(
name|x
parameter_list|,
name|r
parameter_list|)
value|_rotl(x,r)
end_define

begin_define
define|#
directive|define
name|XXH_rotl64
parameter_list|(
name|x
parameter_list|,
name|r
parameter_list|)
value|_rotl64(x,r)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|XXH_rotl32
parameter_list|(
name|x
parameter_list|,
name|r
parameter_list|)
value|((x<< r) | (x>> (32 - r)))
end_define

begin_define
define|#
directive|define
name|XXH_rotl64
parameter_list|(
name|x
parameter_list|,
name|r
parameter_list|)
value|((x<< r) | (x>> (64 - r)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_if

begin_comment
comment|/* Visual Studio */
end_comment

begin_define
define|#
directive|define
name|XXH_swap32
value|_byteswap_ulong
end_define

begin_define
define|#
directive|define
name|XXH_swap64
value|_byteswap_uint64
end_define

begin_elif
elif|#
directive|elif
operator|(
name|GCC_VERSION
operator|>=
literal|403
operator|&&
operator|!
name|defined
argument_list|(
name|__riscv
argument_list|)
operator|)
end_elif

begin_define
define|#
directive|define
name|XXH_swap32
value|__builtin_bswap32
end_define

begin_define
define|#
directive|define
name|XXH_swap64
value|__builtin_bswap64
end_define

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|U32
name|XXH_swap32
parameter_list|(
name|U32
name|x
parameter_list|)
block|{
return|return
operator|(
operator|(
name|x
operator|<<
literal|24
operator|)
operator|&
literal|0xff000000
operator|)
operator||
operator|(
operator|(
name|x
operator|<<
literal|8
operator|)
operator|&
literal|0x00ff0000
operator|)
operator||
operator|(
operator|(
name|x
operator|>>
literal|8
operator|)
operator|&
literal|0x0000ff00
operator|)
operator||
operator|(
operator|(
name|x
operator|>>
literal|24
operator|)
operator|&
literal|0x000000ff
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|U64
name|XXH_swap64
parameter_list|(
name|U64
name|x
parameter_list|)
block|{
return|return
operator|(
operator|(
name|x
operator|<<
literal|56
operator|)
operator|&
literal|0xff00000000000000ULL
operator|)
operator||
operator|(
operator|(
name|x
operator|<<
literal|40
operator|)
operator|&
literal|0x00ff000000000000ULL
operator|)
operator||
operator|(
operator|(
name|x
operator|<<
literal|24
operator|)
operator|&
literal|0x0000ff0000000000ULL
operator|)
operator||
operator|(
operator|(
name|x
operator|<<
literal|8
operator|)
operator|&
literal|0x000000ff00000000ULL
operator|)
operator||
operator|(
operator|(
name|x
operator|>>
literal|8
operator|)
operator|&
literal|0x00000000ff000000ULL
operator|)
operator||
operator|(
operator|(
name|x
operator|>>
literal|24
operator|)
operator|&
literal|0x0000000000ff0000ULL
operator|)
operator||
operator|(
operator|(
name|x
operator|>>
literal|40
operator|)
operator|&
literal|0x000000000000ff00ULL
operator|)
operator||
operator|(
operator|(
name|x
operator|>>
literal|56
operator|)
operator|&
literal|0x00000000000000ffULL
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ************************************* *  Architecture Macros ***************************************/
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|XXH_bigEndian
init|=
literal|0
block|,
name|XXH_littleEndian
init|=
literal|1
block|}
name|XXH_endianess
typedef|;
end_typedef

begin_comment
comment|/* XXH_CPU_LITTLE_ENDIAN can be defined externally, for example on the compiler command line */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|XXH_CPU_LITTLE_ENDIAN
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|int
name|g_one
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|XXH_CPU_LITTLE_ENDIAN
value|(*(const char*)(&g_one))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* *************************** *  Memory reads *****************************/
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|XXH_aligned
block|,
name|XXH_unaligned
block|}
name|XXH_alignment
typedef|;
end_typedef

begin_function
name|FORCE_INLINE_TEMPLATE
name|U32
name|XXH_readLE32_align
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|XXH_endianess
name|endian
parameter_list|,
name|XXH_alignment
name|align
parameter_list|)
block|{
if|if
condition|(
name|align
operator|==
name|XXH_unaligned
condition|)
return|return
name|endian
operator|==
name|XXH_littleEndian
condition|?
name|XXH_read32
argument_list|(
name|ptr
argument_list|)
else|:
name|XXH_swap32
argument_list|(
name|XXH_read32
argument_list|(
name|ptr
argument_list|)
argument_list|)
return|;
else|else
return|return
name|endian
operator|==
name|XXH_littleEndian
condition|?
operator|*
operator|(
specifier|const
name|U32
operator|*
operator|)
name|ptr
else|:
name|XXH_swap32
argument_list|(
operator|*
operator|(
specifier|const
name|U32
operator|*
operator|)
name|ptr
argument_list|)
return|;
block|}
end_function

begin_function
name|FORCE_INLINE_TEMPLATE
name|U32
name|XXH_readLE32
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|XXH_endianess
name|endian
parameter_list|)
block|{
return|return
name|XXH_readLE32_align
argument_list|(
name|ptr
argument_list|,
name|endian
argument_list|,
name|XXH_unaligned
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|U32
name|XXH_readBE32
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
return|return
name|XXH_CPU_LITTLE_ENDIAN
condition|?
name|XXH_swap32
argument_list|(
name|XXH_read32
argument_list|(
name|ptr
argument_list|)
argument_list|)
else|:
name|XXH_read32
argument_list|(
name|ptr
argument_list|)
return|;
block|}
end_function

begin_function
name|FORCE_INLINE_TEMPLATE
name|U64
name|XXH_readLE64_align
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|XXH_endianess
name|endian
parameter_list|,
name|XXH_alignment
name|align
parameter_list|)
block|{
if|if
condition|(
name|align
operator|==
name|XXH_unaligned
condition|)
return|return
name|endian
operator|==
name|XXH_littleEndian
condition|?
name|XXH_read64
argument_list|(
name|ptr
argument_list|)
else|:
name|XXH_swap64
argument_list|(
name|XXH_read64
argument_list|(
name|ptr
argument_list|)
argument_list|)
return|;
else|else
return|return
name|endian
operator|==
name|XXH_littleEndian
condition|?
operator|*
operator|(
specifier|const
name|U64
operator|*
operator|)
name|ptr
else|:
name|XXH_swap64
argument_list|(
operator|*
operator|(
specifier|const
name|U64
operator|*
operator|)
name|ptr
argument_list|)
return|;
block|}
end_function

begin_function
name|FORCE_INLINE_TEMPLATE
name|U64
name|XXH_readLE64
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|XXH_endianess
name|endian
parameter_list|)
block|{
return|return
name|XXH_readLE64_align
argument_list|(
name|ptr
argument_list|,
name|endian
argument_list|,
name|XXH_unaligned
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|U64
name|XXH_readBE64
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
return|return
name|XXH_CPU_LITTLE_ENDIAN
condition|?
name|XXH_swap64
argument_list|(
name|XXH_read64
argument_list|(
name|ptr
argument_list|)
argument_list|)
else|:
name|XXH_read64
argument_list|(
name|ptr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ************************************* *  Macros ***************************************/
end_comment

begin_define
define|#
directive|define
name|XXH_STATIC_ASSERT
parameter_list|(
name|c
parameter_list|)
value|{ enum { XXH_static_assert = 1/(int)(!!(c)) }; }
end_define

begin_comment
comment|/* use only *after* variable declarations */
end_comment

begin_comment
comment|/* ************************************* *  Constants ***************************************/
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|U32
name|PRIME32_1
init|=
literal|2654435761U
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|U32
name|PRIME32_2
init|=
literal|2246822519U
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|U32
name|PRIME32_3
init|=
literal|3266489917U
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|U32
name|PRIME32_4
init|=
literal|668265263U
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|U32
name|PRIME32_5
init|=
literal|374761393U
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|U64
name|PRIME64_1
init|=
literal|11400714785074694791ULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|U64
name|PRIME64_2
init|=
literal|14029467366897019727ULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|U64
name|PRIME64_3
init|=
literal|1609587929392839161ULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|U64
name|PRIME64_4
init|=
literal|9650029242287828579ULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|U64
name|PRIME64_5
init|=
literal|2870177450012600261ULL
decl_stmt|;
end_decl_stmt

begin_function
name|XXH_PUBLIC_API
name|unsigned
name|XXH_versionNumber
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|XXH_VERSION_NUMBER
return|;
block|}
end_function

begin_comment
comment|/* ************************** *  Utils ****************************/
end_comment

begin_function
name|XXH_PUBLIC_API
name|void
name|XXH32_copyState
parameter_list|(
name|XXH32_state_t
modifier|*
specifier|restrict
name|dstState
parameter_list|,
specifier|const
name|XXH32_state_t
modifier|*
specifier|restrict
name|srcState
parameter_list|)
block|{
name|memcpy
argument_list|(
name|dstState
argument_list|,
name|srcState
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dstState
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|XXH_PUBLIC_API
name|void
name|XXH64_copyState
parameter_list|(
name|XXH64_state_t
modifier|*
specifier|restrict
name|dstState
parameter_list|,
specifier|const
name|XXH64_state_t
modifier|*
specifier|restrict
name|srcState
parameter_list|)
block|{
name|memcpy
argument_list|(
name|dstState
argument_list|,
name|srcState
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dstState
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* *************************** *  Simple Hash Functions *****************************/
end_comment

begin_function
specifier|static
name|U32
name|XXH32_round
parameter_list|(
name|U32
name|seed
parameter_list|,
name|U32
name|input
parameter_list|)
block|{
name|seed
operator|+=
name|input
operator|*
name|PRIME32_2
expr_stmt|;
name|seed
operator|=
name|XXH_rotl32
argument_list|(
name|seed
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|seed
operator|*=
name|PRIME32_1
expr_stmt|;
return|return
name|seed
return|;
block|}
end_function

begin_function
name|FORCE_INLINE_TEMPLATE
name|U32
name|XXH32_endian_align
parameter_list|(
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|size_t
name|len
parameter_list|,
name|U32
name|seed
parameter_list|,
name|XXH_endianess
name|endian
parameter_list|,
name|XXH_alignment
name|align
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|p
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|input
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|bEnd
init|=
name|p
operator|+
name|len
decl_stmt|;
name|U32
name|h32
decl_stmt|;
define|#
directive|define
name|XXH_get32bits
parameter_list|(
name|p
parameter_list|)
value|XXH_readLE32_align(p, endian, align)
ifdef|#
directive|ifdef
name|XXH_ACCEPT_NULL_INPUT_POINTER
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|len
operator|=
literal|0
expr_stmt|;
name|bEnd
operator|=
name|p
operator|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|size_t
operator|)
literal|16
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|len
operator|>=
literal|16
condition|)
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|limit
init|=
name|bEnd
operator|-
literal|16
decl_stmt|;
name|U32
name|v1
init|=
name|seed
operator|+
name|PRIME32_1
operator|+
name|PRIME32_2
decl_stmt|;
name|U32
name|v2
init|=
name|seed
operator|+
name|PRIME32_2
decl_stmt|;
name|U32
name|v3
init|=
name|seed
operator|+
literal|0
decl_stmt|;
name|U32
name|v4
init|=
name|seed
operator|-
name|PRIME32_1
decl_stmt|;
do|do
block|{
name|v1
operator|=
name|XXH32_round
argument_list|(
name|v1
argument_list|,
name|XXH_get32bits
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|v2
operator|=
name|XXH32_round
argument_list|(
name|v2
argument_list|,
name|XXH_get32bits
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|v3
operator|=
name|XXH32_round
argument_list|(
name|v3
argument_list|,
name|XXH_get32bits
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|v4
operator|=
name|XXH32_round
argument_list|(
name|v4
argument_list|,
name|XXH_get32bits
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|<=
name|limit
condition|)
do|;
name|h32
operator|=
name|XXH_rotl32
argument_list|(
name|v1
argument_list|,
literal|1
argument_list|)
operator|+
name|XXH_rotl32
argument_list|(
name|v2
argument_list|,
literal|7
argument_list|)
operator|+
name|XXH_rotl32
argument_list|(
name|v3
argument_list|,
literal|12
argument_list|)
operator|+
name|XXH_rotl32
argument_list|(
name|v4
argument_list|,
literal|18
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|h32
operator|=
name|seed
operator|+
name|PRIME32_5
expr_stmt|;
block|}
name|h32
operator|+=
operator|(
name|U32
operator|)
name|len
expr_stmt|;
while|while
condition|(
name|p
operator|+
literal|4
operator|<=
name|bEnd
condition|)
block|{
name|h32
operator|+=
name|XXH_get32bits
argument_list|(
name|p
argument_list|)
operator|*
name|PRIME32_3
expr_stmt|;
name|h32
operator|=
name|XXH_rotl32
argument_list|(
name|h32
argument_list|,
literal|17
argument_list|)
operator|*
name|PRIME32_4
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
while|while
condition|(
name|p
operator|<
name|bEnd
condition|)
block|{
name|h32
operator|+=
operator|(
operator|*
name|p
operator|)
operator|*
name|PRIME32_5
expr_stmt|;
name|h32
operator|=
name|XXH_rotl32
argument_list|(
name|h32
argument_list|,
literal|11
argument_list|)
operator|*
name|PRIME32_1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|h32
operator|^=
name|h32
operator|>>
literal|15
expr_stmt|;
name|h32
operator|*=
name|PRIME32_2
expr_stmt|;
name|h32
operator|^=
name|h32
operator|>>
literal|13
expr_stmt|;
name|h32
operator|*=
name|PRIME32_3
expr_stmt|;
name|h32
operator|^=
name|h32
operator|>>
literal|16
expr_stmt|;
return|return
name|h32
return|;
block|}
end_function

begin_function
name|XXH_PUBLIC_API
name|unsigned
name|int
name|XXH32
parameter_list|(
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|size_t
name|len
parameter_list|,
name|unsigned
name|int
name|seed
parameter_list|)
block|{
if|#
directive|if
literal|0
comment|/* Simple version, good for code maintenance, but unfortunately slow for small inputs */
block|XXH32_CREATESTATE_STATIC(state);     XXH32_reset(state, seed);     XXH32_update(state, input, len);     return XXH32_digest(state);
else|#
directive|else
name|XXH_endianess
name|endian_detected
init|=
operator|(
name|XXH_endianess
operator|)
name|XXH_CPU_LITTLE_ENDIAN
decl_stmt|;
if|if
condition|(
name|XXH_FORCE_ALIGN_CHECK
condition|)
block|{
if|if
condition|(
operator|(
operator|(
operator|(
name|size_t
operator|)
name|input
operator|)
operator|&
literal|3
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Input is 4-bytes aligned, leverage the speed benefit */
if|if
condition|(
operator|(
name|endian_detected
operator|==
name|XXH_littleEndian
operator|)
operator|||
name|XXH_FORCE_NATIVE_FORMAT
condition|)
return|return
name|XXH32_endian_align
argument_list|(
name|input
argument_list|,
name|len
argument_list|,
name|seed
argument_list|,
name|XXH_littleEndian
argument_list|,
name|XXH_aligned
argument_list|)
return|;
else|else
return|return
name|XXH32_endian_align
argument_list|(
name|input
argument_list|,
name|len
argument_list|,
name|seed
argument_list|,
name|XXH_bigEndian
argument_list|,
name|XXH_aligned
argument_list|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|endian_detected
operator|==
name|XXH_littleEndian
operator|)
operator|||
name|XXH_FORCE_NATIVE_FORMAT
condition|)
return|return
name|XXH32_endian_align
argument_list|(
name|input
argument_list|,
name|len
argument_list|,
name|seed
argument_list|,
name|XXH_littleEndian
argument_list|,
name|XXH_unaligned
argument_list|)
return|;
else|else
return|return
name|XXH32_endian_align
argument_list|(
name|input
argument_list|,
name|len
argument_list|,
name|seed
argument_list|,
name|XXH_bigEndian
argument_list|,
name|XXH_unaligned
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|U64
name|XXH64_round
parameter_list|(
name|U64
name|acc
parameter_list|,
name|U64
name|input
parameter_list|)
block|{
name|acc
operator|+=
name|input
operator|*
name|PRIME64_2
expr_stmt|;
name|acc
operator|=
name|XXH_rotl64
argument_list|(
name|acc
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|acc
operator|*=
name|PRIME64_1
expr_stmt|;
return|return
name|acc
return|;
block|}
end_function

begin_function
specifier|static
name|U64
name|XXH64_mergeRound
parameter_list|(
name|U64
name|acc
parameter_list|,
name|U64
name|val
parameter_list|)
block|{
name|val
operator|=
name|XXH64_round
argument_list|(
literal|0
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|acc
operator|^=
name|val
expr_stmt|;
name|acc
operator|=
name|acc
operator|*
name|PRIME64_1
operator|+
name|PRIME64_4
expr_stmt|;
return|return
name|acc
return|;
block|}
end_function

begin_function
name|FORCE_INLINE_TEMPLATE
name|U64
name|XXH64_endian_align
parameter_list|(
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|size_t
name|len
parameter_list|,
name|U64
name|seed
parameter_list|,
name|XXH_endianess
name|endian
parameter_list|,
name|XXH_alignment
name|align
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|p
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|input
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|bEnd
init|=
name|p
operator|+
name|len
decl_stmt|;
name|U64
name|h64
decl_stmt|;
define|#
directive|define
name|XXH_get64bits
parameter_list|(
name|p
parameter_list|)
value|XXH_readLE64_align(p, endian, align)
ifdef|#
directive|ifdef
name|XXH_ACCEPT_NULL_INPUT_POINTER
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|len
operator|=
literal|0
expr_stmt|;
name|bEnd
operator|=
name|p
operator|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|size_t
operator|)
literal|32
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|len
operator|>=
literal|32
condition|)
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|limit
init|=
name|bEnd
operator|-
literal|32
decl_stmt|;
name|U64
name|v1
init|=
name|seed
operator|+
name|PRIME64_1
operator|+
name|PRIME64_2
decl_stmt|;
name|U64
name|v2
init|=
name|seed
operator|+
name|PRIME64_2
decl_stmt|;
name|U64
name|v3
init|=
name|seed
operator|+
literal|0
decl_stmt|;
name|U64
name|v4
init|=
name|seed
operator|-
name|PRIME64_1
decl_stmt|;
do|do
block|{
name|v1
operator|=
name|XXH64_round
argument_list|(
name|v1
argument_list|,
name|XXH_get64bits
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|8
expr_stmt|;
name|v2
operator|=
name|XXH64_round
argument_list|(
name|v2
argument_list|,
name|XXH_get64bits
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|8
expr_stmt|;
name|v3
operator|=
name|XXH64_round
argument_list|(
name|v3
argument_list|,
name|XXH_get64bits
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|8
expr_stmt|;
name|v4
operator|=
name|XXH64_round
argument_list|(
name|v4
argument_list|,
name|XXH_get64bits
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|8
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|<=
name|limit
condition|)
do|;
name|h64
operator|=
name|XXH_rotl64
argument_list|(
name|v1
argument_list|,
literal|1
argument_list|)
operator|+
name|XXH_rotl64
argument_list|(
name|v2
argument_list|,
literal|7
argument_list|)
operator|+
name|XXH_rotl64
argument_list|(
name|v3
argument_list|,
literal|12
argument_list|)
operator|+
name|XXH_rotl64
argument_list|(
name|v4
argument_list|,
literal|18
argument_list|)
expr_stmt|;
name|h64
operator|=
name|XXH64_mergeRound
argument_list|(
name|h64
argument_list|,
name|v1
argument_list|)
expr_stmt|;
name|h64
operator|=
name|XXH64_mergeRound
argument_list|(
name|h64
argument_list|,
name|v2
argument_list|)
expr_stmt|;
name|h64
operator|=
name|XXH64_mergeRound
argument_list|(
name|h64
argument_list|,
name|v3
argument_list|)
expr_stmt|;
name|h64
operator|=
name|XXH64_mergeRound
argument_list|(
name|h64
argument_list|,
name|v4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|h64
operator|=
name|seed
operator|+
name|PRIME64_5
expr_stmt|;
block|}
name|h64
operator|+=
operator|(
name|U64
operator|)
name|len
expr_stmt|;
while|while
condition|(
name|p
operator|+
literal|8
operator|<=
name|bEnd
condition|)
block|{
name|U64
specifier|const
name|k1
init|=
name|XXH64_round
argument_list|(
literal|0
argument_list|,
name|XXH_get64bits
argument_list|(
name|p
argument_list|)
argument_list|)
decl_stmt|;
name|h64
operator|^=
name|k1
expr_stmt|;
name|h64
operator|=
name|XXH_rotl64
argument_list|(
name|h64
argument_list|,
literal|27
argument_list|)
operator|*
name|PRIME64_1
operator|+
name|PRIME64_4
expr_stmt|;
name|p
operator|+=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|+
literal|4
operator|<=
name|bEnd
condition|)
block|{
name|h64
operator|^=
call|(
name|U64
call|)
argument_list|(
name|XXH_get32bits
argument_list|(
name|p
argument_list|)
argument_list|)
operator|*
name|PRIME64_1
expr_stmt|;
name|h64
operator|=
name|XXH_rotl64
argument_list|(
name|h64
argument_list|,
literal|23
argument_list|)
operator|*
name|PRIME64_2
operator|+
name|PRIME64_3
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
while|while
condition|(
name|p
operator|<
name|bEnd
condition|)
block|{
name|h64
operator|^=
operator|(
operator|*
name|p
operator|)
operator|*
name|PRIME64_5
expr_stmt|;
name|h64
operator|=
name|XXH_rotl64
argument_list|(
name|h64
argument_list|,
literal|11
argument_list|)
operator|*
name|PRIME64_1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|h64
operator|^=
name|h64
operator|>>
literal|33
expr_stmt|;
name|h64
operator|*=
name|PRIME64_2
expr_stmt|;
name|h64
operator|^=
name|h64
operator|>>
literal|29
expr_stmt|;
name|h64
operator|*=
name|PRIME64_3
expr_stmt|;
name|h64
operator|^=
name|h64
operator|>>
literal|32
expr_stmt|;
return|return
name|h64
return|;
block|}
end_function

begin_function
name|XXH_PUBLIC_API
name|unsigned
name|long
name|long
name|XXH64
parameter_list|(
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|size_t
name|len
parameter_list|,
name|unsigned
name|long
name|long
name|seed
parameter_list|)
block|{
if|#
directive|if
literal|0
comment|/* Simple version, good for code maintenance, but unfortunately slow for small inputs */
block|XXH64_CREATESTATE_STATIC(state);     XXH64_reset(state, seed);     XXH64_update(state, input, len);     return XXH64_digest(state);
else|#
directive|else
name|XXH_endianess
name|endian_detected
init|=
operator|(
name|XXH_endianess
operator|)
name|XXH_CPU_LITTLE_ENDIAN
decl_stmt|;
if|if
condition|(
name|XXH_FORCE_ALIGN_CHECK
condition|)
block|{
if|if
condition|(
operator|(
operator|(
operator|(
name|size_t
operator|)
name|input
operator|)
operator|&
literal|7
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Input is aligned, let's leverage the speed advantage */
if|if
condition|(
operator|(
name|endian_detected
operator|==
name|XXH_littleEndian
operator|)
operator|||
name|XXH_FORCE_NATIVE_FORMAT
condition|)
return|return
name|XXH64_endian_align
argument_list|(
name|input
argument_list|,
name|len
argument_list|,
name|seed
argument_list|,
name|XXH_littleEndian
argument_list|,
name|XXH_aligned
argument_list|)
return|;
else|else
return|return
name|XXH64_endian_align
argument_list|(
name|input
argument_list|,
name|len
argument_list|,
name|seed
argument_list|,
name|XXH_bigEndian
argument_list|,
name|XXH_aligned
argument_list|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|endian_detected
operator|==
name|XXH_littleEndian
operator|)
operator|||
name|XXH_FORCE_NATIVE_FORMAT
condition|)
return|return
name|XXH64_endian_align
argument_list|(
name|input
argument_list|,
name|len
argument_list|,
name|seed
argument_list|,
name|XXH_littleEndian
argument_list|,
name|XXH_unaligned
argument_list|)
return|;
else|else
return|return
name|XXH64_endian_align
argument_list|(
name|input
argument_list|,
name|len
argument_list|,
name|seed
argument_list|,
name|XXH_bigEndian
argument_list|,
name|XXH_unaligned
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ************************************************** *  Advanced Hash Functions ****************************************************/
end_comment

begin_function
name|XXH_PUBLIC_API
name|XXH32_state_t
modifier|*
name|XXH32_createState
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|XXH32_state_t
operator|*
operator|)
name|XXH_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|XXH32_state_t
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|XXH_PUBLIC_API
name|XXH_errorcode
name|XXH32_freeState
parameter_list|(
name|XXH32_state_t
modifier|*
name|statePtr
parameter_list|)
block|{
name|XXH_free
argument_list|(
name|statePtr
argument_list|)
expr_stmt|;
return|return
name|XXH_OK
return|;
block|}
end_function

begin_function
name|XXH_PUBLIC_API
name|XXH64_state_t
modifier|*
name|XXH64_createState
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|XXH64_state_t
operator|*
operator|)
name|XXH_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|XXH64_state_t
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|XXH_PUBLIC_API
name|XXH_errorcode
name|XXH64_freeState
parameter_list|(
name|XXH64_state_t
modifier|*
name|statePtr
parameter_list|)
block|{
name|XXH_free
argument_list|(
name|statePtr
argument_list|)
expr_stmt|;
return|return
name|XXH_OK
return|;
block|}
end_function

begin_comment
comment|/*** Hash feed ***/
end_comment

begin_function
name|XXH_PUBLIC_API
name|XXH_errorcode
name|XXH32_reset
parameter_list|(
name|XXH32_state_t
modifier|*
name|statePtr
parameter_list|,
name|unsigned
name|int
name|seed
parameter_list|)
block|{
name|XXH32_state_t
name|state
decl_stmt|;
comment|/* using a local state to memcpy() in order to avoid strict-aliasing warnings */
name|memset
argument_list|(
operator|&
name|state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|state
argument_list|)
operator|-
literal|4
argument_list|)
expr_stmt|;
comment|/* do not write into reserved, for future removal */
name|state
operator|.
name|v1
operator|=
name|seed
operator|+
name|PRIME32_1
operator|+
name|PRIME32_2
expr_stmt|;
name|state
operator|.
name|v2
operator|=
name|seed
operator|+
name|PRIME32_2
expr_stmt|;
name|state
operator|.
name|v3
operator|=
name|seed
operator|+
literal|0
expr_stmt|;
name|state
operator|.
name|v4
operator|=
name|seed
operator|-
name|PRIME32_1
expr_stmt|;
name|memcpy
argument_list|(
name|statePtr
argument_list|,
operator|&
name|state
argument_list|,
sizeof|sizeof
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|XXH_OK
return|;
block|}
end_function

begin_function
name|XXH_PUBLIC_API
name|XXH_errorcode
name|XXH64_reset
parameter_list|(
name|XXH64_state_t
modifier|*
name|statePtr
parameter_list|,
name|unsigned
name|long
name|long
name|seed
parameter_list|)
block|{
name|XXH64_state_t
name|state
decl_stmt|;
comment|/* using a local state to memcpy() in order to avoid strict-aliasing warnings */
name|memset
argument_list|(
operator|&
name|state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|state
argument_list|)
operator|-
literal|8
argument_list|)
expr_stmt|;
comment|/* do not write into reserved, for future removal */
name|state
operator|.
name|v1
operator|=
name|seed
operator|+
name|PRIME64_1
operator|+
name|PRIME64_2
expr_stmt|;
name|state
operator|.
name|v2
operator|=
name|seed
operator|+
name|PRIME64_2
expr_stmt|;
name|state
operator|.
name|v3
operator|=
name|seed
operator|+
literal|0
expr_stmt|;
name|state
operator|.
name|v4
operator|=
name|seed
operator|-
name|PRIME64_1
expr_stmt|;
name|memcpy
argument_list|(
name|statePtr
argument_list|,
operator|&
name|state
argument_list|,
sizeof|sizeof
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|XXH_OK
return|;
block|}
end_function

begin_function
name|FORCE_INLINE_TEMPLATE
name|XXH_errorcode
name|XXH32_update_endian
parameter_list|(
name|XXH32_state_t
modifier|*
name|state
parameter_list|,
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|size_t
name|len
parameter_list|,
name|XXH_endianess
name|endian
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|p
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|input
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|bEnd
init|=
name|p
operator|+
name|len
decl_stmt|;
ifdef|#
directive|ifdef
name|XXH_ACCEPT_NULL_INPUT_POINTER
if|if
condition|(
name|input
operator|==
name|NULL
condition|)
return|return
name|XXH_ERROR
return|;
endif|#
directive|endif
name|state
operator|->
name|total_len_32
operator|+=
operator|(
name|unsigned
operator|)
name|len
expr_stmt|;
name|state
operator|->
name|large_len
operator||=
operator|(
name|len
operator|>=
literal|16
operator|)
operator||
operator|(
name|state
operator|->
name|total_len_32
operator|>=
literal|16
operator|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|memsize
operator|+
name|len
operator|<
literal|16
condition|)
block|{
comment|/* fill in tmp buffer */
name|XXH_memcpy
argument_list|(
operator|(
name|BYTE
operator|*
operator|)
operator|(
name|state
operator|->
name|mem32
operator|)
operator|+
name|state
operator|->
name|memsize
argument_list|,
name|input
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|state
operator|->
name|memsize
operator|+=
operator|(
name|unsigned
operator|)
name|len
expr_stmt|;
return|return
name|XXH_OK
return|;
block|}
if|if
condition|(
name|state
operator|->
name|memsize
condition|)
block|{
comment|/* some data left from previous update */
name|XXH_memcpy
argument_list|(
operator|(
name|BYTE
operator|*
operator|)
operator|(
name|state
operator|->
name|mem32
operator|)
operator|+
name|state
operator|->
name|memsize
argument_list|,
name|input
argument_list|,
literal|16
operator|-
name|state
operator|->
name|memsize
argument_list|)
expr_stmt|;
block|{
specifier|const
name|U32
modifier|*
name|p32
init|=
name|state
operator|->
name|mem32
decl_stmt|;
name|state
operator|->
name|v1
operator|=
name|XXH32_round
argument_list|(
name|state
operator|->
name|v1
argument_list|,
name|XXH_readLE32
argument_list|(
name|p32
argument_list|,
name|endian
argument_list|)
argument_list|)
expr_stmt|;
name|p32
operator|++
expr_stmt|;
name|state
operator|->
name|v2
operator|=
name|XXH32_round
argument_list|(
name|state
operator|->
name|v2
argument_list|,
name|XXH_readLE32
argument_list|(
name|p32
argument_list|,
name|endian
argument_list|)
argument_list|)
expr_stmt|;
name|p32
operator|++
expr_stmt|;
name|state
operator|->
name|v3
operator|=
name|XXH32_round
argument_list|(
name|state
operator|->
name|v3
argument_list|,
name|XXH_readLE32
argument_list|(
name|p32
argument_list|,
name|endian
argument_list|)
argument_list|)
expr_stmt|;
name|p32
operator|++
expr_stmt|;
name|state
operator|->
name|v4
operator|=
name|XXH32_round
argument_list|(
name|state
operator|->
name|v4
argument_list|,
name|XXH_readLE32
argument_list|(
name|p32
argument_list|,
name|endian
argument_list|)
argument_list|)
expr_stmt|;
name|p32
operator|++
expr_stmt|;
block|}
name|p
operator|+=
literal|16
operator|-
name|state
operator|->
name|memsize
expr_stmt|;
name|state
operator|->
name|memsize
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|<=
name|bEnd
operator|-
literal|16
condition|)
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|limit
init|=
name|bEnd
operator|-
literal|16
decl_stmt|;
name|U32
name|v1
init|=
name|state
operator|->
name|v1
decl_stmt|;
name|U32
name|v2
init|=
name|state
operator|->
name|v2
decl_stmt|;
name|U32
name|v3
init|=
name|state
operator|->
name|v3
decl_stmt|;
name|U32
name|v4
init|=
name|state
operator|->
name|v4
decl_stmt|;
do|do
block|{
name|v1
operator|=
name|XXH32_round
argument_list|(
name|v1
argument_list|,
name|XXH_readLE32
argument_list|(
name|p
argument_list|,
name|endian
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|v2
operator|=
name|XXH32_round
argument_list|(
name|v2
argument_list|,
name|XXH_readLE32
argument_list|(
name|p
argument_list|,
name|endian
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|v3
operator|=
name|XXH32_round
argument_list|(
name|v3
argument_list|,
name|XXH_readLE32
argument_list|(
name|p
argument_list|,
name|endian
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|v4
operator|=
name|XXH32_round
argument_list|(
name|v4
argument_list|,
name|XXH_readLE32
argument_list|(
name|p
argument_list|,
name|endian
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|<=
name|limit
condition|)
do|;
name|state
operator|->
name|v1
operator|=
name|v1
expr_stmt|;
name|state
operator|->
name|v2
operator|=
name|v2
expr_stmt|;
name|state
operator|->
name|v3
operator|=
name|v3
expr_stmt|;
name|state
operator|->
name|v4
operator|=
name|v4
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|<
name|bEnd
condition|)
block|{
name|XXH_memcpy
argument_list|(
name|state
operator|->
name|mem32
argument_list|,
name|p
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|bEnd
operator|-
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|memsize
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|bEnd
operator|-
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|XXH_OK
return|;
block|}
end_function

begin_function
name|XXH_PUBLIC_API
name|XXH_errorcode
name|XXH32_update
parameter_list|(
name|XXH32_state_t
modifier|*
name|state_in
parameter_list|,
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|XXH_endianess
name|endian_detected
init|=
operator|(
name|XXH_endianess
operator|)
name|XXH_CPU_LITTLE_ENDIAN
decl_stmt|;
if|if
condition|(
operator|(
name|endian_detected
operator|==
name|XXH_littleEndian
operator|)
operator|||
name|XXH_FORCE_NATIVE_FORMAT
condition|)
return|return
name|XXH32_update_endian
argument_list|(
name|state_in
argument_list|,
name|input
argument_list|,
name|len
argument_list|,
name|XXH_littleEndian
argument_list|)
return|;
else|else
return|return
name|XXH32_update_endian
argument_list|(
name|state_in
argument_list|,
name|input
argument_list|,
name|len
argument_list|,
name|XXH_bigEndian
argument_list|)
return|;
block|}
end_function

begin_function
name|FORCE_INLINE_TEMPLATE
name|U32
name|XXH32_digest_endian
parameter_list|(
specifier|const
name|XXH32_state_t
modifier|*
name|state
parameter_list|,
name|XXH_endianess
name|endian
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|p
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|state
operator|->
name|mem32
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|bEnd
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|state
operator|->
name|mem32
operator|)
operator|+
name|state
operator|->
name|memsize
decl_stmt|;
name|U32
name|h32
decl_stmt|;
if|if
condition|(
name|state
operator|->
name|large_len
condition|)
block|{
name|h32
operator|=
name|XXH_rotl32
argument_list|(
name|state
operator|->
name|v1
argument_list|,
literal|1
argument_list|)
operator|+
name|XXH_rotl32
argument_list|(
name|state
operator|->
name|v2
argument_list|,
literal|7
argument_list|)
operator|+
name|XXH_rotl32
argument_list|(
name|state
operator|->
name|v3
argument_list|,
literal|12
argument_list|)
operator|+
name|XXH_rotl32
argument_list|(
name|state
operator|->
name|v4
argument_list|,
literal|18
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|h32
operator|=
name|state
operator|->
name|v3
comment|/* == seed */
operator|+
name|PRIME32_5
expr_stmt|;
block|}
name|h32
operator|+=
name|state
operator|->
name|total_len_32
expr_stmt|;
while|while
condition|(
name|p
operator|+
literal|4
operator|<=
name|bEnd
condition|)
block|{
name|h32
operator|+=
name|XXH_readLE32
argument_list|(
name|p
argument_list|,
name|endian
argument_list|)
operator|*
name|PRIME32_3
expr_stmt|;
name|h32
operator|=
name|XXH_rotl32
argument_list|(
name|h32
argument_list|,
literal|17
argument_list|)
operator|*
name|PRIME32_4
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
while|while
condition|(
name|p
operator|<
name|bEnd
condition|)
block|{
name|h32
operator|+=
operator|(
operator|*
name|p
operator|)
operator|*
name|PRIME32_5
expr_stmt|;
name|h32
operator|=
name|XXH_rotl32
argument_list|(
name|h32
argument_list|,
literal|11
argument_list|)
operator|*
name|PRIME32_1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|h32
operator|^=
name|h32
operator|>>
literal|15
expr_stmt|;
name|h32
operator|*=
name|PRIME32_2
expr_stmt|;
name|h32
operator|^=
name|h32
operator|>>
literal|13
expr_stmt|;
name|h32
operator|*=
name|PRIME32_3
expr_stmt|;
name|h32
operator|^=
name|h32
operator|>>
literal|16
expr_stmt|;
return|return
name|h32
return|;
block|}
end_function

begin_function
name|XXH_PUBLIC_API
name|unsigned
name|int
name|XXH32_digest
parameter_list|(
specifier|const
name|XXH32_state_t
modifier|*
name|state_in
parameter_list|)
block|{
name|XXH_endianess
name|endian_detected
init|=
operator|(
name|XXH_endianess
operator|)
name|XXH_CPU_LITTLE_ENDIAN
decl_stmt|;
if|if
condition|(
operator|(
name|endian_detected
operator|==
name|XXH_littleEndian
operator|)
operator|||
name|XXH_FORCE_NATIVE_FORMAT
condition|)
return|return
name|XXH32_digest_endian
argument_list|(
name|state_in
argument_list|,
name|XXH_littleEndian
argument_list|)
return|;
else|else
return|return
name|XXH32_digest_endian
argument_list|(
name|state_in
argument_list|,
name|XXH_bigEndian
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **** XXH64 **** */
end_comment

begin_function
name|FORCE_INLINE_TEMPLATE
name|XXH_errorcode
name|XXH64_update_endian
parameter_list|(
name|XXH64_state_t
modifier|*
name|state
parameter_list|,
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|size_t
name|len
parameter_list|,
name|XXH_endianess
name|endian
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|p
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|input
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|bEnd
init|=
name|p
operator|+
name|len
decl_stmt|;
ifdef|#
directive|ifdef
name|XXH_ACCEPT_NULL_INPUT_POINTER
if|if
condition|(
name|input
operator|==
name|NULL
condition|)
return|return
name|XXH_ERROR
return|;
endif|#
directive|endif
name|state
operator|->
name|total_len
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|memsize
operator|+
name|len
operator|<
literal|32
condition|)
block|{
comment|/* fill in tmp buffer */
name|XXH_memcpy
argument_list|(
operator|(
operator|(
name|BYTE
operator|*
operator|)
name|state
operator|->
name|mem64
operator|)
operator|+
name|state
operator|->
name|memsize
argument_list|,
name|input
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|state
operator|->
name|memsize
operator|+=
operator|(
name|U32
operator|)
name|len
expr_stmt|;
return|return
name|XXH_OK
return|;
block|}
if|if
condition|(
name|state
operator|->
name|memsize
condition|)
block|{
comment|/* tmp buffer is full */
name|XXH_memcpy
argument_list|(
operator|(
operator|(
name|BYTE
operator|*
operator|)
name|state
operator|->
name|mem64
operator|)
operator|+
name|state
operator|->
name|memsize
argument_list|,
name|input
argument_list|,
literal|32
operator|-
name|state
operator|->
name|memsize
argument_list|)
expr_stmt|;
name|state
operator|->
name|v1
operator|=
name|XXH64_round
argument_list|(
name|state
operator|->
name|v1
argument_list|,
name|XXH_readLE64
argument_list|(
name|state
operator|->
name|mem64
operator|+
literal|0
argument_list|,
name|endian
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|v2
operator|=
name|XXH64_round
argument_list|(
name|state
operator|->
name|v2
argument_list|,
name|XXH_readLE64
argument_list|(
name|state
operator|->
name|mem64
operator|+
literal|1
argument_list|,
name|endian
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|v3
operator|=
name|XXH64_round
argument_list|(
name|state
operator|->
name|v3
argument_list|,
name|XXH_readLE64
argument_list|(
name|state
operator|->
name|mem64
operator|+
literal|2
argument_list|,
name|endian
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|v4
operator|=
name|XXH64_round
argument_list|(
name|state
operator|->
name|v4
argument_list|,
name|XXH_readLE64
argument_list|(
name|state
operator|->
name|mem64
operator|+
literal|3
argument_list|,
name|endian
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|32
operator|-
name|state
operator|->
name|memsize
expr_stmt|;
name|state
operator|->
name|memsize
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|+
literal|32
operator|<=
name|bEnd
condition|)
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|limit
init|=
name|bEnd
operator|-
literal|32
decl_stmt|;
name|U64
name|v1
init|=
name|state
operator|->
name|v1
decl_stmt|;
name|U64
name|v2
init|=
name|state
operator|->
name|v2
decl_stmt|;
name|U64
name|v3
init|=
name|state
operator|->
name|v3
decl_stmt|;
name|U64
name|v4
init|=
name|state
operator|->
name|v4
decl_stmt|;
do|do
block|{
name|v1
operator|=
name|XXH64_round
argument_list|(
name|v1
argument_list|,
name|XXH_readLE64
argument_list|(
name|p
argument_list|,
name|endian
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|8
expr_stmt|;
name|v2
operator|=
name|XXH64_round
argument_list|(
name|v2
argument_list|,
name|XXH_readLE64
argument_list|(
name|p
argument_list|,
name|endian
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|8
expr_stmt|;
name|v3
operator|=
name|XXH64_round
argument_list|(
name|v3
argument_list|,
name|XXH_readLE64
argument_list|(
name|p
argument_list|,
name|endian
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|8
expr_stmt|;
name|v4
operator|=
name|XXH64_round
argument_list|(
name|v4
argument_list|,
name|XXH_readLE64
argument_list|(
name|p
argument_list|,
name|endian
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|8
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|<=
name|limit
condition|)
do|;
name|state
operator|->
name|v1
operator|=
name|v1
expr_stmt|;
name|state
operator|->
name|v2
operator|=
name|v2
expr_stmt|;
name|state
operator|->
name|v3
operator|=
name|v3
expr_stmt|;
name|state
operator|->
name|v4
operator|=
name|v4
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|<
name|bEnd
condition|)
block|{
name|XXH_memcpy
argument_list|(
name|state
operator|->
name|mem64
argument_list|,
name|p
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|bEnd
operator|-
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|memsize
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|bEnd
operator|-
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|XXH_OK
return|;
block|}
end_function

begin_function
name|XXH_PUBLIC_API
name|XXH_errorcode
name|XXH64_update
parameter_list|(
name|XXH64_state_t
modifier|*
name|state_in
parameter_list|,
specifier|const
name|void
modifier|*
name|input
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|XXH_endianess
name|endian_detected
init|=
operator|(
name|XXH_endianess
operator|)
name|XXH_CPU_LITTLE_ENDIAN
decl_stmt|;
if|if
condition|(
operator|(
name|endian_detected
operator|==
name|XXH_littleEndian
operator|)
operator|||
name|XXH_FORCE_NATIVE_FORMAT
condition|)
return|return
name|XXH64_update_endian
argument_list|(
name|state_in
argument_list|,
name|input
argument_list|,
name|len
argument_list|,
name|XXH_littleEndian
argument_list|)
return|;
else|else
return|return
name|XXH64_update_endian
argument_list|(
name|state_in
argument_list|,
name|input
argument_list|,
name|len
argument_list|,
name|XXH_bigEndian
argument_list|)
return|;
block|}
end_function

begin_function
name|FORCE_INLINE_TEMPLATE
name|U64
name|XXH64_digest_endian
parameter_list|(
specifier|const
name|XXH64_state_t
modifier|*
name|state
parameter_list|,
name|XXH_endianess
name|endian
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|p
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|state
operator|->
name|mem64
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|bEnd
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|state
operator|->
name|mem64
operator|+
name|state
operator|->
name|memsize
decl_stmt|;
name|U64
name|h64
decl_stmt|;
if|if
condition|(
name|state
operator|->
name|total_len
operator|>=
literal|32
condition|)
block|{
name|U64
specifier|const
name|v1
init|=
name|state
operator|->
name|v1
decl_stmt|;
name|U64
specifier|const
name|v2
init|=
name|state
operator|->
name|v2
decl_stmt|;
name|U64
specifier|const
name|v3
init|=
name|state
operator|->
name|v3
decl_stmt|;
name|U64
specifier|const
name|v4
init|=
name|state
operator|->
name|v4
decl_stmt|;
name|h64
operator|=
name|XXH_rotl64
argument_list|(
name|v1
argument_list|,
literal|1
argument_list|)
operator|+
name|XXH_rotl64
argument_list|(
name|v2
argument_list|,
literal|7
argument_list|)
operator|+
name|XXH_rotl64
argument_list|(
name|v3
argument_list|,
literal|12
argument_list|)
operator|+
name|XXH_rotl64
argument_list|(
name|v4
argument_list|,
literal|18
argument_list|)
expr_stmt|;
name|h64
operator|=
name|XXH64_mergeRound
argument_list|(
name|h64
argument_list|,
name|v1
argument_list|)
expr_stmt|;
name|h64
operator|=
name|XXH64_mergeRound
argument_list|(
name|h64
argument_list|,
name|v2
argument_list|)
expr_stmt|;
name|h64
operator|=
name|XXH64_mergeRound
argument_list|(
name|h64
argument_list|,
name|v3
argument_list|)
expr_stmt|;
name|h64
operator|=
name|XXH64_mergeRound
argument_list|(
name|h64
argument_list|,
name|v4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|h64
operator|=
name|state
operator|->
name|v3
operator|+
name|PRIME64_5
expr_stmt|;
block|}
name|h64
operator|+=
operator|(
name|U64
operator|)
name|state
operator|->
name|total_len
expr_stmt|;
while|while
condition|(
name|p
operator|+
literal|8
operator|<=
name|bEnd
condition|)
block|{
name|U64
specifier|const
name|k1
init|=
name|XXH64_round
argument_list|(
literal|0
argument_list|,
name|XXH_readLE64
argument_list|(
name|p
argument_list|,
name|endian
argument_list|)
argument_list|)
decl_stmt|;
name|h64
operator|^=
name|k1
expr_stmt|;
name|h64
operator|=
name|XXH_rotl64
argument_list|(
name|h64
argument_list|,
literal|27
argument_list|)
operator|*
name|PRIME64_1
operator|+
name|PRIME64_4
expr_stmt|;
name|p
operator|+=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|+
literal|4
operator|<=
name|bEnd
condition|)
block|{
name|h64
operator|^=
call|(
name|U64
call|)
argument_list|(
name|XXH_readLE32
argument_list|(
name|p
argument_list|,
name|endian
argument_list|)
argument_list|)
operator|*
name|PRIME64_1
expr_stmt|;
name|h64
operator|=
name|XXH_rotl64
argument_list|(
name|h64
argument_list|,
literal|23
argument_list|)
operator|*
name|PRIME64_2
operator|+
name|PRIME64_3
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
while|while
condition|(
name|p
operator|<
name|bEnd
condition|)
block|{
name|h64
operator|^=
operator|(
operator|*
name|p
operator|)
operator|*
name|PRIME64_5
expr_stmt|;
name|h64
operator|=
name|XXH_rotl64
argument_list|(
name|h64
argument_list|,
literal|11
argument_list|)
operator|*
name|PRIME64_1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|h64
operator|^=
name|h64
operator|>>
literal|33
expr_stmt|;
name|h64
operator|*=
name|PRIME64_2
expr_stmt|;
name|h64
operator|^=
name|h64
operator|>>
literal|29
expr_stmt|;
name|h64
operator|*=
name|PRIME64_3
expr_stmt|;
name|h64
operator|^=
name|h64
operator|>>
literal|32
expr_stmt|;
return|return
name|h64
return|;
block|}
end_function

begin_function
name|XXH_PUBLIC_API
name|unsigned
name|long
name|long
name|XXH64_digest
parameter_list|(
specifier|const
name|XXH64_state_t
modifier|*
name|state_in
parameter_list|)
block|{
name|XXH_endianess
name|endian_detected
init|=
operator|(
name|XXH_endianess
operator|)
name|XXH_CPU_LITTLE_ENDIAN
decl_stmt|;
if|if
condition|(
operator|(
name|endian_detected
operator|==
name|XXH_littleEndian
operator|)
operator|||
name|XXH_FORCE_NATIVE_FORMAT
condition|)
return|return
name|XXH64_digest_endian
argument_list|(
name|state_in
argument_list|,
name|XXH_littleEndian
argument_list|)
return|;
else|else
return|return
name|XXH64_digest_endian
argument_list|(
name|state_in
argument_list|,
name|XXH_bigEndian
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ************************** *  Canonical representation ****************************/
end_comment

begin_comment
comment|/*! Default XXH result types are basic unsigned 32 and 64 bits. *   The canonical representation follows human-readable write convention, aka big-endian (large digits first). *   These functions allow transformation of hash result into and from its canonical format. *   This way, hash values can be written into a file or buffer, and remain comparable across different systems and programs. */
end_comment

begin_function
name|XXH_PUBLIC_API
name|void
name|XXH32_canonicalFromHash
parameter_list|(
name|XXH32_canonical_t
modifier|*
name|dst
parameter_list|,
name|XXH32_hash_t
name|hash
parameter_list|)
block|{
name|XXH_STATIC_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|XXH32_canonical_t
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|XXH32_hash_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|XXH_CPU_LITTLE_ENDIAN
condition|)
name|hash
operator|=
name|XXH_swap32
argument_list|(
name|hash
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dst
argument_list|,
operator|&
name|hash
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dst
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|XXH_PUBLIC_API
name|void
name|XXH64_canonicalFromHash
parameter_list|(
name|XXH64_canonical_t
modifier|*
name|dst
parameter_list|,
name|XXH64_hash_t
name|hash
parameter_list|)
block|{
name|XXH_STATIC_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|XXH64_canonical_t
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|XXH64_hash_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|XXH_CPU_LITTLE_ENDIAN
condition|)
name|hash
operator|=
name|XXH_swap64
argument_list|(
name|hash
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dst
argument_list|,
operator|&
name|hash
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dst
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|XXH_PUBLIC_API
name|XXH32_hash_t
name|XXH32_hashFromCanonical
parameter_list|(
specifier|const
name|XXH32_canonical_t
modifier|*
name|src
parameter_list|)
block|{
return|return
name|XXH_readBE32
argument_list|(
name|src
argument_list|)
return|;
block|}
end_function

begin_function
name|XXH_PUBLIC_API
name|XXH64_hash_t
name|XXH64_hashFromCanonical
parameter_list|(
specifier|const
name|XXH64_canonical_t
modifier|*
name|src
parameter_list|)
block|{
return|return
name|XXH_readBE64
argument_list|(
name|src
argument_list|)
return|;
block|}
end_function

end_unit

