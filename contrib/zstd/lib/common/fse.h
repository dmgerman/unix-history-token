begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ******************************************************************    FSE : Finite State Entropy codec    Public Prototypes declaration    Copyright (C) 2013-2016, Yann Collet.     BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)     Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are    met:         * Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer.        * Redistributions in binary form must reproduce the above    copyright notice, this list of conditions and the following disclaimer    in the documentation and/or other materials provided with the    distribution.     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     You can contact the author at :    - Source repository : https://github.com/Cyan4973/FiniteStateEntropy ****************************************************************** */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FSE_H
end_ifndef

begin_define
define|#
directive|define
name|FSE_H
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/*-***************************************** *  Dependencies ******************************************/
include|#
directive|include
file|<stddef.h>
comment|/* size_t, ptrdiff_t */
comment|/*-***************************************** *  FSE_PUBLIC_API : control library symbols visibility ******************************************/
if|#
directive|if
name|defined
argument_list|(
name|FSE_DLL_EXPORT
argument_list|)
operator|&&
operator|(
name|FSE_DLL_EXPORT
operator|==
literal|1
operator|)
operator|&&
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|__GNUC__
operator|>=
literal|4
operator|)
define|#
directive|define
name|FSE_PUBLIC_API
value|__attribute__ ((visibility ("default")))
elif|#
directive|elif
name|defined
argument_list|(
name|FSE_DLL_EXPORT
argument_list|)
operator|&&
operator|(
name|FSE_DLL_EXPORT
operator|==
literal|1
operator|)
comment|/* Visual expected */
define|#
directive|define
name|FSE_PUBLIC_API
value|__declspec(dllexport)
elif|#
directive|elif
name|defined
argument_list|(
name|FSE_DLL_IMPORT
argument_list|)
operator|&&
operator|(
name|FSE_DLL_IMPORT
operator|==
literal|1
operator|)
define|#
directive|define
name|FSE_PUBLIC_API
value|__declspec(dllimport)
comment|/* It isn't required but allows to generate better code, saving a function pointer load from the IAT and an indirect jump.*/
else|#
directive|else
define|#
directive|define
name|FSE_PUBLIC_API
endif|#
directive|endif
comment|/*------   Version   ------*/
define|#
directive|define
name|FSE_VERSION_MAJOR
value|0
define|#
directive|define
name|FSE_VERSION_MINOR
value|9
define|#
directive|define
name|FSE_VERSION_RELEASE
value|0
define|#
directive|define
name|FSE_LIB_VERSION
value|FSE_VERSION_MAJOR.FSE_VERSION_MINOR.FSE_VERSION_RELEASE
define|#
directive|define
name|FSE_QUOTE
parameter_list|(
name|str
parameter_list|)
value|#str
define|#
directive|define
name|FSE_EXPAND_AND_QUOTE
parameter_list|(
name|str
parameter_list|)
value|FSE_QUOTE(str)
define|#
directive|define
name|FSE_VERSION_STRING
value|FSE_EXPAND_AND_QUOTE(FSE_LIB_VERSION)
define|#
directive|define
name|FSE_VERSION_NUMBER
value|(FSE_VERSION_MAJOR *100*100 + FSE_VERSION_MINOR *100 + FSE_VERSION_RELEASE)
name|FSE_PUBLIC_API
name|unsigned
name|FSE_versionNumber
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/**< library version number; to be used when checking dll version */
comment|/*-**************************************** *  FSE simple functions ******************************************/
comment|/*! FSE_compress() :     Compress content of buffer 'src', of size 'srcSize', into destination buffer 'dst'.     'dst' buffer must be already allocated. Compression runs faster is dstCapacity>= FSE_compressBound(srcSize).     @return : size of compressed data (<= dstCapacity).     Special values : if return == 0, srcData is not compressible => Nothing is stored within dst !!!                      if return == 1, srcData is a single byte symbol * srcSize times. Use RLE compression instead.                      if FSE_isError(return), compression failed (more details using FSE_getErrorName()) */
name|FSE_PUBLIC_API
name|size_t
name|FSE_compress
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
comment|/*! FSE_decompress():     Decompress FSE data from buffer 'cSrc', of size 'cSrcSize',     into already allocated destination buffer 'dst', of size 'dstCapacity'.     @return : size of regenerated data (<= maxDstSize),               or an error code, which can be tested using FSE_isError() .      ** Important ** : FSE_decompress() does not decompress non-compressible nor RLE data !!!     Why ? : making this distinction requires a header.     Header management is intentionally delegated to the user layer, which can better manage special cases. */
name|FSE_PUBLIC_API
name|size_t
name|FSE_decompress
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
function_decl|;
comment|/*-***************************************** *  Tool functions ******************************************/
name|FSE_PUBLIC_API
name|size_t
name|FSE_compressBound
parameter_list|(
name|size_t
name|size
parameter_list|)
function_decl|;
comment|/* maximum compressed size */
comment|/* Error Management */
name|FSE_PUBLIC_API
name|unsigned
name|FSE_isError
parameter_list|(
name|size_t
name|code
parameter_list|)
function_decl|;
comment|/* tells if a return value is an error code */
name|FSE_PUBLIC_API
specifier|const
name|char
modifier|*
name|FSE_getErrorName
parameter_list|(
name|size_t
name|code
parameter_list|)
function_decl|;
comment|/* provides error code string (useful for debugging) */
comment|/*-***************************************** *  FSE advanced functions ******************************************/
comment|/*! FSE_compress2() :     Same as FSE_compress(), but allows the selection of 'maxSymbolValue' and 'tableLog'     Both parameters can be defined as '0' to mean : use default value     @return : size of compressed data     Special values : if return == 0, srcData is not compressible => Nothing is stored within cSrc !!!                      if return == 1, srcData is a single byte symbol * srcSize times. Use RLE compression.                      if FSE_isError(return), it's an error code. */
name|FSE_PUBLIC_API
name|size_t
name|FSE_compress2
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|,
name|unsigned
name|tableLog
parameter_list|)
function_decl|;
comment|/*-***************************************** *  FSE detailed API ******************************************/
comment|/*! FSE_compress() does the following: 1. count symbol occurrence from source[] into table count[] 2. normalize counters so that sum(count[]) == Power_of_2 (2^tableLog) 3. save normalized counters to memory buffer using writeNCount() 4. build encoding table 'CTable' from normalized counters 5. encode the data stream using encoding table 'CTable'  FSE_decompress() does the following: 1. read normalized counters with readNCount() 2. build decoding table 'DTable' from normalized counters 3. decode the data stream using decoding table 'DTable'  The following API allows targeting specific sub-functions for advanced tasks. For example, it's possible to compress several blocks using the same 'CTable', or to save and provide normalized distribution using external method. */
comment|/* *** COMPRESSION *** */
comment|/*! FSE_count():     Provides the precise count of each byte within a table 'count'.     'count' is a table of unsigned int, of minimum size (*maxSymbolValuePtr+1).     *maxSymbolValuePtr will be updated if detected smaller than initial value.     @return : the count of the most frequent symbol (which is not identified).               if return == srcSize, there is only one symbol.               Can also return an error code, which can be tested with FSE_isError(). */
name|FSE_PUBLIC_API
name|size_t
name|FSE_count
parameter_list|(
name|unsigned
modifier|*
name|count
parameter_list|,
name|unsigned
modifier|*
name|maxSymbolValuePtr
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
comment|/*! FSE_optimalTableLog():     dynamically downsize 'tableLog' when conditions are met.     It saves CPU time, by using smaller tables, while preserving or even improving compression ratio.     @return : recommended tableLog (necessarily<= 'maxTableLog') */
name|FSE_PUBLIC_API
name|unsigned
name|FSE_optimalTableLog
parameter_list|(
name|unsigned
name|maxTableLog
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|)
function_decl|;
comment|/*! FSE_normalizeCount():     normalize counts so that sum(count[]) == Power_of_2 (2^tableLog)     'normalizedCounter' is a table of short, of minimum size (maxSymbolValue+1).     @return : tableLog,               or an errorCode, which can be tested using FSE_isError() */
name|FSE_PUBLIC_API
name|size_t
name|FSE_normalizeCount
parameter_list|(
name|short
modifier|*
name|normalizedCounter
parameter_list|,
name|unsigned
name|tableLog
parameter_list|,
specifier|const
name|unsigned
modifier|*
name|count
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|)
function_decl|;
comment|/*! FSE_NCountWriteBound():     Provides the maximum possible size of an FSE normalized table, given 'maxSymbolValue' and 'tableLog'.     Typically useful for allocation purpose. */
name|FSE_PUBLIC_API
name|size_t
name|FSE_NCountWriteBound
parameter_list|(
name|unsigned
name|maxSymbolValue
parameter_list|,
name|unsigned
name|tableLog
parameter_list|)
function_decl|;
comment|/*! FSE_writeNCount():     Compactly save 'normalizedCounter' into 'buffer'.     @return : size of the compressed table,               or an errorCode, which can be tested using FSE_isError(). */
name|FSE_PUBLIC_API
name|size_t
name|FSE_writeNCount
parameter_list|(
name|void
modifier|*
name|buffer
parameter_list|,
name|size_t
name|bufferSize
parameter_list|,
specifier|const
name|short
modifier|*
name|normalizedCounter
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|,
name|unsigned
name|tableLog
parameter_list|)
function_decl|;
comment|/*! Constructor and Destructor of FSE_CTable.     Note that FSE_CTable size depends on 'tableLog' and 'maxSymbolValue' */
typedef|typedef
name|unsigned
name|FSE_CTable
typedef|;
comment|/* don't allocate that. It's only meant to be more restrictive than void* */
name|FSE_PUBLIC_API
name|FSE_CTable
modifier|*
name|FSE_createCTable
parameter_list|(
name|unsigned
name|tableLog
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|)
function_decl|;
name|FSE_PUBLIC_API
name|void
name|FSE_freeCTable
parameter_list|(
name|FSE_CTable
modifier|*
name|ct
parameter_list|)
function_decl|;
comment|/*! FSE_buildCTable():     Builds `ct`, which must be already allocated, using FSE_createCTable().     @return : 0, or an errorCode, which can be tested using FSE_isError() */
name|FSE_PUBLIC_API
name|size_t
name|FSE_buildCTable
parameter_list|(
name|FSE_CTable
modifier|*
name|ct
parameter_list|,
specifier|const
name|short
modifier|*
name|normalizedCounter
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|,
name|unsigned
name|tableLog
parameter_list|)
function_decl|;
comment|/*! FSE_compress_usingCTable():     Compress `src` using `ct` into `dst` which must be already allocated.     @return : size of compressed data (<= `dstCapacity`),               or 0 if compressed data could not fit into `dst`,               or an errorCode, which can be tested using FSE_isError() */
name|FSE_PUBLIC_API
name|size_t
name|FSE_compress_usingCTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
specifier|const
name|FSE_CTable
modifier|*
name|ct
parameter_list|)
function_decl|;
comment|/*! Tutorial : ---------- The first step is to count all symbols. FSE_count() does this job very fast. Result will be saved into 'count', a table of unsigned int, which must be already allocated, and have 'maxSymbolValuePtr[0]+1' cells. 'src' is a table of bytes of size 'srcSize'. All values within 'src' MUST be<= maxSymbolValuePtr[0] maxSymbolValuePtr[0] will be updated, with its real value (necessarily<= original value) FSE_count() will return the number of occurrence of the most frequent symbol. This can be used to know if there is a single symbol within 'src', and to quickly evaluate its compressibility. If there is an error, the function will return an ErrorCode (which can be tested using FSE_isError()).  The next step is to normalize the frequencies. FSE_normalizeCount() will ensure that sum of frequencies is == 2 ^'tableLog'. It also guarantees a minimum of 1 to any Symbol with frequency>= 1. You can use 'tableLog'==0 to mean "use default tableLog value". If you are unsure of which tableLog value to use, you can ask FSE_optimalTableLog(), which will provide the optimal valid tableLog given sourceSize, maxSymbolValue, and a user-defined maximum (0 means "default").  The result of FSE_normalizeCount() will be saved into a table, called 'normalizedCounter', which is a table of signed short. 'normalizedCounter' must be already allocated, and have at least 'maxSymbolValue+1' cells. The return value is tableLog if everything proceeded as expected. It is 0 if there is a single symbol within distribution. If there is an error (ex: invalid tableLog value), the function will return an ErrorCode (which can be tested using FSE_isError()).  'normalizedCounter' can be saved in a compact manner to a memory area using FSE_writeNCount(). 'buffer' must be already allocated. For guaranteed success, buffer size must be at least FSE_headerBound(). The result of the function is the number of bytes written into 'buffer'. If there is an error, the function will return an ErrorCode (which can be tested using FSE_isError(); ex : buffer size too small).  'normalizedCounter' can then be used to create the compression table 'CTable'. The space required by 'CTable' must be already allocated, using FSE_createCTable(). You can then use FSE_buildCTable() to fill 'CTable'. If there is an error, both functions will return an ErrorCode (which can be tested using FSE_isError()).  'CTable' can then be used to compress 'src', with FSE_compress_usingCTable(). Similar to FSE_count(), the convention is that 'src' is assumed to be a table of char of size 'srcSize' The function returns the size of compressed data (without header), necessarily<= `dstCapacity`. If it returns '0', compressed data could not fit into 'dst'. If there is an error, the function will return an ErrorCode (which can be tested using FSE_isError()). */
comment|/* *** DECOMPRESSION *** */
comment|/*! FSE_readNCount():     Read compactly saved 'normalizedCounter' from 'rBuffer'.     @return : size read from 'rBuffer',               or an errorCode, which can be tested using FSE_isError().               maxSymbolValuePtr[0] and tableLogPtr[0] will also be updated with their respective values */
name|FSE_PUBLIC_API
name|size_t
name|FSE_readNCount
parameter_list|(
name|short
modifier|*
name|normalizedCounter
parameter_list|,
name|unsigned
modifier|*
name|maxSymbolValuePtr
parameter_list|,
name|unsigned
modifier|*
name|tableLogPtr
parameter_list|,
specifier|const
name|void
modifier|*
name|rBuffer
parameter_list|,
name|size_t
name|rBuffSize
parameter_list|)
function_decl|;
comment|/*! Constructor and Destructor of FSE_DTable.     Note that its size depends on 'tableLog' */
typedef|typedef
name|unsigned
name|FSE_DTable
typedef|;
comment|/* don't allocate that. It's just a way to be more restrictive than void* */
name|FSE_PUBLIC_API
name|FSE_DTable
modifier|*
name|FSE_createDTable
parameter_list|(
name|unsigned
name|tableLog
parameter_list|)
function_decl|;
name|FSE_PUBLIC_API
name|void
name|FSE_freeDTable
parameter_list|(
name|FSE_DTable
modifier|*
name|dt
parameter_list|)
function_decl|;
comment|/*! FSE_buildDTable():     Builds 'dt', which must be already allocated, using FSE_createDTable().     return : 0, or an errorCode, which can be tested using FSE_isError() */
name|FSE_PUBLIC_API
name|size_t
name|FSE_buildDTable
parameter_list|(
name|FSE_DTable
modifier|*
name|dt
parameter_list|,
specifier|const
name|short
modifier|*
name|normalizedCounter
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|,
name|unsigned
name|tableLog
parameter_list|)
function_decl|;
comment|/*! FSE_decompress_usingDTable():     Decompress compressed source `cSrc` of size `cSrcSize` using `dt`     into `dst` which must be already allocated.     @return : size of regenerated data (necessarily<= `dstCapacity`),               or an errorCode, which can be tested using FSE_isError() */
name|FSE_PUBLIC_API
name|size_t
name|FSE_decompress_usingDTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|FSE_DTable
modifier|*
name|dt
parameter_list|)
function_decl|;
comment|/*! Tutorial : ---------- (Note : these functions only decompress FSE-compressed blocks.  If block is uncompressed, use memcpy() instead  If block is a single repeated byte, use memset() instead )  The first step is to obtain the normalized frequencies of symbols. This can be performed by FSE_readNCount() if it was saved using FSE_writeNCount(). 'normalizedCounter' must be already allocated, and have at least 'maxSymbolValuePtr[0]+1' cells of signed short. In practice, that means it's necessary to know 'maxSymbolValue' beforehand, or size the table to handle worst case situations (typically 256). FSE_readNCount() will provide 'tableLog' and 'maxSymbolValue'. The result of FSE_readNCount() is the number of bytes read from 'rBuffer'. Note that 'rBufferSize' must be at least 4 bytes, even if useful information is less than that. If there is an error, the function will return an error code, which can be tested using FSE_isError().  The next step is to build the decompression tables 'FSE_DTable' from 'normalizedCounter'. This is performed by the function FSE_buildDTable(). The space required by 'FSE_DTable' must be already allocated using FSE_createDTable(). If there is an error, the function will return an error code, which can be tested using FSE_isError().  `FSE_DTable` can then be used to decompress `cSrc`, with FSE_decompress_usingDTable(). `cSrcSize` must be strictly correct, otherwise decompression will fail. FSE_decompress_usingDTable() result will tell how many bytes were regenerated (<=`dstCapacity`). If there is an error, the function will return an error code, which can be tested using FSE_isError(). (ex: dst buffer too small) */
ifdef|#
directive|ifdef
name|FSE_STATIC_LINKING_ONLY
comment|/* *** Dependency *** */
include|#
directive|include
file|"bitstream.h"
comment|/* ***************************************** *  Static allocation *******************************************/
comment|/* FSE buffer bounds */
define|#
directive|define
name|FSE_NCOUNTBOUND
value|512
define|#
directive|define
name|FSE_BLOCKBOUND
parameter_list|(
name|size
parameter_list|)
value|(size + (size>>7))
define|#
directive|define
name|FSE_COMPRESSBOUND
parameter_list|(
name|size
parameter_list|)
value|(FSE_NCOUNTBOUND + FSE_BLOCKBOUND(size))
comment|/* Macro version, useful for static allocation */
comment|/* It is possible to statically allocate FSE CTable/DTable as a table of FSE_CTable/FSE_DTable using below macros */
define|#
directive|define
name|FSE_CTABLE_SIZE_U32
parameter_list|(
name|maxTableLog
parameter_list|,
name|maxSymbolValue
parameter_list|)
value|(1 + (1<<(maxTableLog-1)) + ((maxSymbolValue+1)*2))
define|#
directive|define
name|FSE_DTABLE_SIZE_U32
parameter_list|(
name|maxTableLog
parameter_list|)
value|(1 + (1<<maxTableLog))
comment|/* or use the size to malloc() space directly. Pay attention to alignment restrictions though */
define|#
directive|define
name|FSE_CTABLE_SIZE
parameter_list|(
name|maxTableLog
parameter_list|,
name|maxSymbolValue
parameter_list|)
value|(FSE_CTABLE_SIZE_U32(maxTableLog, maxSymbolValue) * sizeof(FSE_CTable))
define|#
directive|define
name|FSE_DTABLE_SIZE
parameter_list|(
name|maxTableLog
parameter_list|)
value|(FSE_DTABLE_SIZE_U32(maxTableLog) * sizeof(FSE_DTable))
comment|/* ***************************************** *  FSE advanced API *******************************************/
comment|/* FSE_count_wksp() :  * Same as FSE_count(), but using an externally provided scratch buffer.  * `workSpace` size must be table of>= `1024` unsigned  */
name|size_t
name|FSE_count_wksp
parameter_list|(
name|unsigned
modifier|*
name|count
parameter_list|,
name|unsigned
modifier|*
name|maxSymbolValuePtr
parameter_list|,
specifier|const
name|void
modifier|*
name|source
parameter_list|,
name|size_t
name|sourceSize
parameter_list|,
name|unsigned
modifier|*
name|workSpace
parameter_list|)
function_decl|;
comment|/** FSE_countFast() :  *  same as FSE_count(), but blindly trusts that all byte values within src are<= *maxSymbolValuePtr  */
name|size_t
name|FSE_countFast
parameter_list|(
name|unsigned
modifier|*
name|count
parameter_list|,
name|unsigned
modifier|*
name|maxSymbolValuePtr
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
comment|/* FSE_countFast_wksp() :  * Same as FSE_countFast(), but using an externally provided scratch buffer.  * `workSpace` must be a table of minimum `1024` unsigned  */
name|size_t
name|FSE_countFast_wksp
parameter_list|(
name|unsigned
modifier|*
name|count
parameter_list|,
name|unsigned
modifier|*
name|maxSymbolValuePtr
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|unsigned
modifier|*
name|workSpace
parameter_list|)
function_decl|;
comment|/*! FSE_count_simple  * Same as FSE_countFast(), but does not use any additional memory (not even on stack).  * This function is unsafe, and will segfault if any value within `src` is `> *maxSymbolValuePtr` (presuming it's also the size of `count`). */
name|size_t
name|FSE_count_simple
parameter_list|(
name|unsigned
modifier|*
name|count
parameter_list|,
name|unsigned
modifier|*
name|maxSymbolValuePtr
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
name|unsigned
name|FSE_optimalTableLog_internal
parameter_list|(
name|unsigned
name|maxTableLog
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|,
name|unsigned
name|minus
parameter_list|)
function_decl|;
comment|/**< same as FSE_optimalTableLog(), which used `minus==2` */
comment|/* FSE_compress_wksp() :  * Same as FSE_compress2(), but using an externally allocated scratch buffer (`workSpace`).  * FSE_WKSP_SIZE_U32() provides the minimum size required for `workSpace` as a table of FSE_CTable.  */
define|#
directive|define
name|FSE_WKSP_SIZE_U32
parameter_list|(
name|maxTableLog
parameter_list|,
name|maxSymbolValue
parameter_list|)
value|( FSE_CTABLE_SIZE_U32(maxTableLog, maxSymbolValue) + ((maxTableLog> 12) ? (1<< (maxTableLog - 2)) : 1024) )
name|size_t
name|FSE_compress_wksp
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|,
name|unsigned
name|tableLog
parameter_list|,
name|void
modifier|*
name|workSpace
parameter_list|,
name|size_t
name|wkspSize
parameter_list|)
function_decl|;
name|size_t
name|FSE_buildCTable_raw
parameter_list|(
name|FSE_CTable
modifier|*
name|ct
parameter_list|,
name|unsigned
name|nbBits
parameter_list|)
function_decl|;
comment|/**< build a fake FSE_CTable, designed for a flat distribution, where each symbol uses nbBits */
name|size_t
name|FSE_buildCTable_rle
parameter_list|(
name|FSE_CTable
modifier|*
name|ct
parameter_list|,
name|unsigned
name|char
name|symbolValue
parameter_list|)
function_decl|;
comment|/**< build a fake FSE_CTable, designed to compress always the same symbolValue */
comment|/* FSE_buildCTable_wksp() :  * Same as FSE_buildCTable(), but using an externally allocated scratch buffer (`workSpace`).  * `wkspSize` must be>= `(1<<tableLog)`.  */
name|size_t
name|FSE_buildCTable_wksp
parameter_list|(
name|FSE_CTable
modifier|*
name|ct
parameter_list|,
specifier|const
name|short
modifier|*
name|normalizedCounter
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|,
name|unsigned
name|tableLog
parameter_list|,
name|void
modifier|*
name|workSpace
parameter_list|,
name|size_t
name|wkspSize
parameter_list|)
function_decl|;
name|size_t
name|FSE_buildDTable_raw
parameter_list|(
name|FSE_DTable
modifier|*
name|dt
parameter_list|,
name|unsigned
name|nbBits
parameter_list|)
function_decl|;
comment|/**< build a fake FSE_DTable, designed to read a flat distribution where each symbol uses nbBits */
name|size_t
name|FSE_buildDTable_rle
parameter_list|(
name|FSE_DTable
modifier|*
name|dt
parameter_list|,
name|unsigned
name|char
name|symbolValue
parameter_list|)
function_decl|;
comment|/**< build a fake FSE_DTable, designed to always generate the same symbolValue */
name|size_t
name|FSE_decompress_wksp
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
name|FSE_DTable
modifier|*
name|workSpace
parameter_list|,
name|unsigned
name|maxLog
parameter_list|)
function_decl|;
comment|/**< same as FSE_decompress(), using an externally allocated `workSpace` produced with `FSE_DTABLE_SIZE_U32(maxLog)` */
comment|/* ***************************************** *  FSE symbol compression API *******************************************/
comment|/*!    This API consists of small unitary functions, which highly benefit from being inlined.    Hence their body are included in next section. */
typedef|typedef
struct|struct
block|{
name|ptrdiff_t
name|value
decl_stmt|;
specifier|const
name|void
modifier|*
name|stateTable
decl_stmt|;
specifier|const
name|void
modifier|*
name|symbolTT
decl_stmt|;
name|unsigned
name|stateLog
decl_stmt|;
block|}
name|FSE_CState_t
typedef|;
specifier|static
name|void
name|FSE_initCState
parameter_list|(
name|FSE_CState_t
modifier|*
name|CStatePtr
parameter_list|,
specifier|const
name|FSE_CTable
modifier|*
name|ct
parameter_list|)
function_decl|;
specifier|static
name|void
name|FSE_encodeSymbol
parameter_list|(
name|BIT_CStream_t
modifier|*
name|bitC
parameter_list|,
name|FSE_CState_t
modifier|*
name|CStatePtr
parameter_list|,
name|unsigned
name|symbol
parameter_list|)
function_decl|;
specifier|static
name|void
name|FSE_flushCState
parameter_list|(
name|BIT_CStream_t
modifier|*
name|bitC
parameter_list|,
specifier|const
name|FSE_CState_t
modifier|*
name|CStatePtr
parameter_list|)
function_decl|;
comment|/**< These functions are inner components of FSE_compress_usingCTable(). They allow the creation of custom streams, mixing multiple tables and bit sources.  A key property to keep in mind is that encoding and decoding are done **in reverse direction**. So the first symbol you will encode is the last you will decode, like a LIFO stack.  You will need a few variables to track your CStream. They are :  FSE_CTable    ct;         // Provided by FSE_buildCTable() BIT_CStream_t bitStream;  // bitStream tracking structure FSE_CState_t  state;      // State tracking structure (can have several)   The first thing to do is to init bitStream and state.     size_t errorCode = BIT_initCStream(&bitStream, dstBuffer, maxDstSize);     FSE_initCState(&state, ct);  Note that BIT_initCStream() can produce an error code, so its result should be tested, using FSE_isError(); You can then encode your input data, byte after byte. FSE_encodeSymbol() outputs a maximum of 'tableLog' bits at a time. Remember decoding will be done in reverse direction.     FSE_encodeByte(&bitStream,&state, symbol);  At any time, you can also add any bit sequence. Note : maximum allowed nbBits is 25, for compatibility with 32-bits decoders     BIT_addBits(&bitStream, bitField, nbBits);  The above methods don't commit data to memory, they just store it into local register, for speed. Local register size is 64-bits on 64-bits systems, 32-bits on 32-bits systems (size_t). Writing data to memory is a manual operation, performed by the flushBits function.     BIT_flushBits(&bitStream);  Your last FSE encoding operation shall be to flush your last state value(s).     FSE_flushState(&bitStream,&state);  Finally, you must close the bitStream. The function returns the size of CStream in bytes. If data couldn't fit into dstBuffer, it will return a 0 ( == not compressible) If there is an error, it returns an errorCode (which can be tested using FSE_isError()).     size_t size = BIT_closeCStream(&bitStream); */
comment|/* ***************************************** *  FSE symbol decompression API *******************************************/
typedef|typedef
struct|struct
block|{
name|size_t
name|state
decl_stmt|;
specifier|const
name|void
modifier|*
name|table
decl_stmt|;
comment|/* precise table may vary, depending on U16 */
block|}
name|FSE_DState_t
typedef|;
specifier|static
name|void
name|FSE_initDState
parameter_list|(
name|FSE_DState_t
modifier|*
name|DStatePtr
parameter_list|,
name|BIT_DStream_t
modifier|*
name|bitD
parameter_list|,
specifier|const
name|FSE_DTable
modifier|*
name|dt
parameter_list|)
function_decl|;
specifier|static
name|unsigned
name|char
name|FSE_decodeSymbol
parameter_list|(
name|FSE_DState_t
modifier|*
name|DStatePtr
parameter_list|,
name|BIT_DStream_t
modifier|*
name|bitD
parameter_list|)
function_decl|;
specifier|static
name|unsigned
name|FSE_endOfDState
parameter_list|(
specifier|const
name|FSE_DState_t
modifier|*
name|DStatePtr
parameter_list|)
function_decl|;
comment|/**< Let's now decompose FSE_decompress_usingDTable() into its unitary components. You will decode FSE-encoded symbols from the bitStream, and also any other bitFields you put in, **in reverse order**.  You will need a few variables to track your bitStream. They are :  BIT_DStream_t DStream;    // Stream context FSE_DState_t  DState;     // State context. Multiple ones are possible FSE_DTable*   DTablePtr;  // Decoding table, provided by FSE_buildDTable()  The first thing to do is to init the bitStream.     errorCode = BIT_initDStream(&DStream, srcBuffer, srcSize);  You should then retrieve your initial state(s) (in reverse flushing order if you have several ones) :     errorCode = FSE_initDState(&DState,&DStream, DTablePtr);  You can then decode your data, symbol after symbol. For information the maximum number of bits read by FSE_decodeSymbol() is 'tableLog'. Keep in mind that symbols are decoded in reverse order, like a LIFO stack (last in, first out).     unsigned char symbol = FSE_decodeSymbol(&DState,&DStream);  You can retrieve any bitfield you eventually stored into the bitStream (in reverse order) Note : maximum allowed nbBits is 25, for 32-bits compatibility     size_t bitField = BIT_readBits(&DStream, nbBits);  All above operations only read from local register (which size depends on size_t). Refueling the register from memory is manually performed by the reload method.     endSignal = FSE_reloadDStream(&DStream);  BIT_reloadDStream() result tells if there is still some more data to read from DStream. BIT_DStream_unfinished : there is still some data left into the DStream. BIT_DStream_endOfBuffer : Dstream reached end of buffer. Its container may no longer be completely filled. BIT_DStream_completed : Dstream reached its exact end, corresponding in general to decompression completed. BIT_DStream_tooFar : Dstream went too far. Decompression result is corrupted.  When reaching end of buffer (BIT_DStream_endOfBuffer), progress slowly, notably if you decode multiple symbols per loop, to properly detect the exact end of stream. After each decoded symbol, check if DStream is fully consumed using this simple test :     BIT_reloadDStream(&DStream)>= BIT_DStream_completed  When it's done, verify decompression is fully completed, by checking both DStream and the relevant states. Checking if DStream has reached its end is performed by :     BIT_endOfDStream(&DStream); Check also the states. There might be some symbols left there, if some high probability ones (>50%) are possible.     FSE_endOfDState(&DState); */
comment|/* ***************************************** *  FSE unsafe API *******************************************/
specifier|static
name|unsigned
name|char
name|FSE_decodeSymbolFast
parameter_list|(
name|FSE_DState_t
modifier|*
name|DStatePtr
parameter_list|,
name|BIT_DStream_t
modifier|*
name|bitD
parameter_list|)
function_decl|;
comment|/* faster, but works only if nbBits is always>= 1 (otherwise, result will be corrupted) */
comment|/* ***************************************** *  Implementation of inlined functions *******************************************/
typedef|typedef
struct|struct
block|{
name|int
name|deltaFindState
decl_stmt|;
name|U32
name|deltaNbBits
decl_stmt|;
block|}
name|FSE_symbolCompressionTransform
typedef|;
comment|/* total 8 bytes */
name|MEM_STATIC
name|void
name|FSE_initCState
parameter_list|(
name|FSE_CState_t
modifier|*
name|statePtr
parameter_list|,
specifier|const
name|FSE_CTable
modifier|*
name|ct
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|ptr
init|=
name|ct
decl_stmt|;
specifier|const
name|U16
modifier|*
name|u16ptr
init|=
operator|(
specifier|const
name|U16
operator|*
operator|)
name|ptr
decl_stmt|;
specifier|const
name|U32
name|tableLog
init|=
name|MEM_read16
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
name|statePtr
operator|->
name|value
operator|=
operator|(
name|ptrdiff_t
operator|)
literal|1
operator|<<
name|tableLog
expr_stmt|;
name|statePtr
operator|->
name|stateTable
operator|=
name|u16ptr
operator|+
literal|2
expr_stmt|;
name|statePtr
operator|->
name|symbolTT
operator|=
operator|(
operator|(
specifier|const
name|U32
operator|*
operator|)
name|ct
operator|+
literal|1
operator|+
operator|(
name|tableLog
condition|?
operator|(
literal|1
operator|<<
operator|(
name|tableLog
operator|-
literal|1
operator|)
operator|)
else|:
literal|1
operator|)
operator|)
expr_stmt|;
name|statePtr
operator|->
name|stateLog
operator|=
name|tableLog
expr_stmt|;
block|}
comment|/*! FSE_initCState2() : *   Same as FSE_initCState(), but the first symbol to include (which will be the last to be read) *   uses the smallest state value possible, saving the cost of this symbol */
name|MEM_STATIC
name|void
name|FSE_initCState2
parameter_list|(
name|FSE_CState_t
modifier|*
name|statePtr
parameter_list|,
specifier|const
name|FSE_CTable
modifier|*
name|ct
parameter_list|,
name|U32
name|symbol
parameter_list|)
block|{
name|FSE_initCState
argument_list|(
name|statePtr
argument_list|,
name|ct
argument_list|)
expr_stmt|;
block|{
specifier|const
name|FSE_symbolCompressionTransform
name|symbolTT
init|=
operator|(
operator|(
specifier|const
name|FSE_symbolCompressionTransform
operator|*
operator|)
operator|(
name|statePtr
operator|->
name|symbolTT
operator|)
operator|)
index|[
name|symbol
index|]
decl_stmt|;
specifier|const
name|U16
modifier|*
name|stateTable
init|=
operator|(
specifier|const
name|U16
operator|*
operator|)
operator|(
name|statePtr
operator|->
name|stateTable
operator|)
decl_stmt|;
name|U32
name|nbBitsOut
init|=
call|(
name|U32
call|)
argument_list|(
operator|(
name|symbolTT
operator|.
name|deltaNbBits
operator|+
operator|(
literal|1
operator|<<
literal|15
operator|)
operator|)
operator|>>
literal|16
argument_list|)
decl_stmt|;
name|statePtr
operator|->
name|value
operator|=
operator|(
name|nbBitsOut
operator|<<
literal|16
operator|)
operator|-
name|symbolTT
operator|.
name|deltaNbBits
expr_stmt|;
name|statePtr
operator|->
name|value
operator|=
name|stateTable
index|[
operator|(
name|statePtr
operator|->
name|value
operator|>>
name|nbBitsOut
operator|)
operator|+
name|symbolTT
operator|.
name|deltaFindState
index|]
expr_stmt|;
block|}
block|}
name|MEM_STATIC
name|void
name|FSE_encodeSymbol
parameter_list|(
name|BIT_CStream_t
modifier|*
name|bitC
parameter_list|,
name|FSE_CState_t
modifier|*
name|statePtr
parameter_list|,
name|U32
name|symbol
parameter_list|)
block|{
name|FSE_symbolCompressionTransform
specifier|const
name|symbolTT
init|=
operator|(
operator|(
specifier|const
name|FSE_symbolCompressionTransform
operator|*
operator|)
operator|(
name|statePtr
operator|->
name|symbolTT
operator|)
operator|)
index|[
name|symbol
index|]
decl_stmt|;
specifier|const
name|U16
modifier|*
specifier|const
name|stateTable
init|=
operator|(
specifier|const
name|U16
operator|*
operator|)
operator|(
name|statePtr
operator|->
name|stateTable
operator|)
decl_stmt|;
name|U32
specifier|const
name|nbBitsOut
init|=
call|(
name|U32
call|)
argument_list|(
operator|(
name|statePtr
operator|->
name|value
operator|+
name|symbolTT
operator|.
name|deltaNbBits
operator|)
operator|>>
literal|16
argument_list|)
decl_stmt|;
name|BIT_addBits
argument_list|(
name|bitC
argument_list|,
name|statePtr
operator|->
name|value
argument_list|,
name|nbBitsOut
argument_list|)
expr_stmt|;
name|statePtr
operator|->
name|value
operator|=
name|stateTable
index|[
operator|(
name|statePtr
operator|->
name|value
operator|>>
name|nbBitsOut
operator|)
operator|+
name|symbolTT
operator|.
name|deltaFindState
index|]
expr_stmt|;
block|}
name|MEM_STATIC
name|void
name|FSE_flushCState
parameter_list|(
name|BIT_CStream_t
modifier|*
name|bitC
parameter_list|,
specifier|const
name|FSE_CState_t
modifier|*
name|statePtr
parameter_list|)
block|{
name|BIT_addBits
argument_list|(
name|bitC
argument_list|,
name|statePtr
operator|->
name|value
argument_list|,
name|statePtr
operator|->
name|stateLog
argument_list|)
expr_stmt|;
name|BIT_flushBits
argument_list|(
name|bitC
argument_list|)
expr_stmt|;
block|}
comment|/* ======    Decompression    ====== */
typedef|typedef
struct|struct
block|{
name|U16
name|tableLog
decl_stmt|;
name|U16
name|fastMode
decl_stmt|;
block|}
name|FSE_DTableHeader
typedef|;
comment|/* sizeof U32 */
typedef|typedef
struct|struct
block|{
name|unsigned
name|short
name|newState
decl_stmt|;
name|unsigned
name|char
name|symbol
decl_stmt|;
name|unsigned
name|char
name|nbBits
decl_stmt|;
block|}
name|FSE_decode_t
typedef|;
comment|/* size == U32 */
name|MEM_STATIC
name|void
name|FSE_initDState
parameter_list|(
name|FSE_DState_t
modifier|*
name|DStatePtr
parameter_list|,
name|BIT_DStream_t
modifier|*
name|bitD
parameter_list|,
specifier|const
name|FSE_DTable
modifier|*
name|dt
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|ptr
init|=
name|dt
decl_stmt|;
specifier|const
name|FSE_DTableHeader
modifier|*
specifier|const
name|DTableH
init|=
operator|(
specifier|const
name|FSE_DTableHeader
operator|*
operator|)
name|ptr
decl_stmt|;
name|DStatePtr
operator|->
name|state
operator|=
name|BIT_readBits
argument_list|(
name|bitD
argument_list|,
name|DTableH
operator|->
name|tableLog
argument_list|)
expr_stmt|;
name|BIT_reloadDStream
argument_list|(
name|bitD
argument_list|)
expr_stmt|;
name|DStatePtr
operator|->
name|table
operator|=
name|dt
operator|+
literal|1
expr_stmt|;
block|}
name|MEM_STATIC
name|BYTE
name|FSE_peekSymbol
parameter_list|(
specifier|const
name|FSE_DState_t
modifier|*
name|DStatePtr
parameter_list|)
block|{
name|FSE_decode_t
specifier|const
name|DInfo
init|=
operator|(
operator|(
specifier|const
name|FSE_decode_t
operator|*
operator|)
operator|(
name|DStatePtr
operator|->
name|table
operator|)
operator|)
index|[
name|DStatePtr
operator|->
name|state
index|]
decl_stmt|;
return|return
name|DInfo
operator|.
name|symbol
return|;
block|}
name|MEM_STATIC
name|void
name|FSE_updateState
parameter_list|(
name|FSE_DState_t
modifier|*
name|DStatePtr
parameter_list|,
name|BIT_DStream_t
modifier|*
name|bitD
parameter_list|)
block|{
name|FSE_decode_t
specifier|const
name|DInfo
init|=
operator|(
operator|(
specifier|const
name|FSE_decode_t
operator|*
operator|)
operator|(
name|DStatePtr
operator|->
name|table
operator|)
operator|)
index|[
name|DStatePtr
operator|->
name|state
index|]
decl_stmt|;
name|U32
specifier|const
name|nbBits
init|=
name|DInfo
operator|.
name|nbBits
decl_stmt|;
name|size_t
specifier|const
name|lowBits
init|=
name|BIT_readBits
argument_list|(
name|bitD
argument_list|,
name|nbBits
argument_list|)
decl_stmt|;
name|DStatePtr
operator|->
name|state
operator|=
name|DInfo
operator|.
name|newState
operator|+
name|lowBits
expr_stmt|;
block|}
name|MEM_STATIC
name|BYTE
name|FSE_decodeSymbol
parameter_list|(
name|FSE_DState_t
modifier|*
name|DStatePtr
parameter_list|,
name|BIT_DStream_t
modifier|*
name|bitD
parameter_list|)
block|{
name|FSE_decode_t
specifier|const
name|DInfo
init|=
operator|(
operator|(
specifier|const
name|FSE_decode_t
operator|*
operator|)
operator|(
name|DStatePtr
operator|->
name|table
operator|)
operator|)
index|[
name|DStatePtr
operator|->
name|state
index|]
decl_stmt|;
name|U32
specifier|const
name|nbBits
init|=
name|DInfo
operator|.
name|nbBits
decl_stmt|;
name|BYTE
specifier|const
name|symbol
init|=
name|DInfo
operator|.
name|symbol
decl_stmt|;
name|size_t
specifier|const
name|lowBits
init|=
name|BIT_readBits
argument_list|(
name|bitD
argument_list|,
name|nbBits
argument_list|)
decl_stmt|;
name|DStatePtr
operator|->
name|state
operator|=
name|DInfo
operator|.
name|newState
operator|+
name|lowBits
expr_stmt|;
return|return
name|symbol
return|;
block|}
comment|/*! FSE_decodeSymbolFast() :     unsafe, only works if no symbol has a probability> 50% */
name|MEM_STATIC
name|BYTE
name|FSE_decodeSymbolFast
parameter_list|(
name|FSE_DState_t
modifier|*
name|DStatePtr
parameter_list|,
name|BIT_DStream_t
modifier|*
name|bitD
parameter_list|)
block|{
name|FSE_decode_t
specifier|const
name|DInfo
init|=
operator|(
operator|(
specifier|const
name|FSE_decode_t
operator|*
operator|)
operator|(
name|DStatePtr
operator|->
name|table
operator|)
operator|)
index|[
name|DStatePtr
operator|->
name|state
index|]
decl_stmt|;
name|U32
specifier|const
name|nbBits
init|=
name|DInfo
operator|.
name|nbBits
decl_stmt|;
name|BYTE
specifier|const
name|symbol
init|=
name|DInfo
operator|.
name|symbol
decl_stmt|;
name|size_t
specifier|const
name|lowBits
init|=
name|BIT_readBitsFast
argument_list|(
name|bitD
argument_list|,
name|nbBits
argument_list|)
decl_stmt|;
name|DStatePtr
operator|->
name|state
operator|=
name|DInfo
operator|.
name|newState
operator|+
name|lowBits
expr_stmt|;
return|return
name|symbol
return|;
block|}
name|MEM_STATIC
name|unsigned
name|FSE_endOfDState
parameter_list|(
specifier|const
name|FSE_DState_t
modifier|*
name|DStatePtr
parameter_list|)
block|{
return|return
name|DStatePtr
operator|->
name|state
operator|==
literal|0
return|;
block|}
ifndef|#
directive|ifndef
name|FSE_COMMONDEFS_ONLY
comment|/* ************************************************************** *  Tuning parameters ****************************************************************/
comment|/*!MEMORY_USAGE : *  Memory usage formula : N->2^N Bytes (examples : 10 -> 1KB; 12 -> 4KB ; 16 -> 64KB; 20 -> 1MB; etc.) *  Increasing memory usage improves compression ratio *  Reduced memory usage can improve speed, due to cache effect *  Recommended max value is 14, for 16KB, which nicely fits into Intel x86 L1 cache */
ifndef|#
directive|ifndef
name|FSE_MAX_MEMORY_USAGE
define|#
directive|define
name|FSE_MAX_MEMORY_USAGE
value|14
endif|#
directive|endif
ifndef|#
directive|ifndef
name|FSE_DEFAULT_MEMORY_USAGE
define|#
directive|define
name|FSE_DEFAULT_MEMORY_USAGE
value|13
endif|#
directive|endif
comment|/*!FSE_MAX_SYMBOL_VALUE : *  Maximum symbol value authorized. *  Required for proper stack allocation */
ifndef|#
directive|ifndef
name|FSE_MAX_SYMBOL_VALUE
define|#
directive|define
name|FSE_MAX_SYMBOL_VALUE
value|255
endif|#
directive|endif
comment|/* ************************************************************** *  template functions type& suffix ****************************************************************/
define|#
directive|define
name|FSE_FUNCTION_TYPE
value|BYTE
define|#
directive|define
name|FSE_FUNCTION_EXTENSION
define|#
directive|define
name|FSE_DECODE_TYPE
value|FSE_decode_t
endif|#
directive|endif
comment|/* !FSE_COMMONDEFS_ONLY */
comment|/* *************************************************************** *  Constants *****************************************************************/
define|#
directive|define
name|FSE_MAX_TABLELOG
value|(FSE_MAX_MEMORY_USAGE-2)
define|#
directive|define
name|FSE_MAX_TABLESIZE
value|(1U<<FSE_MAX_TABLELOG)
define|#
directive|define
name|FSE_MAXTABLESIZE_MASK
value|(FSE_MAX_TABLESIZE-1)
define|#
directive|define
name|FSE_DEFAULT_TABLELOG
value|(FSE_DEFAULT_MEMORY_USAGE-2)
define|#
directive|define
name|FSE_MIN_TABLELOG
value|5
define|#
directive|define
name|FSE_TABLELOG_ABSOLUTE_MAX
value|15
if|#
directive|if
name|FSE_MAX_TABLELOG
operator|>
name|FSE_TABLELOG_ABSOLUTE_MAX
error|#
directive|error
literal|"FSE_MAX_TABLELOG> FSE_TABLELOG_ABSOLUTE_MAX is not supported"
endif|#
directive|endif
define|#
directive|define
name|FSE_TABLESTEP
parameter_list|(
name|tableSize
parameter_list|)
value|((tableSize>>1) + (tableSize>>3) + 3)
endif|#
directive|endif
comment|/* FSE_STATIC_LINKING_ONLY */
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FSE_H */
end_comment

end_unit

