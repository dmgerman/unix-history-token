begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2016-present, Yann Collet, Facebook, Inc.  * All rights reserved.  *  * This source code is licensed under the BSD-style license found in the  * LICENSE file in the root directory of this source tree. An additional grant  * of patent rights can be found in the PATENTS file in the same directory.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
ifndef|#
directive|ifndef
name|ZSTD_H_235446
define|#
directive|define
name|ZSTD_H_235446
comment|/* ======   Dependency   ======*/
include|#
directive|include
file|<stddef.h>
comment|/* size_t */
comment|/* =====   ZSTDLIB_API : control library symbols visibility   ===== */
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|__GNUC__
operator|>=
literal|4
operator|)
define|#
directive|define
name|ZSTDLIB_VISIBILITY
value|__attribute__ ((visibility ("default")))
else|#
directive|else
define|#
directive|define
name|ZSTDLIB_VISIBILITY
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ZSTD_DLL_EXPORT
argument_list|)
operator|&&
operator|(
name|ZSTD_DLL_EXPORT
operator|==
literal|1
operator|)
define|#
directive|define
name|ZSTDLIB_API
value|__declspec(dllexport) ZSTDLIB_VISIBILITY
elif|#
directive|elif
name|defined
argument_list|(
name|ZSTD_DLL_IMPORT
argument_list|)
operator|&&
operator|(
name|ZSTD_DLL_IMPORT
operator|==
literal|1
operator|)
define|#
directive|define
name|ZSTDLIB_API
value|__declspec(dllimport) ZSTDLIB_VISIBILITY
comment|/* It isn't required but allows to generate better code, saving a function pointer load from the IAT and an indirect jump.*/
else|#
directive|else
define|#
directive|define
name|ZSTDLIB_API
value|ZSTDLIB_VISIBILITY
endif|#
directive|endif
comment|/*******************************************************************************************************   Introduction    zstd, short for Zstandard, is a fast lossless compression algorithm, targeting real-time compression scenarios   at zlib-level and better compression ratios. The zstd compression library provides in-memory compression and   decompression functions. The library supports compression levels from 1 up to ZSTD_maxCLevel() which is 22.   Levels>= 20, labeled `--ultra`, should be used with caution, as they require more memory.   Compression can be done in:     - a single step (described as Simple API)     - a single step, reusing a context (described as Explicit memory management)     - unbounded multiple steps (described as Streaming compression)   The compression ratio achievable on small data can be highly improved using compression with a dictionary in:     - a single step (described as Simple dictionary API)     - a single step, reusing a dictionary (described as Fast dictionary API)    Advanced experimental functions can be accessed using #define ZSTD_STATIC_LINKING_ONLY before including zstd.h.   These APIs shall never be used with a dynamic library.   They are not "stable", their definition may change in the future. Only static linking is allowed. *********************************************************************************************************/
comment|/*------   Version   ------*/
define|#
directive|define
name|ZSTD_VERSION_MAJOR
value|1
define|#
directive|define
name|ZSTD_VERSION_MINOR
value|2
define|#
directive|define
name|ZSTD_VERSION_RELEASE
value|0
define|#
directive|define
name|ZSTD_LIB_VERSION
value|ZSTD_VERSION_MAJOR.ZSTD_VERSION_MINOR.ZSTD_VERSION_RELEASE
define|#
directive|define
name|ZSTD_QUOTE
parameter_list|(
name|str
parameter_list|)
value|#str
define|#
directive|define
name|ZSTD_EXPAND_AND_QUOTE
parameter_list|(
name|str
parameter_list|)
value|ZSTD_QUOTE(str)
define|#
directive|define
name|ZSTD_VERSION_STRING
value|ZSTD_EXPAND_AND_QUOTE(ZSTD_LIB_VERSION)
define|#
directive|define
name|ZSTD_VERSION_NUMBER
value|(ZSTD_VERSION_MAJOR *100*100 + ZSTD_VERSION_MINOR *100 + ZSTD_VERSION_RELEASE)
name|ZSTDLIB_API
name|unsigned
name|ZSTD_versionNumber
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/**< library version number; to be used when checking dll version */
comment|/*************************************** *  Simple API ***************************************/
comment|/*! ZSTD_compress() :  *  Compresses `src` content as a single zstd compressed frame into already allocated `dst`.  *  Hint : compression runs faster if `dstCapacity`>=  `ZSTD_compressBound(srcSize)`.  *  @return : compressed size written into `dst` (<= `dstCapacity),  *            or an error code if it fails (which can be tested using ZSTD_isError()). */
name|ZSTDLIB_API
name|size_t
name|ZSTD_compress
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|int
name|compressionLevel
parameter_list|)
function_decl|;
comment|/*! ZSTD_decompress() :  *  `compressedSize` : must be the _exact_ size of some number of compressed and/or skippable frames.  *  `dstCapacity` is an upper bound of originalSize.  *  If user cannot imply a maximum upper bound, it's better to use streaming mode to decompress data.  *  @return : the number of bytes decompressed into `dst` (<= `dstCapacity`),  *            or an errorCode if it fails (which can be tested using ZSTD_isError()). */
name|ZSTDLIB_API
name|size_t
name|ZSTD_decompress
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|compressedSize
parameter_list|)
function_decl|;
comment|/*! ZSTD_getDecompressedSize() :  *  NOTE: This function is planned to be obsolete, in favour of ZSTD_getFrameContentSize.  *  ZSTD_getFrameContentSize functions the same way, returning the decompressed size of a single  *  frame, but distinguishes empty frames from frames with an unknown size, or errors.  *  *  Additionally, ZSTD_findDecompressedSize can be used instead.  It can handle multiple  *  concatenated frames in one buffer, and so is more general.  *  As a result however, it requires more computation and entire frames to be passed to it,  *  as opposed to ZSTD_getFrameContentSize which requires only a single frame's header.  *  *  'src' is the start of a zstd compressed frame.  *  @return : content size to be decompressed, as a 64-bits value _if known_, 0 otherwise.  *   note 1 : decompressed size is an optional field, that may not be present, especially in streaming mode.  *            When `return==0`, data to decompress could be any size.  *            In which case, it's necessary to use streaming mode to decompress data.  *            Optionally, application can still use ZSTD_decompress() while relying on implied limits.  *            (For example, data may be necessarily cut into blocks<= 16 KB).  *   note 2 : decompressed size is always present when compression is done with ZSTD_compress()  *   note 3 : decompressed size can be very large (64-bits value),  *            potentially larger than what local system can handle as a single memory segment.  *            In which case, it's necessary to use streaming mode to decompress data.  *   note 4 : If source is untrusted, decompressed size could be wrong or intentionally modified.  *            Always ensure result fits within application's authorized limits.  *            Each application can set its own limits.  *   note 5 : when `return==0`, if precise failure cause is needed, use ZSTD_getFrameParams() to know more. */
name|ZSTDLIB_API
name|unsigned
name|long
name|long
name|ZSTD_getDecompressedSize
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
comment|/*======  Helper functions  ======*/
name|ZSTDLIB_API
name|int
name|ZSTD_maxCLevel
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/*!< maximum compression level available */
name|ZSTDLIB_API
name|size_t
name|ZSTD_compressBound
parameter_list|(
name|size_t
name|srcSize
parameter_list|)
function_decl|;
comment|/*!< maximum compressed size in worst case scenario */
name|ZSTDLIB_API
name|unsigned
name|ZSTD_isError
parameter_list|(
name|size_t
name|code
parameter_list|)
function_decl|;
comment|/*!< tells if a `size_t` function result is an error code */
name|ZSTDLIB_API
specifier|const
name|char
modifier|*
name|ZSTD_getErrorName
parameter_list|(
name|size_t
name|code
parameter_list|)
function_decl|;
comment|/*!< provides readable string from an error code */
comment|/*************************************** *  Explicit memory management ***************************************/
comment|/*= Compression context  *  When compressing many times,  *  it is recommended to allocate a context just once, and re-use it for each successive compression operation.  *  This will make workload friendlier for system's memory.  *  Use one context per thread for parallel execution in multi-threaded environments. */
typedef|typedef
name|struct
name|ZSTD_CCtx_s
name|ZSTD_CCtx
typedef|;
name|ZSTDLIB_API
name|ZSTD_CCtx
modifier|*
name|ZSTD_createCCtx
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_freeCCtx
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|)
function_decl|;
comment|/*! ZSTD_compressCCtx() :  *  Same as ZSTD_compress(), requires an allocated ZSTD_CCtx (see ZSTD_createCCtx()). */
name|ZSTDLIB_API
name|size_t
name|ZSTD_compressCCtx
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|ctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|int
name|compressionLevel
parameter_list|)
function_decl|;
comment|/*= Decompression context  *  When decompressing many times,  *  it is recommended to allocate a context just once, and re-use it for each successive compression operation.  *  This will make workload friendlier for system's memory.  *  Use one context per thread for parallel execution in multi-threaded environments. */
typedef|typedef
name|struct
name|ZSTD_DCtx_s
name|ZSTD_DCtx
typedef|;
name|ZSTDLIB_API
name|ZSTD_DCtx
modifier|*
name|ZSTD_createDCtx
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_freeDCtx
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|)
function_decl|;
comment|/*! ZSTD_decompressDCtx() :  *  Same as ZSTD_decompress(), requires an allocated ZSTD_DCtx (see ZSTD_createDCtx()). */
name|ZSTDLIB_API
name|size_t
name|ZSTD_decompressDCtx
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|ctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
comment|/************************** *  Simple dictionary API ***************************/
comment|/*! ZSTD_compress_usingDict() : *   Compression using a predefined Dictionary (see dictBuilder/zdict.h). *   Note : This function loads the dictionary, resulting in significant startup delay. *   Note : When `dict == NULL || dictSize< 8` no dictionary is used. */
name|ZSTDLIB_API
name|size_t
name|ZSTD_compress_usingDict
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|ctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|,
name|int
name|compressionLevel
parameter_list|)
function_decl|;
comment|/*! ZSTD_decompress_usingDict() : *   Decompression using a predefined Dictionary (see dictBuilder/zdict.h). *   Dictionary must be identical to the one used during compression. *   Note : This function loads the dictionary, resulting in significant startup delay. *   Note : When `dict == NULL || dictSize< 8` no dictionary is used. */
name|ZSTDLIB_API
name|size_t
name|ZSTD_decompress_usingDict
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|)
function_decl|;
comment|/**************************** *  Fast dictionary API ****************************/
typedef|typedef
name|struct
name|ZSTD_CDict_s
name|ZSTD_CDict
typedef|;
comment|/*! ZSTD_createCDict() : *   When compressing multiple messages / blocks with the same dictionary, it's recommended to load it just once. *   ZSTD_createCDict() will create a digested dictionary, ready to start future compression operations without startup delay. *   ZSTD_CDict can be created once and used by multiple threads concurrently, as its usage is read-only. *   `dictBuffer` can be released after ZSTD_CDict creation, as its content is copied within CDict */
name|ZSTDLIB_API
name|ZSTD_CDict
modifier|*
name|ZSTD_createCDict
parameter_list|(
specifier|const
name|void
modifier|*
name|dictBuffer
parameter_list|,
name|size_t
name|dictSize
parameter_list|,
name|int
name|compressionLevel
parameter_list|)
function_decl|;
comment|/*! ZSTD_freeCDict() : *   Function frees memory allocated by ZSTD_createCDict(). */
name|ZSTDLIB_API
name|size_t
name|ZSTD_freeCDict
parameter_list|(
name|ZSTD_CDict
modifier|*
name|CDict
parameter_list|)
function_decl|;
comment|/*! ZSTD_compress_usingCDict() :  *  Compression using a digested Dictionary.  *  Faster startup than ZSTD_compress_usingDict(), recommended when same dictionary is used multiple times.  *  Note that compression level is decided during dictionary creation.  *  Frame parameters are hardcoded (dictID=yes, contentSize=yes, checksum=no) */
name|ZSTDLIB_API
name|size_t
name|ZSTD_compress_usingCDict
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
specifier|const
name|ZSTD_CDict
modifier|*
name|cdict
parameter_list|)
function_decl|;
typedef|typedef
name|struct
name|ZSTD_DDict_s
name|ZSTD_DDict
typedef|;
comment|/*! ZSTD_createDDict() : *   Create a digested dictionary, ready to start decompression operation without startup delay. *   dictBuffer can be released after DDict creation, as its content is copied inside DDict */
name|ZSTDLIB_API
name|ZSTD_DDict
modifier|*
name|ZSTD_createDDict
parameter_list|(
specifier|const
name|void
modifier|*
name|dictBuffer
parameter_list|,
name|size_t
name|dictSize
parameter_list|)
function_decl|;
comment|/*! ZSTD_freeDDict() : *   Function frees memory allocated with ZSTD_createDDict() */
name|ZSTDLIB_API
name|size_t
name|ZSTD_freeDDict
parameter_list|(
name|ZSTD_DDict
modifier|*
name|ddict
parameter_list|)
function_decl|;
comment|/*! ZSTD_decompress_usingDDict() : *   Decompression using a digested Dictionary. *   Faster startup than ZSTD_decompress_usingDict(), recommended when same dictionary is used multiple times. */
name|ZSTDLIB_API
name|size_t
name|ZSTD_decompress_usingDDict
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
specifier|const
name|ZSTD_DDict
modifier|*
name|ddict
parameter_list|)
function_decl|;
comment|/**************************** *  Streaming ****************************/
typedef|typedef
struct|struct
name|ZSTD_inBuffer_s
block|{
specifier|const
name|void
modifier|*
name|src
decl_stmt|;
comment|/**< start of input buffer */
name|size_t
name|size
decl_stmt|;
comment|/**< size of input buffer */
name|size_t
name|pos
decl_stmt|;
comment|/**< position where reading stopped. Will be updated. Necessarily 0<= pos<= size */
block|}
name|ZSTD_inBuffer
typedef|;
typedef|typedef
struct|struct
name|ZSTD_outBuffer_s
block|{
name|void
modifier|*
name|dst
decl_stmt|;
comment|/**< start of output buffer */
name|size_t
name|size
decl_stmt|;
comment|/**< size of output buffer */
name|size_t
name|pos
decl_stmt|;
comment|/**< position where writing stopped. Will be updated. Necessarily 0<= pos<= size */
block|}
name|ZSTD_outBuffer
typedef|;
comment|/*-*********************************************************************** *  Streaming compression - HowTo * *  A ZSTD_CStream object is required to track streaming operation. *  Use ZSTD_createCStream() and ZSTD_freeCStream() to create/release resources. *  ZSTD_CStream objects can be reused multiple times on consecutive compression operations. *  It is recommended to re-use ZSTD_CStream in situations where many streaming operations will be achieved consecutively, *  since it will play nicer with system's memory, by re-using already allocated memory. *  Use one separate ZSTD_CStream per thread for parallel execution. * *  Start a new compression by initializing ZSTD_CStream. *  Use ZSTD_initCStream() to start a new compression operation. *  Use ZSTD_initCStream_usingDict() or ZSTD_initCStream_usingCDict() for a compression which requires a dictionary (experimental section) * *  Use ZSTD_compressStream() repetitively to consume input stream. *  The function will automatically update both `pos` fields. *  Note that it may not consume the entire input, in which case `pos< size`, *  and it's up to the caller to present again remaining data. *  @return : a size hint, preferred nb of bytes to use as input for next function call *            or an error code, which can be tested using ZSTD_isError(). *            Note 1 : it's just a hint, to help latency a little, any other value will work fine. *            Note 2 : size hint is guaranteed to be<= ZSTD_CStreamInSize() * *  At any moment, it's possible to flush whatever data remains within internal buffer, using ZSTD_flushStream(). *  `output->pos` will be updated. *  Note that some content might still be left within internal buffer if `output->size` is too small. *  @return : nb of bytes still present within internal buffer (0 if it's empty) *            or an error code, which can be tested using ZSTD_isError(). * *  ZSTD_endStream() instructs to finish a frame. *  It will perform a flush and write frame epilogue. *  The epilogue is required for decoders to consider a frame completed. *  Similar to ZSTD_flushStream(), it may not be able to flush the full content if `output->size` is too small. *  In which case, call again ZSTD_endStream() to complete the flush. *  @return : nb of bytes still present within internal buffer (0 if it's empty, hence compression completed) *            or an error code, which can be tested using ZSTD_isError(). * * *******************************************************************/
typedef|typedef
name|struct
name|ZSTD_CStream_s
name|ZSTD_CStream
typedef|;
comment|/*===== ZSTD_CStream management functions =====*/
name|ZSTDLIB_API
name|ZSTD_CStream
modifier|*
name|ZSTD_createCStream
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_freeCStream
parameter_list|(
name|ZSTD_CStream
modifier|*
name|zcs
parameter_list|)
function_decl|;
comment|/*===== Streaming compression functions =====*/
name|ZSTDLIB_API
name|size_t
name|ZSTD_initCStream
parameter_list|(
name|ZSTD_CStream
modifier|*
name|zcs
parameter_list|,
name|int
name|compressionLevel
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_compressStream
parameter_list|(
name|ZSTD_CStream
modifier|*
name|zcs
parameter_list|,
name|ZSTD_outBuffer
modifier|*
name|output
parameter_list|,
name|ZSTD_inBuffer
modifier|*
name|input
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_flushStream
parameter_list|(
name|ZSTD_CStream
modifier|*
name|zcs
parameter_list|,
name|ZSTD_outBuffer
modifier|*
name|output
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_endStream
parameter_list|(
name|ZSTD_CStream
modifier|*
name|zcs
parameter_list|,
name|ZSTD_outBuffer
modifier|*
name|output
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_CStreamInSize
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/**< recommended size for input buffer */
name|ZSTDLIB_API
name|size_t
name|ZSTD_CStreamOutSize
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/**< recommended size for output buffer. Guarantee to successfully flush at least one complete compressed block in all circumstances. */
comment|/*-*************************************************************************** *  Streaming decompression - HowTo * *  A ZSTD_DStream object is required to track streaming operations. *  Use ZSTD_createDStream() and ZSTD_freeDStream() to create/release resources. *  ZSTD_DStream objects can be re-used multiple times. * *  Use ZSTD_initDStream() to start a new decompression operation, *   or ZSTD_initDStream_usingDict() if decompression requires a dictionary. *   @return : recommended first input size * *  Use ZSTD_decompressStream() repetitively to consume your input. *  The function will update both `pos` fields. *  If `input.pos< input.size`, some input has not been consumed. *  It's up to the caller to present again remaining data. *  If `output.pos< output.size`, decoder has flushed everything it could. *  @return : 0 when a frame is completely decoded and fully flushed, *            an error code, which can be tested using ZSTD_isError(), *            any other value> 0, which means there is still some decoding to do to complete current frame. *            The return value is a suggested next input size (a hint to improve latency) that will never load more than the current frame. * *******************************************************************************/
typedef|typedef
name|struct
name|ZSTD_DStream_s
name|ZSTD_DStream
typedef|;
comment|/*===== ZSTD_DStream management functions =====*/
name|ZSTDLIB_API
name|ZSTD_DStream
modifier|*
name|ZSTD_createDStream
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_freeDStream
parameter_list|(
name|ZSTD_DStream
modifier|*
name|zds
parameter_list|)
function_decl|;
comment|/*===== Streaming decompression functions =====*/
name|ZSTDLIB_API
name|size_t
name|ZSTD_initDStream
parameter_list|(
name|ZSTD_DStream
modifier|*
name|zds
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_decompressStream
parameter_list|(
name|ZSTD_DStream
modifier|*
name|zds
parameter_list|,
name|ZSTD_outBuffer
modifier|*
name|output
parameter_list|,
name|ZSTD_inBuffer
modifier|*
name|input
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_DStreamInSize
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/*!< recommended size for input buffer */
name|ZSTDLIB_API
name|size_t
name|ZSTD_DStreamOutSize
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/*!< recommended size for output buffer. Guarantee to successfully flush at least one complete block in all circumstances. */
endif|#
directive|endif
comment|/* ZSTD_H_235446 */
if|#
directive|if
name|defined
argument_list|(
name|ZSTD_STATIC_LINKING_ONLY
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|ZSTD_H_ZSTD_STATIC_LINKING_ONLY
argument_list|)
define|#
directive|define
name|ZSTD_H_ZSTD_STATIC_LINKING_ONLY
comment|/****************************************************************************************  * START OF ADVANCED AND EXPERIMENTAL FUNCTIONS  * The definitions in this section are considered experimental.  * They should never be used with a dynamic library, as they may change in the future.  * They are provided for advanced usages.  * Use them only in association with static linking.  * ***************************************************************************************/
comment|/* --- Constants ---*/
define|#
directive|define
name|ZSTD_MAGICNUMBER
value|0xFD2FB528
comment|/*>= v0.8.0 */
define|#
directive|define
name|ZSTD_MAGIC_SKIPPABLE_START
value|0x184D2A50U
define|#
directive|define
name|ZSTD_CONTENTSIZE_UNKNOWN
value|(0ULL - 1)
define|#
directive|define
name|ZSTD_CONTENTSIZE_ERROR
value|(0ULL - 2)
define|#
directive|define
name|ZSTD_WINDOWLOG_MAX_32
value|27
define|#
directive|define
name|ZSTD_WINDOWLOG_MAX_64
value|27
define|#
directive|define
name|ZSTD_WINDOWLOG_MAX
value|((unsigned)(sizeof(size_t) == 4 ? ZSTD_WINDOWLOG_MAX_32 : ZSTD_WINDOWLOG_MAX_64))
define|#
directive|define
name|ZSTD_WINDOWLOG_MIN
value|10
define|#
directive|define
name|ZSTD_HASHLOG_MAX
value|ZSTD_WINDOWLOG_MAX
define|#
directive|define
name|ZSTD_HASHLOG_MIN
value|6
define|#
directive|define
name|ZSTD_CHAINLOG_MAX
value|(ZSTD_WINDOWLOG_MAX+1)
define|#
directive|define
name|ZSTD_CHAINLOG_MIN
value|ZSTD_HASHLOG_MIN
define|#
directive|define
name|ZSTD_HASHLOG3_MAX
value|17
define|#
directive|define
name|ZSTD_SEARCHLOG_MAX
value|(ZSTD_WINDOWLOG_MAX-1)
define|#
directive|define
name|ZSTD_SEARCHLOG_MIN
value|1
define|#
directive|define
name|ZSTD_SEARCHLENGTH_MAX
value|7
comment|/* only for ZSTD_fast, other strategies are limited to 6 */
define|#
directive|define
name|ZSTD_SEARCHLENGTH_MIN
value|3
comment|/* only for ZSTD_btopt, other strategies are limited to 4 */
define|#
directive|define
name|ZSTD_TARGETLENGTH_MIN
value|4
define|#
directive|define
name|ZSTD_TARGETLENGTH_MAX
value|999
define|#
directive|define
name|ZSTD_FRAMEHEADERSIZE_MAX
value|18
comment|/* for static allocation */
define|#
directive|define
name|ZSTD_FRAMEHEADERSIZE_MIN
value|6
specifier|static
specifier|const
name|size_t
name|ZSTD_frameHeaderSize_prefix
init|=
literal|5
decl_stmt|;
specifier|static
specifier|const
name|size_t
name|ZSTD_frameHeaderSize_min
init|=
name|ZSTD_FRAMEHEADERSIZE_MIN
decl_stmt|;
specifier|static
specifier|const
name|size_t
name|ZSTD_frameHeaderSize_max
init|=
name|ZSTD_FRAMEHEADERSIZE_MAX
decl_stmt|;
specifier|static
specifier|const
name|size_t
name|ZSTD_skippableHeaderSize
init|=
literal|8
decl_stmt|;
comment|/* magic number + skippable frame length */
comment|/*--- Advanced types ---*/
typedef|typedef
enum|enum
block|{
name|ZSTD_fast
block|,
name|ZSTD_dfast
block|,
name|ZSTD_greedy
block|,
name|ZSTD_lazy
block|,
name|ZSTD_lazy2
block|,
name|ZSTD_btlazy2
block|,
name|ZSTD_btopt
block|,
name|ZSTD_btopt2
block|}
name|ZSTD_strategy
typedef|;
comment|/* from faster to stronger */
typedef|typedef
struct|struct
block|{
name|unsigned
name|windowLog
decl_stmt|;
comment|/**< largest match distance : larger == more compression, more memory needed during decompression */
name|unsigned
name|chainLog
decl_stmt|;
comment|/**< fully searched segment : larger == more compression, slower, more memory (useless for fast) */
name|unsigned
name|hashLog
decl_stmt|;
comment|/**< dispatch table : larger == faster, more memory */
name|unsigned
name|searchLog
decl_stmt|;
comment|/**< nb of searches : larger == more compression, slower */
name|unsigned
name|searchLength
decl_stmt|;
comment|/**< match length searched : larger == faster decompression, sometimes less compression */
name|unsigned
name|targetLength
decl_stmt|;
comment|/**< acceptable match size for optimal parser (only) : larger == more compression, slower */
name|ZSTD_strategy
name|strategy
decl_stmt|;
block|}
name|ZSTD_compressionParameters
typedef|;
typedef|typedef
struct|struct
block|{
name|unsigned
name|contentSizeFlag
decl_stmt|;
comment|/**< 1: content size will be in frame header (when known) */
name|unsigned
name|checksumFlag
decl_stmt|;
comment|/**< 1: generate a 32-bits checksum at end of frame, for error detection */
name|unsigned
name|noDictIDFlag
decl_stmt|;
comment|/**< 1: no dictID will be saved into frame header (if dictionary compression) */
block|}
name|ZSTD_frameParameters
typedef|;
typedef|typedef
struct|struct
block|{
name|ZSTD_compressionParameters
name|cParams
decl_stmt|;
name|ZSTD_frameParameters
name|fParams
decl_stmt|;
block|}
name|ZSTD_parameters
typedef|;
comment|/*= Custom memory allocation functions */
typedef|typedef
name|void
modifier|*
function_decl|(
modifier|*
name|ZSTD_allocFunction
function_decl|)
parameter_list|(
name|void
modifier|*
name|opaque
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
typedef|typedef
name|void
function_decl|(
modifier|*
name|ZSTD_freeFunction
function_decl|)
parameter_list|(
name|void
modifier|*
name|opaque
parameter_list|,
name|void
modifier|*
name|address
parameter_list|)
function_decl|;
typedef|typedef
struct|struct
block|{
name|ZSTD_allocFunction
name|customAlloc
decl_stmt|;
name|ZSTD_freeFunction
name|customFree
decl_stmt|;
name|void
modifier|*
name|opaque
decl_stmt|;
block|}
name|ZSTD_customMem
typedef|;
comment|/*************************************** *  Compressed size functions ***************************************/
comment|/*! ZSTD_findFrameCompressedSize() :  *  `src` should point to the start of a ZSTD encoded frame or skippable frame  *  `srcSize` must be at least as large as the frame  *  @return : the compressed size of the frame pointed to by `src`, suitable to pass to  *      `ZSTD_decompress` or similar, or an error code if given invalid input. */
name|ZSTDLIB_API
name|size_t
name|ZSTD_findFrameCompressedSize
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
comment|/*************************************** *  Decompressed size functions ***************************************/
comment|/*! ZSTD_getFrameContentSize() : *   `src` should point to the start of a ZSTD encoded frame *   `srcSize` must be at least as large as the frame header.  A value greater than or equal *       to `ZSTD_frameHeaderSize_max` is guaranteed to be large enough in all cases. *   @return : decompressed size of the frame pointed to be `src` if known, otherwise *             - ZSTD_CONTENTSIZE_UNKNOWN if the size cannot be determined *             - ZSTD_CONTENTSIZE_ERROR if an error occurred (e.g. invalid magic number, srcSize too small) */
name|ZSTDLIB_API
name|unsigned
name|long
name|long
name|ZSTD_getFrameContentSize
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
comment|/*! ZSTD_findDecompressedSize() : *   `src` should point the start of a series of ZSTD encoded and/or skippable frames *   `srcSize` must be the _exact_ size of this series *       (i.e. there should be a frame boundary exactly `srcSize` bytes after `src`) *   @return : the decompressed size of all data in the contained frames, as a 64-bit value _if known_ *             - if the decompressed size cannot be determined: ZSTD_CONTENTSIZE_UNKNOWN *             - if an error occurred: ZSTD_CONTENTSIZE_ERROR * *    note 1 : decompressed size is an optional field, that may not be present, especially in streaming mode. *             When `return==ZSTD_CONTENTSIZE_UNKNOWN`, data to decompress could be any size. *             In which case, it's necessary to use streaming mode to decompress data. *             Optionally, application can still use ZSTD_decompress() while relying on implied limits. *             (For example, data may be necessarily cut into blocks<= 16 KB). *    note 2 : decompressed size is always present when compression is done with ZSTD_compress() *    note 3 : decompressed size can be very large (64-bits value), *             potentially larger than what local system can handle as a single memory segment. *             In which case, it's necessary to use streaming mode to decompress data. *    note 4 : If source is untrusted, decompressed size could be wrong or intentionally modified. *             Always ensure result fits within application's authorized limits. *             Each application can set its own limits. *    note 5 : ZSTD_findDecompressedSize handles multiple frames, and so it must traverse the input to *             read each contained frame header.  This is efficient as most of the data is skipped, *             however it does mean that all frame data must be present and valid. */
name|ZSTDLIB_API
name|unsigned
name|long
name|long
name|ZSTD_findDecompressedSize
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
comment|/*************************************** *  Advanced compression functions ***************************************/
comment|/*! ZSTD_estimateCCtxSize() :  *  Gives the amount of memory allocated for a ZSTD_CCtx given a set of compression parameters.  *  `frameContentSize` is an optional parameter, provide `0` if unknown */
name|ZSTDLIB_API
name|size_t
name|ZSTD_estimateCCtxSize
parameter_list|(
name|ZSTD_compressionParameters
name|cParams
parameter_list|)
function_decl|;
comment|/*! ZSTD_createCCtx_advanced() :  *  Create a ZSTD compression context using external alloc and free functions */
name|ZSTDLIB_API
name|ZSTD_CCtx
modifier|*
name|ZSTD_createCCtx_advanced
parameter_list|(
name|ZSTD_customMem
name|customMem
parameter_list|)
function_decl|;
comment|/*! ZSTD_sizeofCCtx() :  *  Gives the amount of memory used by a given ZSTD_CCtx */
name|ZSTDLIB_API
name|size_t
name|ZSTD_sizeof_CCtx
parameter_list|(
specifier|const
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|)
function_decl|;
typedef|typedef
enum|enum
block|{
name|ZSTD_p_forceWindow
block|,
comment|/* Force back-references to remain< windowSize, even when referencing Dictionary content (default:0) */
name|ZSTD_p_forceRawDict
comment|/* Force loading dictionary in "content-only" mode (no header analysis) */
block|}
name|ZSTD_CCtxParameter
typedef|;
comment|/*! ZSTD_setCCtxParameter() :  *  Set advanced parameters, selected through enum ZSTD_CCtxParameter  *  @result : 0, or an error code (which can be tested with ZSTD_isError()) */
name|ZSTDLIB_API
name|size_t
name|ZSTD_setCCtxParameter
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|,
name|ZSTD_CCtxParameter
name|param
parameter_list|,
name|unsigned
name|value
parameter_list|)
function_decl|;
comment|/*! ZSTD_createCDict_byReference() :  *  Create a digested dictionary for compression  *  Dictionary content is simply referenced, and therefore stays in dictBuffer.  *  It is important that dictBuffer outlives CDict, it must remain read accessible throughout the lifetime of CDict */
name|ZSTDLIB_API
name|ZSTD_CDict
modifier|*
name|ZSTD_createCDict_byReference
parameter_list|(
specifier|const
name|void
modifier|*
name|dictBuffer
parameter_list|,
name|size_t
name|dictSize
parameter_list|,
name|int
name|compressionLevel
parameter_list|)
function_decl|;
comment|/*! ZSTD_createCDict_advanced() :  *  Create a ZSTD_CDict using external alloc and free, and customized compression parameters */
name|ZSTDLIB_API
name|ZSTD_CDict
modifier|*
name|ZSTD_createCDict_advanced
parameter_list|(
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|,
name|unsigned
name|byReference
parameter_list|,
name|ZSTD_compressionParameters
name|cParams
parameter_list|,
name|ZSTD_customMem
name|customMem
parameter_list|)
function_decl|;
comment|/*! ZSTD_sizeof_CDict() :  *  Gives the amount of memory used by a given ZSTD_sizeof_CDict */
name|ZSTDLIB_API
name|size_t
name|ZSTD_sizeof_CDict
parameter_list|(
specifier|const
name|ZSTD_CDict
modifier|*
name|cdict
parameter_list|)
function_decl|;
comment|/*! ZSTD_getCParams() : *   @return ZSTD_compressionParameters structure for a selected compression level and estimated srcSize. *   `estimatedSrcSize` value is optional, select 0 if not known */
name|ZSTDLIB_API
name|ZSTD_compressionParameters
name|ZSTD_getCParams
parameter_list|(
name|int
name|compressionLevel
parameter_list|,
name|unsigned
name|long
name|long
name|estimatedSrcSize
parameter_list|,
name|size_t
name|dictSize
parameter_list|)
function_decl|;
comment|/*! ZSTD_getParams() : *   same as ZSTD_getCParams(), but @return a full `ZSTD_parameters` object instead of sub-component `ZSTD_compressionParameters`. *   All fields of `ZSTD_frameParameters` are set to default (0) */
name|ZSTDLIB_API
name|ZSTD_parameters
name|ZSTD_getParams
parameter_list|(
name|int
name|compressionLevel
parameter_list|,
name|unsigned
name|long
name|long
name|estimatedSrcSize
parameter_list|,
name|size_t
name|dictSize
parameter_list|)
function_decl|;
comment|/*! ZSTD_checkCParams() : *   Ensure param values remain within authorized range */
name|ZSTDLIB_API
name|size_t
name|ZSTD_checkCParams
parameter_list|(
name|ZSTD_compressionParameters
name|params
parameter_list|)
function_decl|;
comment|/*! ZSTD_adjustCParams() : *   optimize params for a given `srcSize` and `dictSize`. *   both values are optional, select `0` if unknown. */
name|ZSTDLIB_API
name|ZSTD_compressionParameters
name|ZSTD_adjustCParams
parameter_list|(
name|ZSTD_compressionParameters
name|cPar
parameter_list|,
name|unsigned
name|long
name|long
name|srcSize
parameter_list|,
name|size_t
name|dictSize
parameter_list|)
function_decl|;
comment|/*! ZSTD_compress_advanced() : *   Same as ZSTD_compress_usingDict(), with fine-tune control over each compression parameter */
name|ZSTDLIB_API
name|size_t
name|ZSTD_compress_advanced
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|,
name|ZSTD_parameters
name|params
parameter_list|)
function_decl|;
comment|/*! ZSTD_compress_usingCDict_advanced() : *   Same as ZSTD_compress_usingCDict(), with fine-tune control over frame parameters */
name|ZSTDLIB_API
name|size_t
name|ZSTD_compress_usingCDict_advanced
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
specifier|const
name|ZSTD_CDict
modifier|*
name|cdict
parameter_list|,
name|ZSTD_frameParameters
name|fParams
parameter_list|)
function_decl|;
comment|/*--- Advanced decompression functions ---*/
comment|/*! ZSTD_isFrame() :  *  Tells if the content of `buffer` starts with a valid Frame Identifier.  *  Note : Frame Identifier is 4 bytes. If `size< 4`, @return will always be 0.  *  Note 2 : Legacy Frame Identifiers are considered valid only if Legacy Support is enabled.  *  Note 3 : Skippable Frame Identifiers are considered valid. */
name|ZSTDLIB_API
name|unsigned
name|ZSTD_isFrame
parameter_list|(
specifier|const
name|void
modifier|*
name|buffer
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
comment|/*! ZSTD_estimateDCtxSize() :  *  Gives the potential amount of memory allocated to create a ZSTD_DCtx */
name|ZSTDLIB_API
name|size_t
name|ZSTD_estimateDCtxSize
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/*! ZSTD_createDCtx_advanced() :  *  Create a ZSTD decompression context using external alloc and free functions */
name|ZSTDLIB_API
name|ZSTD_DCtx
modifier|*
name|ZSTD_createDCtx_advanced
parameter_list|(
name|ZSTD_customMem
name|customMem
parameter_list|)
function_decl|;
comment|/*! ZSTD_sizeof_DCtx() :  *  Gives the amount of memory used by a given ZSTD_DCtx */
name|ZSTDLIB_API
name|size_t
name|ZSTD_sizeof_DCtx
parameter_list|(
specifier|const
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|)
function_decl|;
comment|/*! ZSTD_createDDict_byReference() :  *  Create a digested dictionary, ready to start decompression operation without startup delay.  *  Dictionary content is simply referenced, and therefore stays in dictBuffer.  *  It is important that dictBuffer outlives DDict, it must remain read accessible throughout the lifetime of DDict */
name|ZSTDLIB_API
name|ZSTD_DDict
modifier|*
name|ZSTD_createDDict_byReference
parameter_list|(
specifier|const
name|void
modifier|*
name|dictBuffer
parameter_list|,
name|size_t
name|dictSize
parameter_list|)
function_decl|;
comment|/*! ZSTD_createDDict_advanced() :  *  Create a ZSTD_DDict using external alloc and free, optionally by reference */
name|ZSTDLIB_API
name|ZSTD_DDict
modifier|*
name|ZSTD_createDDict_advanced
parameter_list|(
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|,
name|unsigned
name|byReference
parameter_list|,
name|ZSTD_customMem
name|customMem
parameter_list|)
function_decl|;
comment|/*! ZSTD_sizeof_DDict() :  *  Gives the amount of memory used by a given ZSTD_DDict */
name|ZSTDLIB_API
name|size_t
name|ZSTD_sizeof_DDict
parameter_list|(
specifier|const
name|ZSTD_DDict
modifier|*
name|ddict
parameter_list|)
function_decl|;
comment|/*! ZSTD_getDictID_fromDict() :  *  Provides the dictID stored within dictionary.  *  if @return == 0, the dictionary is not conformant with Zstandard specification.  *  It can still be loaded, but as a content-only dictionary. */
name|ZSTDLIB_API
name|unsigned
name|ZSTD_getDictID_fromDict
parameter_list|(
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|)
function_decl|;
comment|/*! ZSTD_getDictID_fromDDict() :  *  Provides the dictID of the dictionary loaded into `ddict`.  *  If @return == 0, the dictionary is not conformant to Zstandard specification, or empty.  *  Non-conformant dictionaries can still be loaded, but as content-only dictionaries. */
name|ZSTDLIB_API
name|unsigned
name|ZSTD_getDictID_fromDDict
parameter_list|(
specifier|const
name|ZSTD_DDict
modifier|*
name|ddict
parameter_list|)
function_decl|;
comment|/*! ZSTD_getDictID_fromFrame() :  *  Provides the dictID required to decompressed the frame stored within `src`.  *  If @return == 0, the dictID could not be decoded.  *  This could for one of the following reasons :  *  - The frame does not require a dictionary to be decoded (most common case).  *  - The frame was built with dictID intentionally removed. Whatever dictionary is necessary is a hidden information.  *    Note : this use case also happens when using a non-conformant dictionary.  *  - `srcSize` is too small, and as a result, the frame header could not be decoded (only possible if `srcSize< ZSTD_FRAMEHEADERSIZE_MAX`).  *  - This is not a Zstandard frame.  *  When identifying the exact failure cause, it's possible to use ZSTD_getFrameParams(), which will provide a more precise error code. */
name|ZSTDLIB_API
name|unsigned
name|ZSTD_getDictID_fromFrame
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
comment|/******************************************************************** *  Advanced streaming functions ********************************************************************/
comment|/*=====   Advanced Streaming compression functions  =====*/
name|ZSTDLIB_API
name|ZSTD_CStream
modifier|*
name|ZSTD_createCStream_advanced
parameter_list|(
name|ZSTD_customMem
name|customMem
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_sizeof_CStream
parameter_list|(
specifier|const
name|ZSTD_CStream
modifier|*
name|zcs
parameter_list|)
function_decl|;
comment|/**< size of CStream is variable, depending primarily on compression level */
name|ZSTDLIB_API
name|size_t
name|ZSTD_initCStream_srcSize
parameter_list|(
name|ZSTD_CStream
modifier|*
name|zcs
parameter_list|,
name|int
name|compressionLevel
parameter_list|,
name|unsigned
name|long
name|long
name|pledgedSrcSize
parameter_list|)
function_decl|;
comment|/**< pledgedSrcSize must be correct, a size of 0 means unknown.  for a frame size of 0 use initCStream_advanced */
name|ZSTDLIB_API
name|size_t
name|ZSTD_initCStream_usingDict
parameter_list|(
name|ZSTD_CStream
modifier|*
name|zcs
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|,
name|int
name|compressionLevel
parameter_list|)
function_decl|;
comment|/**< note: a dict will not be used if dict == NULL or dictSize< 8 */
name|ZSTDLIB_API
name|size_t
name|ZSTD_initCStream_advanced
parameter_list|(
name|ZSTD_CStream
modifier|*
name|zcs
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|,
name|ZSTD_parameters
name|params
parameter_list|,
name|unsigned
name|long
name|long
name|pledgedSrcSize
parameter_list|)
function_decl|;
comment|/**< pledgedSrcSize is optional and can be 0 (meaning unknown). note: if the contentSizeFlag is set, pledgedSrcSize == 0 means the source size is actually 0 */
name|ZSTDLIB_API
name|size_t
name|ZSTD_initCStream_usingCDict
parameter_list|(
name|ZSTD_CStream
modifier|*
name|zcs
parameter_list|,
specifier|const
name|ZSTD_CDict
modifier|*
name|cdict
parameter_list|)
function_decl|;
comment|/**< note : cdict will just be referenced, and must outlive compression session */
name|ZSTDLIB_API
name|size_t
name|ZSTD_initCStream_usingCDict_advanced
parameter_list|(
name|ZSTD_CStream
modifier|*
name|zcs
parameter_list|,
specifier|const
name|ZSTD_CDict
modifier|*
name|cdict
parameter_list|,
name|unsigned
name|long
name|long
name|pledgedSrcSize
parameter_list|,
name|ZSTD_frameParameters
name|fParams
parameter_list|)
function_decl|;
comment|/**< same as ZSTD_initCStream_usingCDict(), with control over frame parameters */
comment|/*! ZSTD_resetCStream() :  *  start a new compression job, using same parameters from previous job.  *  This is typically useful to skip dictionary loading stage, since it will re-use it in-place..  *  Note that zcs must be init at least once before using ZSTD_resetCStream().  *  pledgedSrcSize==0 means "srcSize unknown".  *  If pledgedSrcSize> 0, its value must be correct, as it will be written in header, and controlled at the end.  *  @return : 0, or an error code (which can be tested using ZSTD_isError()) */
name|ZSTDLIB_API
name|size_t
name|ZSTD_resetCStream
parameter_list|(
name|ZSTD_CStream
modifier|*
name|zcs
parameter_list|,
name|unsigned
name|long
name|long
name|pledgedSrcSize
parameter_list|)
function_decl|;
comment|/*=====   Advanced Streaming decompression functions  =====*/
typedef|typedef
enum|enum
block|{
name|DStream_p_maxWindowSize
block|}
name|ZSTD_DStreamParameter_e
typedef|;
name|ZSTDLIB_API
name|ZSTD_DStream
modifier|*
name|ZSTD_createDStream_advanced
parameter_list|(
name|ZSTD_customMem
name|customMem
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_initDStream_usingDict
parameter_list|(
name|ZSTD_DStream
modifier|*
name|zds
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|)
function_decl|;
comment|/**< note: a dict will not be used if dict == NULL or dictSize< 8 */
name|ZSTDLIB_API
name|size_t
name|ZSTD_setDStreamParameter
parameter_list|(
name|ZSTD_DStream
modifier|*
name|zds
parameter_list|,
name|ZSTD_DStreamParameter_e
name|paramType
parameter_list|,
name|unsigned
name|paramValue
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_initDStream_usingDDict
parameter_list|(
name|ZSTD_DStream
modifier|*
name|zds
parameter_list|,
specifier|const
name|ZSTD_DDict
modifier|*
name|ddict
parameter_list|)
function_decl|;
comment|/**< note : ddict will just be referenced, and must outlive decompression session */
name|ZSTDLIB_API
name|size_t
name|ZSTD_resetDStream
parameter_list|(
name|ZSTD_DStream
modifier|*
name|zds
parameter_list|)
function_decl|;
comment|/**< re-use decompression parameters from previous init; saves dictionary loading */
name|ZSTDLIB_API
name|size_t
name|ZSTD_sizeof_DStream
parameter_list|(
specifier|const
name|ZSTD_DStream
modifier|*
name|zds
parameter_list|)
function_decl|;
comment|/********************************************************************* *  Buffer-less and synchronous inner streaming functions * *  This is an advanced API, giving full control over buffer management, for users which need direct control over memory. *  But it's also a complex one, with many restrictions (documented below). *  Prefer using normal streaming API for an easier experience ********************************************************************* */
comment|/**   Buffer-less streaming compression (synchronous mode)    A ZSTD_CCtx object is required to track streaming operations.   Use ZSTD_createCCtx() / ZSTD_freeCCtx() to manage resource.   ZSTD_CCtx object can be re-used multiple times within successive compression operations.    Start by initializing a context.   Use ZSTD_compressBegin(), or ZSTD_compressBegin_usingDict() for dictionary compression,   or ZSTD_compressBegin_advanced(), for finer parameter control.   It's also possible to duplicate a reference context which has already been initialized, using ZSTD_copyCCtx()    Then, consume your input using ZSTD_compressContinue().   There are some important considerations to keep in mind when using this advanced function :   - ZSTD_compressContinue() has no internal buffer. It uses externally provided buffer only.   - Interface is synchronous : input is consumed entirely and produce 1+ (or more) compressed blocks.   - Caller must ensure there is enough space in `dst` to store compressed data under worst case scenario.     Worst case evaluation is provided by ZSTD_compressBound().     ZSTD_compressContinue() doesn't guarantee recover after a failed compression.   - ZSTD_compressContinue() presumes prior input ***is still accessible and unmodified*** (up to maximum distance size, see WindowLog).     It remembers all previous contiguous blocks, plus one separated memory segment (which can itself consists of multiple contiguous blocks)   - ZSTD_compressContinue() detects that prior input has been overwritten when `src` buffer overlaps.     In which case, it will "discard" the relevant memory section from its history.    Finish a frame with ZSTD_compressEnd(), which will write the last block(s) and optional checksum.   It's possible to use srcSize==0, in which case, it will write a final empty block to end the frame.   Without last block mark, frames will be considered unfinished (corrupted) by decoders.    `ZSTD_CCtx` object can be re-used (ZSTD_compressBegin()) to compress some new frame. */
comment|/*=====   Buffer-less streaming compression functions  =====*/
name|ZSTDLIB_API
name|size_t
name|ZSTD_compressBegin
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|,
name|int
name|compressionLevel
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_compressBegin_usingDict
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|,
name|int
name|compressionLevel
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_compressBegin_advanced
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|,
name|ZSTD_parameters
name|params
parameter_list|,
name|unsigned
name|long
name|long
name|pledgedSrcSize
parameter_list|)
function_decl|;
comment|/**< pledgedSrcSize is optional and can be 0 (meaning unknown). note: if the contentSizeFlag is set, pledgedSrcSize == 0 means the source size is actually 0 */
name|ZSTDLIB_API
name|size_t
name|ZSTD_compressBegin_usingCDict
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|,
specifier|const
name|ZSTD_CDict
modifier|*
name|cdict
parameter_list|)
function_decl|;
comment|/**< note: fails if cdict==NULL */
name|ZSTDLIB_API
name|size_t
name|ZSTD_compressBegin_usingCDict_advanced
parameter_list|(
name|ZSTD_CCtx
modifier|*
specifier|const
name|cctx
parameter_list|,
specifier|const
name|ZSTD_CDict
modifier|*
specifier|const
name|cdict
parameter_list|,
name|ZSTD_frameParameters
specifier|const
name|fParams
parameter_list|,
name|unsigned
name|long
name|long
specifier|const
name|pledgedSrcSize
parameter_list|)
function_decl|;
comment|/* compression parameters are already set within cdict. pledgedSrcSize=0 means null-size */
name|ZSTDLIB_API
name|size_t
name|ZSTD_copyCCtx
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|,
specifier|const
name|ZSTD_CCtx
modifier|*
name|preparedCCtx
parameter_list|,
name|unsigned
name|long
name|long
name|pledgedSrcSize
parameter_list|)
function_decl|;
comment|/**<  note: if pledgedSrcSize can be 0, indicating unknown size.  if it is non-zero, it must be accurate.  for 0 size frames, use compressBegin_advanced */
name|ZSTDLIB_API
name|size_t
name|ZSTD_compressContinue
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_compressEnd
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
comment|/*-   Buffer-less streaming decompression (synchronous mode)    A ZSTD_DCtx object is required to track streaming operations.   Use ZSTD_createDCtx() / ZSTD_freeDCtx() to manage it.   A ZSTD_DCtx object can be re-used multiple times.    First typical operation is to retrieve frame parameters, using ZSTD_getFrameParams().   It fills a ZSTD_frameParams structure which provide important information to correctly decode the frame,   such as the minimum rolling buffer size to allocate to decompress data (`windowSize`),   and the dictionary ID used.   (Note : content size is optional, it may not be present. 0 means : content size unknown).   Note that these values could be wrong, either because of data malformation, or because an attacker is spoofing deliberate false information.   As a consequence, check that values remain within valid application range, especially `windowSize`, before allocation.   Each application can set its own limit, depending on local restrictions. For extended interoperability, it is recommended to support at least 8 MB.   Frame parameters are extracted from the beginning of the compressed frame.   Data fragment must be large enough to ensure successful decoding, typically `ZSTD_frameHeaderSize_max` bytes.   @result : 0 : successful decoding, the `ZSTD_frameParams` structure is correctly filled.>0 : `srcSize` is too small, please provide at least @result bytes on next attempt.            errorCode, which can be tested using ZSTD_isError().    Start decompression, with ZSTD_decompressBegin() or ZSTD_decompressBegin_usingDict().   Alternatively, you can copy a prepared context, using ZSTD_copyDCtx().    Then use ZSTD_nextSrcSizeToDecompress() and ZSTD_decompressContinue() alternatively.   ZSTD_nextSrcSizeToDecompress() tells how many bytes to provide as 'srcSize' to ZSTD_decompressContinue().   ZSTD_decompressContinue() requires this _exact_ amount of bytes, or it will fail.    @result of ZSTD_decompressContinue() is the number of bytes regenerated within 'dst' (necessarily<= dstCapacity).   It can be zero, which is not an error; it just means ZSTD_decompressContinue() has decoded some metadata item.   It can also be an error code, which can be tested with ZSTD_isError().    ZSTD_decompressContinue() needs previous data blocks during decompression, up to `windowSize`.   They should preferably be located contiguously, prior to current block.   Alternatively, a round buffer of sufficient size is also possible. Sufficient size is determined by frame parameters.   ZSTD_decompressContinue() is very sensitive to contiguity,   if 2 blocks don't follow each other, make sure that either the compressor breaks contiguity at the same place,   or that previous contiguous segment is large enough to properly handle maximum back-reference.    A frame is fully decoded when ZSTD_nextSrcSizeToDecompress() returns zero.   Context can then be reset to start a new decompression.    Note : it's possible to know if next input to present is a header or a block, using ZSTD_nextInputType().   This information is not required to properly decode a frame.    == Special case : skippable frames ==    Skippable frames allow integration of user-defined data into a flow of concatenated frames.   Skippable frames will be ignored (skipped) by a decompressor. The format of skippable frames is as follows :   a) Skippable frame ID - 4 Bytes, Little endian format, any value from 0x184D2A50 to 0x184D2A5F   b) Frame Size - 4 Bytes, Little endian format, unsigned 32-bits   c) Frame Content - any content (User Data) of length equal to Frame Size   For skippable frames ZSTD_decompressContinue() always returns 0.   For skippable frames ZSTD_getFrameParams() returns fparamsPtr->windowLog==0 what means that a frame is skippable.     Note : If fparamsPtr->frameContentSize==0, it is ambiguous: the frame might actually be a Zstd encoded frame with no content.            For purposes of decompression, it is valid in both cases to skip the frame using            ZSTD_findFrameCompressedSize to find its size in bytes.   It also returns Frame Size as fparamsPtr->frameContentSize. */
typedef|typedef
struct|struct
block|{
name|unsigned
name|long
name|long
name|frameContentSize
decl_stmt|;
name|unsigned
name|windowSize
decl_stmt|;
name|unsigned
name|dictID
decl_stmt|;
name|unsigned
name|checksumFlag
decl_stmt|;
block|}
name|ZSTD_frameParams
typedef|;
comment|/*=====   Buffer-less streaming decompression functions  =====*/
name|ZSTDLIB_API
name|size_t
name|ZSTD_getFrameParams
parameter_list|(
name|ZSTD_frameParams
modifier|*
name|fparamsPtr
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
comment|/**< doesn't consume input, see details below */
name|ZSTDLIB_API
name|size_t
name|ZSTD_decompressBegin
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_decompressBegin_usingDict
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|void
name|ZSTD_copyDCtx
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
specifier|const
name|ZSTD_DCtx
modifier|*
name|preparedDCtx
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_nextSrcSizeToDecompress
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_decompressContinue
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
typedef|typedef
enum|enum
block|{
name|ZSTDnit_frameHeader
block|,
name|ZSTDnit_blockHeader
block|,
name|ZSTDnit_block
block|,
name|ZSTDnit_lastBlock
block|,
name|ZSTDnit_checksum
block|,
name|ZSTDnit_skippableFrame
block|}
name|ZSTD_nextInputType_e
typedef|;
name|ZSTDLIB_API
name|ZSTD_nextInputType_e
name|ZSTD_nextInputType
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|)
function_decl|;
comment|/**     Block functions      Block functions produce and decode raw zstd blocks, without frame metadata.     Frame metadata cost is typically ~18 bytes, which can be non-negligible for very small blocks (< 100 bytes).     User will have to take in charge required information to regenerate data, such as compressed and content sizes.      A few rules to respect :     - Compressing and decompressing require a context structure       + Use ZSTD_createCCtx() and ZSTD_createDCtx()     - It is necessary to init context before starting       + compression : any ZSTD_compressBegin*() variant, including with dictionary       + decompression : any ZSTD_decompressBegin*() variant, including with dictionary       + copyCCtx() and copyDCtx() can be used too     - Block size is limited, it must be<= ZSTD_getBlockSizeMax()<= ZSTD_BLOCKSIZE_ABSOLUTEMAX       + If input is larger than a block size, it's necessary to split input data into multiple blocks       + For inputs larger than a single block size, consider using the regular ZSTD_compress() instead.         Frame metadata is not that costly, and quickly becomes negligible as source size grows larger.     - When a block is considered not compressible enough, ZSTD_compressBlock() result will be zero.       In which case, nothing is produced into `dst`.       + User must test for such outcome and deal directly with uncompressed data       + ZSTD_decompressBlock() doesn't accept uncompressed data as input !!!       + In case of multiple successive blocks, should some of them be uncompressed,         decoder must be informed of their existence in order to follow proper history.         Use ZSTD_insertBlock() for such a case. */
define|#
directive|define
name|ZSTD_BLOCKSIZE_ABSOLUTEMAX
value|(128 * 1024)
comment|/* define, for static allocation */
comment|/*=====   Raw zstd block functions  =====*/
name|ZSTDLIB_API
name|size_t
name|ZSTD_getBlockSizeMax
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_compressBlock
parameter_list|(
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_decompressBlock
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
function_decl|;
name|ZSTDLIB_API
name|size_t
name|ZSTD_insertBlock
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
specifier|const
name|void
modifier|*
name|blockStart
parameter_list|,
name|size_t
name|blockSize
parameter_list|)
function_decl|;
comment|/**< insert block into `dctx` history. Useful for uncompressed blocks */
endif|#
directive|endif
comment|/* ZSTD_H_ZSTD_STATIC_LINKING_ONLY */
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

end_unit

