begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright (c) 2016-present, Yann Collet, Facebook, Inc.  * All rights reserved.  *  * This source code is licensed under the BSD-style license found in the  * LICENSE file in the root directory of this source tree. An additional grant  * of patent rights can be found in the PATENTS file in the same directory.  */
end_comment

begin_comment
comment|/* *************************************************************** *  Tuning parameters *****************************************************************/
end_comment

begin_comment
comment|/*!  * HEAPMODE :  * Select how default decompression function ZSTD_decompress() will allocate memory,  * in memory stack (0), or in memory heap (1, requires malloc())  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ZSTD_HEAPMODE
end_ifndef

begin_define
define|#
directive|define
name|ZSTD_HEAPMODE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*! *  LEGACY_SUPPORT : *  if set to 1, ZSTD_decompress() can decode older formats (v0.1+) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ZSTD_LEGACY_SUPPORT
end_ifndef

begin_define
define|#
directive|define
name|ZSTD_LEGACY_SUPPORT
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*! *  MAXWINDOWSIZE_DEFAULT : *  maximum window size accepted by DStream, by default. *  Frames requiring more memory will be rejected. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ZSTD_MAXWINDOWSIZE_DEFAULT
end_ifndef

begin_define
define|#
directive|define
name|ZSTD_MAXWINDOWSIZE_DEFAULT
value|((1<< ZSTD_WINDOWLOG_MAX) + 1)
end_define

begin_comment
comment|/* defined within zstd.h */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*-******************************************************* *  Dependencies *********************************************************/
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* memcpy, memmove, memset */
end_comment

begin_include
include|#
directive|include
file|"mem.h"
end_include

begin_comment
comment|/* low level memory routines */
end_comment

begin_define
define|#
directive|define
name|FSE_STATIC_LINKING_ONLY
end_define

begin_include
include|#
directive|include
file|"fse.h"
end_include

begin_define
define|#
directive|define
name|HUF_STATIC_LINKING_ONLY
end_define

begin_include
include|#
directive|include
file|"huf.h"
end_include

begin_include
include|#
directive|include
file|"zstd_internal.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|ZSTD_LEGACY_SUPPORT
argument_list|)
operator|&&
operator|(
name|ZSTD_LEGACY_SUPPORT
operator|>=
literal|1
operator|)
end_if

begin_include
include|#
directive|include
file|"zstd_legacy.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_if

begin_include
include|#
directive|include
file|<mmintrin.h>
end_include

begin_comment
comment|/* https://msdn.microsoft.com/fr-fr/library/84szxsww(v=vs.90).aspx */
end_comment

begin_define
define|#
directive|define
name|ZSTD_PREFETCH
parameter_list|(
name|ptr
parameter_list|)
value|_mm_prefetch((const char*)ptr, _MM_HINT_T0)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__GNUC__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|ZSTD_PREFETCH
parameter_list|(
name|ptr
parameter_list|)
value|__builtin_prefetch(ptr, 0, 0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ZSTD_PREFETCH
parameter_list|(
name|ptr
parameter_list|)
end_define

begin_comment
comment|/* disabled */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*-************************************* *  Macros ***************************************/
end_comment

begin_define
define|#
directive|define
name|ZSTD_isError
value|ERR_isError
end_define

begin_comment
comment|/* for inlining */
end_comment

begin_define
define|#
directive|define
name|FSE_isError
value|ERR_isError
end_define

begin_define
define|#
directive|define
name|HUF_isError
value|ERR_isError
end_define

begin_comment
comment|/*_******************************************************* *  Memory operations **********************************************************/
end_comment

begin_function
specifier|static
name|void
name|ZSTD_copy4
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|)
block|{
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-************************************************************* *   Context management ***************************************************************/
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|ZSTDds_getFrameHeaderSize
block|,
name|ZSTDds_decodeFrameHeader
block|,
name|ZSTDds_decodeBlockHeader
block|,
name|ZSTDds_decompressBlock
block|,
name|ZSTDds_decompressLastBlock
block|,
name|ZSTDds_checkChecksum
block|,
name|ZSTDds_decodeSkippableHeader
block|,
name|ZSTDds_skipFrame
block|}
name|ZSTD_dStage
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|FSE_DTable
name|LLTable
index|[
name|FSE_DTABLE_SIZE_U32
argument_list|(
name|LLFSELog
argument_list|)
index|]
decl_stmt|;
name|FSE_DTable
name|OFTable
index|[
name|FSE_DTABLE_SIZE_U32
argument_list|(
name|OffFSELog
argument_list|)
index|]
decl_stmt|;
name|FSE_DTable
name|MLTable
index|[
name|FSE_DTABLE_SIZE_U32
argument_list|(
name|MLFSELog
argument_list|)
index|]
decl_stmt|;
name|HUF_DTable
name|hufTable
index|[
name|HUF_DTABLE_SIZE
argument_list|(
name|HufLog
argument_list|)
index|]
decl_stmt|;
comment|/* can accommodate HUF_decompress4X */
name|U32
name|rep
index|[
name|ZSTD_REP_NUM
index|]
decl_stmt|;
block|}
name|ZSTD_entropyTables_t
typedef|;
end_typedef

begin_struct
struct|struct
name|ZSTD_DCtx_s
block|{
specifier|const
name|FSE_DTable
modifier|*
name|LLTptr
decl_stmt|;
specifier|const
name|FSE_DTable
modifier|*
name|MLTptr
decl_stmt|;
specifier|const
name|FSE_DTable
modifier|*
name|OFTptr
decl_stmt|;
specifier|const
name|HUF_DTable
modifier|*
name|HUFptr
decl_stmt|;
name|ZSTD_entropyTables_t
name|entropy
decl_stmt|;
specifier|const
name|void
modifier|*
name|previousDstEnd
decl_stmt|;
comment|/* detect continuity */
specifier|const
name|void
modifier|*
name|base
decl_stmt|;
comment|/* start of current segment */
specifier|const
name|void
modifier|*
name|vBase
decl_stmt|;
comment|/* virtual start of previous segment if it was just before current one */
specifier|const
name|void
modifier|*
name|dictEnd
decl_stmt|;
comment|/* end of previous segment */
name|size_t
name|expected
decl_stmt|;
name|ZSTD_frameParams
name|fParams
decl_stmt|;
name|blockType_e
name|bType
decl_stmt|;
comment|/* used in ZSTD_decompressContinue(), to transfer blockType between header decoding and block decoding stages */
name|ZSTD_dStage
name|stage
decl_stmt|;
name|U32
name|litEntropy
decl_stmt|;
name|U32
name|fseEntropy
decl_stmt|;
name|XXH64_state_t
name|xxhState
decl_stmt|;
name|size_t
name|headerSize
decl_stmt|;
name|U32
name|dictID
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|litPtr
decl_stmt|;
name|ZSTD_customMem
name|customMem
decl_stmt|;
name|size_t
name|litSize
decl_stmt|;
name|size_t
name|rleSize
decl_stmt|;
name|BYTE
name|litBuffer
index|[
name|ZSTD_BLOCKSIZE_ABSOLUTEMAX
operator|+
name|WILDCOPY_OVERLENGTH
index|]
decl_stmt|;
name|BYTE
name|headerBuffer
index|[
name|ZSTD_FRAMEHEADERSIZE_MAX
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* typedef'd to ZSTD_DCtx within "zstd.h" */
end_comment

begin_function
name|size_t
name|ZSTD_sizeof_DCtx
parameter_list|(
specifier|const
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|)
block|{
return|return
operator|(
name|dctx
operator|==
name|NULL
operator|)
condition|?
literal|0
else|:
sizeof|sizeof
argument_list|(
name|ZSTD_DCtx
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTD_estimateDCtxSize
parameter_list|(
name|void
parameter_list|)
block|{
return|return
sizeof|sizeof
argument_list|(
name|ZSTD_DCtx
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTD_decompressBegin
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|)
block|{
name|dctx
operator|->
name|expected
operator|=
name|ZSTD_frameHeaderSize_prefix
expr_stmt|;
name|dctx
operator|->
name|stage
operator|=
name|ZSTDds_getFrameHeaderSize
expr_stmt|;
name|dctx
operator|->
name|previousDstEnd
operator|=
name|NULL
expr_stmt|;
name|dctx
operator|->
name|base
operator|=
name|NULL
expr_stmt|;
name|dctx
operator|->
name|vBase
operator|=
name|NULL
expr_stmt|;
name|dctx
operator|->
name|dictEnd
operator|=
name|NULL
expr_stmt|;
name|dctx
operator|->
name|entropy
operator|.
name|hufTable
index|[
literal|0
index|]
operator|=
call|(
name|HUF_DTable
call|)
argument_list|(
operator|(
name|HufLog
operator|)
operator|*
literal|0x1000001
argument_list|)
expr_stmt|;
comment|/* cover both little and big endian */
name|dctx
operator|->
name|litEntropy
operator|=
name|dctx
operator|->
name|fseEntropy
operator|=
literal|0
expr_stmt|;
name|dctx
operator|->
name|dictID
operator|=
literal|0
expr_stmt|;
name|MEM_STATIC_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|dctx
operator|->
name|entropy
operator|.
name|rep
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|repStartValue
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dctx
operator|->
name|entropy
operator|.
name|rep
argument_list|,
name|repStartValue
argument_list|,
sizeof|sizeof
argument_list|(
name|repStartValue
argument_list|)
argument_list|)
expr_stmt|;
comment|/* initial repcodes */
name|dctx
operator|->
name|LLTptr
operator|=
name|dctx
operator|->
name|entropy
operator|.
name|LLTable
expr_stmt|;
name|dctx
operator|->
name|MLTptr
operator|=
name|dctx
operator|->
name|entropy
operator|.
name|MLTable
expr_stmt|;
name|dctx
operator|->
name|OFTptr
operator|=
name|dctx
operator|->
name|entropy
operator|.
name|OFTable
expr_stmt|;
name|dctx
operator|->
name|HUFptr
operator|=
name|dctx
operator|->
name|entropy
operator|.
name|hufTable
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|ZSTD_DCtx
modifier|*
name|ZSTD_createDCtx_advanced
parameter_list|(
name|ZSTD_customMem
name|customMem
parameter_list|)
block|{
name|ZSTD_DCtx
modifier|*
name|dctx
decl_stmt|;
if|if
condition|(
operator|!
name|customMem
operator|.
name|customAlloc
operator|&&
operator|!
name|customMem
operator|.
name|customFree
condition|)
name|customMem
operator|=
name|defaultCustomMem
expr_stmt|;
if|if
condition|(
operator|!
name|customMem
operator|.
name|customAlloc
operator|||
operator|!
name|customMem
operator|.
name|customFree
condition|)
return|return
name|NULL
return|;
name|dctx
operator|=
operator|(
name|ZSTD_DCtx
operator|*
operator|)
name|ZSTD_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ZSTD_DCtx
argument_list|)
argument_list|,
name|customMem
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dctx
condition|)
return|return
name|NULL
return|;
name|memcpy
argument_list|(
operator|&
name|dctx
operator|->
name|customMem
argument_list|,
operator|&
name|customMem
argument_list|,
sizeof|sizeof
argument_list|(
name|customMem
argument_list|)
argument_list|)
expr_stmt|;
name|ZSTD_decompressBegin
argument_list|(
name|dctx
argument_list|)
expr_stmt|;
return|return
name|dctx
return|;
block|}
end_function

begin_function
name|ZSTD_DCtx
modifier|*
name|ZSTD_createDCtx
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|ZSTD_createDCtx_advanced
argument_list|(
name|defaultCustomMem
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTD_freeDCtx
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|)
block|{
if|if
condition|(
name|dctx
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* support free on NULL */
name|ZSTD_free
argument_list|(
name|dctx
argument_list|,
name|dctx
operator|->
name|customMem
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* reserved as a potential error code in the future */
block|}
end_function

begin_function
name|void
name|ZSTD_copyDCtx
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dstDCtx
parameter_list|,
specifier|const
name|ZSTD_DCtx
modifier|*
name|srcDCtx
parameter_list|)
block|{
name|size_t
specifier|const
name|workSpaceSize
init|=
operator|(
name|ZSTD_BLOCKSIZE_ABSOLUTEMAX
operator|+
name|WILDCOPY_OVERLENGTH
operator|)
operator|+
name|ZSTD_frameHeaderSize_max
decl_stmt|;
name|memcpy
argument_list|(
name|dstDCtx
argument_list|,
name|srcDCtx
argument_list|,
sizeof|sizeof
argument_list|(
name|ZSTD_DCtx
argument_list|)
operator|-
name|workSpaceSize
argument_list|)
expr_stmt|;
comment|/* no need to copy workspace */
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* deprecated */
end_comment

begin_comment
unit|static void ZSTD_refDCtx(ZSTD_DCtx* dstDCtx, const ZSTD_DCtx* srcDCtx) {     ZSTD_decompressBegin(dstDCtx);
comment|/* init */
end_comment

begin_comment
unit|if (srcDCtx) {
comment|/* support refDCtx on NULL */
end_comment

begin_endif
unit|dstDCtx->dictEnd = srcDCtx->dictEnd;         dstDCtx->vBase = srcDCtx->vBase;         dstDCtx->base = srcDCtx->base;         dstDCtx->previousDstEnd = srcDCtx->previousDstEnd;         dstDCtx->dictID = srcDCtx->dictID;         dstDCtx->litEntropy = srcDCtx->litEntropy;         dstDCtx->fseEntropy = srcDCtx->fseEntropy;         dstDCtx->LLTptr = srcDCtx->entropy.LLTable;         dstDCtx->MLTptr = srcDCtx->entropy.MLTable;         dstDCtx->OFTptr = srcDCtx->entropy.OFTable;         dstDCtx->HUFptr = srcDCtx->entropy.hufTable;         dstDCtx->entropy.rep[0] = srcDCtx->entropy.rep[0];         dstDCtx->entropy.rep[1] = srcDCtx->entropy.rep[1];         dstDCtx->entropy.rep[2] = srcDCtx->entropy.rep[2];     } }
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|ZSTD_refDDict
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dstDCtx
parameter_list|,
specifier|const
name|ZSTD_DDict
modifier|*
name|ddict
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*-************************************************************* *   Decompression section ***************************************************************/
end_comment

begin_comment
comment|/*! ZSTD_isFrame() :  *  Tells if the content of `buffer` starts with a valid Frame Identifier.  *  Note : Frame Identifier is 4 bytes. If `size< 4`, @return will always be 0.  *  Note 2 : Legacy Frame Identifiers are considered valid only if Legacy Support is enabled.  *  Note 3 : Skippable Frame Identifiers are considered valid. */
end_comment

begin_function
name|unsigned
name|ZSTD_isFrame
parameter_list|(
specifier|const
name|void
modifier|*
name|buffer
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
if|if
condition|(
name|size
operator|<
literal|4
condition|)
return|return
literal|0
return|;
block|{
name|U32
specifier|const
name|magic
init|=
name|MEM_readLE32
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|magic
operator|==
name|ZSTD_MAGICNUMBER
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|magic
operator|&
literal|0xFFFFFFF0U
operator|)
operator|==
name|ZSTD_MAGIC_SKIPPABLE_START
condition|)
return|return
literal|1
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|ZSTD_LEGACY_SUPPORT
argument_list|)
operator|&&
operator|(
name|ZSTD_LEGACY_SUPPORT
operator|>=
literal|1
operator|)
if|if
condition|(
name|ZSTD_isLegacy
argument_list|(
name|buffer
argument_list|,
name|size
argument_list|)
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** ZSTD_frameHeaderSize() : *   srcSize must be>= ZSTD_frameHeaderSize_prefix. *   @return : size of the Frame Header */
end_comment

begin_function
specifier|static
name|size_t
name|ZSTD_frameHeaderSize
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
if|if
condition|(
name|srcSize
operator|<
name|ZSTD_frameHeaderSize_prefix
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
block|{
name|BYTE
specifier|const
name|fhd
init|=
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
operator|)
index|[
literal|4
index|]
decl_stmt|;
name|U32
specifier|const
name|dictID
init|=
name|fhd
operator|&
literal|3
decl_stmt|;
name|U32
specifier|const
name|singleSegment
init|=
operator|(
name|fhd
operator|>>
literal|5
operator|)
operator|&
literal|1
decl_stmt|;
name|U32
specifier|const
name|fcsId
init|=
name|fhd
operator|>>
literal|6
decl_stmt|;
return|return
name|ZSTD_frameHeaderSize_prefix
operator|+
operator|!
name|singleSegment
operator|+
name|ZSTD_did_fieldSize
index|[
name|dictID
index|]
operator|+
name|ZSTD_fcs_fieldSize
index|[
name|fcsId
index|]
operator|+
operator|(
name|singleSegment
operator|&&
operator|!
name|fcsId
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/** ZSTD_getFrameParams() : *   decode Frame Header, or require larger `srcSize`. *   @return : 0, `fparamsPtr` is correctly filled, *>0, `srcSize` is too small, result is expected `srcSize`, *             or an error code, which can be tested using ZSTD_isError() */
end_comment

begin_function
name|size_t
name|ZSTD_getFrameParams
parameter_list|(
name|ZSTD_frameParams
modifier|*
name|fparamsPtr
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
decl_stmt|;
if|if
condition|(
name|srcSize
operator|<
name|ZSTD_frameHeaderSize_prefix
condition|)
return|return
name|ZSTD_frameHeaderSize_prefix
return|;
if|if
condition|(
name|MEM_readLE32
argument_list|(
name|src
argument_list|)
operator|!=
name|ZSTD_MAGICNUMBER
condition|)
block|{
if|if
condition|(
operator|(
name|MEM_readLE32
argument_list|(
name|src
argument_list|)
operator|&
literal|0xFFFFFFF0U
operator|)
operator|==
name|ZSTD_MAGIC_SKIPPABLE_START
condition|)
block|{
if|if
condition|(
name|srcSize
operator|<
name|ZSTD_skippableHeaderSize
condition|)
return|return
name|ZSTD_skippableHeaderSize
return|;
comment|/* magic number + skippable frame length */
name|memset
argument_list|(
name|fparamsPtr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fparamsPtr
argument_list|)
argument_list|)
expr_stmt|;
name|fparamsPtr
operator|->
name|frameContentSize
operator|=
name|MEM_readLE32
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|src
operator|+
literal|4
argument_list|)
expr_stmt|;
name|fparamsPtr
operator|->
name|windowSize
operator|=
literal|0
expr_stmt|;
comment|/* windowSize==0 means a frame is skippable */
return|return
literal|0
return|;
block|}
return|return
name|ERROR
argument_list|(
name|prefix_unknown
argument_list|)
return|;
block|}
comment|/* ensure there is enough `srcSize` to fully read/decode frame header */
block|{
name|size_t
specifier|const
name|fhsize
init|=
name|ZSTD_frameHeaderSize
argument_list|(
name|src
argument_list|,
name|srcSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|srcSize
operator|<
name|fhsize
condition|)
return|return
name|fhsize
return|;
block|}
block|{
name|BYTE
specifier|const
name|fhdByte
init|=
name|ip
index|[
literal|4
index|]
decl_stmt|;
name|size_t
name|pos
init|=
literal|5
decl_stmt|;
name|U32
specifier|const
name|dictIDSizeCode
init|=
name|fhdByte
operator|&
literal|3
decl_stmt|;
name|U32
specifier|const
name|checksumFlag
init|=
operator|(
name|fhdByte
operator|>>
literal|2
operator|)
operator|&
literal|1
decl_stmt|;
name|U32
specifier|const
name|singleSegment
init|=
operator|(
name|fhdByte
operator|>>
literal|5
operator|)
operator|&
literal|1
decl_stmt|;
name|U32
specifier|const
name|fcsID
init|=
name|fhdByte
operator|>>
literal|6
decl_stmt|;
name|U32
specifier|const
name|windowSizeMax
init|=
literal|1U
operator|<<
name|ZSTD_WINDOWLOG_MAX
decl_stmt|;
name|U32
name|windowSize
init|=
literal|0
decl_stmt|;
name|U32
name|dictID
init|=
literal|0
decl_stmt|;
name|U64
name|frameContentSize
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|fhdByte
operator|&
literal|0x08
operator|)
operator|!=
literal|0
condition|)
return|return
name|ERROR
argument_list|(
name|frameParameter_unsupported
argument_list|)
return|;
comment|/* reserved bits, which must be zero */
if|if
condition|(
operator|!
name|singleSegment
condition|)
block|{
name|BYTE
specifier|const
name|wlByte
init|=
name|ip
index|[
name|pos
operator|++
index|]
decl_stmt|;
name|U32
specifier|const
name|windowLog
init|=
operator|(
name|wlByte
operator|>>
literal|3
operator|)
operator|+
name|ZSTD_WINDOWLOG_ABSOLUTEMIN
decl_stmt|;
if|if
condition|(
name|windowLog
operator|>
name|ZSTD_WINDOWLOG_MAX
condition|)
return|return
name|ERROR
argument_list|(
name|frameParameter_windowTooLarge
argument_list|)
return|;
comment|/* avoids issue with 1<< windowLog */
name|windowSize
operator|=
operator|(
literal|1U
operator|<<
name|windowLog
operator|)
expr_stmt|;
name|windowSize
operator|+=
operator|(
name|windowSize
operator|>>
literal|3
operator|)
operator|*
operator|(
name|wlByte
operator|&
literal|7
operator|)
expr_stmt|;
block|}
switch|switch
condition|(
name|dictIDSizeCode
condition|)
block|{
default|default:
comment|/* impossible */
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
name|dictID
operator|=
name|ip
index|[
name|pos
index|]
expr_stmt|;
name|pos
operator|++
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|dictID
operator|=
name|MEM_readLE16
argument_list|(
name|ip
operator|+
name|pos
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|dictID
operator|=
name|MEM_readLE32
argument_list|(
name|ip
operator|+
name|pos
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|4
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|fcsID
condition|)
block|{
default|default:
comment|/* impossible */
case|case
literal|0
case|:
if|if
condition|(
name|singleSegment
condition|)
name|frameContentSize
operator|=
name|ip
index|[
name|pos
index|]
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|frameContentSize
operator|=
name|MEM_readLE16
argument_list|(
name|ip
operator|+
name|pos
argument_list|)
operator|+
literal|256
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|frameContentSize
operator|=
name|MEM_readLE32
argument_list|(
name|ip
operator|+
name|pos
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|frameContentSize
operator|=
name|MEM_readLE64
argument_list|(
name|ip
operator|+
name|pos
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|windowSize
condition|)
name|windowSize
operator|=
operator|(
name|U32
operator|)
name|frameContentSize
expr_stmt|;
if|if
condition|(
name|windowSize
operator|>
name|windowSizeMax
condition|)
return|return
name|ERROR
argument_list|(
name|frameParameter_windowTooLarge
argument_list|)
return|;
name|fparamsPtr
operator|->
name|frameContentSize
operator|=
name|frameContentSize
expr_stmt|;
name|fparamsPtr
operator|->
name|windowSize
operator|=
name|windowSize
expr_stmt|;
name|fparamsPtr
operator|->
name|dictID
operator|=
name|dictID
expr_stmt|;
name|fparamsPtr
operator|->
name|checksumFlag
operator|=
name|checksumFlag
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/** ZSTD_getFrameContentSize() : *   compatible with legacy mode *   @return : decompressed size of the single frame pointed to be `src` if known, otherwise *             - ZSTD_CONTENTSIZE_UNKNOWN if the size cannot be determined *             - ZSTD_CONTENTSIZE_ERROR if an error occurred (e.g. invalid magic number, srcSize too small) */
end_comment

begin_function
name|unsigned
name|long
name|long
name|ZSTD_getFrameContentSize
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|ZSTD_LEGACY_SUPPORT
argument_list|)
operator|&&
operator|(
name|ZSTD_LEGACY_SUPPORT
operator|>=
literal|1
operator|)
if|if
condition|(
name|ZSTD_isLegacy
argument_list|(
name|src
argument_list|,
name|srcSize
argument_list|)
condition|)
block|{
name|unsigned
name|long
name|long
specifier|const
name|ret
init|=
name|ZSTD_getDecompressedSize_legacy
argument_list|(
name|src
argument_list|,
name|srcSize
argument_list|)
decl_stmt|;
return|return
name|ret
operator|==
literal|0
condition|?
name|ZSTD_CONTENTSIZE_UNKNOWN
else|:
name|ret
return|;
block|}
endif|#
directive|endif
block|{
name|ZSTD_frameParams
name|fParams
decl_stmt|;
if|if
condition|(
name|ZSTD_getFrameParams
argument_list|(
operator|&
name|fParams
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|ZSTD_CONTENTSIZE_ERROR
return|;
if|if
condition|(
name|fParams
operator|.
name|windowSize
operator|==
literal|0
condition|)
block|{
comment|/* Either skippable or empty frame, size == 0 either way */
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|fParams
operator|.
name|frameContentSize
operator|!=
literal|0
condition|)
block|{
return|return
name|fParams
operator|.
name|frameContentSize
return|;
block|}
else|else
block|{
return|return
name|ZSTD_CONTENTSIZE_UNKNOWN
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/** ZSTD_findDecompressedSize() :  *  compatible with legacy mode  *  `srcSize` must be the exact length of some number of ZSTD compressed and/or  *      skippable frames  *  @return : decompressed size of the frames contained */
end_comment

begin_function
name|unsigned
name|long
name|long
name|ZSTD_findDecompressedSize
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
block|{
name|unsigned
name|long
name|long
name|totalDstSize
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|srcSize
operator|>=
name|ZSTD_frameHeaderSize_prefix
condition|)
block|{
specifier|const
name|U32
name|magicNumber
init|=
name|MEM_readLE32
argument_list|(
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|magicNumber
operator|&
literal|0xFFFFFFF0U
operator|)
operator|==
name|ZSTD_MAGIC_SKIPPABLE_START
condition|)
block|{
name|size_t
name|skippableSize
decl_stmt|;
if|if
condition|(
name|srcSize
operator|<
name|ZSTD_skippableHeaderSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|skippableSize
operator|=
name|MEM_readLE32
argument_list|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
operator|+
literal|4
argument_list|)
operator|+
name|ZSTD_skippableHeaderSize
expr_stmt|;
if|if
condition|(
name|srcSize
operator|<
name|skippableSize
condition|)
block|{
return|return
name|ZSTD_CONTENTSIZE_ERROR
return|;
block|}
name|src
operator|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
operator|+
name|skippableSize
expr_stmt|;
name|srcSize
operator|-=
name|skippableSize
expr_stmt|;
continue|continue;
block|}
block|{
name|unsigned
name|long
name|long
specifier|const
name|ret
init|=
name|ZSTD_getFrameContentSize
argument_list|(
name|src
argument_list|,
name|srcSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|>=
name|ZSTD_CONTENTSIZE_ERROR
condition|)
return|return
name|ret
return|;
comment|/* check for overflow */
if|if
condition|(
name|totalDstSize
operator|+
name|ret
operator|<
name|totalDstSize
condition|)
return|return
name|ZSTD_CONTENTSIZE_ERROR
return|;
name|totalDstSize
operator|+=
name|ret
expr_stmt|;
block|}
block|{
name|size_t
specifier|const
name|frameSrcSize
init|=
name|ZSTD_findFrameCompressedSize
argument_list|(
name|src
argument_list|,
name|srcSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|frameSrcSize
argument_list|)
condition|)
block|{
return|return
name|ZSTD_CONTENTSIZE_ERROR
return|;
block|}
name|src
operator|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
operator|+
name|frameSrcSize
expr_stmt|;
name|srcSize
operator|-=
name|frameSrcSize
expr_stmt|;
block|}
block|}
if|if
condition|(
name|srcSize
condition|)
block|{
return|return
name|ZSTD_CONTENTSIZE_ERROR
return|;
block|}
return|return
name|totalDstSize
return|;
block|}
block|}
end_function

begin_comment
comment|/** ZSTD_getDecompressedSize() : *   compatible with legacy mode *   @return : decompressed size if known, 0 otherwise               note : 0 can mean any of the following :                    - decompressed size is not present within frame header                    - frame header unknown / not supported                    - frame header not complete (`srcSize` too small) */
end_comment

begin_function
name|unsigned
name|long
name|long
name|ZSTD_getDecompressedSize
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
name|unsigned
name|long
name|long
specifier|const
name|ret
init|=
name|ZSTD_getFrameContentSize
argument_list|(
name|src
argument_list|,
name|srcSize
argument_list|)
decl_stmt|;
return|return
name|ret
operator|>=
name|ZSTD_CONTENTSIZE_ERROR
condition|?
literal|0
else|:
name|ret
return|;
block|}
end_function

begin_comment
comment|/** ZSTD_decodeFrameHeader() : *   `headerSize` must be the size provided by ZSTD_frameHeaderSize(). *   @return : 0 if success, or an error code, which can be tested using ZSTD_isError() */
end_comment

begin_function
specifier|static
name|size_t
name|ZSTD_decodeFrameHeader
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|headerSize
parameter_list|)
block|{
name|size_t
specifier|const
name|result
init|=
name|ZSTD_getFrameParams
argument_list|(
operator|&
operator|(
name|dctx
operator|->
name|fParams
operator|)
argument_list|,
name|src
argument_list|,
name|headerSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|result
argument_list|)
condition|)
return|return
name|result
return|;
comment|/* invalid header */
if|if
condition|(
name|result
operator|>
literal|0
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
comment|/* headerSize too small */
if|if
condition|(
name|dctx
operator|->
name|fParams
operator|.
name|dictID
operator|&&
operator|(
name|dctx
operator|->
name|dictID
operator|!=
name|dctx
operator|->
name|fParams
operator|.
name|dictID
operator|)
condition|)
return|return
name|ERROR
argument_list|(
name|dictionary_wrong
argument_list|)
return|;
if|if
condition|(
name|dctx
operator|->
name|fParams
operator|.
name|checksumFlag
condition|)
name|XXH64_reset
argument_list|(
operator|&
name|dctx
operator|->
name|xxhState
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
block|{
name|blockType_e
name|blockType
decl_stmt|;
name|U32
name|lastBlock
decl_stmt|;
name|U32
name|origSize
decl_stmt|;
block|}
name|blockProperties_t
typedef|;
end_typedef

begin_comment
comment|/*! ZSTD_getcBlockSize() : *   Provides the size of compressed block from block header `src` */
end_comment

begin_function
name|size_t
name|ZSTD_getcBlockSize
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|blockProperties_t
modifier|*
name|bpPtr
parameter_list|)
block|{
if|if
condition|(
name|srcSize
operator|<
name|ZSTD_blockHeaderSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
block|{
name|U32
specifier|const
name|cBlockHeader
init|=
name|MEM_readLE24
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|U32
specifier|const
name|cSize
init|=
name|cBlockHeader
operator|>>
literal|3
decl_stmt|;
name|bpPtr
operator|->
name|lastBlock
operator|=
name|cBlockHeader
operator|&
literal|1
expr_stmt|;
name|bpPtr
operator|->
name|blockType
operator|=
call|(
name|blockType_e
call|)
argument_list|(
operator|(
name|cBlockHeader
operator|>>
literal|1
operator|)
operator|&
literal|3
argument_list|)
expr_stmt|;
name|bpPtr
operator|->
name|origSize
operator|=
name|cSize
expr_stmt|;
comment|/* only useful for RLE */
if|if
condition|(
name|bpPtr
operator|->
name|blockType
operator|==
name|bt_rle
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|bpPtr
operator|->
name|blockType
operator|==
name|bt_reserved
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
return|return
name|cSize
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|size_t
name|ZSTD_copyRawBlock
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
if|if
condition|(
name|srcSize
operator|>
name|dstCapacity
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
expr_stmt|;
return|return
name|srcSize
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|ZSTD_setRleBlock
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|size_t
name|regenSize
parameter_list|)
block|{
if|if
condition|(
name|srcSize
operator|!=
literal|1
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
if|if
condition|(
name|regenSize
operator|>
name|dstCapacity
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
name|memset
argument_list|(
name|dst
argument_list|,
operator|*
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
argument_list|,
name|regenSize
argument_list|)
expr_stmt|;
return|return
name|regenSize
return|;
block|}
end_function

begin_comment
comment|/*! ZSTD_decodeLiteralsBlock() :     @return : nb of bytes read from src (< srcSize ) */
end_comment

begin_function
name|size_t
name|ZSTD_decodeLiteralsBlock
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
comment|/* note : srcSize< BLOCKSIZE */
block|{
if|if
condition|(
name|srcSize
operator|<
name|MIN_CBLOCK_SIZE
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
decl_stmt|;
name|symbolEncodingType_e
specifier|const
name|litEncType
init|=
call|(
name|symbolEncodingType_e
call|)
argument_list|(
name|istart
index|[
literal|0
index|]
operator|&
literal|3
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|litEncType
condition|)
block|{
case|case
name|set_repeat
case|:
if|if
condition|(
name|dctx
operator|->
name|litEntropy
operator|==
literal|0
condition|)
return|return
name|ERROR
argument_list|(
name|dictionary_corrupted
argument_list|)
return|;
comment|/* fall-through */
case|case
name|set_compressed
case|:
if|if
condition|(
name|srcSize
operator|<
literal|5
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* srcSize>= MIN_CBLOCK_SIZE == 3; here we need up to 5 for case 3 */
block|{
name|size_t
name|lhSize
decl_stmt|,
name|litSize
decl_stmt|,
name|litCSize
decl_stmt|;
name|U32
name|singleStream
init|=
literal|0
decl_stmt|;
name|U32
specifier|const
name|lhlCode
init|=
operator|(
name|istart
index|[
literal|0
index|]
operator|>>
literal|2
operator|)
operator|&
literal|3
decl_stmt|;
name|U32
specifier|const
name|lhc
init|=
name|MEM_readLE32
argument_list|(
name|istart
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|lhlCode
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
default|default:
comment|/* note : default is impossible, since lhlCode into [0..3] */
comment|/* 2 - 2 - 10 - 10 */
name|singleStream
operator|=
operator|!
name|lhlCode
expr_stmt|;
name|lhSize
operator|=
literal|3
expr_stmt|;
name|litSize
operator|=
operator|(
name|lhc
operator|>>
literal|4
operator|)
operator|&
literal|0x3FF
expr_stmt|;
name|litCSize
operator|=
operator|(
name|lhc
operator|>>
literal|14
operator|)
operator|&
literal|0x3FF
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* 2 - 2 - 14 - 14 */
name|lhSize
operator|=
literal|4
expr_stmt|;
name|litSize
operator|=
operator|(
name|lhc
operator|>>
literal|4
operator|)
operator|&
literal|0x3FFF
expr_stmt|;
name|litCSize
operator|=
name|lhc
operator|>>
literal|18
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* 2 - 2 - 18 - 18 */
name|lhSize
operator|=
literal|5
expr_stmt|;
name|litSize
operator|=
operator|(
name|lhc
operator|>>
literal|4
operator|)
operator|&
literal|0x3FFFF
expr_stmt|;
name|litCSize
operator|=
operator|(
name|lhc
operator|>>
literal|22
operator|)
operator|+
operator|(
name|istart
index|[
literal|4
index|]
operator|<<
literal|10
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|litSize
operator|>
name|ZSTD_BLOCKSIZE_ABSOLUTEMAX
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
if|if
condition|(
name|litCSize
operator|+
name|lhSize
operator|>
name|srcSize
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
if|if
condition|(
name|HUF_isError
argument_list|(
operator|(
name|litEncType
operator|==
name|set_repeat
operator|)
condition|?
operator|(
name|singleStream
condition|?
name|HUF_decompress1X_usingDTable
argument_list|(
name|dctx
operator|->
name|litBuffer
argument_list|,
name|litSize
argument_list|,
name|istart
operator|+
name|lhSize
argument_list|,
name|litCSize
argument_list|,
name|dctx
operator|->
name|HUFptr
argument_list|)
else|:
name|HUF_decompress4X_usingDTable
argument_list|(
name|dctx
operator|->
name|litBuffer
argument_list|,
name|litSize
argument_list|,
name|istart
operator|+
name|lhSize
argument_list|,
name|litCSize
argument_list|,
name|dctx
operator|->
name|HUFptr
argument_list|)
operator|)
else|:
operator|(
name|singleStream
condition|?
name|HUF_decompress1X2_DCtx
argument_list|(
name|dctx
operator|->
name|entropy
operator|.
name|hufTable
argument_list|,
name|dctx
operator|->
name|litBuffer
argument_list|,
name|litSize
argument_list|,
name|istart
operator|+
name|lhSize
argument_list|,
name|litCSize
argument_list|)
else|:
name|HUF_decompress4X_hufOnly
argument_list|(
name|dctx
operator|->
name|entropy
operator|.
name|hufTable
argument_list|,
name|dctx
operator|->
name|litBuffer
argument_list|,
name|litSize
argument_list|,
name|istart
operator|+
name|lhSize
argument_list|,
name|litCSize
argument_list|)
operator|)
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
name|dctx
operator|->
name|litPtr
operator|=
name|dctx
operator|->
name|litBuffer
expr_stmt|;
name|dctx
operator|->
name|litSize
operator|=
name|litSize
expr_stmt|;
name|dctx
operator|->
name|litEntropy
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|litEncType
operator|==
name|set_compressed
condition|)
name|dctx
operator|->
name|HUFptr
operator|=
name|dctx
operator|->
name|entropy
operator|.
name|hufTable
expr_stmt|;
name|memset
argument_list|(
name|dctx
operator|->
name|litBuffer
operator|+
name|dctx
operator|->
name|litSize
argument_list|,
literal|0
argument_list|,
name|WILDCOPY_OVERLENGTH
argument_list|)
expr_stmt|;
return|return
name|litCSize
operator|+
name|lhSize
return|;
block|}
case|case
name|set_basic
case|:
block|{
name|size_t
name|litSize
decl_stmt|,
name|lhSize
decl_stmt|;
name|U32
specifier|const
name|lhlCode
init|=
operator|(
operator|(
name|istart
index|[
literal|0
index|]
operator|)
operator|>>
literal|2
operator|)
operator|&
literal|3
decl_stmt|;
switch|switch
condition|(
name|lhlCode
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|2
case|:
default|default:
comment|/* note : default is impossible, since lhlCode into [0..3] */
name|lhSize
operator|=
literal|1
expr_stmt|;
name|litSize
operator|=
name|istart
index|[
literal|0
index|]
operator|>>
literal|3
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|lhSize
operator|=
literal|2
expr_stmt|;
name|litSize
operator|=
name|MEM_readLE16
argument_list|(
name|istart
argument_list|)
operator|>>
literal|4
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|lhSize
operator|=
literal|3
expr_stmt|;
name|litSize
operator|=
name|MEM_readLE24
argument_list|(
name|istart
argument_list|)
operator|>>
literal|4
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|lhSize
operator|+
name|litSize
operator|+
name|WILDCOPY_OVERLENGTH
operator|>
name|srcSize
condition|)
block|{
comment|/* risk reading beyond src buffer with wildcopy */
if|if
condition|(
name|litSize
operator|+
name|lhSize
operator|>
name|srcSize
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
name|memcpy
argument_list|(
name|dctx
operator|->
name|litBuffer
argument_list|,
name|istart
operator|+
name|lhSize
argument_list|,
name|litSize
argument_list|)
expr_stmt|;
name|dctx
operator|->
name|litPtr
operator|=
name|dctx
operator|->
name|litBuffer
expr_stmt|;
name|dctx
operator|->
name|litSize
operator|=
name|litSize
expr_stmt|;
name|memset
argument_list|(
name|dctx
operator|->
name|litBuffer
operator|+
name|dctx
operator|->
name|litSize
argument_list|,
literal|0
argument_list|,
name|WILDCOPY_OVERLENGTH
argument_list|)
expr_stmt|;
return|return
name|lhSize
operator|+
name|litSize
return|;
block|}
comment|/* direct reference into compressed stream */
name|dctx
operator|->
name|litPtr
operator|=
name|istart
operator|+
name|lhSize
expr_stmt|;
name|dctx
operator|->
name|litSize
operator|=
name|litSize
expr_stmt|;
return|return
name|lhSize
operator|+
name|litSize
return|;
block|}
case|case
name|set_rle
case|:
block|{
name|U32
specifier|const
name|lhlCode
init|=
operator|(
operator|(
name|istart
index|[
literal|0
index|]
operator|)
operator|>>
literal|2
operator|)
operator|&
literal|3
decl_stmt|;
name|size_t
name|litSize
decl_stmt|,
name|lhSize
decl_stmt|;
switch|switch
condition|(
name|lhlCode
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|2
case|:
default|default:
comment|/* note : default is impossible, since lhlCode into [0..3] */
name|lhSize
operator|=
literal|1
expr_stmt|;
name|litSize
operator|=
name|istart
index|[
literal|0
index|]
operator|>>
literal|3
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|lhSize
operator|=
literal|2
expr_stmt|;
name|litSize
operator|=
name|MEM_readLE16
argument_list|(
name|istart
argument_list|)
operator|>>
literal|4
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|lhSize
operator|=
literal|3
expr_stmt|;
name|litSize
operator|=
name|MEM_readLE24
argument_list|(
name|istart
argument_list|)
operator|>>
literal|4
expr_stmt|;
if|if
condition|(
name|srcSize
operator|<
literal|4
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* srcSize>= MIN_CBLOCK_SIZE == 3; here we need lhSize+1 = 4 */
break|break;
block|}
if|if
condition|(
name|litSize
operator|>
name|ZSTD_BLOCKSIZE_ABSOLUTEMAX
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
name|memset
argument_list|(
name|dctx
operator|->
name|litBuffer
argument_list|,
name|istart
index|[
name|lhSize
index|]
argument_list|,
name|litSize
operator|+
name|WILDCOPY_OVERLENGTH
argument_list|)
expr_stmt|;
name|dctx
operator|->
name|litPtr
operator|=
name|dctx
operator|->
name|litBuffer
expr_stmt|;
name|dctx
operator|->
name|litSize
operator|=
name|litSize
expr_stmt|;
return|return
name|lhSize
operator|+
literal|1
return|;
block|}
default|default:
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* impossible */
block|}
block|}
block|}
end_function

begin_typedef
typedef|typedef
union|union
block|{
name|FSE_decode_t
name|realData
decl_stmt|;
name|U32
name|alignedBy4
decl_stmt|;
block|}
name|FSE_decode_t4
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|FSE_decode_t4
name|LL_defaultDTable
index|[
operator|(
literal|1
operator|<<
name|LL_DEFAULTNORMLOG
operator|)
operator|+
literal|1
index|]
init|=
block|{
block|{
block|{
name|LL_DEFAULTNORMLOG
block|,
literal|1
block|,
literal|1
block|}
block|}
block|,
comment|/* header : tableLog, fastMode, fastMode */
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|}
block|}
block|,
comment|/* 0 : base, symbol, bits */
block|{
block|{
literal|16
block|,
literal|0
block|,
literal|4
block|}
block|}
block|,
block|{
block|{
literal|32
block|,
literal|1
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|3
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|4
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|6
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|7
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|9
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|10
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|12
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|14
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|16
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|18
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|19
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|21
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|22
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|24
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|32
block|,
literal|25
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|26
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|27
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|29
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|31
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|32
block|,
literal|0
block|,
literal|4
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|1
block|,
literal|4
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|2
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|32
block|,
literal|4
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|5
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|32
block|,
literal|7
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|8
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|32
block|,
literal|10
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|11
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|13
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|32
block|,
literal|16
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|17
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|32
block|,
literal|19
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|20
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|32
block|,
literal|22
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|23
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|25
block|,
literal|4
block|}
block|}
block|,
block|{
block|{
literal|16
block|,
literal|25
block|,
literal|4
block|}
block|}
block|,
block|{
block|{
literal|32
block|,
literal|26
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|28
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|30
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|48
block|,
literal|0
block|,
literal|4
block|}
block|}
block|,
block|{
block|{
literal|16
block|,
literal|1
block|,
literal|4
block|}
block|}
block|,
block|{
block|{
literal|32
block|,
literal|2
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|32
block|,
literal|3
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|32
block|,
literal|5
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|32
block|,
literal|6
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|32
block|,
literal|8
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|32
block|,
literal|9
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|32
block|,
literal|11
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|32
block|,
literal|12
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|15
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|32
block|,
literal|17
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|32
block|,
literal|18
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|32
block|,
literal|20
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|32
block|,
literal|21
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|32
block|,
literal|23
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|32
block|,
literal|24
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|35
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|34
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|33
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|32
block|,
literal|6
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* LL_defaultDTable */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|FSE_decode_t4
name|ML_defaultDTable
index|[
operator|(
literal|1
operator|<<
name|ML_DEFAULTNORMLOG
operator|)
operator|+
literal|1
index|]
init|=
block|{
block|{
block|{
name|ML_DEFAULTNORMLOG
block|,
literal|1
block|,
literal|1
block|}
block|}
block|,
comment|/* header : tableLog, fastMode, fastMode */
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|6
block|}
block|}
block|,
comment|/* 0 : base, symbol, bits */
block|{
block|{
literal|0
block|,
literal|1
block|,
literal|4
block|}
block|}
block|,
block|{
block|{
literal|32
block|,
literal|2
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|3
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|5
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|6
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|8
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|10
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|13
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|16
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|19
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|22
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|25
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|28
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|31
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|33
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|35
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|37
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|39
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|41
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|43
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|45
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|16
block|,
literal|1
block|,
literal|4
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|2
block|,
literal|4
block|}
block|}
block|,
block|{
block|{
literal|32
block|,
literal|3
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|4
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|32
block|,
literal|6
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|7
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|9
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|12
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|15
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|18
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|21
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|24
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|27
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|30
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|32
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|34
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|36
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|38
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|40
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|42
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|44
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|32
block|,
literal|1
block|,
literal|4
block|}
block|}
block|,
block|{
block|{
literal|48
block|,
literal|1
block|,
literal|4
block|}
block|}
block|,
block|{
block|{
literal|16
block|,
literal|2
block|,
literal|4
block|}
block|}
block|,
block|{
block|{
literal|32
block|,
literal|4
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|32
block|,
literal|5
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|32
block|,
literal|7
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|32
block|,
literal|8
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|11
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|14
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|17
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|20
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|23
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|26
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|29
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|52
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|51
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|50
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|49
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|48
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|47
block|,
literal|6
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|46
block|,
literal|6
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ML_defaultDTable */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|FSE_decode_t4
name|OF_defaultDTable
index|[
operator|(
literal|1
operator|<<
name|OF_DEFAULTNORMLOG
operator|)
operator|+
literal|1
index|]
init|=
block|{
block|{
block|{
name|OF_DEFAULTNORMLOG
block|,
literal|1
block|,
literal|1
block|}
block|}
block|,
comment|/* header : tableLog, fastMode, fastMode */
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|5
block|}
block|}
block|,
comment|/* 0 : base, symbol, bits */
block|{
block|{
literal|0
block|,
literal|6
block|,
literal|4
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|9
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|15
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|21
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|3
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|7
block|,
literal|4
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|12
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|18
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|23
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|5
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|8
block|,
literal|4
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|14
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|20
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|2
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|16
block|,
literal|7
block|,
literal|4
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|11
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|17
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|22
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|4
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|16
block|,
literal|8
block|,
literal|4
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|13
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|19
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|1
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|16
block|,
literal|6
block|,
literal|4
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|10
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|16
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|28
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|27
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|26
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|25
block|,
literal|5
block|}
block|}
block|,
block|{
block|{
literal|0
block|,
literal|24
block|,
literal|5
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* OF_defaultDTable */
end_comment

begin_comment
comment|/*! ZSTD_buildSeqTable() :     @return : nb bytes read from src,               or an error code if it fails, testable with ZSTD_isError() */
end_comment

begin_function
specifier|static
name|size_t
name|ZSTD_buildSeqTable
parameter_list|(
name|FSE_DTable
modifier|*
name|DTableSpace
parameter_list|,
specifier|const
name|FSE_DTable
modifier|*
modifier|*
name|DTablePtr
parameter_list|,
name|symbolEncodingType_e
name|type
parameter_list|,
name|U32
name|max
parameter_list|,
name|U32
name|maxLog
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
specifier|const
name|FSE_decode_t4
modifier|*
name|defaultTable
parameter_list|,
name|U32
name|flagRepeatTable
parameter_list|)
block|{
specifier|const
name|void
modifier|*
specifier|const
name|tmpPtr
init|=
name|defaultTable
decl_stmt|;
comment|/* bypass strict aliasing */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|set_rle
case|:
if|if
condition|(
operator|!
name|srcSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
if|if
condition|(
operator|(
operator|*
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
operator|)
operator|>
name|max
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
name|FSE_buildDTable_rle
argument_list|(
name|DTableSpace
argument_list|,
operator|*
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
argument_list|)
expr_stmt|;
operator|*
name|DTablePtr
operator|=
name|DTableSpace
expr_stmt|;
return|return
literal|1
return|;
case|case
name|set_basic
case|:
operator|*
name|DTablePtr
operator|=
operator|(
specifier|const
name|FSE_DTable
operator|*
operator|)
name|tmpPtr
expr_stmt|;
return|return
literal|0
return|;
case|case
name|set_repeat
case|:
if|if
condition|(
operator|!
name|flagRepeatTable
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
return|return
literal|0
return|;
default|default :
comment|/* impossible */
case|case
name|set_compressed
case|:
block|{
name|U32
name|tableLog
decl_stmt|;
name|S16
name|norm
index|[
name|MaxSeq
operator|+
literal|1
index|]
decl_stmt|;
name|size_t
specifier|const
name|headerSize
init|=
name|FSE_readNCount
argument_list|(
name|norm
argument_list|,
operator|&
name|max
argument_list|,
operator|&
name|tableLog
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|FSE_isError
argument_list|(
name|headerSize
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
if|if
condition|(
name|tableLog
operator|>
name|maxLog
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
name|FSE_buildDTable
argument_list|(
name|DTableSpace
argument_list|,
name|norm
argument_list|,
name|max
argument_list|,
name|tableLog
argument_list|)
expr_stmt|;
operator|*
name|DTablePtr
operator|=
name|DTableSpace
expr_stmt|;
return|return
name|headerSize
return|;
block|}
block|}
block|}
end_function

begin_function
name|size_t
name|ZSTD_decodeSeqHeaders
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
name|int
modifier|*
name|nbSeqPtr
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart
init|=
operator|(
specifier|const
name|BYTE
operator|*
specifier|const
operator|)
name|src
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|iend
init|=
name|istart
operator|+
name|srcSize
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|ip
init|=
name|istart
decl_stmt|;
comment|/* check */
if|if
condition|(
name|srcSize
operator|<
name|MIN_SEQUENCES_SIZE
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
comment|/* SeqHead */
block|{
name|int
name|nbSeq
init|=
operator|*
name|ip
operator|++
decl_stmt|;
if|if
condition|(
operator|!
name|nbSeq
condition|)
block|{
operator|*
name|nbSeqPtr
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|nbSeq
operator|>
literal|0x7F
condition|)
block|{
if|if
condition|(
name|nbSeq
operator|==
literal|0xFF
condition|)
block|{
if|if
condition|(
name|ip
operator|+
literal|2
operator|>
name|iend
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|nbSeq
operator|=
name|MEM_readLE16
argument_list|(
name|ip
argument_list|)
operator|+
name|LONGNBSEQ
operator|,
name|ip
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ip
operator|>=
name|iend
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|nbSeq
operator|=
operator|(
operator|(
name|nbSeq
operator|-
literal|0x80
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|*
name|ip
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|nbSeqPtr
operator|=
name|nbSeq
expr_stmt|;
block|}
comment|/* FSE table descriptors */
if|if
condition|(
name|ip
operator|+
literal|4
operator|>
name|iend
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
comment|/* minimum possible size */
block|{
name|symbolEncodingType_e
specifier|const
name|LLtype
init|=
call|(
name|symbolEncodingType_e
call|)
argument_list|(
operator|*
name|ip
operator|>>
literal|6
argument_list|)
decl_stmt|;
name|symbolEncodingType_e
specifier|const
name|OFtype
init|=
call|(
name|symbolEncodingType_e
call|)
argument_list|(
operator|(
operator|*
name|ip
operator|>>
literal|4
operator|)
operator|&
literal|3
argument_list|)
decl_stmt|;
name|symbolEncodingType_e
specifier|const
name|MLtype
init|=
call|(
name|symbolEncodingType_e
call|)
argument_list|(
operator|(
operator|*
name|ip
operator|>>
literal|2
operator|)
operator|&
literal|3
argument_list|)
decl_stmt|;
name|ip
operator|++
expr_stmt|;
comment|/* Build DTables */
block|{
name|size_t
specifier|const
name|llhSize
init|=
name|ZSTD_buildSeqTable
argument_list|(
name|dctx
operator|->
name|entropy
operator|.
name|LLTable
argument_list|,
operator|&
name|dctx
operator|->
name|LLTptr
argument_list|,
name|LLtype
argument_list|,
name|MaxLL
argument_list|,
name|LLFSELog
argument_list|,
name|ip
argument_list|,
name|iend
operator|-
name|ip
argument_list|,
name|LL_defaultDTable
argument_list|,
name|dctx
operator|->
name|fseEntropy
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|llhSize
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
name|ip
operator|+=
name|llhSize
expr_stmt|;
block|}
block|{
name|size_t
specifier|const
name|ofhSize
init|=
name|ZSTD_buildSeqTable
argument_list|(
name|dctx
operator|->
name|entropy
operator|.
name|OFTable
argument_list|,
operator|&
name|dctx
operator|->
name|OFTptr
argument_list|,
name|OFtype
argument_list|,
name|MaxOff
argument_list|,
name|OffFSELog
argument_list|,
name|ip
argument_list|,
name|iend
operator|-
name|ip
argument_list|,
name|OF_defaultDTable
argument_list|,
name|dctx
operator|->
name|fseEntropy
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|ofhSize
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
name|ip
operator|+=
name|ofhSize
expr_stmt|;
block|}
block|{
name|size_t
specifier|const
name|mlhSize
init|=
name|ZSTD_buildSeqTable
argument_list|(
name|dctx
operator|->
name|entropy
operator|.
name|MLTable
argument_list|,
operator|&
name|dctx
operator|->
name|MLTptr
argument_list|,
name|MLtype
argument_list|,
name|MaxML
argument_list|,
name|MLFSELog
argument_list|,
name|ip
argument_list|,
name|iend
operator|-
name|ip
argument_list|,
name|ML_defaultDTable
argument_list|,
name|dctx
operator|->
name|fseEntropy
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|mlhSize
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
name|ip
operator|+=
name|mlhSize
expr_stmt|;
block|}
block|}
return|return
name|ip
operator|-
name|istart
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
block|{
name|size_t
name|litLength
decl_stmt|;
name|size_t
name|matchLength
decl_stmt|;
name|size_t
name|offset
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|match
decl_stmt|;
block|}
name|seq_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|BIT_DStream_t
name|DStream
decl_stmt|;
name|FSE_DState_t
name|stateLL
decl_stmt|;
name|FSE_DState_t
name|stateOffb
decl_stmt|;
name|FSE_DState_t
name|stateML
decl_stmt|;
name|size_t
name|prevOffset
index|[
name|ZSTD_REP_NUM
index|]
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|base
decl_stmt|;
name|size_t
name|pos
decl_stmt|;
name|uPtrDiff
name|gotoDict
decl_stmt|;
block|}
name|seqState_t
typedef|;
end_typedef

begin_function
name|FORCE_NOINLINE
name|size_t
name|ZSTD_execSequenceLast7
parameter_list|(
name|BYTE
modifier|*
name|op
parameter_list|,
name|BYTE
modifier|*
specifier|const
name|oend
parameter_list|,
name|seq_t
name|sequence
parameter_list|,
specifier|const
name|BYTE
modifier|*
modifier|*
name|litPtr
parameter_list|,
specifier|const
name|BYTE
modifier|*
specifier|const
name|litLimit
parameter_list|,
specifier|const
name|BYTE
modifier|*
specifier|const
name|base
parameter_list|,
specifier|const
name|BYTE
modifier|*
specifier|const
name|vBase
parameter_list|,
specifier|const
name|BYTE
modifier|*
specifier|const
name|dictEnd
parameter_list|)
block|{
name|BYTE
modifier|*
specifier|const
name|oLitEnd
init|=
name|op
operator|+
name|sequence
operator|.
name|litLength
decl_stmt|;
name|size_t
specifier|const
name|sequenceLength
init|=
name|sequence
operator|.
name|litLength
operator|+
name|sequence
operator|.
name|matchLength
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|oMatchEnd
init|=
name|op
operator|+
name|sequenceLength
decl_stmt|;
comment|/* risk : address space overflow (32-bits) */
name|BYTE
modifier|*
specifier|const
name|oend_w
init|=
name|oend
operator|-
name|WILDCOPY_OVERLENGTH
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|iLitEnd
init|=
operator|*
name|litPtr
operator|+
name|sequence
operator|.
name|litLength
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|match
init|=
name|oLitEnd
operator|-
name|sequence
operator|.
name|offset
decl_stmt|;
comment|/* check */
if|if
condition|(
name|oMatchEnd
operator|>
name|oend
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
comment|/* last match must start at a minimum distance of WILDCOPY_OVERLENGTH from oend */
if|if
condition|(
name|iLitEnd
operator|>
name|litLimit
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* over-read beyond lit buffer */
if|if
condition|(
name|oLitEnd
operator|<=
name|oend_w
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
comment|/* Precondition */
comment|/* copy literals */
if|if
condition|(
name|op
operator|<
name|oend_w
condition|)
block|{
name|ZSTD_wildcopy
argument_list|(
name|op
argument_list|,
operator|*
name|litPtr
argument_list|,
name|oend_w
operator|-
name|op
argument_list|)
expr_stmt|;
operator|*
name|litPtr
operator|+=
name|oend_w
operator|-
name|op
expr_stmt|;
name|op
operator|=
name|oend_w
expr_stmt|;
block|}
while|while
condition|(
name|op
operator|<
name|oLitEnd
condition|)
operator|*
name|op
operator|++
operator|=
operator|*
operator|(
operator|*
name|litPtr
operator|)
operator|++
expr_stmt|;
comment|/* copy Match */
if|if
condition|(
name|sequence
operator|.
name|offset
operator|>
call|(
name|size_t
call|)
argument_list|(
name|oLitEnd
operator|-
name|base
argument_list|)
condition|)
block|{
comment|/* offset beyond prefix */
if|if
condition|(
name|sequence
operator|.
name|offset
operator|>
call|(
name|size_t
call|)
argument_list|(
name|oLitEnd
operator|-
name|vBase
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
name|match
operator|=
name|dictEnd
operator|-
operator|(
name|base
operator|-
name|match
operator|)
expr_stmt|;
if|if
condition|(
name|match
operator|+
name|sequence
operator|.
name|matchLength
operator|<=
name|dictEnd
condition|)
block|{
name|memmove
argument_list|(
name|oLitEnd
argument_list|,
name|match
argument_list|,
name|sequence
operator|.
name|matchLength
argument_list|)
expr_stmt|;
return|return
name|sequenceLength
return|;
block|}
comment|/* span extDict& currentPrefixSegment */
block|{
name|size_t
specifier|const
name|length1
init|=
name|dictEnd
operator|-
name|match
decl_stmt|;
name|memmove
argument_list|(
name|oLitEnd
argument_list|,
name|match
argument_list|,
name|length1
argument_list|)
expr_stmt|;
name|op
operator|=
name|oLitEnd
operator|+
name|length1
expr_stmt|;
name|sequence
operator|.
name|matchLength
operator|-=
name|length1
expr_stmt|;
name|match
operator|=
name|base
expr_stmt|;
block|}
block|}
while|while
condition|(
name|op
operator|<
name|oMatchEnd
condition|)
operator|*
name|op
operator|++
operator|=
operator|*
name|match
operator|++
expr_stmt|;
return|return
name|sequenceLength
return|;
block|}
end_function

begin_function
specifier|static
name|seq_t
name|ZSTD_decodeSequence
parameter_list|(
name|seqState_t
modifier|*
name|seqState
parameter_list|)
block|{
name|seq_t
name|seq
decl_stmt|;
name|U32
specifier|const
name|llCode
init|=
name|FSE_peekSymbol
argument_list|(
operator|&
name|seqState
operator|->
name|stateLL
argument_list|)
decl_stmt|;
name|U32
specifier|const
name|mlCode
init|=
name|FSE_peekSymbol
argument_list|(
operator|&
name|seqState
operator|->
name|stateML
argument_list|)
decl_stmt|;
name|U32
specifier|const
name|ofCode
init|=
name|FSE_peekSymbol
argument_list|(
operator|&
name|seqState
operator|->
name|stateOffb
argument_list|)
decl_stmt|;
comment|/*<= maxOff, by table construction */
name|U32
specifier|const
name|llBits
init|=
name|LL_bits
index|[
name|llCode
index|]
decl_stmt|;
name|U32
specifier|const
name|mlBits
init|=
name|ML_bits
index|[
name|mlCode
index|]
decl_stmt|;
name|U32
specifier|const
name|ofBits
init|=
name|ofCode
decl_stmt|;
name|U32
specifier|const
name|totalBits
init|=
name|llBits
operator|+
name|mlBits
operator|+
name|ofBits
decl_stmt|;
specifier|static
specifier|const
name|U32
name|LL_base
index|[
name|MaxLL
operator|+
literal|1
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|18
block|,
literal|20
block|,
literal|22
block|,
literal|24
block|,
literal|28
block|,
literal|32
block|,
literal|40
block|,
literal|48
block|,
literal|64
block|,
literal|0x80
block|,
literal|0x100
block|,
literal|0x200
block|,
literal|0x400
block|,
literal|0x800
block|,
literal|0x1000
block|,
literal|0x2000
block|,
literal|0x4000
block|,
literal|0x8000
block|,
literal|0x10000
block|}
decl_stmt|;
specifier|static
specifier|const
name|U32
name|ML_base
index|[
name|MaxML
operator|+
literal|1
index|]
init|=
block|{
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|37
block|,
literal|39
block|,
literal|41
block|,
literal|43
block|,
literal|47
block|,
literal|51
block|,
literal|59
block|,
literal|67
block|,
literal|83
block|,
literal|99
block|,
literal|0x83
block|,
literal|0x103
block|,
literal|0x203
block|,
literal|0x403
block|,
literal|0x803
block|,
literal|0x1003
block|,
literal|0x2003
block|,
literal|0x4003
block|,
literal|0x8003
block|,
literal|0x10003
block|}
decl_stmt|;
specifier|static
specifier|const
name|U32
name|OF_base
index|[
name|MaxOff
operator|+
literal|1
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|5
block|,
literal|0xD
block|,
literal|0x1D
block|,
literal|0x3D
block|,
literal|0x7D
block|,
literal|0xFD
block|,
literal|0x1FD
block|,
literal|0x3FD
block|,
literal|0x7FD
block|,
literal|0xFFD
block|,
literal|0x1FFD
block|,
literal|0x3FFD
block|,
literal|0x7FFD
block|,
literal|0xFFFD
block|,
literal|0x1FFFD
block|,
literal|0x3FFFD
block|,
literal|0x7FFFD
block|,
literal|0xFFFFD
block|,
literal|0x1FFFFD
block|,
literal|0x3FFFFD
block|,
literal|0x7FFFFD
block|,
literal|0xFFFFFD
block|,
literal|0x1FFFFFD
block|,
literal|0x3FFFFFD
block|,
literal|0x7FFFFFD
block|,
literal|0xFFFFFFD
block|}
decl_stmt|;
comment|/* sequence */
block|{
name|size_t
name|offset
decl_stmt|;
if|if
condition|(
operator|!
name|ofCode
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|offset
operator|=
name|OF_base
index|[
name|ofCode
index|]
operator|+
name|BIT_readBitsFast
argument_list|(
operator|&
name|seqState
operator|->
name|DStream
argument_list|,
name|ofBits
argument_list|)
expr_stmt|;
comment|/*<=  (ZSTD_WINDOWLOG_MAX-1) bits */
if|if
condition|(
name|MEM_32bits
argument_list|()
condition|)
name|BIT_reloadDStream
argument_list|(
operator|&
name|seqState
operator|->
name|DStream
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ofCode
operator|<=
literal|1
condition|)
block|{
name|offset
operator|+=
operator|(
name|llCode
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|offset
condition|)
block|{
name|size_t
name|temp
init|=
operator|(
name|offset
operator|==
literal|3
operator|)
condition|?
name|seqState
operator|->
name|prevOffset
index|[
literal|0
index|]
operator|-
literal|1
else|:
name|seqState
operator|->
name|prevOffset
index|[
name|offset
index|]
decl_stmt|;
name|temp
operator|+=
operator|!
name|temp
expr_stmt|;
comment|/* 0 is not valid; input is corrupted; force offset to 1 */
if|if
condition|(
name|offset
operator|!=
literal|1
condition|)
name|seqState
operator|->
name|prevOffset
index|[
literal|2
index|]
operator|=
name|seqState
operator|->
name|prevOffset
index|[
literal|1
index|]
expr_stmt|;
name|seqState
operator|->
name|prevOffset
index|[
literal|1
index|]
operator|=
name|seqState
operator|->
name|prevOffset
index|[
literal|0
index|]
expr_stmt|;
name|seqState
operator|->
name|prevOffset
index|[
literal|0
index|]
operator|=
name|offset
operator|=
name|temp
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|=
name|seqState
operator|->
name|prevOffset
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|seqState
operator|->
name|prevOffset
index|[
literal|2
index|]
operator|=
name|seqState
operator|->
name|prevOffset
index|[
literal|1
index|]
expr_stmt|;
name|seqState
operator|->
name|prevOffset
index|[
literal|1
index|]
operator|=
name|seqState
operator|->
name|prevOffset
index|[
literal|0
index|]
expr_stmt|;
name|seqState
operator|->
name|prevOffset
index|[
literal|0
index|]
operator|=
name|offset
expr_stmt|;
block|}
name|seq
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
block|}
name|seq
operator|.
name|matchLength
operator|=
name|ML_base
index|[
name|mlCode
index|]
operator|+
operator|(
operator|(
name|mlCode
operator|>
literal|31
operator|)
condition|?
name|BIT_readBitsFast
argument_list|(
operator|&
name|seqState
operator|->
name|DStream
argument_list|,
name|mlBits
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
comment|/*<=  16 bits */
if|if
condition|(
name|MEM_32bits
argument_list|()
operator|&&
operator|(
name|mlBits
operator|+
name|llBits
operator|>
literal|24
operator|)
condition|)
name|BIT_reloadDStream
argument_list|(
operator|&
name|seqState
operator|->
name|DStream
argument_list|)
expr_stmt|;
name|seq
operator|.
name|litLength
operator|=
name|LL_base
index|[
name|llCode
index|]
operator|+
operator|(
operator|(
name|llCode
operator|>
literal|15
operator|)
condition|?
name|BIT_readBitsFast
argument_list|(
operator|&
name|seqState
operator|->
name|DStream
argument_list|,
name|llBits
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
comment|/*<=  16 bits */
if|if
condition|(
name|MEM_32bits
argument_list|()
operator|||
operator|(
name|totalBits
operator|>
literal|64
operator|-
literal|7
operator|-
operator|(
name|LLFSELog
operator|+
name|MLFSELog
operator|+
name|OffFSELog
operator|)
operator|)
condition|)
name|BIT_reloadDStream
argument_list|(
operator|&
name|seqState
operator|->
name|DStream
argument_list|)
expr_stmt|;
comment|/* ANS state update */
name|FSE_updateState
argument_list|(
operator|&
name|seqState
operator|->
name|stateLL
argument_list|,
operator|&
name|seqState
operator|->
name|DStream
argument_list|)
expr_stmt|;
comment|/*<=  9 bits */
name|FSE_updateState
argument_list|(
operator|&
name|seqState
operator|->
name|stateML
argument_list|,
operator|&
name|seqState
operator|->
name|DStream
argument_list|)
expr_stmt|;
comment|/*<=  9 bits */
if|if
condition|(
name|MEM_32bits
argument_list|()
condition|)
name|BIT_reloadDStream
argument_list|(
operator|&
name|seqState
operator|->
name|DStream
argument_list|)
expr_stmt|;
comment|/*<= 18 bits */
name|FSE_updateState
argument_list|(
operator|&
name|seqState
operator|->
name|stateOffb
argument_list|,
operator|&
name|seqState
operator|->
name|DStream
argument_list|)
expr_stmt|;
comment|/*<=  8 bits */
return|return
name|seq
return|;
block|}
end_function

begin_function
name|FORCE_INLINE
name|size_t
name|ZSTD_execSequence
parameter_list|(
name|BYTE
modifier|*
name|op
parameter_list|,
name|BYTE
modifier|*
specifier|const
name|oend
parameter_list|,
name|seq_t
name|sequence
parameter_list|,
specifier|const
name|BYTE
modifier|*
modifier|*
name|litPtr
parameter_list|,
specifier|const
name|BYTE
modifier|*
specifier|const
name|litLimit
parameter_list|,
specifier|const
name|BYTE
modifier|*
specifier|const
name|base
parameter_list|,
specifier|const
name|BYTE
modifier|*
specifier|const
name|vBase
parameter_list|,
specifier|const
name|BYTE
modifier|*
specifier|const
name|dictEnd
parameter_list|)
block|{
name|BYTE
modifier|*
specifier|const
name|oLitEnd
init|=
name|op
operator|+
name|sequence
operator|.
name|litLength
decl_stmt|;
name|size_t
specifier|const
name|sequenceLength
init|=
name|sequence
operator|.
name|litLength
operator|+
name|sequence
operator|.
name|matchLength
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|oMatchEnd
init|=
name|op
operator|+
name|sequenceLength
decl_stmt|;
comment|/* risk : address space overflow (32-bits) */
name|BYTE
modifier|*
specifier|const
name|oend_w
init|=
name|oend
operator|-
name|WILDCOPY_OVERLENGTH
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|iLitEnd
init|=
operator|*
name|litPtr
operator|+
name|sequence
operator|.
name|litLength
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|match
init|=
name|oLitEnd
operator|-
name|sequence
operator|.
name|offset
decl_stmt|;
comment|/* check */
if|if
condition|(
name|oMatchEnd
operator|>
name|oend
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
comment|/* last match must start at a minimum distance of WILDCOPY_OVERLENGTH from oend */
if|if
condition|(
name|iLitEnd
operator|>
name|litLimit
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* over-read beyond lit buffer */
if|if
condition|(
name|oLitEnd
operator|>
name|oend_w
condition|)
return|return
name|ZSTD_execSequenceLast7
argument_list|(
name|op
argument_list|,
name|oend
argument_list|,
name|sequence
argument_list|,
name|litPtr
argument_list|,
name|litLimit
argument_list|,
name|base
argument_list|,
name|vBase
argument_list|,
name|dictEnd
argument_list|)
return|;
comment|/* copy Literals */
name|ZSTD_copy8
argument_list|(
name|op
argument_list|,
operator|*
name|litPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sequence
operator|.
name|litLength
operator|>
literal|8
condition|)
name|ZSTD_wildcopy
argument_list|(
name|op
operator|+
literal|8
argument_list|,
operator|(
operator|*
name|litPtr
operator|)
operator|+
literal|8
argument_list|,
name|sequence
operator|.
name|litLength
operator|-
literal|8
argument_list|)
expr_stmt|;
comment|/* note : since oLitEnd<= oend-WILDCOPY_OVERLENGTH, no risk of overwrite beyond oend */
name|op
operator|=
name|oLitEnd
expr_stmt|;
operator|*
name|litPtr
operator|=
name|iLitEnd
expr_stmt|;
comment|/* update for next sequence */
comment|/* copy Match */
if|if
condition|(
name|sequence
operator|.
name|offset
operator|>
call|(
name|size_t
call|)
argument_list|(
name|oLitEnd
operator|-
name|base
argument_list|)
condition|)
block|{
comment|/* offset beyond prefix */
if|if
condition|(
name|sequence
operator|.
name|offset
operator|>
call|(
name|size_t
call|)
argument_list|(
name|oLitEnd
operator|-
name|vBase
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
name|match
operator|=
name|dictEnd
operator|+
operator|(
name|match
operator|-
name|base
operator|)
expr_stmt|;
if|if
condition|(
name|match
operator|+
name|sequence
operator|.
name|matchLength
operator|<=
name|dictEnd
condition|)
block|{
name|memmove
argument_list|(
name|oLitEnd
argument_list|,
name|match
argument_list|,
name|sequence
operator|.
name|matchLength
argument_list|)
expr_stmt|;
return|return
name|sequenceLength
return|;
block|}
comment|/* span extDict& currentPrefixSegment */
block|{
name|size_t
specifier|const
name|length1
init|=
name|dictEnd
operator|-
name|match
decl_stmt|;
name|memmove
argument_list|(
name|oLitEnd
argument_list|,
name|match
argument_list|,
name|length1
argument_list|)
expr_stmt|;
name|op
operator|=
name|oLitEnd
operator|+
name|length1
expr_stmt|;
name|sequence
operator|.
name|matchLength
operator|-=
name|length1
expr_stmt|;
name|match
operator|=
name|base
expr_stmt|;
if|if
condition|(
name|op
operator|>
name|oend_w
operator|||
name|sequence
operator|.
name|matchLength
operator|<
name|MINMATCH
condition|)
block|{
name|U32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sequence
operator|.
name|matchLength
condition|;
operator|++
name|i
control|)
name|op
index|[
name|i
index|]
operator|=
name|match
index|[
name|i
index|]
expr_stmt|;
return|return
name|sequenceLength
return|;
block|}
block|}
block|}
comment|/* Requirement: op<= oend_w&& sequence.matchLength>= MINMATCH */
comment|/* match within prefix */
if|if
condition|(
name|sequence
operator|.
name|offset
operator|<
literal|8
condition|)
block|{
comment|/* close range match, overlap */
specifier|static
specifier|const
name|U32
name|dec32table
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|}
decl_stmt|;
comment|/* added */
specifier|static
specifier|const
name|int
name|dec64table
index|[]
init|=
block|{
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|}
decl_stmt|;
comment|/* subtracted */
name|int
specifier|const
name|sub2
init|=
name|dec64table
index|[
name|sequence
operator|.
name|offset
index|]
decl_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|match
index|[
literal|0
index|]
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|match
index|[
literal|1
index|]
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|match
index|[
literal|2
index|]
expr_stmt|;
name|op
index|[
literal|3
index|]
operator|=
name|match
index|[
literal|3
index|]
expr_stmt|;
name|match
operator|+=
name|dec32table
index|[
name|sequence
operator|.
name|offset
index|]
expr_stmt|;
name|ZSTD_copy4
argument_list|(
name|op
operator|+
literal|4
argument_list|,
name|match
argument_list|)
expr_stmt|;
name|match
operator|-=
name|sub2
expr_stmt|;
block|}
else|else
block|{
name|ZSTD_copy8
argument_list|(
name|op
argument_list|,
name|match
argument_list|)
expr_stmt|;
block|}
name|op
operator|+=
literal|8
expr_stmt|;
name|match
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|oMatchEnd
operator|>
name|oend
operator|-
operator|(
literal|16
operator|-
name|MINMATCH
operator|)
condition|)
block|{
if|if
condition|(
name|op
operator|<
name|oend_w
condition|)
block|{
name|ZSTD_wildcopy
argument_list|(
name|op
argument_list|,
name|match
argument_list|,
name|oend_w
operator|-
name|op
argument_list|)
expr_stmt|;
name|match
operator|+=
name|oend_w
operator|-
name|op
expr_stmt|;
name|op
operator|=
name|oend_w
expr_stmt|;
block|}
while|while
condition|(
name|op
operator|<
name|oMatchEnd
condition|)
operator|*
name|op
operator|++
operator|=
operator|*
name|match
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ZSTD_wildcopy
argument_list|(
name|op
argument_list|,
name|match
argument_list|,
operator|(
name|ptrdiff_t
operator|)
name|sequence
operator|.
name|matchLength
operator|-
literal|8
argument_list|)
expr_stmt|;
comment|/* works even if matchLength< 8 */
block|}
return|return
name|sequenceLength
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|ZSTD_decompressSequences
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|seqStart
parameter_list|,
name|size_t
name|seqSize
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|seqStart
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|iend
init|=
name|ip
operator|+
name|seqSize
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|ostart
init|=
operator|(
name|BYTE
operator|*
specifier|const
operator|)
name|dst
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|oend
init|=
name|ostart
operator|+
name|maxDstSize
decl_stmt|;
name|BYTE
modifier|*
name|op
init|=
name|ostart
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|litPtr
init|=
name|dctx
operator|->
name|litPtr
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|litEnd
init|=
name|litPtr
operator|+
name|dctx
operator|->
name|litSize
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|base
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|dctx
operator|->
name|base
operator|)
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|vBase
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|dctx
operator|->
name|vBase
operator|)
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|dictEnd
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|dctx
operator|->
name|dictEnd
operator|)
decl_stmt|;
name|int
name|nbSeq
decl_stmt|;
comment|/* Build Decoding Tables */
block|{
name|size_t
specifier|const
name|seqHSize
init|=
name|ZSTD_decodeSeqHeaders
argument_list|(
name|dctx
argument_list|,
operator|&
name|nbSeq
argument_list|,
name|ip
argument_list|,
name|seqSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|seqHSize
argument_list|)
condition|)
return|return
name|seqHSize
return|;
name|ip
operator|+=
name|seqHSize
expr_stmt|;
block|}
comment|/* Regen sequences */
if|if
condition|(
name|nbSeq
condition|)
block|{
name|seqState_t
name|seqState
decl_stmt|;
name|dctx
operator|->
name|fseEntropy
operator|=
literal|1
expr_stmt|;
block|{
name|U32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ZSTD_REP_NUM
condition|;
name|i
operator|++
control|)
name|seqState
operator|.
name|prevOffset
index|[
name|i
index|]
operator|=
name|dctx
operator|->
name|entropy
operator|.
name|rep
index|[
name|i
index|]
expr_stmt|;
block|}
name|CHECK_E
argument_list|(
name|BIT_initDStream
argument_list|(
operator|&
name|seqState
operator|.
name|DStream
argument_list|,
name|ip
argument_list|,
name|iend
operator|-
name|ip
argument_list|)
argument_list|,
name|corruption_detected
argument_list|)
expr_stmt|;
name|FSE_initDState
argument_list|(
operator|&
name|seqState
operator|.
name|stateLL
argument_list|,
operator|&
name|seqState
operator|.
name|DStream
argument_list|,
name|dctx
operator|->
name|LLTptr
argument_list|)
expr_stmt|;
name|FSE_initDState
argument_list|(
operator|&
name|seqState
operator|.
name|stateOffb
argument_list|,
operator|&
name|seqState
operator|.
name|DStream
argument_list|,
name|dctx
operator|->
name|OFTptr
argument_list|)
expr_stmt|;
name|FSE_initDState
argument_list|(
operator|&
name|seqState
operator|.
name|stateML
argument_list|,
operator|&
name|seqState
operator|.
name|DStream
argument_list|,
name|dctx
operator|->
name|MLTptr
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|(
name|BIT_reloadDStream
argument_list|(
operator|&
operator|(
name|seqState
operator|.
name|DStream
operator|)
argument_list|)
operator|<=
name|BIT_DStream_completed
operator|)
operator|&&
name|nbSeq
condition|;
control|)
block|{
name|nbSeq
operator|--
expr_stmt|;
block|{
name|seq_t
specifier|const
name|sequence
init|=
name|ZSTD_decodeSequence
argument_list|(
operator|&
name|seqState
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|oneSeqSize
init|=
name|ZSTD_execSequence
argument_list|(
name|op
argument_list|,
name|oend
argument_list|,
name|sequence
argument_list|,
operator|&
name|litPtr
argument_list|,
name|litEnd
argument_list|,
name|base
argument_list|,
name|vBase
argument_list|,
name|dictEnd
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|oneSeqSize
argument_list|)
condition|)
return|return
name|oneSeqSize
return|;
name|op
operator|+=
name|oneSeqSize
expr_stmt|;
block|}
block|}
comment|/* check if reached exact end */
if|if
condition|(
name|nbSeq
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* save reps for next block */
block|{
name|U32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ZSTD_REP_NUM
condition|;
name|i
operator|++
control|)
name|dctx
operator|->
name|entropy
operator|.
name|rep
index|[
name|i
index|]
operator|=
call|(
name|U32
call|)
argument_list|(
name|seqState
operator|.
name|prevOffset
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* last literal segment */
block|{
name|size_t
specifier|const
name|lastLLSize
init|=
name|litEnd
operator|-
name|litPtr
decl_stmt|;
if|if
condition|(
name|lastLLSize
operator|>
call|(
name|size_t
call|)
argument_list|(
name|oend
operator|-
name|op
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
name|memcpy
argument_list|(
name|op
argument_list|,
name|litPtr
argument_list|,
name|lastLLSize
argument_list|)
expr_stmt|;
name|op
operator|+=
name|lastLLSize
expr_stmt|;
block|}
return|return
name|op
operator|-
name|ostart
return|;
block|}
end_function

begin_function
name|FORCE_INLINE
name|seq_t
name|ZSTD_decodeSequenceLong_generic
parameter_list|(
name|seqState_t
modifier|*
name|seqState
parameter_list|,
name|int
specifier|const
name|longOffsets
parameter_list|)
block|{
name|seq_t
name|seq
decl_stmt|;
name|U32
specifier|const
name|llCode
init|=
name|FSE_peekSymbol
argument_list|(
operator|&
name|seqState
operator|->
name|stateLL
argument_list|)
decl_stmt|;
name|U32
specifier|const
name|mlCode
init|=
name|FSE_peekSymbol
argument_list|(
operator|&
name|seqState
operator|->
name|stateML
argument_list|)
decl_stmt|;
name|U32
specifier|const
name|ofCode
init|=
name|FSE_peekSymbol
argument_list|(
operator|&
name|seqState
operator|->
name|stateOffb
argument_list|)
decl_stmt|;
comment|/*<= maxOff, by table construction */
name|U32
specifier|const
name|llBits
init|=
name|LL_bits
index|[
name|llCode
index|]
decl_stmt|;
name|U32
specifier|const
name|mlBits
init|=
name|ML_bits
index|[
name|mlCode
index|]
decl_stmt|;
name|U32
specifier|const
name|ofBits
init|=
name|ofCode
decl_stmt|;
name|U32
specifier|const
name|totalBits
init|=
name|llBits
operator|+
name|mlBits
operator|+
name|ofBits
decl_stmt|;
specifier|static
specifier|const
name|U32
name|LL_base
index|[
name|MaxLL
operator|+
literal|1
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|18
block|,
literal|20
block|,
literal|22
block|,
literal|24
block|,
literal|28
block|,
literal|32
block|,
literal|40
block|,
literal|48
block|,
literal|64
block|,
literal|0x80
block|,
literal|0x100
block|,
literal|0x200
block|,
literal|0x400
block|,
literal|0x800
block|,
literal|0x1000
block|,
literal|0x2000
block|,
literal|0x4000
block|,
literal|0x8000
block|,
literal|0x10000
block|}
decl_stmt|;
specifier|static
specifier|const
name|U32
name|ML_base
index|[
name|MaxML
operator|+
literal|1
index|]
init|=
block|{
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|37
block|,
literal|39
block|,
literal|41
block|,
literal|43
block|,
literal|47
block|,
literal|51
block|,
literal|59
block|,
literal|67
block|,
literal|83
block|,
literal|99
block|,
literal|0x83
block|,
literal|0x103
block|,
literal|0x203
block|,
literal|0x403
block|,
literal|0x803
block|,
literal|0x1003
block|,
literal|0x2003
block|,
literal|0x4003
block|,
literal|0x8003
block|,
literal|0x10003
block|}
decl_stmt|;
specifier|static
specifier|const
name|U32
name|OF_base
index|[
name|MaxOff
operator|+
literal|1
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|5
block|,
literal|0xD
block|,
literal|0x1D
block|,
literal|0x3D
block|,
literal|0x7D
block|,
literal|0xFD
block|,
literal|0x1FD
block|,
literal|0x3FD
block|,
literal|0x7FD
block|,
literal|0xFFD
block|,
literal|0x1FFD
block|,
literal|0x3FFD
block|,
literal|0x7FFD
block|,
literal|0xFFFD
block|,
literal|0x1FFFD
block|,
literal|0x3FFFD
block|,
literal|0x7FFFD
block|,
literal|0xFFFFD
block|,
literal|0x1FFFFD
block|,
literal|0x3FFFFD
block|,
literal|0x7FFFFD
block|,
literal|0xFFFFFD
block|,
literal|0x1FFFFFD
block|,
literal|0x3FFFFFD
block|,
literal|0x7FFFFFD
block|,
literal|0xFFFFFFD
block|}
decl_stmt|;
comment|/* sequence */
block|{
name|size_t
name|offset
decl_stmt|;
if|if
condition|(
operator|!
name|ofCode
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|longOffsets
condition|)
block|{
name|int
specifier|const
name|extraBits
init|=
name|ofBits
operator|-
name|MIN
argument_list|(
name|ofBits
argument_list|,
name|STREAM_ACCUMULATOR_MIN
argument_list|)
decl_stmt|;
name|offset
operator|=
name|OF_base
index|[
name|ofCode
index|]
operator|+
operator|(
name|BIT_readBitsFast
argument_list|(
operator|&
name|seqState
operator|->
name|DStream
argument_list|,
name|ofBits
operator|-
name|extraBits
argument_list|)
operator|<<
name|extraBits
operator|)
expr_stmt|;
if|if
condition|(
name|MEM_32bits
argument_list|()
operator|||
name|extraBits
condition|)
name|BIT_reloadDStream
argument_list|(
operator|&
name|seqState
operator|->
name|DStream
argument_list|)
expr_stmt|;
if|if
condition|(
name|extraBits
condition|)
name|offset
operator|+=
name|BIT_readBitsFast
argument_list|(
operator|&
name|seqState
operator|->
name|DStream
argument_list|,
name|extraBits
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|=
name|OF_base
index|[
name|ofCode
index|]
operator|+
name|BIT_readBitsFast
argument_list|(
operator|&
name|seqState
operator|->
name|DStream
argument_list|,
name|ofBits
argument_list|)
expr_stmt|;
comment|/*<=  (ZSTD_WINDOWLOG_MAX-1) bits */
if|if
condition|(
name|MEM_32bits
argument_list|()
condition|)
name|BIT_reloadDStream
argument_list|(
operator|&
name|seqState
operator|->
name|DStream
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ofCode
operator|<=
literal|1
condition|)
block|{
name|offset
operator|+=
operator|(
name|llCode
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|offset
condition|)
block|{
name|size_t
name|temp
init|=
operator|(
name|offset
operator|==
literal|3
operator|)
condition|?
name|seqState
operator|->
name|prevOffset
index|[
literal|0
index|]
operator|-
literal|1
else|:
name|seqState
operator|->
name|prevOffset
index|[
name|offset
index|]
decl_stmt|;
name|temp
operator|+=
operator|!
name|temp
expr_stmt|;
comment|/* 0 is not valid; input is corrupted; force offset to 1 */
if|if
condition|(
name|offset
operator|!=
literal|1
condition|)
name|seqState
operator|->
name|prevOffset
index|[
literal|2
index|]
operator|=
name|seqState
operator|->
name|prevOffset
index|[
literal|1
index|]
expr_stmt|;
name|seqState
operator|->
name|prevOffset
index|[
literal|1
index|]
operator|=
name|seqState
operator|->
name|prevOffset
index|[
literal|0
index|]
expr_stmt|;
name|seqState
operator|->
name|prevOffset
index|[
literal|0
index|]
operator|=
name|offset
operator|=
name|temp
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|=
name|seqState
operator|->
name|prevOffset
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|seqState
operator|->
name|prevOffset
index|[
literal|2
index|]
operator|=
name|seqState
operator|->
name|prevOffset
index|[
literal|1
index|]
expr_stmt|;
name|seqState
operator|->
name|prevOffset
index|[
literal|1
index|]
operator|=
name|seqState
operator|->
name|prevOffset
index|[
literal|0
index|]
expr_stmt|;
name|seqState
operator|->
name|prevOffset
index|[
literal|0
index|]
operator|=
name|offset
expr_stmt|;
block|}
name|seq
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
block|}
name|seq
operator|.
name|matchLength
operator|=
name|ML_base
index|[
name|mlCode
index|]
operator|+
operator|(
operator|(
name|mlCode
operator|>
literal|31
operator|)
condition|?
name|BIT_readBitsFast
argument_list|(
operator|&
name|seqState
operator|->
name|DStream
argument_list|,
name|mlBits
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
comment|/*<=  16 bits */
if|if
condition|(
name|MEM_32bits
argument_list|()
operator|&&
operator|(
name|mlBits
operator|+
name|llBits
operator|>
literal|24
operator|)
condition|)
name|BIT_reloadDStream
argument_list|(
operator|&
name|seqState
operator|->
name|DStream
argument_list|)
expr_stmt|;
name|seq
operator|.
name|litLength
operator|=
name|LL_base
index|[
name|llCode
index|]
operator|+
operator|(
operator|(
name|llCode
operator|>
literal|15
operator|)
condition|?
name|BIT_readBitsFast
argument_list|(
operator|&
name|seqState
operator|->
name|DStream
argument_list|,
name|llBits
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
comment|/*<=  16 bits */
if|if
condition|(
name|MEM_32bits
argument_list|()
operator|||
operator|(
name|totalBits
operator|>
literal|64
operator|-
literal|7
operator|-
operator|(
name|LLFSELog
operator|+
name|MLFSELog
operator|+
name|OffFSELog
operator|)
operator|)
condition|)
name|BIT_reloadDStream
argument_list|(
operator|&
name|seqState
operator|->
name|DStream
argument_list|)
expr_stmt|;
block|{
name|size_t
specifier|const
name|pos
init|=
name|seqState
operator|->
name|pos
operator|+
name|seq
operator|.
name|litLength
decl_stmt|;
name|seq
operator|.
name|match
operator|=
name|seqState
operator|->
name|base
operator|+
name|pos
operator|-
name|seq
operator|.
name|offset
expr_stmt|;
comment|/* single memory segment */
if|if
condition|(
name|seq
operator|.
name|offset
operator|>
name|pos
condition|)
name|seq
operator|.
name|match
operator|+=
name|seqState
operator|->
name|gotoDict
expr_stmt|;
comment|/* separate memory segment */
name|seqState
operator|->
name|pos
operator|=
name|pos
operator|+
name|seq
operator|.
name|matchLength
expr_stmt|;
block|}
comment|/* ANS state update */
name|FSE_updateState
argument_list|(
operator|&
name|seqState
operator|->
name|stateLL
argument_list|,
operator|&
name|seqState
operator|->
name|DStream
argument_list|)
expr_stmt|;
comment|/*<=  9 bits */
name|FSE_updateState
argument_list|(
operator|&
name|seqState
operator|->
name|stateML
argument_list|,
operator|&
name|seqState
operator|->
name|DStream
argument_list|)
expr_stmt|;
comment|/*<=  9 bits */
if|if
condition|(
name|MEM_32bits
argument_list|()
condition|)
name|BIT_reloadDStream
argument_list|(
operator|&
name|seqState
operator|->
name|DStream
argument_list|)
expr_stmt|;
comment|/*<= 18 bits */
name|FSE_updateState
argument_list|(
operator|&
name|seqState
operator|->
name|stateOffb
argument_list|,
operator|&
name|seqState
operator|->
name|DStream
argument_list|)
expr_stmt|;
comment|/*<=  8 bits */
return|return
name|seq
return|;
block|}
end_function

begin_function
specifier|static
name|seq_t
name|ZSTD_decodeSequenceLong
parameter_list|(
name|seqState_t
modifier|*
name|seqState
parameter_list|,
name|unsigned
specifier|const
name|windowSize
parameter_list|)
block|{
if|if
condition|(
name|ZSTD_highbit32
argument_list|(
name|windowSize
argument_list|)
operator|>
name|STREAM_ACCUMULATOR_MIN
condition|)
block|{
return|return
name|ZSTD_decodeSequenceLong_generic
argument_list|(
name|seqState
argument_list|,
literal|1
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|ZSTD_decodeSequenceLong_generic
argument_list|(
name|seqState
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|FORCE_INLINE
name|size_t
name|ZSTD_execSequenceLong
parameter_list|(
name|BYTE
modifier|*
name|op
parameter_list|,
name|BYTE
modifier|*
specifier|const
name|oend
parameter_list|,
name|seq_t
name|sequence
parameter_list|,
specifier|const
name|BYTE
modifier|*
modifier|*
name|litPtr
parameter_list|,
specifier|const
name|BYTE
modifier|*
specifier|const
name|litLimit
parameter_list|,
specifier|const
name|BYTE
modifier|*
specifier|const
name|base
parameter_list|,
specifier|const
name|BYTE
modifier|*
specifier|const
name|vBase
parameter_list|,
specifier|const
name|BYTE
modifier|*
specifier|const
name|dictEnd
parameter_list|)
block|{
name|BYTE
modifier|*
specifier|const
name|oLitEnd
init|=
name|op
operator|+
name|sequence
operator|.
name|litLength
decl_stmt|;
name|size_t
specifier|const
name|sequenceLength
init|=
name|sequence
operator|.
name|litLength
operator|+
name|sequence
operator|.
name|matchLength
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|oMatchEnd
init|=
name|op
operator|+
name|sequenceLength
decl_stmt|;
comment|/* risk : address space overflow (32-bits) */
name|BYTE
modifier|*
specifier|const
name|oend_w
init|=
name|oend
operator|-
name|WILDCOPY_OVERLENGTH
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|iLitEnd
init|=
operator|*
name|litPtr
operator|+
name|sequence
operator|.
name|litLength
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|match
init|=
name|sequence
operator|.
name|match
decl_stmt|;
comment|/* check */
if|#
directive|if
literal|1
if|if
condition|(
name|oMatchEnd
operator|>
name|oend
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
comment|/* last match must start at a minimum distance of WILDCOPY_OVERLENGTH from oend */
if|if
condition|(
name|iLitEnd
operator|>
name|litLimit
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* over-read beyond lit buffer */
if|if
condition|(
name|oLitEnd
operator|>
name|oend_w
condition|)
return|return
name|ZSTD_execSequenceLast7
argument_list|(
name|op
argument_list|,
name|oend
argument_list|,
name|sequence
argument_list|,
name|litPtr
argument_list|,
name|litLimit
argument_list|,
name|base
argument_list|,
name|vBase
argument_list|,
name|dictEnd
argument_list|)
return|;
endif|#
directive|endif
comment|/* copy Literals */
name|ZSTD_copy8
argument_list|(
name|op
argument_list|,
operator|*
name|litPtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sequence
operator|.
name|litLength
operator|>
literal|8
condition|)
name|ZSTD_wildcopy
argument_list|(
name|op
operator|+
literal|8
argument_list|,
operator|(
operator|*
name|litPtr
operator|)
operator|+
literal|8
argument_list|,
name|sequence
operator|.
name|litLength
operator|-
literal|8
argument_list|)
expr_stmt|;
comment|/* note : since oLitEnd<= oend-WILDCOPY_OVERLENGTH, no risk of overwrite beyond oend */
name|op
operator|=
name|oLitEnd
expr_stmt|;
operator|*
name|litPtr
operator|=
name|iLitEnd
expr_stmt|;
comment|/* update for next sequence */
comment|/* copy Match */
if|#
directive|if
literal|1
if|if
condition|(
name|sequence
operator|.
name|offset
operator|>
call|(
name|size_t
call|)
argument_list|(
name|oLitEnd
operator|-
name|base
argument_list|)
condition|)
block|{
comment|/* offset beyond prefix */
if|if
condition|(
name|sequence
operator|.
name|offset
operator|>
call|(
name|size_t
call|)
argument_list|(
name|oLitEnd
operator|-
name|vBase
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
if|if
condition|(
name|match
operator|+
name|sequence
operator|.
name|matchLength
operator|<=
name|dictEnd
condition|)
block|{
name|memmove
argument_list|(
name|oLitEnd
argument_list|,
name|match
argument_list|,
name|sequence
operator|.
name|matchLength
argument_list|)
expr_stmt|;
return|return
name|sequenceLength
return|;
block|}
comment|/* span extDict& currentPrefixSegment */
block|{
name|size_t
specifier|const
name|length1
init|=
name|dictEnd
operator|-
name|match
decl_stmt|;
name|memmove
argument_list|(
name|oLitEnd
argument_list|,
name|match
argument_list|,
name|length1
argument_list|)
expr_stmt|;
name|op
operator|=
name|oLitEnd
operator|+
name|length1
expr_stmt|;
name|sequence
operator|.
name|matchLength
operator|-=
name|length1
expr_stmt|;
name|match
operator|=
name|base
expr_stmt|;
if|if
condition|(
name|op
operator|>
name|oend_w
operator|||
name|sequence
operator|.
name|matchLength
operator|<
name|MINMATCH
condition|)
block|{
name|U32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sequence
operator|.
name|matchLength
condition|;
operator|++
name|i
control|)
name|op
index|[
name|i
index|]
operator|=
name|match
index|[
name|i
index|]
expr_stmt|;
return|return
name|sequenceLength
return|;
block|}
block|}
block|}
comment|/* Requirement: op<= oend_w&& sequence.matchLength>= MINMATCH */
endif|#
directive|endif
comment|/* match within prefix */
if|if
condition|(
name|sequence
operator|.
name|offset
operator|<
literal|8
condition|)
block|{
comment|/* close range match, overlap */
specifier|static
specifier|const
name|U32
name|dec32table
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|}
decl_stmt|;
comment|/* added */
specifier|static
specifier|const
name|int
name|dec64table
index|[]
init|=
block|{
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|}
decl_stmt|;
comment|/* subtracted */
name|int
specifier|const
name|sub2
init|=
name|dec64table
index|[
name|sequence
operator|.
name|offset
index|]
decl_stmt|;
name|op
index|[
literal|0
index|]
operator|=
name|match
index|[
literal|0
index|]
expr_stmt|;
name|op
index|[
literal|1
index|]
operator|=
name|match
index|[
literal|1
index|]
expr_stmt|;
name|op
index|[
literal|2
index|]
operator|=
name|match
index|[
literal|2
index|]
expr_stmt|;
name|op
index|[
literal|3
index|]
operator|=
name|match
index|[
literal|3
index|]
expr_stmt|;
name|match
operator|+=
name|dec32table
index|[
name|sequence
operator|.
name|offset
index|]
expr_stmt|;
name|ZSTD_copy4
argument_list|(
name|op
operator|+
literal|4
argument_list|,
name|match
argument_list|)
expr_stmt|;
name|match
operator|-=
name|sub2
expr_stmt|;
block|}
else|else
block|{
name|ZSTD_copy8
argument_list|(
name|op
argument_list|,
name|match
argument_list|)
expr_stmt|;
block|}
name|op
operator|+=
literal|8
expr_stmt|;
name|match
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|oMatchEnd
operator|>
name|oend
operator|-
operator|(
literal|16
operator|-
name|MINMATCH
operator|)
condition|)
block|{
if|if
condition|(
name|op
operator|<
name|oend_w
condition|)
block|{
name|ZSTD_wildcopy
argument_list|(
name|op
argument_list|,
name|match
argument_list|,
name|oend_w
operator|-
name|op
argument_list|)
expr_stmt|;
name|match
operator|+=
name|oend_w
operator|-
name|op
expr_stmt|;
name|op
operator|=
name|oend_w
expr_stmt|;
block|}
while|while
condition|(
name|op
operator|<
name|oMatchEnd
condition|)
operator|*
name|op
operator|++
operator|=
operator|*
name|match
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ZSTD_wildcopy
argument_list|(
name|op
argument_list|,
name|match
argument_list|,
operator|(
name|ptrdiff_t
operator|)
name|sequence
operator|.
name|matchLength
operator|-
literal|8
argument_list|)
expr_stmt|;
comment|/* works even if matchLength< 8 */
block|}
return|return
name|sequenceLength
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|ZSTD_decompressSequencesLong
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|seqStart
parameter_list|,
name|size_t
name|seqSize
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|seqStart
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|iend
init|=
name|ip
operator|+
name|seqSize
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|ostart
init|=
operator|(
name|BYTE
operator|*
specifier|const
operator|)
name|dst
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|oend
init|=
name|ostart
operator|+
name|maxDstSize
decl_stmt|;
name|BYTE
modifier|*
name|op
init|=
name|ostart
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|litPtr
init|=
name|dctx
operator|->
name|litPtr
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|litEnd
init|=
name|litPtr
operator|+
name|dctx
operator|->
name|litSize
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|base
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|dctx
operator|->
name|base
operator|)
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|vBase
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|dctx
operator|->
name|vBase
operator|)
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|dictEnd
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
name|dctx
operator|->
name|dictEnd
operator|)
decl_stmt|;
name|unsigned
specifier|const
name|windowSize
init|=
name|dctx
operator|->
name|fParams
operator|.
name|windowSize
decl_stmt|;
name|int
name|nbSeq
decl_stmt|;
comment|/* Build Decoding Tables */
block|{
name|size_t
specifier|const
name|seqHSize
init|=
name|ZSTD_decodeSeqHeaders
argument_list|(
name|dctx
argument_list|,
operator|&
name|nbSeq
argument_list|,
name|ip
argument_list|,
name|seqSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|seqHSize
argument_list|)
condition|)
return|return
name|seqHSize
return|;
name|ip
operator|+=
name|seqHSize
expr_stmt|;
block|}
comment|/* Regen sequences */
if|if
condition|(
name|nbSeq
condition|)
block|{
define|#
directive|define
name|STORED_SEQS
value|4
define|#
directive|define
name|STOSEQ_MASK
value|(STORED_SEQS-1)
define|#
directive|define
name|ADVANCED_SEQS
value|4
name|seq_t
name|sequences
index|[
name|STORED_SEQS
index|]
decl_stmt|;
name|int
specifier|const
name|seqAdvance
init|=
name|MIN
argument_list|(
name|nbSeq
argument_list|,
name|ADVANCED_SEQS
argument_list|)
decl_stmt|;
name|seqState_t
name|seqState
decl_stmt|;
name|int
name|seqNb
decl_stmt|;
name|dctx
operator|->
name|fseEntropy
operator|=
literal|1
expr_stmt|;
block|{
name|U32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ZSTD_REP_NUM
condition|;
name|i
operator|++
control|)
name|seqState
operator|.
name|prevOffset
index|[
name|i
index|]
operator|=
name|dctx
operator|->
name|entropy
operator|.
name|rep
index|[
name|i
index|]
expr_stmt|;
block|}
name|seqState
operator|.
name|base
operator|=
name|base
expr_stmt|;
name|seqState
operator|.
name|pos
operator|=
call|(
name|size_t
call|)
argument_list|(
name|op
operator|-
name|base
argument_list|)
expr_stmt|;
name|seqState
operator|.
name|gotoDict
operator|=
operator|(
name|uPtrDiff
operator|)
name|dictEnd
operator|-
operator|(
name|uPtrDiff
operator|)
name|base
expr_stmt|;
comment|/* cast to avoid undefined behaviour */
name|CHECK_E
argument_list|(
name|BIT_initDStream
argument_list|(
operator|&
name|seqState
operator|.
name|DStream
argument_list|,
name|ip
argument_list|,
name|iend
operator|-
name|ip
argument_list|)
argument_list|,
name|corruption_detected
argument_list|)
expr_stmt|;
name|FSE_initDState
argument_list|(
operator|&
name|seqState
operator|.
name|stateLL
argument_list|,
operator|&
name|seqState
operator|.
name|DStream
argument_list|,
name|dctx
operator|->
name|LLTptr
argument_list|)
expr_stmt|;
name|FSE_initDState
argument_list|(
operator|&
name|seqState
operator|.
name|stateOffb
argument_list|,
operator|&
name|seqState
operator|.
name|DStream
argument_list|,
name|dctx
operator|->
name|OFTptr
argument_list|)
expr_stmt|;
name|FSE_initDState
argument_list|(
operator|&
name|seqState
operator|.
name|stateML
argument_list|,
operator|&
name|seqState
operator|.
name|DStream
argument_list|,
name|dctx
operator|->
name|MLTptr
argument_list|)
expr_stmt|;
comment|/* prepare in advance */
for|for
control|(
name|seqNb
operator|=
literal|0
init|;
operator|(
name|BIT_reloadDStream
argument_list|(
operator|&
name|seqState
operator|.
name|DStream
argument_list|)
operator|<=
name|BIT_DStream_completed
operator|)
operator|&&
name|seqNb
operator|<
name|seqAdvance
condition|;
name|seqNb
operator|++
control|)
block|{
name|sequences
index|[
name|seqNb
index|]
operator|=
name|ZSTD_decodeSequenceLong
argument_list|(
operator|&
name|seqState
argument_list|,
name|windowSize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|seqNb
operator|<
name|seqAdvance
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* decode and decompress */
for|for
control|(
init|;
operator|(
name|BIT_reloadDStream
argument_list|(
operator|&
operator|(
name|seqState
operator|.
name|DStream
operator|)
argument_list|)
operator|<=
name|BIT_DStream_completed
operator|)
operator|&&
name|seqNb
operator|<
name|nbSeq
condition|;
name|seqNb
operator|++
control|)
block|{
name|seq_t
specifier|const
name|sequence
init|=
name|ZSTD_decodeSequenceLong
argument_list|(
operator|&
name|seqState
argument_list|,
name|windowSize
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|oneSeqSize
init|=
name|ZSTD_execSequenceLong
argument_list|(
name|op
argument_list|,
name|oend
argument_list|,
name|sequences
index|[
operator|(
name|seqNb
operator|-
name|ADVANCED_SEQS
operator|)
operator|&
name|STOSEQ_MASK
index|]
argument_list|,
operator|&
name|litPtr
argument_list|,
name|litEnd
argument_list|,
name|base
argument_list|,
name|vBase
argument_list|,
name|dictEnd
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|oneSeqSize
argument_list|)
condition|)
return|return
name|oneSeqSize
return|;
name|ZSTD_PREFETCH
argument_list|(
name|sequence
operator|.
name|match
argument_list|)
expr_stmt|;
name|sequences
index|[
name|seqNb
operator|&
name|STOSEQ_MASK
index|]
operator|=
name|sequence
expr_stmt|;
name|op
operator|+=
name|oneSeqSize
expr_stmt|;
block|}
if|if
condition|(
name|seqNb
operator|<
name|nbSeq
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* finish queue */
name|seqNb
operator|-=
name|seqAdvance
expr_stmt|;
for|for
control|(
init|;
name|seqNb
operator|<
name|nbSeq
condition|;
name|seqNb
operator|++
control|)
block|{
name|size_t
specifier|const
name|oneSeqSize
init|=
name|ZSTD_execSequenceLong
argument_list|(
name|op
argument_list|,
name|oend
argument_list|,
name|sequences
index|[
name|seqNb
operator|&
name|STOSEQ_MASK
index|]
argument_list|,
operator|&
name|litPtr
argument_list|,
name|litEnd
argument_list|,
name|base
argument_list|,
name|vBase
argument_list|,
name|dictEnd
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|oneSeqSize
argument_list|)
condition|)
return|return
name|oneSeqSize
return|;
name|op
operator|+=
name|oneSeqSize
expr_stmt|;
block|}
comment|/* save reps for next block */
block|{
name|U32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ZSTD_REP_NUM
condition|;
name|i
operator|++
control|)
name|dctx
operator|->
name|entropy
operator|.
name|rep
index|[
name|i
index|]
operator|=
call|(
name|U32
call|)
argument_list|(
name|seqState
operator|.
name|prevOffset
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* last literal segment */
block|{
name|size_t
specifier|const
name|lastLLSize
init|=
name|litEnd
operator|-
name|litPtr
decl_stmt|;
if|if
condition|(
name|lastLLSize
operator|>
call|(
name|size_t
call|)
argument_list|(
name|oend
operator|-
name|op
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
name|memcpy
argument_list|(
name|op
argument_list|,
name|litPtr
argument_list|,
name|lastLLSize
argument_list|)
expr_stmt|;
name|op
operator|+=
name|lastLLSize
expr_stmt|;
block|}
return|return
name|op
operator|-
name|ostart
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|ZSTD_decompressBlock_internal
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
comment|/* blockType == blockCompressed */
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
decl_stmt|;
if|if
condition|(
name|srcSize
operator|>=
name|ZSTD_BLOCKSIZE_ABSOLUTEMAX
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
comment|/* Decode literals section */
block|{
name|size_t
specifier|const
name|litCSize
init|=
name|ZSTD_decodeLiteralsBlock
argument_list|(
name|dctx
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|litCSize
argument_list|)
condition|)
return|return
name|litCSize
return|;
name|ip
operator|+=
name|litCSize
expr_stmt|;
name|srcSize
operator|-=
name|litCSize
expr_stmt|;
block|}
if|if
condition|(
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|>
literal|4
condition|)
comment|/* do not enable prefetching on 32-bits x86, as it's performance detrimental */
comment|/* likely because of register pressure */
comment|/* if that's the correct cause, then 32-bits ARM should be affected differently */
comment|/* it would be good to test this on ARM real hardware, to see if prefetch version improves speed */
if|if
condition|(
name|dctx
operator|->
name|fParams
operator|.
name|windowSize
operator|>
operator|(
literal|1
operator|<<
literal|23
operator|)
condition|)
return|return
name|ZSTD_decompressSequencesLong
argument_list|(
name|dctx
argument_list|,
name|dst
argument_list|,
name|dstCapacity
argument_list|,
name|ip
argument_list|,
name|srcSize
argument_list|)
return|;
return|return
name|ZSTD_decompressSequences
argument_list|(
name|dctx
argument_list|,
name|dst
argument_list|,
name|dstCapacity
argument_list|,
name|ip
argument_list|,
name|srcSize
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ZSTD_checkContinuity
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
specifier|const
name|void
modifier|*
name|dst
parameter_list|)
block|{
if|if
condition|(
name|dst
operator|!=
name|dctx
operator|->
name|previousDstEnd
condition|)
block|{
comment|/* not contiguous */
name|dctx
operator|->
name|dictEnd
operator|=
name|dctx
operator|->
name|previousDstEnd
expr_stmt|;
name|dctx
operator|->
name|vBase
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|dst
operator|-
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|dctx
operator|->
name|previousDstEnd
operator|)
operator|-
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|dctx
operator|->
name|base
operator|)
operator|)
expr_stmt|;
name|dctx
operator|->
name|base
operator|=
name|dst
expr_stmt|;
name|dctx
operator|->
name|previousDstEnd
operator|=
name|dst
expr_stmt|;
block|}
block|}
end_function

begin_function
name|size_t
name|ZSTD_decompressBlock
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
name|size_t
name|dSize
decl_stmt|;
name|ZSTD_checkContinuity
argument_list|(
name|dctx
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|dSize
operator|=
name|ZSTD_decompressBlock_internal
argument_list|(
name|dctx
argument_list|,
name|dst
argument_list|,
name|dstCapacity
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
expr_stmt|;
name|dctx
operator|->
name|previousDstEnd
operator|=
operator|(
name|char
operator|*
operator|)
name|dst
operator|+
name|dSize
expr_stmt|;
return|return
name|dSize
return|;
block|}
end_function

begin_comment
comment|/** ZSTD_insertBlock() :     insert `src` block into `dctx` history. Useful to track uncompressed blocks. */
end_comment

begin_function
name|ZSTDLIB_API
name|size_t
name|ZSTD_insertBlock
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
specifier|const
name|void
modifier|*
name|blockStart
parameter_list|,
name|size_t
name|blockSize
parameter_list|)
block|{
name|ZSTD_checkContinuity
argument_list|(
name|dctx
argument_list|,
name|blockStart
argument_list|)
expr_stmt|;
name|dctx
operator|->
name|previousDstEnd
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|blockStart
operator|+
name|blockSize
expr_stmt|;
return|return
name|blockSize
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTD_generateNxBytes
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
name|BYTE
name|byte
parameter_list|,
name|size_t
name|length
parameter_list|)
block|{
if|if
condition|(
name|length
operator|>
name|dstCapacity
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
name|memset
argument_list|(
name|dst
argument_list|,
name|byte
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
end_function

begin_comment
comment|/** ZSTD_findFrameCompressedSize() :  *  compatible with legacy mode  *  `src` must point to the start of a ZSTD frame, ZSTD legacy frame, or skippable frame  *  `srcSize` must be at least as large as the frame contained  *  @return : the compressed size of the frame starting at `src` */
end_comment

begin_function
name|size_t
name|ZSTD_findFrameCompressedSize
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|ZSTD_LEGACY_SUPPORT
argument_list|)
operator|&&
operator|(
name|ZSTD_LEGACY_SUPPORT
operator|>=
literal|1
operator|)
if|if
condition|(
name|ZSTD_isLegacy
argument_list|(
name|src
argument_list|,
name|srcSize
argument_list|)
condition|)
return|return
name|ZSTD_findFrameCompressedSizeLegacy
argument_list|(
name|src
argument_list|,
name|srcSize
argument_list|)
return|;
endif|#
directive|endif
if|if
condition|(
name|srcSize
operator|>=
name|ZSTD_skippableHeaderSize
operator|&&
operator|(
name|MEM_readLE32
argument_list|(
name|src
argument_list|)
operator|&
literal|0xFFFFFFFF0U
operator|)
operator|==
name|ZSTD_MAGIC_SKIPPABLE_START
condition|)
block|{
return|return
name|ZSTD_skippableHeaderSize
operator|+
name|MEM_readLE32
argument_list|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
operator|+
literal|4
argument_list|)
return|;
block|}
else|else
block|{
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|ipstart
init|=
name|ip
decl_stmt|;
name|size_t
name|remainingSize
init|=
name|srcSize
decl_stmt|;
name|ZSTD_frameParams
name|fParams
decl_stmt|;
name|size_t
specifier|const
name|headerSize
init|=
name|ZSTD_frameHeaderSize
argument_list|(
name|ip
argument_list|,
name|remainingSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|headerSize
argument_list|)
condition|)
return|return
name|headerSize
return|;
comment|/* Frame Header */
block|{
name|size_t
specifier|const
name|ret
init|=
name|ZSTD_getFrameParams
argument_list|(
operator|&
name|fParams
argument_list|,
name|ip
argument_list|,
name|remainingSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|ret
argument_list|)
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
block|}
name|ip
operator|+=
name|headerSize
expr_stmt|;
name|remainingSize
operator|-=
name|headerSize
expr_stmt|;
comment|/* Loop on each block */
while|while
condition|(
literal|1
condition|)
block|{
name|blockProperties_t
name|blockProperties
decl_stmt|;
name|size_t
specifier|const
name|cBlockSize
init|=
name|ZSTD_getcBlockSize
argument_list|(
name|ip
argument_list|,
name|remainingSize
argument_list|,
operator|&
name|blockProperties
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|cBlockSize
argument_list|)
condition|)
return|return
name|cBlockSize
return|;
if|if
condition|(
name|ZSTD_blockHeaderSize
operator|+
name|cBlockSize
operator|>
name|remainingSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|ip
operator|+=
name|ZSTD_blockHeaderSize
operator|+
name|cBlockSize
expr_stmt|;
name|remainingSize
operator|-=
name|ZSTD_blockHeaderSize
operator|+
name|cBlockSize
expr_stmt|;
if|if
condition|(
name|blockProperties
operator|.
name|lastBlock
condition|)
break|break;
block|}
if|if
condition|(
name|fParams
operator|.
name|checksumFlag
condition|)
block|{
comment|/* Frame content checksum */
if|if
condition|(
name|remainingSize
operator|<
literal|4
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|ip
operator|+=
literal|4
expr_stmt|;
name|remainingSize
operator|-=
literal|4
expr_stmt|;
block|}
return|return
name|ip
operator|-
name|ipstart
return|;
block|}
block|}
end_function

begin_comment
comment|/*! ZSTD_decompressFrame() : *   @dctx must be properly initialized */
end_comment

begin_function
specifier|static
name|size_t
name|ZSTD_decompressFrame
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|srcPtr
parameter_list|,
name|size_t
modifier|*
name|srcSizePtr
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
operator|(
operator|*
name|srcPtr
operator|)
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|ostart
init|=
operator|(
name|BYTE
operator|*
specifier|const
operator|)
name|dst
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|oend
init|=
name|ostart
operator|+
name|dstCapacity
decl_stmt|;
name|BYTE
modifier|*
name|op
init|=
name|ostart
decl_stmt|;
name|size_t
name|remainingSize
init|=
operator|*
name|srcSizePtr
decl_stmt|;
comment|/* check */
if|if
condition|(
name|remainingSize
operator|<
name|ZSTD_frameHeaderSize_min
operator|+
name|ZSTD_blockHeaderSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
comment|/* Frame Header */
block|{
name|size_t
specifier|const
name|frameHeaderSize
init|=
name|ZSTD_frameHeaderSize
argument_list|(
name|ip
argument_list|,
name|ZSTD_frameHeaderSize_prefix
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|frameHeaderSize
argument_list|)
condition|)
return|return
name|frameHeaderSize
return|;
if|if
condition|(
name|remainingSize
operator|<
name|frameHeaderSize
operator|+
name|ZSTD_blockHeaderSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|CHECK_F
argument_list|(
name|ZSTD_decodeFrameHeader
argument_list|(
name|dctx
argument_list|,
name|ip
argument_list|,
name|frameHeaderSize
argument_list|)
argument_list|)
expr_stmt|;
name|ip
operator|+=
name|frameHeaderSize
expr_stmt|;
name|remainingSize
operator|-=
name|frameHeaderSize
expr_stmt|;
block|}
comment|/* Loop on each block */
while|while
condition|(
literal|1
condition|)
block|{
name|size_t
name|decodedSize
decl_stmt|;
name|blockProperties_t
name|blockProperties
decl_stmt|;
name|size_t
specifier|const
name|cBlockSize
init|=
name|ZSTD_getcBlockSize
argument_list|(
name|ip
argument_list|,
name|remainingSize
argument_list|,
operator|&
name|blockProperties
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|cBlockSize
argument_list|)
condition|)
return|return
name|cBlockSize
return|;
name|ip
operator|+=
name|ZSTD_blockHeaderSize
expr_stmt|;
name|remainingSize
operator|-=
name|ZSTD_blockHeaderSize
expr_stmt|;
if|if
condition|(
name|cBlockSize
operator|>
name|remainingSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
switch|switch
condition|(
name|blockProperties
operator|.
name|blockType
condition|)
block|{
case|case
name|bt_compressed
case|:
name|decodedSize
operator|=
name|ZSTD_decompressBlock_internal
argument_list|(
name|dctx
argument_list|,
name|op
argument_list|,
name|oend
operator|-
name|op
argument_list|,
name|ip
argument_list|,
name|cBlockSize
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_raw
case|:
name|decodedSize
operator|=
name|ZSTD_copyRawBlock
argument_list|(
name|op
argument_list|,
name|oend
operator|-
name|op
argument_list|,
name|ip
argument_list|,
name|cBlockSize
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_rle
case|:
name|decodedSize
operator|=
name|ZSTD_generateNxBytes
argument_list|(
name|op
argument_list|,
name|oend
operator|-
name|op
argument_list|,
operator|*
name|ip
argument_list|,
name|blockProperties
operator|.
name|origSize
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_reserved
case|:
default|default:
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
block|}
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|decodedSize
argument_list|)
condition|)
return|return
name|decodedSize
return|;
if|if
condition|(
name|dctx
operator|->
name|fParams
operator|.
name|checksumFlag
condition|)
name|XXH64_update
argument_list|(
operator|&
name|dctx
operator|->
name|xxhState
argument_list|,
name|op
argument_list|,
name|decodedSize
argument_list|)
expr_stmt|;
name|op
operator|+=
name|decodedSize
expr_stmt|;
name|ip
operator|+=
name|cBlockSize
expr_stmt|;
name|remainingSize
operator|-=
name|cBlockSize
expr_stmt|;
if|if
condition|(
name|blockProperties
operator|.
name|lastBlock
condition|)
break|break;
block|}
if|if
condition|(
name|dctx
operator|->
name|fParams
operator|.
name|checksumFlag
condition|)
block|{
comment|/* Frame content checksum verification */
name|U32
specifier|const
name|checkCalc
init|=
operator|(
name|U32
operator|)
name|XXH64_digest
argument_list|(
operator|&
name|dctx
operator|->
name|xxhState
argument_list|)
decl_stmt|;
name|U32
name|checkRead
decl_stmt|;
if|if
condition|(
name|remainingSize
operator|<
literal|4
condition|)
return|return
name|ERROR
argument_list|(
name|checksum_wrong
argument_list|)
return|;
name|checkRead
operator|=
name|MEM_readLE32
argument_list|(
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|checkRead
operator|!=
name|checkCalc
condition|)
return|return
name|ERROR
argument_list|(
name|checksum_wrong
argument_list|)
return|;
name|ip
operator|+=
literal|4
expr_stmt|;
name|remainingSize
operator|-=
literal|4
expr_stmt|;
block|}
comment|/* Allow caller to get size read */
operator|*
name|srcPtr
operator|=
name|ip
expr_stmt|;
operator|*
name|srcSizePtr
operator|=
name|remainingSize
expr_stmt|;
return|return
name|op
operator|-
name|ostart
return|;
block|}
end_function

begin_function_decl
specifier|static
specifier|const
name|void
modifier|*
name|ZSTD_DDictDictContent
parameter_list|(
specifier|const
name|ZSTD_DDict
modifier|*
name|ddict
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|ZSTD_DDictDictSize
parameter_list|(
specifier|const
name|ZSTD_DDict
modifier|*
name|ddict
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|size_t
name|ZSTD_decompressMultiFrame
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|,
specifier|const
name|ZSTD_DDict
modifier|*
name|ddict
parameter_list|)
block|{
name|void
modifier|*
specifier|const
name|dststart
init|=
name|dst
decl_stmt|;
if|if
condition|(
name|ddict
condition|)
block|{
if|if
condition|(
name|dict
condition|)
block|{
comment|/* programmer error, these two cases should be mutually exclusive */
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
block|}
name|dict
operator|=
name|ZSTD_DDictDictContent
argument_list|(
name|ddict
argument_list|)
expr_stmt|;
name|dictSize
operator|=
name|ZSTD_DDictDictSize
argument_list|(
name|ddict
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|srcSize
operator|>=
name|ZSTD_frameHeaderSize_prefix
condition|)
block|{
name|U32
name|magicNumber
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ZSTD_LEGACY_SUPPORT
argument_list|)
operator|&&
operator|(
name|ZSTD_LEGACY_SUPPORT
operator|>=
literal|1
operator|)
if|if
condition|(
name|ZSTD_isLegacy
argument_list|(
name|src
argument_list|,
name|srcSize
argument_list|)
condition|)
block|{
name|size_t
name|decodedSize
decl_stmt|;
name|size_t
specifier|const
name|frameSize
init|=
name|ZSTD_findFrameCompressedSizeLegacy
argument_list|(
name|src
argument_list|,
name|srcSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|frameSize
argument_list|)
condition|)
return|return
name|frameSize
return|;
name|decodedSize
operator|=
name|ZSTD_decompressLegacy
argument_list|(
name|dst
argument_list|,
name|dstCapacity
argument_list|,
name|src
argument_list|,
name|frameSize
argument_list|,
name|dict
argument_list|,
name|dictSize
argument_list|)
expr_stmt|;
name|dst
operator|=
operator|(
name|BYTE
operator|*
operator|)
name|dst
operator|+
name|decodedSize
expr_stmt|;
name|dstCapacity
operator|-=
name|decodedSize
expr_stmt|;
name|src
operator|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
operator|+
name|frameSize
expr_stmt|;
name|srcSize
operator|-=
name|frameSize
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
name|magicNumber
operator|=
name|MEM_readLE32
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|magicNumber
operator|!=
name|ZSTD_MAGICNUMBER
condition|)
block|{
if|if
condition|(
operator|(
name|magicNumber
operator|&
literal|0xFFFFFFF0U
operator|)
operator|==
name|ZSTD_MAGIC_SKIPPABLE_START
condition|)
block|{
name|size_t
name|skippableSize
decl_stmt|;
if|if
condition|(
name|srcSize
operator|<
name|ZSTD_skippableHeaderSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|skippableSize
operator|=
name|MEM_readLE32
argument_list|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
operator|+
literal|4
argument_list|)
operator|+
name|ZSTD_skippableHeaderSize
expr_stmt|;
if|if
condition|(
name|srcSize
operator|<
name|skippableSize
condition|)
block|{
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
block|}
name|src
operator|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
operator|+
name|skippableSize
expr_stmt|;
name|srcSize
operator|-=
name|skippableSize
expr_stmt|;
continue|continue;
block|}
else|else
block|{
return|return
name|ERROR
argument_list|(
name|prefix_unknown
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|ddict
condition|)
block|{
comment|/* we were called from ZSTD_decompress_usingDDict */
name|ZSTD_refDDict
argument_list|(
name|dctx
argument_list|,
name|ddict
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* this will initialize correctly with no dict if dict == NULL, so              * use this in all cases but ddict */
name|CHECK_F
argument_list|(
name|ZSTD_decompressBegin_usingDict
argument_list|(
name|dctx
argument_list|,
name|dict
argument_list|,
name|dictSize
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ZSTD_checkContinuity
argument_list|(
name|dctx
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|{
specifier|const
name|size_t
name|res
init|=
name|ZSTD_decompressFrame
argument_list|(
name|dctx
argument_list|,
name|dst
argument_list|,
name|dstCapacity
argument_list|,
operator|&
name|src
argument_list|,
operator|&
name|srcSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|res
argument_list|)
condition|)
return|return
name|res
return|;
comment|/* don't need to bounds check this, ZSTD_decompressFrame will have              * already */
name|dst
operator|=
operator|(
name|BYTE
operator|*
operator|)
name|dst
operator|+
name|res
expr_stmt|;
name|dstCapacity
operator|-=
name|res
expr_stmt|;
block|}
block|}
if|if
condition|(
name|srcSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
comment|/* input not entirely consumed */
return|return
operator|(
name|BYTE
operator|*
operator|)
name|dst
operator|-
operator|(
name|BYTE
operator|*
operator|)
name|dststart
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTD_decompress_usingDict
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|)
block|{
return|return
name|ZSTD_decompressMultiFrame
argument_list|(
name|dctx
argument_list|,
name|dst
argument_list|,
name|dstCapacity
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
name|dict
argument_list|,
name|dictSize
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTD_decompressDCtx
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
return|return
name|ZSTD_decompress_usingDict
argument_list|(
name|dctx
argument_list|,
name|dst
argument_list|,
name|dstCapacity
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTD_decompress
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|ZSTD_HEAPMODE
argument_list|)
operator|&&
operator|(
name|ZSTD_HEAPMODE
operator|==
literal|1
operator|)
name|size_t
name|regenSize
decl_stmt|;
name|ZSTD_DCtx
modifier|*
specifier|const
name|dctx
init|=
name|ZSTD_createDCtx
argument_list|()
decl_stmt|;
if|if
condition|(
name|dctx
operator|==
name|NULL
condition|)
return|return
name|ERROR
argument_list|(
name|memory_allocation
argument_list|)
return|;
name|regenSize
operator|=
name|ZSTD_decompressDCtx
argument_list|(
name|dctx
argument_list|,
name|dst
argument_list|,
name|dstCapacity
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
expr_stmt|;
name|ZSTD_freeDCtx
argument_list|(
name|dctx
argument_list|)
expr_stmt|;
return|return
name|regenSize
return|;
else|#
directive|else
comment|/* stack mode */
name|ZSTD_DCtx
name|dctx
decl_stmt|;
return|return
name|ZSTD_decompressDCtx
argument_list|(
operator|&
name|dctx
argument_list|,
name|dst
argument_list|,
name|dstCapacity
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*-************************************** *   Advanced Streaming Decompression API *   Bufferless and synchronous ****************************************/
end_comment

begin_function
name|size_t
name|ZSTD_nextSrcSizeToDecompress
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|)
block|{
return|return
name|dctx
operator|->
name|expected
return|;
block|}
end_function

begin_function
name|ZSTD_nextInputType_e
name|ZSTD_nextInputType
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|)
block|{
switch|switch
condition|(
name|dctx
operator|->
name|stage
condition|)
block|{
default|default:
comment|/* should not happen */
case|case
name|ZSTDds_getFrameHeaderSize
case|:
case|case
name|ZSTDds_decodeFrameHeader
case|:
return|return
name|ZSTDnit_frameHeader
return|;
case|case
name|ZSTDds_decodeBlockHeader
case|:
return|return
name|ZSTDnit_blockHeader
return|;
case|case
name|ZSTDds_decompressBlock
case|:
return|return
name|ZSTDnit_block
return|;
case|case
name|ZSTDds_decompressLastBlock
case|:
return|return
name|ZSTDnit_lastBlock
return|;
case|case
name|ZSTDds_checkChecksum
case|:
return|return
name|ZSTDnit_checksum
return|;
case|case
name|ZSTDds_decodeSkippableHeader
case|:
case|case
name|ZSTDds_skipFrame
case|:
return|return
name|ZSTDnit_skippableFrame
return|;
block|}
block|}
end_function

begin_function
name|int
name|ZSTD_isSkipFrame
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|)
block|{
return|return
name|dctx
operator|->
name|stage
operator|==
name|ZSTDds_skipFrame
return|;
block|}
end_function

begin_comment
comment|/* for zbuff */
end_comment

begin_comment
comment|/** ZSTD_decompressContinue() : *   @return : nb of bytes generated into `dst` (necessarily<= `dstCapacity) *             or an error code, which can be tested using ZSTD_isError() */
end_comment

begin_function
name|size_t
name|ZSTD_decompressContinue
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
comment|/* Sanity check */
if|if
condition|(
name|srcSize
operator|!=
name|dctx
operator|->
name|expected
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
if|if
condition|(
name|dstCapacity
condition|)
name|ZSTD_checkContinuity
argument_list|(
name|dctx
argument_list|,
name|dst
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dctx
operator|->
name|stage
condition|)
block|{
case|case
name|ZSTDds_getFrameHeaderSize
case|:
if|if
condition|(
name|srcSize
operator|!=
name|ZSTD_frameHeaderSize_prefix
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
comment|/* impossible */
if|if
condition|(
operator|(
name|MEM_readLE32
argument_list|(
name|src
argument_list|)
operator|&
literal|0xFFFFFFF0U
operator|)
operator|==
name|ZSTD_MAGIC_SKIPPABLE_START
condition|)
block|{
comment|/* skippable frame */
name|memcpy
argument_list|(
name|dctx
operator|->
name|headerBuffer
argument_list|,
name|src
argument_list|,
name|ZSTD_frameHeaderSize_prefix
argument_list|)
expr_stmt|;
name|dctx
operator|->
name|expected
operator|=
name|ZSTD_skippableHeaderSize
operator|-
name|ZSTD_frameHeaderSize_prefix
expr_stmt|;
comment|/* magic number + skippable frame length */
name|dctx
operator|->
name|stage
operator|=
name|ZSTDds_decodeSkippableHeader
expr_stmt|;
return|return
literal|0
return|;
block|}
name|dctx
operator|->
name|headerSize
operator|=
name|ZSTD_frameHeaderSize
argument_list|(
name|src
argument_list|,
name|ZSTD_frameHeaderSize_prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|dctx
operator|->
name|headerSize
argument_list|)
condition|)
return|return
name|dctx
operator|->
name|headerSize
return|;
name|memcpy
argument_list|(
name|dctx
operator|->
name|headerBuffer
argument_list|,
name|src
argument_list|,
name|ZSTD_frameHeaderSize_prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|dctx
operator|->
name|headerSize
operator|>
name|ZSTD_frameHeaderSize_prefix
condition|)
block|{
name|dctx
operator|->
name|expected
operator|=
name|dctx
operator|->
name|headerSize
operator|-
name|ZSTD_frameHeaderSize_prefix
expr_stmt|;
name|dctx
operator|->
name|stage
operator|=
name|ZSTDds_decodeFrameHeader
expr_stmt|;
return|return
literal|0
return|;
block|}
name|dctx
operator|->
name|expected
operator|=
literal|0
expr_stmt|;
comment|/* not necessary to copy more */
case|case
name|ZSTDds_decodeFrameHeader
case|:
name|memcpy
argument_list|(
name|dctx
operator|->
name|headerBuffer
operator|+
name|ZSTD_frameHeaderSize_prefix
argument_list|,
name|src
argument_list|,
name|dctx
operator|->
name|expected
argument_list|)
expr_stmt|;
name|CHECK_F
argument_list|(
name|ZSTD_decodeFrameHeader
argument_list|(
name|dctx
argument_list|,
name|dctx
operator|->
name|headerBuffer
argument_list|,
name|dctx
operator|->
name|headerSize
argument_list|)
argument_list|)
expr_stmt|;
name|dctx
operator|->
name|expected
operator|=
name|ZSTD_blockHeaderSize
expr_stmt|;
name|dctx
operator|->
name|stage
operator|=
name|ZSTDds_decodeBlockHeader
expr_stmt|;
return|return
literal|0
return|;
case|case
name|ZSTDds_decodeBlockHeader
case|:
block|{
name|blockProperties_t
name|bp
decl_stmt|;
name|size_t
specifier|const
name|cBlockSize
init|=
name|ZSTD_getcBlockSize
argument_list|(
name|src
argument_list|,
name|ZSTD_blockHeaderSize
argument_list|,
operator|&
name|bp
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|cBlockSize
argument_list|)
condition|)
return|return
name|cBlockSize
return|;
name|dctx
operator|->
name|expected
operator|=
name|cBlockSize
expr_stmt|;
name|dctx
operator|->
name|bType
operator|=
name|bp
operator|.
name|blockType
expr_stmt|;
name|dctx
operator|->
name|rleSize
operator|=
name|bp
operator|.
name|origSize
expr_stmt|;
if|if
condition|(
name|cBlockSize
condition|)
block|{
name|dctx
operator|->
name|stage
operator|=
name|bp
operator|.
name|lastBlock
condition|?
name|ZSTDds_decompressLastBlock
else|:
name|ZSTDds_decompressBlock
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* empty block */
if|if
condition|(
name|bp
operator|.
name|lastBlock
condition|)
block|{
if|if
condition|(
name|dctx
operator|->
name|fParams
operator|.
name|checksumFlag
condition|)
block|{
name|dctx
operator|->
name|expected
operator|=
literal|4
expr_stmt|;
name|dctx
operator|->
name|stage
operator|=
name|ZSTDds_checkChecksum
expr_stmt|;
block|}
else|else
block|{
name|dctx
operator|->
name|expected
operator|=
literal|0
expr_stmt|;
comment|/* end of frame */
name|dctx
operator|->
name|stage
operator|=
name|ZSTDds_getFrameHeaderSize
expr_stmt|;
block|}
block|}
else|else
block|{
name|dctx
operator|->
name|expected
operator|=
literal|3
expr_stmt|;
comment|/* go directly to next header */
name|dctx
operator|->
name|stage
operator|=
name|ZSTDds_decodeBlockHeader
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
case|case
name|ZSTDds_decompressLastBlock
case|:
case|case
name|ZSTDds_decompressBlock
case|:
block|{
name|size_t
name|rSize
decl_stmt|;
switch|switch
condition|(
name|dctx
operator|->
name|bType
condition|)
block|{
case|case
name|bt_compressed
case|:
name|rSize
operator|=
name|ZSTD_decompressBlock_internal
argument_list|(
name|dctx
argument_list|,
name|dst
argument_list|,
name|dstCapacity
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_raw
case|:
name|rSize
operator|=
name|ZSTD_copyRawBlock
argument_list|(
name|dst
argument_list|,
name|dstCapacity
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_rle
case|:
name|rSize
operator|=
name|ZSTD_setRleBlock
argument_list|(
name|dst
argument_list|,
name|dstCapacity
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
name|dctx
operator|->
name|rleSize
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_reserved
case|:
comment|/* should never happen */
default|default:
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
block|}
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|rSize
argument_list|)
condition|)
return|return
name|rSize
return|;
if|if
condition|(
name|dctx
operator|->
name|fParams
operator|.
name|checksumFlag
condition|)
name|XXH64_update
argument_list|(
operator|&
name|dctx
operator|->
name|xxhState
argument_list|,
name|dst
argument_list|,
name|rSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|dctx
operator|->
name|stage
operator|==
name|ZSTDds_decompressLastBlock
condition|)
block|{
comment|/* end of frame */
if|if
condition|(
name|dctx
operator|->
name|fParams
operator|.
name|checksumFlag
condition|)
block|{
comment|/* another round for frame checksum */
name|dctx
operator|->
name|expected
operator|=
literal|4
expr_stmt|;
name|dctx
operator|->
name|stage
operator|=
name|ZSTDds_checkChecksum
expr_stmt|;
block|}
else|else
block|{
name|dctx
operator|->
name|expected
operator|=
literal|0
expr_stmt|;
comment|/* ends here */
name|dctx
operator|->
name|stage
operator|=
name|ZSTDds_getFrameHeaderSize
expr_stmt|;
block|}
block|}
else|else
block|{
name|dctx
operator|->
name|stage
operator|=
name|ZSTDds_decodeBlockHeader
expr_stmt|;
name|dctx
operator|->
name|expected
operator|=
name|ZSTD_blockHeaderSize
expr_stmt|;
name|dctx
operator|->
name|previousDstEnd
operator|=
operator|(
name|char
operator|*
operator|)
name|dst
operator|+
name|rSize
expr_stmt|;
block|}
return|return
name|rSize
return|;
block|}
case|case
name|ZSTDds_checkChecksum
case|:
block|{
name|U32
specifier|const
name|h32
init|=
operator|(
name|U32
operator|)
name|XXH64_digest
argument_list|(
operator|&
name|dctx
operator|->
name|xxhState
argument_list|)
decl_stmt|;
name|U32
specifier|const
name|check32
init|=
name|MEM_readLE32
argument_list|(
name|src
argument_list|)
decl_stmt|;
comment|/* srcSize == 4, guaranteed by dctx->expected */
if|if
condition|(
name|check32
operator|!=
name|h32
condition|)
return|return
name|ERROR
argument_list|(
name|checksum_wrong
argument_list|)
return|;
name|dctx
operator|->
name|expected
operator|=
literal|0
expr_stmt|;
name|dctx
operator|->
name|stage
operator|=
name|ZSTDds_getFrameHeaderSize
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
name|ZSTDds_decodeSkippableHeader
case|:
block|{
name|memcpy
argument_list|(
name|dctx
operator|->
name|headerBuffer
operator|+
name|ZSTD_frameHeaderSize_prefix
argument_list|,
name|src
argument_list|,
name|dctx
operator|->
name|expected
argument_list|)
expr_stmt|;
name|dctx
operator|->
name|expected
operator|=
name|MEM_readLE32
argument_list|(
name|dctx
operator|->
name|headerBuffer
operator|+
literal|4
argument_list|)
expr_stmt|;
name|dctx
operator|->
name|stage
operator|=
name|ZSTDds_skipFrame
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
name|ZSTDds_skipFrame
case|:
block|{
name|dctx
operator|->
name|expected
operator|=
literal|0
expr_stmt|;
name|dctx
operator|->
name|stage
operator|=
name|ZSTDds_getFrameHeaderSize
expr_stmt|;
return|return
literal|0
return|;
block|}
default|default:
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
comment|/* impossible */
block|}
block|}
end_function

begin_function
specifier|static
name|size_t
name|ZSTD_refDictContent
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|)
block|{
name|dctx
operator|->
name|dictEnd
operator|=
name|dctx
operator|->
name|previousDstEnd
expr_stmt|;
name|dctx
operator|->
name|vBase
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|dict
operator|-
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|dctx
operator|->
name|previousDstEnd
operator|)
operator|-
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|dctx
operator|->
name|base
operator|)
operator|)
expr_stmt|;
name|dctx
operator|->
name|base
operator|=
name|dict
expr_stmt|;
name|dctx
operator|->
name|previousDstEnd
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|dict
operator|+
name|dictSize
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ZSTD_loadEntropy() :  * dict : must point at beginning of a valid zstd dictionary  * @return : size of entropy tables read */
end_comment

begin_function
specifier|static
name|size_t
name|ZSTD_loadEntropy
parameter_list|(
name|ZSTD_entropyTables_t
modifier|*
name|entropy
parameter_list|,
specifier|const
name|void
modifier|*
specifier|const
name|dict
parameter_list|,
name|size_t
specifier|const
name|dictSize
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|dictPtr
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|dict
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|dictEnd
init|=
name|dictPtr
operator|+
name|dictSize
decl_stmt|;
if|if
condition|(
name|dictSize
operator|<=
literal|8
condition|)
return|return
name|ERROR
argument_list|(
name|dictionary_corrupted
argument_list|)
return|;
name|dictPtr
operator|+=
literal|8
expr_stmt|;
comment|/* skip header = magic + dictID */
block|{
name|size_t
specifier|const
name|hSize
init|=
name|HUF_readDTableX4
argument_list|(
name|entropy
operator|->
name|hufTable
argument_list|,
name|dictPtr
argument_list|,
name|dictEnd
operator|-
name|dictPtr
argument_list|)
decl_stmt|;
if|if
condition|(
name|HUF_isError
argument_list|(
name|hSize
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|dictionary_corrupted
argument_list|)
return|;
name|dictPtr
operator|+=
name|hSize
expr_stmt|;
block|}
block|{
name|short
name|offcodeNCount
index|[
name|MaxOff
operator|+
literal|1
index|]
decl_stmt|;
name|U32
name|offcodeMaxValue
init|=
name|MaxOff
decl_stmt|,
name|offcodeLog
decl_stmt|;
name|size_t
specifier|const
name|offcodeHeaderSize
init|=
name|FSE_readNCount
argument_list|(
name|offcodeNCount
argument_list|,
operator|&
name|offcodeMaxValue
argument_list|,
operator|&
name|offcodeLog
argument_list|,
name|dictPtr
argument_list|,
name|dictEnd
operator|-
name|dictPtr
argument_list|)
decl_stmt|;
if|if
condition|(
name|FSE_isError
argument_list|(
name|offcodeHeaderSize
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|dictionary_corrupted
argument_list|)
return|;
if|if
condition|(
name|offcodeLog
operator|>
name|OffFSELog
condition|)
return|return
name|ERROR
argument_list|(
name|dictionary_corrupted
argument_list|)
return|;
name|CHECK_E
argument_list|(
name|FSE_buildDTable
argument_list|(
name|entropy
operator|->
name|OFTable
argument_list|,
name|offcodeNCount
argument_list|,
name|offcodeMaxValue
argument_list|,
name|offcodeLog
argument_list|)
argument_list|,
name|dictionary_corrupted
argument_list|)
expr_stmt|;
name|dictPtr
operator|+=
name|offcodeHeaderSize
expr_stmt|;
block|}
block|{
name|short
name|matchlengthNCount
index|[
name|MaxML
operator|+
literal|1
index|]
decl_stmt|;
name|unsigned
name|matchlengthMaxValue
init|=
name|MaxML
decl_stmt|,
name|matchlengthLog
decl_stmt|;
name|size_t
specifier|const
name|matchlengthHeaderSize
init|=
name|FSE_readNCount
argument_list|(
name|matchlengthNCount
argument_list|,
operator|&
name|matchlengthMaxValue
argument_list|,
operator|&
name|matchlengthLog
argument_list|,
name|dictPtr
argument_list|,
name|dictEnd
operator|-
name|dictPtr
argument_list|)
decl_stmt|;
if|if
condition|(
name|FSE_isError
argument_list|(
name|matchlengthHeaderSize
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|dictionary_corrupted
argument_list|)
return|;
if|if
condition|(
name|matchlengthLog
operator|>
name|MLFSELog
condition|)
return|return
name|ERROR
argument_list|(
name|dictionary_corrupted
argument_list|)
return|;
name|CHECK_E
argument_list|(
name|FSE_buildDTable
argument_list|(
name|entropy
operator|->
name|MLTable
argument_list|,
name|matchlengthNCount
argument_list|,
name|matchlengthMaxValue
argument_list|,
name|matchlengthLog
argument_list|)
argument_list|,
name|dictionary_corrupted
argument_list|)
expr_stmt|;
name|dictPtr
operator|+=
name|matchlengthHeaderSize
expr_stmt|;
block|}
block|{
name|short
name|litlengthNCount
index|[
name|MaxLL
operator|+
literal|1
index|]
decl_stmt|;
name|unsigned
name|litlengthMaxValue
init|=
name|MaxLL
decl_stmt|,
name|litlengthLog
decl_stmt|;
name|size_t
specifier|const
name|litlengthHeaderSize
init|=
name|FSE_readNCount
argument_list|(
name|litlengthNCount
argument_list|,
operator|&
name|litlengthMaxValue
argument_list|,
operator|&
name|litlengthLog
argument_list|,
name|dictPtr
argument_list|,
name|dictEnd
operator|-
name|dictPtr
argument_list|)
decl_stmt|;
if|if
condition|(
name|FSE_isError
argument_list|(
name|litlengthHeaderSize
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|dictionary_corrupted
argument_list|)
return|;
if|if
condition|(
name|litlengthLog
operator|>
name|LLFSELog
condition|)
return|return
name|ERROR
argument_list|(
name|dictionary_corrupted
argument_list|)
return|;
name|CHECK_E
argument_list|(
name|FSE_buildDTable
argument_list|(
name|entropy
operator|->
name|LLTable
argument_list|,
name|litlengthNCount
argument_list|,
name|litlengthMaxValue
argument_list|,
name|litlengthLog
argument_list|)
argument_list|,
name|dictionary_corrupted
argument_list|)
expr_stmt|;
name|dictPtr
operator|+=
name|litlengthHeaderSize
expr_stmt|;
block|}
if|if
condition|(
name|dictPtr
operator|+
literal|12
operator|>
name|dictEnd
condition|)
return|return
name|ERROR
argument_list|(
name|dictionary_corrupted
argument_list|)
return|;
block|{
name|int
name|i
decl_stmt|;
name|size_t
specifier|const
name|dictContentSize
init|=
call|(
name|size_t
call|)
argument_list|(
name|dictEnd
operator|-
operator|(
name|dictPtr
operator|+
literal|12
operator|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|U32
specifier|const
name|rep
init|=
name|MEM_readLE32
argument_list|(
name|dictPtr
argument_list|)
decl_stmt|;
name|dictPtr
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|rep
operator|==
literal|0
operator|||
name|rep
operator|>=
name|dictContentSize
condition|)
return|return
name|ERROR
argument_list|(
name|dictionary_corrupted
argument_list|)
return|;
name|entropy
operator|->
name|rep
index|[
name|i
index|]
operator|=
name|rep
expr_stmt|;
block|}
block|}
return|return
name|dictPtr
operator|-
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|dict
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|ZSTD_decompress_insertDictionary
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|)
block|{
if|if
condition|(
name|dictSize
operator|<
literal|8
condition|)
return|return
name|ZSTD_refDictContent
argument_list|(
name|dctx
argument_list|,
name|dict
argument_list|,
name|dictSize
argument_list|)
return|;
block|{
name|U32
specifier|const
name|magic
init|=
name|MEM_readLE32
argument_list|(
name|dict
argument_list|)
decl_stmt|;
if|if
condition|(
name|magic
operator|!=
name|ZSTD_DICT_MAGIC
condition|)
block|{
return|return
name|ZSTD_refDictContent
argument_list|(
name|dctx
argument_list|,
name|dict
argument_list|,
name|dictSize
argument_list|)
return|;
comment|/* pure content mode */
block|}
block|}
name|dctx
operator|->
name|dictID
operator|=
name|MEM_readLE32
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|dict
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* load entropy tables */
block|{
name|size_t
specifier|const
name|eSize
init|=
name|ZSTD_loadEntropy
argument_list|(
operator|&
name|dctx
operator|->
name|entropy
argument_list|,
name|dict
argument_list|,
name|dictSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|eSize
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|dictionary_corrupted
argument_list|)
return|;
name|dict
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|dict
operator|+
name|eSize
expr_stmt|;
name|dictSize
operator|-=
name|eSize
expr_stmt|;
block|}
name|dctx
operator|->
name|litEntropy
operator|=
name|dctx
operator|->
name|fseEntropy
operator|=
literal|1
expr_stmt|;
comment|/* reference dictionary content */
return|return
name|ZSTD_refDictContent
argument_list|(
name|dctx
argument_list|,
name|dict
argument_list|,
name|dictSize
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTD_decompressBegin_usingDict
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|)
block|{
name|CHECK_F
argument_list|(
name|ZSTD_decompressBegin
argument_list|(
name|dctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dict
operator|&&
name|dictSize
condition|)
name|CHECK_E
argument_list|(
name|ZSTD_decompress_insertDictionary
argument_list|(
name|dctx
argument_list|,
name|dict
argument_list|,
name|dictSize
argument_list|)
argument_list|,
name|dictionary_corrupted
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ======   ZSTD_DDict   ====== */
end_comment

begin_struct
struct|struct
name|ZSTD_DDict_s
block|{
name|void
modifier|*
name|dictBuffer
decl_stmt|;
specifier|const
name|void
modifier|*
name|dictContent
decl_stmt|;
name|size_t
name|dictSize
decl_stmt|;
name|ZSTD_entropyTables_t
name|entropy
decl_stmt|;
name|U32
name|dictID
decl_stmt|;
name|U32
name|entropyPresent
decl_stmt|;
name|ZSTD_customMem
name|cMem
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* typedef'd to ZSTD_DDict within "zstd.h" */
end_comment

begin_function
specifier|static
specifier|const
name|void
modifier|*
name|ZSTD_DDictDictContent
parameter_list|(
specifier|const
name|ZSTD_DDict
modifier|*
name|ddict
parameter_list|)
block|{
return|return
name|ddict
operator|->
name|dictContent
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|ZSTD_DDictDictSize
parameter_list|(
specifier|const
name|ZSTD_DDict
modifier|*
name|ddict
parameter_list|)
block|{
return|return
name|ddict
operator|->
name|dictSize
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ZSTD_refDDict
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dstDCtx
parameter_list|,
specifier|const
name|ZSTD_DDict
modifier|*
name|ddict
parameter_list|)
block|{
name|ZSTD_decompressBegin
argument_list|(
name|dstDCtx
argument_list|)
expr_stmt|;
comment|/* init */
if|if
condition|(
name|ddict
condition|)
block|{
comment|/* support refDDict on NULL */
name|dstDCtx
operator|->
name|dictID
operator|=
name|ddict
operator|->
name|dictID
expr_stmt|;
name|dstDCtx
operator|->
name|base
operator|=
name|ddict
operator|->
name|dictContent
expr_stmt|;
name|dstDCtx
operator|->
name|vBase
operator|=
name|ddict
operator|->
name|dictContent
expr_stmt|;
name|dstDCtx
operator|->
name|dictEnd
operator|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|ddict
operator|->
name|dictContent
operator|+
name|ddict
operator|->
name|dictSize
expr_stmt|;
name|dstDCtx
operator|->
name|previousDstEnd
operator|=
name|dstDCtx
operator|->
name|dictEnd
expr_stmt|;
if|if
condition|(
name|ddict
operator|->
name|entropyPresent
condition|)
block|{
name|dstDCtx
operator|->
name|litEntropy
operator|=
literal|1
expr_stmt|;
name|dstDCtx
operator|->
name|fseEntropy
operator|=
literal|1
expr_stmt|;
name|dstDCtx
operator|->
name|LLTptr
operator|=
name|ddict
operator|->
name|entropy
operator|.
name|LLTable
expr_stmt|;
name|dstDCtx
operator|->
name|MLTptr
operator|=
name|ddict
operator|->
name|entropy
operator|.
name|MLTable
expr_stmt|;
name|dstDCtx
operator|->
name|OFTptr
operator|=
name|ddict
operator|->
name|entropy
operator|.
name|OFTable
expr_stmt|;
name|dstDCtx
operator|->
name|HUFptr
operator|=
name|ddict
operator|->
name|entropy
operator|.
name|hufTable
expr_stmt|;
name|dstDCtx
operator|->
name|entropy
operator|.
name|rep
index|[
literal|0
index|]
operator|=
name|ddict
operator|->
name|entropy
operator|.
name|rep
index|[
literal|0
index|]
expr_stmt|;
name|dstDCtx
operator|->
name|entropy
operator|.
name|rep
index|[
literal|1
index|]
operator|=
name|ddict
operator|->
name|entropy
operator|.
name|rep
index|[
literal|1
index|]
expr_stmt|;
name|dstDCtx
operator|->
name|entropy
operator|.
name|rep
index|[
literal|2
index|]
operator|=
name|ddict
operator|->
name|entropy
operator|.
name|rep
index|[
literal|2
index|]
expr_stmt|;
block|}
else|else
block|{
name|dstDCtx
operator|->
name|litEntropy
operator|=
literal|0
expr_stmt|;
name|dstDCtx
operator|->
name|fseEntropy
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|size_t
name|ZSTD_loadEntropy_inDDict
parameter_list|(
name|ZSTD_DDict
modifier|*
name|ddict
parameter_list|)
block|{
name|ddict
operator|->
name|dictID
operator|=
literal|0
expr_stmt|;
name|ddict
operator|->
name|entropyPresent
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ddict
operator|->
name|dictSize
operator|<
literal|8
condition|)
return|return
literal|0
return|;
block|{
name|U32
specifier|const
name|magic
init|=
name|MEM_readLE32
argument_list|(
name|ddict
operator|->
name|dictContent
argument_list|)
decl_stmt|;
if|if
condition|(
name|magic
operator|!=
name|ZSTD_DICT_MAGIC
condition|)
return|return
literal|0
return|;
comment|/* pure content mode */
block|}
name|ddict
operator|->
name|dictID
operator|=
name|MEM_readLE32
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|ddict
operator|->
name|dictContent
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* load entropy tables */
name|CHECK_E
argument_list|(
name|ZSTD_loadEntropy
argument_list|(
operator|&
name|ddict
operator|->
name|entropy
argument_list|,
name|ddict
operator|->
name|dictContent
argument_list|,
name|ddict
operator|->
name|dictSize
argument_list|)
argument_list|,
name|dictionary_corrupted
argument_list|)
expr_stmt|;
name|ddict
operator|->
name|entropyPresent
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|ZSTD_DDict
modifier|*
name|ZSTD_createDDict_advanced
parameter_list|(
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|,
name|unsigned
name|byReference
parameter_list|,
name|ZSTD_customMem
name|customMem
parameter_list|)
block|{
if|if
condition|(
operator|!
name|customMem
operator|.
name|customAlloc
operator|&&
operator|!
name|customMem
operator|.
name|customFree
condition|)
name|customMem
operator|=
name|defaultCustomMem
expr_stmt|;
if|if
condition|(
operator|!
name|customMem
operator|.
name|customAlloc
operator|||
operator|!
name|customMem
operator|.
name|customFree
condition|)
return|return
name|NULL
return|;
block|{
name|ZSTD_DDict
modifier|*
specifier|const
name|ddict
init|=
operator|(
name|ZSTD_DDict
operator|*
operator|)
name|ZSTD_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ZSTD_DDict
argument_list|)
argument_list|,
name|customMem
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ddict
condition|)
return|return
name|NULL
return|;
name|ddict
operator|->
name|cMem
operator|=
name|customMem
expr_stmt|;
if|if
condition|(
operator|(
name|byReference
operator|)
operator|||
operator|(
operator|!
name|dict
operator|)
operator|||
operator|(
operator|!
name|dictSize
operator|)
condition|)
block|{
name|ddict
operator|->
name|dictBuffer
operator|=
name|NULL
expr_stmt|;
name|ddict
operator|->
name|dictContent
operator|=
name|dict
expr_stmt|;
block|}
else|else
block|{
name|void
modifier|*
specifier|const
name|internalBuffer
init|=
name|ZSTD_malloc
argument_list|(
name|dictSize
argument_list|,
name|customMem
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|internalBuffer
condition|)
block|{
name|ZSTD_freeDDict
argument_list|(
name|ddict
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memcpy
argument_list|(
name|internalBuffer
argument_list|,
name|dict
argument_list|,
name|dictSize
argument_list|)
expr_stmt|;
name|ddict
operator|->
name|dictBuffer
operator|=
name|internalBuffer
expr_stmt|;
name|ddict
operator|->
name|dictContent
operator|=
name|internalBuffer
expr_stmt|;
block|}
name|ddict
operator|->
name|dictSize
operator|=
name|dictSize
expr_stmt|;
name|ddict
operator|->
name|entropy
operator|.
name|hufTable
index|[
literal|0
index|]
operator|=
call|(
name|HUF_DTable
call|)
argument_list|(
operator|(
name|HufLog
operator|)
operator|*
literal|0x1000001
argument_list|)
expr_stmt|;
comment|/* cover both little and big endian */
comment|/* parse dictionary content */
block|{
name|size_t
specifier|const
name|errorCode
init|=
name|ZSTD_loadEntropy_inDDict
argument_list|(
name|ddict
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
block|{
name|ZSTD_freeDDict
argument_list|(
name|ddict
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
return|return
name|ddict
return|;
block|}
block|}
end_function

begin_comment
comment|/*! ZSTD_createDDict() : *   Create a digested dictionary, to start decompression without startup delay. *   `dict` content is copied inside DDict. *   Consequently, `dict` can be released after `ZSTD_DDict` creation */
end_comment

begin_function
name|ZSTD_DDict
modifier|*
name|ZSTD_createDDict
parameter_list|(
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|)
block|{
name|ZSTD_customMem
specifier|const
name|allocator
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
return|return
name|ZSTD_createDDict_advanced
argument_list|(
name|dict
argument_list|,
name|dictSize
argument_list|,
literal|0
argument_list|,
name|allocator
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*! ZSTD_createDDict_byReference() :  *  Create a digested dictionary, to start decompression without startup delay.  *  Dictionary content is simply referenced, it will be accessed during decompression.  *  Warning : dictBuffer must outlive DDict (DDict must be freed before dictBuffer) */
end_comment

begin_function
name|ZSTD_DDict
modifier|*
name|ZSTD_createDDict_byReference
parameter_list|(
specifier|const
name|void
modifier|*
name|dictBuffer
parameter_list|,
name|size_t
name|dictSize
parameter_list|)
block|{
name|ZSTD_customMem
specifier|const
name|allocator
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
return|return
name|ZSTD_createDDict_advanced
argument_list|(
name|dictBuffer
argument_list|,
name|dictSize
argument_list|,
literal|1
argument_list|,
name|allocator
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTD_freeDDict
parameter_list|(
name|ZSTD_DDict
modifier|*
name|ddict
parameter_list|)
block|{
if|if
condition|(
name|ddict
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* support free on NULL */
block|{
name|ZSTD_customMem
specifier|const
name|cMem
init|=
name|ddict
operator|->
name|cMem
decl_stmt|;
name|ZSTD_free
argument_list|(
name|ddict
operator|->
name|dictBuffer
argument_list|,
name|cMem
argument_list|)
expr_stmt|;
name|ZSTD_free
argument_list|(
name|ddict
argument_list|,
name|cMem
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
name|size_t
name|ZSTD_sizeof_DDict
parameter_list|(
specifier|const
name|ZSTD_DDict
modifier|*
name|ddict
parameter_list|)
block|{
if|if
condition|(
name|ddict
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* support sizeof on NULL */
return|return
sizeof|sizeof
argument_list|(
operator|*
name|ddict
argument_list|)
operator|+
operator|(
name|ddict
operator|->
name|dictBuffer
condition|?
name|ddict
operator|->
name|dictSize
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*! ZSTD_getDictID_fromDict() :  *  Provides the dictID stored within dictionary.  *  if @return == 0, the dictionary is not conformant with Zstandard specification.  *  It can still be loaded, but as a content-only dictionary. */
end_comment

begin_function
name|unsigned
name|ZSTD_getDictID_fromDict
parameter_list|(
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|)
block|{
if|if
condition|(
name|dictSize
operator|<
literal|8
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|MEM_readLE32
argument_list|(
name|dict
argument_list|)
operator|!=
name|ZSTD_DICT_MAGIC
condition|)
return|return
literal|0
return|;
return|return
name|MEM_readLE32
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|dict
operator|+
literal|4
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*! ZSTD_getDictID_fromDDict() :  *  Provides the dictID of the dictionary loaded into `ddict`.  *  If @return == 0, the dictionary is not conformant to Zstandard specification, or empty.  *  Non-conformant dictionaries can still be loaded, but as content-only dictionaries. */
end_comment

begin_function
name|unsigned
name|ZSTD_getDictID_fromDDict
parameter_list|(
specifier|const
name|ZSTD_DDict
modifier|*
name|ddict
parameter_list|)
block|{
if|if
condition|(
name|ddict
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
return|return
name|ZSTD_getDictID_fromDict
argument_list|(
name|ddict
operator|->
name|dictContent
argument_list|,
name|ddict
operator|->
name|dictSize
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*! ZSTD_getDictID_fromFrame() :  *  Provides the dictID required to decompressed the frame stored within `src`.  *  If @return == 0, the dictID could not be decoded.  *  This could for one of the following reasons :  *  - The frame does not require a dictionary to be decoded (most common case).  *  - The frame was built with dictID intentionally removed. Whatever dictionary is necessary is a hidden information.  *    Note : this use case also happens when using a non-conformant dictionary.  *  - `srcSize` is too small, and as a result, the frame header could not be decoded (only possible if `srcSize< ZSTD_FRAMEHEADERSIZE_MAX`).  *  - This is not a Zstandard frame.  *  When identifying the exact failure cause, it's possible to used ZSTD_getFrameParams(), which will provide a more precise error code. */
end_comment

begin_function
name|unsigned
name|ZSTD_getDictID_fromFrame
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
name|ZSTD_frameParams
name|zfp
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|size_t
specifier|const
name|hError
init|=
name|ZSTD_getFrameParams
argument_list|(
operator|&
name|zfp
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|hError
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|zfp
operator|.
name|dictID
return|;
block|}
end_function

begin_comment
comment|/*! ZSTD_decompress_usingDDict() : *   Decompression using a pre-digested Dictionary *   Use dictionary without significant overhead. */
end_comment

begin_function
name|size_t
name|ZSTD_decompress_usingDDict
parameter_list|(
name|ZSTD_DCtx
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
specifier|const
name|ZSTD_DDict
modifier|*
name|ddict
parameter_list|)
block|{
comment|/* pass content and size in case legacy frames are encountered */
return|return
name|ZSTD_decompressMultiFrame
argument_list|(
name|dctx
argument_list|,
name|dst
argument_list|,
name|dstCapacity
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|ddict
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*===================================== *   Streaming decompression *====================================*/
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|zdss_init
block|,
name|zdss_loadHeader
block|,
name|zdss_read
block|,
name|zdss_load
block|,
name|zdss_flush
block|}
name|ZSTD_dStreamStage
typedef|;
end_typedef

begin_comment
comment|/* *** Resource management *** */
end_comment

begin_struct
struct|struct
name|ZSTD_DStream_s
block|{
name|ZSTD_DCtx
modifier|*
name|dctx
decl_stmt|;
name|ZSTD_DDict
modifier|*
name|ddictLocal
decl_stmt|;
specifier|const
name|ZSTD_DDict
modifier|*
name|ddict
decl_stmt|;
name|ZSTD_frameParams
name|fParams
decl_stmt|;
name|ZSTD_dStreamStage
name|stage
decl_stmt|;
name|char
modifier|*
name|inBuff
decl_stmt|;
name|size_t
name|inBuffSize
decl_stmt|;
name|size_t
name|inPos
decl_stmt|;
name|size_t
name|maxWindowSize
decl_stmt|;
name|char
modifier|*
name|outBuff
decl_stmt|;
name|size_t
name|outBuffSize
decl_stmt|;
name|size_t
name|outStart
decl_stmt|;
name|size_t
name|outEnd
decl_stmt|;
name|size_t
name|blockSize
decl_stmt|;
name|BYTE
name|headerBuffer
index|[
name|ZSTD_FRAMEHEADERSIZE_MAX
index|]
decl_stmt|;
comment|/* tmp buffer to store frame header */
name|size_t
name|lhSize
decl_stmt|;
name|ZSTD_customMem
name|customMem
decl_stmt|;
name|void
modifier|*
name|legacyContext
decl_stmt|;
name|U32
name|previousLegacyVersion
decl_stmt|;
name|U32
name|legacyVersion
decl_stmt|;
name|U32
name|hostageByte
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* typedef'd to ZSTD_DStream within "zstd.h" */
end_comment

begin_function
name|ZSTD_DStream
modifier|*
name|ZSTD_createDStream
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|ZSTD_createDStream_advanced
argument_list|(
name|defaultCustomMem
argument_list|)
return|;
block|}
end_function

begin_function
name|ZSTD_DStream
modifier|*
name|ZSTD_createDStream_advanced
parameter_list|(
name|ZSTD_customMem
name|customMem
parameter_list|)
block|{
name|ZSTD_DStream
modifier|*
name|zds
decl_stmt|;
if|if
condition|(
operator|!
name|customMem
operator|.
name|customAlloc
operator|&&
operator|!
name|customMem
operator|.
name|customFree
condition|)
name|customMem
operator|=
name|defaultCustomMem
expr_stmt|;
if|if
condition|(
operator|!
name|customMem
operator|.
name|customAlloc
operator|||
operator|!
name|customMem
operator|.
name|customFree
condition|)
return|return
name|NULL
return|;
name|zds
operator|=
operator|(
name|ZSTD_DStream
operator|*
operator|)
name|ZSTD_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ZSTD_DStream
argument_list|)
argument_list|,
name|customMem
argument_list|)
expr_stmt|;
if|if
condition|(
name|zds
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|zds
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ZSTD_DStream
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|zds
operator|->
name|customMem
argument_list|,
operator|&
name|customMem
argument_list|,
sizeof|sizeof
argument_list|(
name|ZSTD_customMem
argument_list|)
argument_list|)
expr_stmt|;
name|zds
operator|->
name|dctx
operator|=
name|ZSTD_createDCtx_advanced
argument_list|(
name|customMem
argument_list|)
expr_stmt|;
if|if
condition|(
name|zds
operator|->
name|dctx
operator|==
name|NULL
condition|)
block|{
name|ZSTD_freeDStream
argument_list|(
name|zds
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|zds
operator|->
name|stage
operator|=
name|zdss_init
expr_stmt|;
name|zds
operator|->
name|maxWindowSize
operator|=
name|ZSTD_MAXWINDOWSIZE_DEFAULT
expr_stmt|;
return|return
name|zds
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTD_freeDStream
parameter_list|(
name|ZSTD_DStream
modifier|*
name|zds
parameter_list|)
block|{
if|if
condition|(
name|zds
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* support free on null */
block|{
name|ZSTD_customMem
specifier|const
name|cMem
init|=
name|zds
operator|->
name|customMem
decl_stmt|;
name|ZSTD_freeDCtx
argument_list|(
name|zds
operator|->
name|dctx
argument_list|)
expr_stmt|;
name|ZSTD_freeDDict
argument_list|(
name|zds
operator|->
name|ddictLocal
argument_list|)
expr_stmt|;
name|ZSTD_free
argument_list|(
name|zds
operator|->
name|inBuff
argument_list|,
name|cMem
argument_list|)
expr_stmt|;
name|ZSTD_free
argument_list|(
name|zds
operator|->
name|outBuff
argument_list|,
name|cMem
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ZSTD_LEGACY_SUPPORT
argument_list|)
operator|&&
operator|(
name|ZSTD_LEGACY_SUPPORT
operator|>=
literal|1
operator|)
if|if
condition|(
name|zds
operator|->
name|legacyContext
condition|)
name|ZSTD_freeLegacyStreamContext
argument_list|(
name|zds
operator|->
name|legacyContext
argument_list|,
name|zds
operator|->
name|previousLegacyVersion
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ZSTD_free
argument_list|(
name|zds
argument_list|,
name|cMem
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* *** Initialization *** */
end_comment

begin_function
name|size_t
name|ZSTD_DStreamInSize
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|ZSTD_BLOCKSIZE_ABSOLUTEMAX
operator|+
name|ZSTD_blockHeaderSize
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTD_DStreamOutSize
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|ZSTD_BLOCKSIZE_ABSOLUTEMAX
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTD_initDStream_usingDict
parameter_list|(
name|ZSTD_DStream
modifier|*
name|zds
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|)
block|{
name|zds
operator|->
name|stage
operator|=
name|zdss_loadHeader
expr_stmt|;
name|zds
operator|->
name|lhSize
operator|=
name|zds
operator|->
name|inPos
operator|=
name|zds
operator|->
name|outStart
operator|=
name|zds
operator|->
name|outEnd
operator|=
literal|0
expr_stmt|;
name|ZSTD_freeDDict
argument_list|(
name|zds
operator|->
name|ddictLocal
argument_list|)
expr_stmt|;
if|if
condition|(
name|dict
operator|&&
name|dictSize
operator|>=
literal|8
condition|)
block|{
name|zds
operator|->
name|ddictLocal
operator|=
name|ZSTD_createDDict
argument_list|(
name|dict
argument_list|,
name|dictSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|zds
operator|->
name|ddictLocal
operator|==
name|NULL
condition|)
return|return
name|ERROR
argument_list|(
name|memory_allocation
argument_list|)
return|;
block|}
else|else
name|zds
operator|->
name|ddictLocal
operator|=
name|NULL
expr_stmt|;
name|zds
operator|->
name|ddict
operator|=
name|zds
operator|->
name|ddictLocal
expr_stmt|;
name|zds
operator|->
name|legacyVersion
operator|=
literal|0
expr_stmt|;
name|zds
operator|->
name|hostageByte
operator|=
literal|0
expr_stmt|;
return|return
name|ZSTD_frameHeaderSize_prefix
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTD_initDStream
parameter_list|(
name|ZSTD_DStream
modifier|*
name|zds
parameter_list|)
block|{
return|return
name|ZSTD_initDStream_usingDict
argument_list|(
name|zds
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTD_initDStream_usingDDict
parameter_list|(
name|ZSTD_DStream
modifier|*
name|zds
parameter_list|,
specifier|const
name|ZSTD_DDict
modifier|*
name|ddict
parameter_list|)
comment|/**< note : ddict will just be referenced, and must outlive decompression session */
block|{
name|size_t
specifier|const
name|initResult
init|=
name|ZSTD_initDStream
argument_list|(
name|zds
argument_list|)
decl_stmt|;
name|zds
operator|->
name|ddict
operator|=
name|ddict
expr_stmt|;
return|return
name|initResult
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTD_resetDStream
parameter_list|(
name|ZSTD_DStream
modifier|*
name|zds
parameter_list|)
block|{
name|zds
operator|->
name|stage
operator|=
name|zdss_loadHeader
expr_stmt|;
name|zds
operator|->
name|lhSize
operator|=
name|zds
operator|->
name|inPos
operator|=
name|zds
operator|->
name|outStart
operator|=
name|zds
operator|->
name|outEnd
operator|=
literal|0
expr_stmt|;
name|zds
operator|->
name|legacyVersion
operator|=
literal|0
expr_stmt|;
name|zds
operator|->
name|hostageByte
operator|=
literal|0
expr_stmt|;
return|return
name|ZSTD_frameHeaderSize_prefix
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTD_setDStreamParameter
parameter_list|(
name|ZSTD_DStream
modifier|*
name|zds
parameter_list|,
name|ZSTD_DStreamParameter_e
name|paramType
parameter_list|,
name|unsigned
name|paramValue
parameter_list|)
block|{
switch|switch
condition|(
name|paramType
condition|)
block|{
default|default :
return|return
name|ERROR
argument_list|(
name|parameter_unknown
argument_list|)
return|;
case|case
name|DStream_p_maxWindowSize
case|:
name|zds
operator|->
name|maxWindowSize
operator|=
name|paramValue
condition|?
name|paramValue
else|:
call|(
name|U32
call|)
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTD_sizeof_DStream
parameter_list|(
specifier|const
name|ZSTD_DStream
modifier|*
name|zds
parameter_list|)
block|{
if|if
condition|(
name|zds
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* support sizeof on NULL */
return|return
sizeof|sizeof
argument_list|(
operator|*
name|zds
argument_list|)
operator|+
name|ZSTD_sizeof_DCtx
argument_list|(
name|zds
operator|->
name|dctx
argument_list|)
operator|+
name|ZSTD_sizeof_DDict
argument_list|(
name|zds
operator|->
name|ddictLocal
argument_list|)
operator|+
name|zds
operator|->
name|inBuffSize
operator|+
name|zds
operator|->
name|outBuffSize
return|;
block|}
end_function

begin_comment
comment|/* *****   Decompression   ***** */
end_comment

begin_function
name|MEM_STATIC
name|size_t
name|ZSTD_limitCopy
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
name|size_t
specifier|const
name|length
init|=
name|MIN
argument_list|(
name|dstCapacity
argument_list|,
name|srcSize
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTD_decompressStream
parameter_list|(
name|ZSTD_DStream
modifier|*
name|zds
parameter_list|,
name|ZSTD_outBuffer
modifier|*
name|output
parameter_list|,
name|ZSTD_inBuffer
modifier|*
name|input
parameter_list|)
block|{
specifier|const
name|char
modifier|*
specifier|const
name|istart
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|input
operator|->
name|src
operator|)
operator|+
name|input
operator|->
name|pos
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|iend
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|input
operator|->
name|src
operator|)
operator|+
name|input
operator|->
name|size
decl_stmt|;
specifier|const
name|char
modifier|*
name|ip
init|=
name|istart
decl_stmt|;
name|char
modifier|*
specifier|const
name|ostart
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|output
operator|->
name|dst
operator|)
operator|+
name|output
operator|->
name|pos
decl_stmt|;
name|char
modifier|*
specifier|const
name|oend
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|output
operator|->
name|dst
operator|)
operator|+
name|output
operator|->
name|size
decl_stmt|;
name|char
modifier|*
name|op
init|=
name|ostart
decl_stmt|;
name|U32
name|someMoreWork
init|=
literal|1
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ZSTD_LEGACY_SUPPORT
argument_list|)
operator|&&
operator|(
name|ZSTD_LEGACY_SUPPORT
operator|>=
literal|1
operator|)
if|if
condition|(
name|zds
operator|->
name|legacyVersion
condition|)
return|return
name|ZSTD_decompressLegacyStream
argument_list|(
name|zds
operator|->
name|legacyContext
argument_list|,
name|zds
operator|->
name|legacyVersion
argument_list|,
name|output
argument_list|,
name|input
argument_list|)
return|;
endif|#
directive|endif
while|while
condition|(
name|someMoreWork
condition|)
block|{
switch|switch
condition|(
name|zds
operator|->
name|stage
condition|)
block|{
case|case
name|zdss_init
case|:
name|ZSTD_resetDStream
argument_list|(
name|zds
argument_list|)
expr_stmt|;
comment|/* transparent reset on starting decoding a new frame */
comment|/* fall-through */
case|case
name|zdss_loadHeader
case|:
block|{
name|size_t
specifier|const
name|hSize
init|=
name|ZSTD_getFrameParams
argument_list|(
operator|&
name|zds
operator|->
name|fParams
argument_list|,
name|zds
operator|->
name|headerBuffer
argument_list|,
name|zds
operator|->
name|lhSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|hSize
argument_list|)
condition|)
if|#
directive|if
name|defined
argument_list|(
name|ZSTD_LEGACY_SUPPORT
argument_list|)
operator|&&
operator|(
name|ZSTD_LEGACY_SUPPORT
operator|>=
literal|1
operator|)
block|{
name|U32
specifier|const
name|legacyVersion
init|=
name|ZSTD_isLegacy
argument_list|(
name|istart
argument_list|,
name|iend
operator|-
name|istart
argument_list|)
decl_stmt|;
if|if
condition|(
name|legacyVersion
condition|)
block|{
specifier|const
name|void
modifier|*
specifier|const
name|dict
init|=
name|zds
operator|->
name|ddict
condition|?
name|zds
operator|->
name|ddict
operator|->
name|dictContent
else|:
name|NULL
decl_stmt|;
name|size_t
specifier|const
name|dictSize
init|=
name|zds
operator|->
name|ddict
condition|?
name|zds
operator|->
name|ddict
operator|->
name|dictSize
else|:
literal|0
decl_stmt|;
name|CHECK_F
argument_list|(
name|ZSTD_initLegacyStream
argument_list|(
operator|&
name|zds
operator|->
name|legacyContext
argument_list|,
name|zds
operator|->
name|previousLegacyVersion
argument_list|,
name|legacyVersion
argument_list|,
name|dict
argument_list|,
name|dictSize
argument_list|)
argument_list|)
expr_stmt|;
name|zds
operator|->
name|legacyVersion
operator|=
name|zds
operator|->
name|previousLegacyVersion
operator|=
name|legacyVersion
expr_stmt|;
return|return
name|ZSTD_decompressLegacyStream
argument_list|(
name|zds
operator|->
name|legacyContext
argument_list|,
name|zds
operator|->
name|legacyVersion
argument_list|,
name|output
argument_list|,
name|input
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|hSize
return|;
comment|/* error */
block|}
block|}
else|#
directive|else
return|return
name|hSize
return|;
endif|#
directive|endif
if|if
condition|(
name|hSize
operator|!=
literal|0
condition|)
block|{
comment|/* need more input */
name|size_t
specifier|const
name|toLoad
init|=
name|hSize
operator|-
name|zds
operator|->
name|lhSize
decl_stmt|;
comment|/* if hSize!=0, hSize> zds->lhSize */
if|if
condition|(
name|toLoad
operator|>
call|(
name|size_t
call|)
argument_list|(
name|iend
operator|-
name|ip
argument_list|)
condition|)
block|{
comment|/* not enough input to load full header */
name|memcpy
argument_list|(
name|zds
operator|->
name|headerBuffer
operator|+
name|zds
operator|->
name|lhSize
argument_list|,
name|ip
argument_list|,
name|iend
operator|-
name|ip
argument_list|)
expr_stmt|;
name|zds
operator|->
name|lhSize
operator|+=
name|iend
operator|-
name|ip
expr_stmt|;
name|input
operator|->
name|pos
operator|=
name|input
operator|->
name|size
expr_stmt|;
return|return
operator|(
name|MAX
argument_list|(
name|ZSTD_frameHeaderSize_min
argument_list|,
name|hSize
argument_list|)
operator|-
name|zds
operator|->
name|lhSize
operator|)
operator|+
name|ZSTD_blockHeaderSize
return|;
comment|/* remaining header bytes + next block header */
block|}
name|memcpy
argument_list|(
name|zds
operator|->
name|headerBuffer
operator|+
name|zds
operator|->
name|lhSize
argument_list|,
name|ip
argument_list|,
name|toLoad
argument_list|)
expr_stmt|;
name|zds
operator|->
name|lhSize
operator|=
name|hSize
expr_stmt|;
name|ip
operator|+=
name|toLoad
expr_stmt|;
break|break;
block|}
block|}
comment|/* check for single-pass mode opportunity */
if|if
condition|(
name|zds
operator|->
name|fParams
operator|.
name|frameContentSize
operator|&&
name|zds
operator|->
name|fParams
operator|.
name|windowSize
comment|/* skippable frame if == 0 */
operator|&&
call|(
name|U64
call|)
argument_list|(
name|size_t
argument_list|)
argument_list|(
name|oend
operator|-
name|op
argument_list|)
operator|>=
name|zds
operator|->
name|fParams
operator|.
name|frameContentSize
condition|)
block|{
name|size_t
specifier|const
name|cSize
init|=
name|ZSTD_findFrameCompressedSize
argument_list|(
name|istart
argument_list|,
name|iend
operator|-
name|istart
argument_list|)
decl_stmt|;
if|if
condition|(
name|cSize
operator|<=
call|(
name|size_t
call|)
argument_list|(
name|iend
operator|-
name|istart
argument_list|)
condition|)
block|{
name|size_t
specifier|const
name|decompressedSize
init|=
name|ZSTD_decompress_usingDDict
argument_list|(
name|zds
operator|->
name|dctx
argument_list|,
name|op
argument_list|,
name|oend
operator|-
name|op
argument_list|,
name|istart
argument_list|,
name|cSize
argument_list|,
name|zds
operator|->
name|ddict
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|decompressedSize
argument_list|)
condition|)
return|return
name|decompressedSize
return|;
name|ip
operator|=
name|istart
operator|+
name|cSize
expr_stmt|;
name|op
operator|+=
name|decompressedSize
expr_stmt|;
name|zds
operator|->
name|dctx
operator|->
name|expected
operator|=
literal|0
expr_stmt|;
name|zds
operator|->
name|stage
operator|=
name|zdss_init
expr_stmt|;
name|someMoreWork
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/* Consume header */
name|ZSTD_refDDict
argument_list|(
name|zds
operator|->
name|dctx
argument_list|,
name|zds
operator|->
name|ddict
argument_list|)
expr_stmt|;
block|{
name|size_t
specifier|const
name|h1Size
init|=
name|ZSTD_nextSrcSizeToDecompress
argument_list|(
name|zds
operator|->
name|dctx
argument_list|)
decl_stmt|;
comment|/* == ZSTD_frameHeaderSize_prefix */
name|CHECK_F
argument_list|(
name|ZSTD_decompressContinue
argument_list|(
name|zds
operator|->
name|dctx
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|zds
operator|->
name|headerBuffer
argument_list|,
name|h1Size
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|size_t
specifier|const
name|h2Size
init|=
name|ZSTD_nextSrcSizeToDecompress
argument_list|(
name|zds
operator|->
name|dctx
argument_list|)
decl_stmt|;
name|CHECK_F
argument_list|(
name|ZSTD_decompressContinue
argument_list|(
name|zds
operator|->
name|dctx
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|zds
operator|->
name|headerBuffer
operator|+
name|h1Size
argument_list|,
name|h2Size
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|zds
operator|->
name|fParams
operator|.
name|windowSize
operator|=
name|MAX
argument_list|(
name|zds
operator|->
name|fParams
operator|.
name|windowSize
argument_list|,
literal|1U
operator|<<
name|ZSTD_WINDOWLOG_ABSOLUTEMIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|zds
operator|->
name|fParams
operator|.
name|windowSize
operator|>
name|zds
operator|->
name|maxWindowSize
condition|)
return|return
name|ERROR
argument_list|(
name|frameParameter_windowTooLarge
argument_list|)
return|;
comment|/* Adapt buffer sizes to frame header instructions */
block|{
name|size_t
specifier|const
name|blockSize
init|=
name|MIN
argument_list|(
name|zds
operator|->
name|fParams
operator|.
name|windowSize
argument_list|,
name|ZSTD_BLOCKSIZE_ABSOLUTEMAX
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|neededOutSize
init|=
name|zds
operator|->
name|fParams
operator|.
name|windowSize
operator|+
name|blockSize
operator|+
name|WILDCOPY_OVERLENGTH
operator|*
literal|2
decl_stmt|;
name|zds
operator|->
name|blockSize
operator|=
name|blockSize
expr_stmt|;
if|if
condition|(
name|zds
operator|->
name|inBuffSize
operator|<
name|blockSize
condition|)
block|{
name|ZSTD_free
argument_list|(
name|zds
operator|->
name|inBuff
argument_list|,
name|zds
operator|->
name|customMem
argument_list|)
expr_stmt|;
name|zds
operator|->
name|inBuffSize
operator|=
name|blockSize
expr_stmt|;
name|zds
operator|->
name|inBuff
operator|=
operator|(
name|char
operator|*
operator|)
name|ZSTD_malloc
argument_list|(
name|blockSize
argument_list|,
name|zds
operator|->
name|customMem
argument_list|)
expr_stmt|;
if|if
condition|(
name|zds
operator|->
name|inBuff
operator|==
name|NULL
condition|)
return|return
name|ERROR
argument_list|(
name|memory_allocation
argument_list|)
return|;
block|}
if|if
condition|(
name|zds
operator|->
name|outBuffSize
operator|<
name|neededOutSize
condition|)
block|{
name|ZSTD_free
argument_list|(
name|zds
operator|->
name|outBuff
argument_list|,
name|zds
operator|->
name|customMem
argument_list|)
expr_stmt|;
name|zds
operator|->
name|outBuffSize
operator|=
name|neededOutSize
expr_stmt|;
name|zds
operator|->
name|outBuff
operator|=
operator|(
name|char
operator|*
operator|)
name|ZSTD_malloc
argument_list|(
name|neededOutSize
argument_list|,
name|zds
operator|->
name|customMem
argument_list|)
expr_stmt|;
if|if
condition|(
name|zds
operator|->
name|outBuff
operator|==
name|NULL
condition|)
return|return
name|ERROR
argument_list|(
name|memory_allocation
argument_list|)
return|;
block|}
block|}
name|zds
operator|->
name|stage
operator|=
name|zdss_read
expr_stmt|;
comment|/* pass-through */
case|case
name|zdss_read
case|:
block|{
name|size_t
specifier|const
name|neededInSize
init|=
name|ZSTD_nextSrcSizeToDecompress
argument_list|(
name|zds
operator|->
name|dctx
argument_list|)
decl_stmt|;
if|if
condition|(
name|neededInSize
operator|==
literal|0
condition|)
block|{
comment|/* end of frame */
name|zds
operator|->
name|stage
operator|=
name|zdss_init
expr_stmt|;
name|someMoreWork
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|iend
operator|-
name|ip
argument_list|)
operator|>=
name|neededInSize
condition|)
block|{
comment|/* decode directly from src */
specifier|const
name|int
name|isSkipFrame
init|=
name|ZSTD_isSkipFrame
argument_list|(
name|zds
operator|->
name|dctx
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|decodedSize
init|=
name|ZSTD_decompressContinue
argument_list|(
name|zds
operator|->
name|dctx
argument_list|,
name|zds
operator|->
name|outBuff
operator|+
name|zds
operator|->
name|outStart
argument_list|,
operator|(
name|isSkipFrame
condition|?
literal|0
else|:
name|zds
operator|->
name|outBuffSize
operator|-
name|zds
operator|->
name|outStart
operator|)
argument_list|,
name|ip
argument_list|,
name|neededInSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|decodedSize
argument_list|)
condition|)
return|return
name|decodedSize
return|;
name|ip
operator|+=
name|neededInSize
expr_stmt|;
if|if
condition|(
operator|!
name|decodedSize
operator|&&
operator|!
name|isSkipFrame
condition|)
break|break;
comment|/* this was just a header */
name|zds
operator|->
name|outEnd
operator|=
name|zds
operator|->
name|outStart
operator|+
name|decodedSize
expr_stmt|;
name|zds
operator|->
name|stage
operator|=
name|zdss_flush
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ip
operator|==
name|iend
condition|)
block|{
name|someMoreWork
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* no more input */
name|zds
operator|->
name|stage
operator|=
name|zdss_load
expr_stmt|;
comment|/* pass-through */
block|}
case|case
name|zdss_load
case|:
block|{
name|size_t
specifier|const
name|neededInSize
init|=
name|ZSTD_nextSrcSizeToDecompress
argument_list|(
name|zds
operator|->
name|dctx
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|toLoad
init|=
name|neededInSize
operator|-
name|zds
operator|->
name|inPos
decl_stmt|;
comment|/* should always be<= remaining space within inBuff */
name|size_t
name|loadedSize
decl_stmt|;
if|if
condition|(
name|toLoad
operator|>
name|zds
operator|->
name|inBuffSize
operator|-
name|zds
operator|->
name|inPos
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* should never happen */
name|loadedSize
operator|=
name|ZSTD_limitCopy
argument_list|(
name|zds
operator|->
name|inBuff
operator|+
name|zds
operator|->
name|inPos
argument_list|,
name|toLoad
argument_list|,
name|ip
argument_list|,
name|iend
operator|-
name|ip
argument_list|)
expr_stmt|;
name|ip
operator|+=
name|loadedSize
expr_stmt|;
name|zds
operator|->
name|inPos
operator|+=
name|loadedSize
expr_stmt|;
if|if
condition|(
name|loadedSize
operator|<
name|toLoad
condition|)
block|{
name|someMoreWork
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* not enough input, wait for more */
comment|/* decode loaded input */
block|{
specifier|const
name|int
name|isSkipFrame
init|=
name|ZSTD_isSkipFrame
argument_list|(
name|zds
operator|->
name|dctx
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|decodedSize
init|=
name|ZSTD_decompressContinue
argument_list|(
name|zds
operator|->
name|dctx
argument_list|,
name|zds
operator|->
name|outBuff
operator|+
name|zds
operator|->
name|outStart
argument_list|,
name|zds
operator|->
name|outBuffSize
operator|-
name|zds
operator|->
name|outStart
argument_list|,
name|zds
operator|->
name|inBuff
argument_list|,
name|neededInSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|decodedSize
argument_list|)
condition|)
return|return
name|decodedSize
return|;
name|zds
operator|->
name|inPos
operator|=
literal|0
expr_stmt|;
comment|/* input is consumed */
if|if
condition|(
operator|!
name|decodedSize
operator|&&
operator|!
name|isSkipFrame
condition|)
block|{
name|zds
operator|->
name|stage
operator|=
name|zdss_read
expr_stmt|;
break|break;
block|}
comment|/* this was just a header */
name|zds
operator|->
name|outEnd
operator|=
name|zds
operator|->
name|outStart
operator|+
name|decodedSize
expr_stmt|;
name|zds
operator|->
name|stage
operator|=
name|zdss_flush
expr_stmt|;
comment|/* pass-through */
block|}
block|}
case|case
name|zdss_flush
case|:
block|{
name|size_t
specifier|const
name|toFlushSize
init|=
name|zds
operator|->
name|outEnd
operator|-
name|zds
operator|->
name|outStart
decl_stmt|;
name|size_t
specifier|const
name|flushedSize
init|=
name|ZSTD_limitCopy
argument_list|(
name|op
argument_list|,
name|oend
operator|-
name|op
argument_list|,
name|zds
operator|->
name|outBuff
operator|+
name|zds
operator|->
name|outStart
argument_list|,
name|toFlushSize
argument_list|)
decl_stmt|;
name|op
operator|+=
name|flushedSize
expr_stmt|;
name|zds
operator|->
name|outStart
operator|+=
name|flushedSize
expr_stmt|;
if|if
condition|(
name|flushedSize
operator|==
name|toFlushSize
condition|)
block|{
comment|/* flush completed */
name|zds
operator|->
name|stage
operator|=
name|zdss_read
expr_stmt|;
if|if
condition|(
name|zds
operator|->
name|outStart
operator|+
name|zds
operator|->
name|blockSize
operator|>
name|zds
operator|->
name|outBuffSize
condition|)
name|zds
operator|->
name|outStart
operator|=
name|zds
operator|->
name|outEnd
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* cannot complete flush */
name|someMoreWork
operator|=
literal|0
expr_stmt|;
break|break;
block|}
default|default:
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
comment|/* impossible */
block|}
block|}
comment|/* result */
name|input
operator|->
name|pos
operator|+=
call|(
name|size_t
call|)
argument_list|(
name|ip
operator|-
name|istart
argument_list|)
expr_stmt|;
name|output
operator|->
name|pos
operator|+=
call|(
name|size_t
call|)
argument_list|(
name|op
operator|-
name|ostart
argument_list|)
expr_stmt|;
block|{
name|size_t
name|nextSrcSizeHint
init|=
name|ZSTD_nextSrcSizeToDecompress
argument_list|(
name|zds
operator|->
name|dctx
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|nextSrcSizeHint
condition|)
block|{
comment|/* frame fully decoded */
if|if
condition|(
name|zds
operator|->
name|outEnd
operator|==
name|zds
operator|->
name|outStart
condition|)
block|{
comment|/* output fully flushed */
if|if
condition|(
name|zds
operator|->
name|hostageByte
condition|)
block|{
if|if
condition|(
name|input
operator|->
name|pos
operator|>=
name|input
operator|->
name|size
condition|)
block|{
name|zds
operator|->
name|stage
operator|=
name|zdss_read
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* can't release hostage (not present) */
name|input
operator|->
name|pos
operator|++
expr_stmt|;
comment|/* release hostage */
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|zds
operator|->
name|hostageByte
condition|)
block|{
comment|/* output not fully flushed; keep last byte as hostage; will be released when all output is flushed */
name|input
operator|->
name|pos
operator|--
expr_stmt|;
comment|/* note : pos> 0, otherwise, impossible to finish reading last block */
name|zds
operator|->
name|hostageByte
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
name|nextSrcSizeHint
operator|+=
name|ZSTD_blockHeaderSize
operator|*
operator|(
name|ZSTD_nextInputType
argument_list|(
name|zds
operator|->
name|dctx
argument_list|)
operator|==
name|ZSTDnit_block
operator|)
expr_stmt|;
comment|/* preload header of next block */
if|if
condition|(
name|zds
operator|->
name|inPos
operator|>
name|nextSrcSizeHint
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
comment|/* should never happen */
name|nextSrcSizeHint
operator|-=
name|zds
operator|->
name|inPos
expr_stmt|;
comment|/* already loaded*/
return|return
name|nextSrcSizeHint
return|;
block|}
block|}
end_function

end_unit

