begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ******************************************************************    Huffman decoder, part of New Generation Entropy library    Copyright (C) 2013-2016, Yann Collet.     BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)     Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are    met:         * Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer.        * Redistributions in binary form must reproduce the above    copyright notice, this list of conditions and the following disclaimer    in the documentation and/or other materials provided with the    distribution.     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.      You can contact the author at :     - FSE+HUF source repository : https://github.com/Cyan4973/FiniteStateEntropy     - Public forum : https://groups.google.com/forum/#!forum/lz4c ****************************************************************** */
end_comment

begin_comment
comment|/* ************************************************************** *  Compiler specifics ****************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_comment
comment|/* Visual Studio */
end_comment

begin_define
define|#
directive|define
name|FORCE_INLINE
value|static __forceinline
end_define

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4127
name|)
end_pragma

begin_comment
comment|/* disable: C4127: conditional expression is constant */
end_comment

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
operator|||
name|defined
argument_list|(
name|__STDC_VERSION__
argument_list|)
operator|&&
name|__STDC_VERSION__
operator|>=
literal|199901L
end_if

begin_comment
comment|/* C99 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|FORCE_INLINE
value|static inline __attribute__((always_inline))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FORCE_INLINE
value|static inline
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FORCE_INLINE
value|static
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __STDC_VERSION__ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ************************************************************** *  Dependencies ****************************************************************/
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* memcpy, memset */
end_comment

begin_include
include|#
directive|include
file|"bitstream.h"
end_include

begin_comment
comment|/* BIT_* */
end_comment

begin_include
include|#
directive|include
file|"fse.h"
end_include

begin_comment
comment|/* header compression */
end_comment

begin_define
define|#
directive|define
name|HUF_STATIC_LINKING_ONLY
end_define

begin_include
include|#
directive|include
file|"huf.h"
end_include

begin_comment
comment|/* ************************************************************** *  Error Management ****************************************************************/
end_comment

begin_define
define|#
directive|define
name|HUF_STATIC_ASSERT
parameter_list|(
name|c
parameter_list|)
value|{ enum { HUF_static_assert = 1/(int)(!!(c)) }; }
end_define

begin_comment
comment|/* use only *after* variable declarations */
end_comment

begin_comment
comment|/*-***************************/
end_comment

begin_comment
comment|/*  generic DTableDesc       */
end_comment

begin_comment
comment|/*-***************************/
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|BYTE
name|maxTableLog
decl_stmt|;
name|BYTE
name|tableType
decl_stmt|;
name|BYTE
name|tableLog
decl_stmt|;
name|BYTE
name|reserved
decl_stmt|;
block|}
name|DTableDesc
typedef|;
end_typedef

begin_function
specifier|static
name|DTableDesc
name|HUF_getDTableDesc
parameter_list|(
specifier|const
name|HUF_DTable
modifier|*
name|table
parameter_list|)
block|{
name|DTableDesc
name|dtd
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|dtd
argument_list|,
name|table
argument_list|,
sizeof|sizeof
argument_list|(
name|dtd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|dtd
return|;
block|}
end_function

begin_comment
comment|/*-***************************/
end_comment

begin_comment
comment|/*  single-symbol decoding   */
end_comment

begin_comment
comment|/*-***************************/
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|BYTE
name|byte
decl_stmt|;
name|BYTE
name|nbBits
decl_stmt|;
block|}
name|HUF_DEltX2
typedef|;
end_typedef

begin_comment
comment|/* single-symbol decoding */
end_comment

begin_function
name|size_t
name|HUF_readDTableX2
parameter_list|(
name|HUF_DTable
modifier|*
name|DTable
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
name|BYTE
name|huffWeight
index|[
name|HUF_SYMBOLVALUE_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|U32
name|rankVal
index|[
name|HUF_TABLELOG_ABSOLUTEMAX
operator|+
literal|1
index|]
decl_stmt|;
comment|/* large enough for values from 0 to 16 */
name|U32
name|tableLog
init|=
literal|0
decl_stmt|;
name|U32
name|nbSymbols
init|=
literal|0
decl_stmt|;
name|size_t
name|iSize
decl_stmt|;
name|void
modifier|*
specifier|const
name|dtPtr
init|=
name|DTable
operator|+
literal|1
decl_stmt|;
name|HUF_DEltX2
modifier|*
specifier|const
name|dt
init|=
operator|(
name|HUF_DEltX2
operator|*
operator|)
name|dtPtr
decl_stmt|;
name|HUF_STATIC_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|DTableDesc
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|HUF_DTable
argument_list|)
argument_list|)
expr_stmt|;
comment|/* memset(huffWeight, 0, sizeof(huffWeight)); */
comment|/* is not necessary, even though some analyzer complain ... */
name|iSize
operator|=
name|HUF_readStats
argument_list|(
name|huffWeight
argument_list|,
name|HUF_SYMBOLVALUE_MAX
operator|+
literal|1
argument_list|,
name|rankVal
argument_list|,
operator|&
name|nbSymbols
argument_list|,
operator|&
name|tableLog
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|HUF_isError
argument_list|(
name|iSize
argument_list|)
condition|)
return|return
name|iSize
return|;
comment|/* Table header */
block|{
name|DTableDesc
name|dtd
init|=
name|HUF_getDTableDesc
argument_list|(
name|DTable
argument_list|)
decl_stmt|;
if|if
condition|(
name|tableLog
operator|>
call|(
name|U32
call|)
argument_list|(
name|dtd
operator|.
name|maxTableLog
operator|+
literal|1
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|tableLog_tooLarge
argument_list|)
return|;
comment|/* DTable too small, Huffman tree cannot fit in */
name|dtd
operator|.
name|tableType
operator|=
literal|0
expr_stmt|;
name|dtd
operator|.
name|tableLog
operator|=
operator|(
name|BYTE
operator|)
name|tableLog
expr_stmt|;
name|memcpy
argument_list|(
name|DTable
argument_list|,
operator|&
name|dtd
argument_list|,
sizeof|sizeof
argument_list|(
name|dtd
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Calculate starting value for each rank */
block|{
name|U32
name|n
decl_stmt|,
name|nextRankStart
init|=
literal|0
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|1
init|;
name|n
operator|<
name|tableLog
operator|+
literal|1
condition|;
name|n
operator|++
control|)
block|{
name|U32
specifier|const
name|current
init|=
name|nextRankStart
decl_stmt|;
name|nextRankStart
operator|+=
operator|(
name|rankVal
index|[
name|n
index|]
operator|<<
operator|(
name|n
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|rankVal
index|[
name|n
index|]
operator|=
name|current
expr_stmt|;
block|}
block|}
comment|/* fill DTable */
block|{
name|U32
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nbSymbols
condition|;
name|n
operator|++
control|)
block|{
name|U32
specifier|const
name|w
init|=
name|huffWeight
index|[
name|n
index|]
decl_stmt|;
name|U32
specifier|const
name|length
init|=
operator|(
literal|1
operator|<<
name|w
operator|)
operator|>>
literal|1
decl_stmt|;
name|U32
name|u
decl_stmt|;
name|HUF_DEltX2
name|D
decl_stmt|;
name|D
operator|.
name|byte
operator|=
operator|(
name|BYTE
operator|)
name|n
expr_stmt|;
name|D
operator|.
name|nbBits
operator|=
call|(
name|BYTE
call|)
argument_list|(
name|tableLog
operator|+
literal|1
operator|-
name|w
argument_list|)
expr_stmt|;
for|for
control|(
name|u
operator|=
name|rankVal
index|[
name|w
index|]
init|;
name|u
operator|<
name|rankVal
index|[
name|w
index|]
operator|+
name|length
condition|;
name|u
operator|++
control|)
name|dt
index|[
name|u
index|]
operator|=
name|D
expr_stmt|;
name|rankVal
index|[
name|w
index|]
operator|+=
name|length
expr_stmt|;
block|}
block|}
return|return
name|iSize
return|;
block|}
end_function

begin_function
specifier|static
name|BYTE
name|HUF_decodeSymbolX2
parameter_list|(
name|BIT_DStream_t
modifier|*
name|Dstream
parameter_list|,
specifier|const
name|HUF_DEltX2
modifier|*
name|dt
parameter_list|,
specifier|const
name|U32
name|dtLog
parameter_list|)
block|{
name|size_t
specifier|const
name|val
init|=
name|BIT_lookBitsFast
argument_list|(
name|Dstream
argument_list|,
name|dtLog
argument_list|)
decl_stmt|;
comment|/* note : dtLog>= 1 */
name|BYTE
specifier|const
name|c
init|=
name|dt
index|[
name|val
index|]
operator|.
name|byte
decl_stmt|;
name|BIT_skipBits
argument_list|(
name|Dstream
argument_list|,
name|dt
index|[
name|val
index|]
operator|.
name|nbBits
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_define
define|#
directive|define
name|HUF_DECODE_SYMBOLX2_0
parameter_list|(
name|ptr
parameter_list|,
name|DStreamPtr
parameter_list|)
define|\
value|*ptr++ = HUF_decodeSymbolX2(DStreamPtr, dt, dtLog)
end_define

begin_define
define|#
directive|define
name|HUF_DECODE_SYMBOLX2_1
parameter_list|(
name|ptr
parameter_list|,
name|DStreamPtr
parameter_list|)
define|\
value|if (MEM_64bits() || (HUF_TABLELOG_MAX<=12)) \         HUF_DECODE_SYMBOLX2_0(ptr, DStreamPtr)
end_define

begin_define
define|#
directive|define
name|HUF_DECODE_SYMBOLX2_2
parameter_list|(
name|ptr
parameter_list|,
name|DStreamPtr
parameter_list|)
define|\
value|if (MEM_64bits()) \         HUF_DECODE_SYMBOLX2_0(ptr, DStreamPtr)
end_define

begin_function
name|FORCE_INLINE
name|size_t
name|HUF_decodeStreamX2
parameter_list|(
name|BYTE
modifier|*
name|p
parameter_list|,
name|BIT_DStream_t
modifier|*
specifier|const
name|bitDPtr
parameter_list|,
name|BYTE
modifier|*
specifier|const
name|pEnd
parameter_list|,
specifier|const
name|HUF_DEltX2
modifier|*
specifier|const
name|dt
parameter_list|,
specifier|const
name|U32
name|dtLog
parameter_list|)
block|{
name|BYTE
modifier|*
specifier|const
name|pStart
init|=
name|p
decl_stmt|;
comment|/* up to 4 symbols at a time */
while|while
condition|(
operator|(
name|BIT_reloadDStream
argument_list|(
name|bitDPtr
argument_list|)
operator|==
name|BIT_DStream_unfinished
operator|)
operator|&&
operator|(
name|p
operator|<=
name|pEnd
operator|-
literal|4
operator|)
condition|)
block|{
name|HUF_DECODE_SYMBOLX2_2
argument_list|(
name|p
argument_list|,
name|bitDPtr
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX2_1
argument_list|(
name|p
argument_list|,
name|bitDPtr
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX2_2
argument_list|(
name|p
argument_list|,
name|bitDPtr
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX2_0
argument_list|(
name|p
argument_list|,
name|bitDPtr
argument_list|)
expr_stmt|;
block|}
comment|/* closer to the end */
while|while
condition|(
operator|(
name|BIT_reloadDStream
argument_list|(
name|bitDPtr
argument_list|)
operator|==
name|BIT_DStream_unfinished
operator|)
operator|&&
operator|(
name|p
operator|<
name|pEnd
operator|)
condition|)
name|HUF_DECODE_SYMBOLX2_0
argument_list|(
name|p
argument_list|,
name|bitDPtr
argument_list|)
expr_stmt|;
comment|/* no more data to retrieve from bitstream, hence no need to reload */
while|while
condition|(
name|p
operator|<
name|pEnd
condition|)
name|HUF_DECODE_SYMBOLX2_0
argument_list|(
name|p
argument_list|,
name|bitDPtr
argument_list|)
expr_stmt|;
return|return
name|pEnd
operator|-
name|pStart
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|HUF_decompress1X2_usingDTable_internal
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|HUF_DTable
modifier|*
name|DTable
parameter_list|)
block|{
name|BYTE
modifier|*
name|op
init|=
operator|(
name|BYTE
operator|*
operator|)
name|dst
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|oend
init|=
name|op
operator|+
name|dstSize
decl_stmt|;
specifier|const
name|void
modifier|*
name|dtPtr
init|=
name|DTable
operator|+
literal|1
decl_stmt|;
specifier|const
name|HUF_DEltX2
modifier|*
specifier|const
name|dt
init|=
operator|(
specifier|const
name|HUF_DEltX2
operator|*
operator|)
name|dtPtr
decl_stmt|;
name|BIT_DStream_t
name|bitD
decl_stmt|;
name|DTableDesc
specifier|const
name|dtd
init|=
name|HUF_getDTableDesc
argument_list|(
name|DTable
argument_list|)
decl_stmt|;
name|U32
specifier|const
name|dtLog
init|=
name|dtd
operator|.
name|tableLog
decl_stmt|;
block|{
name|size_t
specifier|const
name|errorCode
init|=
name|BIT_initDStream
argument_list|(
operator|&
name|bitD
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|HUF_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
block|}
name|HUF_decodeStreamX2
argument_list|(
name|op
argument_list|,
operator|&
name|bitD
argument_list|,
name|oend
argument_list|,
name|dt
argument_list|,
name|dtLog
argument_list|)
expr_stmt|;
comment|/* check */
if|if
condition|(
operator|!
name|BIT_endOfDStream
argument_list|(
operator|&
name|bitD
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
return|return
name|dstSize
return|;
block|}
end_function

begin_function
name|size_t
name|HUF_decompress1X2_usingDTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|HUF_DTable
modifier|*
name|DTable
parameter_list|)
block|{
name|DTableDesc
name|dtd
init|=
name|HUF_getDTableDesc
argument_list|(
name|DTable
argument_list|)
decl_stmt|;
if|if
condition|(
name|dtd
operator|.
name|tableType
operator|!=
literal|0
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
return|return
name|HUF_decompress1X2_usingDTable_internal
argument_list|(
name|dst
argument_list|,
name|dstSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|,
name|DTable
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|HUF_decompress1X2_DCtx
parameter_list|(
name|HUF_DTable
modifier|*
name|DCtx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|cSrc
decl_stmt|;
name|size_t
specifier|const
name|hSize
init|=
name|HUF_readDTableX2
argument_list|(
name|DCtx
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|HUF_isError
argument_list|(
name|hSize
argument_list|)
condition|)
return|return
name|hSize
return|;
if|if
condition|(
name|hSize
operator|>=
name|cSrcSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|ip
operator|+=
name|hSize
expr_stmt|;
name|cSrcSize
operator|-=
name|hSize
expr_stmt|;
return|return
name|HUF_decompress1X2_usingDTable_internal
argument_list|(
name|dst
argument_list|,
name|dstSize
argument_list|,
name|ip
argument_list|,
name|cSrcSize
argument_list|,
name|DCtx
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|HUF_decompress1X2
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
block|{
name|HUF_CREATE_STATIC_DTABLEX2
argument_list|(
name|DTable
argument_list|,
name|HUF_TABLELOG_MAX
argument_list|)
expr_stmt|;
return|return
name|HUF_decompress1X2_DCtx
argument_list|(
name|DTable
argument_list|,
name|dst
argument_list|,
name|dstSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|HUF_decompress4X2_usingDTable_internal
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|HUF_DTable
modifier|*
name|DTable
parameter_list|)
block|{
comment|/* Check */
if|if
condition|(
name|cSrcSize
operator|<
literal|10
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* strict minimum : jump table + 1 byte per stream */
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|cSrc
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|ostart
init|=
operator|(
name|BYTE
operator|*
operator|)
name|dst
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|oend
init|=
name|ostart
operator|+
name|dstSize
decl_stmt|;
specifier|const
name|void
modifier|*
specifier|const
name|dtPtr
init|=
name|DTable
operator|+
literal|1
decl_stmt|;
specifier|const
name|HUF_DEltX2
modifier|*
specifier|const
name|dt
init|=
operator|(
specifier|const
name|HUF_DEltX2
operator|*
operator|)
name|dtPtr
decl_stmt|;
comment|/* Init */
name|BIT_DStream_t
name|bitD1
decl_stmt|;
name|BIT_DStream_t
name|bitD2
decl_stmt|;
name|BIT_DStream_t
name|bitD3
decl_stmt|;
name|BIT_DStream_t
name|bitD4
decl_stmt|;
name|size_t
specifier|const
name|length1
init|=
name|MEM_readLE16
argument_list|(
name|istart
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|length2
init|=
name|MEM_readLE16
argument_list|(
name|istart
operator|+
literal|2
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|length3
init|=
name|MEM_readLE16
argument_list|(
name|istart
operator|+
literal|4
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|length4
init|=
name|cSrcSize
operator|-
operator|(
name|length1
operator|+
name|length2
operator|+
name|length3
operator|+
literal|6
operator|)
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart1
init|=
name|istart
operator|+
literal|6
decl_stmt|;
comment|/* jumpTable */
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart2
init|=
name|istart1
operator|+
name|length1
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart3
init|=
name|istart2
operator|+
name|length2
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart4
init|=
name|istart3
operator|+
name|length3
decl_stmt|;
specifier|const
name|size_t
name|segmentSize
init|=
operator|(
name|dstSize
operator|+
literal|3
operator|)
operator|/
literal|4
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|opStart2
init|=
name|ostart
operator|+
name|segmentSize
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|opStart3
init|=
name|opStart2
operator|+
name|segmentSize
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|opStart4
init|=
name|opStart3
operator|+
name|segmentSize
decl_stmt|;
name|BYTE
modifier|*
name|op1
init|=
name|ostart
decl_stmt|;
name|BYTE
modifier|*
name|op2
init|=
name|opStart2
decl_stmt|;
name|BYTE
modifier|*
name|op3
init|=
name|opStart3
decl_stmt|;
name|BYTE
modifier|*
name|op4
init|=
name|opStart4
decl_stmt|;
name|U32
name|endSignal
decl_stmt|;
name|DTableDesc
specifier|const
name|dtd
init|=
name|HUF_getDTableDesc
argument_list|(
name|DTable
argument_list|)
decl_stmt|;
name|U32
specifier|const
name|dtLog
init|=
name|dtd
operator|.
name|tableLog
decl_stmt|;
if|if
condition|(
name|length4
operator|>
name|cSrcSize
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* overflow */
block|{
name|size_t
specifier|const
name|errorCode
init|=
name|BIT_initDStream
argument_list|(
operator|&
name|bitD1
argument_list|,
name|istart1
argument_list|,
name|length1
argument_list|)
decl_stmt|;
if|if
condition|(
name|HUF_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
block|}
block|{
name|size_t
specifier|const
name|errorCode
init|=
name|BIT_initDStream
argument_list|(
operator|&
name|bitD2
argument_list|,
name|istart2
argument_list|,
name|length2
argument_list|)
decl_stmt|;
if|if
condition|(
name|HUF_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
block|}
block|{
name|size_t
specifier|const
name|errorCode
init|=
name|BIT_initDStream
argument_list|(
operator|&
name|bitD3
argument_list|,
name|istart3
argument_list|,
name|length3
argument_list|)
decl_stmt|;
if|if
condition|(
name|HUF_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
block|}
block|{
name|size_t
specifier|const
name|errorCode
init|=
name|BIT_initDStream
argument_list|(
operator|&
name|bitD4
argument_list|,
name|istart4
argument_list|,
name|length4
argument_list|)
decl_stmt|;
if|if
condition|(
name|HUF_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
block|}
comment|/* 16-32 symbols per loop (4-8 symbols per stream) */
name|endSignal
operator|=
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD1
argument_list|)
operator||
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD2
argument_list|)
operator||
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD3
argument_list|)
operator||
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD4
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|(
name|endSignal
operator|==
name|BIT_DStream_unfinished
operator|)
operator|&&
operator|(
name|op4
operator|<
operator|(
name|oend
operator|-
literal|7
operator|)
operator|)
condition|;
control|)
block|{
name|HUF_DECODE_SYMBOLX2_2
argument_list|(
name|op1
argument_list|,
operator|&
name|bitD1
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX2_2
argument_list|(
name|op2
argument_list|,
operator|&
name|bitD2
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX2_2
argument_list|(
name|op3
argument_list|,
operator|&
name|bitD3
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX2_2
argument_list|(
name|op4
argument_list|,
operator|&
name|bitD4
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX2_1
argument_list|(
name|op1
argument_list|,
operator|&
name|bitD1
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX2_1
argument_list|(
name|op2
argument_list|,
operator|&
name|bitD2
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX2_1
argument_list|(
name|op3
argument_list|,
operator|&
name|bitD3
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX2_1
argument_list|(
name|op4
argument_list|,
operator|&
name|bitD4
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX2_2
argument_list|(
name|op1
argument_list|,
operator|&
name|bitD1
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX2_2
argument_list|(
name|op2
argument_list|,
operator|&
name|bitD2
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX2_2
argument_list|(
name|op3
argument_list|,
operator|&
name|bitD3
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX2_2
argument_list|(
name|op4
argument_list|,
operator|&
name|bitD4
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX2_0
argument_list|(
name|op1
argument_list|,
operator|&
name|bitD1
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX2_0
argument_list|(
name|op2
argument_list|,
operator|&
name|bitD2
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX2_0
argument_list|(
name|op3
argument_list|,
operator|&
name|bitD3
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX2_0
argument_list|(
name|op4
argument_list|,
operator|&
name|bitD4
argument_list|)
expr_stmt|;
name|endSignal
operator|=
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD1
argument_list|)
operator||
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD2
argument_list|)
operator||
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD3
argument_list|)
operator||
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD4
argument_list|)
expr_stmt|;
block|}
comment|/* check corruption */
if|if
condition|(
name|op1
operator|>
name|opStart2
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
if|if
condition|(
name|op2
operator|>
name|opStart3
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
if|if
condition|(
name|op3
operator|>
name|opStart4
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* note : op4 supposed already verified within main loop */
comment|/* finish bitStreams one by one */
name|HUF_decodeStreamX2
argument_list|(
name|op1
argument_list|,
operator|&
name|bitD1
argument_list|,
name|opStart2
argument_list|,
name|dt
argument_list|,
name|dtLog
argument_list|)
expr_stmt|;
name|HUF_decodeStreamX2
argument_list|(
name|op2
argument_list|,
operator|&
name|bitD2
argument_list|,
name|opStart3
argument_list|,
name|dt
argument_list|,
name|dtLog
argument_list|)
expr_stmt|;
name|HUF_decodeStreamX2
argument_list|(
name|op3
argument_list|,
operator|&
name|bitD3
argument_list|,
name|opStart4
argument_list|,
name|dt
argument_list|,
name|dtLog
argument_list|)
expr_stmt|;
name|HUF_decodeStreamX2
argument_list|(
name|op4
argument_list|,
operator|&
name|bitD4
argument_list|,
name|oend
argument_list|,
name|dt
argument_list|,
name|dtLog
argument_list|)
expr_stmt|;
comment|/* check */
name|endSignal
operator|=
name|BIT_endOfDStream
argument_list|(
operator|&
name|bitD1
argument_list|)
operator|&
name|BIT_endOfDStream
argument_list|(
operator|&
name|bitD2
argument_list|)
operator|&
name|BIT_endOfDStream
argument_list|(
operator|&
name|bitD3
argument_list|)
operator|&
name|BIT_endOfDStream
argument_list|(
operator|&
name|bitD4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|endSignal
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* decoded size */
return|return
name|dstSize
return|;
block|}
block|}
end_function

begin_function
name|size_t
name|HUF_decompress4X2_usingDTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|HUF_DTable
modifier|*
name|DTable
parameter_list|)
block|{
name|DTableDesc
name|dtd
init|=
name|HUF_getDTableDesc
argument_list|(
name|DTable
argument_list|)
decl_stmt|;
if|if
condition|(
name|dtd
operator|.
name|tableType
operator|!=
literal|0
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
return|return
name|HUF_decompress4X2_usingDTable_internal
argument_list|(
name|dst
argument_list|,
name|dstSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|,
name|DTable
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|HUF_decompress4X2_DCtx
parameter_list|(
name|HUF_DTable
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|cSrc
decl_stmt|;
name|size_t
specifier|const
name|hSize
init|=
name|HUF_readDTableX2
argument_list|(
name|dctx
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|HUF_isError
argument_list|(
name|hSize
argument_list|)
condition|)
return|return
name|hSize
return|;
if|if
condition|(
name|hSize
operator|>=
name|cSrcSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|ip
operator|+=
name|hSize
expr_stmt|;
name|cSrcSize
operator|-=
name|hSize
expr_stmt|;
return|return
name|HUF_decompress4X2_usingDTable_internal
argument_list|(
name|dst
argument_list|,
name|dstSize
argument_list|,
name|ip
argument_list|,
name|cSrcSize
argument_list|,
name|dctx
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|HUF_decompress4X2
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
block|{
name|HUF_CREATE_STATIC_DTABLEX2
argument_list|(
name|DTable
argument_list|,
name|HUF_TABLELOG_MAX
argument_list|)
expr_stmt|;
return|return
name|HUF_decompress4X2_DCtx
argument_list|(
name|DTable
argument_list|,
name|dst
argument_list|,
name|dstSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* *************************/
end_comment

begin_comment
comment|/* double-symbols decoding */
end_comment

begin_comment
comment|/* *************************/
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|U16
name|sequence
decl_stmt|;
name|BYTE
name|nbBits
decl_stmt|;
name|BYTE
name|length
decl_stmt|;
block|}
name|HUF_DEltX4
typedef|;
end_typedef

begin_comment
comment|/* double-symbols decoding */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|BYTE
name|symbol
decl_stmt|;
name|BYTE
name|weight
decl_stmt|;
block|}
name|sortedSymbol_t
typedef|;
end_typedef

begin_comment
comment|/* HUF_fillDTableX4Level2() :  * `rankValOrigin` must be a table of at least (HUF_TABLELOG_MAX + 1) U32 */
end_comment

begin_function
specifier|static
name|void
name|HUF_fillDTableX4Level2
parameter_list|(
name|HUF_DEltX4
modifier|*
name|DTable
parameter_list|,
name|U32
name|sizeLog
parameter_list|,
specifier|const
name|U32
name|consumed
parameter_list|,
specifier|const
name|U32
modifier|*
name|rankValOrigin
parameter_list|,
specifier|const
name|int
name|minWeight
parameter_list|,
specifier|const
name|sortedSymbol_t
modifier|*
name|sortedSymbols
parameter_list|,
specifier|const
name|U32
name|sortedListSize
parameter_list|,
name|U32
name|nbBitsBaseline
parameter_list|,
name|U16
name|baseSeq
parameter_list|)
block|{
name|HUF_DEltX4
name|DElt
decl_stmt|;
name|U32
name|rankVal
index|[
name|HUF_TABLELOG_MAX
operator|+
literal|1
index|]
decl_stmt|;
comment|/* get pre-calculated rankVal */
name|memcpy
argument_list|(
name|rankVal
argument_list|,
name|rankValOrigin
argument_list|,
sizeof|sizeof
argument_list|(
name|rankVal
argument_list|)
argument_list|)
expr_stmt|;
comment|/* fill skipped values */
if|if
condition|(
name|minWeight
operator|>
literal|1
condition|)
block|{
name|U32
name|i
decl_stmt|,
name|skipSize
init|=
name|rankVal
index|[
name|minWeight
index|]
decl_stmt|;
name|MEM_writeLE16
argument_list|(
operator|&
operator|(
name|DElt
operator|.
name|sequence
operator|)
argument_list|,
name|baseSeq
argument_list|)
expr_stmt|;
name|DElt
operator|.
name|nbBits
operator|=
call|(
name|BYTE
call|)
argument_list|(
name|consumed
argument_list|)
expr_stmt|;
name|DElt
operator|.
name|length
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|skipSize
condition|;
name|i
operator|++
control|)
name|DTable
index|[
name|i
index|]
operator|=
name|DElt
expr_stmt|;
block|}
comment|/* fill DTable */
block|{
name|U32
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|sortedListSize
condition|;
name|s
operator|++
control|)
block|{
comment|/* note : sortedSymbols already skipped */
specifier|const
name|U32
name|symbol
init|=
name|sortedSymbols
index|[
name|s
index|]
operator|.
name|symbol
decl_stmt|;
specifier|const
name|U32
name|weight
init|=
name|sortedSymbols
index|[
name|s
index|]
operator|.
name|weight
decl_stmt|;
specifier|const
name|U32
name|nbBits
init|=
name|nbBitsBaseline
operator|-
name|weight
decl_stmt|;
specifier|const
name|U32
name|length
init|=
literal|1
operator|<<
operator|(
name|sizeLog
operator|-
name|nbBits
operator|)
decl_stmt|;
specifier|const
name|U32
name|start
init|=
name|rankVal
index|[
name|weight
index|]
decl_stmt|;
name|U32
name|i
init|=
name|start
decl_stmt|;
specifier|const
name|U32
name|end
init|=
name|start
operator|+
name|length
decl_stmt|;
name|MEM_writeLE16
argument_list|(
operator|&
operator|(
name|DElt
operator|.
name|sequence
operator|)
argument_list|,
call|(
name|U16
call|)
argument_list|(
name|baseSeq
operator|+
operator|(
name|symbol
operator|<<
literal|8
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|DElt
operator|.
name|nbBits
operator|=
call|(
name|BYTE
call|)
argument_list|(
name|nbBits
operator|+
name|consumed
argument_list|)
expr_stmt|;
name|DElt
operator|.
name|length
operator|=
literal|2
expr_stmt|;
do|do
block|{
name|DTable
index|[
name|i
operator|++
index|]
operator|=
name|DElt
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|<
name|end
condition|)
do|;
comment|/* since length>= 1 */
name|rankVal
index|[
name|weight
index|]
operator|+=
name|length
expr_stmt|;
block|}
block|}
block|}
end_function

begin_typedef
typedef|typedef
name|U32
name|rankVal_t
index|[
name|HUF_TABLELOG_MAX
index|]
index|[
name|HUF_TABLELOG_MAX
operator|+
literal|1
index|]
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|HUF_fillDTableX4
parameter_list|(
name|HUF_DEltX4
modifier|*
name|DTable
parameter_list|,
specifier|const
name|U32
name|targetLog
parameter_list|,
specifier|const
name|sortedSymbol_t
modifier|*
name|sortedList
parameter_list|,
specifier|const
name|U32
name|sortedListSize
parameter_list|,
specifier|const
name|U32
modifier|*
name|rankStart
parameter_list|,
name|rankVal_t
name|rankValOrigin
parameter_list|,
specifier|const
name|U32
name|maxWeight
parameter_list|,
specifier|const
name|U32
name|nbBitsBaseline
parameter_list|)
block|{
name|U32
name|rankVal
index|[
name|HUF_TABLELOG_MAX
operator|+
literal|1
index|]
decl_stmt|;
specifier|const
name|int
name|scaleLog
init|=
name|nbBitsBaseline
operator|-
name|targetLog
decl_stmt|;
comment|/* note : targetLog>= srcLog, hence scaleLog<= 1 */
specifier|const
name|U32
name|minBits
init|=
name|nbBitsBaseline
operator|-
name|maxWeight
decl_stmt|;
name|U32
name|s
decl_stmt|;
name|memcpy
argument_list|(
name|rankVal
argument_list|,
name|rankValOrigin
argument_list|,
sizeof|sizeof
argument_list|(
name|rankVal
argument_list|)
argument_list|)
expr_stmt|;
comment|/* fill DTable */
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|sortedListSize
condition|;
name|s
operator|++
control|)
block|{
specifier|const
name|U16
name|symbol
init|=
name|sortedList
index|[
name|s
index|]
operator|.
name|symbol
decl_stmt|;
specifier|const
name|U32
name|weight
init|=
name|sortedList
index|[
name|s
index|]
operator|.
name|weight
decl_stmt|;
specifier|const
name|U32
name|nbBits
init|=
name|nbBitsBaseline
operator|-
name|weight
decl_stmt|;
specifier|const
name|U32
name|start
init|=
name|rankVal
index|[
name|weight
index|]
decl_stmt|;
specifier|const
name|U32
name|length
init|=
literal|1
operator|<<
operator|(
name|targetLog
operator|-
name|nbBits
operator|)
decl_stmt|;
if|if
condition|(
name|targetLog
operator|-
name|nbBits
operator|>=
name|minBits
condition|)
block|{
comment|/* enough room for a second symbol */
name|U32
name|sortedRank
decl_stmt|;
name|int
name|minWeight
init|=
name|nbBits
operator|+
name|scaleLog
decl_stmt|;
if|if
condition|(
name|minWeight
operator|<
literal|1
condition|)
name|minWeight
operator|=
literal|1
expr_stmt|;
name|sortedRank
operator|=
name|rankStart
index|[
name|minWeight
index|]
expr_stmt|;
name|HUF_fillDTableX4Level2
argument_list|(
name|DTable
operator|+
name|start
argument_list|,
name|targetLog
operator|-
name|nbBits
argument_list|,
name|nbBits
argument_list|,
name|rankValOrigin
index|[
name|nbBits
index|]
argument_list|,
name|minWeight
argument_list|,
name|sortedList
operator|+
name|sortedRank
argument_list|,
name|sortedListSize
operator|-
name|sortedRank
argument_list|,
name|nbBitsBaseline
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|HUF_DEltX4
name|DElt
decl_stmt|;
name|MEM_writeLE16
argument_list|(
operator|&
operator|(
name|DElt
operator|.
name|sequence
operator|)
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|DElt
operator|.
name|nbBits
operator|=
call|(
name|BYTE
call|)
argument_list|(
name|nbBits
argument_list|)
expr_stmt|;
name|DElt
operator|.
name|length
operator|=
literal|1
expr_stmt|;
block|{
name|U32
specifier|const
name|end
init|=
name|start
operator|+
name|length
decl_stmt|;
name|U32
name|u
decl_stmt|;
for|for
control|(
name|u
operator|=
name|start
init|;
name|u
operator|<
name|end
condition|;
name|u
operator|++
control|)
name|DTable
index|[
name|u
index|]
operator|=
name|DElt
expr_stmt|;
block|}
block|}
name|rankVal
index|[
name|weight
index|]
operator|+=
name|length
expr_stmt|;
block|}
block|}
end_function

begin_function
name|size_t
name|HUF_readDTableX4
parameter_list|(
name|HUF_DTable
modifier|*
name|DTable
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
name|BYTE
name|weightList
index|[
name|HUF_SYMBOLVALUE_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|sortedSymbol_t
name|sortedSymbol
index|[
name|HUF_SYMBOLVALUE_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|U32
name|rankStats
index|[
name|HUF_TABLELOG_MAX
operator|+
literal|1
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|U32
name|rankStart0
index|[
name|HUF_TABLELOG_MAX
operator|+
literal|2
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|U32
modifier|*
specifier|const
name|rankStart
init|=
name|rankStart0
operator|+
literal|1
decl_stmt|;
name|rankVal_t
name|rankVal
decl_stmt|;
name|U32
name|tableLog
decl_stmt|,
name|maxW
decl_stmt|,
name|sizeOfSort
decl_stmt|,
name|nbSymbols
decl_stmt|;
name|DTableDesc
name|dtd
init|=
name|HUF_getDTableDesc
argument_list|(
name|DTable
argument_list|)
decl_stmt|;
name|U32
specifier|const
name|maxTableLog
init|=
name|dtd
operator|.
name|maxTableLog
decl_stmt|;
name|size_t
name|iSize
decl_stmt|;
name|void
modifier|*
name|dtPtr
init|=
name|DTable
operator|+
literal|1
decl_stmt|;
comment|/* force compiler to avoid strict-aliasing */
name|HUF_DEltX4
modifier|*
specifier|const
name|dt
init|=
operator|(
name|HUF_DEltX4
operator|*
operator|)
name|dtPtr
decl_stmt|;
name|HUF_STATIC_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|HUF_DEltX4
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|HUF_DTable
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if compiler fails here, assertion is wrong */
if|if
condition|(
name|maxTableLog
operator|>
name|HUF_TABLELOG_MAX
condition|)
return|return
name|ERROR
argument_list|(
name|tableLog_tooLarge
argument_list|)
return|;
comment|/* memset(weightList, 0, sizeof(weightList)); */
comment|/* is not necessary, even though some analyzer complain ... */
name|iSize
operator|=
name|HUF_readStats
argument_list|(
name|weightList
argument_list|,
name|HUF_SYMBOLVALUE_MAX
operator|+
literal|1
argument_list|,
name|rankStats
argument_list|,
operator|&
name|nbSymbols
argument_list|,
operator|&
name|tableLog
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|HUF_isError
argument_list|(
name|iSize
argument_list|)
condition|)
return|return
name|iSize
return|;
comment|/* check result */
if|if
condition|(
name|tableLog
operator|>
name|maxTableLog
condition|)
return|return
name|ERROR
argument_list|(
name|tableLog_tooLarge
argument_list|)
return|;
comment|/* DTable can't fit code depth */
comment|/* find maxWeight */
for|for
control|(
name|maxW
operator|=
name|tableLog
init|;
name|rankStats
index|[
name|maxW
index|]
operator|==
literal|0
condition|;
name|maxW
operator|--
control|)
block|{}
comment|/* necessarily finds a solution before 0 */
comment|/* Get start index of each weight */
block|{
name|U32
name|w
decl_stmt|,
name|nextRankStart
init|=
literal|0
decl_stmt|;
for|for
control|(
name|w
operator|=
literal|1
init|;
name|w
operator|<
name|maxW
operator|+
literal|1
condition|;
name|w
operator|++
control|)
block|{
name|U32
name|current
init|=
name|nextRankStart
decl_stmt|;
name|nextRankStart
operator|+=
name|rankStats
index|[
name|w
index|]
expr_stmt|;
name|rankStart
index|[
name|w
index|]
operator|=
name|current
expr_stmt|;
block|}
name|rankStart
index|[
literal|0
index|]
operator|=
name|nextRankStart
expr_stmt|;
comment|/* put all 0w symbols at the end of sorted list*/
name|sizeOfSort
operator|=
name|nextRankStart
expr_stmt|;
block|}
comment|/* sort symbols by weight */
block|{
name|U32
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|nbSymbols
condition|;
name|s
operator|++
control|)
block|{
name|U32
specifier|const
name|w
init|=
name|weightList
index|[
name|s
index|]
decl_stmt|;
name|U32
specifier|const
name|r
init|=
name|rankStart
index|[
name|w
index|]
operator|++
decl_stmt|;
name|sortedSymbol
index|[
name|r
index|]
operator|.
name|symbol
operator|=
operator|(
name|BYTE
operator|)
name|s
expr_stmt|;
name|sortedSymbol
index|[
name|r
index|]
operator|.
name|weight
operator|=
operator|(
name|BYTE
operator|)
name|w
expr_stmt|;
block|}
name|rankStart
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* forget 0w symbols; this is beginning of weight(1) */
block|}
comment|/* Build rankVal */
block|{
name|U32
modifier|*
specifier|const
name|rankVal0
init|=
name|rankVal
index|[
literal|0
index|]
decl_stmt|;
block|{
name|int
specifier|const
name|rescale
init|=
operator|(
name|maxTableLog
operator|-
name|tableLog
operator|)
operator|-
literal|1
decl_stmt|;
comment|/* tableLog<= maxTableLog */
name|U32
name|nextRankVal
init|=
literal|0
decl_stmt|;
name|U32
name|w
decl_stmt|;
for|for
control|(
name|w
operator|=
literal|1
init|;
name|w
operator|<
name|maxW
operator|+
literal|1
condition|;
name|w
operator|++
control|)
block|{
name|U32
name|current
init|=
name|nextRankVal
decl_stmt|;
name|nextRankVal
operator|+=
name|rankStats
index|[
name|w
index|]
operator|<<
operator|(
name|w
operator|+
name|rescale
operator|)
expr_stmt|;
name|rankVal0
index|[
name|w
index|]
operator|=
name|current
expr_stmt|;
block|}
block|}
block|{
name|U32
specifier|const
name|minBits
init|=
name|tableLog
operator|+
literal|1
operator|-
name|maxW
decl_stmt|;
name|U32
name|consumed
decl_stmt|;
for|for
control|(
name|consumed
operator|=
name|minBits
init|;
name|consumed
operator|<
name|maxTableLog
operator|-
name|minBits
operator|+
literal|1
condition|;
name|consumed
operator|++
control|)
block|{
name|U32
modifier|*
specifier|const
name|rankValPtr
init|=
name|rankVal
index|[
name|consumed
index|]
decl_stmt|;
name|U32
name|w
decl_stmt|;
for|for
control|(
name|w
operator|=
literal|1
init|;
name|w
operator|<
name|maxW
operator|+
literal|1
condition|;
name|w
operator|++
control|)
block|{
name|rankValPtr
index|[
name|w
index|]
operator|=
name|rankVal0
index|[
name|w
index|]
operator|>>
name|consumed
expr_stmt|;
block|}
block|}
block|}
block|}
name|HUF_fillDTableX4
argument_list|(
name|dt
argument_list|,
name|maxTableLog
argument_list|,
name|sortedSymbol
argument_list|,
name|sizeOfSort
argument_list|,
name|rankStart0
argument_list|,
name|rankVal
argument_list|,
name|maxW
argument_list|,
name|tableLog
operator|+
literal|1
argument_list|)
expr_stmt|;
name|dtd
operator|.
name|tableLog
operator|=
operator|(
name|BYTE
operator|)
name|maxTableLog
expr_stmt|;
name|dtd
operator|.
name|tableType
operator|=
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|DTable
argument_list|,
operator|&
name|dtd
argument_list|,
sizeof|sizeof
argument_list|(
name|dtd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|iSize
return|;
block|}
end_function

begin_function
specifier|static
name|U32
name|HUF_decodeSymbolX4
parameter_list|(
name|void
modifier|*
name|op
parameter_list|,
name|BIT_DStream_t
modifier|*
name|DStream
parameter_list|,
specifier|const
name|HUF_DEltX4
modifier|*
name|dt
parameter_list|,
specifier|const
name|U32
name|dtLog
parameter_list|)
block|{
name|size_t
specifier|const
name|val
init|=
name|BIT_lookBitsFast
argument_list|(
name|DStream
argument_list|,
name|dtLog
argument_list|)
decl_stmt|;
comment|/* note : dtLog>= 1 */
name|memcpy
argument_list|(
name|op
argument_list|,
name|dt
operator|+
name|val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|BIT_skipBits
argument_list|(
name|DStream
argument_list|,
name|dt
index|[
name|val
index|]
operator|.
name|nbBits
argument_list|)
expr_stmt|;
return|return
name|dt
index|[
name|val
index|]
operator|.
name|length
return|;
block|}
end_function

begin_function
specifier|static
name|U32
name|HUF_decodeLastSymbolX4
parameter_list|(
name|void
modifier|*
name|op
parameter_list|,
name|BIT_DStream_t
modifier|*
name|DStream
parameter_list|,
specifier|const
name|HUF_DEltX4
modifier|*
name|dt
parameter_list|,
specifier|const
name|U32
name|dtLog
parameter_list|)
block|{
name|size_t
specifier|const
name|val
init|=
name|BIT_lookBitsFast
argument_list|(
name|DStream
argument_list|,
name|dtLog
argument_list|)
decl_stmt|;
comment|/* note : dtLog>= 1 */
name|memcpy
argument_list|(
name|op
argument_list|,
name|dt
operator|+
name|val
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|dt
index|[
name|val
index|]
operator|.
name|length
operator|==
literal|1
condition|)
name|BIT_skipBits
argument_list|(
name|DStream
argument_list|,
name|dt
index|[
name|val
index|]
operator|.
name|nbBits
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|DStream
operator|->
name|bitsConsumed
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|DStream
operator|->
name|bitContainer
argument_list|)
operator|*
literal|8
operator|)
condition|)
block|{
name|BIT_skipBits
argument_list|(
name|DStream
argument_list|,
name|dt
index|[
name|val
index|]
operator|.
name|nbBits
argument_list|)
expr_stmt|;
if|if
condition|(
name|DStream
operator|->
name|bitsConsumed
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|DStream
operator|->
name|bitContainer
argument_list|)
operator|*
literal|8
operator|)
condition|)
name|DStream
operator|->
name|bitsConsumed
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|DStream
operator|->
name|bitContainer
argument_list|)
operator|*
literal|8
operator|)
expr_stmt|;
comment|/* ugly hack; works only because it's the last symbol. Note : can't easily extract nbBits from just this symbol */
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|HUF_DECODE_SYMBOLX4_0
parameter_list|(
name|ptr
parameter_list|,
name|DStreamPtr
parameter_list|)
define|\
value|ptr += HUF_decodeSymbolX4(ptr, DStreamPtr, dt, dtLog)
end_define

begin_define
define|#
directive|define
name|HUF_DECODE_SYMBOLX4_1
parameter_list|(
name|ptr
parameter_list|,
name|DStreamPtr
parameter_list|)
define|\
value|if (MEM_64bits() || (HUF_TABLELOG_MAX<=12)) \         ptr += HUF_decodeSymbolX4(ptr, DStreamPtr, dt, dtLog)
end_define

begin_define
define|#
directive|define
name|HUF_DECODE_SYMBOLX4_2
parameter_list|(
name|ptr
parameter_list|,
name|DStreamPtr
parameter_list|)
define|\
value|if (MEM_64bits()) \         ptr += HUF_decodeSymbolX4(ptr, DStreamPtr, dt, dtLog)
end_define

begin_function
name|FORCE_INLINE
name|size_t
name|HUF_decodeStreamX4
parameter_list|(
name|BYTE
modifier|*
name|p
parameter_list|,
name|BIT_DStream_t
modifier|*
name|bitDPtr
parameter_list|,
name|BYTE
modifier|*
specifier|const
name|pEnd
parameter_list|,
specifier|const
name|HUF_DEltX4
modifier|*
specifier|const
name|dt
parameter_list|,
specifier|const
name|U32
name|dtLog
parameter_list|)
block|{
name|BYTE
modifier|*
specifier|const
name|pStart
init|=
name|p
decl_stmt|;
comment|/* up to 8 symbols at a time */
while|while
condition|(
operator|(
name|BIT_reloadDStream
argument_list|(
name|bitDPtr
argument_list|)
operator|==
name|BIT_DStream_unfinished
operator|)
operator|&
operator|(
name|p
operator|<
name|pEnd
operator|-
operator|(
sizeof|sizeof
argument_list|(
name|bitDPtr
operator|->
name|bitContainer
argument_list|)
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|HUF_DECODE_SYMBOLX4_2
argument_list|(
name|p
argument_list|,
name|bitDPtr
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX4_1
argument_list|(
name|p
argument_list|,
name|bitDPtr
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX4_2
argument_list|(
name|p
argument_list|,
name|bitDPtr
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX4_0
argument_list|(
name|p
argument_list|,
name|bitDPtr
argument_list|)
expr_stmt|;
block|}
comment|/* closer to end : up to 2 symbols at a time */
while|while
condition|(
operator|(
name|BIT_reloadDStream
argument_list|(
name|bitDPtr
argument_list|)
operator|==
name|BIT_DStream_unfinished
operator|)
operator|&
operator|(
name|p
operator|<=
name|pEnd
operator|-
literal|2
operator|)
condition|)
name|HUF_DECODE_SYMBOLX4_0
argument_list|(
name|p
argument_list|,
name|bitDPtr
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|<=
name|pEnd
operator|-
literal|2
condition|)
name|HUF_DECODE_SYMBOLX4_0
argument_list|(
name|p
argument_list|,
name|bitDPtr
argument_list|)
expr_stmt|;
comment|/* no need to reload : reached the end of DStream */
if|if
condition|(
name|p
operator|<
name|pEnd
condition|)
name|p
operator|+=
name|HUF_decodeLastSymbolX4
argument_list|(
name|p
argument_list|,
name|bitDPtr
argument_list|,
name|dt
argument_list|,
name|dtLog
argument_list|)
expr_stmt|;
return|return
name|p
operator|-
name|pStart
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|HUF_decompress1X4_usingDTable_internal
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|HUF_DTable
modifier|*
name|DTable
parameter_list|)
block|{
name|BIT_DStream_t
name|bitD
decl_stmt|;
comment|/* Init */
block|{
name|size_t
specifier|const
name|errorCode
init|=
name|BIT_initDStream
argument_list|(
operator|&
name|bitD
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|HUF_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
block|}
comment|/* decode */
block|{
name|BYTE
modifier|*
specifier|const
name|ostart
init|=
operator|(
name|BYTE
operator|*
operator|)
name|dst
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|oend
init|=
name|ostart
operator|+
name|dstSize
decl_stmt|;
specifier|const
name|void
modifier|*
specifier|const
name|dtPtr
init|=
name|DTable
operator|+
literal|1
decl_stmt|;
comment|/* force compiler to not use strict-aliasing */
specifier|const
name|HUF_DEltX4
modifier|*
specifier|const
name|dt
init|=
operator|(
specifier|const
name|HUF_DEltX4
operator|*
operator|)
name|dtPtr
decl_stmt|;
name|DTableDesc
specifier|const
name|dtd
init|=
name|HUF_getDTableDesc
argument_list|(
name|DTable
argument_list|)
decl_stmt|;
name|HUF_decodeStreamX4
argument_list|(
name|ostart
argument_list|,
operator|&
name|bitD
argument_list|,
name|oend
argument_list|,
name|dt
argument_list|,
name|dtd
operator|.
name|tableLog
argument_list|)
expr_stmt|;
block|}
comment|/* check */
if|if
condition|(
operator|!
name|BIT_endOfDStream
argument_list|(
operator|&
name|bitD
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* decoded size */
return|return
name|dstSize
return|;
block|}
end_function

begin_function
name|size_t
name|HUF_decompress1X4_usingDTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|HUF_DTable
modifier|*
name|DTable
parameter_list|)
block|{
name|DTableDesc
name|dtd
init|=
name|HUF_getDTableDesc
argument_list|(
name|DTable
argument_list|)
decl_stmt|;
if|if
condition|(
name|dtd
operator|.
name|tableType
operator|!=
literal|1
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
return|return
name|HUF_decompress1X4_usingDTable_internal
argument_list|(
name|dst
argument_list|,
name|dstSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|,
name|DTable
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|HUF_decompress1X4_DCtx
parameter_list|(
name|HUF_DTable
modifier|*
name|DCtx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|cSrc
decl_stmt|;
name|size_t
specifier|const
name|hSize
init|=
name|HUF_readDTableX4
argument_list|(
name|DCtx
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|HUF_isError
argument_list|(
name|hSize
argument_list|)
condition|)
return|return
name|hSize
return|;
if|if
condition|(
name|hSize
operator|>=
name|cSrcSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|ip
operator|+=
name|hSize
expr_stmt|;
name|cSrcSize
operator|-=
name|hSize
expr_stmt|;
return|return
name|HUF_decompress1X4_usingDTable_internal
argument_list|(
name|dst
argument_list|,
name|dstSize
argument_list|,
name|ip
argument_list|,
name|cSrcSize
argument_list|,
name|DCtx
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|HUF_decompress1X4
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
block|{
name|HUF_CREATE_STATIC_DTABLEX4
argument_list|(
name|DTable
argument_list|,
name|HUF_TABLELOG_MAX
argument_list|)
expr_stmt|;
return|return
name|HUF_decompress1X4_DCtx
argument_list|(
name|DTable
argument_list|,
name|dst
argument_list|,
name|dstSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|HUF_decompress4X4_usingDTable_internal
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|HUF_DTable
modifier|*
name|DTable
parameter_list|)
block|{
if|if
condition|(
name|cSrcSize
operator|<
literal|10
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* strict minimum : jump table + 1 byte per stream */
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|cSrc
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|ostart
init|=
operator|(
name|BYTE
operator|*
operator|)
name|dst
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|oend
init|=
name|ostart
operator|+
name|dstSize
decl_stmt|;
specifier|const
name|void
modifier|*
specifier|const
name|dtPtr
init|=
name|DTable
operator|+
literal|1
decl_stmt|;
specifier|const
name|HUF_DEltX4
modifier|*
specifier|const
name|dt
init|=
operator|(
specifier|const
name|HUF_DEltX4
operator|*
operator|)
name|dtPtr
decl_stmt|;
comment|/* Init */
name|BIT_DStream_t
name|bitD1
decl_stmt|;
name|BIT_DStream_t
name|bitD2
decl_stmt|;
name|BIT_DStream_t
name|bitD3
decl_stmt|;
name|BIT_DStream_t
name|bitD4
decl_stmt|;
name|size_t
specifier|const
name|length1
init|=
name|MEM_readLE16
argument_list|(
name|istart
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|length2
init|=
name|MEM_readLE16
argument_list|(
name|istart
operator|+
literal|2
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|length3
init|=
name|MEM_readLE16
argument_list|(
name|istart
operator|+
literal|4
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|length4
init|=
name|cSrcSize
operator|-
operator|(
name|length1
operator|+
name|length2
operator|+
name|length3
operator|+
literal|6
operator|)
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart1
init|=
name|istart
operator|+
literal|6
decl_stmt|;
comment|/* jumpTable */
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart2
init|=
name|istart1
operator|+
name|length1
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart3
init|=
name|istart2
operator|+
name|length2
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart4
init|=
name|istart3
operator|+
name|length3
decl_stmt|;
name|size_t
specifier|const
name|segmentSize
init|=
operator|(
name|dstSize
operator|+
literal|3
operator|)
operator|/
literal|4
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|opStart2
init|=
name|ostart
operator|+
name|segmentSize
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|opStart3
init|=
name|opStart2
operator|+
name|segmentSize
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|opStart4
init|=
name|opStart3
operator|+
name|segmentSize
decl_stmt|;
name|BYTE
modifier|*
name|op1
init|=
name|ostart
decl_stmt|;
name|BYTE
modifier|*
name|op2
init|=
name|opStart2
decl_stmt|;
name|BYTE
modifier|*
name|op3
init|=
name|opStart3
decl_stmt|;
name|BYTE
modifier|*
name|op4
init|=
name|opStart4
decl_stmt|;
name|U32
name|endSignal
decl_stmt|;
name|DTableDesc
specifier|const
name|dtd
init|=
name|HUF_getDTableDesc
argument_list|(
name|DTable
argument_list|)
decl_stmt|;
name|U32
specifier|const
name|dtLog
init|=
name|dtd
operator|.
name|tableLog
decl_stmt|;
if|if
condition|(
name|length4
operator|>
name|cSrcSize
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* overflow */
block|{
name|size_t
specifier|const
name|errorCode
init|=
name|BIT_initDStream
argument_list|(
operator|&
name|bitD1
argument_list|,
name|istart1
argument_list|,
name|length1
argument_list|)
decl_stmt|;
if|if
condition|(
name|HUF_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
block|}
block|{
name|size_t
specifier|const
name|errorCode
init|=
name|BIT_initDStream
argument_list|(
operator|&
name|bitD2
argument_list|,
name|istart2
argument_list|,
name|length2
argument_list|)
decl_stmt|;
if|if
condition|(
name|HUF_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
block|}
block|{
name|size_t
specifier|const
name|errorCode
init|=
name|BIT_initDStream
argument_list|(
operator|&
name|bitD3
argument_list|,
name|istart3
argument_list|,
name|length3
argument_list|)
decl_stmt|;
if|if
condition|(
name|HUF_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
block|}
block|{
name|size_t
specifier|const
name|errorCode
init|=
name|BIT_initDStream
argument_list|(
operator|&
name|bitD4
argument_list|,
name|istart4
argument_list|,
name|length4
argument_list|)
decl_stmt|;
if|if
condition|(
name|HUF_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
block|}
comment|/* 16-32 symbols per loop (4-8 symbols per stream) */
name|endSignal
operator|=
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD1
argument_list|)
operator||
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD2
argument_list|)
operator||
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD3
argument_list|)
operator||
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD4
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|(
name|endSignal
operator|==
name|BIT_DStream_unfinished
operator|)
operator|&
operator|(
name|op4
operator|<
operator|(
name|oend
operator|-
operator|(
sizeof|sizeof
argument_list|(
name|bitD4
operator|.
name|bitContainer
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
condition|;
control|)
block|{
name|HUF_DECODE_SYMBOLX4_2
argument_list|(
name|op1
argument_list|,
operator|&
name|bitD1
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX4_2
argument_list|(
name|op2
argument_list|,
operator|&
name|bitD2
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX4_2
argument_list|(
name|op3
argument_list|,
operator|&
name|bitD3
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX4_2
argument_list|(
name|op4
argument_list|,
operator|&
name|bitD4
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX4_1
argument_list|(
name|op1
argument_list|,
operator|&
name|bitD1
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX4_1
argument_list|(
name|op2
argument_list|,
operator|&
name|bitD2
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX4_1
argument_list|(
name|op3
argument_list|,
operator|&
name|bitD3
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX4_1
argument_list|(
name|op4
argument_list|,
operator|&
name|bitD4
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX4_2
argument_list|(
name|op1
argument_list|,
operator|&
name|bitD1
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX4_2
argument_list|(
name|op2
argument_list|,
operator|&
name|bitD2
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX4_2
argument_list|(
name|op3
argument_list|,
operator|&
name|bitD3
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX4_2
argument_list|(
name|op4
argument_list|,
operator|&
name|bitD4
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX4_0
argument_list|(
name|op1
argument_list|,
operator|&
name|bitD1
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX4_0
argument_list|(
name|op2
argument_list|,
operator|&
name|bitD2
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX4_0
argument_list|(
name|op3
argument_list|,
operator|&
name|bitD3
argument_list|)
expr_stmt|;
name|HUF_DECODE_SYMBOLX4_0
argument_list|(
name|op4
argument_list|,
operator|&
name|bitD4
argument_list|)
expr_stmt|;
name|endSignal
operator|=
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD1
argument_list|)
operator||
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD2
argument_list|)
operator||
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD3
argument_list|)
operator||
name|BIT_reloadDStream
argument_list|(
operator|&
name|bitD4
argument_list|)
expr_stmt|;
block|}
comment|/* check corruption */
if|if
condition|(
name|op1
operator|>
name|opStart2
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
if|if
condition|(
name|op2
operator|>
name|opStart3
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
if|if
condition|(
name|op3
operator|>
name|opStart4
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* note : op4 already verified within main loop */
comment|/* finish bitStreams one by one */
name|HUF_decodeStreamX4
argument_list|(
name|op1
argument_list|,
operator|&
name|bitD1
argument_list|,
name|opStart2
argument_list|,
name|dt
argument_list|,
name|dtLog
argument_list|)
expr_stmt|;
name|HUF_decodeStreamX4
argument_list|(
name|op2
argument_list|,
operator|&
name|bitD2
argument_list|,
name|opStart3
argument_list|,
name|dt
argument_list|,
name|dtLog
argument_list|)
expr_stmt|;
name|HUF_decodeStreamX4
argument_list|(
name|op3
argument_list|,
operator|&
name|bitD3
argument_list|,
name|opStart4
argument_list|,
name|dt
argument_list|,
name|dtLog
argument_list|)
expr_stmt|;
name|HUF_decodeStreamX4
argument_list|(
name|op4
argument_list|,
operator|&
name|bitD4
argument_list|,
name|oend
argument_list|,
name|dt
argument_list|,
name|dtLog
argument_list|)
expr_stmt|;
comment|/* check */
block|{
name|U32
specifier|const
name|endCheck
init|=
name|BIT_endOfDStream
argument_list|(
operator|&
name|bitD1
argument_list|)
operator|&
name|BIT_endOfDStream
argument_list|(
operator|&
name|bitD2
argument_list|)
operator|&
name|BIT_endOfDStream
argument_list|(
operator|&
name|bitD3
argument_list|)
operator|&
name|BIT_endOfDStream
argument_list|(
operator|&
name|bitD4
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|endCheck
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
block|}
comment|/* decoded size */
return|return
name|dstSize
return|;
block|}
block|}
end_function

begin_function
name|size_t
name|HUF_decompress4X4_usingDTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|HUF_DTable
modifier|*
name|DTable
parameter_list|)
block|{
name|DTableDesc
name|dtd
init|=
name|HUF_getDTableDesc
argument_list|(
name|DTable
argument_list|)
decl_stmt|;
if|if
condition|(
name|dtd
operator|.
name|tableType
operator|!=
literal|1
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
return|return
name|HUF_decompress4X4_usingDTable_internal
argument_list|(
name|dst
argument_list|,
name|dstSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|,
name|DTable
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|HUF_decompress4X4_DCtx
parameter_list|(
name|HUF_DTable
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|cSrc
decl_stmt|;
name|size_t
name|hSize
init|=
name|HUF_readDTableX4
argument_list|(
name|dctx
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|HUF_isError
argument_list|(
name|hSize
argument_list|)
condition|)
return|return
name|hSize
return|;
if|if
condition|(
name|hSize
operator|>=
name|cSrcSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|ip
operator|+=
name|hSize
expr_stmt|;
name|cSrcSize
operator|-=
name|hSize
expr_stmt|;
return|return
name|HUF_decompress4X4_usingDTable_internal
argument_list|(
name|dst
argument_list|,
name|dstSize
argument_list|,
name|ip
argument_list|,
name|cSrcSize
argument_list|,
name|dctx
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|HUF_decompress4X4
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
block|{
name|HUF_CREATE_STATIC_DTABLEX4
argument_list|(
name|DTable
argument_list|,
name|HUF_TABLELOG_MAX
argument_list|)
expr_stmt|;
return|return
name|HUF_decompress4X4_DCtx
argument_list|(
name|DTable
argument_list|,
name|dst
argument_list|,
name|dstSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ********************************/
end_comment

begin_comment
comment|/* Generic decompression selector */
end_comment

begin_comment
comment|/* ********************************/
end_comment

begin_function
name|size_t
name|HUF_decompress1X_usingDTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|HUF_DTable
modifier|*
name|DTable
parameter_list|)
block|{
name|DTableDesc
specifier|const
name|dtd
init|=
name|HUF_getDTableDesc
argument_list|(
name|DTable
argument_list|)
decl_stmt|;
return|return
name|dtd
operator|.
name|tableType
condition|?
name|HUF_decompress1X4_usingDTable_internal
argument_list|(
name|dst
argument_list|,
name|maxDstSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|,
name|DTable
argument_list|)
else|:
name|HUF_decompress1X2_usingDTable_internal
argument_list|(
name|dst
argument_list|,
name|maxDstSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|,
name|DTable
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|HUF_decompress4X_usingDTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|,
specifier|const
name|HUF_DTable
modifier|*
name|DTable
parameter_list|)
block|{
name|DTableDesc
specifier|const
name|dtd
init|=
name|HUF_getDTableDesc
argument_list|(
name|DTable
argument_list|)
decl_stmt|;
return|return
name|dtd
operator|.
name|tableType
condition|?
name|HUF_decompress4X4_usingDTable_internal
argument_list|(
name|dst
argument_list|,
name|maxDstSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|,
name|DTable
argument_list|)
else|:
name|HUF_decompress4X2_usingDTable_internal
argument_list|(
name|dst
argument_list|,
name|maxDstSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|,
name|DTable
argument_list|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
block|{
name|U32
name|tableTime
decl_stmt|;
name|U32
name|decode256Time
decl_stmt|;
block|}
name|algo_time_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|algo_time_t
name|algoTime
index|[
literal|16
comment|/* Quantization */
index|]
index|[
literal|3
comment|/* single, double, quad */
index|]
init|=
block|{
comment|/* single, double, quad */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|2
block|,
literal|2
block|}
block|}
block|,
comment|/* Q==0 : impossible */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|2
block|,
literal|2
block|}
block|}
block|,
comment|/* Q==1 : impossible */
block|{
block|{
literal|38
block|,
literal|130
block|}
block|,
block|{
literal|1313
block|,
literal|74
block|}
block|,
block|{
literal|2151
block|,
literal|38
block|}
block|}
block|,
comment|/* Q == 2 : 12-18% */
block|{
block|{
literal|448
block|,
literal|128
block|}
block|,
block|{
literal|1353
block|,
literal|74
block|}
block|,
block|{
literal|2238
block|,
literal|41
block|}
block|}
block|,
comment|/* Q == 3 : 18-25% */
block|{
block|{
literal|556
block|,
literal|128
block|}
block|,
block|{
literal|1353
block|,
literal|74
block|}
block|,
block|{
literal|2238
block|,
literal|47
block|}
block|}
block|,
comment|/* Q == 4 : 25-32% */
block|{
block|{
literal|714
block|,
literal|128
block|}
block|,
block|{
literal|1418
block|,
literal|74
block|}
block|,
block|{
literal|2436
block|,
literal|53
block|}
block|}
block|,
comment|/* Q == 5 : 32-38% */
block|{
block|{
literal|883
block|,
literal|128
block|}
block|,
block|{
literal|1437
block|,
literal|74
block|}
block|,
block|{
literal|2464
block|,
literal|61
block|}
block|}
block|,
comment|/* Q == 6 : 38-44% */
block|{
block|{
literal|897
block|,
literal|128
block|}
block|,
block|{
literal|1515
block|,
literal|75
block|}
block|,
block|{
literal|2622
block|,
literal|68
block|}
block|}
block|,
comment|/* Q == 7 : 44-50% */
block|{
block|{
literal|926
block|,
literal|128
block|}
block|,
block|{
literal|1613
block|,
literal|75
block|}
block|,
block|{
literal|2730
block|,
literal|75
block|}
block|}
block|,
comment|/* Q == 8 : 50-56% */
block|{
block|{
literal|947
block|,
literal|128
block|}
block|,
block|{
literal|1729
block|,
literal|77
block|}
block|,
block|{
literal|3359
block|,
literal|77
block|}
block|}
block|,
comment|/* Q == 9 : 56-62% */
block|{
block|{
literal|1107
block|,
literal|128
block|}
block|,
block|{
literal|2083
block|,
literal|81
block|}
block|,
block|{
literal|4006
block|,
literal|84
block|}
block|}
block|,
comment|/* Q ==10 : 62-69% */
block|{
block|{
literal|1177
block|,
literal|128
block|}
block|,
block|{
literal|2379
block|,
literal|87
block|}
block|,
block|{
literal|4785
block|,
literal|88
block|}
block|}
block|,
comment|/* Q ==11 : 69-75% */
block|{
block|{
literal|1242
block|,
literal|128
block|}
block|,
block|{
literal|2415
block|,
literal|93
block|}
block|,
block|{
literal|5155
block|,
literal|84
block|}
block|}
block|,
comment|/* Q ==12 : 75-81% */
block|{
block|{
literal|1349
block|,
literal|128
block|}
block|,
block|{
literal|2644
block|,
literal|106
block|}
block|,
block|{
literal|5260
block|,
literal|106
block|}
block|}
block|,
comment|/* Q ==13 : 81-87% */
block|{
block|{
literal|1455
block|,
literal|128
block|}
block|,
block|{
literal|2422
block|,
literal|124
block|}
block|,
block|{
literal|4174
block|,
literal|124
block|}
block|}
block|,
comment|/* Q ==14 : 87-93% */
block|{
block|{
literal|722
block|,
literal|128
block|}
block|,
block|{
literal|1891
block|,
literal|145
block|}
block|,
block|{
literal|1936
block|,
literal|146
block|}
block|}
block|,
comment|/* Q ==15 : 93-99% */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** HUF_selectDecoder() : *   Tells which decoder is likely to decode faster, *   based on a set of pre-determined metrics. *   @return : 0==HUF_decompress4X2, 1==HUF_decompress4X4 . *   Assumption : 0< cSrcSize< dstSize<= 128 KB */
end_comment

begin_function
name|U32
name|HUF_selectDecoder
parameter_list|(
name|size_t
name|dstSize
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
block|{
comment|/* decoder timing evaluation */
name|U32
specifier|const
name|Q
init|=
call|(
name|U32
call|)
argument_list|(
name|cSrcSize
operator|*
literal|16
operator|/
name|dstSize
argument_list|)
decl_stmt|;
comment|/* Q< 16 since dstSize> cSrcSize */
name|U32
specifier|const
name|D256
init|=
call|(
name|U32
call|)
argument_list|(
name|dstSize
operator|>>
literal|8
argument_list|)
decl_stmt|;
name|U32
specifier|const
name|DTime0
init|=
name|algoTime
index|[
name|Q
index|]
index|[
literal|0
index|]
operator|.
name|tableTime
operator|+
operator|(
name|algoTime
index|[
name|Q
index|]
index|[
literal|0
index|]
operator|.
name|decode256Time
operator|*
name|D256
operator|)
decl_stmt|;
name|U32
name|DTime1
init|=
name|algoTime
index|[
name|Q
index|]
index|[
literal|1
index|]
operator|.
name|tableTime
operator|+
operator|(
name|algoTime
index|[
name|Q
index|]
index|[
literal|1
index|]
operator|.
name|decode256Time
operator|*
name|D256
operator|)
decl_stmt|;
name|DTime1
operator|+=
name|DTime1
operator|>>
literal|3
expr_stmt|;
comment|/* advantage to algorithm using less memory, for cache eviction */
return|return
name|DTime1
operator|<
name|DTime0
return|;
block|}
end_function

begin_typedef
typedef|typedef
name|size_t
function_decl|(
modifier|*
name|decompressionAlgo
function_decl|)
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
function_decl|;
end_typedef

begin_function
name|size_t
name|HUF_decompress
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
block|{
specifier|static
specifier|const
name|decompressionAlgo
name|decompress
index|[
literal|2
index|]
init|=
block|{
name|HUF_decompress4X2
block|,
name|HUF_decompress4X4
block|}
decl_stmt|;
comment|/* validation checks */
if|if
condition|(
name|dstSize
operator|==
literal|0
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
if|if
condition|(
name|cSrcSize
operator|>
name|dstSize
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* invalid */
if|if
condition|(
name|cSrcSize
operator|==
name|dstSize
condition|)
block|{
name|memcpy
argument_list|(
name|dst
argument_list|,
name|cSrc
argument_list|,
name|dstSize
argument_list|)
expr_stmt|;
return|return
name|dstSize
return|;
block|}
comment|/* not compressed */
if|if
condition|(
name|cSrcSize
operator|==
literal|1
condition|)
block|{
name|memset
argument_list|(
name|dst
argument_list|,
operator|*
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|cSrc
argument_list|,
name|dstSize
argument_list|)
expr_stmt|;
return|return
name|dstSize
return|;
block|}
comment|/* RLE */
block|{
name|U32
specifier|const
name|algoNb
init|=
name|HUF_selectDecoder
argument_list|(
name|dstSize
argument_list|,
name|cSrcSize
argument_list|)
decl_stmt|;
return|return
name|decompress
index|[
name|algoNb
index|]
operator|(
name|dst
operator|,
name|dstSize
operator|,
name|cSrc
operator|,
name|cSrcSize
operator|)
return|;
block|}
block|}
end_function

begin_function
name|size_t
name|HUF_decompress4X_DCtx
parameter_list|(
name|HUF_DTable
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
block|{
comment|/* validation checks */
if|if
condition|(
name|dstSize
operator|==
literal|0
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
if|if
condition|(
name|cSrcSize
operator|>
name|dstSize
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* invalid */
if|if
condition|(
name|cSrcSize
operator|==
name|dstSize
condition|)
block|{
name|memcpy
argument_list|(
name|dst
argument_list|,
name|cSrc
argument_list|,
name|dstSize
argument_list|)
expr_stmt|;
return|return
name|dstSize
return|;
block|}
comment|/* not compressed */
if|if
condition|(
name|cSrcSize
operator|==
literal|1
condition|)
block|{
name|memset
argument_list|(
name|dst
argument_list|,
operator|*
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|cSrc
argument_list|,
name|dstSize
argument_list|)
expr_stmt|;
return|return
name|dstSize
return|;
block|}
comment|/* RLE */
block|{
name|U32
specifier|const
name|algoNb
init|=
name|HUF_selectDecoder
argument_list|(
name|dstSize
argument_list|,
name|cSrcSize
argument_list|)
decl_stmt|;
return|return
name|algoNb
condition|?
name|HUF_decompress4X4_DCtx
argument_list|(
name|dctx
argument_list|,
name|dst
argument_list|,
name|dstSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|)
else|:
name|HUF_decompress4X2_DCtx
argument_list|(
name|dctx
argument_list|,
name|dst
argument_list|,
name|dstSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|size_t
name|HUF_decompress4X_hufOnly
parameter_list|(
name|HUF_DTable
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
block|{
comment|/* validation checks */
if|if
condition|(
name|dstSize
operator|==
literal|0
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
if|if
condition|(
operator|(
name|cSrcSize
operator|>=
name|dstSize
operator|)
operator|||
operator|(
name|cSrcSize
operator|<=
literal|1
operator|)
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* invalid */
block|{
name|U32
specifier|const
name|algoNb
init|=
name|HUF_selectDecoder
argument_list|(
name|dstSize
argument_list|,
name|cSrcSize
argument_list|)
decl_stmt|;
return|return
name|algoNb
condition|?
name|HUF_decompress4X4_DCtx
argument_list|(
name|dctx
argument_list|,
name|dst
argument_list|,
name|dstSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|)
else|:
name|HUF_decompress4X2_DCtx
argument_list|(
name|dctx
argument_list|,
name|dst
argument_list|,
name|dstSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|size_t
name|HUF_decompress1X_DCtx
parameter_list|(
name|HUF_DTable
modifier|*
name|dctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|cSrc
parameter_list|,
name|size_t
name|cSrcSize
parameter_list|)
block|{
comment|/* validation checks */
if|if
condition|(
name|dstSize
operator|==
literal|0
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
if|if
condition|(
name|cSrcSize
operator|>
name|dstSize
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* invalid */
if|if
condition|(
name|cSrcSize
operator|==
name|dstSize
condition|)
block|{
name|memcpy
argument_list|(
name|dst
argument_list|,
name|cSrc
argument_list|,
name|dstSize
argument_list|)
expr_stmt|;
return|return
name|dstSize
return|;
block|}
comment|/* not compressed */
if|if
condition|(
name|cSrcSize
operator|==
literal|1
condition|)
block|{
name|memset
argument_list|(
name|dst
argument_list|,
operator|*
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|cSrc
argument_list|,
name|dstSize
argument_list|)
expr_stmt|;
return|return
name|dstSize
return|;
block|}
comment|/* RLE */
block|{
name|U32
specifier|const
name|algoNb
init|=
name|HUF_selectDecoder
argument_list|(
name|dstSize
argument_list|,
name|cSrcSize
argument_list|)
decl_stmt|;
return|return
name|algoNb
condition|?
name|HUF_decompress1X4_DCtx
argument_list|(
name|dctx
argument_list|,
name|dst
argument_list|,
name|dstSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|)
else|:
name|HUF_decompress1X2_DCtx
argument_list|(
name|dctx
argument_list|,
name|dst
argument_list|,
name|dstSize
argument_list|,
name|cSrc
argument_list|,
name|cSrcSize
argument_list|)
return|;
block|}
block|}
end_function

end_unit

