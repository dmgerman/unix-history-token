begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ******************************************************************    FSE : Finite State Entropy encoder    Copyright (C) 2013-2015, Yann Collet.     BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)     Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are    met:         * Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer.        * Redistributions in binary form must reproduce the above    copyright notice, this list of conditions and the following disclaimer    in the documentation and/or other materials provided with the    distribution.     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.      You can contact the author at :     - FSE source repository : https://github.com/Cyan4973/FiniteStateEntropy     - Public forum : https://groups.google.com/forum/#!forum/lz4c ****************************************************************** */
end_comment

begin_comment
comment|/* ************************************************************** *  Includes ****************************************************************/
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* malloc, free, qsort */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* memcpy, memset */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* printf (debug) */
end_comment

begin_include
include|#
directive|include
file|"bitstream.h"
end_include

begin_include
include|#
directive|include
file|"compiler.h"
end_include

begin_define
define|#
directive|define
name|FSE_STATIC_LINKING_ONLY
end_define

begin_include
include|#
directive|include
file|"fse.h"
end_include

begin_include
include|#
directive|include
file|"error_private.h"
end_include

begin_comment
comment|/* ************************************************************** *  Error Management ****************************************************************/
end_comment

begin_define
define|#
directive|define
name|FSE_isError
value|ERR_isError
end_define

begin_define
define|#
directive|define
name|FSE_STATIC_ASSERT
parameter_list|(
name|c
parameter_list|)
value|{ enum { FSE_static_assert = 1/(int)(!!(c)) }; }
end_define

begin_comment
comment|/* use only *after* variable declarations */
end_comment

begin_comment
comment|/* ************************************************************** *  Templates ****************************************************************/
end_comment

begin_comment
comment|/*   designed to be included   for type-specific functions (template emulation in C)   Objective is to write these functions only once, for improved maintenance */
end_comment

begin_comment
comment|/* safety checks */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FSE_FUNCTION_EXTENSION
end_ifndef

begin_error
error|#
directive|error
literal|"FSE_FUNCTION_EXTENSION must be defined"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FSE_FUNCTION_TYPE
end_ifndef

begin_error
error|#
directive|error
literal|"FSE_FUNCTION_TYPE must be defined"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Function names */
end_comment

begin_define
define|#
directive|define
name|FSE_CAT
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|X##Y
end_define

begin_define
define|#
directive|define
name|FSE_FUNCTION_NAME
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|FSE_CAT(X,Y)
end_define

begin_define
define|#
directive|define
name|FSE_TYPE_NAME
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|FSE_CAT(X,Y)
end_define

begin_comment
comment|/* Function templates */
end_comment

begin_comment
comment|/* FSE_buildCTable_wksp() :  * Same as FSE_buildCTable(), but using an externally allocated scratch buffer (`workSpace`).  * wkspSize should be sized to handle worst case situation, which is `1<<max_tableLog * sizeof(FSE_FUNCTION_TYPE)`  * workSpace must also be properly aligned with FSE_FUNCTION_TYPE requirements  */
end_comment

begin_function
name|size_t
name|FSE_buildCTable_wksp
parameter_list|(
name|FSE_CTable
modifier|*
name|ct
parameter_list|,
specifier|const
name|short
modifier|*
name|normalizedCounter
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|,
name|unsigned
name|tableLog
parameter_list|,
name|void
modifier|*
name|workSpace
parameter_list|,
name|size_t
name|wkspSize
parameter_list|)
block|{
name|U32
specifier|const
name|tableSize
init|=
literal|1
operator|<<
name|tableLog
decl_stmt|;
name|U32
specifier|const
name|tableMask
init|=
name|tableSize
operator|-
literal|1
decl_stmt|;
name|void
modifier|*
specifier|const
name|ptr
init|=
name|ct
decl_stmt|;
name|U16
modifier|*
specifier|const
name|tableU16
init|=
operator|(
operator|(
name|U16
operator|*
operator|)
name|ptr
operator|)
operator|+
literal|2
decl_stmt|;
name|void
modifier|*
specifier|const
name|FSCT
init|=
operator|(
operator|(
name|U32
operator|*
operator|)
name|ptr
operator|)
operator|+
literal|1
comment|/* header */
operator|+
operator|(
name|tableLog
condition|?
name|tableSize
operator|>>
literal|1
else|:
literal|1
operator|)
decl_stmt|;
name|FSE_symbolCompressionTransform
modifier|*
specifier|const
name|symbolTT
init|=
operator|(
name|FSE_symbolCompressionTransform
operator|*
operator|)
operator|(
name|FSCT
operator|)
decl_stmt|;
name|U32
specifier|const
name|step
init|=
name|FSE_TABLESTEP
argument_list|(
name|tableSize
argument_list|)
decl_stmt|;
name|U32
name|cumul
index|[
name|FSE_MAX_SYMBOL_VALUE
operator|+
literal|2
index|]
decl_stmt|;
name|FSE_FUNCTION_TYPE
modifier|*
specifier|const
name|tableSymbol
init|=
operator|(
name|FSE_FUNCTION_TYPE
operator|*
operator|)
name|workSpace
decl_stmt|;
name|U32
name|highThreshold
init|=
name|tableSize
operator|-
literal|1
decl_stmt|;
comment|/* CTable header */
if|if
condition|(
operator|(
operator|(
name|size_t
operator|)
literal|1
operator|<<
name|tableLog
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|FSE_FUNCTION_TYPE
argument_list|)
operator|>
name|wkspSize
condition|)
return|return
name|ERROR
argument_list|(
name|tableLog_tooLarge
argument_list|)
return|;
name|tableU16
index|[
operator|-
literal|2
index|]
operator|=
operator|(
name|U16
operator|)
name|tableLog
expr_stmt|;
name|tableU16
index|[
operator|-
literal|1
index|]
operator|=
operator|(
name|U16
operator|)
name|maxSymbolValue
expr_stmt|;
comment|/* For explanations on how to distribute symbol values over the table :     *  http://fastcompression.blogspot.fr/2014/02/fse-distributing-symbol-values.html */
comment|/* symbol start positions */
block|{
name|U32
name|u
decl_stmt|;
name|cumul
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|u
operator|=
literal|1
init|;
name|u
operator|<=
name|maxSymbolValue
operator|+
literal|1
condition|;
name|u
operator|++
control|)
block|{
if|if
condition|(
name|normalizedCounter
index|[
name|u
operator|-
literal|1
index|]
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Low proba symbol */
name|cumul
index|[
name|u
index|]
operator|=
name|cumul
index|[
name|u
operator|-
literal|1
index|]
operator|+
literal|1
expr_stmt|;
name|tableSymbol
index|[
name|highThreshold
operator|--
index|]
operator|=
call|(
name|FSE_FUNCTION_TYPE
call|)
argument_list|(
name|u
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cumul
index|[
name|u
index|]
operator|=
name|cumul
index|[
name|u
operator|-
literal|1
index|]
operator|+
name|normalizedCounter
index|[
name|u
operator|-
literal|1
index|]
expr_stmt|;
block|}
block|}
name|cumul
index|[
name|maxSymbolValue
operator|+
literal|1
index|]
operator|=
name|tableSize
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Spread symbols */
block|{
name|U32
name|position
init|=
literal|0
decl_stmt|;
name|U32
name|symbol
decl_stmt|;
for|for
control|(
name|symbol
operator|=
literal|0
init|;
name|symbol
operator|<=
name|maxSymbolValue
condition|;
name|symbol
operator|++
control|)
block|{
name|int
name|nbOccurences
decl_stmt|;
for|for
control|(
name|nbOccurences
operator|=
literal|0
init|;
name|nbOccurences
operator|<
name|normalizedCounter
index|[
name|symbol
index|]
condition|;
name|nbOccurences
operator|++
control|)
block|{
name|tableSymbol
index|[
name|position
index|]
operator|=
operator|(
name|FSE_FUNCTION_TYPE
operator|)
name|symbol
expr_stmt|;
name|position
operator|=
operator|(
name|position
operator|+
name|step
operator|)
operator|&
name|tableMask
expr_stmt|;
while|while
condition|(
name|position
operator|>
name|highThreshold
condition|)
name|position
operator|=
operator|(
name|position
operator|+
name|step
operator|)
operator|&
name|tableMask
expr_stmt|;
comment|/* Low proba area */
block|}
block|}
if|if
condition|(
name|position
operator|!=
literal|0
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
comment|/* Must have gone through all positions */
block|}
comment|/* Build table */
block|{
name|U32
name|u
decl_stmt|;
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|tableSize
condition|;
name|u
operator|++
control|)
block|{
name|FSE_FUNCTION_TYPE
name|s
init|=
name|tableSymbol
index|[
name|u
index|]
decl_stmt|;
comment|/* note : static analyzer may not understand tableSymbol is properly initialized */
name|tableU16
index|[
name|cumul
index|[
name|s
index|]
operator|++
index|]
operator|=
call|(
name|U16
call|)
argument_list|(
name|tableSize
operator|+
name|u
argument_list|)
expr_stmt|;
comment|/* TableU16 : sorted by symbol order; gives next state value */
block|}
block|}
comment|/* Build Symbol Transformation Table */
block|{
name|unsigned
name|total
init|=
literal|0
decl_stmt|;
name|unsigned
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<=
name|maxSymbolValue
condition|;
name|s
operator|++
control|)
block|{
switch|switch
condition|(
name|normalizedCounter
index|[
name|s
index|]
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
operator|-
literal|1
case|:
case|case
literal|1
case|:
name|symbolTT
index|[
name|s
index|]
operator|.
name|deltaNbBits
operator|=
operator|(
name|tableLog
operator|<<
literal|16
operator|)
operator|-
operator|(
literal|1
operator|<<
name|tableLog
operator|)
expr_stmt|;
name|symbolTT
index|[
name|s
index|]
operator|.
name|deltaFindState
operator|=
name|total
operator|-
literal|1
expr_stmt|;
name|total
operator|++
expr_stmt|;
break|break;
default|default :
block|{
name|U32
specifier|const
name|maxBitsOut
init|=
name|tableLog
operator|-
name|BIT_highbit32
argument_list|(
name|normalizedCounter
index|[
name|s
index|]
operator|-
literal|1
argument_list|)
decl_stmt|;
name|U32
specifier|const
name|minStatePlus
init|=
name|normalizedCounter
index|[
name|s
index|]
operator|<<
name|maxBitsOut
decl_stmt|;
name|symbolTT
index|[
name|s
index|]
operator|.
name|deltaNbBits
operator|=
operator|(
name|maxBitsOut
operator|<<
literal|16
operator|)
operator|-
name|minStatePlus
expr_stmt|;
name|symbolTT
index|[
name|s
index|]
operator|.
name|deltaFindState
operator|=
name|total
operator|-
name|normalizedCounter
index|[
name|s
index|]
expr_stmt|;
name|total
operator|+=
name|normalizedCounter
index|[
name|s
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|size_t
name|FSE_buildCTable
parameter_list|(
name|FSE_CTable
modifier|*
name|ct
parameter_list|,
specifier|const
name|short
modifier|*
name|normalizedCounter
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|,
name|unsigned
name|tableLog
parameter_list|)
block|{
name|FSE_FUNCTION_TYPE
name|tableSymbol
index|[
name|FSE_MAX_TABLESIZE
index|]
decl_stmt|;
comment|/* memset() is not necessary, even if static analyzer complain about it */
return|return
name|FSE_buildCTable_wksp
argument_list|(
name|ct
argument_list|,
name|normalizedCounter
argument_list|,
name|maxSymbolValue
argument_list|,
name|tableLog
argument_list|,
name|tableSymbol
argument_list|,
sizeof|sizeof
argument_list|(
name|tableSymbol
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|FSE_COMMONDEFS_ONLY
end_ifndef

begin_comment
comment|/*-************************************************************** *  FSE NCount encoding-decoding ****************************************************************/
end_comment

begin_function
name|size_t
name|FSE_NCountWriteBound
parameter_list|(
name|unsigned
name|maxSymbolValue
parameter_list|,
name|unsigned
name|tableLog
parameter_list|)
block|{
name|size_t
specifier|const
name|maxHeaderSize
init|=
operator|(
operator|(
operator|(
name|maxSymbolValue
operator|+
literal|1
operator|)
operator|*
name|tableLog
operator|)
operator|>>
literal|3
operator|)
operator|+
literal|3
decl_stmt|;
return|return
name|maxSymbolValue
condition|?
name|maxHeaderSize
else|:
name|FSE_NCOUNTBOUND
return|;
comment|/* maxSymbolValue==0 ? use default */
block|}
end_function

begin_function
specifier|static
name|size_t
name|FSE_writeNCount_generic
parameter_list|(
name|void
modifier|*
name|header
parameter_list|,
name|size_t
name|headerBufferSize
parameter_list|,
specifier|const
name|short
modifier|*
name|normalizedCounter
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|,
name|unsigned
name|tableLog
parameter_list|,
name|unsigned
name|writeIsSafe
parameter_list|)
block|{
name|BYTE
modifier|*
specifier|const
name|ostart
init|=
operator|(
name|BYTE
operator|*
operator|)
name|header
decl_stmt|;
name|BYTE
modifier|*
name|out
init|=
name|ostart
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|oend
init|=
name|ostart
operator|+
name|headerBufferSize
decl_stmt|;
name|int
name|nbBits
decl_stmt|;
specifier|const
name|int
name|tableSize
init|=
literal|1
operator|<<
name|tableLog
decl_stmt|;
name|int
name|remaining
decl_stmt|;
name|int
name|threshold
decl_stmt|;
name|U32
name|bitStream
decl_stmt|;
name|int
name|bitCount
decl_stmt|;
name|unsigned
name|charnum
init|=
literal|0
decl_stmt|;
name|int
name|previous0
init|=
literal|0
decl_stmt|;
name|bitStream
operator|=
literal|0
expr_stmt|;
name|bitCount
operator|=
literal|0
expr_stmt|;
comment|/* Table Size */
name|bitStream
operator|+=
operator|(
name|tableLog
operator|-
name|FSE_MIN_TABLELOG
operator|)
operator|<<
name|bitCount
expr_stmt|;
name|bitCount
operator|+=
literal|4
expr_stmt|;
comment|/* Init */
name|remaining
operator|=
name|tableSize
operator|+
literal|1
expr_stmt|;
comment|/* +1 for extra accuracy */
name|threshold
operator|=
name|tableSize
expr_stmt|;
name|nbBits
operator|=
name|tableLog
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|remaining
operator|>
literal|1
condition|)
block|{
comment|/* stops at 1 */
if|if
condition|(
name|previous0
condition|)
block|{
name|unsigned
name|start
init|=
name|charnum
decl_stmt|;
while|while
condition|(
operator|!
name|normalizedCounter
index|[
name|charnum
index|]
condition|)
name|charnum
operator|++
expr_stmt|;
while|while
condition|(
name|charnum
operator|>=
name|start
operator|+
literal|24
condition|)
block|{
name|start
operator|+=
literal|24
expr_stmt|;
name|bitStream
operator|+=
literal|0xFFFFU
operator|<<
name|bitCount
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|writeIsSafe
operator|)
operator|&&
operator|(
name|out
operator|>
name|oend
operator|-
literal|2
operator|)
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
comment|/* Buffer overflow */
name|out
index|[
literal|0
index|]
operator|=
operator|(
name|BYTE
operator|)
name|bitStream
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
call|(
name|BYTE
call|)
argument_list|(
name|bitStream
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|2
expr_stmt|;
name|bitStream
operator|>>=
literal|16
expr_stmt|;
block|}
while|while
condition|(
name|charnum
operator|>=
name|start
operator|+
literal|3
condition|)
block|{
name|start
operator|+=
literal|3
expr_stmt|;
name|bitStream
operator|+=
literal|3
operator|<<
name|bitCount
expr_stmt|;
name|bitCount
operator|+=
literal|2
expr_stmt|;
block|}
name|bitStream
operator|+=
operator|(
name|charnum
operator|-
name|start
operator|)
operator|<<
name|bitCount
expr_stmt|;
name|bitCount
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|bitCount
operator|>
literal|16
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|writeIsSafe
operator|)
operator|&&
operator|(
name|out
operator|>
name|oend
operator|-
literal|2
operator|)
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
comment|/* Buffer overflow */
name|out
index|[
literal|0
index|]
operator|=
operator|(
name|BYTE
operator|)
name|bitStream
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
call|(
name|BYTE
call|)
argument_list|(
name|bitStream
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|2
expr_stmt|;
name|bitStream
operator|>>=
literal|16
expr_stmt|;
name|bitCount
operator|-=
literal|16
expr_stmt|;
block|}
block|}
block|{
name|int
name|count
init|=
name|normalizedCounter
index|[
name|charnum
operator|++
index|]
decl_stmt|;
name|int
specifier|const
name|max
init|=
operator|(
literal|2
operator|*
name|threshold
operator|-
literal|1
operator|)
operator|-
name|remaining
decl_stmt|;
name|remaining
operator|-=
name|count
operator|<
literal|0
condition|?
operator|-
name|count
else|:
name|count
expr_stmt|;
name|count
operator|++
expr_stmt|;
comment|/* +1 for extra accuracy */
if|if
condition|(
name|count
operator|>=
name|threshold
condition|)
name|count
operator|+=
name|max
expr_stmt|;
comment|/* [0..max[ [max..threshold[ (...) [threshold+max 2*threshold[ */
name|bitStream
operator|+=
name|count
operator|<<
name|bitCount
expr_stmt|;
name|bitCount
operator|+=
name|nbBits
expr_stmt|;
name|bitCount
operator|-=
operator|(
name|count
operator|<
name|max
operator|)
expr_stmt|;
name|previous0
operator|=
operator|(
name|count
operator|==
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|remaining
operator|<
literal|1
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
while|while
condition|(
name|remaining
operator|<
name|threshold
condition|)
name|nbBits
operator|--
operator|,
name|threshold
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bitCount
operator|>
literal|16
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|writeIsSafe
operator|)
operator|&&
operator|(
name|out
operator|>
name|oend
operator|-
literal|2
operator|)
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
comment|/* Buffer overflow */
name|out
index|[
literal|0
index|]
operator|=
operator|(
name|BYTE
operator|)
name|bitStream
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
call|(
name|BYTE
call|)
argument_list|(
name|bitStream
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|2
expr_stmt|;
name|bitStream
operator|>>=
literal|16
expr_stmt|;
name|bitCount
operator|-=
literal|16
expr_stmt|;
block|}
block|}
comment|/* flush remaining bitStream */
if|if
condition|(
operator|(
operator|!
name|writeIsSafe
operator|)
operator|&&
operator|(
name|out
operator|>
name|oend
operator|-
literal|2
operator|)
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
comment|/* Buffer overflow */
name|out
index|[
literal|0
index|]
operator|=
operator|(
name|BYTE
operator|)
name|bitStream
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
call|(
name|BYTE
call|)
argument_list|(
name|bitStream
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|out
operator|+=
operator|(
name|bitCount
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|charnum
operator|>
name|maxSymbolValue
operator|+
literal|1
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
return|return
operator|(
name|out
operator|-
name|ostart
operator|)
return|;
block|}
end_function

begin_function
name|size_t
name|FSE_writeNCount
parameter_list|(
name|void
modifier|*
name|buffer
parameter_list|,
name|size_t
name|bufferSize
parameter_list|,
specifier|const
name|short
modifier|*
name|normalizedCounter
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|,
name|unsigned
name|tableLog
parameter_list|)
block|{
if|if
condition|(
name|tableLog
operator|>
name|FSE_MAX_TABLELOG
condition|)
return|return
name|ERROR
argument_list|(
name|tableLog_tooLarge
argument_list|)
return|;
comment|/* Unsupported */
if|if
condition|(
name|tableLog
operator|<
name|FSE_MIN_TABLELOG
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
comment|/* Unsupported */
if|if
condition|(
name|bufferSize
operator|<
name|FSE_NCountWriteBound
argument_list|(
name|maxSymbolValue
argument_list|,
name|tableLog
argument_list|)
condition|)
return|return
name|FSE_writeNCount_generic
argument_list|(
name|buffer
argument_list|,
name|bufferSize
argument_list|,
name|normalizedCounter
argument_list|,
name|maxSymbolValue
argument_list|,
name|tableLog
argument_list|,
literal|0
argument_list|)
return|;
return|return
name|FSE_writeNCount_generic
argument_list|(
name|buffer
argument_list|,
name|bufferSize
argument_list|,
name|normalizedCounter
argument_list|,
name|maxSymbolValue
argument_list|,
name|tableLog
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*-************************************************************** *  Counting histogram ****************************************************************/
end_comment

begin_comment
comment|/*! FSE_count_simple     This function counts byte values within `src`, and store the histogram into table `count`.     It doesn't use any additional memory.     But this function is unsafe : it doesn't check that all values within `src` can fit into `count`.     For this reason, prefer using a table `count` with 256 elements.     @return : count of most numerous element */
end_comment

begin_function
name|size_t
name|FSE_count_simple
parameter_list|(
name|unsigned
modifier|*
name|count
parameter_list|,
name|unsigned
modifier|*
name|maxSymbolValuePtr
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|end
init|=
name|ip
operator|+
name|srcSize
decl_stmt|;
name|unsigned
name|maxSymbolValue
init|=
operator|*
name|maxSymbolValuePtr
decl_stmt|;
name|unsigned
name|max
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
name|count
argument_list|,
literal|0
argument_list|,
operator|(
name|maxSymbolValue
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|count
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|srcSize
operator|==
literal|0
condition|)
block|{
operator|*
name|maxSymbolValuePtr
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
while|while
condition|(
name|ip
operator|<
name|end
condition|)
name|count
index|[
operator|*
name|ip
operator|++
index|]
operator|++
expr_stmt|;
while|while
condition|(
operator|!
name|count
index|[
name|maxSymbolValue
index|]
condition|)
name|maxSymbolValue
operator|--
expr_stmt|;
operator|*
name|maxSymbolValuePtr
operator|=
name|maxSymbolValue
expr_stmt|;
block|{
name|U32
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<=
name|maxSymbolValue
condition|;
name|s
operator|++
control|)
if|if
condition|(
name|count
index|[
name|s
index|]
operator|>
name|max
condition|)
name|max
operator|=
name|count
index|[
name|s
index|]
expr_stmt|;
block|}
return|return
operator|(
name|size_t
operator|)
name|max
return|;
block|}
end_function

begin_comment
comment|/* FSE_count_parallel_wksp() :  * Same as FSE_count_parallel(), but using an externally provided scratch buffer.  * `workSpace` size must be a minimum of `1024 * sizeof(unsigned)`` */
end_comment

begin_function
specifier|static
name|size_t
name|FSE_count_parallel_wksp
parameter_list|(
name|unsigned
modifier|*
name|count
parameter_list|,
name|unsigned
modifier|*
name|maxSymbolValuePtr
parameter_list|,
specifier|const
name|void
modifier|*
name|source
parameter_list|,
name|size_t
name|sourceSize
parameter_list|,
name|unsigned
name|checkMax
parameter_list|,
name|unsigned
modifier|*
specifier|const
name|workSpace
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|source
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|iend
init|=
name|ip
operator|+
name|sourceSize
decl_stmt|;
name|unsigned
name|maxSymbolValue
init|=
operator|*
name|maxSymbolValuePtr
decl_stmt|;
name|unsigned
name|max
init|=
literal|0
decl_stmt|;
name|U32
modifier|*
specifier|const
name|Counting1
init|=
name|workSpace
decl_stmt|;
name|U32
modifier|*
specifier|const
name|Counting2
init|=
name|Counting1
operator|+
literal|256
decl_stmt|;
name|U32
modifier|*
specifier|const
name|Counting3
init|=
name|Counting2
operator|+
literal|256
decl_stmt|;
name|U32
modifier|*
specifier|const
name|Counting4
init|=
name|Counting3
operator|+
literal|256
decl_stmt|;
name|memset
argument_list|(
name|Counting1
argument_list|,
literal|0
argument_list|,
literal|4
operator|*
literal|256
operator|*
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
argument_list|)
expr_stmt|;
comment|/* safety checks */
if|if
condition|(
operator|!
name|sourceSize
condition|)
block|{
name|memset
argument_list|(
name|count
argument_list|,
literal|0
argument_list|,
name|maxSymbolValue
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|maxSymbolValuePtr
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|maxSymbolValue
condition|)
name|maxSymbolValue
operator|=
literal|255
expr_stmt|;
comment|/* 0 == default */
comment|/* by stripes of 16 bytes */
block|{
name|U32
name|cached
init|=
name|MEM_read32
argument_list|(
name|ip
argument_list|)
decl_stmt|;
name|ip
operator|+=
literal|4
expr_stmt|;
while|while
condition|(
name|ip
operator|<
name|iend
operator|-
literal|15
condition|)
block|{
name|U32
name|c
init|=
name|cached
decl_stmt|;
name|cached
operator|=
name|MEM_read32
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|ip
operator|+=
literal|4
expr_stmt|;
name|Counting1
index|[
operator|(
name|BYTE
operator|)
name|c
index|]
operator|++
expr_stmt|;
name|Counting2
index|[
call|(
name|BYTE
call|)
argument_list|(
name|c
operator|>>
literal|8
argument_list|)
index|]
operator|++
expr_stmt|;
name|Counting3
index|[
call|(
name|BYTE
call|)
argument_list|(
name|c
operator|>>
literal|16
argument_list|)
index|]
operator|++
expr_stmt|;
name|Counting4
index|[
name|c
operator|>>
literal|24
index|]
operator|++
expr_stmt|;
name|c
operator|=
name|cached
expr_stmt|;
name|cached
operator|=
name|MEM_read32
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|ip
operator|+=
literal|4
expr_stmt|;
name|Counting1
index|[
operator|(
name|BYTE
operator|)
name|c
index|]
operator|++
expr_stmt|;
name|Counting2
index|[
call|(
name|BYTE
call|)
argument_list|(
name|c
operator|>>
literal|8
argument_list|)
index|]
operator|++
expr_stmt|;
name|Counting3
index|[
call|(
name|BYTE
call|)
argument_list|(
name|c
operator|>>
literal|16
argument_list|)
index|]
operator|++
expr_stmt|;
name|Counting4
index|[
name|c
operator|>>
literal|24
index|]
operator|++
expr_stmt|;
name|c
operator|=
name|cached
expr_stmt|;
name|cached
operator|=
name|MEM_read32
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|ip
operator|+=
literal|4
expr_stmt|;
name|Counting1
index|[
operator|(
name|BYTE
operator|)
name|c
index|]
operator|++
expr_stmt|;
name|Counting2
index|[
call|(
name|BYTE
call|)
argument_list|(
name|c
operator|>>
literal|8
argument_list|)
index|]
operator|++
expr_stmt|;
name|Counting3
index|[
call|(
name|BYTE
call|)
argument_list|(
name|c
operator|>>
literal|16
argument_list|)
index|]
operator|++
expr_stmt|;
name|Counting4
index|[
name|c
operator|>>
literal|24
index|]
operator|++
expr_stmt|;
name|c
operator|=
name|cached
expr_stmt|;
name|cached
operator|=
name|MEM_read32
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|ip
operator|+=
literal|4
expr_stmt|;
name|Counting1
index|[
operator|(
name|BYTE
operator|)
name|c
index|]
operator|++
expr_stmt|;
name|Counting2
index|[
call|(
name|BYTE
call|)
argument_list|(
name|c
operator|>>
literal|8
argument_list|)
index|]
operator|++
expr_stmt|;
name|Counting3
index|[
call|(
name|BYTE
call|)
argument_list|(
name|c
operator|>>
literal|16
argument_list|)
index|]
operator|++
expr_stmt|;
name|Counting4
index|[
name|c
operator|>>
literal|24
index|]
operator|++
expr_stmt|;
block|}
name|ip
operator|-=
literal|4
expr_stmt|;
block|}
comment|/* finish last symbols */
while|while
condition|(
name|ip
operator|<
name|iend
condition|)
name|Counting1
index|[
operator|*
name|ip
operator|++
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|checkMax
condition|)
block|{
comment|/* verify stats will fit into destination table */
name|U32
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
literal|255
init|;
name|s
operator|>
name|maxSymbolValue
condition|;
name|s
operator|--
control|)
block|{
name|Counting1
index|[
name|s
index|]
operator|+=
name|Counting2
index|[
name|s
index|]
operator|+
name|Counting3
index|[
name|s
index|]
operator|+
name|Counting4
index|[
name|s
index|]
expr_stmt|;
if|if
condition|(
name|Counting1
index|[
name|s
index|]
condition|)
return|return
name|ERROR
argument_list|(
name|maxSymbolValue_tooSmall
argument_list|)
return|;
block|}
block|}
block|{
name|U32
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<=
name|maxSymbolValue
condition|;
name|s
operator|++
control|)
block|{
name|count
index|[
name|s
index|]
operator|=
name|Counting1
index|[
name|s
index|]
operator|+
name|Counting2
index|[
name|s
index|]
operator|+
name|Counting3
index|[
name|s
index|]
operator|+
name|Counting4
index|[
name|s
index|]
expr_stmt|;
if|if
condition|(
name|count
index|[
name|s
index|]
operator|>
name|max
condition|)
name|max
operator|=
name|count
index|[
name|s
index|]
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|!
name|count
index|[
name|maxSymbolValue
index|]
condition|)
name|maxSymbolValue
operator|--
expr_stmt|;
operator|*
name|maxSymbolValuePtr
operator|=
name|maxSymbolValue
expr_stmt|;
return|return
operator|(
name|size_t
operator|)
name|max
return|;
block|}
end_function

begin_comment
comment|/* FSE_countFast_wksp() :  * Same as FSE_countFast(), but using an externally provided scratch buffer.  * `workSpace` size must be table of>= `1024` unsigned */
end_comment

begin_function
name|size_t
name|FSE_countFast_wksp
parameter_list|(
name|unsigned
modifier|*
name|count
parameter_list|,
name|unsigned
modifier|*
name|maxSymbolValuePtr
parameter_list|,
specifier|const
name|void
modifier|*
name|source
parameter_list|,
name|size_t
name|sourceSize
parameter_list|,
name|unsigned
modifier|*
name|workSpace
parameter_list|)
block|{
if|if
condition|(
name|sourceSize
operator|<
literal|1500
condition|)
return|return
name|FSE_count_simple
argument_list|(
name|count
argument_list|,
name|maxSymbolValuePtr
argument_list|,
name|source
argument_list|,
name|sourceSize
argument_list|)
return|;
return|return
name|FSE_count_parallel_wksp
argument_list|(
name|count
argument_list|,
name|maxSymbolValuePtr
argument_list|,
name|source
argument_list|,
name|sourceSize
argument_list|,
literal|0
argument_list|,
name|workSpace
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* fast variant (unsafe : won't check if src contains values beyond count[] limit) */
end_comment

begin_function
name|size_t
name|FSE_countFast
parameter_list|(
name|unsigned
modifier|*
name|count
parameter_list|,
name|unsigned
modifier|*
name|maxSymbolValuePtr
parameter_list|,
specifier|const
name|void
modifier|*
name|source
parameter_list|,
name|size_t
name|sourceSize
parameter_list|)
block|{
name|unsigned
name|tmpCounters
index|[
literal|1024
index|]
decl_stmt|;
return|return
name|FSE_countFast_wksp
argument_list|(
name|count
argument_list|,
name|maxSymbolValuePtr
argument_list|,
name|source
argument_list|,
name|sourceSize
argument_list|,
name|tmpCounters
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* FSE_count_wksp() :  * Same as FSE_count(), but using an externally provided scratch buffer.  * `workSpace` size must be table of>= `1024` unsigned */
end_comment

begin_function
name|size_t
name|FSE_count_wksp
parameter_list|(
name|unsigned
modifier|*
name|count
parameter_list|,
name|unsigned
modifier|*
name|maxSymbolValuePtr
parameter_list|,
specifier|const
name|void
modifier|*
name|source
parameter_list|,
name|size_t
name|sourceSize
parameter_list|,
name|unsigned
modifier|*
name|workSpace
parameter_list|)
block|{
if|if
condition|(
operator|*
name|maxSymbolValuePtr
operator|<
literal|255
condition|)
return|return
name|FSE_count_parallel_wksp
argument_list|(
name|count
argument_list|,
name|maxSymbolValuePtr
argument_list|,
name|source
argument_list|,
name|sourceSize
argument_list|,
literal|1
argument_list|,
name|workSpace
argument_list|)
return|;
operator|*
name|maxSymbolValuePtr
operator|=
literal|255
expr_stmt|;
return|return
name|FSE_countFast_wksp
argument_list|(
name|count
argument_list|,
name|maxSymbolValuePtr
argument_list|,
name|source
argument_list|,
name|sourceSize
argument_list|,
name|workSpace
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|FSE_count
parameter_list|(
name|unsigned
modifier|*
name|count
parameter_list|,
name|unsigned
modifier|*
name|maxSymbolValuePtr
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
name|unsigned
name|tmpCounters
index|[
literal|1024
index|]
decl_stmt|;
return|return
name|FSE_count_wksp
argument_list|(
name|count
argument_list|,
name|maxSymbolValuePtr
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
name|tmpCounters
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*-************************************************************** *  FSE Compression Code ****************************************************************/
end_comment

begin_comment
comment|/*! FSE_sizeof_CTable() :     FSE_CTable is a variable size structure which contains :     `U16 tableLog;`     `U16 maxSymbolValue;`     `U16 nextStateNumber[1<< tableLog];`                         // This size is variable     `FSE_symbolCompressionTransform symbolTT[maxSymbolValue+1];`  // This size is variable Allocation is manual (C standard does not support variable-size structures). */
end_comment

begin_function
name|size_t
name|FSE_sizeof_CTable
parameter_list|(
name|unsigned
name|maxSymbolValue
parameter_list|,
name|unsigned
name|tableLog
parameter_list|)
block|{
if|if
condition|(
name|tableLog
operator|>
name|FSE_MAX_TABLELOG
condition|)
return|return
name|ERROR
argument_list|(
name|tableLog_tooLarge
argument_list|)
return|;
return|return
name|FSE_CTABLE_SIZE_U32
argument_list|(
name|tableLog
argument_list|,
name|maxSymbolValue
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
return|;
block|}
end_function

begin_function
name|FSE_CTable
modifier|*
name|FSE_createCTable
parameter_list|(
name|unsigned
name|maxSymbolValue
parameter_list|,
name|unsigned
name|tableLog
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|;
if|if
condition|(
name|tableLog
operator|>
name|FSE_TABLELOG_ABSOLUTE_MAX
condition|)
name|tableLog
operator|=
name|FSE_TABLELOG_ABSOLUTE_MAX
expr_stmt|;
name|size
operator|=
name|FSE_CTABLE_SIZE_U32
argument_list|(
name|tableLog
argument_list|,
name|maxSymbolValue
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
expr_stmt|;
return|return
operator|(
name|FSE_CTable
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|FSE_freeCTable
parameter_list|(
name|FSE_CTable
modifier|*
name|ct
parameter_list|)
block|{
name|free
argument_list|(
name|ct
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* provides the minimum logSize to safely represent a distribution */
end_comment

begin_function
specifier|static
name|unsigned
name|FSE_minTableLog
parameter_list|(
name|size_t
name|srcSize
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|)
block|{
name|U32
name|minBitsSrc
init|=
name|BIT_highbit32
argument_list|(
call|(
name|U32
call|)
argument_list|(
name|srcSize
operator|-
literal|1
argument_list|)
argument_list|)
operator|+
literal|1
decl_stmt|;
name|U32
name|minBitsSymbols
init|=
name|BIT_highbit32
argument_list|(
name|maxSymbolValue
argument_list|)
operator|+
literal|2
decl_stmt|;
name|U32
name|minBits
init|=
name|minBitsSrc
operator|<
name|minBitsSymbols
condition|?
name|minBitsSrc
else|:
name|minBitsSymbols
decl_stmt|;
return|return
name|minBits
return|;
block|}
end_function

begin_function
name|unsigned
name|FSE_optimalTableLog_internal
parameter_list|(
name|unsigned
name|maxTableLog
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|,
name|unsigned
name|minus
parameter_list|)
block|{
name|U32
name|maxBitsSrc
init|=
name|BIT_highbit32
argument_list|(
call|(
name|U32
call|)
argument_list|(
name|srcSize
operator|-
literal|1
argument_list|)
argument_list|)
operator|-
name|minus
decl_stmt|;
name|U32
name|tableLog
init|=
name|maxTableLog
decl_stmt|;
name|U32
name|minBits
init|=
name|FSE_minTableLog
argument_list|(
name|srcSize
argument_list|,
name|maxSymbolValue
argument_list|)
decl_stmt|;
if|if
condition|(
name|tableLog
operator|==
literal|0
condition|)
name|tableLog
operator|=
name|FSE_DEFAULT_TABLELOG
expr_stmt|;
if|if
condition|(
name|maxBitsSrc
operator|<
name|tableLog
condition|)
name|tableLog
operator|=
name|maxBitsSrc
expr_stmt|;
comment|/* Accuracy can be reduced */
if|if
condition|(
name|minBits
operator|>
name|tableLog
condition|)
name|tableLog
operator|=
name|minBits
expr_stmt|;
comment|/* Need a minimum to safely represent all symbol values */
if|if
condition|(
name|tableLog
operator|<
name|FSE_MIN_TABLELOG
condition|)
name|tableLog
operator|=
name|FSE_MIN_TABLELOG
expr_stmt|;
if|if
condition|(
name|tableLog
operator|>
name|FSE_MAX_TABLELOG
condition|)
name|tableLog
operator|=
name|FSE_MAX_TABLELOG
expr_stmt|;
return|return
name|tableLog
return|;
block|}
end_function

begin_function
name|unsigned
name|FSE_optimalTableLog
parameter_list|(
name|unsigned
name|maxTableLog
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|)
block|{
return|return
name|FSE_optimalTableLog_internal
argument_list|(
name|maxTableLog
argument_list|,
name|srcSize
argument_list|,
name|maxSymbolValue
argument_list|,
literal|2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Secondary normalization method.    To be used when primary method fails. */
end_comment

begin_function
specifier|static
name|size_t
name|FSE_normalizeM2
parameter_list|(
name|short
modifier|*
name|norm
parameter_list|,
name|U32
name|tableLog
parameter_list|,
specifier|const
name|unsigned
modifier|*
name|count
parameter_list|,
name|size_t
name|total
parameter_list|,
name|U32
name|maxSymbolValue
parameter_list|)
block|{
name|short
specifier|const
name|NOT_YET_ASSIGNED
init|=
operator|-
literal|2
decl_stmt|;
name|U32
name|s
decl_stmt|;
name|U32
name|distributed
init|=
literal|0
decl_stmt|;
name|U32
name|ToDistribute
decl_stmt|;
comment|/* Init */
name|U32
specifier|const
name|lowThreshold
init|=
call|(
name|U32
call|)
argument_list|(
name|total
operator|>>
name|tableLog
argument_list|)
decl_stmt|;
name|U32
name|lowOne
init|=
call|(
name|U32
call|)
argument_list|(
operator|(
name|total
operator|*
literal|3
operator|)
operator|>>
operator|(
name|tableLog
operator|+
literal|1
operator|)
argument_list|)
decl_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<=
name|maxSymbolValue
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|count
index|[
name|s
index|]
operator|==
literal|0
condition|)
block|{
name|norm
index|[
name|s
index|]
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|count
index|[
name|s
index|]
operator|<=
name|lowThreshold
condition|)
block|{
name|norm
index|[
name|s
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|distributed
operator|++
expr_stmt|;
name|total
operator|-=
name|count
index|[
name|s
index|]
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|count
index|[
name|s
index|]
operator|<=
name|lowOne
condition|)
block|{
name|norm
index|[
name|s
index|]
operator|=
literal|1
expr_stmt|;
name|distributed
operator|++
expr_stmt|;
name|total
operator|-=
name|count
index|[
name|s
index|]
expr_stmt|;
continue|continue;
block|}
name|norm
index|[
name|s
index|]
operator|=
name|NOT_YET_ASSIGNED
expr_stmt|;
block|}
name|ToDistribute
operator|=
operator|(
literal|1
operator|<<
name|tableLog
operator|)
operator|-
name|distributed
expr_stmt|;
if|if
condition|(
operator|(
name|total
operator|/
name|ToDistribute
operator|)
operator|>
name|lowOne
condition|)
block|{
comment|/* risk of rounding to zero */
name|lowOne
operator|=
call|(
name|U32
call|)
argument_list|(
operator|(
name|total
operator|*
literal|3
operator|)
operator|/
operator|(
name|ToDistribute
operator|*
literal|2
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<=
name|maxSymbolValue
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|norm
index|[
name|s
index|]
operator|==
name|NOT_YET_ASSIGNED
operator|)
operator|&&
operator|(
name|count
index|[
name|s
index|]
operator|<=
name|lowOne
operator|)
condition|)
block|{
name|norm
index|[
name|s
index|]
operator|=
literal|1
expr_stmt|;
name|distributed
operator|++
expr_stmt|;
name|total
operator|-=
name|count
index|[
name|s
index|]
expr_stmt|;
continue|continue;
block|}
block|}
name|ToDistribute
operator|=
operator|(
literal|1
operator|<<
name|tableLog
operator|)
operator|-
name|distributed
expr_stmt|;
block|}
if|if
condition|(
name|distributed
operator|==
name|maxSymbolValue
operator|+
literal|1
condition|)
block|{
comment|/* all values are pretty poor;            probably incompressible data (should have already been detected);            find max, then give all remaining points to max */
name|U32
name|maxV
init|=
literal|0
decl_stmt|,
name|maxC
init|=
literal|0
decl_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<=
name|maxSymbolValue
condition|;
name|s
operator|++
control|)
if|if
condition|(
name|count
index|[
name|s
index|]
operator|>
name|maxC
condition|)
name|maxV
operator|=
name|s
operator|,
name|maxC
operator|=
name|count
index|[
name|s
index|]
expr_stmt|;
name|norm
index|[
name|maxV
index|]
operator|+=
operator|(
name|short
operator|)
name|ToDistribute
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|total
operator|==
literal|0
condition|)
block|{
comment|/* all of the symbols were low enough for the lowOne or lowThreshold */
for|for
control|(
name|s
operator|=
literal|0
init|;
name|ToDistribute
operator|>
literal|0
condition|;
name|s
operator|=
operator|(
name|s
operator|+
literal|1
operator|)
operator|%
operator|(
name|maxSymbolValue
operator|+
literal|1
operator|)
control|)
if|if
condition|(
name|norm
index|[
name|s
index|]
operator|>
literal|0
condition|)
name|ToDistribute
operator|--
operator|,
name|norm
index|[
name|s
index|]
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
block|{
name|U64
specifier|const
name|vStepLog
init|=
literal|62
operator|-
name|tableLog
decl_stmt|;
name|U64
specifier|const
name|mid
init|=
operator|(
literal|1ULL
operator|<<
operator|(
name|vStepLog
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
decl_stmt|;
name|U64
specifier|const
name|rStep
init|=
operator|(
operator|(
operator|(
operator|(
name|U64
operator|)
literal|1
operator|<<
name|vStepLog
operator|)
operator|*
name|ToDistribute
operator|)
operator|+
name|mid
operator|)
operator|/
name|total
decl_stmt|;
comment|/* scale on remaining */
name|U64
name|tmpTotal
init|=
name|mid
decl_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<=
name|maxSymbolValue
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|norm
index|[
name|s
index|]
operator|==
name|NOT_YET_ASSIGNED
condition|)
block|{
name|U64
specifier|const
name|end
init|=
name|tmpTotal
operator|+
operator|(
name|count
index|[
name|s
index|]
operator|*
name|rStep
operator|)
decl_stmt|;
name|U32
specifier|const
name|sStart
init|=
call|(
name|U32
call|)
argument_list|(
name|tmpTotal
operator|>>
name|vStepLog
argument_list|)
decl_stmt|;
name|U32
specifier|const
name|sEnd
init|=
call|(
name|U32
call|)
argument_list|(
name|end
operator|>>
name|vStepLog
argument_list|)
decl_stmt|;
name|U32
specifier|const
name|weight
init|=
name|sEnd
operator|-
name|sStart
decl_stmt|;
if|if
condition|(
name|weight
operator|<
literal|1
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
name|norm
index|[
name|s
index|]
operator|=
operator|(
name|short
operator|)
name|weight
expr_stmt|;
name|tmpTotal
operator|=
name|end
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|size_t
name|FSE_normalizeCount
parameter_list|(
name|short
modifier|*
name|normalizedCounter
parameter_list|,
name|unsigned
name|tableLog
parameter_list|,
specifier|const
name|unsigned
modifier|*
name|count
parameter_list|,
name|size_t
name|total
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|)
block|{
comment|/* Sanity checks */
if|if
condition|(
name|tableLog
operator|==
literal|0
condition|)
name|tableLog
operator|=
name|FSE_DEFAULT_TABLELOG
expr_stmt|;
if|if
condition|(
name|tableLog
operator|<
name|FSE_MIN_TABLELOG
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
comment|/* Unsupported size */
if|if
condition|(
name|tableLog
operator|>
name|FSE_MAX_TABLELOG
condition|)
return|return
name|ERROR
argument_list|(
name|tableLog_tooLarge
argument_list|)
return|;
comment|/* Unsupported size */
if|if
condition|(
name|tableLog
operator|<
name|FSE_minTableLog
argument_list|(
name|total
argument_list|,
name|maxSymbolValue
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
comment|/* Too small tableLog, compression potentially impossible */
block|{
name|U32
specifier|const
name|rtbTable
index|[]
init|=
block|{
literal|0
block|,
literal|473195
block|,
literal|504333
block|,
literal|520860
block|,
literal|550000
block|,
literal|700000
block|,
literal|750000
block|,
literal|830000
block|}
decl_stmt|;
name|U64
specifier|const
name|scale
init|=
literal|62
operator|-
name|tableLog
decl_stmt|;
name|U64
specifier|const
name|step
init|=
operator|(
operator|(
name|U64
operator|)
literal|1
operator|<<
literal|62
operator|)
operator|/
name|total
decl_stmt|;
comment|/*<== here, one division ! */
name|U64
specifier|const
name|vStep
init|=
literal|1ULL
operator|<<
operator|(
name|scale
operator|-
literal|20
operator|)
decl_stmt|;
name|int
name|stillToDistribute
init|=
literal|1
operator|<<
name|tableLog
decl_stmt|;
name|unsigned
name|s
decl_stmt|;
name|unsigned
name|largest
init|=
literal|0
decl_stmt|;
name|short
name|largestP
init|=
literal|0
decl_stmt|;
name|U32
name|lowThreshold
init|=
call|(
name|U32
call|)
argument_list|(
name|total
operator|>>
name|tableLog
argument_list|)
decl_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<=
name|maxSymbolValue
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|count
index|[
name|s
index|]
operator|==
name|total
condition|)
return|return
literal|0
return|;
comment|/* rle special case */
if|if
condition|(
name|count
index|[
name|s
index|]
operator|==
literal|0
condition|)
block|{
name|normalizedCounter
index|[
name|s
index|]
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|count
index|[
name|s
index|]
operator|<=
name|lowThreshold
condition|)
block|{
name|normalizedCounter
index|[
name|s
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|stillToDistribute
operator|--
expr_stmt|;
block|}
else|else
block|{
name|short
name|proba
init|=
call|(
name|short
call|)
argument_list|(
operator|(
name|count
index|[
name|s
index|]
operator|*
name|step
operator|)
operator|>>
name|scale
argument_list|)
decl_stmt|;
if|if
condition|(
name|proba
operator|<
literal|8
condition|)
block|{
name|U64
name|restToBeat
init|=
name|vStep
operator|*
name|rtbTable
index|[
name|proba
index|]
decl_stmt|;
name|proba
operator|+=
operator|(
name|count
index|[
name|s
index|]
operator|*
name|step
operator|)
operator|-
operator|(
operator|(
name|U64
operator|)
name|proba
operator|<<
name|scale
operator|)
operator|>
name|restToBeat
expr_stmt|;
block|}
if|if
condition|(
name|proba
operator|>
name|largestP
condition|)
name|largestP
operator|=
name|proba
operator|,
name|largest
operator|=
name|s
expr_stmt|;
name|normalizedCounter
index|[
name|s
index|]
operator|=
name|proba
expr_stmt|;
name|stillToDistribute
operator|-=
name|proba
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|-
name|stillToDistribute
operator|>=
operator|(
name|normalizedCounter
index|[
name|largest
index|]
operator|>>
literal|1
operator|)
condition|)
block|{
comment|/* corner case, need another normalization method */
name|size_t
specifier|const
name|errorCode
init|=
name|FSE_normalizeM2
argument_list|(
name|normalizedCounter
argument_list|,
name|tableLog
argument_list|,
name|count
argument_list|,
name|total
argument_list|,
name|maxSymbolValue
argument_list|)
decl_stmt|;
if|if
condition|(
name|FSE_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
return|return
name|errorCode
return|;
block|}
else|else
name|normalizedCounter
index|[
name|largest
index|]
operator|+=
operator|(
name|short
operator|)
name|stillToDistribute
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|{
comment|/* Print Table (debug) */
block|U32 s;         U32 nTotal = 0;         for (s=0; s<=maxSymbolValue; s++)             printf("%3i: %4i \n", s, normalizedCounter[s]);         for (s=0; s<=maxSymbolValue; s++)             nTotal += abs(normalizedCounter[s]);         if (nTotal != (1U<<tableLog))             printf("Warning !!! Total == %u != %u !!!", nTotal, 1U<<tableLog);         getchar();     }
endif|#
directive|endif
return|return
name|tableLog
return|;
block|}
end_function

begin_comment
comment|/* fake FSE_CTable, for raw (uncompressed) input */
end_comment

begin_function
name|size_t
name|FSE_buildCTable_raw
parameter_list|(
name|FSE_CTable
modifier|*
name|ct
parameter_list|,
name|unsigned
name|nbBits
parameter_list|)
block|{
specifier|const
name|unsigned
name|tableSize
init|=
literal|1
operator|<<
name|nbBits
decl_stmt|;
specifier|const
name|unsigned
name|tableMask
init|=
name|tableSize
operator|-
literal|1
decl_stmt|;
specifier|const
name|unsigned
name|maxSymbolValue
init|=
name|tableMask
decl_stmt|;
name|void
modifier|*
specifier|const
name|ptr
init|=
name|ct
decl_stmt|;
name|U16
modifier|*
specifier|const
name|tableU16
init|=
operator|(
operator|(
name|U16
operator|*
operator|)
name|ptr
operator|)
operator|+
literal|2
decl_stmt|;
name|void
modifier|*
specifier|const
name|FSCT
init|=
operator|(
operator|(
name|U32
operator|*
operator|)
name|ptr
operator|)
operator|+
literal|1
comment|/* header */
operator|+
operator|(
name|tableSize
operator|>>
literal|1
operator|)
decl_stmt|;
comment|/* assumption : tableLog>= 1 */
name|FSE_symbolCompressionTransform
modifier|*
specifier|const
name|symbolTT
init|=
operator|(
name|FSE_symbolCompressionTransform
operator|*
operator|)
operator|(
name|FSCT
operator|)
decl_stmt|;
name|unsigned
name|s
decl_stmt|;
comment|/* Sanity checks */
if|if
condition|(
name|nbBits
operator|<
literal|1
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
comment|/* min size */
comment|/* header */
name|tableU16
index|[
operator|-
literal|2
index|]
operator|=
operator|(
name|U16
operator|)
name|nbBits
expr_stmt|;
name|tableU16
index|[
operator|-
literal|1
index|]
operator|=
operator|(
name|U16
operator|)
name|maxSymbolValue
expr_stmt|;
comment|/* Build table */
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|tableSize
condition|;
name|s
operator|++
control|)
name|tableU16
index|[
name|s
index|]
operator|=
call|(
name|U16
call|)
argument_list|(
name|tableSize
operator|+
name|s
argument_list|)
expr_stmt|;
comment|/* Build Symbol Transformation Table */
block|{
specifier|const
name|U32
name|deltaNbBits
init|=
operator|(
name|nbBits
operator|<<
literal|16
operator|)
operator|-
operator|(
literal|1
operator|<<
name|nbBits
operator|)
decl_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<=
name|maxSymbolValue
condition|;
name|s
operator|++
control|)
block|{
name|symbolTT
index|[
name|s
index|]
operator|.
name|deltaNbBits
operator|=
name|deltaNbBits
expr_stmt|;
name|symbolTT
index|[
name|s
index|]
operator|.
name|deltaFindState
operator|=
name|s
operator|-
literal|1
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* fake FSE_CTable, for rle input (always same symbol) */
end_comment

begin_function
name|size_t
name|FSE_buildCTable_rle
parameter_list|(
name|FSE_CTable
modifier|*
name|ct
parameter_list|,
name|BYTE
name|symbolValue
parameter_list|)
block|{
name|void
modifier|*
name|ptr
init|=
name|ct
decl_stmt|;
name|U16
modifier|*
name|tableU16
init|=
operator|(
operator|(
name|U16
operator|*
operator|)
name|ptr
operator|)
operator|+
literal|2
decl_stmt|;
name|void
modifier|*
name|FSCTptr
init|=
operator|(
name|U32
operator|*
operator|)
name|ptr
operator|+
literal|2
decl_stmt|;
name|FSE_symbolCompressionTransform
modifier|*
name|symbolTT
init|=
operator|(
name|FSE_symbolCompressionTransform
operator|*
operator|)
name|FSCTptr
decl_stmt|;
comment|/* header */
name|tableU16
index|[
operator|-
literal|2
index|]
operator|=
operator|(
name|U16
operator|)
literal|0
expr_stmt|;
name|tableU16
index|[
operator|-
literal|1
index|]
operator|=
operator|(
name|U16
operator|)
name|symbolValue
expr_stmt|;
comment|/* Build table */
name|tableU16
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|tableU16
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* just in case */
comment|/* Build Symbol Transformation Table */
name|symbolTT
index|[
name|symbolValue
index|]
operator|.
name|deltaNbBits
operator|=
literal|0
expr_stmt|;
name|symbolTT
index|[
name|symbolValue
index|]
operator|.
name|deltaFindState
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|FSE_compress_usingCTable_generic
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
specifier|const
name|FSE_CTable
modifier|*
name|ct
parameter_list|,
specifier|const
name|unsigned
name|fast
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|iend
init|=
name|istart
operator|+
name|srcSize
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|ip
init|=
name|iend
decl_stmt|;
name|BIT_CStream_t
name|bitC
decl_stmt|;
name|FSE_CState_t
name|CState1
decl_stmt|,
name|CState2
decl_stmt|;
comment|/* init */
if|if
condition|(
name|srcSize
operator|<=
literal|2
condition|)
return|return
literal|0
return|;
block|{
name|size_t
specifier|const
name|initError
init|=
name|BIT_initCStream
argument_list|(
operator|&
name|bitC
argument_list|,
name|dst
argument_list|,
name|dstSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|FSE_isError
argument_list|(
name|initError
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* not enough space available to write a bitstream */
block|}
define|#
directive|define
name|FSE_FLUSHBITS
parameter_list|(
name|s
parameter_list|)
value|(fast ? BIT_flushBitsFast(s) : BIT_flushBits(s))
if|if
condition|(
name|srcSize
operator|&
literal|1
condition|)
block|{
name|FSE_initCState2
argument_list|(
operator|&
name|CState1
argument_list|,
name|ct
argument_list|,
operator|*
operator|--
name|ip
argument_list|)
expr_stmt|;
name|FSE_initCState2
argument_list|(
operator|&
name|CState2
argument_list|,
name|ct
argument_list|,
operator|*
operator|--
name|ip
argument_list|)
expr_stmt|;
name|FSE_encodeSymbol
argument_list|(
operator|&
name|bitC
argument_list|,
operator|&
name|CState1
argument_list|,
operator|*
operator|--
name|ip
argument_list|)
expr_stmt|;
name|FSE_FLUSHBITS
argument_list|(
operator|&
name|bitC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FSE_initCState2
argument_list|(
operator|&
name|CState2
argument_list|,
name|ct
argument_list|,
operator|*
operator|--
name|ip
argument_list|)
expr_stmt|;
name|FSE_initCState2
argument_list|(
operator|&
name|CState1
argument_list|,
name|ct
argument_list|,
operator|*
operator|--
name|ip
argument_list|)
expr_stmt|;
block|}
comment|/* join to mod 4 */
name|srcSize
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
sizeof|sizeof
argument_list|(
name|bitC
operator|.
name|bitContainer
argument_list|)
operator|*
literal|8
operator|>
name|FSE_MAX_TABLELOG
operator|*
literal|4
operator|+
literal|7
operator|)
operator|&&
operator|(
name|srcSize
operator|&
literal|2
operator|)
condition|)
block|{
comment|/* test bit 2 */
name|FSE_encodeSymbol
argument_list|(
operator|&
name|bitC
argument_list|,
operator|&
name|CState2
argument_list|,
operator|*
operator|--
name|ip
argument_list|)
expr_stmt|;
name|FSE_encodeSymbol
argument_list|(
operator|&
name|bitC
argument_list|,
operator|&
name|CState1
argument_list|,
operator|*
operator|--
name|ip
argument_list|)
expr_stmt|;
name|FSE_FLUSHBITS
argument_list|(
operator|&
name|bitC
argument_list|)
expr_stmt|;
block|}
comment|/* 2 or 4 encoding per loop */
while|while
condition|(
name|ip
operator|>
name|istart
condition|)
block|{
name|FSE_encodeSymbol
argument_list|(
operator|&
name|bitC
argument_list|,
operator|&
name|CState2
argument_list|,
operator|*
operator|--
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|bitC
operator|.
name|bitContainer
argument_list|)
operator|*
literal|8
operator|<
name|FSE_MAX_TABLELOG
operator|*
literal|2
operator|+
literal|7
condition|)
comment|/* this test must be static */
name|FSE_FLUSHBITS
argument_list|(
operator|&
name|bitC
argument_list|)
expr_stmt|;
name|FSE_encodeSymbol
argument_list|(
operator|&
name|bitC
argument_list|,
operator|&
name|CState1
argument_list|,
operator|*
operator|--
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|bitC
operator|.
name|bitContainer
argument_list|)
operator|*
literal|8
operator|>
name|FSE_MAX_TABLELOG
operator|*
literal|4
operator|+
literal|7
condition|)
block|{
comment|/* this test must be static */
name|FSE_encodeSymbol
argument_list|(
operator|&
name|bitC
argument_list|,
operator|&
name|CState2
argument_list|,
operator|*
operator|--
name|ip
argument_list|)
expr_stmt|;
name|FSE_encodeSymbol
argument_list|(
operator|&
name|bitC
argument_list|,
operator|&
name|CState1
argument_list|,
operator|*
operator|--
name|ip
argument_list|)
expr_stmt|;
block|}
name|FSE_FLUSHBITS
argument_list|(
operator|&
name|bitC
argument_list|)
expr_stmt|;
block|}
name|FSE_flushCState
argument_list|(
operator|&
name|bitC
argument_list|,
operator|&
name|CState2
argument_list|)
expr_stmt|;
name|FSE_flushCState
argument_list|(
operator|&
name|bitC
argument_list|,
operator|&
name|CState1
argument_list|)
expr_stmt|;
return|return
name|BIT_closeCStream
argument_list|(
operator|&
name|bitC
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|FSE_compress_usingCTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
specifier|const
name|FSE_CTable
modifier|*
name|ct
parameter_list|)
block|{
name|unsigned
specifier|const
name|fast
init|=
operator|(
name|dstSize
operator|>=
name|FSE_BLOCKBOUND
argument_list|(
name|srcSize
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|fast
condition|)
return|return
name|FSE_compress_usingCTable_generic
argument_list|(
name|dst
argument_list|,
name|dstSize
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
name|ct
argument_list|,
literal|1
argument_list|)
return|;
else|else
return|return
name|FSE_compress_usingCTable_generic
argument_list|(
name|dst
argument_list|,
name|dstSize
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
name|ct
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|FSE_compressBound
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
return|return
name|FSE_COMPRESSBOUND
argument_list|(
name|size
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CHECK_V_F
parameter_list|(
name|e
parameter_list|,
name|f
parameter_list|)
value|size_t const e = f; if (ERR_isError(e)) return e
end_define

begin_define
define|#
directive|define
name|CHECK_F
parameter_list|(
name|f
parameter_list|)
value|{ CHECK_V_F(_var_err__, f); }
end_define

begin_comment
comment|/* FSE_compress_wksp() :  * Same as FSE_compress2(), but using an externally allocated scratch buffer (`workSpace`).  * `wkspSize` size must be `(1<<tableLog)`.  */
end_comment

begin_function
name|size_t
name|FSE_compress_wksp
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|,
name|unsigned
name|tableLog
parameter_list|,
name|void
modifier|*
name|workSpace
parameter_list|,
name|size_t
name|wkspSize
parameter_list|)
block|{
name|BYTE
modifier|*
specifier|const
name|ostart
init|=
operator|(
name|BYTE
operator|*
operator|)
name|dst
decl_stmt|;
name|BYTE
modifier|*
name|op
init|=
name|ostart
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|oend
init|=
name|ostart
operator|+
name|dstSize
decl_stmt|;
name|U32
name|count
index|[
name|FSE_MAX_SYMBOL_VALUE
operator|+
literal|1
index|]
decl_stmt|;
name|S16
name|norm
index|[
name|FSE_MAX_SYMBOL_VALUE
operator|+
literal|1
index|]
decl_stmt|;
name|FSE_CTable
modifier|*
name|CTable
init|=
operator|(
name|FSE_CTable
operator|*
operator|)
name|workSpace
decl_stmt|;
name|size_t
specifier|const
name|CTableSize
init|=
name|FSE_CTABLE_SIZE_U32
argument_list|(
name|tableLog
argument_list|,
name|maxSymbolValue
argument_list|)
decl_stmt|;
name|void
modifier|*
name|scratchBuffer
init|=
operator|(
name|void
operator|*
operator|)
operator|(
name|CTable
operator|+
name|CTableSize
operator|)
decl_stmt|;
name|size_t
specifier|const
name|scratchBufferSize
init|=
name|wkspSize
operator|-
operator|(
name|CTableSize
operator|*
sizeof|sizeof
argument_list|(
name|FSE_CTable
argument_list|)
operator|)
decl_stmt|;
comment|/* init conditions */
if|if
condition|(
name|wkspSize
operator|<
name|FSE_WKSP_SIZE_U32
argument_list|(
name|tableLog
argument_list|,
name|maxSymbolValue
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|tableLog_tooLarge
argument_list|)
return|;
if|if
condition|(
name|srcSize
operator|<=
literal|1
condition|)
return|return
literal|0
return|;
comment|/* Not compressible */
if|if
condition|(
operator|!
name|maxSymbolValue
condition|)
name|maxSymbolValue
operator|=
name|FSE_MAX_SYMBOL_VALUE
expr_stmt|;
if|if
condition|(
operator|!
name|tableLog
condition|)
name|tableLog
operator|=
name|FSE_DEFAULT_TABLELOG
expr_stmt|;
comment|/* Scan input and build symbol stats */
block|{
name|CHECK_V_F
argument_list|(
name|maxCount
argument_list|,
name|FSE_count_wksp
argument_list|(
name|count
argument_list|,
operator|&
name|maxSymbolValue
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
name|scratchBuffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxCount
operator|==
name|srcSize
condition|)
return|return
literal|1
return|;
comment|/* only a single symbol in src : rle */
if|if
condition|(
name|maxCount
operator|==
literal|1
condition|)
return|return
literal|0
return|;
comment|/* each symbol present maximum once => not compressible */
if|if
condition|(
name|maxCount
operator|<
operator|(
name|srcSize
operator|>>
literal|7
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Heuristic : not compressible enough */
block|}
name|tableLog
operator|=
name|FSE_optimalTableLog
argument_list|(
name|tableLog
argument_list|,
name|srcSize
argument_list|,
name|maxSymbolValue
argument_list|)
expr_stmt|;
name|CHECK_F
argument_list|(
name|FSE_normalizeCount
argument_list|(
name|norm
argument_list|,
name|tableLog
argument_list|,
name|count
argument_list|,
name|srcSize
argument_list|,
name|maxSymbolValue
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write table description header */
block|{
name|CHECK_V_F
argument_list|(
name|nc_err
argument_list|,
name|FSE_writeNCount
argument_list|(
name|op
argument_list|,
name|oend
operator|-
name|op
argument_list|,
name|norm
argument_list|,
name|maxSymbolValue
argument_list|,
name|tableLog
argument_list|)
argument_list|)
expr_stmt|;
name|op
operator|+=
name|nc_err
expr_stmt|;
block|}
comment|/* Compress */
name|CHECK_F
argument_list|(
name|FSE_buildCTable_wksp
argument_list|(
name|CTable
argument_list|,
name|norm
argument_list|,
name|maxSymbolValue
argument_list|,
name|tableLog
argument_list|,
name|scratchBuffer
argument_list|,
name|scratchBufferSize
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|CHECK_V_F
argument_list|(
name|cSize
argument_list|,
name|FSE_compress_usingCTable
argument_list|(
name|op
argument_list|,
name|oend
operator|-
name|op
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
name|CTable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cSize
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* not enough space for compressed data */
name|op
operator|+=
name|cSize
expr_stmt|;
block|}
comment|/* check compressibility */
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|op
operator|-
name|ostart
argument_list|)
operator|>=
name|srcSize
operator|-
literal|1
condition|)
return|return
literal|0
return|;
return|return
name|op
operator|-
name|ostart
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
block|{
name|FSE_CTable
name|CTable_max
index|[
name|FSE_CTABLE_SIZE_U32
argument_list|(
name|FSE_MAX_TABLELOG
argument_list|,
name|FSE_MAX_SYMBOL_VALUE
argument_list|)
index|]
decl_stmt|;
name|BYTE
name|scratchBuffer
index|[
literal|1
operator|<<
name|FSE_MAX_TABLELOG
index|]
decl_stmt|;
block|}
name|fseWkspMax_t
typedef|;
end_typedef

begin_function
name|size_t
name|FSE_compress2
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|,
name|unsigned
name|tableLog
parameter_list|)
block|{
name|fseWkspMax_t
name|scratchBuffer
decl_stmt|;
name|FSE_STATIC_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|scratchBuffer
argument_list|)
operator|>=
name|FSE_WKSP_SIZE_U32
argument_list|(
name|FSE_MAX_TABLELOG
argument_list|,
name|FSE_MAX_SYMBOL_VALUE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* compilation failures here means scratchBuffer is not large enough */
if|if
condition|(
name|tableLog
operator|>
name|FSE_MAX_TABLELOG
condition|)
return|return
name|ERROR
argument_list|(
name|tableLog_tooLarge
argument_list|)
return|;
return|return
name|FSE_compress_wksp
argument_list|(
name|dst
argument_list|,
name|dstCapacity
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
name|maxSymbolValue
argument_list|,
name|tableLog
argument_list|,
operator|&
name|scratchBuffer
argument_list|,
sizeof|sizeof
argument_list|(
name|scratchBuffer
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|FSE_compress
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
return|return
name|FSE_compress2
argument_list|(
name|dst
argument_list|,
name|dstCapacity
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
name|FSE_MAX_SYMBOL_VALUE
argument_list|,
name|FSE_DEFAULT_TABLELOG
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FSE_COMMONDEFS_ONLY */
end_comment

end_unit

