begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright (c) 2016-present, Yann Collet, Facebook, Inc.  * All rights reserved.  *  * This source code is licensed under the BSD-style license found in the  * LICENSE file in the root directory of this source tree. An additional grant  * of patent rights can be found in the PATENTS file in the same directory.  */
end_comment

begin_comment
comment|/* ======   Tuning parameters   ====== */
end_comment

begin_define
define|#
directive|define
name|ZSTDMT_NBTHREADS_MAX
value|128
end_define

begin_comment
comment|/* ======   Compiler specifics   ====== */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_if

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4204
name|)
end_pragma

begin_comment
comment|/* disable: C4204: non-constant aggregate initializer */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ======   Dependencies   ====== */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* memcpy, memset */
end_comment

begin_include
include|#
directive|include
file|"pool.h"
end_include

begin_comment
comment|/* threadpool */
end_comment

begin_include
include|#
directive|include
file|"threading.h"
end_include

begin_comment
comment|/* mutex */
end_comment

begin_include
include|#
directive|include
file|"zstd_internal.h"
end_include

begin_comment
comment|/* MIN, ERROR, ZSTD_*, ZSTD_highbit32 */
end_comment

begin_include
include|#
directive|include
file|"zstdmt_compress.h"
end_include

begin_comment
comment|/* ======   Debug   ====== */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|ZSTD_DEBUG
argument_list|)
operator|&&
operator|(
name|ZSTD_DEBUG
operator|>=
literal|2
operator|)
end_if

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/times.h>
end_include

begin_define
define|#
directive|define
name|DEBUGLOGRAW
parameter_list|(
name|l
parameter_list|,
modifier|...
parameter_list|)
value|if (l<=ZSTD_DEBUG) { fprintf(stderr, __VA_ARGS__); }
end_define

begin_define
define|#
directive|define
name|DEBUG_PRINTHEX
parameter_list|(
name|l
parameter_list|,
name|p
parameter_list|,
name|n
parameter_list|)
value|{            \     unsigned debug_u;                        \     for (debug_u=0; debug_u<(n); debug_u++)  \         DEBUGLOGRAW(l, "%02X ", ((const unsigned char*)(p))[debug_u]); \     DEBUGLOGRAW(l, " \n");                   \ }
end_define

begin_function
specifier|static
name|unsigned
name|long
name|long
name|GetCurrentClockTimeMicroseconds
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|clock_t
name|_ticksPerSecond
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|_ticksPerSecond
operator|<=
literal|0
condition|)
name|_ticksPerSecond
operator|=
name|sysconf
argument_list|(
name|_SC_CLK_TCK
argument_list|)
expr_stmt|;
block|{
name|struct
name|tms
name|junk
decl_stmt|;
name|clock_t
name|newTicks
init|=
operator|(
name|clock_t
operator|)
name|times
argument_list|(
operator|&
name|junk
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
operator|(
operator|(
name|unsigned
name|long
name|long
operator|)
name|newTicks
operator|)
operator|*
operator|(
literal|1000000
operator|)
operator|)
operator|/
name|_ticksPerSecond
operator|)
return|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|MUTEX_WAIT_TIME_DLEVEL
value|6
end_define

begin_define
define|#
directive|define
name|PTHREAD_MUTEX_LOCK
parameter_list|(
name|mutex
parameter_list|)
value|{               \     if (ZSTD_DEBUG>=MUTEX_WAIT_TIME_DLEVEL) {   \         unsigned long long const beforeTime = GetCurrentClockTimeMicroseconds(); \         pthread_mutex_lock(mutex);                \         {   unsigned long long const afterTime = GetCurrentClockTimeMicroseconds(); \             unsigned long long const elapsedTime = (afterTime-beforeTime); \             if (elapsedTime> 1000) {
comment|/* or whatever threshold you like; I'm using 1 millisecond here */
value|\                 DEBUGLOG(MUTEX_WAIT_TIME_DLEVEL, "Thread took %llu microseconds to acquire mutex %s \n", \                    elapsedTime, #mutex);          \         }   }                                     \     } else pthread_mutex_lock(mutex);             \ }
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PTHREAD_MUTEX_LOCK
parameter_list|(
name|m
parameter_list|)
value|pthread_mutex_lock(m)
end_define

begin_define
define|#
directive|define
name|DEBUG_PRINTHEX
parameter_list|(
name|l
parameter_list|,
name|p
parameter_list|,
name|n
parameter_list|)
value|{}
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* =====   Buffer Pool   ===== */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|buffer_s
block|{
name|void
modifier|*
name|start
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|}
name|buffer_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|buffer_t
name|g_nullBuffer
init|=
block|{
name|NULL
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|ZSTDMT_bufferPool_s
block|{
name|unsigned
name|totalBuffers
decl_stmt|;
name|unsigned
name|nbBuffers
decl_stmt|;
name|ZSTD_customMem
name|cMem
decl_stmt|;
name|buffer_t
name|bTable
index|[
literal|1
index|]
decl_stmt|;
comment|/* variable size */
block|}
name|ZSTDMT_bufferPool
typedef|;
end_typedef

begin_function
specifier|static
name|ZSTDMT_bufferPool
modifier|*
name|ZSTDMT_createBufferPool
parameter_list|(
name|unsigned
name|nbThreads
parameter_list|,
name|ZSTD_customMem
name|cMem
parameter_list|)
block|{
name|unsigned
specifier|const
name|maxNbBuffers
init|=
literal|2
operator|*
name|nbThreads
operator|+
literal|2
decl_stmt|;
name|ZSTDMT_bufferPool
modifier|*
specifier|const
name|bufPool
init|=
operator|(
name|ZSTDMT_bufferPool
operator|*
operator|)
name|ZSTD_calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ZSTDMT_bufferPool
argument_list|)
operator|+
operator|(
name|maxNbBuffers
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|buffer_t
argument_list|)
argument_list|,
name|cMem
argument_list|)
decl_stmt|;
if|if
condition|(
name|bufPool
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|bufPool
operator|->
name|totalBuffers
operator|=
name|maxNbBuffers
expr_stmt|;
name|bufPool
operator|->
name|nbBuffers
operator|=
literal|0
expr_stmt|;
name|bufPool
operator|->
name|cMem
operator|=
name|cMem
expr_stmt|;
return|return
name|bufPool
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ZSTDMT_freeBufferPool
parameter_list|(
name|ZSTDMT_bufferPool
modifier|*
name|bufPool
parameter_list|)
block|{
name|unsigned
name|u
decl_stmt|;
if|if
condition|(
operator|!
name|bufPool
condition|)
return|return;
comment|/* compatibility with free on NULL */
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|bufPool
operator|->
name|totalBuffers
condition|;
name|u
operator|++
control|)
name|ZSTD_free
argument_list|(
name|bufPool
operator|->
name|bTable
index|[
name|u
index|]
operator|.
name|start
argument_list|,
name|bufPool
operator|->
name|cMem
argument_list|)
expr_stmt|;
name|ZSTD_free
argument_list|(
name|bufPool
argument_list|,
name|bufPool
operator|->
name|cMem
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* only works at initialization, not during compression */
end_comment

begin_function
specifier|static
name|size_t
name|ZSTDMT_sizeof_bufferPool
parameter_list|(
name|ZSTDMT_bufferPool
modifier|*
name|bufPool
parameter_list|)
block|{
name|size_t
specifier|const
name|poolSize
init|=
sizeof|sizeof
argument_list|(
operator|*
name|bufPool
argument_list|)
operator|+
operator|(
name|bufPool
operator|->
name|totalBuffers
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|buffer_t
argument_list|)
decl_stmt|;
name|unsigned
name|u
decl_stmt|;
name|size_t
name|totalBufferSize
init|=
literal|0
decl_stmt|;
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|bufPool
operator|->
name|totalBuffers
condition|;
name|u
operator|++
control|)
name|totalBufferSize
operator|+=
name|bufPool
operator|->
name|bTable
index|[
name|u
index|]
operator|.
name|size
expr_stmt|;
return|return
name|poolSize
operator|+
name|totalBufferSize
return|;
block|}
end_function

begin_comment
comment|/** ZSTDMT_getBuffer() :  *  assumption : invocation from main thread only ! */
end_comment

begin_function
specifier|static
name|buffer_t
name|ZSTDMT_getBuffer
parameter_list|(
name|ZSTDMT_bufferPool
modifier|*
name|pool
parameter_list|,
name|size_t
name|bSize
parameter_list|)
block|{
if|if
condition|(
name|pool
operator|->
name|nbBuffers
condition|)
block|{
comment|/* try to use an existing buffer */
name|buffer_t
specifier|const
name|buf
init|=
name|pool
operator|->
name|bTable
index|[
operator|--
operator|(
name|pool
operator|->
name|nbBuffers
operator|)
index|]
decl_stmt|;
name|size_t
specifier|const
name|availBufferSize
init|=
name|buf
operator|.
name|size
decl_stmt|;
if|if
condition|(
operator|(
name|availBufferSize
operator|>=
name|bSize
operator|)
operator|&
operator|(
name|availBufferSize
operator|<=
literal|10
operator|*
name|bSize
operator|)
condition|)
comment|/* large enough, but not too much */
return|return
name|buf
return|;
comment|/* size conditions not respected : scratch this buffer, create new one */
name|ZSTD_free
argument_list|(
name|buf
operator|.
name|start
argument_list|,
name|pool
operator|->
name|cMem
argument_list|)
expr_stmt|;
block|}
comment|/* create new buffer */
block|{
name|buffer_t
name|buffer
decl_stmt|;
name|void
modifier|*
specifier|const
name|start
init|=
name|ZSTD_malloc
argument_list|(
name|bSize
argument_list|,
name|pool
operator|->
name|cMem
argument_list|)
decl_stmt|;
if|if
condition|(
name|start
operator|==
name|NULL
condition|)
name|bSize
operator|=
literal|0
expr_stmt|;
name|buffer
operator|.
name|start
operator|=
name|start
expr_stmt|;
comment|/* note : start can be NULL if malloc fails ! */
name|buffer
operator|.
name|size
operator|=
name|bSize
expr_stmt|;
return|return
name|buffer
return|;
block|}
block|}
end_function

begin_comment
comment|/* store buffer for later re-use, up to pool capacity */
end_comment

begin_function
specifier|static
name|void
name|ZSTDMT_releaseBuffer
parameter_list|(
name|ZSTDMT_bufferPool
modifier|*
name|pool
parameter_list|,
name|buffer_t
name|buf
parameter_list|)
block|{
if|if
condition|(
name|buf
operator|.
name|start
operator|==
name|NULL
condition|)
return|return;
comment|/* release on NULL */
if|if
condition|(
name|pool
operator|->
name|nbBuffers
operator|<
name|pool
operator|->
name|totalBuffers
condition|)
block|{
name|pool
operator|->
name|bTable
index|[
name|pool
operator|->
name|nbBuffers
operator|++
index|]
operator|=
name|buf
expr_stmt|;
comment|/* store for later re-use */
return|return;
block|}
comment|/* Reached bufferPool capacity (should not happen) */
name|ZSTD_free
argument_list|(
name|buf
operator|.
name|start
argument_list|,
name|pool
operator|->
name|cMem
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =====   CCtx Pool   ===== */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|totalCCtx
decl_stmt|;
name|unsigned
name|availCCtx
decl_stmt|;
name|ZSTD_customMem
name|cMem
decl_stmt|;
name|ZSTD_CCtx
modifier|*
name|cctx
index|[
literal|1
index|]
decl_stmt|;
comment|/* variable size */
block|}
name|ZSTDMT_CCtxPool
typedef|;
end_typedef

begin_comment
comment|/* assumption : CCtxPool invocation only from main thread */
end_comment

begin_comment
comment|/* note : all CCtx borrowed from the pool should be released back to the pool _before_ freeing the pool */
end_comment

begin_function
specifier|static
name|void
name|ZSTDMT_freeCCtxPool
parameter_list|(
name|ZSTDMT_CCtxPool
modifier|*
name|pool
parameter_list|)
block|{
name|unsigned
name|u
decl_stmt|;
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|pool
operator|->
name|totalCCtx
condition|;
name|u
operator|++
control|)
name|ZSTD_freeCCtx
argument_list|(
name|pool
operator|->
name|cctx
index|[
name|u
index|]
argument_list|)
expr_stmt|;
comment|/* note : compatible with free on NULL */
name|ZSTD_free
argument_list|(
name|pool
argument_list|,
name|pool
operator|->
name|cMem
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ZSTDMT_createCCtxPool() :  * implies nbThreads>= 1 , checked by caller ZSTDMT_createCCtx() */
end_comment

begin_function
specifier|static
name|ZSTDMT_CCtxPool
modifier|*
name|ZSTDMT_createCCtxPool
parameter_list|(
name|unsigned
name|nbThreads
parameter_list|,
name|ZSTD_customMem
name|cMem
parameter_list|)
block|{
name|ZSTDMT_CCtxPool
modifier|*
specifier|const
name|cctxPool
init|=
operator|(
name|ZSTDMT_CCtxPool
operator|*
operator|)
name|ZSTD_calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ZSTDMT_CCtxPool
argument_list|)
operator|+
operator|(
name|nbThreads
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|ZSTD_CCtx
operator|*
argument_list|)
argument_list|,
name|cMem
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cctxPool
condition|)
return|return
name|NULL
return|;
name|cctxPool
operator|->
name|cMem
operator|=
name|cMem
expr_stmt|;
name|cctxPool
operator|->
name|totalCCtx
operator|=
name|nbThreads
expr_stmt|;
name|cctxPool
operator|->
name|availCCtx
operator|=
literal|1
expr_stmt|;
comment|/* at least one cctx for single-thread mode */
name|cctxPool
operator|->
name|cctx
index|[
literal|0
index|]
operator|=
name|ZSTD_createCCtx_advanced
argument_list|(
name|cMem
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cctxPool
operator|->
name|cctx
index|[
literal|0
index|]
condition|)
block|{
name|ZSTDMT_freeCCtxPool
argument_list|(
name|cctxPool
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|DEBUGLOG
argument_list|(
literal|3
argument_list|,
literal|"cctxPool created, with %u threads"
argument_list|,
name|nbThreads
argument_list|)
expr_stmt|;
return|return
name|cctxPool
return|;
block|}
end_function

begin_comment
comment|/* only works during initialization phase, not during compression */
end_comment

begin_function
specifier|static
name|size_t
name|ZSTDMT_sizeof_CCtxPool
parameter_list|(
name|ZSTDMT_CCtxPool
modifier|*
name|cctxPool
parameter_list|)
block|{
name|unsigned
specifier|const
name|nbThreads
init|=
name|cctxPool
operator|->
name|totalCCtx
decl_stmt|;
name|size_t
specifier|const
name|poolSize
init|=
sizeof|sizeof
argument_list|(
operator|*
name|cctxPool
argument_list|)
operator|+
operator|(
name|nbThreads
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|ZSTD_CCtx
operator|*
argument_list|)
decl_stmt|;
name|unsigned
name|u
decl_stmt|;
name|size_t
name|totalCCtxSize
init|=
literal|0
decl_stmt|;
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|nbThreads
condition|;
name|u
operator|++
control|)
name|totalCCtxSize
operator|+=
name|ZSTD_sizeof_CCtx
argument_list|(
name|cctxPool
operator|->
name|cctx
index|[
name|u
index|]
argument_list|)
expr_stmt|;
return|return
name|poolSize
operator|+
name|totalCCtxSize
return|;
block|}
end_function

begin_function
specifier|static
name|ZSTD_CCtx
modifier|*
name|ZSTDMT_getCCtx
parameter_list|(
name|ZSTDMT_CCtxPool
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|pool
operator|->
name|availCCtx
condition|)
block|{
name|pool
operator|->
name|availCCtx
operator|--
expr_stmt|;
return|return
name|pool
operator|->
name|cctx
index|[
name|pool
operator|->
name|availCCtx
index|]
return|;
block|}
return|return
name|ZSTD_createCCtx
argument_list|()
return|;
comment|/* note : can be NULL, when creation fails ! */
block|}
end_function

begin_function
specifier|static
name|void
name|ZSTDMT_releaseCCtx
parameter_list|(
name|ZSTDMT_CCtxPool
modifier|*
name|pool
parameter_list|,
name|ZSTD_CCtx
modifier|*
name|cctx
parameter_list|)
block|{
if|if
condition|(
name|cctx
operator|==
name|NULL
condition|)
return|return;
comment|/* compatibility with release on NULL */
if|if
condition|(
name|pool
operator|->
name|availCCtx
operator|<
name|pool
operator|->
name|totalCCtx
condition|)
name|pool
operator|->
name|cctx
index|[
name|pool
operator|->
name|availCCtx
operator|++
index|]
operator|=
name|cctx
expr_stmt|;
else|else
comment|/* pool overflow : should not happen, since totalCCtx==nbThreads */
name|ZSTD_freeCCtx
argument_list|(
name|cctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =====   Thread worker   ===== */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|buffer_t
name|buffer
decl_stmt|;
name|size_t
name|filled
decl_stmt|;
block|}
name|inBuff_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|ZSTD_CCtx
modifier|*
name|cctx
decl_stmt|;
name|buffer_t
name|src
decl_stmt|;
specifier|const
name|void
modifier|*
name|srcStart
decl_stmt|;
name|size_t
name|srcSize
decl_stmt|;
name|size_t
name|dictSize
decl_stmt|;
name|buffer_t
name|dstBuff
decl_stmt|;
name|size_t
name|cSize
decl_stmt|;
name|size_t
name|dstFlushed
decl_stmt|;
name|unsigned
name|firstChunk
decl_stmt|;
name|unsigned
name|lastChunk
decl_stmt|;
name|unsigned
name|jobCompleted
decl_stmt|;
name|unsigned
name|jobScanned
decl_stmt|;
name|pthread_mutex_t
modifier|*
name|jobCompleted_mutex
decl_stmt|;
name|pthread_cond_t
modifier|*
name|jobCompleted_cond
decl_stmt|;
name|ZSTD_parameters
name|params
decl_stmt|;
specifier|const
name|ZSTD_CDict
modifier|*
name|cdict
decl_stmt|;
name|unsigned
name|long
name|long
name|fullFrameSize
decl_stmt|;
block|}
name|ZSTDMT_jobDescription
typedef|;
end_typedef

begin_comment
comment|/* ZSTDMT_compressChunk() : POOL_function type */
end_comment

begin_function
name|void
name|ZSTDMT_compressChunk
parameter_list|(
name|void
modifier|*
name|jobDescription
parameter_list|)
block|{
name|ZSTDMT_jobDescription
modifier|*
specifier|const
name|job
init|=
operator|(
name|ZSTDMT_jobDescription
operator|*
operator|)
name|jobDescription
decl_stmt|;
specifier|const
name|void
modifier|*
specifier|const
name|src
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|job
operator|->
name|srcStart
operator|+
name|job
operator|->
name|dictSize
decl_stmt|;
name|buffer_t
specifier|const
name|dstBuff
init|=
name|job
operator|->
name|dstBuff
decl_stmt|;
name|DEBUGLOG
argument_list|(
literal|5
argument_list|,
literal|"job (first:%u) (last:%u) : dictSize %u, srcSize %u"
argument_list|,
name|job
operator|->
name|firstChunk
argument_list|,
name|job
operator|->
name|lastChunk
argument_list|,
operator|(
name|U32
operator|)
name|job
operator|->
name|dictSize
argument_list|,
operator|(
name|U32
operator|)
name|job
operator|->
name|srcSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|job
operator|->
name|cdict
condition|)
block|{
comment|/* should only happen for first segment */
name|size_t
specifier|const
name|initError
init|=
name|ZSTD_compressBegin_usingCDict_advanced
argument_list|(
name|job
operator|->
name|cctx
argument_list|,
name|job
operator|->
name|cdict
argument_list|,
name|job
operator|->
name|params
operator|.
name|fParams
argument_list|,
name|job
operator|->
name|fullFrameSize
argument_list|)
decl_stmt|;
name|DEBUGLOG
argument_list|(
literal|5
argument_list|,
literal|"using CDict"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|initError
argument_list|)
condition|)
block|{
name|job
operator|->
name|cSize
operator|=
name|initError
expr_stmt|;
goto|goto
name|_endJob
goto|;
block|}
block|}
else|else
block|{
comment|/* srcStart points at reloaded section */
if|if
condition|(
operator|!
name|job
operator|->
name|firstChunk
condition|)
name|job
operator|->
name|params
operator|.
name|fParams
operator|.
name|contentSizeFlag
operator|=
literal|0
expr_stmt|;
comment|/* ensure no srcSize control */
block|{
name|size_t
specifier|const
name|dictModeError
init|=
name|ZSTD_setCCtxParameter
argument_list|(
name|job
operator|->
name|cctx
argument_list|,
name|ZSTD_p_forceRawDict
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Force loading dictionary in "content-only" mode (no header analysis) */
name|size_t
specifier|const
name|initError
init|=
name|ZSTD_compressBegin_advanced
argument_list|(
name|job
operator|->
name|cctx
argument_list|,
name|job
operator|->
name|srcStart
argument_list|,
name|job
operator|->
name|dictSize
argument_list|,
name|job
operator|->
name|params
argument_list|,
name|job
operator|->
name|fullFrameSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|initError
argument_list|)
operator|||
name|ZSTD_isError
argument_list|(
name|dictModeError
argument_list|)
condition|)
block|{
name|job
operator|->
name|cSize
operator|=
name|initError
expr_stmt|;
goto|goto
name|_endJob
goto|;
block|}
name|ZSTD_setCCtxParameter
argument_list|(
name|job
operator|->
name|cctx
argument_list|,
name|ZSTD_p_forceWindow
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|job
operator|->
name|firstChunk
condition|)
block|{
comment|/* flush and overwrite frame header when it's not first segment */
name|size_t
specifier|const
name|hSize
init|=
name|ZSTD_compressContinue
argument_list|(
name|job
operator|->
name|cctx
argument_list|,
name|dstBuff
operator|.
name|start
argument_list|,
name|dstBuff
operator|.
name|size
argument_list|,
name|src
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|hSize
argument_list|)
condition|)
block|{
name|job
operator|->
name|cSize
operator|=
name|hSize
expr_stmt|;
goto|goto
name|_endJob
goto|;
block|}
name|ZSTD_invalidateRepCodes
argument_list|(
name|job
operator|->
name|cctx
argument_list|)
expr_stmt|;
block|}
name|DEBUGLOG
argument_list|(
literal|5
argument_list|,
literal|"Compressing : "
argument_list|)
expr_stmt|;
name|DEBUG_PRINTHEX
argument_list|(
literal|4
argument_list|,
name|job
operator|->
name|srcStart
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|job
operator|->
name|cSize
operator|=
operator|(
name|job
operator|->
name|lastChunk
operator|)
condition|?
name|ZSTD_compressEnd
argument_list|(
name|job
operator|->
name|cctx
argument_list|,
name|dstBuff
operator|.
name|start
argument_list|,
name|dstBuff
operator|.
name|size
argument_list|,
name|src
argument_list|,
name|job
operator|->
name|srcSize
argument_list|)
else|:
name|ZSTD_compressContinue
argument_list|(
name|job
operator|->
name|cctx
argument_list|,
name|dstBuff
operator|.
name|start
argument_list|,
name|dstBuff
operator|.
name|size
argument_list|,
name|src
argument_list|,
name|job
operator|->
name|srcSize
argument_list|)
expr_stmt|;
name|DEBUGLOG
argument_list|(
literal|5
argument_list|,
literal|"compressed %u bytes into %u bytes   (first:%u) (last:%u)"
argument_list|,
operator|(
name|unsigned
operator|)
name|job
operator|->
name|srcSize
argument_list|,
operator|(
name|unsigned
operator|)
name|job
operator|->
name|cSize
argument_list|,
name|job
operator|->
name|firstChunk
argument_list|,
name|job
operator|->
name|lastChunk
argument_list|)
expr_stmt|;
name|DEBUGLOG
argument_list|(
literal|5
argument_list|,
literal|"dstBuff.size : %u ; => %s"
argument_list|,
operator|(
name|U32
operator|)
name|dstBuff
operator|.
name|size
argument_list|,
name|ZSTD_getErrorName
argument_list|(
name|job
operator|->
name|cSize
argument_list|)
argument_list|)
expr_stmt|;
name|_endJob
label|:
name|PTHREAD_MUTEX_LOCK
argument_list|(
name|job
operator|->
name|jobCompleted_mutex
argument_list|)
expr_stmt|;
name|job
operator|->
name|jobCompleted
operator|=
literal|1
expr_stmt|;
name|job
operator|->
name|jobScanned
operator|=
literal|0
expr_stmt|;
name|pthread_cond_signal
argument_list|(
name|job
operator|->
name|jobCompleted_cond
argument_list|)
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
name|job
operator|->
name|jobCompleted_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------ */
end_comment

begin_comment
comment|/* =====   Multi-threaded compression   ===== */
end_comment

begin_comment
comment|/* ------------------------------------------ */
end_comment

begin_struct
struct|struct
name|ZSTDMT_CCtx_s
block|{
name|POOL_ctx
modifier|*
name|factory
decl_stmt|;
name|ZSTDMT_jobDescription
modifier|*
name|jobs
decl_stmt|;
name|ZSTDMT_bufferPool
modifier|*
name|buffPool
decl_stmt|;
name|ZSTDMT_CCtxPool
modifier|*
name|cctxPool
decl_stmt|;
name|pthread_mutex_t
name|jobCompleted_mutex
decl_stmt|;
name|pthread_cond_t
name|jobCompleted_cond
decl_stmt|;
name|size_t
name|targetSectionSize
decl_stmt|;
name|size_t
name|marginSize
decl_stmt|;
name|size_t
name|inBuffSize
decl_stmt|;
name|size_t
name|dictSize
decl_stmt|;
name|size_t
name|targetDictSize
decl_stmt|;
name|inBuff_t
name|inBuff
decl_stmt|;
name|ZSTD_parameters
name|params
decl_stmt|;
name|XXH64_state_t
name|xxhState
decl_stmt|;
name|unsigned
name|nbThreads
decl_stmt|;
name|unsigned
name|jobIDMask
decl_stmt|;
name|unsigned
name|doneJobID
decl_stmt|;
name|unsigned
name|nextJobID
decl_stmt|;
name|unsigned
name|frameEnded
decl_stmt|;
name|unsigned
name|allJobsCompleted
decl_stmt|;
name|unsigned
name|overlapRLog
decl_stmt|;
name|unsigned
name|long
name|long
name|frameContentSize
decl_stmt|;
name|size_t
name|sectionSize
decl_stmt|;
name|ZSTD_customMem
name|cMem
decl_stmt|;
name|ZSTD_CDict
modifier|*
name|cdictLocal
decl_stmt|;
specifier|const
name|ZSTD_CDict
modifier|*
name|cdict
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|ZSTDMT_jobDescription
modifier|*
name|ZSTDMT_allocJobsTable
parameter_list|(
name|U32
modifier|*
name|nbJobsPtr
parameter_list|,
name|ZSTD_customMem
name|cMem
parameter_list|)
block|{
name|U32
specifier|const
name|nbJobsLog2
init|=
name|ZSTD_highbit32
argument_list|(
operator|*
name|nbJobsPtr
argument_list|)
operator|+
literal|1
decl_stmt|;
name|U32
specifier|const
name|nbJobs
init|=
literal|1
operator|<<
name|nbJobsLog2
decl_stmt|;
operator|*
name|nbJobsPtr
operator|=
name|nbJobs
expr_stmt|;
return|return
operator|(
name|ZSTDMT_jobDescription
operator|*
operator|)
name|ZSTD_calloc
argument_list|(
name|nbJobs
operator|*
sizeof|sizeof
argument_list|(
name|ZSTDMT_jobDescription
argument_list|)
argument_list|,
name|cMem
argument_list|)
return|;
block|}
end_function

begin_function
name|ZSTDMT_CCtx
modifier|*
name|ZSTDMT_createCCtx_advanced
parameter_list|(
name|unsigned
name|nbThreads
parameter_list|,
name|ZSTD_customMem
name|cMem
parameter_list|)
block|{
name|ZSTDMT_CCtx
modifier|*
name|mtctx
decl_stmt|;
name|U32
name|nbJobs
init|=
name|nbThreads
operator|+
literal|2
decl_stmt|;
name|DEBUGLOG
argument_list|(
literal|3
argument_list|,
literal|"ZSTDMT_createCCtx_advanced"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nbThreads
operator|<
literal|1
operator|)
operator||
operator|(
name|nbThreads
operator|>
name|ZSTDMT_NBTHREADS_MAX
operator|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|(
name|cMem
operator|.
name|customAlloc
operator|!=
name|NULL
operator|)
operator|^
operator|(
name|cMem
operator|.
name|customFree
operator|!=
name|NULL
operator|)
condition|)
comment|/* invalid custom allocator */
return|return
name|NULL
return|;
name|mtctx
operator|=
operator|(
name|ZSTDMT_CCtx
operator|*
operator|)
name|ZSTD_calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ZSTDMT_CCtx
argument_list|)
argument_list|,
name|cMem
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mtctx
condition|)
return|return
name|NULL
return|;
name|mtctx
operator|->
name|cMem
operator|=
name|cMem
expr_stmt|;
name|mtctx
operator|->
name|nbThreads
operator|=
name|nbThreads
expr_stmt|;
name|mtctx
operator|->
name|allJobsCompleted
operator|=
literal|1
expr_stmt|;
name|mtctx
operator|->
name|sectionSize
operator|=
literal|0
expr_stmt|;
name|mtctx
operator|->
name|overlapRLog
operator|=
literal|3
expr_stmt|;
name|mtctx
operator|->
name|factory
operator|=
name|POOL_create
argument_list|(
name|nbThreads
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mtctx
operator|->
name|jobs
operator|=
name|ZSTDMT_allocJobsTable
argument_list|(
operator|&
name|nbJobs
argument_list|,
name|cMem
argument_list|)
expr_stmt|;
name|mtctx
operator|->
name|jobIDMask
operator|=
name|nbJobs
operator|-
literal|1
expr_stmt|;
name|mtctx
operator|->
name|buffPool
operator|=
name|ZSTDMT_createBufferPool
argument_list|(
name|nbThreads
argument_list|,
name|cMem
argument_list|)
expr_stmt|;
name|mtctx
operator|->
name|cctxPool
operator|=
name|ZSTDMT_createCCtxPool
argument_list|(
name|nbThreads
argument_list|,
name|cMem
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mtctx
operator|->
name|factory
operator||
operator|!
name|mtctx
operator|->
name|jobs
operator||
operator|!
name|mtctx
operator|->
name|buffPool
operator||
operator|!
name|mtctx
operator|->
name|cctxPool
condition|)
block|{
name|ZSTDMT_freeCCtx
argument_list|(
name|mtctx
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|pthread_mutex_init
argument_list|(
operator|&
name|mtctx
operator|->
name|jobCompleted_mutex
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Todo : check init function return */
name|pthread_cond_init
argument_list|(
operator|&
name|mtctx
operator|->
name|jobCompleted_cond
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|DEBUGLOG
argument_list|(
literal|3
argument_list|,
literal|"mt_cctx created, for %u threads"
argument_list|,
name|nbThreads
argument_list|)
expr_stmt|;
return|return
name|mtctx
return|;
block|}
end_function

begin_function
name|ZSTDMT_CCtx
modifier|*
name|ZSTDMT_createCCtx
parameter_list|(
name|unsigned
name|nbThreads
parameter_list|)
block|{
return|return
name|ZSTDMT_createCCtx_advanced
argument_list|(
name|nbThreads
argument_list|,
name|ZSTD_defaultCMem
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ZSTDMT_releaseAllJobResources() :  * note : ensure all workers are killed first ! */
end_comment

begin_function
specifier|static
name|void
name|ZSTDMT_releaseAllJobResources
parameter_list|(
name|ZSTDMT_CCtx
modifier|*
name|mtctx
parameter_list|)
block|{
name|unsigned
name|jobID
decl_stmt|;
name|DEBUGLOG
argument_list|(
literal|3
argument_list|,
literal|"ZSTDMT_releaseAllJobResources"
argument_list|)
expr_stmt|;
for|for
control|(
name|jobID
operator|=
literal|0
init|;
name|jobID
operator|<=
name|mtctx
operator|->
name|jobIDMask
condition|;
name|jobID
operator|++
control|)
block|{
name|ZSTDMT_releaseBuffer
argument_list|(
name|mtctx
operator|->
name|buffPool
argument_list|,
name|mtctx
operator|->
name|jobs
index|[
name|jobID
index|]
operator|.
name|dstBuff
argument_list|)
expr_stmt|;
name|mtctx
operator|->
name|jobs
index|[
name|jobID
index|]
operator|.
name|dstBuff
operator|=
name|g_nullBuffer
expr_stmt|;
name|ZSTDMT_releaseBuffer
argument_list|(
name|mtctx
operator|->
name|buffPool
argument_list|,
name|mtctx
operator|->
name|jobs
index|[
name|jobID
index|]
operator|.
name|src
argument_list|)
expr_stmt|;
name|mtctx
operator|->
name|jobs
index|[
name|jobID
index|]
operator|.
name|src
operator|=
name|g_nullBuffer
expr_stmt|;
name|ZSTDMT_releaseCCtx
argument_list|(
name|mtctx
operator|->
name|cctxPool
argument_list|,
name|mtctx
operator|->
name|jobs
index|[
name|jobID
index|]
operator|.
name|cctx
argument_list|)
expr_stmt|;
name|mtctx
operator|->
name|jobs
index|[
name|jobID
index|]
operator|.
name|cctx
operator|=
name|NULL
expr_stmt|;
block|}
name|memset
argument_list|(
name|mtctx
operator|->
name|jobs
argument_list|,
literal|0
argument_list|,
operator|(
name|mtctx
operator|->
name|jobIDMask
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|ZSTDMT_jobDescription
argument_list|)
argument_list|)
expr_stmt|;
name|ZSTDMT_releaseBuffer
argument_list|(
name|mtctx
operator|->
name|buffPool
argument_list|,
name|mtctx
operator|->
name|inBuff
operator|.
name|buffer
argument_list|)
expr_stmt|;
name|mtctx
operator|->
name|inBuff
operator|.
name|buffer
operator|=
name|g_nullBuffer
expr_stmt|;
name|mtctx
operator|->
name|allJobsCompleted
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|size_t
name|ZSTDMT_freeCCtx
parameter_list|(
name|ZSTDMT_CCtx
modifier|*
name|mtctx
parameter_list|)
block|{
if|if
condition|(
name|mtctx
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* compatible with free on NULL */
name|POOL_free
argument_list|(
name|mtctx
operator|->
name|factory
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mtctx
operator|->
name|allJobsCompleted
condition|)
name|ZSTDMT_releaseAllJobResources
argument_list|(
name|mtctx
argument_list|)
expr_stmt|;
comment|/* stop workers first */
name|ZSTDMT_freeBufferPool
argument_list|(
name|mtctx
operator|->
name|buffPool
argument_list|)
expr_stmt|;
comment|/* release job resources into pools first */
name|ZSTD_free
argument_list|(
name|mtctx
operator|->
name|jobs
argument_list|,
name|mtctx
operator|->
name|cMem
argument_list|)
expr_stmt|;
name|ZSTDMT_freeCCtxPool
argument_list|(
name|mtctx
operator|->
name|cctxPool
argument_list|)
expr_stmt|;
name|ZSTD_freeCDict
argument_list|(
name|mtctx
operator|->
name|cdictLocal
argument_list|)
expr_stmt|;
name|pthread_mutex_destroy
argument_list|(
operator|&
name|mtctx
operator|->
name|jobCompleted_mutex
argument_list|)
expr_stmt|;
name|pthread_cond_destroy
argument_list|(
operator|&
name|mtctx
operator|->
name|jobCompleted_cond
argument_list|)
expr_stmt|;
name|ZSTD_free
argument_list|(
name|mtctx
argument_list|,
name|mtctx
operator|->
name|cMem
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTDMT_sizeof_CCtx
parameter_list|(
name|ZSTDMT_CCtx
modifier|*
name|mtctx
parameter_list|)
block|{
if|if
condition|(
name|mtctx
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* supports sizeof NULL */
return|return
sizeof|sizeof
argument_list|(
operator|*
name|mtctx
argument_list|)
operator|+
name|POOL_sizeof
argument_list|(
name|mtctx
operator|->
name|factory
argument_list|)
operator|+
name|ZSTDMT_sizeof_bufferPool
argument_list|(
name|mtctx
operator|->
name|buffPool
argument_list|)
operator|+
operator|(
name|mtctx
operator|->
name|jobIDMask
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|ZSTDMT_jobDescription
argument_list|)
operator|+
name|ZSTDMT_sizeof_CCtxPool
argument_list|(
name|mtctx
operator|->
name|cctxPool
argument_list|)
operator|+
name|ZSTD_sizeof_CDict
argument_list|(
name|mtctx
operator|->
name|cdictLocal
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTDMT_setMTCtxParameter
parameter_list|(
name|ZSTDMT_CCtx
modifier|*
name|mtctx
parameter_list|,
name|ZSDTMT_parameter
name|parameter
parameter_list|,
name|unsigned
name|value
parameter_list|)
block|{
switch|switch
condition|(
name|parameter
condition|)
block|{
case|case
name|ZSTDMT_p_sectionSize
case|:
name|mtctx
operator|->
name|sectionSize
operator|=
name|value
expr_stmt|;
return|return
literal|0
return|;
case|case
name|ZSTDMT_p_overlapSectionLog
case|:
name|DEBUGLOG
argument_list|(
literal|5
argument_list|,
literal|"ZSTDMT_p_overlapSectionLog : %u"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|mtctx
operator|->
name|overlapRLog
operator|=
operator|(
name|value
operator|>=
literal|9
operator|)
condition|?
literal|0
else|:
literal|9
operator|-
name|value
expr_stmt|;
return|return
literal|0
return|;
default|default :
return|return
name|ERROR
argument_list|(
name|compressionParameter_unsupported
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------ */
end_comment

begin_comment
comment|/* =====   Multi-threaded compression   ===== */
end_comment

begin_comment
comment|/* ------------------------------------------ */
end_comment

begin_function
specifier|static
name|unsigned
name|computeNbChunks
parameter_list|(
name|size_t
name|srcSize
parameter_list|,
name|unsigned
name|windowLog
parameter_list|,
name|unsigned
name|nbThreads
parameter_list|)
block|{
name|size_t
specifier|const
name|chunkSizeTarget
init|=
operator|(
name|size_t
operator|)
literal|1
operator|<<
operator|(
name|windowLog
operator|+
literal|2
operator|)
decl_stmt|;
name|size_t
specifier|const
name|chunkMaxSize
init|=
name|chunkSizeTarget
operator|<<
literal|2
decl_stmt|;
name|size_t
specifier|const
name|passSizeMax
init|=
name|chunkMaxSize
operator|*
name|nbThreads
decl_stmt|;
name|unsigned
specifier|const
name|multiplier
init|=
call|(
name|unsigned
call|)
argument_list|(
name|srcSize
operator|/
name|passSizeMax
argument_list|)
operator|+
literal|1
decl_stmt|;
name|unsigned
specifier|const
name|nbChunksLarge
init|=
name|multiplier
operator|*
name|nbThreads
decl_stmt|;
name|unsigned
specifier|const
name|nbChunksMax
init|=
call|(
name|unsigned
call|)
argument_list|(
name|srcSize
operator|/
name|chunkSizeTarget
argument_list|)
operator|+
literal|1
decl_stmt|;
name|unsigned
specifier|const
name|nbChunksSmall
init|=
name|MIN
argument_list|(
name|nbChunksMax
argument_list|,
name|nbThreads
argument_list|)
decl_stmt|;
return|return
operator|(
name|multiplier
operator|>
literal|1
operator|)
condition|?
name|nbChunksLarge
else|:
name|nbChunksSmall
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTDMT_compress_advanced
parameter_list|(
name|ZSTDMT_CCtx
modifier|*
name|mtctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
specifier|const
name|ZSTD_CDict
modifier|*
name|cdict
parameter_list|,
name|ZSTD_parameters
specifier|const
name|params
parameter_list|,
name|unsigned
name|overlapRLog
parameter_list|)
block|{
name|size_t
specifier|const
name|overlapSize
init|=
operator|(
name|overlapRLog
operator|>=
literal|9
operator|)
condition|?
literal|0
else|:
operator|(
name|size_t
operator|)
literal|1
operator|<<
operator|(
name|params
operator|.
name|cParams
operator|.
name|windowLog
operator|-
name|overlapRLog
operator|)
decl_stmt|;
name|unsigned
name|nbChunks
init|=
name|computeNbChunks
argument_list|(
name|srcSize
argument_list|,
name|params
operator|.
name|cParams
operator|.
name|windowLog
argument_list|,
name|mtctx
operator|->
name|nbThreads
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|proposedChunkSize
init|=
operator|(
name|srcSize
operator|+
operator|(
name|nbChunks
operator|-
literal|1
operator|)
operator|)
operator|/
name|nbChunks
decl_stmt|;
name|size_t
specifier|const
name|avgChunkSize
init|=
operator|(
operator|(
name|proposedChunkSize
operator|&
literal|0x1FFFF
operator|)
operator|<
literal|0x7FFF
operator|)
condition|?
name|proposedChunkSize
operator|+
literal|0xFFFF
else|:
name|proposedChunkSize
decl_stmt|;
comment|/* avoid too small last block */
specifier|const
name|char
modifier|*
specifier|const
name|srcStart
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|src
decl_stmt|;
name|size_t
name|remainingSrcSize
init|=
name|srcSize
decl_stmt|;
name|unsigned
specifier|const
name|compressWithinDst
init|=
operator|(
name|dstCapacity
operator|>=
name|ZSTD_compressBound
argument_list|(
name|srcSize
argument_list|)
operator|)
condition|?
name|nbChunks
else|:
call|(
name|unsigned
call|)
argument_list|(
name|dstCapacity
operator|/
name|ZSTD_compressBound
argument_list|(
name|avgChunkSize
argument_list|)
argument_list|)
decl_stmt|;
comment|/* presumes avgChunkSize>= 256 KB, which should be the case */
name|size_t
name|frameStartPos
init|=
literal|0
decl_stmt|,
name|dstBufferPos
init|=
literal|0
decl_stmt|;
name|DEBUGLOG
argument_list|(
literal|4
argument_list|,
literal|"nbChunks  : %2u   (chunkSize : %u bytes)   "
argument_list|,
name|nbChunks
argument_list|,
operator|(
name|U32
operator|)
name|avgChunkSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbChunks
operator|==
literal|1
condition|)
block|{
comment|/* fallback to single-thread mode */
name|ZSTD_CCtx
modifier|*
specifier|const
name|cctx
init|=
name|mtctx
operator|->
name|cctxPool
operator|->
name|cctx
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|cdict
condition|)
return|return
name|ZSTD_compress_usingCDict_advanced
argument_list|(
name|cctx
argument_list|,
name|dst
argument_list|,
name|dstCapacity
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
name|cdict
argument_list|,
name|params
operator|.
name|fParams
argument_list|)
return|;
return|return
name|ZSTD_compress_advanced
argument_list|(
name|cctx
argument_list|,
name|dst
argument_list|,
name|dstCapacity
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|params
argument_list|)
return|;
block|}
name|assert
argument_list|(
name|avgChunkSize
operator|>=
literal|256
name|KB
argument_list|)
expr_stmt|;
comment|/* condition for ZSTD_compressBound(A) + ZSTD_compressBound(B)<= ZSTD_compressBound(A+B), which is useful to avoid allocating extra buffers */
if|if
condition|(
name|nbChunks
operator|>
name|mtctx
operator|->
name|jobIDMask
operator|+
literal|1
condition|)
block|{
comment|/* enlarge job table */
name|U32
name|nbJobs
init|=
name|nbChunks
decl_stmt|;
name|ZSTD_free
argument_list|(
name|mtctx
operator|->
name|jobs
argument_list|,
name|mtctx
operator|->
name|cMem
argument_list|)
expr_stmt|;
name|mtctx
operator|->
name|jobIDMask
operator|=
literal|0
expr_stmt|;
name|mtctx
operator|->
name|jobs
operator|=
name|ZSTDMT_allocJobsTable
argument_list|(
operator|&
name|nbJobs
argument_list|,
name|mtctx
operator|->
name|cMem
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtctx
operator|->
name|jobs
operator|==
name|NULL
condition|)
return|return
name|ERROR
argument_list|(
name|memory_allocation
argument_list|)
return|;
name|mtctx
operator|->
name|jobIDMask
operator|=
name|nbJobs
operator|-
literal|1
expr_stmt|;
block|}
block|{
name|unsigned
name|u
decl_stmt|;
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|nbChunks
condition|;
name|u
operator|++
control|)
block|{
name|size_t
specifier|const
name|chunkSize
init|=
name|MIN
argument_list|(
name|remainingSrcSize
argument_list|,
name|avgChunkSize
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|dstBufferCapacity
init|=
name|ZSTD_compressBound
argument_list|(
name|chunkSize
argument_list|)
decl_stmt|;
name|buffer_t
specifier|const
name|dstAsBuffer
init|=
block|{
operator|(
name|char
operator|*
operator|)
name|dst
operator|+
name|dstBufferPos
block|,
name|dstBufferCapacity
block|}
decl_stmt|;
name|buffer_t
specifier|const
name|dstBuffer
init|=
name|u
operator|<
name|compressWithinDst
condition|?
name|dstAsBuffer
else|:
name|ZSTDMT_getBuffer
argument_list|(
name|mtctx
operator|->
name|buffPool
argument_list|,
name|dstBufferCapacity
argument_list|)
decl_stmt|;
name|ZSTD_CCtx
modifier|*
specifier|const
name|cctx
init|=
name|ZSTDMT_getCCtx
argument_list|(
name|mtctx
operator|->
name|cctxPool
argument_list|)
decl_stmt|;
name|size_t
name|dictSize
init|=
name|u
condition|?
name|overlapSize
else|:
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|cctx
operator|==
name|NULL
operator|)
operator|||
operator|(
name|dstBuffer
operator|.
name|start
operator|==
name|NULL
operator|)
condition|)
block|{
name|mtctx
operator|->
name|jobs
index|[
name|u
index|]
operator|.
name|cSize
operator|=
name|ERROR
argument_list|(
name|memory_allocation
argument_list|)
expr_stmt|;
comment|/* job result */
name|mtctx
operator|->
name|jobs
index|[
name|u
index|]
operator|.
name|jobCompleted
operator|=
literal|1
expr_stmt|;
name|nbChunks
operator|=
name|u
operator|+
literal|1
expr_stmt|;
comment|/* only wait and free u jobs, instead of initially expected nbChunks ones */
break|break;
comment|/* let's wait for previous jobs to complete, but don't start new ones */
block|}
name|mtctx
operator|->
name|jobs
index|[
name|u
index|]
operator|.
name|srcStart
operator|=
name|srcStart
operator|+
name|frameStartPos
operator|-
name|dictSize
expr_stmt|;
name|mtctx
operator|->
name|jobs
index|[
name|u
index|]
operator|.
name|dictSize
operator|=
name|dictSize
expr_stmt|;
name|mtctx
operator|->
name|jobs
index|[
name|u
index|]
operator|.
name|srcSize
operator|=
name|chunkSize
expr_stmt|;
name|mtctx
operator|->
name|jobs
index|[
name|u
index|]
operator|.
name|cdict
operator|=
name|mtctx
operator|->
name|nextJobID
operator|==
literal|0
condition|?
name|cdict
else|:
name|NULL
expr_stmt|;
name|mtctx
operator|->
name|jobs
index|[
name|u
index|]
operator|.
name|fullFrameSize
operator|=
name|srcSize
expr_stmt|;
name|mtctx
operator|->
name|jobs
index|[
name|u
index|]
operator|.
name|params
operator|=
name|params
expr_stmt|;
comment|/* do not calculate checksum within sections, but write it in header for first section */
if|if
condition|(
name|u
operator|!=
literal|0
condition|)
name|mtctx
operator|->
name|jobs
index|[
name|u
index|]
operator|.
name|params
operator|.
name|fParams
operator|.
name|checksumFlag
operator|=
literal|0
expr_stmt|;
name|mtctx
operator|->
name|jobs
index|[
name|u
index|]
operator|.
name|dstBuff
operator|=
name|dstBuffer
expr_stmt|;
name|mtctx
operator|->
name|jobs
index|[
name|u
index|]
operator|.
name|cctx
operator|=
name|cctx
expr_stmt|;
name|mtctx
operator|->
name|jobs
index|[
name|u
index|]
operator|.
name|firstChunk
operator|=
operator|(
name|u
operator|==
literal|0
operator|)
expr_stmt|;
name|mtctx
operator|->
name|jobs
index|[
name|u
index|]
operator|.
name|lastChunk
operator|=
operator|(
name|u
operator|==
name|nbChunks
operator|-
literal|1
operator|)
expr_stmt|;
name|mtctx
operator|->
name|jobs
index|[
name|u
index|]
operator|.
name|jobCompleted
operator|=
literal|0
expr_stmt|;
name|mtctx
operator|->
name|jobs
index|[
name|u
index|]
operator|.
name|jobCompleted_mutex
operator|=
operator|&
name|mtctx
operator|->
name|jobCompleted_mutex
expr_stmt|;
name|mtctx
operator|->
name|jobs
index|[
name|u
index|]
operator|.
name|jobCompleted_cond
operator|=
operator|&
name|mtctx
operator|->
name|jobCompleted_cond
expr_stmt|;
name|DEBUGLOG
argument_list|(
literal|5
argument_list|,
literal|"posting job %u   (%u bytes)"
argument_list|,
name|u
argument_list|,
operator|(
name|U32
operator|)
name|chunkSize
argument_list|)
expr_stmt|;
name|DEBUG_PRINTHEX
argument_list|(
literal|6
argument_list|,
name|mtctx
operator|->
name|jobs
index|[
name|u
index|]
operator|.
name|srcStart
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|POOL_add
argument_list|(
name|mtctx
operator|->
name|factory
argument_list|,
name|ZSTDMT_compressChunk
argument_list|,
operator|&
name|mtctx
operator|->
name|jobs
index|[
name|u
index|]
argument_list|)
expr_stmt|;
name|frameStartPos
operator|+=
name|chunkSize
expr_stmt|;
name|dstBufferPos
operator|+=
name|dstBufferCapacity
expr_stmt|;
name|remainingSrcSize
operator|-=
name|chunkSize
expr_stmt|;
block|}
block|}
comment|/* collect result */
block|{
name|unsigned
name|chunkID
decl_stmt|;
name|size_t
name|error
init|=
literal|0
decl_stmt|,
name|dstPos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|chunkID
operator|=
literal|0
init|;
name|chunkID
operator|<
name|nbChunks
condition|;
name|chunkID
operator|++
control|)
block|{
name|DEBUGLOG
argument_list|(
literal|5
argument_list|,
literal|"waiting for chunk %u "
argument_list|,
name|chunkID
argument_list|)
expr_stmt|;
name|PTHREAD_MUTEX_LOCK
argument_list|(
operator|&
name|mtctx
operator|->
name|jobCompleted_mutex
argument_list|)
expr_stmt|;
while|while
condition|(
name|mtctx
operator|->
name|jobs
index|[
name|chunkID
index|]
operator|.
name|jobCompleted
operator|==
literal|0
condition|)
block|{
name|DEBUGLOG
argument_list|(
literal|5
argument_list|,
literal|"waiting for jobCompleted signal from chunk %u"
argument_list|,
name|chunkID
argument_list|)
expr_stmt|;
name|pthread_cond_wait
argument_list|(
operator|&
name|mtctx
operator|->
name|jobCompleted_cond
argument_list|,
operator|&
name|mtctx
operator|->
name|jobCompleted_mutex
argument_list|)
expr_stmt|;
block|}
name|pthread_mutex_unlock
argument_list|(
operator|&
name|mtctx
operator|->
name|jobCompleted_mutex
argument_list|)
expr_stmt|;
name|DEBUGLOG
argument_list|(
literal|5
argument_list|,
literal|"ready to write chunk %u "
argument_list|,
name|chunkID
argument_list|)
expr_stmt|;
name|ZSTDMT_releaseCCtx
argument_list|(
name|mtctx
operator|->
name|cctxPool
argument_list|,
name|mtctx
operator|->
name|jobs
index|[
name|chunkID
index|]
operator|.
name|cctx
argument_list|)
expr_stmt|;
name|mtctx
operator|->
name|jobs
index|[
name|chunkID
index|]
operator|.
name|cctx
operator|=
name|NULL
expr_stmt|;
name|mtctx
operator|->
name|jobs
index|[
name|chunkID
index|]
operator|.
name|srcStart
operator|=
name|NULL
expr_stmt|;
block|{
name|size_t
specifier|const
name|cSize
init|=
name|mtctx
operator|->
name|jobs
index|[
name|chunkID
index|]
operator|.
name|cSize
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|cSize
argument_list|)
condition|)
name|error
operator|=
name|cSize
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|error
operator|)
operator|&&
operator|(
name|dstPos
operator|+
name|cSize
operator|>
name|dstCapacity
operator|)
condition|)
name|error
operator|=
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunkID
condition|)
block|{
comment|/* note : chunk 0 is written directly at dst, which is correct position */
if|if
condition|(
operator|!
name|error
condition|)
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dst
operator|+
name|dstPos
argument_list|,
name|mtctx
operator|->
name|jobs
index|[
name|chunkID
index|]
operator|.
name|dstBuff
operator|.
name|start
argument_list|,
name|cSize
argument_list|)
expr_stmt|;
comment|/* may overlap when chunk compressed within dst */
if|if
condition|(
name|chunkID
operator|>=
name|compressWithinDst
condition|)
block|{
comment|/* chunk compressed into its own buffer, which must be released */
name|DEBUGLOG
argument_list|(
literal|5
argument_list|,
literal|"releasing buffer %u>=%u"
argument_list|,
name|chunkID
argument_list|,
name|compressWithinDst
argument_list|)
expr_stmt|;
name|ZSTDMT_releaseBuffer
argument_list|(
name|mtctx
operator|->
name|buffPool
argument_list|,
name|mtctx
operator|->
name|jobs
index|[
name|chunkID
index|]
operator|.
name|dstBuff
argument_list|)
expr_stmt|;
block|}
name|mtctx
operator|->
name|jobs
index|[
name|chunkID
index|]
operator|.
name|dstBuff
operator|=
name|g_nullBuffer
expr_stmt|;
block|}
name|dstPos
operator|+=
name|cSize
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|error
condition|)
name|DEBUGLOG
argument_list|(
literal|4
argument_list|,
literal|"compressed size : %u  "
argument_list|,
operator|(
name|U32
operator|)
name|dstPos
argument_list|)
expr_stmt|;
return|return
name|error
condition|?
name|error
else|:
name|dstPos
return|;
block|}
block|}
end_function

begin_function
name|size_t
name|ZSTDMT_compressCCtx
parameter_list|(
name|ZSTDMT_CCtx
modifier|*
name|mtctx
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|int
name|compressionLevel
parameter_list|)
block|{
name|U32
specifier|const
name|overlapRLog
init|=
operator|(
name|compressionLevel
operator|>=
name|ZSTD_maxCLevel
argument_list|()
operator|)
condition|?
literal|0
else|:
literal|3
decl_stmt|;
name|ZSTD_parameters
name|params
init|=
name|ZSTD_getParams
argument_list|(
name|compressionLevel
argument_list|,
name|srcSize
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|params
operator|.
name|fParams
operator|.
name|contentSizeFlag
operator|=
literal|1
expr_stmt|;
return|return
name|ZSTDMT_compress_advanced
argument_list|(
name|mtctx
argument_list|,
name|dst
argument_list|,
name|dstCapacity
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
name|NULL
argument_list|,
name|params
argument_list|,
name|overlapRLog
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ====================================== */
end_comment

begin_comment
comment|/* =======      Streaming API     ======= */
end_comment

begin_comment
comment|/* ====================================== */
end_comment

begin_function
specifier|static
name|void
name|ZSTDMT_waitForAllJobsCompleted
parameter_list|(
name|ZSTDMT_CCtx
modifier|*
name|zcs
parameter_list|)
block|{
name|DEBUGLOG
argument_list|(
literal|4
argument_list|,
literal|"ZSTDMT_waitForAllJobsCompleted"
argument_list|)
expr_stmt|;
while|while
condition|(
name|zcs
operator|->
name|doneJobID
operator|<
name|zcs
operator|->
name|nextJobID
condition|)
block|{
name|unsigned
specifier|const
name|jobID
init|=
name|zcs
operator|->
name|doneJobID
operator|&
name|zcs
operator|->
name|jobIDMask
decl_stmt|;
name|PTHREAD_MUTEX_LOCK
argument_list|(
operator|&
name|zcs
operator|->
name|jobCompleted_mutex
argument_list|)
expr_stmt|;
while|while
condition|(
name|zcs
operator|->
name|jobs
index|[
name|jobID
index|]
operator|.
name|jobCompleted
operator|==
literal|0
condition|)
block|{
name|DEBUGLOG
argument_list|(
literal|5
argument_list|,
literal|"waiting for jobCompleted signal from chunk %u"
argument_list|,
name|zcs
operator|->
name|doneJobID
argument_list|)
expr_stmt|;
comment|/* we want to block when waiting for data to flush */
name|pthread_cond_wait
argument_list|(
operator|&
name|zcs
operator|->
name|jobCompleted_cond
argument_list|,
operator|&
name|zcs
operator|->
name|jobCompleted_mutex
argument_list|)
expr_stmt|;
block|}
name|pthread_mutex_unlock
argument_list|(
operator|&
name|zcs
operator|->
name|jobCompleted_mutex
argument_list|)
expr_stmt|;
name|zcs
operator|->
name|doneJobID
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** ZSTDMT_initCStream_internal() :  *  internal usage only */
end_comment

begin_function
name|size_t
name|ZSTDMT_initCStream_internal
parameter_list|(
name|ZSTDMT_CCtx
modifier|*
name|zcs
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|,
specifier|const
name|ZSTD_CDict
modifier|*
name|cdict
parameter_list|,
name|ZSTD_parameters
name|params
parameter_list|,
name|unsigned
name|long
name|long
name|pledgedSrcSize
parameter_list|)
block|{
name|DEBUGLOG
argument_list|(
literal|4
argument_list|,
literal|"ZSTDMT_initCStream_internal"
argument_list|)
expr_stmt|;
comment|/* params are supposed to be fully validated at this point */
name|assert
argument_list|(
operator|!
name|ZSTD_isError
argument_list|(
name|ZSTD_checkCParams
argument_list|(
name|params
operator|.
name|cParams
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
operator|(
operator|(
name|dict
operator|)
operator|&&
operator|(
name|cdict
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* either dict or cdict, not both */
if|if
condition|(
name|zcs
operator|->
name|nbThreads
operator|==
literal|1
condition|)
block|{
name|DEBUGLOG
argument_list|(
literal|4
argument_list|,
literal|"single thread mode"
argument_list|)
expr_stmt|;
return|return
name|ZSTD_initCStream_internal
argument_list|(
name|zcs
operator|->
name|cctxPool
operator|->
name|cctx
index|[
literal|0
index|]
argument_list|,
name|dict
argument_list|,
name|dictSize
argument_list|,
name|cdict
argument_list|,
name|params
argument_list|,
name|pledgedSrcSize
argument_list|)
return|;
block|}
if|if
condition|(
name|zcs
operator|->
name|allJobsCompleted
operator|==
literal|0
condition|)
block|{
comment|/* previous compression not correctly finished */
name|ZSTDMT_waitForAllJobsCompleted
argument_list|(
name|zcs
argument_list|)
expr_stmt|;
name|ZSTDMT_releaseAllJobResources
argument_list|(
name|zcs
argument_list|)
expr_stmt|;
name|zcs
operator|->
name|allJobsCompleted
operator|=
literal|1
expr_stmt|;
block|}
name|zcs
operator|->
name|params
operator|=
name|params
expr_stmt|;
name|zcs
operator|->
name|frameContentSize
operator|=
name|pledgedSrcSize
expr_stmt|;
if|if
condition|(
name|dict
condition|)
block|{
name|DEBUGLOG
argument_list|(
literal|4
argument_list|,
literal|"cdictLocal: %08X"
argument_list|,
operator|(
name|U32
operator|)
operator|(
name|size_t
operator|)
name|zcs
operator|->
name|cdictLocal
argument_list|)
expr_stmt|;
name|ZSTD_freeCDict
argument_list|(
name|zcs
operator|->
name|cdictLocal
argument_list|)
expr_stmt|;
name|zcs
operator|->
name|cdictLocal
operator|=
name|ZSTD_createCDict_advanced
argument_list|(
name|dict
argument_list|,
name|dictSize
argument_list|,
literal|0
comment|/* byRef */
argument_list|,
name|ZSTD_dm_auto
argument_list|,
comment|/* note : a loadPrefix becomes an internal CDict */
name|params
operator|.
name|cParams
argument_list|,
name|zcs
operator|->
name|cMem
argument_list|)
expr_stmt|;
name|zcs
operator|->
name|cdict
operator|=
name|zcs
operator|->
name|cdictLocal
expr_stmt|;
if|if
condition|(
name|zcs
operator|->
name|cdictLocal
operator|==
name|NULL
condition|)
return|return
name|ERROR
argument_list|(
name|memory_allocation
argument_list|)
return|;
block|}
else|else
block|{
name|DEBUGLOG
argument_list|(
literal|4
argument_list|,
literal|"cdictLocal: %08X"
argument_list|,
operator|(
name|U32
operator|)
operator|(
name|size_t
operator|)
name|zcs
operator|->
name|cdictLocal
argument_list|)
expr_stmt|;
name|ZSTD_freeCDict
argument_list|(
name|zcs
operator|->
name|cdictLocal
argument_list|)
expr_stmt|;
name|zcs
operator|->
name|cdictLocal
operator|=
name|NULL
expr_stmt|;
name|zcs
operator|->
name|cdict
operator|=
name|cdict
expr_stmt|;
block|}
name|zcs
operator|->
name|targetDictSize
operator|=
operator|(
name|zcs
operator|->
name|overlapRLog
operator|>=
literal|9
operator|)
condition|?
literal|0
else|:
operator|(
name|size_t
operator|)
literal|1
operator|<<
operator|(
name|zcs
operator|->
name|params
operator|.
name|cParams
operator|.
name|windowLog
operator|-
name|zcs
operator|->
name|overlapRLog
operator|)
expr_stmt|;
name|DEBUGLOG
argument_list|(
literal|4
argument_list|,
literal|"overlapRLog : %u "
argument_list|,
name|zcs
operator|->
name|overlapRLog
argument_list|)
expr_stmt|;
name|DEBUGLOG
argument_list|(
literal|4
argument_list|,
literal|"overlap Size : %u KB"
argument_list|,
call|(
name|U32
call|)
argument_list|(
name|zcs
operator|->
name|targetDictSize
operator|>>
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|zcs
operator|->
name|targetSectionSize
operator|=
name|zcs
operator|->
name|sectionSize
condition|?
name|zcs
operator|->
name|sectionSize
else|:
operator|(
name|size_t
operator|)
literal|1
operator|<<
operator|(
name|zcs
operator|->
name|params
operator|.
name|cParams
operator|.
name|windowLog
operator|+
literal|2
operator|)
expr_stmt|;
name|zcs
operator|->
name|targetSectionSize
operator|=
name|MAX
argument_list|(
name|ZSTDMT_SECTION_SIZE_MIN
argument_list|,
name|zcs
operator|->
name|targetSectionSize
argument_list|)
expr_stmt|;
name|zcs
operator|->
name|targetSectionSize
operator|=
name|MAX
argument_list|(
name|zcs
operator|->
name|targetDictSize
argument_list|,
name|zcs
operator|->
name|targetSectionSize
argument_list|)
expr_stmt|;
name|DEBUGLOG
argument_list|(
literal|4
argument_list|,
literal|"Section Size : %u KB"
argument_list|,
call|(
name|U32
call|)
argument_list|(
name|zcs
operator|->
name|targetSectionSize
operator|>>
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|zcs
operator|->
name|marginSize
operator|=
name|zcs
operator|->
name|targetSectionSize
operator|>>
literal|2
expr_stmt|;
name|zcs
operator|->
name|inBuffSize
operator|=
name|zcs
operator|->
name|targetDictSize
operator|+
name|zcs
operator|->
name|targetSectionSize
operator|+
name|zcs
operator|->
name|marginSize
expr_stmt|;
name|zcs
operator|->
name|inBuff
operator|.
name|buffer
operator|=
name|ZSTDMT_getBuffer
argument_list|(
name|zcs
operator|->
name|buffPool
argument_list|,
name|zcs
operator|->
name|inBuffSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcs
operator|->
name|inBuff
operator|.
name|buffer
operator|.
name|start
operator|==
name|NULL
condition|)
return|return
name|ERROR
argument_list|(
name|memory_allocation
argument_list|)
return|;
name|zcs
operator|->
name|inBuff
operator|.
name|filled
operator|=
literal|0
expr_stmt|;
name|zcs
operator|->
name|dictSize
operator|=
literal|0
expr_stmt|;
name|zcs
operator|->
name|doneJobID
operator|=
literal|0
expr_stmt|;
name|zcs
operator|->
name|nextJobID
operator|=
literal|0
expr_stmt|;
name|zcs
operator|->
name|frameEnded
operator|=
literal|0
expr_stmt|;
name|zcs
operator|->
name|allJobsCompleted
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|params
operator|.
name|fParams
operator|.
name|checksumFlag
condition|)
name|XXH64_reset
argument_list|(
operator|&
name|zcs
operator|->
name|xxhState
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTDMT_initCStream_advanced
parameter_list|(
name|ZSTDMT_CCtx
modifier|*
name|mtctx
parameter_list|,
specifier|const
name|void
modifier|*
name|dict
parameter_list|,
name|size_t
name|dictSize
parameter_list|,
name|ZSTD_parameters
name|params
parameter_list|,
name|unsigned
name|long
name|long
name|pledgedSrcSize
parameter_list|)
block|{
name|DEBUGLOG
argument_list|(
literal|5
argument_list|,
literal|"ZSTDMT_initCStream_advanced"
argument_list|)
expr_stmt|;
return|return
name|ZSTDMT_initCStream_internal
argument_list|(
name|mtctx
argument_list|,
name|dict
argument_list|,
name|dictSize
argument_list|,
name|NULL
argument_list|,
name|params
argument_list|,
name|pledgedSrcSize
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTDMT_initCStream_usingCDict
parameter_list|(
name|ZSTDMT_CCtx
modifier|*
name|mtctx
parameter_list|,
specifier|const
name|ZSTD_CDict
modifier|*
name|cdict
parameter_list|,
name|ZSTD_frameParameters
name|fParams
parameter_list|,
name|unsigned
name|long
name|long
name|pledgedSrcSize
parameter_list|)
block|{
name|ZSTD_parameters
name|params
init|=
name|ZSTD_getParamsFromCDict
argument_list|(
name|cdict
argument_list|)
decl_stmt|;
if|if
condition|(
name|cdict
operator|==
name|NULL
condition|)
return|return
name|ERROR
argument_list|(
name|dictionary_wrong
argument_list|)
return|;
comment|/* method incompatible with NULL cdict */
name|params
operator|.
name|fParams
operator|=
name|fParams
expr_stmt|;
return|return
name|ZSTDMT_initCStream_internal
argument_list|(
name|mtctx
argument_list|,
name|NULL
argument_list|,
literal|0
comment|/*dictSize*/
argument_list|,
name|cdict
argument_list|,
name|params
argument_list|,
name|pledgedSrcSize
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ZSTDMT_resetCStream() :  * pledgedSrcSize is optional and can be zero == unknown */
end_comment

begin_function
name|size_t
name|ZSTDMT_resetCStream
parameter_list|(
name|ZSTDMT_CCtx
modifier|*
name|zcs
parameter_list|,
name|unsigned
name|long
name|long
name|pledgedSrcSize
parameter_list|)
block|{
if|if
condition|(
name|zcs
operator|->
name|nbThreads
operator|==
literal|1
condition|)
return|return
name|ZSTD_resetCStream
argument_list|(
name|zcs
operator|->
name|cctxPool
operator|->
name|cctx
index|[
literal|0
index|]
argument_list|,
name|pledgedSrcSize
argument_list|)
return|;
return|return
name|ZSTDMT_initCStream_internal
argument_list|(
name|zcs
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|zcs
operator|->
name|params
argument_list|,
name|pledgedSrcSize
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTDMT_initCStream
parameter_list|(
name|ZSTDMT_CCtx
modifier|*
name|zcs
parameter_list|,
name|int
name|compressionLevel
parameter_list|)
block|{
name|ZSTD_parameters
specifier|const
name|params
init|=
name|ZSTD_getParams
argument_list|(
name|compressionLevel
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
return|return
name|ZSTDMT_initCStream_internal
argument_list|(
name|zcs
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|params
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|ZSTDMT_createCompressionJob
parameter_list|(
name|ZSTDMT_CCtx
modifier|*
name|zcs
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|unsigned
name|endFrame
parameter_list|)
block|{
name|size_t
specifier|const
name|dstBufferCapacity
init|=
name|ZSTD_compressBound
argument_list|(
name|srcSize
argument_list|)
decl_stmt|;
name|buffer_t
specifier|const
name|dstBuffer
init|=
name|ZSTDMT_getBuffer
argument_list|(
name|zcs
operator|->
name|buffPool
argument_list|,
name|dstBufferCapacity
argument_list|)
decl_stmt|;
name|ZSTD_CCtx
modifier|*
specifier|const
name|cctx
init|=
name|ZSTDMT_getCCtx
argument_list|(
name|zcs
operator|->
name|cctxPool
argument_list|)
decl_stmt|;
name|unsigned
specifier|const
name|jobID
init|=
name|zcs
operator|->
name|nextJobID
operator|&
name|zcs
operator|->
name|jobIDMask
decl_stmt|;
if|if
condition|(
operator|(
name|cctx
operator|==
name|NULL
operator|)
operator|||
operator|(
name|dstBuffer
operator|.
name|start
operator|==
name|NULL
operator|)
condition|)
block|{
name|zcs
operator|->
name|jobs
index|[
name|jobID
index|]
operator|.
name|jobCompleted
operator|=
literal|1
expr_stmt|;
name|zcs
operator|->
name|nextJobID
operator|++
expr_stmt|;
name|ZSTDMT_waitForAllJobsCompleted
argument_list|(
name|zcs
argument_list|)
expr_stmt|;
name|ZSTDMT_releaseAllJobResources
argument_list|(
name|zcs
argument_list|)
expr_stmt|;
return|return
name|ERROR
argument_list|(
name|memory_allocation
argument_list|)
return|;
block|}
name|DEBUGLOG
argument_list|(
literal|4
argument_list|,
literal|"preparing job %u to compress %u bytes with %u preload "
argument_list|,
name|zcs
operator|->
name|nextJobID
argument_list|,
operator|(
name|U32
operator|)
name|srcSize
argument_list|,
operator|(
name|U32
operator|)
name|zcs
operator|->
name|dictSize
argument_list|)
expr_stmt|;
name|zcs
operator|->
name|jobs
index|[
name|jobID
index|]
operator|.
name|src
operator|=
name|zcs
operator|->
name|inBuff
operator|.
name|buffer
expr_stmt|;
name|zcs
operator|->
name|jobs
index|[
name|jobID
index|]
operator|.
name|srcStart
operator|=
name|zcs
operator|->
name|inBuff
operator|.
name|buffer
operator|.
name|start
expr_stmt|;
name|zcs
operator|->
name|jobs
index|[
name|jobID
index|]
operator|.
name|srcSize
operator|=
name|srcSize
expr_stmt|;
name|zcs
operator|->
name|jobs
index|[
name|jobID
index|]
operator|.
name|dictSize
operator|=
name|zcs
operator|->
name|dictSize
expr_stmt|;
name|assert
argument_list|(
name|zcs
operator|->
name|inBuff
operator|.
name|filled
operator|>=
name|srcSize
operator|+
name|zcs
operator|->
name|dictSize
argument_list|)
expr_stmt|;
name|zcs
operator|->
name|jobs
index|[
name|jobID
index|]
operator|.
name|params
operator|=
name|zcs
operator|->
name|params
expr_stmt|;
comment|/* do not calculate checksum within sections, but write it in header for first section */
if|if
condition|(
name|zcs
operator|->
name|nextJobID
condition|)
name|zcs
operator|->
name|jobs
index|[
name|jobID
index|]
operator|.
name|params
operator|.
name|fParams
operator|.
name|checksumFlag
operator|=
literal|0
expr_stmt|;
name|zcs
operator|->
name|jobs
index|[
name|jobID
index|]
operator|.
name|cdict
operator|=
name|zcs
operator|->
name|nextJobID
operator|==
literal|0
condition|?
name|zcs
operator|->
name|cdict
else|:
name|NULL
expr_stmt|;
name|zcs
operator|->
name|jobs
index|[
name|jobID
index|]
operator|.
name|fullFrameSize
operator|=
name|zcs
operator|->
name|frameContentSize
expr_stmt|;
name|zcs
operator|->
name|jobs
index|[
name|jobID
index|]
operator|.
name|dstBuff
operator|=
name|dstBuffer
expr_stmt|;
name|zcs
operator|->
name|jobs
index|[
name|jobID
index|]
operator|.
name|cctx
operator|=
name|cctx
expr_stmt|;
name|zcs
operator|->
name|jobs
index|[
name|jobID
index|]
operator|.
name|firstChunk
operator|=
operator|(
name|zcs
operator|->
name|nextJobID
operator|==
literal|0
operator|)
expr_stmt|;
name|zcs
operator|->
name|jobs
index|[
name|jobID
index|]
operator|.
name|lastChunk
operator|=
name|endFrame
expr_stmt|;
name|zcs
operator|->
name|jobs
index|[
name|jobID
index|]
operator|.
name|jobCompleted
operator|=
literal|0
expr_stmt|;
name|zcs
operator|->
name|jobs
index|[
name|jobID
index|]
operator|.
name|dstFlushed
operator|=
literal|0
expr_stmt|;
name|zcs
operator|->
name|jobs
index|[
name|jobID
index|]
operator|.
name|jobCompleted_mutex
operator|=
operator|&
name|zcs
operator|->
name|jobCompleted_mutex
expr_stmt|;
name|zcs
operator|->
name|jobs
index|[
name|jobID
index|]
operator|.
name|jobCompleted_cond
operator|=
operator|&
name|zcs
operator|->
name|jobCompleted_cond
expr_stmt|;
comment|/* get a new buffer for next input */
if|if
condition|(
operator|!
name|endFrame
condition|)
block|{
name|size_t
specifier|const
name|newDictSize
init|=
name|MIN
argument_list|(
name|srcSize
operator|+
name|zcs
operator|->
name|dictSize
argument_list|,
name|zcs
operator|->
name|targetDictSize
argument_list|)
decl_stmt|;
name|DEBUGLOG
argument_list|(
literal|5
argument_list|,
literal|"ZSTDMT_createCompressionJob::endFrame = %u"
argument_list|,
name|endFrame
argument_list|)
expr_stmt|;
name|zcs
operator|->
name|inBuff
operator|.
name|buffer
operator|=
name|ZSTDMT_getBuffer
argument_list|(
name|zcs
operator|->
name|buffPool
argument_list|,
name|zcs
operator|->
name|inBuffSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcs
operator|->
name|inBuff
operator|.
name|buffer
operator|.
name|start
operator|==
name|NULL
condition|)
block|{
comment|/* not enough memory to allocate next input buffer */
name|zcs
operator|->
name|jobs
index|[
name|jobID
index|]
operator|.
name|jobCompleted
operator|=
literal|1
expr_stmt|;
name|zcs
operator|->
name|nextJobID
operator|++
expr_stmt|;
name|ZSTDMT_waitForAllJobsCompleted
argument_list|(
name|zcs
argument_list|)
expr_stmt|;
name|ZSTDMT_releaseAllJobResources
argument_list|(
name|zcs
argument_list|)
expr_stmt|;
return|return
name|ERROR
argument_list|(
name|memory_allocation
argument_list|)
return|;
block|}
name|DEBUGLOG
argument_list|(
literal|5
argument_list|,
literal|"inBuff currently filled to %u"
argument_list|,
operator|(
name|U32
operator|)
name|zcs
operator|->
name|inBuff
operator|.
name|filled
argument_list|)
expr_stmt|;
name|zcs
operator|->
name|inBuff
operator|.
name|filled
operator|-=
name|srcSize
operator|+
name|zcs
operator|->
name|dictSize
operator|-
name|newDictSize
expr_stmt|;
name|DEBUGLOG
argument_list|(
literal|5
argument_list|,
literal|"new job : inBuff filled to %u, with %u dict and %u src"
argument_list|,
operator|(
name|U32
operator|)
name|zcs
operator|->
name|inBuff
operator|.
name|filled
argument_list|,
operator|(
name|U32
operator|)
name|newDictSize
argument_list|,
call|(
name|U32
call|)
argument_list|(
name|zcs
operator|->
name|inBuff
operator|.
name|filled
operator|-
name|newDictSize
argument_list|)
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|zcs
operator|->
name|inBuff
operator|.
name|buffer
operator|.
name|start
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|zcs
operator|->
name|jobs
index|[
name|jobID
index|]
operator|.
name|srcStart
operator|+
name|zcs
operator|->
name|dictSize
operator|+
name|srcSize
operator|-
name|newDictSize
argument_list|,
name|zcs
operator|->
name|inBuff
operator|.
name|filled
argument_list|)
expr_stmt|;
name|DEBUGLOG
argument_list|(
literal|5
argument_list|,
literal|"new inBuff pre-filled"
argument_list|)
expr_stmt|;
name|zcs
operator|->
name|dictSize
operator|=
name|newDictSize
expr_stmt|;
block|}
else|else
block|{
comment|/* if (endFrame==1) */
name|DEBUGLOG
argument_list|(
literal|5
argument_list|,
literal|"ZSTDMT_createCompressionJob::endFrame = %u"
argument_list|,
name|endFrame
argument_list|)
expr_stmt|;
name|zcs
operator|->
name|inBuff
operator|.
name|buffer
operator|=
name|g_nullBuffer
expr_stmt|;
name|zcs
operator|->
name|inBuff
operator|.
name|filled
operator|=
literal|0
expr_stmt|;
name|zcs
operator|->
name|dictSize
operator|=
literal|0
expr_stmt|;
name|zcs
operator|->
name|frameEnded
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|zcs
operator|->
name|nextJobID
operator|==
literal|0
condition|)
comment|/* single chunk exception : checksum is calculated directly within worker thread */
name|zcs
operator|->
name|params
operator|.
name|fParams
operator|.
name|checksumFlag
operator|=
literal|0
expr_stmt|;
block|}
name|DEBUGLOG
argument_list|(
literal|4
argument_list|,
literal|"posting job %u : %u bytes  (end:%u) (note : doneJob = %u=>%u)"
argument_list|,
name|zcs
operator|->
name|nextJobID
argument_list|,
operator|(
name|U32
operator|)
name|zcs
operator|->
name|jobs
index|[
name|jobID
index|]
operator|.
name|srcSize
argument_list|,
name|zcs
operator|->
name|jobs
index|[
name|jobID
index|]
operator|.
name|lastChunk
argument_list|,
name|zcs
operator|->
name|doneJobID
argument_list|,
name|zcs
operator|->
name|doneJobID
operator|&
name|zcs
operator|->
name|jobIDMask
argument_list|)
expr_stmt|;
name|POOL_add
argument_list|(
name|zcs
operator|->
name|factory
argument_list|,
name|ZSTDMT_compressChunk
argument_list|,
operator|&
name|zcs
operator|->
name|jobs
index|[
name|jobID
index|]
argument_list|)
expr_stmt|;
comment|/* this call is blocking when thread worker pool is exhausted */
name|zcs
operator|->
name|nextJobID
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ZSTDMT_flushNextJob() :  * output : will be updated with amount of data flushed .  * blockToFlush : if>0, the function will block and wait if there is no data available to flush .  * @return : amount of data remaining within internal buffer, 1 if unknown but> 0, 0 if no more, or an error code */
end_comment

begin_function
specifier|static
name|size_t
name|ZSTDMT_flushNextJob
parameter_list|(
name|ZSTDMT_CCtx
modifier|*
name|zcs
parameter_list|,
name|ZSTD_outBuffer
modifier|*
name|output
parameter_list|,
name|unsigned
name|blockToFlush
parameter_list|)
block|{
name|unsigned
specifier|const
name|wJobID
init|=
name|zcs
operator|->
name|doneJobID
operator|&
name|zcs
operator|->
name|jobIDMask
decl_stmt|;
if|if
condition|(
name|zcs
operator|->
name|doneJobID
operator|==
name|zcs
operator|->
name|nextJobID
condition|)
return|return
literal|0
return|;
comment|/* all flushed ! */
name|PTHREAD_MUTEX_LOCK
argument_list|(
operator|&
name|zcs
operator|->
name|jobCompleted_mutex
argument_list|)
expr_stmt|;
while|while
condition|(
name|zcs
operator|->
name|jobs
index|[
name|wJobID
index|]
operator|.
name|jobCompleted
operator|==
literal|0
condition|)
block|{
name|DEBUGLOG
argument_list|(
literal|5
argument_list|,
literal|"waiting for jobCompleted signal from job %u"
argument_list|,
name|zcs
operator|->
name|doneJobID
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|blockToFlush
condition|)
block|{
name|pthread_mutex_unlock
argument_list|(
operator|&
name|zcs
operator|->
name|jobCompleted_mutex
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* nothing ready to be flushed => skip */
name|pthread_cond_wait
argument_list|(
operator|&
name|zcs
operator|->
name|jobCompleted_cond
argument_list|,
operator|&
name|zcs
operator|->
name|jobCompleted_mutex
argument_list|)
expr_stmt|;
comment|/* block when nothing available to flush */
block|}
name|pthread_mutex_unlock
argument_list|(
operator|&
name|zcs
operator|->
name|jobCompleted_mutex
argument_list|)
expr_stmt|;
comment|/* compression job completed : output can be flushed */
block|{
name|ZSTDMT_jobDescription
name|job
init|=
name|zcs
operator|->
name|jobs
index|[
name|wJobID
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|job
operator|.
name|jobScanned
condition|)
block|{
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|job
operator|.
name|cSize
argument_list|)
condition|)
block|{
name|DEBUGLOG
argument_list|(
literal|5
argument_list|,
literal|"compression error detected "
argument_list|)
expr_stmt|;
name|ZSTDMT_waitForAllJobsCompleted
argument_list|(
name|zcs
argument_list|)
expr_stmt|;
name|ZSTDMT_releaseAllJobResources
argument_list|(
name|zcs
argument_list|)
expr_stmt|;
return|return
name|job
operator|.
name|cSize
return|;
block|}
name|ZSTDMT_releaseCCtx
argument_list|(
name|zcs
operator|->
name|cctxPool
argument_list|,
name|job
operator|.
name|cctx
argument_list|)
expr_stmt|;
name|zcs
operator|->
name|jobs
index|[
name|wJobID
index|]
operator|.
name|cctx
operator|=
name|NULL
expr_stmt|;
name|DEBUGLOG
argument_list|(
literal|5
argument_list|,
literal|"zcs->params.fParams.checksumFlag : %u "
argument_list|,
name|zcs
operator|->
name|params
operator|.
name|fParams
operator|.
name|checksumFlag
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcs
operator|->
name|params
operator|.
name|fParams
operator|.
name|checksumFlag
condition|)
block|{
name|XXH64_update
argument_list|(
operator|&
name|zcs
operator|->
name|xxhState
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|job
operator|.
name|srcStart
operator|+
name|job
operator|.
name|dictSize
argument_list|,
name|job
operator|.
name|srcSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcs
operator|->
name|frameEnded
operator|&&
operator|(
name|zcs
operator|->
name|doneJobID
operator|+
literal|1
operator|==
name|zcs
operator|->
name|nextJobID
operator|)
condition|)
block|{
comment|/* write checksum at end of last section */
name|U32
specifier|const
name|checksum
init|=
operator|(
name|U32
operator|)
name|XXH64_digest
argument_list|(
operator|&
name|zcs
operator|->
name|xxhState
argument_list|)
decl_stmt|;
name|DEBUGLOG
argument_list|(
literal|5
argument_list|,
literal|"writing checksum : %08X \n"
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
name|MEM_writeLE32
argument_list|(
operator|(
name|char
operator|*
operator|)
name|job
operator|.
name|dstBuff
operator|.
name|start
operator|+
name|job
operator|.
name|cSize
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
name|job
operator|.
name|cSize
operator|+=
literal|4
expr_stmt|;
name|zcs
operator|->
name|jobs
index|[
name|wJobID
index|]
operator|.
name|cSize
operator|+=
literal|4
expr_stmt|;
block|}
block|}
name|ZSTDMT_releaseBuffer
argument_list|(
name|zcs
operator|->
name|buffPool
argument_list|,
name|job
operator|.
name|src
argument_list|)
expr_stmt|;
name|zcs
operator|->
name|jobs
index|[
name|wJobID
index|]
operator|.
name|srcStart
operator|=
name|NULL
expr_stmt|;
name|zcs
operator|->
name|jobs
index|[
name|wJobID
index|]
operator|.
name|src
operator|=
name|g_nullBuffer
expr_stmt|;
name|zcs
operator|->
name|jobs
index|[
name|wJobID
index|]
operator|.
name|jobScanned
operator|=
literal|1
expr_stmt|;
block|}
block|{
name|size_t
specifier|const
name|toWrite
init|=
name|MIN
argument_list|(
name|job
operator|.
name|cSize
operator|-
name|job
operator|.
name|dstFlushed
argument_list|,
name|output
operator|->
name|size
operator|-
name|output
operator|->
name|pos
argument_list|)
decl_stmt|;
name|DEBUGLOG
argument_list|(
literal|5
argument_list|,
literal|"Flushing %u bytes from job %u "
argument_list|,
operator|(
name|U32
operator|)
name|toWrite
argument_list|,
name|zcs
operator|->
name|doneJobID
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|output
operator|->
name|dst
operator|+
name|output
operator|->
name|pos
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|job
operator|.
name|dstBuff
operator|.
name|start
operator|+
name|job
operator|.
name|dstFlushed
argument_list|,
name|toWrite
argument_list|)
expr_stmt|;
name|output
operator|->
name|pos
operator|+=
name|toWrite
expr_stmt|;
name|job
operator|.
name|dstFlushed
operator|+=
name|toWrite
expr_stmt|;
block|}
if|if
condition|(
name|job
operator|.
name|dstFlushed
operator|==
name|job
operator|.
name|cSize
condition|)
block|{
comment|/* output buffer fully flushed => move to next one */
name|ZSTDMT_releaseBuffer
argument_list|(
name|zcs
operator|->
name|buffPool
argument_list|,
name|job
operator|.
name|dstBuff
argument_list|)
expr_stmt|;
name|zcs
operator|->
name|jobs
index|[
name|wJobID
index|]
operator|.
name|dstBuff
operator|=
name|g_nullBuffer
expr_stmt|;
name|zcs
operator|->
name|jobs
index|[
name|wJobID
index|]
operator|.
name|jobCompleted
operator|=
literal|0
expr_stmt|;
name|zcs
operator|->
name|doneJobID
operator|++
expr_stmt|;
block|}
else|else
block|{
name|zcs
operator|->
name|jobs
index|[
name|wJobID
index|]
operator|.
name|dstFlushed
operator|=
name|job
operator|.
name|dstFlushed
expr_stmt|;
block|}
comment|/* return value : how many bytes left in buffer ; fake it to 1 if unknown but>0 */
if|if
condition|(
name|job
operator|.
name|cSize
operator|>
name|job
operator|.
name|dstFlushed
condition|)
return|return
operator|(
name|job
operator|.
name|cSize
operator|-
name|job
operator|.
name|dstFlushed
operator|)
return|;
if|if
condition|(
name|zcs
operator|->
name|doneJobID
operator|<
name|zcs
operator|->
name|nextJobID
condition|)
return|return
literal|1
return|;
comment|/* still some buffer to flush */
name|zcs
operator|->
name|allJobsCompleted
operator|=
name|zcs
operator|->
name|frameEnded
expr_stmt|;
comment|/* frame completed and entirely flushed */
return|return
literal|0
return|;
comment|/* everything flushed */
block|}
block|}
end_function

begin_comment
comment|/** ZSTDMT_compressStream_generic() :  *  internal use only  *  assumption : output and input are valid (pos<= size)  * @return : minimum amount of data remaining to flush, 0 if none */
end_comment

begin_function
name|size_t
name|ZSTDMT_compressStream_generic
parameter_list|(
name|ZSTDMT_CCtx
modifier|*
name|mtctx
parameter_list|,
name|ZSTD_outBuffer
modifier|*
name|output
parameter_list|,
name|ZSTD_inBuffer
modifier|*
name|input
parameter_list|,
name|ZSTD_EndDirective
name|endOp
parameter_list|)
block|{
name|size_t
specifier|const
name|newJobThreshold
init|=
name|mtctx
operator|->
name|dictSize
operator|+
name|mtctx
operator|->
name|targetSectionSize
operator|+
name|mtctx
operator|->
name|marginSize
decl_stmt|;
name|assert
argument_list|(
name|output
operator|->
name|pos
operator|<=
name|output
operator|->
name|size
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|input
operator|->
name|pos
operator|<=
name|input
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mtctx
operator|->
name|frameEnded
operator|)
operator|&&
operator|(
name|endOp
operator|==
name|ZSTD_e_continue
operator|)
condition|)
block|{
comment|/* current frame being ended. Only flush/end are allowed. Or start new frame with init */
return|return
name|ERROR
argument_list|(
name|stage_wrong
argument_list|)
return|;
block|}
if|if
condition|(
name|mtctx
operator|->
name|nbThreads
operator|==
literal|1
condition|)
block|{
return|return
name|ZSTD_compressStream_generic
argument_list|(
name|mtctx
operator|->
name|cctxPool
operator|->
name|cctx
index|[
literal|0
index|]
argument_list|,
name|output
argument_list|,
name|input
argument_list|,
name|endOp
argument_list|)
return|;
block|}
comment|/* single-pass shortcut (note : this is blocking-mode) */
if|if
condition|(
operator|(
name|mtctx
operator|->
name|nextJobID
operator|==
literal|0
operator|)
comment|/* just started */
operator|&&
operator|(
name|mtctx
operator|->
name|inBuff
operator|.
name|filled
operator|==
literal|0
operator|)
comment|/* nothing buffered */
operator|&&
operator|(
name|endOp
operator|==
name|ZSTD_e_end
operator|)
comment|/* end order */
operator|&&
operator|(
name|output
operator|->
name|size
operator|-
name|output
operator|->
name|pos
operator|>=
name|ZSTD_compressBound
argument_list|(
name|input
operator|->
name|size
operator|-
name|input
operator|->
name|pos
argument_list|)
operator|)
condition|)
block|{
comment|/* enough room */
name|size_t
specifier|const
name|cSize
init|=
name|ZSTDMT_compress_advanced
argument_list|(
name|mtctx
argument_list|,
operator|(
name|char
operator|*
operator|)
name|output
operator|->
name|dst
operator|+
name|output
operator|->
name|pos
argument_list|,
name|output
operator|->
name|size
operator|-
name|output
operator|->
name|pos
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|input
operator|->
name|src
operator|+
name|input
operator|->
name|pos
argument_list|,
name|input
operator|->
name|size
operator|-
name|input
operator|->
name|pos
argument_list|,
name|mtctx
operator|->
name|cdict
argument_list|,
name|mtctx
operator|->
name|params
argument_list|,
name|mtctx
operator|->
name|overlapRLog
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|cSize
argument_list|)
condition|)
return|return
name|cSize
return|;
name|input
operator|->
name|pos
operator|=
name|input
operator|->
name|size
expr_stmt|;
name|output
operator|->
name|pos
operator|+=
name|cSize
expr_stmt|;
name|ZSTDMT_releaseBuffer
argument_list|(
name|mtctx
operator|->
name|buffPool
argument_list|,
name|mtctx
operator|->
name|inBuff
operator|.
name|buffer
argument_list|)
expr_stmt|;
comment|/* was allocated in initStream */
name|mtctx
operator|->
name|allJobsCompleted
operator|=
literal|1
expr_stmt|;
name|mtctx
operator|->
name|frameEnded
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* fill input buffer */
if|if
condition|(
operator|(
name|input
operator|->
name|src
operator|)
operator|&&
operator|(
name|mtctx
operator|->
name|inBuff
operator|.
name|buffer
operator|.
name|start
operator|)
condition|)
block|{
comment|/* support NULL input */
name|size_t
specifier|const
name|toLoad
init|=
name|MIN
argument_list|(
name|input
operator|->
name|size
operator|-
name|input
operator|->
name|pos
argument_list|,
name|mtctx
operator|->
name|inBuffSize
operator|-
name|mtctx
operator|->
name|inBuff
operator|.
name|filled
argument_list|)
decl_stmt|;
name|DEBUGLOG
argument_list|(
literal|2
argument_list|,
literal|"inBuff:%08X;  inBuffSize=%u;  ToCopy=%u"
argument_list|,
operator|(
name|U32
operator|)
operator|(
name|size_t
operator|)
name|mtctx
operator|->
name|inBuff
operator|.
name|buffer
operator|.
name|start
argument_list|,
operator|(
name|U32
operator|)
name|mtctx
operator|->
name|inBuffSize
argument_list|,
operator|(
name|U32
operator|)
name|toLoad
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mtctx
operator|->
name|inBuff
operator|.
name|buffer
operator|.
name|start
operator|+
name|mtctx
operator|->
name|inBuff
operator|.
name|filled
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|input
operator|->
name|src
operator|+
name|input
operator|->
name|pos
argument_list|,
name|toLoad
argument_list|)
expr_stmt|;
name|input
operator|->
name|pos
operator|+=
name|toLoad
expr_stmt|;
name|mtctx
operator|->
name|inBuff
operator|.
name|filled
operator|+=
name|toLoad
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mtctx
operator|->
name|inBuff
operator|.
name|filled
operator|>=
name|newJobThreshold
operator|)
comment|/* filled enough : let's compress */
operator|&&
operator|(
name|mtctx
operator|->
name|nextJobID
operator|<=
name|mtctx
operator|->
name|doneJobID
operator|+
name|mtctx
operator|->
name|jobIDMask
operator|)
condition|)
block|{
comment|/* avoid overwriting job round buffer */
name|CHECK_F
argument_list|(
name|ZSTDMT_createCompressionJob
argument_list|(
name|mtctx
argument_list|,
name|mtctx
operator|->
name|targetSectionSize
argument_list|,
literal|0
comment|/* endFrame */
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* check for potential compressed data ready to be flushed */
name|CHECK_F
argument_list|(
name|ZSTDMT_flushNextJob
argument_list|(
name|mtctx
argument_list|,
name|output
argument_list|,
operator|(
name|mtctx
operator|->
name|inBuff
operator|.
name|filled
operator|==
name|mtctx
operator|->
name|inBuffSize
operator|)
comment|/* blockToFlush */
argument_list|)
argument_list|)
expr_stmt|;
comment|/* block if it wasn't possible to create new job due to saturation */
if|if
condition|(
name|input
operator|->
name|pos
operator|<
name|input
operator|->
name|size
condition|)
comment|/* input not consumed : do not flush yet */
name|endOp
operator|=
name|ZSTD_e_continue
expr_stmt|;
switch|switch
condition|(
name|endOp
condition|)
block|{
case|case
name|ZSTD_e_flush
case|:
return|return
name|ZSTDMT_flushStream
argument_list|(
name|mtctx
argument_list|,
name|output
argument_list|)
return|;
case|case
name|ZSTD_e_end
case|:
return|return
name|ZSTDMT_endStream
argument_list|(
name|mtctx
argument_list|,
name|output
argument_list|)
return|;
case|case
name|ZSTD_e_continue
case|:
return|return
literal|1
return|;
default|default:
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
comment|/* invalid endDirective */
block|}
block|}
end_function

begin_function
name|size_t
name|ZSTDMT_compressStream
parameter_list|(
name|ZSTDMT_CCtx
modifier|*
name|zcs
parameter_list|,
name|ZSTD_outBuffer
modifier|*
name|output
parameter_list|,
name|ZSTD_inBuffer
modifier|*
name|input
parameter_list|)
block|{
name|CHECK_F
argument_list|(
name|ZSTDMT_compressStream_generic
argument_list|(
name|zcs
argument_list|,
name|output
argument_list|,
name|input
argument_list|,
name|ZSTD_e_continue
argument_list|)
argument_list|)
expr_stmt|;
comment|/* recommended next input size : fill current input buffer */
return|return
name|zcs
operator|->
name|inBuffSize
operator|-
name|zcs
operator|->
name|inBuff
operator|.
name|filled
return|;
comment|/* note : could be zero when input buffer is fully filled and no more availability to create new job */
block|}
end_function

begin_function
specifier|static
name|size_t
name|ZSTDMT_flushStream_internal
parameter_list|(
name|ZSTDMT_CCtx
modifier|*
name|zcs
parameter_list|,
name|ZSTD_outBuffer
modifier|*
name|output
parameter_list|,
name|unsigned
name|endFrame
parameter_list|)
block|{
name|size_t
specifier|const
name|srcSize
init|=
name|zcs
operator|->
name|inBuff
operator|.
name|filled
operator|-
name|zcs
operator|->
name|dictSize
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|srcSize
operator|>
literal|0
operator|)
operator|||
operator|(
name|endFrame
operator|&&
operator|!
name|zcs
operator|->
name|frameEnded
operator|)
operator|)
operator|&&
operator|(
name|zcs
operator|->
name|nextJobID
operator|<=
name|zcs
operator|->
name|doneJobID
operator|+
name|zcs
operator|->
name|jobIDMask
operator|)
condition|)
block|{
name|CHECK_F
argument_list|(
name|ZSTDMT_createCompressionJob
argument_list|(
name|zcs
argument_list|,
name|srcSize
argument_list|,
name|endFrame
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* check if there is any data available to flush */
return|return
name|ZSTDMT_flushNextJob
argument_list|(
name|zcs
argument_list|,
name|output
argument_list|,
literal|1
comment|/* blockToFlush */
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTDMT_flushStream
parameter_list|(
name|ZSTDMT_CCtx
modifier|*
name|zcs
parameter_list|,
name|ZSTD_outBuffer
modifier|*
name|output
parameter_list|)
block|{
name|DEBUGLOG
argument_list|(
literal|5
argument_list|,
literal|"ZSTDMT_flushStream"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcs
operator|->
name|nbThreads
operator|==
literal|1
condition|)
return|return
name|ZSTD_flushStream
argument_list|(
name|zcs
operator|->
name|cctxPool
operator|->
name|cctx
index|[
literal|0
index|]
argument_list|,
name|output
argument_list|)
return|;
return|return
name|ZSTDMT_flushStream_internal
argument_list|(
name|zcs
argument_list|,
name|output
argument_list|,
literal|0
comment|/* endFrame */
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|ZSTDMT_endStream
parameter_list|(
name|ZSTDMT_CCtx
modifier|*
name|zcs
parameter_list|,
name|ZSTD_outBuffer
modifier|*
name|output
parameter_list|)
block|{
name|DEBUGLOG
argument_list|(
literal|4
argument_list|,
literal|"ZSTDMT_endStream"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcs
operator|->
name|nbThreads
operator|==
literal|1
condition|)
return|return
name|ZSTD_endStream
argument_list|(
name|zcs
operator|->
name|cctxPool
operator|->
name|cctx
index|[
literal|0
index|]
argument_list|,
name|output
argument_list|)
return|;
return|return
name|ZSTDMT_flushStream_internal
argument_list|(
name|zcs
argument_list|,
name|output
argument_list|,
literal|1
comment|/* endFrame */
argument_list|)
return|;
block|}
end_function

end_unit

