begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ******************************************************************    Huffman encoder, part of New Generation Entropy library    Copyright (C) 2013-2016, Yann Collet.     BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)     Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are    met:         * Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer.        * Redistributions in binary form must reproduce the above    copyright notice, this list of conditions and the following disclaimer    in the documentation and/or other materials provided with the    distribution.     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.      You can contact the author at :     - FSE+HUF source repository : https://github.com/Cyan4973/FiniteStateEntropy     - Public forum : https://groups.google.com/forum/#!forum/lz4c ****************************************************************** */
end_comment

begin_comment
comment|/* ************************************************************** *  Compiler specifics ****************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_comment
comment|/* Visual Studio */
end_comment

begin_pragma
pragma|#
directive|pragma
name|warning
name|(
name|disable
name|:
name|4127
name|)
end_pragma

begin_comment
comment|/* disable: C4127: conditional expression is constant */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ************************************************************** *  Includes ****************************************************************/
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* memcpy, memset */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* printf (debug) */
end_comment

begin_include
include|#
directive|include
file|"bitstream.h"
end_include

begin_define
define|#
directive|define
name|FSE_STATIC_LINKING_ONLY
end_define

begin_comment
comment|/* FSE_optimalTableLog_internal */
end_comment

begin_include
include|#
directive|include
file|"fse.h"
end_include

begin_comment
comment|/* header compression */
end_comment

begin_define
define|#
directive|define
name|HUF_STATIC_LINKING_ONLY
end_define

begin_include
include|#
directive|include
file|"huf.h"
end_include

begin_include
include|#
directive|include
file|"error_private.h"
end_include

begin_comment
comment|/* ************************************************************** *  Error Management ****************************************************************/
end_comment

begin_define
define|#
directive|define
name|HUF_isError
value|ERR_isError
end_define

begin_define
define|#
directive|define
name|HUF_STATIC_ASSERT
parameter_list|(
name|c
parameter_list|)
value|{ enum { HUF_static_assert = 1/(int)(!!(c)) }; }
end_define

begin_comment
comment|/* use only *after* variable declarations */
end_comment

begin_define
define|#
directive|define
name|CHECK_V_F
parameter_list|(
name|e
parameter_list|,
name|f
parameter_list|)
value|size_t const e = f; if (ERR_isError(e)) return e
end_define

begin_define
define|#
directive|define
name|CHECK_F
parameter_list|(
name|f
parameter_list|)
value|{ CHECK_V_F(_var_err__, f); }
end_define

begin_comment
comment|/* ************************************************************** *  Utils ****************************************************************/
end_comment

begin_function
name|unsigned
name|HUF_optimalTableLog
parameter_list|(
name|unsigned
name|maxTableLog
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|)
block|{
return|return
name|FSE_optimalTableLog_internal
argument_list|(
name|maxTableLog
argument_list|,
name|srcSize
argument_list|,
name|maxSymbolValue
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ******************************************************* *  HUF : Huffman block compression *********************************************************/
end_comment

begin_comment
comment|/* HUF_compressWeights() :  * Same as FSE_compress(), but dedicated to huff0's weights compression.  * The use case needs much less stack memory.  * Note : all elements within weightTable are supposed to be<= HUF_TABLELOG_MAX.  */
end_comment

begin_define
define|#
directive|define
name|MAX_FSE_TABLELOG_FOR_HUFF_HEADER
value|6
end_define

begin_function
name|size_t
name|HUF_compressWeights
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|weightTable
parameter_list|,
name|size_t
name|wtSize
parameter_list|)
block|{
name|BYTE
modifier|*
specifier|const
name|ostart
init|=
operator|(
name|BYTE
operator|*
operator|)
name|dst
decl_stmt|;
name|BYTE
modifier|*
name|op
init|=
name|ostart
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|oend
init|=
name|ostart
operator|+
name|dstSize
decl_stmt|;
name|U32
name|maxSymbolValue
init|=
name|HUF_TABLELOG_MAX
decl_stmt|;
name|U32
name|tableLog
init|=
name|MAX_FSE_TABLELOG_FOR_HUFF_HEADER
decl_stmt|;
name|FSE_CTable
name|CTable
index|[
name|FSE_CTABLE_SIZE_U32
argument_list|(
name|MAX_FSE_TABLELOG_FOR_HUFF_HEADER
argument_list|,
name|HUF_TABLELOG_MAX
argument_list|)
index|]
decl_stmt|;
name|BYTE
name|scratchBuffer
index|[
literal|1
operator|<<
name|MAX_FSE_TABLELOG_FOR_HUFF_HEADER
index|]
decl_stmt|;
name|U32
name|count
index|[
name|HUF_TABLELOG_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|S16
name|norm
index|[
name|HUF_TABLELOG_MAX
operator|+
literal|1
index|]
decl_stmt|;
comment|/* init conditions */
if|if
condition|(
name|wtSize
operator|<=
literal|1
condition|)
return|return
literal|0
return|;
comment|/* Not compressible */
comment|/* Scan input and build symbol stats */
block|{
name|CHECK_V_F
argument_list|(
name|maxCount
argument_list|,
name|FSE_count_simple
argument_list|(
name|count
argument_list|,
operator|&
name|maxSymbolValue
argument_list|,
name|weightTable
argument_list|,
name|wtSize
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxCount
operator|==
name|wtSize
condition|)
return|return
literal|1
return|;
comment|/* only a single symbol in src : rle */
if|if
condition|(
name|maxCount
operator|==
literal|1
condition|)
return|return
literal|0
return|;
comment|/* each symbol present maximum once => not compressible */
block|}
name|tableLog
operator|=
name|FSE_optimalTableLog
argument_list|(
name|tableLog
argument_list|,
name|wtSize
argument_list|,
name|maxSymbolValue
argument_list|)
expr_stmt|;
name|CHECK_F
argument_list|(
name|FSE_normalizeCount
argument_list|(
name|norm
argument_list|,
name|tableLog
argument_list|,
name|count
argument_list|,
name|wtSize
argument_list|,
name|maxSymbolValue
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write table description header */
block|{
name|CHECK_V_F
argument_list|(
name|hSize
argument_list|,
name|FSE_writeNCount
argument_list|(
name|op
argument_list|,
name|oend
operator|-
name|op
argument_list|,
name|norm
argument_list|,
name|maxSymbolValue
argument_list|,
name|tableLog
argument_list|)
argument_list|)
expr_stmt|;
name|op
operator|+=
name|hSize
expr_stmt|;
block|}
comment|/* Compress */
name|CHECK_F
argument_list|(
name|FSE_buildCTable_wksp
argument_list|(
name|CTable
argument_list|,
name|norm
argument_list|,
name|maxSymbolValue
argument_list|,
name|tableLog
argument_list|,
name|scratchBuffer
argument_list|,
sizeof|sizeof
argument_list|(
name|scratchBuffer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|CHECK_V_F
argument_list|(
name|cSize
argument_list|,
name|FSE_compress_usingCTable
argument_list|(
name|op
argument_list|,
name|oend
operator|-
name|op
argument_list|,
name|weightTable
argument_list|,
name|wtSize
argument_list|,
name|CTable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cSize
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* not enough space for compressed data */
name|op
operator|+=
name|cSize
expr_stmt|;
block|}
return|return
name|op
operator|-
name|ostart
return|;
block|}
end_function

begin_struct
struct|struct
name|HUF_CElt_s
block|{
name|U16
name|val
decl_stmt|;
name|BYTE
name|nbBits
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* typedef'd to HUF_CElt within "huf.h" */
end_comment

begin_comment
comment|/*! HUF_writeCTable() :     `CTable` : Huffman tree to save, using huf representation.     @return : size of saved CTable */
end_comment

begin_function
name|size_t
name|HUF_writeCTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|HUF_CElt
modifier|*
name|CTable
parameter_list|,
name|U32
name|maxSymbolValue
parameter_list|,
name|U32
name|huffLog
parameter_list|)
block|{
name|BYTE
name|bitsToWeight
index|[
name|HUF_TABLELOG_MAX
operator|+
literal|1
index|]
decl_stmt|;
comment|/* precomputed conversion table */
name|BYTE
name|huffWeight
index|[
name|HUF_SYMBOLVALUE_MAX
index|]
decl_stmt|;
name|BYTE
modifier|*
name|op
init|=
operator|(
name|BYTE
operator|*
operator|)
name|dst
decl_stmt|;
name|U32
name|n
decl_stmt|;
comment|/* check conditions */
if|if
condition|(
name|maxSymbolValue
operator|>
name|HUF_SYMBOLVALUE_MAX
condition|)
return|return
name|ERROR
argument_list|(
name|maxSymbolValue_tooLarge
argument_list|)
return|;
comment|/* convert to weight */
name|bitsToWeight
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|1
init|;
name|n
operator|<
name|huffLog
operator|+
literal|1
condition|;
name|n
operator|++
control|)
name|bitsToWeight
index|[
name|n
index|]
operator|=
call|(
name|BYTE
call|)
argument_list|(
name|huffLog
operator|+
literal|1
operator|-
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|maxSymbolValue
condition|;
name|n
operator|++
control|)
name|huffWeight
index|[
name|n
index|]
operator|=
name|bitsToWeight
index|[
name|CTable
index|[
name|n
index|]
operator|.
name|nbBits
index|]
expr_stmt|;
comment|/* attempt weights compression by FSE */
block|{
name|CHECK_V_F
argument_list|(
name|hSize
argument_list|,
name|HUF_compressWeights
argument_list|(
name|op
operator|+
literal|1
argument_list|,
name|maxDstSize
operator|-
literal|1
argument_list|,
name|huffWeight
argument_list|,
name|maxSymbolValue
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hSize
operator|>
literal|1
operator|)
operator|&
operator|(
name|hSize
operator|<
name|maxSymbolValue
operator|/
literal|2
operator|)
condition|)
block|{
comment|/* FSE compressed */
name|op
index|[
literal|0
index|]
operator|=
operator|(
name|BYTE
operator|)
name|hSize
expr_stmt|;
return|return
name|hSize
operator|+
literal|1
return|;
block|}
block|}
comment|/* write raw values as 4-bits (max : 15) */
if|if
condition|(
name|maxSymbolValue
operator|>
operator|(
literal|256
operator|-
literal|128
operator|)
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
comment|/* should not happen : likely means source cannot be compressed */
if|if
condition|(
operator|(
operator|(
name|maxSymbolValue
operator|+
literal|1
operator|)
operator|/
literal|2
operator|)
operator|+
literal|1
operator|>
name|maxDstSize
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
comment|/* not enough space within dst buffer */
name|op
index|[
literal|0
index|]
operator|=
call|(
name|BYTE
call|)
argument_list|(
literal|128
comment|/*special case*/
operator|+
operator|(
name|maxSymbolValue
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|huffWeight
index|[
name|maxSymbolValue
index|]
operator|=
literal|0
expr_stmt|;
comment|/* to be sure it doesn't cause msan issue in final combination */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|maxSymbolValue
condition|;
name|n
operator|+=
literal|2
control|)
name|op
index|[
operator|(
name|n
operator|/
literal|2
operator|)
operator|+
literal|1
index|]
operator|=
call|(
name|BYTE
call|)
argument_list|(
operator|(
name|huffWeight
index|[
name|n
index|]
operator|<<
literal|4
operator|)
operator|+
name|huffWeight
index|[
name|n
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|maxSymbolValue
operator|+
literal|1
operator|)
operator|/
literal|2
operator|)
operator|+
literal|1
return|;
block|}
end_function

begin_function
name|size_t
name|HUF_readCTable
parameter_list|(
name|HUF_CElt
modifier|*
name|CTable
parameter_list|,
name|U32
name|maxSymbolValue
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
name|BYTE
name|huffWeight
index|[
name|HUF_SYMBOLVALUE_MAX
operator|+
literal|1
index|]
decl_stmt|;
comment|/* init not required, even though some static analyzer may complain */
name|U32
name|rankVal
index|[
name|HUF_TABLELOG_ABSOLUTEMAX
operator|+
literal|1
index|]
decl_stmt|;
comment|/* large enough for values from 0 to 16 */
name|U32
name|tableLog
init|=
literal|0
decl_stmt|;
name|U32
name|nbSymbols
init|=
literal|0
decl_stmt|;
comment|/* get symbol weights */
name|CHECK_V_F
argument_list|(
name|readSize
argument_list|,
name|HUF_readStats
argument_list|(
name|huffWeight
argument_list|,
name|HUF_SYMBOLVALUE_MAX
operator|+
literal|1
argument_list|,
name|rankVal
argument_list|,
operator|&
name|nbSymbols
argument_list|,
operator|&
name|tableLog
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
argument_list|)
expr_stmt|;
comment|/* check result */
if|if
condition|(
name|tableLog
operator|>
name|HUF_TABLELOG_MAX
condition|)
return|return
name|ERROR
argument_list|(
name|tableLog_tooLarge
argument_list|)
return|;
if|if
condition|(
name|nbSymbols
operator|>
name|maxSymbolValue
operator|+
literal|1
condition|)
return|return
name|ERROR
argument_list|(
name|maxSymbolValue_tooSmall
argument_list|)
return|;
comment|/* Prepare base value per rank */
block|{
name|U32
name|n
decl_stmt|,
name|nextRankStart
init|=
literal|0
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|1
init|;
name|n
operator|<=
name|tableLog
condition|;
name|n
operator|++
control|)
block|{
name|U32
name|current
init|=
name|nextRankStart
decl_stmt|;
name|nextRankStart
operator|+=
operator|(
name|rankVal
index|[
name|n
index|]
operator|<<
operator|(
name|n
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|rankVal
index|[
name|n
index|]
operator|=
name|current
expr_stmt|;
block|}
block|}
comment|/* fill nbBits */
block|{
name|U32
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nbSymbols
condition|;
name|n
operator|++
control|)
block|{
specifier|const
name|U32
name|w
init|=
name|huffWeight
index|[
name|n
index|]
decl_stmt|;
name|CTable
index|[
name|n
index|]
operator|.
name|nbBits
operator|=
call|(
name|BYTE
call|)
argument_list|(
name|tableLog
operator|+
literal|1
operator|-
name|w
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* fill val */
block|{
name|U16
name|nbPerRank
index|[
name|HUF_TABLELOG_MAX
operator|+
literal|2
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
comment|/* support w=0=>n=tableLog+1 */
name|U16
name|valPerRank
index|[
name|HUF_TABLELOG_MAX
operator|+
literal|2
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
block|{
name|U32
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nbSymbols
condition|;
name|n
operator|++
control|)
name|nbPerRank
index|[
name|CTable
index|[
name|n
index|]
operator|.
name|nbBits
index|]
operator|++
expr_stmt|;
block|}
comment|/* determine stating value per rank */
name|valPerRank
index|[
name|tableLog
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* for w==0 */
block|{
name|U16
name|min
init|=
literal|0
decl_stmt|;
name|U32
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
name|tableLog
init|;
name|n
operator|>
literal|0
condition|;
name|n
operator|--
control|)
block|{
comment|/* start at n=tablelog<-> w=1 */
name|valPerRank
index|[
name|n
index|]
operator|=
name|min
expr_stmt|;
comment|/* get starting value within each rank */
name|min
operator|+=
name|nbPerRank
index|[
name|n
index|]
expr_stmt|;
name|min
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
comment|/* assign value within rank, symbol order */
block|{
name|U32
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<=
name|maxSymbolValue
condition|;
name|n
operator|++
control|)
name|CTable
index|[
name|n
index|]
operator|.
name|val
operator|=
name|valPerRank
index|[
name|CTable
index|[
name|n
index|]
operator|.
name|nbBits
index|]
operator|++
expr_stmt|;
block|}
block|}
return|return
name|readSize
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|nodeElt_s
block|{
name|U32
name|count
decl_stmt|;
name|U16
name|parent
decl_stmt|;
name|BYTE
name|byte
decl_stmt|;
name|BYTE
name|nbBits
decl_stmt|;
block|}
name|nodeElt
typedef|;
end_typedef

begin_function
specifier|static
name|U32
name|HUF_setMaxHeight
parameter_list|(
name|nodeElt
modifier|*
name|huffNode
parameter_list|,
name|U32
name|lastNonNull
parameter_list|,
name|U32
name|maxNbBits
parameter_list|)
block|{
specifier|const
name|U32
name|largestBits
init|=
name|huffNode
index|[
name|lastNonNull
index|]
operator|.
name|nbBits
decl_stmt|;
if|if
condition|(
name|largestBits
operator|<=
name|maxNbBits
condition|)
return|return
name|largestBits
return|;
comment|/* early exit : no elt> maxNbBits */
comment|/* there are several too large elements (at least>= 2) */
block|{
name|int
name|totalCost
init|=
literal|0
decl_stmt|;
specifier|const
name|U32
name|baseCost
init|=
literal|1
operator|<<
operator|(
name|largestBits
operator|-
name|maxNbBits
operator|)
decl_stmt|;
name|U32
name|n
init|=
name|lastNonNull
decl_stmt|;
while|while
condition|(
name|huffNode
index|[
name|n
index|]
operator|.
name|nbBits
operator|>
name|maxNbBits
condition|)
block|{
name|totalCost
operator|+=
name|baseCost
operator|-
operator|(
literal|1
operator|<<
operator|(
name|largestBits
operator|-
name|huffNode
index|[
name|n
index|]
operator|.
name|nbBits
operator|)
operator|)
expr_stmt|;
name|huffNode
index|[
name|n
index|]
operator|.
name|nbBits
operator|=
operator|(
name|BYTE
operator|)
name|maxNbBits
expr_stmt|;
name|n
operator|--
expr_stmt|;
block|}
comment|/* n stops at huffNode[n].nbBits<= maxNbBits */
while|while
condition|(
name|huffNode
index|[
name|n
index|]
operator|.
name|nbBits
operator|==
name|maxNbBits
condition|)
name|n
operator|--
expr_stmt|;
comment|/* n end at index of smallest symbol using< maxNbBits */
comment|/* renorm totalCost */
name|totalCost
operator|>>=
operator|(
name|largestBits
operator|-
name|maxNbBits
operator|)
expr_stmt|;
comment|/* note : totalCost is necessarily a multiple of baseCost */
comment|/* repay normalized cost */
block|{
name|U32
specifier|const
name|noSymbol
init|=
literal|0xF0F0F0F0
decl_stmt|;
name|U32
name|rankLast
index|[
name|HUF_TABLELOG_MAX
operator|+
literal|2
index|]
decl_stmt|;
name|int
name|pos
decl_stmt|;
comment|/* Get pos of last (smallest) symbol per rank */
name|memset
argument_list|(
name|rankLast
argument_list|,
literal|0xF0
argument_list|,
sizeof|sizeof
argument_list|(
name|rankLast
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|U32
name|currentNbBits
init|=
name|maxNbBits
decl_stmt|;
for|for
control|(
name|pos
operator|=
name|n
init|;
name|pos
operator|>=
literal|0
condition|;
name|pos
operator|--
control|)
block|{
if|if
condition|(
name|huffNode
index|[
name|pos
index|]
operator|.
name|nbBits
operator|>=
name|currentNbBits
condition|)
continue|continue;
name|currentNbBits
operator|=
name|huffNode
index|[
name|pos
index|]
operator|.
name|nbBits
expr_stmt|;
comment|/*< maxNbBits */
name|rankLast
index|[
name|maxNbBits
operator|-
name|currentNbBits
index|]
operator|=
name|pos
expr_stmt|;
block|}
block|}
while|while
condition|(
name|totalCost
operator|>
literal|0
condition|)
block|{
name|U32
name|nBitsToDecrease
init|=
name|BIT_highbit32
argument_list|(
name|totalCost
argument_list|)
operator|+
literal|1
decl_stmt|;
for|for
control|(
init|;
name|nBitsToDecrease
operator|>
literal|1
condition|;
name|nBitsToDecrease
operator|--
control|)
block|{
name|U32
name|highPos
init|=
name|rankLast
index|[
name|nBitsToDecrease
index|]
decl_stmt|;
name|U32
name|lowPos
init|=
name|rankLast
index|[
name|nBitsToDecrease
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|highPos
operator|==
name|noSymbol
condition|)
continue|continue;
if|if
condition|(
name|lowPos
operator|==
name|noSymbol
condition|)
break|break;
block|{
name|U32
specifier|const
name|highTotal
init|=
name|huffNode
index|[
name|highPos
index|]
operator|.
name|count
decl_stmt|;
name|U32
specifier|const
name|lowTotal
init|=
literal|2
operator|*
name|huffNode
index|[
name|lowPos
index|]
operator|.
name|count
decl_stmt|;
if|if
condition|(
name|highTotal
operator|<=
name|lowTotal
condition|)
break|break;
block|}
block|}
comment|/* only triggered when no more rank 1 symbol left => find closest one (note : there is necessarily at least one !) */
comment|/* HUF_MAX_TABLELOG test just to please gcc 5+; but it should not be necessary */
while|while
condition|(
operator|(
name|nBitsToDecrease
operator|<=
name|HUF_TABLELOG_MAX
operator|)
operator|&&
operator|(
name|rankLast
index|[
name|nBitsToDecrease
index|]
operator|==
name|noSymbol
operator|)
condition|)
name|nBitsToDecrease
operator|++
expr_stmt|;
name|totalCost
operator|-=
literal|1
operator|<<
operator|(
name|nBitsToDecrease
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|rankLast
index|[
name|nBitsToDecrease
operator|-
literal|1
index|]
operator|==
name|noSymbol
condition|)
name|rankLast
index|[
name|nBitsToDecrease
operator|-
literal|1
index|]
operator|=
name|rankLast
index|[
name|nBitsToDecrease
index|]
expr_stmt|;
comment|/* this rank is no longer empty */
name|huffNode
index|[
name|rankLast
index|[
name|nBitsToDecrease
index|]
index|]
operator|.
name|nbBits
operator|++
expr_stmt|;
if|if
condition|(
name|rankLast
index|[
name|nBitsToDecrease
index|]
operator|==
literal|0
condition|)
comment|/* special case, reached largest symbol */
name|rankLast
index|[
name|nBitsToDecrease
index|]
operator|=
name|noSymbol
expr_stmt|;
else|else
block|{
name|rankLast
index|[
name|nBitsToDecrease
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|huffNode
index|[
name|rankLast
index|[
name|nBitsToDecrease
index|]
index|]
operator|.
name|nbBits
operator|!=
name|maxNbBits
operator|-
name|nBitsToDecrease
condition|)
name|rankLast
index|[
name|nBitsToDecrease
index|]
operator|=
name|noSymbol
expr_stmt|;
comment|/* this rank is now empty */
block|}
block|}
comment|/* while (totalCost> 0) */
while|while
condition|(
name|totalCost
operator|<
literal|0
condition|)
block|{
comment|/* Sometimes, cost correction overshoot */
if|if
condition|(
name|rankLast
index|[
literal|1
index|]
operator|==
name|noSymbol
condition|)
block|{
comment|/* special case : no rank 1 symbol (using maxNbBits-1); let's create one from largest rank 0 (using maxNbBits) */
while|while
condition|(
name|huffNode
index|[
name|n
index|]
operator|.
name|nbBits
operator|==
name|maxNbBits
condition|)
name|n
operator|--
expr_stmt|;
name|huffNode
index|[
name|n
operator|+
literal|1
index|]
operator|.
name|nbBits
operator|--
expr_stmt|;
name|rankLast
index|[
literal|1
index|]
operator|=
name|n
operator|+
literal|1
expr_stmt|;
name|totalCost
operator|++
expr_stmt|;
continue|continue;
block|}
name|huffNode
index|[
name|rankLast
index|[
literal|1
index|]
operator|+
literal|1
index|]
operator|.
name|nbBits
operator|--
expr_stmt|;
name|rankLast
index|[
literal|1
index|]
operator|++
expr_stmt|;
name|totalCost
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* there are several too large elements (at least>= 2) */
return|return
name|maxNbBits
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
block|{
name|U32
name|base
decl_stmt|;
name|U32
name|current
decl_stmt|;
block|}
name|rankPos
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|HUF_sort
parameter_list|(
name|nodeElt
modifier|*
name|huffNode
parameter_list|,
specifier|const
name|U32
modifier|*
name|count
parameter_list|,
name|U32
name|maxSymbolValue
parameter_list|)
block|{
name|rankPos
name|rank
index|[
literal|32
index|]
decl_stmt|;
name|U32
name|n
decl_stmt|;
name|memset
argument_list|(
name|rank
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rank
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<=
name|maxSymbolValue
condition|;
name|n
operator|++
control|)
block|{
name|U32
name|r
init|=
name|BIT_highbit32
argument_list|(
name|count
index|[
name|n
index|]
operator|+
literal|1
argument_list|)
decl_stmt|;
name|rank
index|[
name|r
index|]
operator|.
name|base
operator|++
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
literal|30
init|;
name|n
operator|>
literal|0
condition|;
name|n
operator|--
control|)
name|rank
index|[
name|n
operator|-
literal|1
index|]
operator|.
name|base
operator|+=
name|rank
index|[
name|n
index|]
operator|.
name|base
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|32
condition|;
name|n
operator|++
control|)
name|rank
index|[
name|n
index|]
operator|.
name|current
operator|=
name|rank
index|[
name|n
index|]
operator|.
name|base
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<=
name|maxSymbolValue
condition|;
name|n
operator|++
control|)
block|{
name|U32
specifier|const
name|c
init|=
name|count
index|[
name|n
index|]
decl_stmt|;
name|U32
specifier|const
name|r
init|=
name|BIT_highbit32
argument_list|(
name|c
operator|+
literal|1
argument_list|)
operator|+
literal|1
decl_stmt|;
name|U32
name|pos
init|=
name|rank
index|[
name|r
index|]
operator|.
name|current
operator|++
decl_stmt|;
while|while
condition|(
operator|(
name|pos
operator|>
name|rank
index|[
name|r
index|]
operator|.
name|base
operator|)
operator|&&
operator|(
name|c
operator|>
name|huffNode
index|[
name|pos
operator|-
literal|1
index|]
operator|.
name|count
operator|)
condition|)
name|huffNode
index|[
name|pos
index|]
operator|=
name|huffNode
index|[
name|pos
operator|-
literal|1
index|]
operator|,
name|pos
operator|--
expr_stmt|;
name|huffNode
index|[
name|pos
index|]
operator|.
name|count
operator|=
name|c
expr_stmt|;
name|huffNode
index|[
name|pos
index|]
operator|.
name|byte
operator|=
operator|(
name|BYTE
operator|)
name|n
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/** HUF_buildCTable_wksp() :  *  Same as HUF_buildCTable(), but using externally allocated scratch buffer.  *  `workSpace` must be aligned on 4-bytes boundaries, and be at least as large as a table of 1024 unsigned.  */
end_comment

begin_define
define|#
directive|define
name|STARTNODE
value|(HUF_SYMBOLVALUE_MAX+1)
end_define

begin_typedef
typedef|typedef
name|nodeElt
name|huffNodeTable
index|[
literal|2
operator|*
name|HUF_SYMBOLVALUE_MAX
operator|+
literal|1
operator|+
literal|1
index|]
typedef|;
end_typedef

begin_function
name|size_t
name|HUF_buildCTable_wksp
parameter_list|(
name|HUF_CElt
modifier|*
name|tree
parameter_list|,
specifier|const
name|U32
modifier|*
name|count
parameter_list|,
name|U32
name|maxSymbolValue
parameter_list|,
name|U32
name|maxNbBits
parameter_list|,
name|void
modifier|*
name|workSpace
parameter_list|,
name|size_t
name|wkspSize
parameter_list|)
block|{
name|nodeElt
modifier|*
specifier|const
name|huffNode0
init|=
operator|(
name|nodeElt
operator|*
operator|)
name|workSpace
decl_stmt|;
name|nodeElt
modifier|*
specifier|const
name|huffNode
init|=
name|huffNode0
operator|+
literal|1
decl_stmt|;
name|U32
name|n
decl_stmt|,
name|nonNullRank
decl_stmt|;
name|int
name|lowS
decl_stmt|,
name|lowN
decl_stmt|;
name|U16
name|nodeNb
init|=
name|STARTNODE
decl_stmt|;
name|U32
name|nodeRoot
decl_stmt|;
comment|/* safety checks */
if|if
condition|(
name|wkspSize
operator|<
sizeof|sizeof
argument_list|(
name|huffNodeTable
argument_list|)
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
comment|/* workSpace is not large enough */
if|if
condition|(
name|maxNbBits
operator|==
literal|0
condition|)
name|maxNbBits
operator|=
name|HUF_TABLELOG_DEFAULT
expr_stmt|;
if|if
condition|(
name|maxSymbolValue
operator|>
name|HUF_SYMBOLVALUE_MAX
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
name|memset
argument_list|(
name|huffNode0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|huffNodeTable
argument_list|)
argument_list|)
expr_stmt|;
comment|/* sort, decreasing order */
name|HUF_sort
argument_list|(
name|huffNode
argument_list|,
name|count
argument_list|,
name|maxSymbolValue
argument_list|)
expr_stmt|;
comment|/* init for parents */
name|nonNullRank
operator|=
name|maxSymbolValue
expr_stmt|;
while|while
condition|(
name|huffNode
index|[
name|nonNullRank
index|]
operator|.
name|count
operator|==
literal|0
condition|)
name|nonNullRank
operator|--
expr_stmt|;
name|lowS
operator|=
name|nonNullRank
expr_stmt|;
name|nodeRoot
operator|=
name|nodeNb
operator|+
name|lowS
operator|-
literal|1
expr_stmt|;
name|lowN
operator|=
name|nodeNb
expr_stmt|;
name|huffNode
index|[
name|nodeNb
index|]
operator|.
name|count
operator|=
name|huffNode
index|[
name|lowS
index|]
operator|.
name|count
operator|+
name|huffNode
index|[
name|lowS
operator|-
literal|1
index|]
operator|.
name|count
expr_stmt|;
name|huffNode
index|[
name|lowS
index|]
operator|.
name|parent
operator|=
name|huffNode
index|[
name|lowS
operator|-
literal|1
index|]
operator|.
name|parent
operator|=
name|nodeNb
expr_stmt|;
name|nodeNb
operator|++
expr_stmt|;
name|lowS
operator|-=
literal|2
expr_stmt|;
for|for
control|(
name|n
operator|=
name|nodeNb
init|;
name|n
operator|<=
name|nodeRoot
condition|;
name|n
operator|++
control|)
name|huffNode
index|[
name|n
index|]
operator|.
name|count
operator|=
call|(
name|U32
call|)
argument_list|(
literal|1U
operator|<<
literal|30
argument_list|)
expr_stmt|;
name|huffNode0
index|[
literal|0
index|]
operator|.
name|count
operator|=
call|(
name|U32
call|)
argument_list|(
literal|1U
operator|<<
literal|31
argument_list|)
expr_stmt|;
comment|/* fake entry, strong barrier */
comment|/* create parents */
while|while
condition|(
name|nodeNb
operator|<=
name|nodeRoot
condition|)
block|{
name|U32
name|n1
init|=
operator|(
name|huffNode
index|[
name|lowS
index|]
operator|.
name|count
operator|<
name|huffNode
index|[
name|lowN
index|]
operator|.
name|count
operator|)
condition|?
name|lowS
operator|--
else|:
name|lowN
operator|++
decl_stmt|;
name|U32
name|n2
init|=
operator|(
name|huffNode
index|[
name|lowS
index|]
operator|.
name|count
operator|<
name|huffNode
index|[
name|lowN
index|]
operator|.
name|count
operator|)
condition|?
name|lowS
operator|--
else|:
name|lowN
operator|++
decl_stmt|;
name|huffNode
index|[
name|nodeNb
index|]
operator|.
name|count
operator|=
name|huffNode
index|[
name|n1
index|]
operator|.
name|count
operator|+
name|huffNode
index|[
name|n2
index|]
operator|.
name|count
expr_stmt|;
name|huffNode
index|[
name|n1
index|]
operator|.
name|parent
operator|=
name|huffNode
index|[
name|n2
index|]
operator|.
name|parent
operator|=
name|nodeNb
expr_stmt|;
name|nodeNb
operator|++
expr_stmt|;
block|}
comment|/* distribute weights (unlimited tree height) */
name|huffNode
index|[
name|nodeRoot
index|]
operator|.
name|nbBits
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
name|nodeRoot
operator|-
literal|1
init|;
name|n
operator|>=
name|STARTNODE
condition|;
name|n
operator|--
control|)
name|huffNode
index|[
name|n
index|]
operator|.
name|nbBits
operator|=
name|huffNode
index|[
name|huffNode
index|[
name|n
index|]
operator|.
name|parent
index|]
operator|.
name|nbBits
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<=
name|nonNullRank
condition|;
name|n
operator|++
control|)
name|huffNode
index|[
name|n
index|]
operator|.
name|nbBits
operator|=
name|huffNode
index|[
name|huffNode
index|[
name|n
index|]
operator|.
name|parent
index|]
operator|.
name|nbBits
operator|+
literal|1
expr_stmt|;
comment|/* enforce maxTableLog */
name|maxNbBits
operator|=
name|HUF_setMaxHeight
argument_list|(
name|huffNode
argument_list|,
name|nonNullRank
argument_list|,
name|maxNbBits
argument_list|)
expr_stmt|;
comment|/* fill result into tree (val, nbBits) */
block|{
name|U16
name|nbPerRank
index|[
name|HUF_TABLELOG_MAX
operator|+
literal|1
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|U16
name|valPerRank
index|[
name|HUF_TABLELOG_MAX
operator|+
literal|1
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
if|if
condition|(
name|maxNbBits
operator|>
name|HUF_TABLELOG_MAX
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
comment|/* check fit into table */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<=
name|nonNullRank
condition|;
name|n
operator|++
control|)
name|nbPerRank
index|[
name|huffNode
index|[
name|n
index|]
operator|.
name|nbBits
index|]
operator|++
expr_stmt|;
comment|/* determine stating value per rank */
block|{
name|U16
name|min
init|=
literal|0
decl_stmt|;
for|for
control|(
name|n
operator|=
name|maxNbBits
init|;
name|n
operator|>
literal|0
condition|;
name|n
operator|--
control|)
block|{
name|valPerRank
index|[
name|n
index|]
operator|=
name|min
expr_stmt|;
comment|/* get starting value within each rank */
name|min
operator|+=
name|nbPerRank
index|[
name|n
index|]
expr_stmt|;
name|min
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<=
name|maxSymbolValue
condition|;
name|n
operator|++
control|)
name|tree
index|[
name|huffNode
index|[
name|n
index|]
operator|.
name|byte
index|]
operator|.
name|nbBits
operator|=
name|huffNode
index|[
name|n
index|]
operator|.
name|nbBits
expr_stmt|;
comment|/* push nbBits per symbol, symbol order */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<=
name|maxSymbolValue
condition|;
name|n
operator|++
control|)
name|tree
index|[
name|n
index|]
operator|.
name|val
operator|=
name|valPerRank
index|[
name|tree
index|[
name|n
index|]
operator|.
name|nbBits
index|]
operator|++
expr_stmt|;
comment|/* assign value within rank, symbol order */
block|}
return|return
name|maxNbBits
return|;
block|}
end_function

begin_comment
comment|/** HUF_buildCTable() :  *  Note : count is used before tree is written, so they can safely overlap  */
end_comment

begin_function
name|size_t
name|HUF_buildCTable
parameter_list|(
name|HUF_CElt
modifier|*
name|tree
parameter_list|,
specifier|const
name|U32
modifier|*
name|count
parameter_list|,
name|U32
name|maxSymbolValue
parameter_list|,
name|U32
name|maxNbBits
parameter_list|)
block|{
name|huffNodeTable
name|nodeTable
decl_stmt|;
return|return
name|HUF_buildCTable_wksp
argument_list|(
name|tree
argument_list|,
name|count
argument_list|,
name|maxSymbolValue
argument_list|,
name|maxNbBits
argument_list|,
name|nodeTable
argument_list|,
sizeof|sizeof
argument_list|(
name|nodeTable
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|HUF_estimateCompressedSize
parameter_list|(
name|HUF_CElt
modifier|*
name|CTable
parameter_list|,
specifier|const
name|unsigned
modifier|*
name|count
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|)
block|{
name|size_t
name|nbBits
init|=
literal|0
decl_stmt|;
name|int
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<=
operator|(
name|int
operator|)
name|maxSymbolValue
condition|;
operator|++
name|s
control|)
block|{
name|nbBits
operator|+=
name|CTable
index|[
name|s
index|]
operator|.
name|nbBits
operator|*
name|count
index|[
name|s
index|]
expr_stmt|;
block|}
return|return
name|nbBits
operator|>>
literal|3
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|HUF_validateCTable
parameter_list|(
specifier|const
name|HUF_CElt
modifier|*
name|CTable
parameter_list|,
specifier|const
name|unsigned
modifier|*
name|count
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|)
block|{
name|int
name|bad
init|=
literal|0
decl_stmt|;
name|int
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<=
operator|(
name|int
operator|)
name|maxSymbolValue
condition|;
operator|++
name|s
control|)
block|{
name|bad
operator||=
operator|(
name|count
index|[
name|s
index|]
operator|!=
literal|0
operator|)
operator|&
operator|(
name|CTable
index|[
name|s
index|]
operator|.
name|nbBits
operator|==
literal|0
operator|)
expr_stmt|;
block|}
return|return
operator|!
name|bad
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|HUF_encodeSymbol
parameter_list|(
name|BIT_CStream_t
modifier|*
name|bitCPtr
parameter_list|,
name|U32
name|symbol
parameter_list|,
specifier|const
name|HUF_CElt
modifier|*
name|CTable
parameter_list|)
block|{
name|BIT_addBitsFast
argument_list|(
name|bitCPtr
argument_list|,
name|CTable
index|[
name|symbol
index|]
operator|.
name|val
argument_list|,
name|CTable
index|[
name|symbol
index|]
operator|.
name|nbBits
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|size_t
name|HUF_compressBound
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
return|return
name|HUF_COMPRESSBOUND
argument_list|(
name|size
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|HUF_FLUSHBITS
parameter_list|(
name|s
parameter_list|)
value|BIT_flushBits(s)
end_define

begin_define
define|#
directive|define
name|HUF_FLUSHBITS_1
parameter_list|(
name|stream
parameter_list|)
define|\
value|if (sizeof((stream)->bitContainer)*8< HUF_TABLELOG_MAX*2+7) HUF_FLUSHBITS(stream)
end_define

begin_define
define|#
directive|define
name|HUF_FLUSHBITS_2
parameter_list|(
name|stream
parameter_list|)
define|\
value|if (sizeof((stream)->bitContainer)*8< HUF_TABLELOG_MAX*4+7) HUF_FLUSHBITS(stream)
end_define

begin_function
name|size_t
name|HUF_compress1X_usingCTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
specifier|const
name|HUF_CElt
modifier|*
name|CTable
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|ostart
init|=
operator|(
name|BYTE
operator|*
operator|)
name|dst
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|oend
init|=
name|ostart
operator|+
name|dstSize
decl_stmt|;
name|BYTE
modifier|*
name|op
init|=
name|ostart
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|BIT_CStream_t
name|bitC
decl_stmt|;
comment|/* init */
if|if
condition|(
name|dstSize
operator|<
literal|8
condition|)
return|return
literal|0
return|;
comment|/* not enough space to compress */
block|{
name|size_t
specifier|const
name|initErr
init|=
name|BIT_initCStream
argument_list|(
operator|&
name|bitC
argument_list|,
name|op
argument_list|,
name|oend
operator|-
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|HUF_isError
argument_list|(
name|initErr
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
name|n
operator|=
name|srcSize
operator|&
operator|~
literal|3
expr_stmt|;
comment|/* join to mod 4 */
switch|switch
condition|(
name|srcSize
operator|&
literal|3
condition|)
block|{
case|case
literal|3
case|:
name|HUF_encodeSymbol
argument_list|(
operator|&
name|bitC
argument_list|,
name|ip
index|[
name|n
operator|+
literal|2
index|]
argument_list|,
name|CTable
argument_list|)
expr_stmt|;
name|HUF_FLUSHBITS_2
argument_list|(
operator|&
name|bitC
argument_list|)
expr_stmt|;
comment|/* fall-through */
case|case
literal|2
case|:
name|HUF_encodeSymbol
argument_list|(
operator|&
name|bitC
argument_list|,
name|ip
index|[
name|n
operator|+
literal|1
index|]
argument_list|,
name|CTable
argument_list|)
expr_stmt|;
name|HUF_FLUSHBITS_1
argument_list|(
operator|&
name|bitC
argument_list|)
expr_stmt|;
comment|/* fall-through */
case|case
literal|1
case|:
name|HUF_encodeSymbol
argument_list|(
operator|&
name|bitC
argument_list|,
name|ip
index|[
name|n
operator|+
literal|0
index|]
argument_list|,
name|CTable
argument_list|)
expr_stmt|;
name|HUF_FLUSHBITS
argument_list|(
operator|&
name|bitC
argument_list|)
expr_stmt|;
comment|/* fall-through */
case|case
literal|0
case|:
comment|/* fall-through */
default|default:
break|break;
block|}
for|for
control|(
init|;
name|n
operator|>
literal|0
condition|;
name|n
operator|-=
literal|4
control|)
block|{
comment|/* note : n&3==0 at this stage */
name|HUF_encodeSymbol
argument_list|(
operator|&
name|bitC
argument_list|,
name|ip
index|[
name|n
operator|-
literal|1
index|]
argument_list|,
name|CTable
argument_list|)
expr_stmt|;
name|HUF_FLUSHBITS_1
argument_list|(
operator|&
name|bitC
argument_list|)
expr_stmt|;
name|HUF_encodeSymbol
argument_list|(
operator|&
name|bitC
argument_list|,
name|ip
index|[
name|n
operator|-
literal|2
index|]
argument_list|,
name|CTable
argument_list|)
expr_stmt|;
name|HUF_FLUSHBITS_2
argument_list|(
operator|&
name|bitC
argument_list|)
expr_stmt|;
name|HUF_encodeSymbol
argument_list|(
operator|&
name|bitC
argument_list|,
name|ip
index|[
name|n
operator|-
literal|3
index|]
argument_list|,
name|CTable
argument_list|)
expr_stmt|;
name|HUF_FLUSHBITS_1
argument_list|(
operator|&
name|bitC
argument_list|)
expr_stmt|;
name|HUF_encodeSymbol
argument_list|(
operator|&
name|bitC
argument_list|,
name|ip
index|[
name|n
operator|-
literal|4
index|]
argument_list|,
name|CTable
argument_list|)
expr_stmt|;
name|HUF_FLUSHBITS
argument_list|(
operator|&
name|bitC
argument_list|)
expr_stmt|;
block|}
return|return
name|BIT_closeCStream
argument_list|(
operator|&
name|bitC
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|HUF_compress4X_usingCTable
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
specifier|const
name|HUF_CElt
modifier|*
name|CTable
parameter_list|)
block|{
name|size_t
specifier|const
name|segmentSize
init|=
operator|(
name|srcSize
operator|+
literal|3
operator|)
operator|/
literal|4
decl_stmt|;
comment|/* first 3 segments */
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|iend
init|=
name|ip
operator|+
name|srcSize
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|ostart
init|=
operator|(
name|BYTE
operator|*
operator|)
name|dst
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|oend
init|=
name|ostart
operator|+
name|dstSize
decl_stmt|;
name|BYTE
modifier|*
name|op
init|=
name|ostart
decl_stmt|;
if|if
condition|(
name|dstSize
operator|<
literal|6
operator|+
literal|1
operator|+
literal|1
operator|+
literal|1
operator|+
literal|8
condition|)
return|return
literal|0
return|;
comment|/* minimum space to compress successfully */
if|if
condition|(
name|srcSize
operator|<
literal|12
condition|)
return|return
literal|0
return|;
comment|/* no saving possible : too small input */
name|op
operator|+=
literal|6
expr_stmt|;
comment|/* jumpTable */
block|{
name|CHECK_V_F
argument_list|(
name|cSize
argument_list|,
name|HUF_compress1X_usingCTable
argument_list|(
name|op
argument_list|,
name|oend
operator|-
name|op
argument_list|,
name|ip
argument_list|,
name|segmentSize
argument_list|,
name|CTable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cSize
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|MEM_writeLE16
argument_list|(
name|ostart
argument_list|,
operator|(
name|U16
operator|)
name|cSize
argument_list|)
expr_stmt|;
name|op
operator|+=
name|cSize
expr_stmt|;
block|}
name|ip
operator|+=
name|segmentSize
expr_stmt|;
block|{
name|CHECK_V_F
argument_list|(
name|cSize
argument_list|,
name|HUF_compress1X_usingCTable
argument_list|(
name|op
argument_list|,
name|oend
operator|-
name|op
argument_list|,
name|ip
argument_list|,
name|segmentSize
argument_list|,
name|CTable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cSize
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|MEM_writeLE16
argument_list|(
name|ostart
operator|+
literal|2
argument_list|,
operator|(
name|U16
operator|)
name|cSize
argument_list|)
expr_stmt|;
name|op
operator|+=
name|cSize
expr_stmt|;
block|}
name|ip
operator|+=
name|segmentSize
expr_stmt|;
block|{
name|CHECK_V_F
argument_list|(
name|cSize
argument_list|,
name|HUF_compress1X_usingCTable
argument_list|(
name|op
argument_list|,
name|oend
operator|-
name|op
argument_list|,
name|ip
argument_list|,
name|segmentSize
argument_list|,
name|CTable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cSize
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|MEM_writeLE16
argument_list|(
name|ostart
operator|+
literal|4
argument_list|,
operator|(
name|U16
operator|)
name|cSize
argument_list|)
expr_stmt|;
name|op
operator|+=
name|cSize
expr_stmt|;
block|}
name|ip
operator|+=
name|segmentSize
expr_stmt|;
block|{
name|CHECK_V_F
argument_list|(
name|cSize
argument_list|,
name|HUF_compress1X_usingCTable
argument_list|(
name|op
argument_list|,
name|oend
operator|-
name|op
argument_list|,
name|ip
argument_list|,
name|iend
operator|-
name|ip
argument_list|,
name|CTable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cSize
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|op
operator|+=
name|cSize
expr_stmt|;
block|}
return|return
name|op
operator|-
name|ostart
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|HUF_compressCTable_internal
parameter_list|(
name|BYTE
modifier|*
specifier|const
name|ostart
parameter_list|,
name|BYTE
modifier|*
name|op
parameter_list|,
name|BYTE
modifier|*
specifier|const
name|oend
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|unsigned
name|singleStream
parameter_list|,
specifier|const
name|HUF_CElt
modifier|*
name|CTable
parameter_list|)
block|{
name|size_t
specifier|const
name|cSize
init|=
name|singleStream
condition|?
name|HUF_compress1X_usingCTable
argument_list|(
name|op
argument_list|,
name|oend
operator|-
name|op
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
name|CTable
argument_list|)
else|:
name|HUF_compress4X_usingCTable
argument_list|(
name|op
argument_list|,
name|oend
operator|-
name|op
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
name|CTable
argument_list|)
decl_stmt|;
if|if
condition|(
name|HUF_isError
argument_list|(
name|cSize
argument_list|)
condition|)
block|{
return|return
name|cSize
return|;
block|}
if|if
condition|(
name|cSize
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* uncompressible */
name|op
operator|+=
name|cSize
expr_stmt|;
comment|/* check compressibility */
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|op
operator|-
name|ostart
argument_list|)
operator|>=
name|srcSize
operator|-
literal|1
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|op
operator|-
name|ostart
return|;
block|}
end_function

begin_comment
comment|/* `workSpace` must a table of at least 1024 unsigned */
end_comment

begin_function
specifier|static
name|size_t
name|HUF_compress_internal
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|,
name|unsigned
name|huffLog
parameter_list|,
name|unsigned
name|singleStream
parameter_list|,
name|void
modifier|*
name|workSpace
parameter_list|,
name|size_t
name|wkspSize
parameter_list|,
name|HUF_CElt
modifier|*
name|oldHufTable
parameter_list|,
name|HUF_repeat
modifier|*
name|repeat
parameter_list|,
name|int
name|preferRepeat
parameter_list|)
block|{
name|BYTE
modifier|*
specifier|const
name|ostart
init|=
operator|(
name|BYTE
operator|*
operator|)
name|dst
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|oend
init|=
name|ostart
operator|+
name|dstSize
decl_stmt|;
name|BYTE
modifier|*
name|op
init|=
name|ostart
decl_stmt|;
name|U32
modifier|*
name|count
decl_stmt|;
name|size_t
specifier|const
name|countSize
init|=
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
operator|*
operator|(
name|HUF_SYMBOLVALUE_MAX
operator|+
literal|1
operator|)
decl_stmt|;
name|HUF_CElt
modifier|*
name|CTable
decl_stmt|;
name|size_t
specifier|const
name|CTableSize
init|=
sizeof|sizeof
argument_list|(
name|HUF_CElt
argument_list|)
operator|*
operator|(
name|HUF_SYMBOLVALUE_MAX
operator|+
literal|1
operator|)
decl_stmt|;
comment|/* checks& inits */
if|if
condition|(
name|wkspSize
operator|<
sizeof|sizeof
argument_list|(
name|huffNodeTable
argument_list|)
operator|+
name|countSize
operator|+
name|CTableSize
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
if|if
condition|(
operator|!
name|srcSize
condition|)
return|return
literal|0
return|;
comment|/* Uncompressed (note : 1 means rle, so first byte must be correct) */
if|if
condition|(
operator|!
name|dstSize
condition|)
return|return
literal|0
return|;
comment|/* cannot fit within dst budget */
if|if
condition|(
name|srcSize
operator|>
name|HUF_BLOCKSIZE_MAX
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
comment|/* current block size limit */
if|if
condition|(
name|huffLog
operator|>
name|HUF_TABLELOG_MAX
condition|)
return|return
name|ERROR
argument_list|(
name|tableLog_tooLarge
argument_list|)
return|;
if|if
condition|(
operator|!
name|maxSymbolValue
condition|)
name|maxSymbolValue
operator|=
name|HUF_SYMBOLVALUE_MAX
expr_stmt|;
if|if
condition|(
operator|!
name|huffLog
condition|)
name|huffLog
operator|=
name|HUF_TABLELOG_DEFAULT
expr_stmt|;
name|count
operator|=
operator|(
name|U32
operator|*
operator|)
name|workSpace
expr_stmt|;
name|workSpace
operator|=
operator|(
name|BYTE
operator|*
operator|)
name|workSpace
operator|+
name|countSize
expr_stmt|;
name|wkspSize
operator|-=
name|countSize
expr_stmt|;
name|CTable
operator|=
operator|(
name|HUF_CElt
operator|*
operator|)
name|workSpace
expr_stmt|;
name|workSpace
operator|=
operator|(
name|BYTE
operator|*
operator|)
name|workSpace
operator|+
name|CTableSize
expr_stmt|;
name|wkspSize
operator|-=
name|CTableSize
expr_stmt|;
comment|/* Heuristic : If we don't need to check the validity of the old table use the old table for small inputs */
if|if
condition|(
name|preferRepeat
operator|&&
name|repeat
operator|&&
operator|*
name|repeat
operator|==
name|HUF_repeat_valid
condition|)
block|{
return|return
name|HUF_compressCTable_internal
argument_list|(
name|ostart
argument_list|,
name|op
argument_list|,
name|oend
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
name|singleStream
argument_list|,
name|oldHufTable
argument_list|)
return|;
block|}
comment|/* Scan input and build symbol stats */
block|{
name|CHECK_V_F
argument_list|(
name|largest
argument_list|,
name|FSE_count_wksp
argument_list|(
name|count
argument_list|,
operator|&
name|maxSymbolValue
argument_list|,
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
argument_list|,
name|srcSize
argument_list|,
operator|(
name|U32
operator|*
operator|)
name|workSpace
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|largest
operator|==
name|srcSize
condition|)
block|{
operator|*
name|ostart
operator|=
operator|(
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
operator|)
index|[
literal|0
index|]
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* single symbol, rle */
if|if
condition|(
name|largest
operator|<=
operator|(
name|srcSize
operator|>>
literal|7
operator|)
operator|+
literal|1
condition|)
return|return
literal|0
return|;
comment|/* Fast heuristic : not compressible enough */
block|}
comment|/* Check validity of previous table */
if|if
condition|(
name|repeat
operator|&&
operator|*
name|repeat
operator|==
name|HUF_repeat_check
operator|&&
operator|!
name|HUF_validateCTable
argument_list|(
name|oldHufTable
argument_list|,
name|count
argument_list|,
name|maxSymbolValue
argument_list|)
condition|)
block|{
operator|*
name|repeat
operator|=
name|HUF_repeat_none
expr_stmt|;
block|}
comment|/* Heuristic : use existing table for small inputs */
if|if
condition|(
name|preferRepeat
operator|&&
name|repeat
operator|&&
operator|*
name|repeat
operator|!=
name|HUF_repeat_none
condition|)
block|{
return|return
name|HUF_compressCTable_internal
argument_list|(
name|ostart
argument_list|,
name|op
argument_list|,
name|oend
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
name|singleStream
argument_list|,
name|oldHufTable
argument_list|)
return|;
block|}
comment|/* Build Huffman Tree */
name|huffLog
operator|=
name|HUF_optimalTableLog
argument_list|(
name|huffLog
argument_list|,
name|srcSize
argument_list|,
name|maxSymbolValue
argument_list|)
expr_stmt|;
block|{
name|CHECK_V_F
argument_list|(
name|maxBits
argument_list|,
name|HUF_buildCTable_wksp
argument_list|(
name|CTable
argument_list|,
name|count
argument_list|,
name|maxSymbolValue
argument_list|,
name|huffLog
argument_list|,
name|workSpace
argument_list|,
name|wkspSize
argument_list|)
argument_list|)
expr_stmt|;
name|huffLog
operator|=
operator|(
name|U32
operator|)
name|maxBits
expr_stmt|;
comment|/* Zero the unused symbols so we can check it for validity */
name|memset
argument_list|(
name|CTable
operator|+
name|maxSymbolValue
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
name|CTableSize
operator|-
operator|(
name|maxSymbolValue
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|HUF_CElt
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Write table description header */
block|{
name|CHECK_V_F
argument_list|(
name|hSize
argument_list|,
name|HUF_writeCTable
argument_list|(
name|op
argument_list|,
name|dstSize
argument_list|,
name|CTable
argument_list|,
name|maxSymbolValue
argument_list|,
name|huffLog
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check if using the previous table will be beneficial */
if|if
condition|(
name|repeat
operator|&&
operator|*
name|repeat
operator|!=
name|HUF_repeat_none
condition|)
block|{
name|size_t
specifier|const
name|oldSize
init|=
name|HUF_estimateCompressedSize
argument_list|(
name|oldHufTable
argument_list|,
name|count
argument_list|,
name|maxSymbolValue
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|newSize
init|=
name|HUF_estimateCompressedSize
argument_list|(
name|CTable
argument_list|,
name|count
argument_list|,
name|maxSymbolValue
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldSize
operator|<=
name|hSize
operator|+
name|newSize
operator|||
name|hSize
operator|+
literal|12
operator|>=
name|srcSize
condition|)
block|{
return|return
name|HUF_compressCTable_internal
argument_list|(
name|ostart
argument_list|,
name|op
argument_list|,
name|oend
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
name|singleStream
argument_list|,
name|oldHufTable
argument_list|)
return|;
block|}
block|}
comment|/* Use the new table */
if|if
condition|(
name|hSize
operator|+
literal|12ul
operator|>=
name|srcSize
condition|)
block|{
return|return
literal|0
return|;
block|}
name|op
operator|+=
name|hSize
expr_stmt|;
if|if
condition|(
name|repeat
condition|)
block|{
operator|*
name|repeat
operator|=
name|HUF_repeat_none
expr_stmt|;
block|}
if|if
condition|(
name|oldHufTable
condition|)
block|{
name|memcpy
argument_list|(
name|oldHufTable
argument_list|,
name|CTable
argument_list|,
name|CTableSize
argument_list|)
expr_stmt|;
block|}
comment|/* Save the new table */
block|}
return|return
name|HUF_compressCTable_internal
argument_list|(
name|ostart
argument_list|,
name|op
argument_list|,
name|oend
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
name|singleStream
argument_list|,
name|CTable
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|HUF_compress1X_wksp
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|,
name|unsigned
name|huffLog
parameter_list|,
name|void
modifier|*
name|workSpace
parameter_list|,
name|size_t
name|wkspSize
parameter_list|)
block|{
return|return
name|HUF_compress_internal
argument_list|(
name|dst
argument_list|,
name|dstSize
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
name|maxSymbolValue
argument_list|,
name|huffLog
argument_list|,
literal|1
comment|/* single stream */
argument_list|,
name|workSpace
argument_list|,
name|wkspSize
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|HUF_compress1X_repeat
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|,
name|unsigned
name|huffLog
parameter_list|,
name|void
modifier|*
name|workSpace
parameter_list|,
name|size_t
name|wkspSize
parameter_list|,
name|HUF_CElt
modifier|*
name|hufTable
parameter_list|,
name|HUF_repeat
modifier|*
name|repeat
parameter_list|,
name|int
name|preferRepeat
parameter_list|)
block|{
return|return
name|HUF_compress_internal
argument_list|(
name|dst
argument_list|,
name|dstSize
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
name|maxSymbolValue
argument_list|,
name|huffLog
argument_list|,
literal|1
comment|/* single stream */
argument_list|,
name|workSpace
argument_list|,
name|wkspSize
argument_list|,
name|hufTable
argument_list|,
name|repeat
argument_list|,
name|preferRepeat
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|HUF_compress1X
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|,
name|unsigned
name|huffLog
parameter_list|)
block|{
name|unsigned
name|workSpace
index|[
literal|1024
index|]
decl_stmt|;
return|return
name|HUF_compress1X_wksp
argument_list|(
name|dst
argument_list|,
name|dstSize
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
name|maxSymbolValue
argument_list|,
name|huffLog
argument_list|,
name|workSpace
argument_list|,
sizeof|sizeof
argument_list|(
name|workSpace
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|HUF_compress4X_wksp
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|,
name|unsigned
name|huffLog
parameter_list|,
name|void
modifier|*
name|workSpace
parameter_list|,
name|size_t
name|wkspSize
parameter_list|)
block|{
return|return
name|HUF_compress_internal
argument_list|(
name|dst
argument_list|,
name|dstSize
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
name|maxSymbolValue
argument_list|,
name|huffLog
argument_list|,
literal|0
comment|/* 4 streams */
argument_list|,
name|workSpace
argument_list|,
name|wkspSize
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|HUF_compress4X_repeat
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|,
name|unsigned
name|huffLog
parameter_list|,
name|void
modifier|*
name|workSpace
parameter_list|,
name|size_t
name|wkspSize
parameter_list|,
name|HUF_CElt
modifier|*
name|hufTable
parameter_list|,
name|HUF_repeat
modifier|*
name|repeat
parameter_list|,
name|int
name|preferRepeat
parameter_list|)
block|{
return|return
name|HUF_compress_internal
argument_list|(
name|dst
argument_list|,
name|dstSize
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
name|maxSymbolValue
argument_list|,
name|huffLog
argument_list|,
literal|0
comment|/* 4 streams */
argument_list|,
name|workSpace
argument_list|,
name|wkspSize
argument_list|,
name|hufTable
argument_list|,
name|repeat
argument_list|,
name|preferRepeat
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|HUF_compress2
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|dstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|unsigned
name|maxSymbolValue
parameter_list|,
name|unsigned
name|huffLog
parameter_list|)
block|{
name|unsigned
name|workSpace
index|[
literal|1024
index|]
decl_stmt|;
return|return
name|HUF_compress4X_wksp
argument_list|(
name|dst
argument_list|,
name|dstSize
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|,
name|maxSymbolValue
argument_list|,
name|huffLog
argument_list|,
name|workSpace
argument_list|,
sizeof|sizeof
argument_list|(
name|workSpace
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|HUF_compress
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
return|return
name|HUF_compress2
argument_list|(
name|dst
argument_list|,
name|maxDstSize
argument_list|,
name|src
argument_list|,
operator|(
name|U32
operator|)
name|srcSize
argument_list|,
literal|255
argument_list|,
name|HUF_TABLELOG_DEFAULT
argument_list|)
return|;
block|}
end_function

end_unit

