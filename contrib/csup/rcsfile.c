begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007-2008, Ulf Lilleengen<lulf@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"diff.h"
end_include

begin_include
include|#
directive|include
file|"keyword.h"
end_include

begin_include
include|#
directive|include
file|"misc.h"
end_include

begin_include
include|#
directive|include
file|"proto.h"
end_include

begin_include
include|#
directive|include
file|"queue.h"
end_include

begin_include
include|#
directive|include
file|"rcsfile.h"
end_include

begin_include
include|#
directive|include
file|"rcsparse.h"
end_include

begin_include
include|#
directive|include
file|"stream.h"
end_include

begin_define
define|#
directive|define
name|BUF_SIZE_DEFAULT
value|128
end_define

begin_comment
comment|/*  * RCS parser library. This is the part of the library that handles the  * importing, editing and exporting of RCS files. It currently supports only the  * part of the RCS file specification that is needed for csup (for instance,  * newphrases are not supported), and assumes that you can store the whole RCS  * file in memory.  */
end_comment

begin_comment
comment|/*  * Linked list for string tokens.  */
end_comment

begin_struct
struct|struct
name|string
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|STAILQ_ENTRY
argument_list|(
argument|string
argument_list|)
name|string_next
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Linked list of tags and revision numbers, in the RCS file header.  */
end_comment

begin_struct
struct|struct
name|tag
block|{
name|char
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|revnum
decl_stmt|;
name|STAILQ_ENTRY
argument_list|(
argument|tag
argument_list|)
name|tag_next
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * A RCS delta. The delta is identified by a revision number, and contains the  * most important RCS attributes that is needed by csup. It also contains  * pointers to other nodes in the RCS file delta structure.  */
end_comment

begin_struct
struct|struct
name|delta
block|{
name|char
modifier|*
name|revdate
decl_stmt|;
name|char
modifier|*
name|revnum
decl_stmt|;
name|char
modifier|*
name|author
decl_stmt|;
name|char
modifier|*
name|state
decl_stmt|;
name|struct
name|buf
modifier|*
name|log
decl_stmt|;
name|struct
name|buf
modifier|*
name|text
decl_stmt|;
name|int
name|placeholder
decl_stmt|;
name|struct
name|delta
modifier|*
name|diffbase
decl_stmt|;
name|struct
name|delta
modifier|*
name|prev
decl_stmt|;
name|LIST_ENTRY
argument_list|(
argument|delta
argument_list|)
name|delta_next
expr_stmt|;
name|STAILQ_ENTRY
argument_list|(
argument|delta
argument_list|)
name|delta_prev
expr_stmt|;
name|LIST_ENTRY
argument_list|(
argument|delta
argument_list|)
name|table_next
expr_stmt|;
name|STAILQ_ENTRY
argument_list|(
argument|delta
argument_list|)
name|stack_next
expr_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|branch
argument_list|)
name|branchlist
expr_stmt|;
name|LIST_ENTRY
argument_list|(
argument|delta
argument_list|)
name|branch_next_date
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * A branch data structure containing information about deltas in the branch as  * well as a base revision number.  */
end_comment

begin_struct
struct|struct
name|branch
block|{
name|char
modifier|*
name|revnum
decl_stmt|;
name|LIST_HEAD
argument_list|(
argument_list|,
argument|delta
argument_list|)
name|deltalist
expr_stmt|;
comment|/* Next delta in our branch. */
name|STAILQ_ENTRY
argument_list|(
argument|branch
argument_list|)
name|branch_next
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * The rcsfile structure is the "main" structure of the RCS parser library. It  * contains administrative data as well as pointers to the deltas within the  * file.  */
end_comment

begin_struct
struct|struct
name|rcsfile
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|head
decl_stmt|;
name|char
modifier|*
name|branch
decl_stmt|;
comment|/* Default branch. */
name|char
modifier|*
name|cvsroot
decl_stmt|;
name|char
modifier|*
name|colltag
decl_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|string
argument_list|)
name|accesslist
expr_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|tag
argument_list|)
name|taglist
expr_stmt|;
name|int
name|strictlock
decl_stmt|;
name|char
modifier|*
name|comment
decl_stmt|;
name|int
name|expand
decl_stmt|;
name|struct
name|branch
modifier|*
name|trunk
decl_stmt|;
comment|/* The tip delta. */
name|LIST_HEAD
argument_list|(
argument_list|,
argument|delta
argument_list|)
name|deltatable
expr_stmt|;
name|LIST_HEAD
argument_list|(
argument_list|,
argument|delta
argument_list|)
name|deltatable_dates
expr_stmt|;
name|char
modifier|*
name|desc
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|rcsfile_freedelta
parameter_list|(
name|struct
name|delta
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rcsfile_insertdelta
parameter_list|(
name|struct
name|branch
modifier|*
parameter_list|,
name|struct
name|delta
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|delta
modifier|*
name|rcsfile_createdelta
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rcsfile_write_deltatext
parameter_list|(
name|struct
name|rcsfile
modifier|*
parameter_list|,
name|struct
name|stream
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rcsfile_puttext
parameter_list|(
name|struct
name|rcsfile
modifier|*
parameter_list|,
name|struct
name|stream
modifier|*
parameter_list|,
name|struct
name|delta
modifier|*
parameter_list|,
name|struct
name|delta
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|branch
modifier|*
name|rcsfile_getbranch
parameter_list|(
name|struct
name|rcsfile
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rcsfile_insertsorteddelta
parameter_list|(
name|struct
name|rcsfile
modifier|*
parameter_list|,
name|struct
name|delta
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|stream
modifier|*
name|rcsfile_getdeltatext
parameter_list|(
name|struct
name|rcsfile
modifier|*
parameter_list|,
name|struct
name|delta
modifier|*
parameter_list|,
name|struct
name|buf
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rcsdelta_writestring
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|stream
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Space formatting of RCS file. */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|head_space
init|=
literal|"\t"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|branch_space
init|=
literal|"\t"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|tag_space
init|=
literal|"\t"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|date_space
init|=
literal|"\t"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|auth_space
init|=
literal|"\t"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|state_space
init|=
literal|"\t"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|next_space
init|=
literal|"\t"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|branches_space
init|=
literal|"\t"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|comment_space
init|=
literal|"\t"
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|print_stream
parameter_list|(
name|struct
name|stream
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Print the contents of a stream, for debugging. */
end_comment

begin_function
name|void
name|print_stream
parameter_list|(
name|struct
name|stream
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|line
decl_stmt|;
name|line
operator|=
name|stream_getln
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|line
operator|!=
name|NULL
condition|)
block|{
name|lprintf
argument_list|(
operator|-
literal|1
argument_list|,
literal|"%s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|line
operator|=
name|stream_getln
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|lprintf
argument_list|(
operator|-
literal|1
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Parse rcsfile from path and return a pointer to it.  */
end_comment

begin_function
name|struct
name|rcsfile
modifier|*
name|rcsfile_frompath
parameter_list|(
name|char
modifier|*
name|path
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|cvsroot
parameter_list|,
name|char
modifier|*
name|colltag
parameter_list|)
block|{
name|struct
name|rcsfile
modifier|*
name|rf
decl_stmt|;
name|FILE
modifier|*
name|infp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
operator|||
name|name
operator|==
name|NULL
operator|||
name|cvsroot
operator|==
name|NULL
operator|||
name|colltag
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|rf
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|rcsfile
argument_list|)
argument_list|)
expr_stmt|;
name|rf
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|rf
operator|->
name|cvsroot
operator|=
name|xstrdup
argument_list|(
name|cvsroot
argument_list|)
expr_stmt|;
name|rf
operator|->
name|colltag
operator|=
name|xstrdup
argument_list|(
name|colltag
argument_list|)
expr_stmt|;
comment|/* Initialize head branch. */
name|rf
operator|->
name|trunk
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|branch
argument_list|)
argument_list|)
expr_stmt|;
name|rf
operator|->
name|trunk
operator|->
name|revnum
operator|=
name|xstrdup
argument_list|(
literal|"1"
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|rf
operator|->
name|trunk
operator|->
name|deltalist
argument_list|)
expr_stmt|;
comment|/* Initialize delta list. */
name|LIST_INIT
argument_list|(
operator|&
name|rf
operator|->
name|deltatable
argument_list|)
expr_stmt|;
comment|/* Initialize tag list. */
name|STAILQ_INIT
argument_list|(
operator|&
name|rf
operator|->
name|taglist
argument_list|)
expr_stmt|;
comment|/* Initialize accesslist. */
name|STAILQ_INIT
argument_list|(
operator|&
name|rf
operator|->
name|accesslist
argument_list|)
expr_stmt|;
comment|/* Initialize all fields. */
name|rf
operator|->
name|head
operator|=
name|NULL
expr_stmt|;
name|rf
operator|->
name|branch
operator|=
name|NULL
expr_stmt|;
name|rf
operator|->
name|strictlock
operator|=
literal|0
expr_stmt|;
name|rf
operator|->
name|comment
operator|=
name|NULL
expr_stmt|;
name|rf
operator|->
name|expand
operator|=
name|EXPAND_DEFAULT
expr_stmt|;
name|rf
operator|->
name|desc
operator|=
name|NULL
expr_stmt|;
name|infp
operator|=
name|fopen
argument_list|(
name|path
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|infp
operator|==
name|NULL
condition|)
block|{
name|lprintf
argument_list|(
operator|-
literal|1
argument_list|,
literal|"Cannot open \"%s\": %s\n"
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|rcsfile_free
argument_list|(
name|rf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|error
operator|=
name|rcsparse_run
argument_list|(
name|rf
argument_list|,
name|infp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|infp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|lprintf
argument_list|(
operator|-
literal|1
argument_list|,
literal|"Error parsing \"%s\"\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|rcsfile_free
argument_list|(
name|rf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|rf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write content of rcsfile to server. Assumes we have a complete RCS file  * loaded.  */
end_comment

begin_function
name|int
name|rcsfile_send_details
parameter_list|(
name|struct
name|rcsfile
modifier|*
name|rf
parameter_list|,
name|struct
name|stream
modifier|*
name|wr
parameter_list|)
block|{
name|struct
name|delta
modifier|*
name|d
decl_stmt|;
name|struct
name|tag
modifier|*
name|t
decl_stmt|;
specifier|const
name|char
modifier|*
name|keyword
decl_stmt|;
name|int
name|error
decl_stmt|;
name|assert
argument_list|(
name|rf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|"V %s\n"
argument_list|,
name|rf
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Write default branch. */
if|if
condition|(
name|rf
operator|->
name|branch
operator|==
name|NULL
condition|)
name|error
operator|=
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|"b\n"
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|"B %s\n"
argument_list|,
name|rf
operator|->
name|branch
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Write deltas to server. */
name|error
operator|=
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|"D\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|LIST_FOREACH
argument_list|(
argument|d
argument_list|,
argument|&rf->deltatable
argument_list|,
argument|table_next
argument_list|)
block|{
name|error
operator|=
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|"%s %s\n"
argument_list|,
name|d
operator|->
name|revnum
argument_list|,
name|d
operator|->
name|revdate
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Write expand. */
if|if
condition|(
name|rf
operator|->
name|expand
operator|!=
name|EXPAND_DEFAULT
condition|)
block|{
name|keyword
operator|=
name|keyword_encode_expand
argument_list|(
name|rf
operator|->
name|expand
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyword
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|"E %s\n"
argument_list|,
name|keyword_encode_expand
argument_list|(
name|rf
operator|->
name|expand
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* Write tags to server. */
name|error
operator|=
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|"T\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|STAILQ_FOREACH
argument_list|(
argument|t
argument_list|,
argument|&rf->taglist
argument_list|,
argument|tag_next
argument_list|)
block|{
name|error
operator|=
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|"%s %s\n"
argument_list|,
name|t
operator|->
name|tag
argument_list|,
name|t
operator|->
name|revnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write a RCS file to disk represented by the destination stream. Keep track of  * deltas with a stack and an inverted stack.  */
end_comment

begin_function
name|int
name|rcsfile_write
parameter_list|(
name|struct
name|rcsfile
modifier|*
name|rf
parameter_list|,
name|struct
name|stream
modifier|*
name|dest
parameter_list|)
block|{
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|delta
argument_list|)
name|deltastack
expr_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|delta
argument_list|)
name|deltalist_inverted
expr_stmt|;
name|struct
name|tag
modifier|*
name|t
decl_stmt|;
name|struct
name|branch
modifier|*
name|b
decl_stmt|;
name|struct
name|delta
modifier|*
name|d
decl_stmt|,
modifier|*
name|d_tmp
decl_stmt|,
modifier|*
name|d_next
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* First write head. */
name|d
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|rf
operator|->
name|trunk
operator|->
name|deltalist
argument_list|)
expr_stmt|;
name|stream_printf
argument_list|(
name|dest
argument_list|,
literal|"head%s%s;\n"
argument_list|,
name|head_space
argument_list|,
name|d
operator|->
name|revnum
argument_list|)
expr_stmt|;
comment|/* Write branch, if we have. */
if|if
condition|(
name|rf
operator|->
name|branch
operator|!=
name|NULL
condition|)
name|stream_printf
argument_list|(
name|dest
argument_list|,
literal|"branch%s%s;\n"
argument_list|,
name|branch_space
argument_list|,
name|rf
operator|->
name|branch
argument_list|)
expr_stmt|;
comment|/* Write access. */
name|stream_printf
argument_list|(
name|dest
argument_list|,
literal|"access"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (!STAILQ_EMPTY(&rf->accesslist)) {
comment|/* 		 * XXX: Write out access. This doesn't seem to be necessary for 		 * the time being. 		 */
block|}
endif|#
directive|endif
name|stream_printf
argument_list|(
name|dest
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
comment|/* Write out taglist. */
name|stream_printf
argument_list|(
name|dest
argument_list|,
literal|"symbols"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|rf
operator|->
name|taglist
argument_list|)
condition|)
block|{
name|STAILQ_FOREACH
argument_list|(
argument|t
argument_list|,
argument|&rf->taglist
argument_list|,
argument|tag_next
argument_list|)
block|{
name|stream_printf
argument_list|(
name|dest
argument_list|,
literal|"\n%s%s:%s"
argument_list|,
name|tag_space
argument_list|,
name|t
operator|->
name|tag
argument_list|,
name|t
operator|->
name|revnum
argument_list|)
expr_stmt|;
block|}
block|}
name|stream_printf
argument_list|(
name|dest
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
comment|/* Write out locks and strict. */
name|stream_printf
argument_list|(
name|dest
argument_list|,
literal|"locks;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf
operator|->
name|strictlock
condition|)
name|stream_printf
argument_list|(
name|dest
argument_list|,
literal|" strict;"
argument_list|)
expr_stmt|;
name|stream_printf
argument_list|(
name|dest
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Write out the comment. */
if|if
condition|(
name|rf
operator|->
name|comment
operator|!=
name|NULL
condition|)
name|stream_printf
argument_list|(
name|dest
argument_list|,
literal|"comment%s%s;\n"
argument_list|,
name|comment_space
argument_list|,
name|rf
operator|->
name|comment
argument_list|)
expr_stmt|;
name|stream_printf
argument_list|(
name|dest
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Write out deltas. We use a stack where we push the appropriate deltas 	 * that is to be written out during the loop. 	 */
name|STAILQ_INIT
argument_list|(
operator|&
name|deltastack
argument_list|)
expr_stmt|;
name|d
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|rf
operator|->
name|trunk
operator|->
name|deltalist
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|deltastack
argument_list|,
name|d
argument_list|,
name|stack_next
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|deltastack
argument_list|)
condition|)
block|{
name|d
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|deltastack
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|deltastack
argument_list|,
name|stack_next
argument_list|)
expr_stmt|;
comment|/* Do not write out placeholders just to be safe. */
if|if
condition|(
name|d
operator|->
name|placeholder
condition|)
continue|continue;
name|stream_printf
argument_list|(
name|dest
argument_list|,
literal|"%s\n"
argument_list|,
name|d
operator|->
name|revnum
argument_list|)
expr_stmt|;
name|stream_printf
argument_list|(
name|dest
argument_list|,
literal|"date%s%s;%sauthor %s;%sstate"
argument_list|,
name|date_space
argument_list|,
name|d
operator|->
name|revdate
argument_list|,
name|auth_space
argument_list|,
name|d
operator|->
name|author
argument_list|,
name|state_space
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|state
operator|!=
name|NULL
condition|)
name|stream_printf
argument_list|(
name|dest
argument_list|,
literal|" %s"
argument_list|,
name|d
operator|->
name|state
argument_list|)
expr_stmt|;
name|stream_printf
argument_list|(
name|dest
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
name|stream_printf
argument_list|(
name|dest
argument_list|,
literal|"branches"
argument_list|)
expr_stmt|;
comment|/* 		 * Write out our branches. Add them to a reversed list for use 		 * later when we write out the text. 		 */
name|STAILQ_INIT
argument_list|(
operator|&
name|deltalist_inverted
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|b
argument_list|,
argument|&d->branchlist
argument_list|,
argument|branch_next
argument_list|)
block|{
name|d_tmp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|b
operator|->
name|deltalist
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|deltalist_inverted
argument_list|,
name|d_tmp
argument_list|,
name|delta_prev
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|deltastack
argument_list|,
name|d_tmp
argument_list|,
name|stack_next
argument_list|)
expr_stmt|;
block|}
comment|/* Push branch heads on stack. */
name|STAILQ_FOREACH
argument_list|(
argument|d_tmp
argument_list|,
argument|&deltalist_inverted
argument_list|,
argument|delta_prev
argument_list|)
block|{
if|if
condition|(
name|d_tmp
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"empty branch!"
argument_list|)
expr_stmt|;
name|stream_printf
argument_list|(
name|dest
argument_list|,
literal|"\n%s%s"
argument_list|,
name|branches_space
argument_list|,
name|d_tmp
operator|->
name|revnum
argument_list|)
expr_stmt|;
block|}
name|stream_printf
argument_list|(
name|dest
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
name|stream_printf
argument_list|(
name|dest
argument_list|,
literal|"next%s"
argument_list|,
name|next_space
argument_list|)
expr_stmt|;
comment|/* Push next delta on stack. */
name|d_next
operator|=
name|LIST_NEXT
argument_list|(
name|d
argument_list|,
name|delta_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_next
operator|!=
name|NULL
condition|)
block|{
name|stream_printf
argument_list|(
name|dest
argument_list|,
literal|"%s"
argument_list|,
name|d_next
operator|->
name|revnum
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|deltastack
argument_list|,
name|d_next
argument_list|,
name|stack_next
argument_list|)
expr_stmt|;
block|}
name|stream_printf
argument_list|(
name|dest
argument_list|,
literal|";\n\n"
argument_list|)
expr_stmt|;
block|}
name|stream_printf
argument_list|(
name|dest
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Write out desc. */
name|stream_printf
argument_list|(
name|dest
argument_list|,
literal|"desc\n@@"
argument_list|)
expr_stmt|;
name|d
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|rf
operator|->
name|trunk
operator|->
name|deltalist
argument_list|)
expr_stmt|;
comment|/*  	 * XXX: We do not take as much care as cvsup to cope with hand-hacked 	 * RCS-files, and therefore we'll just let them be updated. If having 	 * them correct is important, it will be catched by the checksum anyway. 	 */
comment|/* Write out deltatexts. */
name|error
operator|=
name|rcsfile_write_deltatext
argument_list|(
name|rf
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|stream_printf
argument_list|(
name|dest
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write out deltatexts of a delta and it's subbranches recursively.  */
end_comment

begin_function
name|int
name|rcsfile_write_deltatext
parameter_list|(
name|struct
name|rcsfile
modifier|*
name|rf
parameter_list|,
name|struct
name|stream
modifier|*
name|dest
parameter_list|)
block|{
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|delta
argument_list|)
name|deltastack
expr_stmt|;
name|LIST_HEAD
argument_list|(
argument_list|,
argument|delta
argument_list|)
name|branchlist_datesorted
expr_stmt|;
name|struct
name|delta
modifier|*
name|d
decl_stmt|,
modifier|*
name|d_tmp
decl_stmt|,
modifier|*
name|d_next
decl_stmt|,
modifier|*
name|d_tmp2
decl_stmt|,
modifier|*
name|d_tmp3
decl_stmt|;
name|struct
name|stream
modifier|*
name|in
decl_stmt|;
name|struct
name|branch
modifier|*
name|b
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|deltastack
argument_list|)
expr_stmt|;
name|d
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|rf
operator|->
name|trunk
operator|->
name|deltalist
argument_list|)
expr_stmt|;
name|d
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|deltastack
argument_list|,
name|d
argument_list|,
name|stack_next
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|deltastack
argument_list|)
condition|)
block|{
name|d
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|deltastack
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|deltastack
argument_list|,
name|stack_next
argument_list|)
expr_stmt|;
comment|/* Do not write out placeholders just to be safe. */
if|if
condition|(
name|d
operator|->
name|placeholder
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|stream_printf
argument_list|(
name|dest
argument_list|,
literal|"\n\n\n%s\n"
argument_list|,
name|d
operator|->
name|revnum
argument_list|)
expr_stmt|;
name|stream_printf
argument_list|(
name|dest
argument_list|,
literal|"log\n@"
argument_list|)
expr_stmt|;
name|in
operator|=
name|stream_open_buf
argument_list|(
name|d
operator|->
name|log
argument_list|)
expr_stmt|;
name|line
operator|=
name|stream_getln
argument_list|(
name|in
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
while|while
condition|(
name|line
operator|!=
name|NULL
condition|)
block|{
name|stream_write
argument_list|(
name|dest
argument_list|,
name|line
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|line
operator|=
name|stream_getln
argument_list|(
name|in
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
block|}
name|stream_close
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|stream_printf
argument_list|(
name|dest
argument_list|,
literal|"@\n"
argument_list|)
expr_stmt|;
name|stream_printf
argument_list|(
name|dest
argument_list|,
literal|"text\n@"
argument_list|)
expr_stmt|;
name|error
operator|=
name|rcsfile_puttext
argument_list|(
name|rf
argument_list|,
name|dest
argument_list|,
name|d
argument_list|,
name|d
operator|->
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|stream_printf
argument_list|(
name|dest
argument_list|,
literal|"@"
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|branchlist_datesorted
argument_list|)
expr_stmt|;
name|d_next
operator|=
name|LIST_NEXT
argument_list|(
name|d
argument_list|,
name|delta_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_next
operator|!=
name|NULL
condition|)
block|{
name|d_next
operator|->
name|prev
operator|=
name|d
expr_stmt|;
comment|/* 			 * If it's trunk, treat it like the oldest, if not treat 			 * it like a child. 			 */
if|if
condition|(
name|rcsrev_istrunk
argument_list|(
name|d_next
operator|->
name|revnum
argument_list|)
condition|)
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|deltastack
argument_list|,
name|d_next
argument_list|,
name|stack_next
argument_list|)
expr_stmt|;
else|else
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|branchlist_datesorted
argument_list|,
name|d_next
argument_list|,
name|branch_next_date
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * First, we need to sort our branches based on their date to 		 * take into account some self-hacked RCS files. 		 */
name|STAILQ_FOREACH
argument_list|(
argument|b
argument_list|,
argument|&d->branchlist
argument_list|,
argument|branch_next
argument_list|)
block|{
name|d_tmp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|b
operator|->
name|deltalist
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|branchlist_datesorted
argument_list|)
condition|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|branchlist_datesorted
argument_list|,
name|d_tmp
argument_list|,
name|branch_next_date
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|d_tmp2
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|branchlist_datesorted
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcsnum_cmp
argument_list|(
name|d_tmp
operator|->
name|revdate
argument_list|,
name|d_tmp2
operator|->
name|revdate
argument_list|)
operator|<
literal|0
condition|)
block|{
name|LIST_INSERT_BEFORE
argument_list|(
name|d_tmp2
argument_list|,
name|d_tmp
argument_list|,
name|branch_next_date
argument_list|)
expr_stmt|;
continue|continue;
block|}
while|while
condition|(
operator|(
name|d_tmp3
operator|=
name|LIST_NEXT
argument_list|(
name|d_tmp2
argument_list|,
name|branch_next_date
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|rcsnum_cmp
argument_list|(
name|d_tmp
operator|->
name|revdate
argument_list|,
name|d_tmp3
operator|->
name|revdate
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|d_tmp2
operator|=
name|d_tmp3
expr_stmt|;
block|}
name|LIST_INSERT_AFTER
argument_list|(
name|d_tmp2
argument_list|,
name|d_tmp
argument_list|,
name|branch_next_date
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Invert the deltalist of a branch, since we're writing them 		 * the opposite way.  		 */
name|LIST_FOREACH
argument_list|(
argument|d_tmp
argument_list|,
argument|&branchlist_datesorted
argument_list|,
argument|branch_next_date
argument_list|)
block|{
name|d_tmp
operator|->
name|prev
operator|=
name|d
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|deltastack
argument_list|,
name|d_tmp
argument_list|,
name|stack_next
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generates text given a delta and a diffbase.  */
end_comment

begin_function
specifier|static
name|int
name|rcsfile_puttext
parameter_list|(
name|struct
name|rcsfile
modifier|*
name|rf
parameter_list|,
name|struct
name|stream
modifier|*
name|dest
parameter_list|,
name|struct
name|delta
modifier|*
name|d
parameter_list|,
name|struct
name|delta
modifier|*
name|diffbase
parameter_list|)
block|{
name|struct
name|stream
modifier|*
name|in
decl_stmt|,
modifier|*
name|rd
decl_stmt|,
modifier|*
name|orig
decl_stmt|;
name|struct
name|keyword
modifier|*
name|k
decl_stmt|;
name|struct
name|diffinfo
name|dibuf
decl_stmt|,
modifier|*
name|di
decl_stmt|;
name|struct
name|buf
modifier|*
name|b
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|error
decl_stmt|;
name|di
operator|=
operator|&
name|dibuf
expr_stmt|;
name|b
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* Write if the diffbase is the previous */
if|if
condition|(
name|d
operator|->
name|diffbase
operator|==
name|diffbase
condition|)
block|{
comment|/* Write out the text. */
name|in
operator|=
name|stream_open_buf
argument_list|(
name|d
operator|->
name|text
argument_list|)
expr_stmt|;
name|line
operator|=
name|stream_getln
argument_list|(
name|in
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
while|while
condition|(
name|line
operator|!=
name|NULL
condition|)
block|{
name|stream_write
argument_list|(
name|dest
argument_list|,
name|line
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|line
operator|=
name|stream_getln
argument_list|(
name|in
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
block|}
name|stream_close
argument_list|(
name|in
argument_list|)
expr_stmt|;
comment|/* We need to apply diff to produce text, this is probably HEAD. */
block|}
elseif|else
if|if
condition|(
name|diffbase
operator|==
name|NULL
condition|)
block|{
comment|/* Apply diff. */
name|orig
operator|=
name|rcsfile_getdeltatext
argument_list|(
name|rf
argument_list|,
name|d
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|line
operator|=
name|stream_getln
argument_list|(
name|orig
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
while|while
condition|(
name|line
operator|!=
name|NULL
condition|)
block|{
name|stream_write
argument_list|(
name|dest
argument_list|,
name|line
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|line
operator|=
name|stream_getln
argument_list|(
name|orig
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
block|}
name|stream_close
argument_list|(
name|orig
argument_list|)
expr_stmt|;
comment|/* 	 * A new head was probably added, and now the previous HEAD must be 	 * changed to include the diff instead. 	 */
block|}
elseif|else
if|if
condition|(
name|diffbase
operator|->
name|diffbase
operator|==
name|d
condition|)
block|{
comment|/* Get reverse diff. */
name|orig
operator|=
name|rcsfile_getdeltatext
argument_list|(
name|rf
argument_list|,
name|d
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|di
operator|->
name|di_rcsfile
operator|=
name|rf
operator|->
name|name
expr_stmt|;
name|di
operator|->
name|di_cvsroot
operator|=
name|rf
operator|->
name|cvsroot
expr_stmt|;
name|di
operator|->
name|di_revnum
operator|=
name|d
operator|->
name|revnum
expr_stmt|;
name|di
operator|->
name|di_revdate
operator|=
name|d
operator|->
name|revdate
expr_stmt|;
name|di
operator|->
name|di_author
operator|=
name|d
operator|->
name|author
expr_stmt|;
name|di
operator|->
name|di_tag
operator|=
name|rf
operator|->
name|colltag
expr_stmt|;
name|di
operator|->
name|di_state
operator|=
name|d
operator|->
name|state
expr_stmt|;
name|di
operator|->
name|di_expand
operator|=
name|EXPAND_OLD
expr_stmt|;
name|k
operator|=
name|keyword_new
argument_list|()
expr_stmt|;
name|rd
operator|=
name|stream_open_buf
argument_list|(
name|diffbase
operator|->
name|text
argument_list|)
expr_stmt|;
name|error
operator|=
name|diff_reverse
argument_list|(
name|rd
argument_list|,
name|orig
argument_list|,
name|dest
argument_list|,
name|k
argument_list|,
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|lprintf
argument_list|(
operator|-
literal|1
argument_list|,
literal|"Error applying reverse diff: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|keyword_free
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|stream_close
argument_list|(
name|rd
argument_list|)
expr_stmt|;
name|stream_close
argument_list|(
name|orig
argument_list|)
expr_stmt|;
block|}
name|cleanup
label|:
if|if
condition|(
name|b
operator|!=
name|NULL
condition|)
name|buf_free
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return a stream with an applied diff of a delta.  * XXX: extra overhead on the last apply. Could write directly to file, but  * makes things complicated though.  */
end_comment

begin_function
specifier|static
name|struct
name|stream
modifier|*
name|rcsfile_getdeltatext
parameter_list|(
name|struct
name|rcsfile
modifier|*
name|rf
parameter_list|,
name|struct
name|delta
modifier|*
name|d
parameter_list|,
name|struct
name|buf
modifier|*
modifier|*
name|buf_dest
parameter_list|)
block|{
name|struct
name|diffinfo
name|dibuf
decl_stmt|,
modifier|*
name|di
decl_stmt|;
name|struct
name|stream
modifier|*
name|orig
decl_stmt|,
modifier|*
name|dest
decl_stmt|,
modifier|*
name|rd
decl_stmt|;
name|struct
name|buf
modifier|*
name|buf_orig
decl_stmt|;
name|struct
name|keyword
modifier|*
name|k
decl_stmt|;
name|int
name|error
decl_stmt|;
name|buf_orig
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If diffbase is NULL or we are head (the old head), we have a normal 	 * complete deltatext. 	 */
if|if
condition|(
name|d
operator|->
name|diffbase
operator|==
name|NULL
operator|&&
operator|!
name|strcmp
argument_list|(
name|rf
operator|->
name|head
argument_list|,
name|d
operator|->
name|revnum
argument_list|)
condition|)
block|{
name|orig
operator|=
name|stream_open_buf
argument_list|(
name|d
operator|->
name|text
argument_list|)
expr_stmt|;
return|return
operator|(
name|orig
operator|)
return|;
block|}
name|di
operator|=
operator|&
name|dibuf
expr_stmt|;
comment|/* If not, we need to apply our diff to that of our diffbase. */
name|orig
operator|=
name|rcsfile_getdeltatext
argument_list|(
name|rf
argument_list|,
name|d
operator|->
name|diffbase
argument_list|,
operator|&
name|buf_orig
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * Now that we are sure we have a complete deltatext in ret, let's apply 	 * our diff to it. 	 */
operator|*
name|buf_dest
operator|=
name|buf_new
argument_list|(
name|BUF_SIZE_DEFAULT
argument_list|)
expr_stmt|;
name|dest
operator|=
name|stream_open_buf
argument_list|(
operator|*
name|buf_dest
argument_list|)
expr_stmt|;
name|di
operator|->
name|di_rcsfile
operator|=
name|rf
operator|->
name|name
expr_stmt|;
name|di
operator|->
name|di_cvsroot
operator|=
name|rf
operator|->
name|cvsroot
expr_stmt|;
name|di
operator|->
name|di_revnum
operator|=
name|d
operator|->
name|revnum
expr_stmt|;
name|di
operator|->
name|di_revdate
operator|=
name|d
operator|->
name|revdate
expr_stmt|;
name|di
operator|->
name|di_author
operator|=
name|d
operator|->
name|author
expr_stmt|;
name|di
operator|->
name|di_tag
operator|=
name|rf
operator|->
name|colltag
expr_stmt|;
name|di
operator|->
name|di_state
operator|=
name|d
operator|->
name|state
expr_stmt|;
name|di
operator|->
name|di_expand
operator|=
name|EXPAND_OLD
expr_stmt|;
name|rd
operator|=
name|stream_open_buf
argument_list|(
name|d
operator|->
name|text
argument_list|)
expr_stmt|;
name|k
operator|=
name|keyword_new
argument_list|()
expr_stmt|;
name|error
operator|=
name|diff_apply
argument_list|(
name|rd
argument_list|,
name|orig
argument_list|,
name|dest
argument_list|,
name|k
argument_list|,
name|di
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stream_flush
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|stream_close
argument_list|(
name|rd
argument_list|)
expr_stmt|;
name|stream_close
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|stream_close
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|keyword_free
argument_list|(
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf_orig
operator|!=
name|NULL
condition|)
name|buf_free
argument_list|(
name|buf_orig
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|lprintf
argument_list|(
operator|-
literal|1
argument_list|,
literal|"Error applying diff: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Now reopen the stream for the reading. */
name|dest
operator|=
name|stream_open_buf
argument_list|(
operator|*
name|buf_dest
argument_list|)
expr_stmt|;
return|return
operator|(
name|dest
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Print content of rcsfile. Useful for debugging. */
end_comment

begin_function
name|void
name|rcsfile_print
parameter_list|(
name|struct
name|rcsfile
modifier|*
name|rf
parameter_list|)
block|{
name|struct
name|delta
modifier|*
name|d
decl_stmt|;
name|struct
name|tag
modifier|*
name|t
decl_stmt|;
name|struct
name|string
modifier|*
name|s
decl_stmt|;
name|struct
name|stream
modifier|*
name|in
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|lprintf
argument_list|(
literal|1
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf
operator|->
name|name
operator|!=
name|NULL
condition|)
name|lprintf
argument_list|(
literal|1
argument_list|,
literal|"name: '%s'\n"
argument_list|,
name|rf
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf
operator|->
name|head
operator|!=
name|NULL
condition|)
name|lprintf
argument_list|(
literal|1
argument_list|,
literal|"head: '%s'\n"
argument_list|,
name|rf
operator|->
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf
operator|->
name|branch
operator|!=
name|NULL
condition|)
name|lprintf
argument_list|(
literal|1
argument_list|,
literal|"branch: '%s'\n"
argument_list|,
name|rf
operator|->
name|branch
argument_list|)
expr_stmt|;
name|lprintf
argument_list|(
literal|1
argument_list|,
literal|"Access: "
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|s
argument_list|,
argument|&rf->accesslist
argument_list|,
argument|string_next
argument_list|)
name|lprintf
argument_list|(
literal|1
argument_list|,
literal|"'%s' "
argument_list|,
name|s
operator|->
name|str
argument_list|)
expr_stmt|;
name|lprintf
argument_list|(
literal|1
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Print all tags. */
name|STAILQ_FOREACH
argument_list|(
argument|t
argument_list|,
argument|&rf->taglist
argument_list|,
argument|tag_next
argument_list|)
block|{
name|lprintf
argument_list|(
literal|1
argument_list|,
literal|"Tag: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|tag
operator|!=
name|NULL
condition|)
name|lprintf
argument_list|(
literal|1
argument_list|,
literal|"name: %s "
argument_list|,
name|t
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|revnum
operator|!=
name|NULL
condition|)
name|lprintf
argument_list|(
literal|1
argument_list|,
literal|"rev: %s"
argument_list|,
name|t
operator|->
name|revnum
argument_list|)
expr_stmt|;
name|lprintf
argument_list|(
literal|1
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rf
operator|->
name|strictlock
condition|)
name|lprintf
argument_list|(
literal|1
argument_list|,
literal|"Strict!\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf
operator|->
name|comment
operator|!=
name|NULL
condition|)
name|lprintf
argument_list|(
literal|1
argument_list|,
literal|"comment: '%s'\n"
argument_list|,
name|rf
operator|->
name|comment
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf
operator|->
name|expand
operator|>=
literal|0
condition|)
name|lprintf
argument_list|(
literal|1
argument_list|,
literal|"expand: '%s'\n"
argument_list|,
name|keyword_encode_expand
argument_list|(
name|rf
operator|->
name|expand
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Print all deltas. */
name|LIST_FOREACH
argument_list|(
argument|d
argument_list|,
argument|&rf->deltatable
argument_list|,
argument|table_next
argument_list|)
block|{
name|lprintf
argument_list|(
literal|1
argument_list|,
literal|"Delta: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|revdate
operator|!=
name|NULL
condition|)
name|lprintf
argument_list|(
literal|1
argument_list|,
literal|"date: %s "
argument_list|,
name|d
operator|->
name|revdate
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|revnum
operator|!=
name|NULL
condition|)
name|lprintf
argument_list|(
literal|1
argument_list|,
literal|"rev: %s"
argument_list|,
name|d
operator|->
name|revnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|author
operator|!=
name|NULL
condition|)
name|lprintf
argument_list|(
literal|1
argument_list|,
literal|"author: %s"
argument_list|,
name|d
operator|->
name|author
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|state
operator|!=
name|NULL
condition|)
name|lprintf
argument_list|(
literal|1
argument_list|,
literal|"state: %s"
argument_list|,
name|d
operator|->
name|state
argument_list|)
expr_stmt|;
name|lprintf
argument_list|(
literal|1
argument_list|,
literal|"Text:\n"
argument_list|)
expr_stmt|;
name|in
operator|=
name|stream_open_buf
argument_list|(
name|d
operator|->
name|text
argument_list|)
expr_stmt|;
name|line
operator|=
name|stream_getln
argument_list|(
name|in
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|line
operator|!=
name|NULL
condition|)
block|{
name|lprintf
argument_list|(
literal|1
argument_list|,
literal|"TEXT: %s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|line
operator|=
name|stream_getln
argument_list|(
name|in
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|stream_close
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|lprintf
argument_list|(
literal|1
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rf
operator|->
name|desc
operator|!=
name|NULL
condition|)
name|lprintf
argument_list|(
literal|1
argument_list|,
literal|"desc: '%s'\n"
argument_list|,
name|rf
operator|->
name|desc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free all memory associated with a struct rcsfile. */
end_comment

begin_function
name|void
name|rcsfile_free
parameter_list|(
name|struct
name|rcsfile
modifier|*
name|rf
parameter_list|)
block|{
name|struct
name|delta
modifier|*
name|d
decl_stmt|;
name|struct
name|tag
modifier|*
name|t
decl_stmt|;
name|struct
name|string
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|rf
operator|->
name|name
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rf
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf
operator|->
name|head
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rf
operator|->
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf
operator|->
name|branch
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rf
operator|->
name|branch
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf
operator|->
name|cvsroot
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rf
operator|->
name|cvsroot
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf
operator|->
name|colltag
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rf
operator|->
name|colltag
argument_list|)
expr_stmt|;
comment|/* Free all access ids. */
while|while
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|rf
operator|->
name|accesslist
argument_list|)
condition|)
block|{
name|s
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|rf
operator|->
name|accesslist
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|rf
operator|->
name|accesslist
argument_list|,
name|string_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|str
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|s
operator|->
name|str
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* Free all tags. */
while|while
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|rf
operator|->
name|taglist
argument_list|)
condition|)
block|{
name|t
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|rf
operator|->
name|taglist
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|rf
operator|->
name|taglist
argument_list|,
name|tag_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|tag
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|t
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|revnum
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|t
operator|->
name|revnum
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rf
operator|->
name|comment
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rf
operator|->
name|comment
argument_list|)
expr_stmt|;
comment|/* Free all deltas in global list */
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|rf
operator|->
name|deltatable
argument_list|)
condition|)
block|{
name|d
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|rf
operator|->
name|deltatable
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|d
argument_list|,
name|delta_next
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|d
argument_list|,
name|table_next
argument_list|)
expr_stmt|;
name|rcsfile_freedelta
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
comment|/* Free global branch. */
if|if
condition|(
name|rf
operator|->
name|trunk
operator|->
name|revnum
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rf
operator|->
name|trunk
operator|->
name|revnum
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rf
operator|->
name|trunk
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf
operator|->
name|desc
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rf
operator|->
name|desc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free a RCS delta.  */
end_comment

begin_function
specifier|static
name|void
name|rcsfile_freedelta
parameter_list|(
name|struct
name|delta
modifier|*
name|d
parameter_list|)
block|{
name|struct
name|branch
modifier|*
name|b
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|revdate
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|d
operator|->
name|revdate
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|revnum
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|d
operator|->
name|revnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|author
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|d
operator|->
name|author
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|state
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|d
operator|->
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|log
operator|!=
name|NULL
condition|)
name|buf_free
argument_list|(
name|d
operator|->
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|text
operator|!=
name|NULL
condition|)
name|buf_free
argument_list|(
name|d
operator|->
name|text
argument_list|)
expr_stmt|;
comment|/* Free all subbranches of a delta. */
comment|/* XXX: Is this ok? Since the branchpoint is removed, there is no good 	 * reason for the branch to exists, but we might still have deltas in 	 * these branches. 	 */
while|while
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|d
operator|->
name|branchlist
argument_list|)
condition|)
block|{
name|b
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|d
operator|->
name|branchlist
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|d
operator|->
name|branchlist
argument_list|,
name|branch_next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|b
operator|->
name|revnum
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Functions for editing RCS deltas.  */
end_comment

begin_comment
comment|/* Add a new entry to the access list. */
end_comment

begin_function
name|void
name|rcsfile_addaccess
parameter_list|(
name|struct
name|rcsfile
modifier|*
name|rf
parameter_list|,
name|char
modifier|*
name|id
parameter_list|)
block|{
name|struct
name|string
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|string
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|str
operator|=
name|xstrdup
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|rf
operator|->
name|accesslist
argument_list|,
name|s
argument_list|,
name|string_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a tag to a RCS file. */
end_comment

begin_function
name|void
name|rcsfile_addtag
parameter_list|(
name|struct
name|rcsfile
modifier|*
name|rf
parameter_list|,
name|char
modifier|*
name|tag
parameter_list|,
name|char
modifier|*
name|revnum
parameter_list|)
block|{
name|struct
name|tag
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tag
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|tag
operator|=
name|xstrdup
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|t
operator|->
name|revnum
operator|=
name|xstrdup
argument_list|(
name|revnum
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|rf
operator|->
name|taglist
argument_list|,
name|t
argument_list|,
name|tag_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Import a tag to a RCS file. */
end_comment

begin_function
name|void
name|rcsfile_importtag
parameter_list|(
name|struct
name|rcsfile
modifier|*
name|rf
parameter_list|,
name|char
modifier|*
name|tag
parameter_list|,
name|char
modifier|*
name|revnum
parameter_list|)
block|{
name|struct
name|tag
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tag
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|tag
operator|=
name|xstrdup
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|t
operator|->
name|revnum
operator|=
name|xstrdup
argument_list|(
name|revnum
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|rf
operator|->
name|taglist
argument_list|,
name|t
argument_list|,
name|tag_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Delete a revision from the global delta list and the branch it is in. Csup  * will tell us to delete the tags involved.  */
end_comment

begin_function
name|void
name|rcsfile_deleterev
parameter_list|(
name|struct
name|rcsfile
modifier|*
name|rf
parameter_list|,
name|char
modifier|*
name|revname
parameter_list|)
block|{
name|struct
name|delta
modifier|*
name|d
decl_stmt|;
name|d
operator|=
name|rcsfile_getdelta
argument_list|(
name|rf
argument_list|,
name|revname
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|d
argument_list|,
name|delta_next
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|d
argument_list|,
name|table_next
argument_list|)
expr_stmt|;
name|rcsfile_freedelta
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete a tag from the tag list. */
end_comment

begin_function
name|void
name|rcsfile_deletetag
parameter_list|(
name|struct
name|rcsfile
modifier|*
name|rf
parameter_list|,
name|char
modifier|*
name|tag
parameter_list|,
name|char
modifier|*
name|revnum
parameter_list|)
block|{
name|struct
name|tag
modifier|*
name|t
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|t
argument_list|,
argument|&rf->taglist
argument_list|,
argument|tag_next
argument_list|)
block|{
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|tag
argument_list|,
name|t
operator|->
name|tag
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|revnum
argument_list|,
name|t
operator|->
name|revnum
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|STAILQ_REMOVE
argument_list|(
operator|&
name|rf
operator|->
name|taglist
argument_list|,
name|t
argument_list|,
name|tag
argument_list|,
name|tag_next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|t
operator|->
name|tag
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|t
operator|->
name|revnum
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/*   * Searches the global deltalist for a delta.  */
end_comment

begin_function
name|struct
name|delta
modifier|*
name|rcsfile_getdelta
parameter_list|(
name|struct
name|rcsfile
modifier|*
name|rf
parameter_list|,
name|char
modifier|*
name|revnum
parameter_list|)
block|{
name|struct
name|delta
modifier|*
name|d
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|d
argument_list|,
argument|&rf->deltatable
argument_list|,
argument|table_next
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|revnum
argument_list|,
name|d
operator|->
name|revnum
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|d
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Set rcsfile head. */
end_comment

begin_function
name|void
name|rcsfile_setval
parameter_list|(
name|struct
name|rcsfile
modifier|*
name|rf
parameter_list|,
name|int
name|field
parameter_list|,
name|char
modifier|*
name|val
parameter_list|)
block|{
switch|switch
condition|(
name|field
condition|)
block|{
case|case
name|RCSFILE_HEAD
case|:
if|if
condition|(
name|rf
operator|->
name|head
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rf
operator|->
name|head
argument_list|)
expr_stmt|;
name|rf
operator|->
name|head
operator|=
name|xstrdup
argument_list|(
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|RCSFILE_BRANCH
case|:
if|if
condition|(
name|rf
operator|->
name|branch
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rf
operator|->
name|branch
argument_list|)
expr_stmt|;
name|rf
operator|->
name|branch
operator|=
operator|(
name|val
operator|==
name|NULL
operator|)
condition|?
name|NULL
else|:
name|xstrdup
argument_list|(
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|RCSFILE_STRICT
case|:
if|if
condition|(
name|val
operator|!=
name|NULL
condition|)
name|rf
operator|->
name|strictlock
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|RCSFILE_COMMENT
case|:
if|if
condition|(
name|rf
operator|->
name|comment
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rf
operator|->
name|comment
argument_list|)
expr_stmt|;
name|rf
operator|->
name|comment
operator|=
name|xstrdup
argument_list|(
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|RCSFILE_EXPAND
case|:
name|rf
operator|->
name|expand
operator|=
name|keyword_decode_expand
argument_list|(
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|RCSFILE_DESC
case|:
if|if
condition|(
name|rf
operator|->
name|desc
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rf
operator|->
name|desc
argument_list|)
expr_stmt|;
name|rf
operator|->
name|desc
operator|=
name|xstrdup
argument_list|(
name|val
argument_list|)
expr_stmt|;
break|break;
default|default:
name|lprintf
argument_list|(
operator|-
literal|1
argument_list|,
literal|"Setting invalid RCSfile value.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Create and initialize a delta. */
end_comment

begin_function
specifier|static
name|struct
name|delta
modifier|*
name|rcsfile_createdelta
parameter_list|(
name|char
modifier|*
name|revnum
parameter_list|)
block|{
name|struct
name|delta
modifier|*
name|d
decl_stmt|;
name|d
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|delta
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|revnum
operator|=
name|xstrdup
argument_list|(
name|revnum
argument_list|)
expr_stmt|;
name|d
operator|->
name|revdate
operator|=
name|NULL
expr_stmt|;
name|d
operator|->
name|state
operator|=
name|NULL
expr_stmt|;
name|d
operator|->
name|author
operator|=
name|NULL
expr_stmt|;
name|d
operator|->
name|log
operator|=
name|buf_new
argument_list|(
name|BUF_SIZE_DEFAULT
argument_list|)
expr_stmt|;
name|d
operator|->
name|text
operator|=
name|buf_new
argument_list|(
name|BUF_SIZE_DEFAULT
argument_list|)
expr_stmt|;
name|d
operator|->
name|diffbase
operator|=
name|NULL
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|d
operator|->
name|branchlist
argument_list|)
expr_stmt|;
return|return
operator|(
name|d
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Add a delta to a imported delta tree. Used by the updater. */
end_comment

begin_function
name|struct
name|delta
modifier|*
name|rcsfile_addelta
parameter_list|(
name|struct
name|rcsfile
modifier|*
name|rf
parameter_list|,
name|char
modifier|*
name|revnum
parameter_list|,
name|char
modifier|*
name|revdate
parameter_list|,
name|char
modifier|*
name|author
parameter_list|,
name|char
modifier|*
name|diffbase
parameter_list|)
block|{
name|struct
name|branch
modifier|*
name|b
decl_stmt|;
name|struct
name|delta
modifier|*
name|d
decl_stmt|,
modifier|*
name|d_bp
decl_stmt|,
modifier|*
name|d_next
decl_stmt|;
name|char
modifier|*
name|brev
decl_stmt|,
modifier|*
name|bprev
decl_stmt|;
name|int
name|trunk
decl_stmt|;
name|d_next
operator|=
name|NULL
expr_stmt|;
name|d
operator|=
name|rcsfile_getdelta
argument_list|(
name|rf
argument_list|,
name|revnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|!=
name|NULL
condition|)
block|{
name|lprintf
argument_list|(
operator|-
literal|1
argument_list|,
literal|"Delta %s already exists!\n"
argument_list|,
name|revnum
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|d
operator|=
name|rcsfile_createdelta
argument_list|(
name|revnum
argument_list|)
expr_stmt|;
name|d
operator|->
name|placeholder
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|revdate
operator|=
name|xstrdup
argument_list|(
name|revdate
argument_list|)
expr_stmt|;
name|d
operator|->
name|author
operator|=
name|xstrdup
argument_list|(
name|author
argument_list|)
expr_stmt|;
name|d
operator|->
name|diffbase
operator|=
name|rcsfile_getdelta
argument_list|(
name|rf
argument_list|,
name|diffbase
argument_list|)
expr_stmt|;
comment|/* If it's trunk, insert it in the head branch list. */
name|b
operator|=
name|rcsrev_istrunk
argument_list|(
name|d
operator|->
name|revnum
argument_list|)
condition|?
name|rf
operator|->
name|trunk
else|:
name|rcsfile_getbranch
argument_list|(
name|rf
argument_list|,
name|d
operator|->
name|revnum
argument_list|)
expr_stmt|;
comment|/* 	 * We didn't find a branch, check if we can find a branchpoint and 	 * create a branch there.  	 */
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
block|{
name|brev
operator|=
name|rcsrev_prefix
argument_list|(
name|d
operator|->
name|revnum
argument_list|)
expr_stmt|;
name|bprev
operator|=
name|rcsrev_prefix
argument_list|(
name|brev
argument_list|)
expr_stmt|;
name|d_bp
operator|=
name|rcsfile_getdelta
argument_list|(
name|rf
argument_list|,
name|bprev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bprev
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_bp
operator|==
name|NULL
condition|)
block|{
name|lprintf
argument_list|(
operator|-
literal|1
argument_list|,
literal|"No branch point for adding delta %s\n"
argument_list|,
name|d
operator|->
name|revnum
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Create the branch and insert in delta. */
name|b
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|branch
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|revnum
operator|=
name|brev
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|b
operator|->
name|deltalist
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|d_bp
operator|->
name|branchlist
argument_list|,
name|b
argument_list|,
name|branch_next
argument_list|)
expr_stmt|;
block|}
comment|/* Insert both into the tree, and into the lookup list. */
name|trunk
operator|=
name|rcsrev_istrunk
argument_list|(
name|d
operator|->
name|revnum
argument_list|)
expr_stmt|;
name|rcsfile_insertdelta
argument_list|(
name|b
argument_list|,
name|d
argument_list|,
name|trunk
argument_list|)
expr_stmt|;
name|rcsfile_insertsorteddelta
argument_list|(
name|rf
argument_list|,
name|d
argument_list|)
expr_stmt|;
return|return
operator|(
name|d
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Adds a delta to a rcsfile struct. Used by the parser. */
end_comment

begin_function
name|void
name|rcsfile_importdelta
parameter_list|(
name|struct
name|rcsfile
modifier|*
name|rf
parameter_list|,
name|char
modifier|*
name|revnum
parameter_list|,
name|char
modifier|*
name|revdate
parameter_list|,
name|char
modifier|*
name|author
parameter_list|,
name|char
modifier|*
name|state
parameter_list|,
name|char
modifier|*
name|next
parameter_list|)
block|{
name|struct
name|branch
modifier|*
name|b
decl_stmt|;
name|struct
name|delta
modifier|*
name|d
decl_stmt|,
modifier|*
name|d_bp
decl_stmt|,
modifier|*
name|d_next
decl_stmt|;
name|char
modifier|*
name|brev
decl_stmt|,
modifier|*
name|bprev
decl_stmt|;
name|int
name|trunk
decl_stmt|;
name|d_next
operator|=
name|NULL
expr_stmt|;
name|d
operator|=
name|rcsfile_getdelta
argument_list|(
name|rf
argument_list|,
name|revnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
block|{
comment|/* If not, we'll just create a new entry. */
name|d
operator|=
name|rcsfile_createdelta
argument_list|(
name|revnum
argument_list|)
expr_stmt|;
name|d
operator|->
name|placeholder
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|d
operator|->
name|placeholder
operator|==
literal|0
condition|)
block|{
name|lprintf
argument_list|(
operator|-
literal|1
argument_list|,
literal|"Trying to import already existing delta\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * If already exists, assume that only revnum is filled out, and set the 	 * rest of the fields. This should be an OK assumption given that we can 	 * be sure internally that the structure is sufficiently initialized so 	 * we won't have any unfreed memory. 	 */
name|d
operator|->
name|revdate
operator|=
name|xstrdup
argument_list|(
name|revdate
argument_list|)
expr_stmt|;
name|d
operator|->
name|author
operator|=
name|xstrdup
argument_list|(
name|author
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|NULL
condition|)
name|d
operator|->
name|state
operator|=
name|xstrdup
argument_list|(
name|state
argument_list|)
expr_stmt|;
comment|/* If we have a next, create a placeholder for it. */
if|if
condition|(
name|next
operator|!=
name|NULL
condition|)
block|{
name|d_next
operator|=
name|rcsfile_createdelta
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|d_next
operator|->
name|placeholder
operator|=
literal|1
expr_stmt|;
comment|/* Diffbase should be the previous. */
name|d_next
operator|->
name|diffbase
operator|=
name|d
expr_stmt|;
block|}
comment|/* If it's trunk, insert it in the head branch list. */
name|b
operator|=
name|rcsrev_istrunk
argument_list|(
name|d
operator|->
name|revnum
argument_list|)
condition|?
name|rf
operator|->
name|trunk
else|:
name|rcsfile_getbranch
argument_list|(
name|rf
argument_list|,
name|d
operator|->
name|revnum
argument_list|)
expr_stmt|;
comment|/* 	 * We didn't find a branch, check if we can find a branchpoint and 	 * create a branch there.  	 */
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
block|{
name|brev
operator|=
name|rcsrev_prefix
argument_list|(
name|d
operator|->
name|revnum
argument_list|)
expr_stmt|;
name|bprev
operator|=
name|rcsrev_prefix
argument_list|(
name|brev
argument_list|)
expr_stmt|;
name|d_bp
operator|=
name|rcsfile_getdelta
argument_list|(
name|rf
argument_list|,
name|bprev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bprev
argument_list|)
expr_stmt|;
if|if
condition|(
name|d_bp
operator|==
name|NULL
condition|)
block|{
name|lprintf
argument_list|(
operator|-
literal|1
argument_list|,
literal|"No branch point for adding delta %s\n"
argument_list|,
name|d
operator|->
name|revnum
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Create the branch and insert in delta. */
name|b
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|branch
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|revnum
operator|=
name|brev
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|b
operator|->
name|deltalist
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|d_bp
operator|->
name|branchlist
argument_list|,
name|b
argument_list|,
name|branch_next
argument_list|)
expr_stmt|;
block|}
comment|/* Insert if not a placeholder. */
if|if
condition|(
operator|!
name|d
operator|->
name|placeholder
condition|)
block|{
comment|/* Insert both into the tree, and into the lookup list. */
if|if
condition|(
name|rcsrev_istrunk
argument_list|(
name|d
operator|->
name|revnum
argument_list|)
condition|)
name|rcsfile_insertdelta
argument_list|(
name|b
argument_list|,
name|d
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|rcsfile_insertdelta
argument_list|(
name|b
argument_list|,
name|d
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*  			 * On import we need to set the diffbase to our 			 * branchpoint for writing out later. 			 * XXX: this could perhaps be done at a better time. 			 */
if|if
condition|(
name|LIST_FIRST
argument_list|(
operator|&
name|b
operator|->
name|deltalist
argument_list|)
operator|==
name|d
condition|)
block|{
name|brev
operator|=
name|rcsrev_prefix
argument_list|(
name|d
operator|->
name|revnum
argument_list|)
expr_stmt|;
name|bprev
operator|=
name|rcsrev_prefix
argument_list|(
name|brev
argument_list|)
expr_stmt|;
name|d_bp
operator|=
name|rcsfile_getdelta
argument_list|(
name|rf
argument_list|,
name|bprev
argument_list|)
expr_stmt|;
comment|/* This should really not happen. */
name|assert
argument_list|(
name|d_bp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|d
operator|->
name|diffbase
operator|=
name|d_bp
expr_stmt|;
name|free
argument_list|(
name|brev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bprev
argument_list|)
expr_stmt|;
block|}
block|}
name|rcsfile_insertsorteddelta
argument_list|(
name|rf
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Not a placeholder anymore. */
block|{
name|d
operator|->
name|placeholder
operator|=
literal|0
expr_stmt|;
comment|/* Put it into the tree. */
name|trunk
operator|=
name|rcsrev_istrunk
argument_list|(
name|d
operator|->
name|revnum
argument_list|)
expr_stmt|;
name|rcsfile_insertdelta
argument_list|(
name|b
argument_list|,
name|d
argument_list|,
name|trunk
argument_list|)
expr_stmt|;
block|}
comment|/* If we have a next, insert the placeholder into the lookup list. */
if|if
condition|(
name|d_next
operator|!=
name|NULL
condition|)
name|rcsfile_insertsorteddelta
argument_list|(
name|rf
argument_list|,
name|d_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find the branch of a revision number.  */
end_comment

begin_function
specifier|static
name|struct
name|branch
modifier|*
name|rcsfile_getbranch
parameter_list|(
name|struct
name|rcsfile
modifier|*
name|rf
parameter_list|,
name|char
modifier|*
name|revnum
parameter_list|)
block|{
name|struct
name|branch
modifier|*
name|b
decl_stmt|;
name|struct
name|delta
modifier|*
name|d
decl_stmt|;
name|char
modifier|*
name|branchrev
decl_stmt|,
modifier|*
name|bprev
decl_stmt|;
name|branchrev
operator|=
name|rcsrev_prefix
argument_list|(
name|revnum
argument_list|)
expr_stmt|;
name|bprev
operator|=
name|rcsrev_prefix
argument_list|(
name|branchrev
argument_list|)
expr_stmt|;
name|d
operator|=
name|rcsfile_getdelta
argument_list|(
name|rf
argument_list|,
name|bprev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bprev
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|b
argument_list|,
argument|&d->branchlist
argument_list|,
argument|branch_next
argument_list|)
block|{
if|if
condition|(
name|rcsnum_cmp
argument_list|(
name|b
operator|->
name|revnum
argument_list|,
name|branchrev
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|branchrev
argument_list|)
expr_stmt|;
return|return
operator|(
name|b
operator|)
return|;
block|}
block|}
name|free
argument_list|(
name|branchrev
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Insert a delta into the correct place in the table of the rcsfile. Sorted by  * date.  */
end_comment

begin_function
specifier|static
name|void
name|rcsfile_insertsorteddelta
parameter_list|(
name|struct
name|rcsfile
modifier|*
name|rf
parameter_list|,
name|struct
name|delta
modifier|*
name|d
parameter_list|)
block|{
name|struct
name|delta
modifier|*
name|d2
decl_stmt|;
comment|/* If it's empty, insert into head. */
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|rf
operator|->
name|deltatable
argument_list|)
condition|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|rf
operator|->
name|deltatable
argument_list|,
name|d
argument_list|,
name|table_next
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Just put it in before the revdate that is lower. */
name|LIST_FOREACH
argument_list|(
argument|d2
argument_list|,
argument|&rf->deltatable
argument_list|,
argument|table_next
argument_list|)
block|{
if|if
condition|(
name|rcsnum_cmp
argument_list|(
name|d
operator|->
name|revnum
argument_list|,
name|d2
operator|->
name|revnum
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|LIST_INSERT_BEFORE
argument_list|(
name|d2
argument_list|,
name|d
argument_list|,
name|table_next
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|LIST_NEXT
argument_list|(
name|d2
argument_list|,
name|table_next
argument_list|)
operator|==
name|NULL
condition|)
break|break;
block|}
comment|/* Insert after last element. */
name|LIST_INSERT_AFTER
argument_list|(
name|d2
argument_list|,
name|d
argument_list|,
name|table_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Insert a delta into the correct place in branch. A trunk branch will have  * different ordering scheme and be sorted by revision number, but a normal  * branch will be sorted by date to maintain compability with branches that is  * "hand-hacked".  */
end_comment

begin_function
specifier|static
name|void
name|rcsfile_insertdelta
parameter_list|(
name|struct
name|branch
modifier|*
name|b
parameter_list|,
name|struct
name|delta
modifier|*
name|d
parameter_list|,
name|int
name|trunk
parameter_list|)
block|{
name|struct
name|delta
modifier|*
name|d2
decl_stmt|;
comment|/* If it's empty, insert into head. */
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|b
operator|->
name|deltalist
argument_list|)
condition|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|b
operator|->
name|deltalist
argument_list|,
name|d
argument_list|,
name|delta_next
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Just put it in before the revnum that is lower. Sort trunk branch by 	 * branchnum but the subbranches after deltadate. 	 */
name|LIST_FOREACH
argument_list|(
argument|d2
argument_list|,
argument|&b->deltalist
argument_list|,
argument|delta_next
argument_list|)
block|{
if|if
condition|(
name|trunk
condition|)
block|{
if|if
condition|(
name|rcsnum_cmp
argument_list|(
name|d
operator|->
name|revnum
argument_list|,
name|d2
operator|->
name|revnum
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|LIST_INSERT_BEFORE
argument_list|(
name|d2
argument_list|,
name|d
argument_list|,
name|delta_next
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|/* XXX: here we depend on the date being set, but it 			 * should be before this is called anyway. */
if|if
condition|(
name|rcsnum_cmp
argument_list|(
name|d
operator|->
name|revdate
argument_list|,
name|d2
operator|->
name|revdate
argument_list|)
operator|<
literal|0
condition|)
block|{
name|LIST_INSERT_BEFORE
argument_list|(
name|d2
argument_list|,
name|d
argument_list|,
name|delta_next
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|LIST_NEXT
argument_list|(
name|d2
argument_list|,
name|delta_next
argument_list|)
operator|==
name|NULL
condition|)
break|break;
block|}
comment|/* Insert after last element. */
name|LIST_INSERT_AFTER
argument_list|(
name|d2
argument_list|,
name|d
argument_list|,
name|delta_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add logtext to a delta. Assume the delta already exists. */
end_comment

begin_function
name|int
name|rcsdelta_addlog
parameter_list|(
name|struct
name|delta
modifier|*
name|d
parameter_list|,
name|char
modifier|*
name|log
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|stream
modifier|*
name|dest
decl_stmt|;
name|assert
argument_list|(
name|d
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Strip away '@' at beginning and end. */
name|log
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
name|log
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dest
operator|=
name|stream_open_buf
argument_list|(
name|d
operator|->
name|log
argument_list|)
expr_stmt|;
name|stream_write
argument_list|(
name|dest
argument_list|,
name|log
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|stream_close
argument_list|(
name|dest
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Add deltatext to a delta. Assume the delta already exists. */
end_comment

begin_function
name|int
name|rcsdelta_addtext
parameter_list|(
name|struct
name|delta
modifier|*
name|d
parameter_list|,
name|char
modifier|*
name|text
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|stream
modifier|*
name|dest
decl_stmt|;
name|assert
argument_list|(
name|d
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Strip away '@' at beginning and end. */
name|text
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
name|text
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dest
operator|=
name|stream_open_buf
argument_list|(
name|d
operator|->
name|text
argument_list|)
expr_stmt|;
name|stream_write
argument_list|(
name|dest
argument_list|,
name|text
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|stream_close
argument_list|(
name|dest
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Add a deltatext logline to a delta. */
end_comment

begin_function
name|void
name|rcsdelta_appendlog
parameter_list|(
name|struct
name|delta
modifier|*
name|d
parameter_list|,
name|char
modifier|*
name|logline
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|struct
name|stream
modifier|*
name|dest
decl_stmt|;
name|assert
argument_list|(
name|d
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dest
operator|=
name|stream_open_buf
argument_list|(
name|d
operator|->
name|log
argument_list|)
expr_stmt|;
name|rcsdelta_writestring
argument_list|(
name|logline
argument_list|,
name|size
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|stream_close
argument_list|(
name|dest
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a deltatext textline to a delta. */
end_comment

begin_function
name|void
name|rcsdelta_appendtext
parameter_list|(
name|struct
name|delta
modifier|*
name|d
parameter_list|,
name|char
modifier|*
name|textline
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|struct
name|stream
modifier|*
name|dest
decl_stmt|;
name|assert
argument_list|(
name|d
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dest
operator|=
name|stream_open_buf
argument_list|(
name|d
operator|->
name|text
argument_list|)
expr_stmt|;
name|rcsdelta_writestring
argument_list|(
name|textline
argument_list|,
name|size
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|stream_close
argument_list|(
name|dest
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rcsdelta_writestring
parameter_list|(
name|char
modifier|*
name|textline
parameter_list|,
name|size_t
name|size
parameter_list|,
name|struct
name|stream
modifier|*
name|dest
parameter_list|)
block|{
name|char
name|buf
index|[
literal|3
index|]
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|int
name|count
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|textline
index|[
name|i
index|]
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
comment|/* Expand @'s */
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'@'
condition|)
block|{
name|buf
index|[
literal|1
index|]
operator|=
literal|'@'
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|count
operator|=
literal|2
expr_stmt|;
block|}
name|stream_write
argument_list|(
name|dest
argument_list|,
name|buf
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set delta state. */
end_comment

begin_function
name|void
name|rcsdelta_setstate
parameter_list|(
name|struct
name|delta
modifier|*
name|d
parameter_list|,
name|char
modifier|*
name|state
parameter_list|)
block|{
if|if
condition|(
name|d
operator|->
name|state
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|NULL
condition|)
block|{
name|d
operator|->
name|state
operator|=
name|xstrdup
argument_list|(
name|state
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|state
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Truncate the deltalog with a certain offset. */
end_comment

begin_function
name|void
name|rcsdelta_truncatelog
parameter_list|(
name|struct
name|delta
modifier|*
name|d
parameter_list|,
name|off_t
name|offset
parameter_list|)
block|{
name|stream_truncate_buf
argument_list|(
name|d
operator|->
name|log
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Truncate the deltatext with a certain offset. */
end_comment

begin_function
name|void
name|rcsdelta_truncatetext
parameter_list|(
name|struct
name|delta
modifier|*
name|d
parameter_list|,
name|off_t
name|offset
parameter_list|)
block|{
name|stream_truncate_buf
argument_list|(
name|d
operator|->
name|text
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

