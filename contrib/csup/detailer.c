begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2006, Maxime Henrion<mux@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"detailer.h"
end_include

begin_include
include|#
directive|include
file|"fixups.h"
end_include

begin_include
include|#
directive|include
file|"globtree.h"
end_include

begin_include
include|#
directive|include
file|"misc.h"
end_include

begin_include
include|#
directive|include
file|"mux.h"
end_include

begin_include
include|#
directive|include
file|"proto.h"
end_include

begin_include
include|#
directive|include
file|"rcsfile.h"
end_include

begin_include
include|#
directive|include
file|"rsyncfile.h"
end_include

begin_include
include|#
directive|include
file|"status.h"
end_include

begin_include
include|#
directive|include
file|"stream.h"
end_include

begin_comment
comment|/* Internal error codes. */
end_comment

begin_define
define|#
directive|define
name|DETAILER_ERR_PROTO
value|(-1)
end_define

begin_comment
comment|/* Protocol error. */
end_comment

begin_define
define|#
directive|define
name|DETAILER_ERR_MSG
value|(-2)
end_define

begin_comment
comment|/* Error is in detailer->errmsg. */
end_comment

begin_define
define|#
directive|define
name|DETAILER_ERR_READ
value|(-3)
end_define

begin_comment
comment|/* Error reading from server. */
end_comment

begin_define
define|#
directive|define
name|DETAILER_ERR_WRITE
value|(-4)
end_define

begin_comment
comment|/* Error writing to server. */
end_comment

begin_struct
struct|struct
name|detailer
block|{
name|struct
name|config
modifier|*
name|config
decl_stmt|;
name|struct
name|stream
modifier|*
name|rd
decl_stmt|;
name|struct
name|stream
modifier|*
name|wr
decl_stmt|;
name|char
modifier|*
name|errmsg
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|detailer_batch
parameter_list|(
name|struct
name|detailer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|detailer_coll
parameter_list|(
name|struct
name|detailer
modifier|*
parameter_list|,
name|struct
name|coll
modifier|*
parameter_list|,
name|struct
name|status
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|detailer_dofile_co
parameter_list|(
name|struct
name|detailer
modifier|*
parameter_list|,
name|struct
name|coll
modifier|*
parameter_list|,
name|struct
name|status
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|detailer_dofile_rcs
parameter_list|(
name|struct
name|detailer
modifier|*
parameter_list|,
name|struct
name|coll
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|detailer_dofile_regular
parameter_list|(
name|struct
name|detailer
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|detailer_dofile_rsync
parameter_list|(
name|struct
name|detailer
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|detailer_checkrcsattr
parameter_list|(
name|struct
name|detailer
modifier|*
parameter_list|,
name|struct
name|coll
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|struct
name|fattr
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|detailer_send_details
parameter_list|(
name|struct
name|detailer
modifier|*
parameter_list|,
name|struct
name|coll
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|struct
name|fattr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
modifier|*
name|detailer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|thread_args
modifier|*
name|args
decl_stmt|;
name|struct
name|detailer
name|dbuf
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|int
name|error
decl_stmt|;
name|args
operator|=
name|arg
expr_stmt|;
name|d
operator|=
operator|&
name|dbuf
expr_stmt|;
name|d
operator|->
name|config
operator|=
name|args
operator|->
name|config
expr_stmt|;
name|d
operator|->
name|rd
operator|=
name|args
operator|->
name|rd
expr_stmt|;
name|d
operator|->
name|wr
operator|=
name|args
operator|->
name|wr
expr_stmt|;
name|d
operator|->
name|errmsg
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|detailer_batch
argument_list|(
name|d
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|DETAILER_ERR_PROTO
case|:
name|xasprintf
argument_list|(
operator|&
name|args
operator|->
name|errmsg
argument_list|,
literal|"Detailer failed: Protocol error"
argument_list|)
expr_stmt|;
name|args
operator|->
name|status
operator|=
name|STATUS_FAILURE
expr_stmt|;
break|break;
case|case
name|DETAILER_ERR_MSG
case|:
name|xasprintf
argument_list|(
operator|&
name|args
operator|->
name|errmsg
argument_list|,
literal|"Detailer failed: %s"
argument_list|,
name|d
operator|->
name|errmsg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|d
operator|->
name|errmsg
argument_list|)
expr_stmt|;
name|args
operator|->
name|status
operator|=
name|STATUS_FAILURE
expr_stmt|;
break|break;
case|case
name|DETAILER_ERR_READ
case|:
if|if
condition|(
name|stream_eof
argument_list|(
name|d
operator|->
name|rd
argument_list|)
condition|)
block|{
name|xasprintf
argument_list|(
operator|&
name|args
operator|->
name|errmsg
argument_list|,
literal|"Detailer failed: "
literal|"Premature EOF from server"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xasprintf
argument_list|(
operator|&
name|args
operator|->
name|errmsg
argument_list|,
literal|"Detailer failed: "
literal|"Network read failure: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|args
operator|->
name|status
operator|=
name|STATUS_TRANSIENTFAILURE
expr_stmt|;
break|break;
case|case
name|DETAILER_ERR_WRITE
case|:
name|xasprintf
argument_list|(
operator|&
name|args
operator|->
name|errmsg
argument_list|,
literal|"Detailer failed: "
literal|"Network write failure: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|->
name|status
operator|=
name|STATUS_TRANSIENTFAILURE
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|args
operator|->
name|status
operator|=
name|STATUS_SUCCESS
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|detailer_batch
parameter_list|(
name|struct
name|detailer
modifier|*
name|d
parameter_list|)
block|{
name|struct
name|config
modifier|*
name|config
decl_stmt|;
name|struct
name|stream
modifier|*
name|rd
decl_stmt|,
modifier|*
name|wr
decl_stmt|;
name|struct
name|coll
modifier|*
name|coll
decl_stmt|;
name|struct
name|status
modifier|*
name|st
decl_stmt|;
name|struct
name|fixup
modifier|*
name|fixup
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|,
modifier|*
name|collname
decl_stmt|,
modifier|*
name|line
decl_stmt|,
modifier|*
name|release
decl_stmt|;
name|int
name|error
decl_stmt|,
name|fixupseof
decl_stmt|;
name|config
operator|=
name|d
operator|->
name|config
expr_stmt|;
name|rd
operator|=
name|d
operator|->
name|rd
expr_stmt|;
name|wr
operator|=
name|d
operator|->
name|wr
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|coll
argument_list|,
argument|&config->colls
argument_list|,
argument|co_next
argument_list|)
block|{
if|if
condition|(
name|coll
operator|->
name|co_options
operator|&
name|CO_SKIP
condition|)
continue|continue;
name|line
operator|=
name|stream_getln
argument_list|(
name|rd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|proto_get_ascii
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
name|collname
operator|=
name|proto_get_ascii
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
name|release
operator|=
name|proto_get_ascii
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
name|error
operator|=
name|proto_get_time
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|coll
operator|->
name|co_scantime
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|line
operator|!=
name|NULL
operator|||
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"COLL"
argument_list|)
operator|!=
literal|0
operator|||
name|strcmp
argument_list|(
name|collname
argument_list|,
name|coll
operator|->
name|co_name
argument_list|)
operator|!=
literal|0
operator|||
name|strcmp
argument_list|(
name|release
argument_list|,
name|coll
operator|->
name|co_release
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|DETAILER_ERR_PROTO
operator|)
return|;
name|error
operator|=
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|"COLL %s %s\n"
argument_list|,
name|coll
operator|->
name|co_name
argument_list|,
name|coll
operator|->
name|co_release
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|DETAILER_ERR_WRITE
operator|)
return|;
name|stream_flush
argument_list|(
name|wr
argument_list|)
expr_stmt|;
if|if
condition|(
name|coll
operator|->
name|co_options
operator|&
name|CO_COMPRESS
condition|)
block|{
name|stream_filter_start
argument_list|(
name|rd
argument_list|,
name|STREAM_FILTER_ZLIB
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|stream_filter_start
argument_list|(
name|wr
argument_list|,
name|STREAM_FILTER_ZLIB
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|st
operator|=
name|status_open
argument_list|(
name|coll
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|d
operator|->
name|errmsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|==
name|NULL
condition|)
return|return
operator|(
name|DETAILER_ERR_MSG
operator|)
return|;
name|error
operator|=
name|detailer_coll
argument_list|(
name|d
argument_list|,
name|coll
argument_list|,
name|st
argument_list|)
expr_stmt|;
name|status_close
argument_list|(
name|st
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|coll
operator|->
name|co_options
operator|&
name|CO_COMPRESS
condition|)
block|{
name|stream_filter_stop
argument_list|(
name|rd
argument_list|)
expr_stmt|;
name|stream_filter_stop
argument_list|(
name|wr
argument_list|)
expr_stmt|;
block|}
name|stream_flush
argument_list|(
name|wr
argument_list|)
expr_stmt|;
block|}
name|line
operator|=
name|stream_getln
argument_list|(
name|rd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
return|return
operator|(
name|DETAILER_ERR_READ
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"."
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|DETAILER_ERR_PROTO
operator|)
return|;
name|error
operator|=
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|DETAILER_ERR_WRITE
operator|)
return|;
name|stream_flush
argument_list|(
name|wr
argument_list|)
expr_stmt|;
comment|/* Now send fixups if needed. */
name|fixup
operator|=
name|NULL
expr_stmt|;
name|fixupseof
operator|=
literal|0
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|coll
argument_list|,
argument|&config->colls
argument_list|,
argument|co_next
argument_list|)
block|{
if|if
condition|(
name|coll
operator|->
name|co_options
operator|&
name|CO_SKIP
condition|)
continue|continue;
name|error
operator|=
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|"COLL %s %s\n"
argument_list|,
name|coll
operator|->
name|co_name
argument_list|,
name|coll
operator|->
name|co_release
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|DETAILER_ERR_WRITE
operator|)
return|;
if|if
condition|(
name|coll
operator|->
name|co_options
operator|&
name|CO_COMPRESS
condition|)
name|stream_filter_start
argument_list|(
name|wr
argument_list|,
name|STREAM_FILTER_ZLIB
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|fixupseof
condition|)
block|{
if|if
condition|(
name|fixup
operator|==
name|NULL
condition|)
name|fixup
operator|=
name|fixups_get
argument_list|(
name|config
operator|->
name|fixups
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixup
operator|==
name|NULL
condition|)
block|{
name|fixupseof
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fixup
operator|->
name|f_coll
operator|!=
name|coll
condition|)
break|break;
if|if
condition|(
name|coll
operator|->
name|co_options
operator|&
name|CO_CHECKOUTMODE
condition|)
name|error
operator|=
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|"Y %s %s %s\n"
argument_list|,
name|fixup
operator|->
name|f_name
argument_list|,
name|coll
operator|->
name|co_tag
argument_list|,
name|coll
operator|->
name|co_date
argument_list|)
expr_stmt|;
else|else
block|{
name|error
operator|=
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|"A %s\n"
argument_list|,
name|fixup
operator|->
name|f_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|DETAILER_ERR_WRITE
operator|)
return|;
name|fixup
operator|=
name|NULL
expr_stmt|;
block|}
name|error
operator|=
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|DETAILER_ERR_WRITE
operator|)
return|;
if|if
condition|(
name|coll
operator|->
name|co_options
operator|&
name|CO_COMPRESS
condition|)
name|stream_filter_stop
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|stream_flush
argument_list|(
name|wr
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|DETAILER_ERR_WRITE
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|detailer_coll
parameter_list|(
name|struct
name|detailer
modifier|*
name|d
parameter_list|,
name|struct
name|coll
modifier|*
name|coll
parameter_list|,
name|struct
name|status
modifier|*
name|st
parameter_list|)
block|{
name|struct
name|fattr
modifier|*
name|rcsattr
decl_stmt|;
name|struct
name|stream
modifier|*
name|rd
decl_stmt|,
modifier|*
name|wr
decl_stmt|;
name|char
modifier|*
name|attr
decl_stmt|,
modifier|*
name|cmd
decl_stmt|,
modifier|*
name|file
decl_stmt|,
modifier|*
name|line
decl_stmt|,
modifier|*
name|msg
decl_stmt|,
modifier|*
name|path
decl_stmt|,
modifier|*
name|target
decl_stmt|;
name|int
name|error
decl_stmt|,
name|attic
decl_stmt|;
name|rd
operator|=
name|d
operator|->
name|rd
expr_stmt|;
name|wr
operator|=
name|d
operator|->
name|wr
expr_stmt|;
name|attic
operator|=
literal|0
expr_stmt|;
name|line
operator|=
name|stream_getln
argument_list|(
name|rd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
return|return
operator|(
name|DETAILER_ERR_READ
operator|)
return|;
while|while
condition|(
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"."
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|cmd
operator|=
name|proto_get_ascii
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|NULL
operator|||
name|strlen
argument_list|(
name|cmd
argument_list|)
operator|!=
literal|1
condition|)
return|return
operator|(
name|DETAILER_ERR_PROTO
operator|)
return|;
switch|switch
condition|(
name|cmd
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'D'
case|:
comment|/* Delete file. */
name|file
operator|=
name|proto_get_ascii
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
operator|||
name|line
operator|!=
name|NULL
condition|)
return|return
operator|(
name|DETAILER_ERR_PROTO
operator|)
return|;
name|error
operator|=
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|"D %s\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|DETAILER_ERR_WRITE
operator|)
return|;
break|break;
case|case
literal|'I'
case|:
case|case
literal|'i'
case|:
case|case
literal|'j'
case|:
comment|/* Directory operations. */
name|file
operator|=
name|proto_get_ascii
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
operator|||
name|line
operator|!=
name|NULL
condition|)
return|return
operator|(
name|DETAILER_ERR_PROTO
operator|)
return|;
name|error
operator|=
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|"%s %s\n"
argument_list|,
name|cmd
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|DETAILER_ERR_WRITE
operator|)
return|;
break|break;
case|case
literal|'J'
case|:
comment|/* Set directory attributes. */
name|file
operator|=
name|proto_get_ascii
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
name|attr
operator|=
name|proto_get_ascii
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
operator|||
name|line
operator|!=
name|NULL
operator|||
name|attr
operator|==
name|NULL
condition|)
return|return
operator|(
name|DETAILER_ERR_PROTO
operator|)
return|;
name|error
operator|=
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|"%s %s %s\n"
argument_list|,
name|cmd
argument_list|,
name|file
argument_list|,
name|attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|DETAILER_ERR_WRITE
operator|)
return|;
break|break;
case|case
literal|'H'
case|:
case|case
literal|'h'
case|:
comment|/* Create a hard link. */
name|file
operator|=
name|proto_get_ascii
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
name|target
operator|=
name|proto_get_ascii
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
operator|||
name|target
operator|==
name|NULL
condition|)
return|return
operator|(
name|DETAILER_ERR_PROTO
operator|)
return|;
name|error
operator|=
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|"%s %s %s\n"
argument_list|,
name|cmd
argument_list|,
name|file
argument_list|,
name|target
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|file
operator|=
name|proto_get_ascii
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
name|attr
operator|=
name|proto_get_ascii
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
operator|||
name|attr
operator|==
name|NULL
operator|||
name|line
operator|!=
name|NULL
condition|)
block|{
return|return
operator|(
name|DETAILER_ERR_PROTO
operator|)
return|;
block|}
name|rcsattr
operator|=
name|fattr_decode
argument_list|(
name|attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcsattr
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|DETAILER_ERR_PROTO
operator|)
return|;
block|}
name|error
operator|=
name|detailer_checkrcsattr
argument_list|(
name|d
argument_list|,
name|coll
argument_list|,
name|file
argument_list|,
name|rcsattr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|file
operator|=
name|proto_get_ascii
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
name|attr
operator|=
name|proto_get_ascii
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
operator|||
name|attr
operator|==
name|NULL
operator|||
name|line
operator|!=
name|NULL
condition|)
return|return
operator|(
name|DETAILER_ERR_PROTO
operator|)
return|;
name|rcsattr
operator|=
name|fattr_decode
argument_list|(
name|attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcsattr
operator|==
name|NULL
condition|)
return|return
operator|(
name|DETAILER_ERR_PROTO
operator|)
return|;
name|error
operator|=
name|detailer_checkrcsattr
argument_list|(
name|d
argument_list|,
name|coll
argument_list|,
name|file
argument_list|,
name|rcsattr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
comment|/* Add or update file. */
name|file
operator|=
name|proto_get_ascii
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
operator|||
name|line
operator|!=
name|NULL
condition|)
return|return
operator|(
name|DETAILER_ERR_PROTO
operator|)
return|;
if|if
condition|(
name|coll
operator|->
name|co_options
operator|&
name|CO_CHECKOUTMODE
condition|)
block|{
name|error
operator|=
name|detailer_dofile_co
argument_list|(
name|d
argument_list|,
name|coll
argument_list|,
name|st
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|path
operator|=
name|cvspath
argument_list|(
name|coll
operator|->
name|co_prefix
argument_list|,
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rcsattr
operator|=
name|fattr_frompath
argument_list|(
name|path
argument_list|,
name|FATTR_NOFOLLOW
argument_list|)
expr_stmt|;
name|error
operator|=
name|detailer_send_details
argument_list|(
name|d
argument_list|,
name|coll
argument_list|,
name|file
argument_list|,
name|path
argument_list|,
name|rcsattr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcsattr
operator|!=
name|NULL
condition|)
name|fattr_free
argument_list|(
name|rcsattr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
break|break;
case|case
literal|'!'
case|:
comment|/* Warning from server. */
name|msg
operator|=
name|proto_get_rest
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return
operator|(
name|DETAILER_ERR_PROTO
operator|)
return|;
name|lprintf
argument_list|(
operator|-
literal|1
argument_list|,
literal|"Server warning: %s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|DETAILER_ERR_PROTO
operator|)
return|;
block|}
name|stream_flush
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|line
operator|=
name|stream_getln
argument_list|(
name|rd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
return|return
operator|(
name|DETAILER_ERR_READ
operator|)
return|;
block|}
name|error
operator|=
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|DETAILER_ERR_WRITE
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Tell the server to update a regular file.  */
end_comment

begin_function
specifier|static
name|int
name|detailer_dofile_regular
parameter_list|(
name|struct
name|detailer
modifier|*
name|d
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|stream
modifier|*
name|wr
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|char
name|md5
index|[
name|MD5_DIGEST_SIZE
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|wr
operator|=
name|d
operator|->
name|wr
expr_stmt|;
name|error
operator|=
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
comment|/* If we don't have it or it's unaccessible, we want it again. */
if|if
condition|(
name|error
condition|)
block|{
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|"A %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* If not, we want the file to be updated. */
name|error
operator|=
name|MD5_File
argument_list|(
name|path
argument_list|,
name|md5
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|lprintf
argument_list|(
operator|-
literal|1
argument_list|,
literal|"Error reading \"%s\"\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|"R %s %O %s\n"
argument_list|,
name|name
argument_list|,
name|st
operator|.
name|st_size
argument_list|,
name|md5
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|DETAILER_ERR_WRITE
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Tell the server to update a file with the rsync algorithm.  */
end_comment

begin_function
specifier|static
name|int
name|detailer_dofile_rsync
parameter_list|(
name|struct
name|detailer
modifier|*
name|d
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|stream
modifier|*
name|wr
decl_stmt|;
name|struct
name|rsyncfile
modifier|*
name|rf
decl_stmt|;
name|wr
operator|=
name|d
operator|->
name|wr
expr_stmt|;
name|rf
operator|=
name|rsync_open
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf
operator|==
name|NULL
condition|)
block|{
comment|/* Fallback if we fail in opening it. */
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|"A %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|"r %s %z %z\n"
argument_list|,
name|name
argument_list|,
name|rsync_filesize
argument_list|(
name|rf
argument_list|)
argument_list|,
name|rsync_blocksize
argument_list|(
name|rf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Detail the blocks. */
while|while
condition|(
name|rsync_nextblock
argument_list|(
name|rf
argument_list|)
operator|!=
literal|0
condition|)
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|"%s %s\n"
argument_list|,
name|rsync_rsum
argument_list|(
name|rf
argument_list|)
argument_list|,
name|rsync_blockmd5
argument_list|(
name|rf
argument_list|)
argument_list|)
expr_stmt|;
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
name|rsync_close
argument_list|(
name|rf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Tell the server to update an RCS file that we have, or send it if we don't.  */
end_comment

begin_function
specifier|static
name|int
name|detailer_dofile_rcs
parameter_list|(
name|struct
name|detailer
modifier|*
name|d
parameter_list|,
name|struct
name|coll
modifier|*
name|coll
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|stream
modifier|*
name|wr
decl_stmt|;
name|struct
name|fattr
modifier|*
name|fa
decl_stmt|;
name|struct
name|rcsfile
modifier|*
name|rf
decl_stmt|;
name|int
name|error
decl_stmt|;
name|wr
operator|=
name|d
operator|->
name|wr
expr_stmt|;
name|path
operator|=
name|atticpath
argument_list|(
name|coll
operator|->
name|co_prefix
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fa
operator|=
name|fattr_frompath
argument_list|(
name|path
argument_list|,
name|FATTR_NOFOLLOW
argument_list|)
expr_stmt|;
if|if
condition|(
name|fa
operator|==
name|NULL
condition|)
block|{
comment|/* We don't have it, so send request to get it. */
name|error
operator|=
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|"A %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|DETAILER_ERR_WRITE
operator|)
return|;
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|rf
operator|=
name|rcsfile_frompath
argument_list|(
name|path
argument_list|,
name|name
argument_list|,
name|coll
operator|->
name|co_cvsroot
argument_list|,
name|coll
operator|->
name|co_tag
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|"A %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|DETAILER_ERR_WRITE
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Tell to update the RCS file. The client version details follow. */
name|rcsfile_send_details
argument_list|(
name|rf
argument_list|,
name|wr
argument_list|)
expr_stmt|;
name|rcsfile_free
argument_list|(
name|rf
argument_list|)
expr_stmt|;
name|fattr_free
argument_list|(
name|fa
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|detailer_dofile_co
parameter_list|(
name|struct
name|detailer
modifier|*
name|d
parameter_list|,
name|struct
name|coll
modifier|*
name|coll
parameter_list|,
name|struct
name|status
modifier|*
name|st
parameter_list|,
name|char
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|stream
modifier|*
name|wr
decl_stmt|;
name|struct
name|fattr
modifier|*
name|fa
decl_stmt|;
name|struct
name|statusrec
modifier|*
name|sr
decl_stmt|;
name|char
name|md5
index|[
name|MD5_DIGEST_SIZE
index|]
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ret
decl_stmt|;
name|wr
operator|=
name|d
operator|->
name|wr
expr_stmt|;
name|path
operator|=
name|checkoutpath
argument_list|(
name|coll
operator|->
name|co_prefix
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
return|return
operator|(
name|DETAILER_ERR_PROTO
operator|)
return|;
name|fa
operator|=
name|fattr_frompath
argument_list|(
name|path
argument_list|,
name|FATTR_NOFOLLOW
argument_list|)
expr_stmt|;
if|if
condition|(
name|fa
operator|==
name|NULL
condition|)
block|{
comment|/* We don't have the file, so the only option at this 		   point is to tell the server to send it.  The server 		   may figure out that the file is dead, in which case 		   it will tell us. */
name|error
operator|=
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|"C %s %s %s\n"
argument_list|,
name|file
argument_list|,
name|coll
operator|->
name|co_tag
argument_list|,
name|coll
operator|->
name|co_date
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|DETAILER_ERR_WRITE
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ret
operator|=
name|status_get
argument_list|(
name|st
argument_list|,
name|file
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|sr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
name|d
operator|->
name|errmsg
operator|=
name|status_errmsg
argument_list|(
name|st
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|DETAILER_ERR_MSG
operator|)
return|;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|sr
operator|=
name|NULL
expr_stmt|;
comment|/* If our recorded information doesn't match the file that the 	   client has, then ignore the recorded information. */
if|if
condition|(
name|sr
operator|!=
name|NULL
operator|&&
operator|(
name|sr
operator|->
name|sr_type
operator|!=
name|SR_CHECKOUTLIVE
operator|||
operator|!
name|fattr_equal
argument_list|(
name|sr
operator|->
name|sr_clientattr
argument_list|,
name|fa
argument_list|)
operator|)
condition|)
name|sr
operator|=
name|NULL
expr_stmt|;
name|fattr_free
argument_list|(
name|fa
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|sr
operator|->
name|sr_revdate
argument_list|,
literal|"."
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|"U %s %s %s %s %s\n"
argument_list|,
name|file
argument_list|,
name|coll
operator|->
name|co_tag
argument_list|,
name|coll
operator|->
name|co_date
argument_list|,
name|sr
operator|->
name|sr_revnum
argument_list|,
name|sr
operator|->
name|sr_revdate
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|DETAILER_ERR_WRITE
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * We don't have complete and/or accurate recorded information 	 * about what version of the file we have.  Compute the file's 	 * checksum as an aid toward identifying which version it is. 	 */
name|error
operator|=
name|MD5_File
argument_list|(
name|path
argument_list|,
name|md5
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|xasprintf
argument_list|(
operator|&
name|d
operator|->
name|errmsg
argument_list|,
literal|"Cannot calculate checksum for \"%s\": %s"
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|DETAILER_ERR_MSG
operator|)
return|;
block|}
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|"S %s %s %s %s\n"
argument_list|,
name|file
argument_list|,
name|coll
operator|->
name|co_tag
argument_list|,
name|coll
operator|->
name|co_date
argument_list|,
name|md5
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|proto_printf
argument_list|(
name|wr
argument_list|,
literal|"s %s %s %s %s %s\n"
argument_list|,
name|file
argument_list|,
name|coll
operator|->
name|co_tag
argument_list|,
name|coll
operator|->
name|co_date
argument_list|,
name|sr
operator|->
name|sr_revnum
argument_list|,
name|md5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|DETAILER_ERR_WRITE
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|detailer_checkrcsattr
parameter_list|(
name|struct
name|detailer
modifier|*
name|d
parameter_list|,
name|struct
name|coll
modifier|*
name|coll
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|fattr
modifier|*
name|server_attr
parameter_list|,
name|int
name|attic
parameter_list|)
block|{
name|struct
name|fattr
modifier|*
name|client_attr
decl_stmt|;
name|char
modifier|*
name|attr
decl_stmt|,
modifier|*
name|path
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/*  	 * I don't think we can use the status file, since it only records file 	 * attributes in cvsmode. 	 */
name|client_attr
operator|=
name|NULL
expr_stmt|;
name|path
operator|=
name|cvspath
argument_list|(
name|coll
operator|->
name|co_prefix
argument_list|,
name|name
argument_list|,
name|attic
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|DETAILER_ERR_PROTO
operator|)
return|;
block|}
if|if
condition|(
name|access
argument_list|(
name|path
argument_list|,
name|F_OK
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|client_attr
operator|=
name|fattr_frompath
argument_list|(
name|path
argument_list|,
name|FATTR_NOFOLLOW
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|&&
name|fattr_equal
argument_list|(
name|client_attr
argument_list|,
name|server_attr
argument_list|)
condition|)
block|{
name|attr
operator|=
name|fattr_encode
argument_list|(
name|client_attr
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|attic
condition|)
block|{
name|error
operator|=
name|proto_printf
argument_list|(
name|d
operator|->
name|wr
argument_list|,
literal|"l %s %s\n"
argument_list|,
name|name
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|proto_printf
argument_list|(
name|d
operator|->
name|wr
argument_list|,
literal|"L %s %s\n"
argument_list|,
name|name
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|fattr_free
argument_list|(
name|client_attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|DETAILER_ERR_WRITE
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* We don't have it, so tell the server to send it. */
name|error
operator|=
name|detailer_send_details
argument_list|(
name|d
argument_list|,
name|coll
argument_list|,
name|name
argument_list|,
name|path
argument_list|,
name|client_attr
argument_list|)
expr_stmt|;
name|fattr_free
argument_list|(
name|client_attr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|detailer_send_details
parameter_list|(
name|struct
name|detailer
modifier|*
name|d
parameter_list|,
name|struct
name|coll
modifier|*
name|coll
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|fattr
modifier|*
name|fa
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|size_t
name|len
decl_stmt|;
comment|/*          * Try to check if the file exists either live or dead to see if we can         * edit it and put it live or dead, rather than receiving the entire         * file. 	*/
if|if
condition|(
name|fa
operator|==
name|NULL
condition|)
block|{
name|path
operator|=
name|atticpath
argument_list|(
name|coll
operator|->
name|co_prefix
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fa
operator|=
name|fattr_frompath
argument_list|(
name|path
argument_list|,
name|FATTR_NOFOLLOW
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fa
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|proto_printf
argument_list|(
name|d
operator|->
name|wr
argument_list|,
literal|"A %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|DETAILER_ERR_WRITE
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|fattr_type
argument_list|(
name|fa
argument_list|)
operator|==
name|FT_FILE
condition|)
block|{
if|if
condition|(
name|isrcs
argument_list|(
name|name
argument_list|,
operator|&
name|len
argument_list|)
operator|&&
operator|!
operator|(
name|coll
operator|->
name|co_options
operator|&
name|CO_NORCS
operator|)
condition|)
block|{
name|detailer_dofile_rcs
argument_list|(
name|d
argument_list|,
name|coll
argument_list|,
name|name
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|coll
operator|->
name|co_options
operator|&
name|CO_NORSYNC
operator|)
operator|&&
operator|!
name|globtree_test
argument_list|(
name|coll
operator|->
name|co_norsync
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|detailer_dofile_rsync
argument_list|(
name|d
argument_list|,
name|name
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|detailer_dofile_regular
argument_list|(
name|d
argument_list|,
name|name
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
operator|=
name|proto_printf
argument_list|(
name|d
operator|->
name|wr
argument_list|,
literal|"N %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|DETAILER_ERR_WRITE
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

