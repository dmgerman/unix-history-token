begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2006, Maxime Henrion<mux@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<fnmatch.h>
end_include

begin_include
include|#
directive|include
file|<regex.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"globtree.h"
end_include

begin_include
include|#
directive|include
file|"misc.h"
end_include

begin_comment
comment|/*  * The "GlobTree" interface allows one to construct arbitrarily complex  * boolean expressions for evaluating whether to accept or reject a  * filename.  The globtree_test() function returns true or false  * according to whether the name is accepted or rejected by the  * expression.  *  * Expressions are trees constructed from nodes representing either  * primitive matching operations (primaries) or operators that are  * applied to their subexpressions.  The simplest primitives are  * globtree_false(), which matches nothing, and globtree_true(), which  * matches everything.  *  * A more useful primitive is the matching operation, constructed with  * globtree_match().  It will call fnmatch() with the suppliedi  * shell-style pattern to determine if the filename matches.  *  * Expressions can be combined with the boolean operators AND, OR, and  * NOT, to form more complex expressions.  */
end_comment

begin_comment
comment|/* Node types. */
end_comment

begin_define
define|#
directive|define
name|GLOBTREE_NOT
value|0
end_define

begin_define
define|#
directive|define
name|GLOBTREE_AND
value|1
end_define

begin_define
define|#
directive|define
name|GLOBTREE_OR
value|2
end_define

begin_define
define|#
directive|define
name|GLOBTREE_MATCH
value|3
end_define

begin_define
define|#
directive|define
name|GLOBTREE_REGEX
value|4
end_define

begin_define
define|#
directive|define
name|GLOBTREE_TRUE
value|5
end_define

begin_define
define|#
directive|define
name|GLOBTREE_FALSE
value|6
end_define

begin_comment
comment|/* A node. */
end_comment

begin_struct
struct|struct
name|globtree
block|{
name|int
name|type
decl_stmt|;
name|struct
name|globtree
modifier|*
name|left
decl_stmt|;
name|struct
name|globtree
modifier|*
name|right
decl_stmt|;
comment|/* The "data" field points to the text pattern for GLOBTREE_MATCH 	   nodes, and to the regex_t for GLOBTREE_REGEX nodes. For any 	   other node, it is set to NULL. */
name|void
modifier|*
name|data
decl_stmt|;
comment|/* The "flags" field contains the flags to pass to fnmatch() for 	   GLOBTREE_MATCH nodes. */
name|int
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|struct
name|globtree
modifier|*
name|globtree_new
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|globtree_eval
parameter_list|(
name|struct
name|globtree
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|struct
name|globtree
modifier|*
name|globtree_new
parameter_list|(
name|int
name|type
parameter_list|)
block|{
name|struct
name|globtree
modifier|*
name|gt
decl_stmt|;
name|gt
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|globtree
argument_list|)
argument_list|)
expr_stmt|;
name|gt
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|gt
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|gt
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|gt
operator|->
name|left
operator|=
name|NULL
expr_stmt|;
name|gt
operator|->
name|right
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|gt
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|globtree
modifier|*
name|globtree_true
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|globtree
modifier|*
name|gt
decl_stmt|;
name|gt
operator|=
name|globtree_new
argument_list|(
name|GLOBTREE_TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|gt
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|globtree
modifier|*
name|globtree_false
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|globtree
modifier|*
name|gt
decl_stmt|;
name|gt
operator|=
name|globtree_new
argument_list|(
name|GLOBTREE_FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|gt
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|globtree
modifier|*
name|globtree_match
parameter_list|(
specifier|const
name|char
modifier|*
name|pattern
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|globtree
modifier|*
name|gt
decl_stmt|;
name|gt
operator|=
name|globtree_new
argument_list|(
name|GLOBTREE_MATCH
argument_list|)
expr_stmt|;
name|gt
operator|->
name|data
operator|=
name|xstrdup
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|gt
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
return|return
operator|(
name|gt
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|globtree
modifier|*
name|globtree_regex
parameter_list|(
specifier|const
name|char
modifier|*
name|pattern
parameter_list|)
block|{
name|struct
name|globtree
modifier|*
name|gt
decl_stmt|;
name|int
name|error
decl_stmt|;
name|gt
operator|=
name|globtree_new
argument_list|(
name|GLOBTREE_REGEX
argument_list|)
expr_stmt|;
name|gt
operator|->
name|data
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|regex_t
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|regcomp
argument_list|(
name|gt
operator|->
name|data
argument_list|,
name|pattern
argument_list|,
name|REG_NOSUB
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|gt
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|globtree
modifier|*
name|globtree_and
parameter_list|(
name|struct
name|globtree
modifier|*
name|left
parameter_list|,
name|struct
name|globtree
modifier|*
name|right
parameter_list|)
block|{
name|struct
name|globtree
modifier|*
name|gt
decl_stmt|;
if|if
condition|(
name|left
operator|->
name|type
operator|==
name|GLOBTREE_FALSE
operator|||
name|right
operator|->
name|type
operator|==
name|GLOBTREE_FALSE
condition|)
block|{
name|globtree_free
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|globtree_free
argument_list|(
name|right
argument_list|)
expr_stmt|;
name|gt
operator|=
name|globtree_false
argument_list|()
expr_stmt|;
return|return
operator|(
name|gt
operator|)
return|;
block|}
if|if
condition|(
name|left
operator|->
name|type
operator|==
name|GLOBTREE_TRUE
condition|)
block|{
name|globtree_free
argument_list|(
name|left
argument_list|)
expr_stmt|;
return|return
operator|(
name|right
operator|)
return|;
block|}
if|if
condition|(
name|right
operator|->
name|type
operator|==
name|GLOBTREE_TRUE
condition|)
block|{
name|globtree_free
argument_list|(
name|right
argument_list|)
expr_stmt|;
return|return
operator|(
name|left
operator|)
return|;
block|}
name|gt
operator|=
name|globtree_new
argument_list|(
name|GLOBTREE_AND
argument_list|)
expr_stmt|;
name|gt
operator|->
name|left
operator|=
name|left
expr_stmt|;
name|gt
operator|->
name|right
operator|=
name|right
expr_stmt|;
return|return
operator|(
name|gt
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|globtree
modifier|*
name|globtree_or
parameter_list|(
name|struct
name|globtree
modifier|*
name|left
parameter_list|,
name|struct
name|globtree
modifier|*
name|right
parameter_list|)
block|{
name|struct
name|globtree
modifier|*
name|gt
decl_stmt|;
if|if
condition|(
name|left
operator|->
name|type
operator|==
name|GLOBTREE_TRUE
operator|||
name|right
operator|->
name|type
operator|==
name|GLOBTREE_TRUE
condition|)
block|{
name|globtree_free
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|globtree_free
argument_list|(
name|right
argument_list|)
expr_stmt|;
name|gt
operator|=
name|globtree_true
argument_list|()
expr_stmt|;
return|return
operator|(
name|gt
operator|)
return|;
block|}
if|if
condition|(
name|left
operator|->
name|type
operator|==
name|GLOBTREE_FALSE
condition|)
block|{
name|globtree_free
argument_list|(
name|left
argument_list|)
expr_stmt|;
return|return
operator|(
name|right
operator|)
return|;
block|}
if|if
condition|(
name|right
operator|->
name|type
operator|==
name|GLOBTREE_FALSE
condition|)
block|{
name|globtree_free
argument_list|(
name|right
argument_list|)
expr_stmt|;
return|return
operator|(
name|left
operator|)
return|;
block|}
name|gt
operator|=
name|globtree_new
argument_list|(
name|GLOBTREE_OR
argument_list|)
expr_stmt|;
name|gt
operator|->
name|left
operator|=
name|left
expr_stmt|;
name|gt
operator|->
name|right
operator|=
name|right
expr_stmt|;
return|return
operator|(
name|gt
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|globtree
modifier|*
name|globtree_not
parameter_list|(
name|struct
name|globtree
modifier|*
name|child
parameter_list|)
block|{
name|struct
name|globtree
modifier|*
name|gt
decl_stmt|;
if|if
condition|(
name|child
operator|->
name|type
operator|==
name|GLOBTREE_TRUE
condition|)
block|{
name|globtree_free
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|gt
operator|=
name|globtree_new
argument_list|(
name|GLOBTREE_FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|gt
operator|)
return|;
block|}
if|if
condition|(
name|child
operator|->
name|type
operator|==
name|GLOBTREE_FALSE
condition|)
block|{
name|globtree_free
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|gt
operator|=
name|globtree_new
argument_list|(
name|GLOBTREE_TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|gt
operator|)
return|;
block|}
name|gt
operator|=
name|globtree_new
argument_list|(
name|GLOBTREE_NOT
argument_list|)
expr_stmt|;
name|gt
operator|->
name|left
operator|=
name|child
expr_stmt|;
return|return
operator|(
name|gt
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Evaluate one node (must be a leaf node). */
end_comment

begin_function
specifier|static
name|int
name|globtree_eval
parameter_list|(
name|struct
name|globtree
modifier|*
name|gt
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
switch|switch
condition|(
name|gt
operator|->
name|type
condition|)
block|{
case|case
name|GLOBTREE_TRUE
case|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|GLOBTREE_FALSE
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|GLOBTREE_MATCH
case|:
name|assert
argument_list|(
name|gt
operator|->
name|data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rv
operator|=
name|fnmatch
argument_list|(
name|gt
operator|->
name|data
argument_list|,
name|path
argument_list|,
name|gt
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|assert
argument_list|(
name|rv
operator|==
name|FNM_NOMATCH
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|GLOBTREE_REGEX
case|:
name|assert
argument_list|(
name|gt
operator|->
name|data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rv
operator|=
name|regexec
argument_list|(
name|gt
operator|->
name|data
argument_list|,
name|path
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|assert
argument_list|(
name|rv
operator|==
name|REG_NOMATCH
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Small stack API to walk the tree iteratively. */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|STATE_DOINGLEFT
block|,
name|STATE_DOINGRIGHT
block|}
name|walkstate_t
typedef|;
end_typedef

begin_struct
struct|struct
name|stack
block|{
name|struct
name|stackelem
modifier|*
name|stack
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|size_t
name|in
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|stackelem
block|{
name|struct
name|globtree
modifier|*
name|node
decl_stmt|;
name|walkstate_t
name|state
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|stack_init
parameter_list|(
name|struct
name|stack
modifier|*
name|stack
parameter_list|)
block|{
name|stack
operator|->
name|in
operator|=
literal|0
expr_stmt|;
name|stack
operator|->
name|size
operator|=
literal|8
expr_stmt|;
comment|/* Initial size. */
name|stack
operator|->
name|stack
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|stackelem
argument_list|)
operator|*
name|stack
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|stack_size
parameter_list|(
name|struct
name|stack
modifier|*
name|stack
parameter_list|)
block|{
return|return
operator|(
name|stack
operator|->
name|in
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|stack_push
parameter_list|(
name|struct
name|stack
modifier|*
name|stack
parameter_list|,
name|struct
name|globtree
modifier|*
name|node
parameter_list|,
name|walkstate_t
name|state
parameter_list|)
block|{
name|struct
name|stackelem
modifier|*
name|e
decl_stmt|;
if|if
condition|(
name|stack
operator|->
name|in
operator|==
name|stack
operator|->
name|size
condition|)
block|{
name|stack
operator|->
name|size
operator|*=
literal|2
expr_stmt|;
name|stack
operator|->
name|stack
operator|=
name|xrealloc
argument_list|(
name|stack
operator|->
name|stack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|stackelem
argument_list|)
operator|*
name|stack
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
name|e
operator|=
name|stack
operator|->
name|stack
operator|+
name|stack
operator|->
name|in
operator|++
expr_stmt|;
name|e
operator|->
name|node
operator|=
name|node
expr_stmt|;
name|e
operator|->
name|state
operator|=
name|state
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|stack_pop
parameter_list|(
name|struct
name|stack
modifier|*
name|stack
parameter_list|,
name|struct
name|globtree
modifier|*
modifier|*
name|node
parameter_list|,
name|walkstate_t
modifier|*
name|state
parameter_list|)
block|{
name|struct
name|stackelem
modifier|*
name|e
decl_stmt|;
name|assert
argument_list|(
name|stack
operator|->
name|in
operator|>
literal|0
argument_list|)
expr_stmt|;
name|e
operator|=
name|stack
operator|->
name|stack
operator|+
operator|--
name|stack
operator|->
name|in
expr_stmt|;
operator|*
name|node
operator|=
name|e
operator|->
name|node
expr_stmt|;
operator|*
name|state
operator|=
name|e
operator|->
name|state
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|stack_free
parameter_list|(
name|struct
name|stack
modifier|*
name|s
parameter_list|)
block|{
name|free
argument_list|(
name|s
operator|->
name|stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tests if the supplied filename matches. */
end_comment

begin_function
name|int
name|globtree_test
parameter_list|(
name|struct
name|globtree
modifier|*
name|gt
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|stack
name|stack
decl_stmt|;
name|walkstate_t
name|state
decl_stmt|;
name|int
name|val
decl_stmt|;
name|stack_init
argument_list|(
operator|&
name|stack
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|doleft
label|:
comment|/* Descend to the left until we hit bottom. */
while|while
condition|(
name|gt
operator|->
name|left
operator|!=
name|NULL
condition|)
block|{
name|stack_push
argument_list|(
operator|&
name|stack
argument_list|,
name|gt
argument_list|,
name|STATE_DOINGLEFT
argument_list|)
expr_stmt|;
name|gt
operator|=
name|gt
operator|->
name|left
expr_stmt|;
block|}
comment|/* Now we're at a leaf node.  Evaluate it. */
name|val
operator|=
name|globtree_eval
argument_list|(
name|gt
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* Ascend, propagating the value through operator nodes. */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|stack_size
argument_list|(
operator|&
name|stack
argument_list|)
operator|==
literal|0
condition|)
block|{
name|stack_free
argument_list|(
operator|&
name|stack
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
name|stack_pop
argument_list|(
operator|&
name|stack
argument_list|,
operator|&
name|gt
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|gt
operator|->
name|type
condition|)
block|{
case|case
name|GLOBTREE_NOT
case|:
name|val
operator|=
operator|!
name|val
expr_stmt|;
break|break;
case|case
name|GLOBTREE_AND
case|:
comment|/* If we haven't yet evaluated the right subtree 				   and the partial result is true, descend to 				   the right.  Otherwise the result is already 				   determined to be val. */
if|if
condition|(
name|state
operator|==
name|STATE_DOINGLEFT
operator|&&
name|val
condition|)
block|{
name|stack_push
argument_list|(
operator|&
name|stack
argument_list|,
name|gt
argument_list|,
name|STATE_DOINGRIGHT
argument_list|)
expr_stmt|;
name|gt
operator|=
name|gt
operator|->
name|right
expr_stmt|;
goto|goto
name|doleft
goto|;
block|}
break|break;
case|case
name|GLOBTREE_OR
case|:
comment|/* If we haven't yet evaluated the right subtree 				   and the partial result is false, descend to 				   the right.  Otherwise the result is already 				   determined to be val. */
if|if
condition|(
name|state
operator|==
name|STATE_DOINGLEFT
operator|&&
operator|!
name|val
condition|)
block|{
name|stack_push
argument_list|(
operator|&
name|stack
argument_list|,
name|gt
argument_list|,
name|STATE_DOINGRIGHT
argument_list|)
expr_stmt|;
name|gt
operator|=
name|gt
operator|->
name|right
expr_stmt|;
goto|goto
name|doleft
goto|;
block|}
break|break;
default|default:
comment|/* We only push nodes that have children. */
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * We could de-recursify this function using a stack, but it would be  * overkill since it is never called from a thread context with a  * limited stack size nor used in a critical path, so I think we can  * afford keeping it recursive.  */
end_comment

begin_function
name|void
name|globtree_free
parameter_list|(
name|struct
name|globtree
modifier|*
name|gt
parameter_list|)
block|{
if|if
condition|(
name|gt
operator|->
name|data
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|gt
operator|->
name|type
operator|==
name|GLOBTREE_REGEX
condition|)
name|regfree
argument_list|(
name|gt
operator|->
name|data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|gt
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gt
operator|->
name|left
operator|!=
name|NULL
condition|)
name|globtree_free
argument_list|(
name|gt
operator|->
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|gt
operator|->
name|right
operator|!=
name|NULL
condition|)
name|globtree_free
argument_list|(
name|gt
operator|->
name|right
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|gt
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

