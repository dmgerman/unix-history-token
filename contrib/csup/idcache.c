begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2006, Maxime Henrion<mux@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"idcache.h"
end_include

begin_include
include|#
directive|include
file|"misc.h"
end_include

begin_comment
comment|/*  * Constants and data structures used to implement the thread-safe  * group and password file caches.  Cache sizes must be prime.  */
end_comment

begin_define
define|#
directive|define
name|UIDTONAME_SZ
value|317
end_define

begin_comment
comment|/* Size of uid -> user name cache */
end_comment

begin_define
define|#
directive|define
name|NAMETOUID_SZ
value|317
end_define

begin_comment
comment|/* Size of user name -> uid cache */
end_comment

begin_define
define|#
directive|define
name|GIDTONAME_SZ
value|317
end_define

begin_comment
comment|/* Size of gid -> group name cache */
end_comment

begin_define
define|#
directive|define
name|NAMETOGID_SZ
value|317
end_define

begin_comment
comment|/* Size of group name -> gid cache */
end_comment

begin_comment
comment|/* Node structures used to cache lookups. */
end_comment

begin_struct
struct|struct
name|uidc
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* user name */
name|uid_t
name|uid
decl_stmt|;
comment|/* cached uid */
name|int
name|valid
decl_stmt|;
comment|/* is this a valid or a miss entry */
name|struct
name|uidc
modifier|*
name|next
decl_stmt|;
comment|/* for collisions */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|gidc
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* group name */
name|gid_t
name|gid
decl_stmt|;
comment|/* cached gid */
name|int
name|valid
decl_stmt|;
comment|/* is this a valid or a miss entry */
name|struct
name|gidc
modifier|*
name|next
decl_stmt|;
comment|/* for collisions */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|uidc
modifier|*
modifier|*
name|uidtoname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* uid to user name cache */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|gidc
modifier|*
modifier|*
name|gidtoname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* gid to group name cache */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|uidc
modifier|*
modifier|*
name|nametouid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* user name to uid cache */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|gidc
modifier|*
modifier|*
name|nametogid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* group name to gid cache */
end_comment

begin_decl_stmt
specifier|static
name|pthread_mutex_t
name|uid_mtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pthread_mutex_t
name|gid_mtx
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|uid_lock
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|uid_unlock
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gid_lock
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gid_unlock
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|hash
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* A 32-bit version of Peter Weinberger's (PJW) hash algorithm,     as used by ELF for hashing function names. */
end_comment

begin_function
specifier|static
name|uint32_t
name|hash
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|uint32_t
name|g
decl_stmt|,
name|h
decl_stmt|;
name|h
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|name
operator|!=
literal|'\0'
condition|)
block|{
name|h
operator|=
operator|(
name|h
operator|<<
literal|4
operator|)
operator|+
operator|*
name|name
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|g
operator|=
name|h
operator|&
literal|0xF0000000
operator|)
condition|)
block|{
name|h
operator|^=
name|g
operator|>>
literal|24
expr_stmt|;
name|h
operator|&=
literal|0x0FFFFFFF
expr_stmt|;
block|}
block|}
return|return
operator|(
name|h
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uid_lock
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|pthread_mutex_lock
argument_list|(
operator|&
name|uid_mtx
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uid_unlock
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|pthread_mutex_unlock
argument_list|(
operator|&
name|uid_mtx
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gid_lock
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|pthread_mutex_lock
argument_list|(
operator|&
name|gid_mtx
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gid_unlock
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|pthread_mutex_unlock
argument_list|(
operator|&
name|gid_mtx
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uidc_insert
parameter_list|(
name|struct
name|uidc
modifier|*
modifier|*
name|tbl
parameter_list|,
name|struct
name|uidc
modifier|*
name|uidc
parameter_list|,
name|uint32_t
name|key
parameter_list|)
block|{
name|uidc
operator|->
name|next
operator|=
name|tbl
index|[
name|key
index|]
expr_stmt|;
name|tbl
index|[
name|key
index|]
operator|=
name|uidc
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gidc_insert
parameter_list|(
name|struct
name|gidc
modifier|*
modifier|*
name|tbl
parameter_list|,
name|struct
name|gidc
modifier|*
name|gidc
parameter_list|,
name|uint32_t
name|key
parameter_list|)
block|{
name|gidc
operator|->
name|next
operator|=
name|tbl
index|[
name|key
index|]
expr_stmt|;
name|tbl
index|[
name|key
index|]
operator|=
name|gidc
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the user name for this uid, or NULL if it's not found. */
end_comment

begin_function
name|char
modifier|*
name|getuserbyid
parameter_list|(
name|uid_t
name|uid
parameter_list|)
block|{
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|struct
name|uidc
modifier|*
name|uidc
decl_stmt|,
modifier|*
name|uidc2
decl_stmt|;
name|uint32_t
name|key
decl_stmt|,
name|key2
decl_stmt|;
name|key
operator|=
name|uid
operator|%
name|UIDTONAME_SZ
expr_stmt|;
name|uid_lock
argument_list|()
expr_stmt|;
name|uidc
operator|=
name|uidtoname
index|[
name|key
index|]
expr_stmt|;
while|while
condition|(
name|uidc
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|uidc
operator|->
name|uid
operator|==
name|uid
condition|)
break|break;
name|uidc
operator|=
name|uidc
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|uidc
operator|==
name|NULL
condition|)
block|{
comment|/* We didn't find this uid, look it up and add it. */
name|uidc
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|uidc
argument_list|)
argument_list|)
expr_stmt|;
name|uidc
operator|->
name|uid
operator|=
name|uid
expr_stmt|;
name|pw
operator|=
name|getpwuid
argument_list|(
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|!=
name|NULL
condition|)
block|{
comment|/* This uid is in the password file. */
name|uidc
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|uidc
operator|->
name|valid
operator|=
literal|1
expr_stmt|;
comment|/* Also add it to the name -> gid table. */
name|uidc2
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|uidc
argument_list|)
argument_list|)
expr_stmt|;
name|uidc2
operator|->
name|uid
operator|=
name|uid
expr_stmt|;
name|uidc2
operator|->
name|name
operator|=
name|uidc
operator|->
name|name
expr_stmt|;
comment|/* We reuse the pointer. */
name|uidc2
operator|->
name|valid
operator|=
literal|1
expr_stmt|;
name|key2
operator|=
name|hash
argument_list|(
name|uidc
operator|->
name|name
argument_list|)
operator|%
name|NAMETOUID_SZ
expr_stmt|;
name|uidc_insert
argument_list|(
name|nametouid
argument_list|,
name|uidc2
argument_list|,
name|key2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Add a miss entry for this uid. */
name|uidc
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
name|uidc
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
block|}
name|uidc_insert
argument_list|(
name|uidtoname
argument_list|,
name|uidc
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
comment|/* It is safe to unlock here since the cache structure 	   is not going to get freed or changed. */
name|uid_unlock
argument_list|()
expr_stmt|;
return|return
operator|(
name|uidc
operator|->
name|name
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the group name for this gid, or NULL if it's not found. */
end_comment

begin_function
name|char
modifier|*
name|getgroupbyid
parameter_list|(
name|gid_t
name|gid
parameter_list|)
block|{
name|struct
name|group
modifier|*
name|gr
decl_stmt|;
name|struct
name|gidc
modifier|*
name|gidc
decl_stmt|,
modifier|*
name|gidc2
decl_stmt|;
name|uint32_t
name|key
decl_stmt|,
name|key2
decl_stmt|;
name|key
operator|=
name|gid
operator|%
name|GIDTONAME_SZ
expr_stmt|;
name|gid_lock
argument_list|()
expr_stmt|;
name|gidc
operator|=
name|gidtoname
index|[
name|key
index|]
expr_stmt|;
while|while
condition|(
name|gidc
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|gidc
operator|->
name|gid
operator|==
name|gid
condition|)
break|break;
name|gidc
operator|=
name|gidc
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|gidc
operator|==
name|NULL
condition|)
block|{
comment|/* We didn't find this gid, look it up and add it. */
name|gidc
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|gidc
argument_list|)
argument_list|)
expr_stmt|;
name|gidc
operator|->
name|gid
operator|=
name|gid
expr_stmt|;
name|gr
operator|=
name|getgrgid
argument_list|(
name|gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|gr
operator|!=
name|NULL
condition|)
block|{
comment|/* This gid is in the group file. */
name|gidc
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|gr
operator|->
name|gr_name
argument_list|)
expr_stmt|;
name|gidc
operator|->
name|valid
operator|=
literal|1
expr_stmt|;
comment|/* Also add it to the name -> gid table. */
name|gidc2
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|gidc
argument_list|)
argument_list|)
expr_stmt|;
name|gidc2
operator|->
name|gid
operator|=
name|gid
expr_stmt|;
name|gidc2
operator|->
name|name
operator|=
name|gidc
operator|->
name|name
expr_stmt|;
comment|/* We reuse the pointer. */
name|gidc2
operator|->
name|valid
operator|=
literal|1
expr_stmt|;
name|key2
operator|=
name|hash
argument_list|(
name|gidc
operator|->
name|name
argument_list|)
operator|%
name|NAMETOGID_SZ
expr_stmt|;
name|gidc_insert
argument_list|(
name|nametogid
argument_list|,
name|gidc2
argument_list|,
name|key2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Add a miss entry for this gid. */
name|gidc
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
name|gidc
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
block|}
name|gidc_insert
argument_list|(
name|gidtoname
argument_list|,
name|gidc
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
comment|/* It is safe to unlock here since the cache structure 	   is not going to get freed or changed. */
name|gid_unlock
argument_list|()
expr_stmt|;
return|return
operator|(
name|gidc
operator|->
name|name
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Finds the uid for this user name.  If it's found, the gid is stored    in *uid and 0 is returned.  Otherwise, -1 is returned. */
end_comment

begin_function
name|int
name|getuidbyname
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uid_t
modifier|*
name|uid
parameter_list|)
block|{
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|struct
name|uidc
modifier|*
name|uidc
decl_stmt|,
modifier|*
name|uidc2
decl_stmt|;
name|uint32_t
name|key
decl_stmt|,
name|key2
decl_stmt|;
name|uid_lock
argument_list|()
expr_stmt|;
name|key
operator|=
name|hash
argument_list|(
name|name
argument_list|)
operator|%
name|NAMETOUID_SZ
expr_stmt|;
name|uidc
operator|=
name|nametouid
index|[
name|key
index|]
expr_stmt|;
while|while
condition|(
name|uidc
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|uidc
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|uidc
operator|=
name|uidc
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|uidc
operator|==
name|NULL
condition|)
block|{
name|uidc
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|uidc
argument_list|)
argument_list|)
expr_stmt|;
name|uidc
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|pw
operator|=
name|getpwnam
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|!=
name|NULL
condition|)
block|{
comment|/* This user name is in the password file. */
name|uidc
operator|->
name|valid
operator|=
literal|1
expr_stmt|;
name|uidc
operator|->
name|uid
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
comment|/* Also add it to the uid -> name table. */
name|uidc2
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|uidc
argument_list|)
argument_list|)
expr_stmt|;
name|uidc2
operator|->
name|name
operator|=
name|uidc
operator|->
name|name
expr_stmt|;
comment|/* We reuse the pointer. */
name|uidc2
operator|->
name|uid
operator|=
name|uidc
operator|->
name|uid
expr_stmt|;
name|uidc2
operator|->
name|valid
operator|=
literal|1
expr_stmt|;
name|key2
operator|=
name|uidc2
operator|->
name|uid
operator|%
name|UIDTONAME_SZ
expr_stmt|;
name|uidc_insert
argument_list|(
name|uidtoname
argument_list|,
name|uidc2
argument_list|,
name|key2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Add a miss entry for this user name. */
name|uidc
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
name|uidc
operator|->
name|uid
operator|=
operator|(
name|uid_t
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* Should not be accessed. */
block|}
name|uidc_insert
argument_list|(
name|nametouid
argument_list|,
name|uidc
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
comment|/* It is safe to unlock here since the cache structure 	   is not going to get freed or changed. */
name|uid_unlock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|uidc
operator|->
name|valid
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|uid
operator|=
name|uidc
operator|->
name|uid
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Finds the gid for this group name.  If it's found, the gid is stored    in *gid and 0 is returned.  Otherwise, -1 is returned. */
end_comment

begin_function
name|int
name|getgidbyname
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|gid_t
modifier|*
name|gid
parameter_list|)
block|{
name|struct
name|group
modifier|*
name|gr
decl_stmt|;
name|struct
name|gidc
modifier|*
name|gidc
decl_stmt|,
modifier|*
name|gidc2
decl_stmt|;
name|uint32_t
name|key
decl_stmt|,
name|key2
decl_stmt|;
name|gid_lock
argument_list|()
expr_stmt|;
name|key
operator|=
name|hash
argument_list|(
name|name
argument_list|)
operator|%
name|NAMETOGID_SZ
expr_stmt|;
name|gidc
operator|=
name|nametogid
index|[
name|key
index|]
expr_stmt|;
while|while
condition|(
name|gidc
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|gidc
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|gidc
operator|=
name|gidc
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|gidc
operator|==
name|NULL
condition|)
block|{
name|gidc
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|gidc
argument_list|)
argument_list|)
expr_stmt|;
name|gidc
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|gr
operator|=
name|getgrnam
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|gr
operator|!=
name|NULL
condition|)
block|{
comment|/* This group name is in the group file. */
name|gidc
operator|->
name|gid
operator|=
name|gr
operator|->
name|gr_gid
expr_stmt|;
name|gidc
operator|->
name|valid
operator|=
literal|1
expr_stmt|;
comment|/* Also add it to the gid -> name table. */
name|gidc2
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|gidc
argument_list|)
argument_list|)
expr_stmt|;
name|gidc2
operator|->
name|name
operator|=
name|gidc
operator|->
name|name
expr_stmt|;
comment|/* We reuse the pointer. */
name|gidc2
operator|->
name|gid
operator|=
name|gidc
operator|->
name|gid
expr_stmt|;
name|gidc2
operator|->
name|valid
operator|=
literal|1
expr_stmt|;
name|key2
operator|=
name|gidc2
operator|->
name|gid
operator|%
name|GIDTONAME_SZ
expr_stmt|;
name|gidc_insert
argument_list|(
name|gidtoname
argument_list|,
name|gidc2
argument_list|,
name|key2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Add a miss entry for this group name. */
name|gidc
operator|->
name|gid
operator|=
operator|(
name|gid_t
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* Should not be accessed. */
name|gidc
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
block|}
name|gidc_insert
argument_list|(
name|nametogid
argument_list|,
name|gidc
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
comment|/* It is safe to unlock here since the cache structure 	   is not going to get freed or changed. */
name|gid_unlock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|gidc
operator|->
name|valid
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|gid
operator|=
name|gidc
operator|->
name|gid
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Initialize the cache structures. */
end_comment

begin_function
name|void
name|idcache_init
parameter_list|(
name|void
parameter_list|)
block|{
name|pthread_mutex_init
argument_list|(
operator|&
name|uid_mtx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pthread_mutex_init
argument_list|(
operator|&
name|gid_mtx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|uidtoname
operator|=
name|xmalloc
argument_list|(
name|UIDTONAME_SZ
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|uidc
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|gidtoname
operator|=
name|xmalloc
argument_list|(
name|GIDTONAME_SZ
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|gidc
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|nametouid
operator|=
name|xmalloc
argument_list|(
name|NAMETOUID_SZ
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|uidc
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|nametogid
operator|=
name|xmalloc
argument_list|(
name|NAMETOGID_SZ
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|gidc
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|uidtoname
argument_list|,
literal|0
argument_list|,
name|UIDTONAME_SZ
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|uidc
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|gidtoname
argument_list|,
literal|0
argument_list|,
name|GIDTONAME_SZ
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|gidc
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|nametouid
argument_list|,
literal|0
argument_list|,
name|NAMETOUID_SZ
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|uidc
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|nametogid
argument_list|,
literal|0
argument_list|,
name|NAMETOGID_SZ
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|gidc
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Cleanup the cache structures. */
end_comment

begin_function
name|void
name|idcache_fini
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|uidc
modifier|*
name|uidc
decl_stmt|,
modifier|*
name|uidc2
decl_stmt|;
name|struct
name|gidc
modifier|*
name|gidc
decl_stmt|,
modifier|*
name|gidc2
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UIDTONAME_SZ
condition|;
name|i
operator|++
control|)
block|{
name|uidc
operator|=
name|uidtoname
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|uidc
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|uidc
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|uidc
operator|->
name|valid
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|uidc
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|uidc2
operator|=
name|uidc
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|uidc
argument_list|)
expr_stmt|;
name|uidc
operator|=
name|uidc2
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|uidtoname
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NAMETOUID_SZ
condition|;
name|i
operator|++
control|)
block|{
name|uidc
operator|=
name|nametouid
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|uidc
operator|!=
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|uidc
operator|->
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* If it's a valid entry, it has been added to both the 			   uidtoname and nametouid tables, and the name pointer 			   has been reused for both entries.  Thus, the name 			   pointer has already been freed in the loop above. */
if|if
condition|(
operator|!
name|uidc
operator|->
name|valid
condition|)
name|free
argument_list|(
name|uidc
operator|->
name|name
argument_list|)
expr_stmt|;
name|uidc2
operator|=
name|uidc
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|uidc
argument_list|)
expr_stmt|;
name|uidc
operator|=
name|uidc2
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|nametouid
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GIDTONAME_SZ
condition|;
name|i
operator|++
control|)
block|{
name|gidc
operator|=
name|gidtoname
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|gidc
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|gidc
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|gidc
operator|->
name|valid
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|gidc
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|gidc2
operator|=
name|gidc
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|gidc
argument_list|)
expr_stmt|;
name|gidc
operator|=
name|gidc2
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|gidtoname
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NAMETOGID_SZ
condition|;
name|i
operator|++
control|)
block|{
name|gidc
operator|=
name|nametogid
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|gidc
operator|!=
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|gidc
operator|->
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* See above comment. */
if|if
condition|(
operator|!
name|gidc
operator|->
name|valid
condition|)
name|free
argument_list|(
name|gidc
operator|->
name|name
argument_list|)
expr_stmt|;
name|gidc2
operator|=
name|gidc
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|gidc
argument_list|)
expr_stmt|;
name|gidc
operator|=
name|gidc2
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|nametogid
argument_list|)
expr_stmt|;
name|pthread_mutex_destroy
argument_list|(
operator|&
name|uid_mtx
argument_list|)
expr_stmt|;
name|pthread_mutex_destroy
argument_list|(
operator|&
name|gid_mtx
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

