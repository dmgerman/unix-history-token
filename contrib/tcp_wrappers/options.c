begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * General skeleton for adding options to the access control language. The   * features offered by this module are documented in the hosts_options(5)   * manual page (source file: hosts_options.5, "nroff -man" format).   *    * Notes and warnings for those who want to add features:   *    * In case of errors, abort options processing and deny access. There are too   * many irreversible side effects to make error recovery feasible. For   * example, it makes no sense to continue after we have already changed the   * userid.   *    * In case of errors, do not terminate the process: the routines might be   * called from a long-running daemon that should run forever. Instead, call   * tcpd_jump() which does a non-local goto back into the hosts_access()   * routine.   *    * In case of severe errors, use clean_exit() instead of directly calling   * exit(), or the inetd may loop on an UDP request.   *    * In verification mode (for example, with the "tcpdmatch" command) the   * "dry_run" flag is set. In this mode, an option function should just "say"   * what it is going to do instead of really doing it.   *    * Some option functions do not return (for example, the twist option passes   * control to another program). In verification mode (dry_run flag is set)   * such options should clear the "dry_run" flag to inform the caller of this   * course of action.   */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#) options.c 1.17 96/02/11 17:01:31"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* System libraries. */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_define
define|#
directive|define
name|SYSLOG_NAMES
end_define

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MAXPATHNAMELEN
end_ifndef

begin_define
define|#
directive|define
name|MAXPATHNAMELEN
value|BUFSIZ
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Local stuff. */
end_comment

begin_include
include|#
directive|include
file|"tcpd.h"
end_include

begin_comment
comment|/* Options runtime support. */
end_comment

begin_decl_stmt
name|int
name|dry_run
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flag set in verification mode */
end_comment

begin_decl_stmt
specifier|extern
name|jmp_buf
name|tcpd_buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tcpd_jump() support */
end_comment

begin_comment
comment|/* Options parser support. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|whitespace_eq
index|[]
init|=
literal|"= \t\r\n"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|whitespace
value|(whitespace_eq + 1)
end_define

begin_function_decl
specifier|static
name|char
modifier|*
name|get_field
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* chew :-delimited field off string */
end_comment

begin_function_decl
specifier|static
name|char
modifier|*
name|chop_string
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* strip leading and trailing blanks */
end_comment

begin_comment
comment|/* List of functions that implement the options. Add yours here. */
end_comment

begin_function_decl
specifier|static
name|void
name|user_option
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* execute "user name.group" option */
end_comment

begin_function_decl
specifier|static
name|void
name|group_option
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* execute "group name" option */
end_comment

begin_function_decl
specifier|static
name|void
name|umask_option
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* execute "umask mask" option */
end_comment

begin_function_decl
specifier|static
name|void
name|linger_option
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* execute "linger time" option */
end_comment

begin_function_decl
specifier|static
name|void
name|keepalive_option
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* execute "keepalive" option */
end_comment

begin_function_decl
specifier|static
name|void
name|spawn_option
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* execute "spawn command" option */
end_comment

begin_function_decl
specifier|static
name|void
name|twist_option
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* execute "twist command" option */
end_comment

begin_function_decl
specifier|static
name|void
name|rfc931_option
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* execute "rfc931" option */
end_comment

begin_function_decl
specifier|static
name|void
name|setenv_option
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* execute "setenv name value" */
end_comment

begin_function_decl
specifier|static
name|void
name|nice_option
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* execute "nice" option */
end_comment

begin_function_decl
specifier|static
name|void
name|severity_option
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* execute "severity value" */
end_comment

begin_function_decl
specifier|static
name|void
name|allow_option
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* execute "allow" option */
end_comment

begin_function_decl
specifier|static
name|void
name|deny_option
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* execute "deny" option */
end_comment

begin_function_decl
specifier|static
name|void
name|banners_option
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* execute "banners path" option */
end_comment

begin_comment
comment|/* Structure of the options table. */
end_comment

begin_struct
struct|struct
name|option
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* keyword name, case is ignored */
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
comment|/* function that does the real work */
name|int
name|flags
decl_stmt|;
comment|/* see below... */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NEED_ARG
value|(1<<1)
end_define

begin_comment
comment|/* option requires argument */
end_comment

begin_define
define|#
directive|define
name|USE_LAST
value|(1<<2)
end_define

begin_comment
comment|/* option must be last */
end_comment

begin_define
define|#
directive|define
name|OPT_ARG
value|(1<<3)
end_define

begin_comment
comment|/* option has optional argument */
end_comment

begin_define
define|#
directive|define
name|EXPAND_ARG
value|(1<<4)
end_define

begin_comment
comment|/* do %x expansion on argument */
end_comment

begin_define
define|#
directive|define
name|need_arg
parameter_list|(
name|o
parameter_list|)
value|((o)->flags& NEED_ARG)
end_define

begin_define
define|#
directive|define
name|opt_arg
parameter_list|(
name|o
parameter_list|)
value|((o)->flags& OPT_ARG)
end_define

begin_define
define|#
directive|define
name|permit_arg
parameter_list|(
name|o
parameter_list|)
value|((o)->flags& (NEED_ARG | OPT_ARG))
end_define

begin_define
define|#
directive|define
name|use_last
parameter_list|(
name|o
parameter_list|)
value|((o)->flags& USE_LAST)
end_define

begin_define
define|#
directive|define
name|expand_arg
parameter_list|(
name|o
parameter_list|)
value|((o)->flags& EXPAND_ARG)
end_define

begin_comment
comment|/* List of known keywords. Add yours here. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|option
name|option_table
index|[]
init|=
block|{
literal|"user"
block|,
name|user_option
block|,
name|NEED_ARG
block|,
literal|"group"
block|,
name|group_option
block|,
name|NEED_ARG
block|,
literal|"umask"
block|,
name|umask_option
block|,
name|NEED_ARG
block|,
literal|"linger"
block|,
name|linger_option
block|,
name|NEED_ARG
block|,
literal|"keepalive"
block|,
name|keepalive_option
block|,
literal|0
block|,
literal|"spawn"
block|,
name|spawn_option
block|,
name|NEED_ARG
operator||
name|EXPAND_ARG
block|,
literal|"twist"
block|,
name|twist_option
block|,
name|NEED_ARG
operator||
name|EXPAND_ARG
operator||
name|USE_LAST
block|,
literal|"rfc931"
block|,
name|rfc931_option
block|,
name|OPT_ARG
block|,
literal|"setenv"
block|,
name|setenv_option
block|,
name|NEED_ARG
operator||
name|EXPAND_ARG
block|,
literal|"nice"
block|,
name|nice_option
block|,
name|OPT_ARG
block|,
literal|"severity"
block|,
name|severity_option
block|,
name|NEED_ARG
block|,
literal|"allow"
block|,
name|allow_option
block|,
name|USE_LAST
block|,
literal|"deny"
block|,
name|deny_option
block|,
name|USE_LAST
block|,
literal|"banners"
block|,
name|banners_option
block|,
name|NEED_ARG
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* process_options - process access control options */
end_comment

begin_function
name|void
name|process_options
parameter_list|(
name|options
parameter_list|,
name|request
parameter_list|)
name|char
modifier|*
name|options
decl_stmt|;
name|struct
name|request_info
modifier|*
name|request
decl_stmt|;
block|{
name|char
modifier|*
name|key
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|char
modifier|*
name|curr_opt
decl_stmt|;
name|char
modifier|*
name|next_opt
decl_stmt|;
name|struct
name|option
modifier|*
name|op
decl_stmt|;
name|char
name|bf
index|[
name|BUFSIZ
index|]
decl_stmt|;
for|for
control|(
name|curr_opt
operator|=
name|get_field
argument_list|(
name|options
argument_list|)
init|;
name|curr_opt
condition|;
name|curr_opt
operator|=
name|next_opt
control|)
block|{
name|next_opt
operator|=
name|get_field
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Separate the option into name and value parts. For backwards 	 * compatibility we ignore exactly one '=' between name and value. 	 */
name|curr_opt
operator|=
name|chop_string
argument_list|(
name|curr_opt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|value
operator|=
name|curr_opt
operator|+
name|strcspn
argument_list|(
name|curr_opt
argument_list|,
name|whitespace_eq
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|value
operator|!=
literal|'='
condition|)
block|{
operator|*
name|value
operator|++
operator|=
literal|0
expr_stmt|;
name|value
operator|+=
name|strspn
argument_list|(
name|value
argument_list|,
name|whitespace
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|value
operator|==
literal|'='
condition|)
block|{
operator|*
name|value
operator|++
operator|=
literal|0
expr_stmt|;
name|value
operator|+=
name|strspn
argument_list|(
name|value
argument_list|,
name|whitespace
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|value
operator|==
literal|0
condition|)
name|value
operator|=
literal|0
expr_stmt|;
name|key
operator|=
name|curr_opt
expr_stmt|;
comment|/* 	 * Disallow missing option names (and empty option fields). 	 */
if|if
condition|(
operator|*
name|key
operator|==
literal|0
condition|)
name|tcpd_jump
argument_list|(
literal|"missing option name"
argument_list|)
expr_stmt|;
comment|/* 	 * Lookup the option-specific info and do some common error checks. 	 * Delegate option-specific processing to the specific functions. 	 */
for|for
control|(
name|op
operator|=
name|option_table
init|;
name|op
operator|->
name|name
operator|&&
name|STR_NE
argument_list|(
name|op
operator|->
name|name
argument_list|,
name|key
argument_list|)
condition|;
name|op
operator|++
control|)
comment|/* VOID */
empty_stmt|;
if|if
condition|(
name|op
operator|->
name|name
operator|==
literal|0
condition|)
name|tcpd_jump
argument_list|(
literal|"bad option name: \"%s\""
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|value
operator|&&
name|need_arg
argument_list|(
name|op
argument_list|)
condition|)
name|tcpd_jump
argument_list|(
literal|"option \"%s\" requires value"
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|&&
operator|!
name|permit_arg
argument_list|(
name|op
argument_list|)
condition|)
name|tcpd_jump
argument_list|(
literal|"option \"%s\" requires no value"
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_opt
operator|&&
name|use_last
argument_list|(
name|op
argument_list|)
condition|)
name|tcpd_jump
argument_list|(
literal|"option \"%s\" must be at end"
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|&&
name|expand_arg
argument_list|(
name|op
argument_list|)
condition|)
name|value
operator|=
name|chop_string
argument_list|(
name|percent_x
argument_list|(
name|bf
argument_list|,
sizeof|sizeof
argument_list|(
name|bf
argument_list|)
argument_list|,
name|value
argument_list|,
name|request
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hosts_access_verbose
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"option:   %s %s"
argument_list|,
name|key
argument_list|,
name|value
condition|?
name|value
else|:
literal|""
argument_list|)
expr_stmt|;
operator|(
operator|*
operator|(
name|op
operator|->
name|func
operator|)
operator|)
operator|(
name|value
operator|,
name|request
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* allow_option - grant access */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|allow_option
parameter_list|(
name|value
parameter_list|,
name|request
parameter_list|)
name|char
modifier|*
name|value
decl_stmt|;
name|struct
name|request_info
modifier|*
name|request
decl_stmt|;
block|{
name|longjmp
argument_list|(
name|tcpd_buf
argument_list|,
name|AC_PERMIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* deny_option - deny access */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|deny_option
parameter_list|(
name|value
parameter_list|,
name|request
parameter_list|)
name|char
modifier|*
name|value
decl_stmt|;
name|struct
name|request_info
modifier|*
name|request
decl_stmt|;
block|{
name|longjmp
argument_list|(
name|tcpd_buf
argument_list|,
name|AC_DENY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* banners_option - expand %<char>, terminate each line with CRLF */
end_comment

begin_function
specifier|static
name|void
name|banners_option
parameter_list|(
name|value
parameter_list|,
name|request
parameter_list|)
name|char
modifier|*
name|value
decl_stmt|;
name|struct
name|request_info
modifier|*
name|request
decl_stmt|;
block|{
name|char
name|path
index|[
name|MAXPATHNAMELEN
index|]
decl_stmt|;
name|char
name|ibuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
name|obuf
index|[
literal|2
operator|*
name|BUFSIZ
index|]
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|sprintf
argument_list|(
name|path
argument_list|,
literal|"%s/%s"
argument_list|,
name|value
argument_list|,
name|eval_daemon
argument_list|(
name|request
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|path
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|ch
operator|=
name|fgetc
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|write
argument_list|(
name|request
operator|->
name|fd
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ungetc
argument_list|(
name|ch
argument_list|,
name|fp
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|ibuf
argument_list|,
sizeof|sizeof
argument_list|(
name|ibuf
argument_list|)
operator|-
literal|1
argument_list|,
name|fp
argument_list|)
condition|)
block|{
if|if
condition|(
name|split_at
argument_list|(
name|ibuf
argument_list|,
literal|'\n'
argument_list|)
condition|)
name|strcat
argument_list|(
name|ibuf
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
name|percent_x
argument_list|(
name|obuf
argument_list|,
sizeof|sizeof
argument_list|(
name|obuf
argument_list|)
argument_list|,
name|ibuf
argument_list|,
name|request
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|request
operator|->
name|fd
argument_list|,
name|obuf
argument_list|,
name|strlen
argument_list|(
name|obuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stat
argument_list|(
name|value
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
name|tcpd_warn
argument_list|(
literal|"%s: %m"
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* group_option - switch group id */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|group_option
parameter_list|(
name|value
parameter_list|,
name|request
parameter_list|)
name|char
modifier|*
name|value
decl_stmt|;
name|struct
name|request_info
modifier|*
name|request
decl_stmt|;
block|{
name|struct
name|group
modifier|*
name|grp
decl_stmt|;
name|struct
name|group
modifier|*
name|getgrnam
parameter_list|()
function_decl|;
if|if
condition|(
operator|(
name|grp
operator|=
name|getgrnam
argument_list|(
name|value
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|tcpd_jump
argument_list|(
literal|"unknown group: \"%s\""
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|endgrent
argument_list|()
expr_stmt|;
if|if
condition|(
name|dry_run
operator|==
literal|0
operator|&&
name|setgid
argument_list|(
name|grp
operator|->
name|gr_gid
argument_list|)
condition|)
name|tcpd_jump
argument_list|(
literal|"setgid(%s): %m"
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* user_option - switch user id */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|user_option
parameter_list|(
name|value
parameter_list|,
name|request
parameter_list|)
name|char
modifier|*
name|value
decl_stmt|;
name|struct
name|request_info
modifier|*
name|request
decl_stmt|;
block|{
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
name|struct
name|passwd
modifier|*
name|getpwnam
parameter_list|()
function_decl|;
name|char
modifier|*
name|group
decl_stmt|;
if|if
condition|(
operator|(
name|group
operator|=
name|split_at
argument_list|(
name|value
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|group_option
argument_list|(
name|group
argument_list|,
name|request
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pwd
operator|=
name|getpwnam
argument_list|(
name|value
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|tcpd_jump
argument_list|(
literal|"unknown user: \"%s\""
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|endpwent
argument_list|()
expr_stmt|;
if|if
condition|(
name|dry_run
operator|==
literal|0
operator|&&
name|setuid
argument_list|(
name|pwd
operator|->
name|pw_uid
argument_list|)
condition|)
name|tcpd_jump
argument_list|(
literal|"setuid(%s): %m"
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* umask_option - set file creation mask */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|umask_option
parameter_list|(
name|value
parameter_list|,
name|request
parameter_list|)
name|char
modifier|*
name|value
decl_stmt|;
name|struct
name|request_info
modifier|*
name|request
decl_stmt|;
block|{
name|unsigned
name|mask
decl_stmt|;
name|char
name|junk
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|value
argument_list|,
literal|"%o%c"
argument_list|,
operator|&
name|mask
argument_list|,
operator|&
name|junk
argument_list|)
operator|!=
literal|1
operator|||
operator|(
name|mask
operator|&
literal|0777
operator|)
operator|!=
name|mask
condition|)
name|tcpd_jump
argument_list|(
literal|"bad umask value: \"%s\""
argument_list|,
name|value
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* spawn_option - spawn a shell command and wait */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|spawn_option
parameter_list|(
name|value
parameter_list|,
name|request
parameter_list|)
name|char
modifier|*
name|value
decl_stmt|;
name|struct
name|request_info
modifier|*
name|request
decl_stmt|;
block|{
if|if
condition|(
name|dry_run
operator|==
literal|0
condition|)
name|shell_cmd
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* linger_option - set the socket linger time (Marc Boucher<marc@cam.org>) */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|linger_option
parameter_list|(
name|value
parameter_list|,
name|request
parameter_list|)
name|char
modifier|*
name|value
decl_stmt|;
name|struct
name|request_info
modifier|*
name|request
decl_stmt|;
block|{
name|struct
name|linger
name|linger
decl_stmt|;
name|char
name|junk
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|value
argument_list|,
literal|"%d%c"
argument_list|,
operator|&
name|linger
operator|.
name|l_linger
argument_list|,
operator|&
name|junk
argument_list|)
operator|!=
literal|1
operator|||
name|linger
operator|.
name|l_linger
operator|<
literal|0
condition|)
name|tcpd_jump
argument_list|(
literal|"bad linger value: \"%s\""
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|dry_run
operator|==
literal|0
condition|)
block|{
name|linger
operator|.
name|l_onoff
operator|=
operator|(
name|linger
operator|.
name|l_linger
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|request
operator|->
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_LINGER
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|linger
argument_list|,
sizeof|sizeof
argument_list|(
name|linger
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|tcpd_warn
argument_list|(
literal|"setsockopt SO_LINGER %d: %m"
argument_list|,
name|linger
operator|.
name|l_linger
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* keepalive_option - set the socket keepalive option */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|keepalive_option
parameter_list|(
name|value
parameter_list|,
name|request
parameter_list|)
name|char
modifier|*
name|value
decl_stmt|;
name|struct
name|request_info
modifier|*
name|request
decl_stmt|;
block|{
specifier|static
name|int
name|on
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|dry_run
operator|==
literal|0
operator|&&
name|setsockopt
argument_list|(
name|request
operator|->
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_KEEPALIVE
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|tcpd_warn
argument_list|(
literal|"setsockopt SO_KEEPALIVE: %m"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* nice_option - set nice value */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|nice_option
parameter_list|(
name|value
parameter_list|,
name|request
parameter_list|)
name|char
modifier|*
name|value
decl_stmt|;
name|struct
name|request_info
modifier|*
name|request
decl_stmt|;
block|{
name|int
name|niceval
init|=
literal|10
decl_stmt|;
name|char
name|junk
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
name|sscanf
argument_list|(
name|value
argument_list|,
literal|"%d%c"
argument_list|,
operator|&
name|niceval
argument_list|,
operator|&
name|junk
argument_list|)
operator|!=
literal|1
condition|)
name|tcpd_jump
argument_list|(
literal|"bad nice value: \"%s\""
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|dry_run
operator|==
literal|0
operator|&&
name|nice
argument_list|(
name|niceval
argument_list|)
operator|<
literal|0
condition|)
name|tcpd_warn
argument_list|(
literal|"nice(%d): %m"
argument_list|,
name|niceval
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* twist_option - replace process by shell command */
end_comment

begin_function
specifier|static
name|void
name|twist_option
parameter_list|(
name|value
parameter_list|,
name|request
parameter_list|)
name|char
modifier|*
name|value
decl_stmt|;
name|struct
name|request_info
modifier|*
name|request
decl_stmt|;
block|{
name|char
modifier|*
name|error
decl_stmt|;
if|if
condition|(
name|dry_run
operator|!=
literal|0
condition|)
block|{
name|dry_run
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|resident
operator|>
literal|0
condition|)
name|tcpd_jump
argument_list|(
literal|"twist option in resident process"
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|deny_severity
argument_list|,
literal|"twist %s to %s"
argument_list|,
name|eval_client
argument_list|(
name|request
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Before switching to the shell, set up stdin, stdout and stderr. */
define|#
directive|define
name|maybe_dup2
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
value|((from == to) ? to : (close(to), dup(from)))
if|if
condition|(
name|maybe_dup2
argument_list|(
name|request
operator|->
name|fd
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
operator|||
name|maybe_dup2
argument_list|(
name|request
operator|->
name|fd
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
operator|||
name|maybe_dup2
argument_list|(
name|request
operator|->
name|fd
argument_list|,
literal|2
argument_list|)
operator|!=
literal|2
condition|)
block|{
name|error
operator|=
literal|"twist_option: dup: %m"
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|request
operator|->
name|fd
operator|>
literal|2
condition|)
name|close
argument_list|(
name|request
operator|->
name|fd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|execl
argument_list|(
literal|"/bin/sh"
argument_list|,
literal|"sh"
argument_list|,
literal|"-c"
argument_list|,
name|value
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
literal|"twist_option: /bin/sh: %m"
expr_stmt|;
block|}
comment|/* Something went wrong: we MUST terminate the process. */
name|tcpd_warn
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|clean_exit
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* rfc931_option - look up remote user name */
end_comment

begin_function
specifier|static
name|void
name|rfc931_option
parameter_list|(
name|value
parameter_list|,
name|request
parameter_list|)
name|char
modifier|*
name|value
decl_stmt|;
name|struct
name|request_info
modifier|*
name|request
decl_stmt|;
block|{
name|int
name|timeout
decl_stmt|;
name|char
name|junk
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|value
argument_list|,
literal|"%d%c"
argument_list|,
operator|&
name|timeout
argument_list|,
operator|&
name|junk
argument_list|)
operator|!=
literal|1
operator|||
name|timeout
operator|<=
literal|0
condition|)
name|tcpd_jump
argument_list|(
literal|"bad rfc931 timeout: \"%s\""
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|rfc931_timeout
operator|=
name|timeout
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|eval_user
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* setenv_option - set environment variable */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|setenv_option
parameter_list|(
name|value
parameter_list|,
name|request
parameter_list|)
name|char
modifier|*
name|value
decl_stmt|;
name|struct
name|request_info
modifier|*
name|request
decl_stmt|;
block|{
name|char
modifier|*
name|var_value
decl_stmt|;
if|if
condition|(
operator|*
operator|(
name|var_value
operator|=
name|value
operator|+
name|strcspn
argument_list|(
name|value
argument_list|,
name|whitespace
argument_list|)
operator|)
condition|)
operator|*
name|var_value
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|setenv
argument_list|(
name|chop_string
argument_list|(
name|value
argument_list|)
argument_list|,
name|chop_string
argument_list|(
name|var_value
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|tcpd_jump
argument_list|(
literal|"memory allocation failure"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* severity_map - lookup facility or severity value */
end_comment

begin_function
specifier|static
name|int
name|severity_map
parameter_list|(
name|table
parameter_list|,
name|name
parameter_list|)
name|CODE
modifier|*
name|table
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|CODE
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|table
init|;
name|t
operator|->
name|c_name
condition|;
name|t
operator|++
control|)
if|if
condition|(
name|STR_EQ
argument_list|(
name|t
operator|->
name|c_name
argument_list|,
name|name
argument_list|)
condition|)
return|return
operator|(
name|t
operator|->
name|c_val
operator|)
return|;
name|tcpd_jump
argument_list|(
literal|"bad syslog facility or severity: \"%s\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/* severity_option - change logging severity for this event (Dave Mitchell) */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|severity_option
parameter_list|(
name|value
parameter_list|,
name|request
parameter_list|)
name|char
modifier|*
name|value
decl_stmt|;
name|struct
name|request_info
modifier|*
name|request
decl_stmt|;
block|{
name|char
modifier|*
name|level
init|=
name|split_at
argument_list|(
name|value
argument_list|,
literal|'.'
argument_list|)
decl_stmt|;
name|allow_severity
operator|=
name|deny_severity
operator|=
name|level
condition|?
name|severity_map
argument_list|(
name|facilitynames
argument_list|,
name|value
argument_list|)
operator||
name|severity_map
argument_list|(
name|prioritynames
argument_list|,
name|level
argument_list|)
else|:
name|severity_map
argument_list|(
name|prioritynames
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* get_field - return pointer to next field in string */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_field
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|last
init|=
literal|""
decl_stmt|;
name|char
modifier|*
name|src
decl_stmt|;
name|char
modifier|*
name|dst
decl_stmt|;
name|char
modifier|*
name|ret
decl_stmt|;
name|int
name|ch
decl_stmt|;
comment|/*      * This function returns pointers to successive fields within a given      * string. ":" is the field separator; warn if the rule ends in one. It      * replaces a "\:" sequence by ":", without treating the result of      * substitution as field terminator. A null argument means resume search      * where the previous call terminated. This function destroys its      * argument.      *       * Work from explicit source or from memory. While processing \: we      * overwrite the input. This way we do not have to maintain buffers for      * copies of input fields.      */
name|src
operator|=
name|dst
operator|=
name|ret
operator|=
operator|(
name|string
condition|?
name|string
else|:
name|last
operator|)
expr_stmt|;
if|if
condition|(
name|src
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
name|ch
operator|=
operator|*
name|src
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|src
operator|==
literal|0
condition|)
name|tcpd_warn
argument_list|(
literal|"rule ends in \":\""
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ch
operator|==
literal|'\\'
operator|&&
name|src
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
name|src
operator|++
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
block|}
name|last
operator|=
name|src
expr_stmt|;
operator|*
name|dst
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* chop_string - strip leading and trailing blanks from string */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|chop_string
parameter_list|(
name|string
parameter_list|)
specifier|register
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|char
modifier|*
name|start
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|string
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
if|if
condition|(
name|start
operator|==
literal|0
condition|)
name|start
operator|=
name|cp
expr_stmt|;
name|end
operator|=
name|cp
expr_stmt|;
block|}
block|}
return|return
operator|(
name|start
condition|?
operator|(
name|end
index|[
literal|1
index|]
operator|=
literal|0
operator|,
name|start
operator|)
else|:
name|cp
operator|)
return|;
block|}
end_function

end_unit

