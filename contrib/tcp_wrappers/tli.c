begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tli_host() determines the type of transport (connected, connectionless),   * the transport address of a client host, and the transport address of a   * server endpoint. In addition, it provides methods to map a transport   * address to a printable host name or address. Socket address results are   * in static memory; tli structures are allocated from the heap.   *    * The result from the hostname lookup method is STRING_PARANOID when a host   * pretends to have someone elses name, or when a host name is available but   * could not be verified.   *    * Diagnostics are reported through syslog(3).   *    * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.   *   * $FreeBSD$   */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#) tli.c 1.15 97/03/21 19:27:25"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TLI
end_ifdef

begin_comment
comment|/* System libraries. */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stream.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/mkdev.h>
end_include

begin_include
include|#
directive|include
file|<sys/tiuser.h>
end_include

begin_include
include|#
directive|include
file|<sys/timod.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<netconfig.h>
end_include

begin_include
include|#
directive|include
file|<netdir.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_function_decl
specifier|extern
name|char
modifier|*
name|nc_sperror
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sys_nerr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|t_errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|t_errlist
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|t_nerr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local stuff. */
end_comment

begin_include
include|#
directive|include
file|"tcpd.h"
end_include

begin_comment
comment|/* Forward declarations. */
end_comment

begin_function_decl
specifier|static
name|void
name|tli_endpoints
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|netconfig
modifier|*
name|tli_transport
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tli_hostname
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tli_hostaddr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tli_cleanup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|tli_error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tli_sink
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* tli_host - look up endpoint addresses and install conversion methods */
end_comment

begin_function
name|void
name|tli_host
parameter_list|(
name|request
parameter_list|)
name|struct
name|request_info
modifier|*
name|request
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|INET6
specifier|static
name|struct
name|sockaddr_storage
name|client
decl_stmt|;
specifier|static
name|struct
name|sockaddr_storage
name|server
decl_stmt|;
else|#
directive|else
specifier|static
name|struct
name|sockaddr_in
name|client
decl_stmt|;
specifier|static
name|struct
name|sockaddr_in
name|server
decl_stmt|;
endif|#
directive|endif
comment|/*      * If we discover that we are using an IP transport, pretend we never      * were here. Otherwise, use the transport-independent method and stick      * to generic network addresses. XXX hard-coded protocol family name.      */
name|tli_endpoints
argument_list|(
name|request
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
operator|(
name|request
operator|->
name|config
operator|=
name|tli_transport
argument_list|(
name|request
operator|->
name|fd
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|STR_EQ
argument_list|(
name|request
operator|->
name|config
operator|->
name|nc_protofmly
argument_list|,
literal|"inet"
argument_list|)
operator|||
name|STR_EQ
argument_list|(
name|request
operator|->
name|config
operator|->
name|nc_protofmly
argument_list|,
literal|"inet6"
argument_list|)
operator|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|(
name|request
operator|->
name|config
operator|=
name|tli_transport
argument_list|(
name|request
operator|->
name|fd
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|STR_EQ
argument_list|(
name|request
operator|->
name|config
operator|->
name|nc_protofmly
argument_list|,
literal|"inet"
argument_list|)
condition|)
block|{
endif|#
directive|endif
if|if
condition|(
name|request
operator|->
name|client
operator|->
name|unit
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
name|client
operator|=
operator|*
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
name|request
operator|->
name|client
operator|->
name|unit
operator|->
name|addr
operator|.
name|buf
expr_stmt|;
name|request
operator|->
name|client
operator|->
name|sin
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|client
expr_stmt|;
else|#
directive|else
name|client
operator|=
operator|*
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|request
operator|->
name|client
operator|->
name|unit
operator|->
name|addr
operator|.
name|buf
expr_stmt|;
name|request
operator|->
name|client
operator|->
name|sin
operator|=
operator|&
name|client
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|request
operator|->
name|server
operator|->
name|unit
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
name|server
operator|=
operator|*
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
name|request
operator|->
name|server
operator|->
name|unit
operator|->
name|addr
operator|.
name|buf
expr_stmt|;
name|request
operator|->
name|server
operator|->
name|sin
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|server
expr_stmt|;
else|#
directive|else
name|server
operator|=
operator|*
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|request
operator|->
name|server
operator|->
name|unit
operator|->
name|addr
operator|.
name|buf
expr_stmt|;
name|request
operator|->
name|server
operator|->
name|sin
operator|=
operator|&
name|server
expr_stmt|;
endif|#
directive|endif
block|}
name|tli_cleanup
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|sock_methods
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|request
operator|->
name|hostname
operator|=
name|tli_hostname
expr_stmt|;
name|request
operator|->
name|hostaddr
operator|=
name|tli_hostaddr
expr_stmt|;
name|request
operator|->
name|cleanup
operator|=
name|tli_cleanup
expr_stmt|;
block|}
block|}
comment|/* tli_cleanup - cleanup some dynamically-allocated data structures */
specifier|static
name|void
name|tli_cleanup
parameter_list|(
name|request
parameter_list|)
name|struct
name|request_info
modifier|*
name|request
decl_stmt|;
block|{
if|if
condition|(
name|request
operator|->
name|config
operator|!=
literal|0
condition|)
name|freenetconfigent
argument_list|(
name|request
operator|->
name|config
argument_list|)
expr_stmt|;
if|if
condition|(
name|request
operator|->
name|client
operator|->
name|unit
operator|!=
literal|0
condition|)
name|t_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|request
operator|->
name|client
operator|->
name|unit
argument_list|,
name|T_UNITDATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|request
operator|->
name|server
operator|->
name|unit
operator|!=
literal|0
condition|)
name|t_free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|request
operator|->
name|server
operator|->
name|unit
argument_list|,
name|T_UNITDATA
argument_list|)
expr_stmt|;
block|}
comment|/* tli_endpoints - determine TLI client and server endpoint information */
specifier|static
name|void
name|tli_endpoints
parameter_list|(
name|request
parameter_list|)
name|struct
name|request_info
modifier|*
name|request
decl_stmt|;
block|{
name|struct
name|t_unitdata
modifier|*
name|server
decl_stmt|;
name|struct
name|t_unitdata
modifier|*
name|client
decl_stmt|;
name|int
name|fd
init|=
name|request
operator|->
name|fd
decl_stmt|;
name|int
name|flags
decl_stmt|;
comment|/*      * Determine the client endpoint address. With unconnected services, peek      * at the sender address of the pending protocol data unit without      * popping it off the receive queue. This trick works because only the      * address member of the unitdata structure has been allocated.      *       * Beware of successful returns with zero-length netbufs (for example,      * Solaris 2.3 with ticlts transport). The netdir(3) routines can't      * handle that. Assume connection-less transport when TI_GETPEERNAME      * produces no usable result, even when t_rcvudata() is unable to figure      * out the peer address. Better to hang than to loop.      */
if|if
condition|(
operator|(
name|client
operator|=
operator|(
expr|struct
name|t_unitdata
operator|*
operator|)
name|t_alloc
argument_list|(
name|fd
argument_list|,
name|T_UNITDATA
argument_list|,
name|T_ADDR
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|tcpd_warn
argument_list|(
literal|"t_alloc: %s"
argument_list|,
name|tli_error
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TI_GETPEERNAME
argument_list|,
operator|&
name|client
operator|->
name|addr
argument_list|)
operator|<
literal|0
operator|||
name|client
operator|->
name|addr
operator|.
name|len
operator|==
literal|0
condition|)
block|{
name|request
operator|->
name|sink
operator|=
name|tli_sink
expr_stmt|;
if|if
condition|(
name|t_rcvudata
argument_list|(
name|fd
argument_list|,
name|client
argument_list|,
operator|&
name|flags
argument_list|)
operator|<
literal|0
operator|||
name|client
operator|->
name|addr
operator|.
name|len
operator|==
literal|0
condition|)
block|{
name|tcpd_warn
argument_list|(
literal|"can't get client address: %s"
argument_list|,
name|tli_error
argument_list|()
argument_list|)
expr_stmt|;
name|t_free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|client
argument_list|,
name|T_UNITDATA
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|request
operator|->
name|client
operator|->
name|unit
operator|=
name|client
expr_stmt|;
comment|/*      * Look up the server endpoint address. This can be used for filtering on      * server address or name, or to look up the client user.      */
if|if
condition|(
operator|(
name|server
operator|=
operator|(
expr|struct
name|t_unitdata
operator|*
operator|)
name|t_alloc
argument_list|(
name|fd
argument_list|,
name|T_UNITDATA
argument_list|,
name|T_ADDR
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|tcpd_warn
argument_list|(
literal|"t_alloc: %s"
argument_list|,
name|tli_error
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TI_GETMYNAME
argument_list|,
operator|&
name|server
operator|->
name|addr
argument_list|)
operator|<
literal|0
condition|)
block|{
name|tcpd_warn
argument_list|(
literal|"TI_GETMYNAME: %m"
argument_list|)
expr_stmt|;
name|t_free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|server
argument_list|,
name|T_UNITDATA
argument_list|)
expr_stmt|;
return|return;
block|}
name|request
operator|->
name|server
operator|->
name|unit
operator|=
name|server
expr_stmt|;
block|}
comment|/* tli_transport - find out TLI transport type */
specifier|static
name|struct
name|netconfig
modifier|*
name|tli_transport
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
name|struct
name|stat
name|from_client
decl_stmt|;
name|struct
name|stat
name|from_config
decl_stmt|;
name|void
modifier|*
name|handlep
decl_stmt|;
name|struct
name|netconfig
modifier|*
name|config
decl_stmt|;
comment|/*      * Assuming that the network device is a clone device, we must compare      * the major device number of stdin to the minor device number of the      * devices listed in the netconfig table.      */
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|from_client
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tcpd_warn
argument_list|(
literal|"fstat(fd %d): %m"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|handlep
operator|=
name|setnetconfig
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|tcpd_warn
argument_list|(
literal|"setnetconfig: %m"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
while|while
condition|(
name|config
operator|=
name|getnetconfig
argument_list|(
name|handlep
argument_list|)
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|config
operator|->
name|nc_device
argument_list|,
operator|&
name|from_config
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|NO_CLONE_DEVICE
comment|/* 	 * If the network devices are not cloned (as is the case for 	 * Solaris 8 Beta), we must compare the major device numbers. 	 */
if|if
condition|(
name|major
argument_list|(
name|from_config
operator|.
name|st_rdev
argument_list|)
operator|==
name|major
argument_list|(
name|from_client
operator|.
name|st_rdev
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
name|minor
argument_list|(
name|from_config
operator|.
name|st_rdev
argument_list|)
operator|==
name|major
argument_list|(
name|from_client
operator|.
name|st_rdev
argument_list|)
condition|)
endif|#
directive|endif
break|break;
block|}
block|}
if|if
condition|(
name|config
operator|==
literal|0
condition|)
block|{
name|tcpd_warn
argument_list|(
literal|"unable to identify transport protocol"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*      * Something else may clobber our getnetconfig() result, so we'd better      * acquire our private copy.      */
if|if
condition|(
operator|(
name|config
operator|=
name|getnetconfigent
argument_list|(
name|config
operator|->
name|nc_netid
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|tcpd_warn
argument_list|(
literal|"getnetconfigent(%s): %s"
argument_list|,
name|config
operator|->
name|nc_netid
argument_list|,
name|nc_sperror
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|config
operator|)
return|;
block|}
comment|/* tli_hostaddr - map TLI transport address to printable address */
specifier|static
name|void
name|tli_hostaddr
parameter_list|(
name|host
parameter_list|)
name|struct
name|host_info
modifier|*
name|host
decl_stmt|;
block|{
name|struct
name|request_info
modifier|*
name|request
init|=
name|host
operator|->
name|request
decl_stmt|;
name|struct
name|netconfig
modifier|*
name|config
init|=
name|request
operator|->
name|config
decl_stmt|;
name|struct
name|t_unitdata
modifier|*
name|unit
init|=
name|host
operator|->
name|unit
decl_stmt|;
name|char
modifier|*
name|uaddr
decl_stmt|;
if|if
condition|(
name|config
operator|!=
literal|0
operator|&&
name|unit
operator|!=
literal|0
operator|&&
operator|(
name|uaddr
operator|=
name|taddr2uaddr
argument_list|(
name|config
argument_list|,
operator|&
name|unit
operator|->
name|addr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|STRN_CPY
argument_list|(
name|host
operator|->
name|addr
argument_list|,
name|uaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|host
operator|->
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|uaddr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* tli_hostname - map TLI transport address to hostname */
specifier|static
name|void
name|tli_hostname
parameter_list|(
name|host
parameter_list|)
name|struct
name|host_info
modifier|*
name|host
decl_stmt|;
block|{
name|struct
name|request_info
modifier|*
name|request
init|=
name|host
operator|->
name|request
decl_stmt|;
name|struct
name|netconfig
modifier|*
name|config
init|=
name|request
operator|->
name|config
decl_stmt|;
name|struct
name|t_unitdata
modifier|*
name|unit
init|=
name|host
operator|->
name|unit
decl_stmt|;
name|struct
name|nd_hostservlist
modifier|*
name|servlist
decl_stmt|;
if|if
condition|(
name|config
operator|!=
literal|0
operator|&&
name|unit
operator|!=
literal|0
operator|&&
name|netdir_getbyaddr
argument_list|(
name|config
argument_list|,
operator|&
name|servlist
argument_list|,
operator|&
name|unit
operator|->
name|addr
argument_list|)
operator|==
name|ND_OK
condition|)
block|{
name|struct
name|nd_hostserv
modifier|*
name|service
init|=
name|servlist
operator|->
name|h_hostservs
decl_stmt|;
name|struct
name|nd_addrlist
modifier|*
name|addr_list
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|netdir_getbyname
argument_list|(
name|config
argument_list|,
name|service
argument_list|,
operator|&
name|addr_list
argument_list|)
operator|!=
name|ND_OK
condition|)
block|{
comment|/* 	     * Unable to verify that the name matches the address. This may 	     * be a transient problem or a botched name server setup. We 	     * decide to play safe. 	     */
name|tcpd_warn
argument_list|(
literal|"can't verify hostname: netdir_getbyname(%.*s) failed"
argument_list|,
name|STRING_LENGTH
argument_list|,
name|service
operator|->
name|h_host
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * Look up the host address in the address list we just got. The 	     * comparison is done on the textual representation, because the 	     * transport address is an opaque structure that may have holes 	     * with uninitialized garbage. This approach obviously loses when 	     * the address does not have a textual representation. 	     */
name|char
modifier|*
name|uaddr
init|=
name|eval_hostaddr
argument_list|(
name|host
argument_list|)
decl_stmt|;
name|char
modifier|*
name|ua
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|found
operator|==
literal|0
operator|&&
name|i
operator|<
name|addr_list
operator|->
name|n_cnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ua
operator|=
name|taddr2uaddr
argument_list|(
name|config
argument_list|,
operator|&
operator|(
name|addr_list
operator|->
name|n_addrs
index|[
name|i
index|]
operator|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|found
operator|=
operator|!
name|strcmp
argument_list|(
name|ua
argument_list|,
name|uaddr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ua
argument_list|)
expr_stmt|;
block|}
block|}
name|netdir_free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|addr_list
argument_list|,
name|ND_ADDRLIST
argument_list|)
expr_stmt|;
comment|/* 	     * When the host name does not map to the initial address, assume 	     * someone has compromised a name server. More likely someone 	     * botched it, but that could be dangerous, too. 	     */
if|if
condition|(
name|found
operator|==
literal|0
condition|)
name|tcpd_warn
argument_list|(
literal|"host name/address mismatch: %s != %.*s"
argument_list|,
name|host
operator|->
name|addr
argument_list|,
name|STRING_LENGTH
argument_list|,
name|service
operator|->
name|h_host
argument_list|)
expr_stmt|;
block|}
name|STRN_CPY
argument_list|(
name|host
operator|->
name|name
argument_list|,
name|found
condition|?
name|service
operator|->
name|h_host
else|:
name|paranoid
argument_list|,
sizeof|sizeof
argument_list|(
name|host
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|netdir_free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|servlist
argument_list|,
name|ND_HOSTSERVLIST
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* tli_error - convert tli error number to text */
specifier|static
name|char
modifier|*
name|tli_error
parameter_list|()
block|{
specifier|static
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|;
if|if
condition|(
name|t_errno
operator|!=
name|TSYSERR
condition|)
block|{
if|if
condition|(
name|t_errno
operator|<
literal|0
operator|||
name|t_errno
operator|>=
name|t_nerr
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Unknown TLI error %d"
argument_list|,
name|t_errno
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|t_errlist
index|[
name|t_errno
index|]
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|errno
operator|<
literal|0
operator|||
name|errno
operator|>=
name|sys_nerr
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Unknown UNIX error %d"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|sys_errlist
index|[
name|errno
index|]
operator|)
return|;
block|}
block|}
block|}
comment|/* tli_sink - absorb unreceived datagram */
specifier|static
name|void
name|tli_sink
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
name|struct
name|t_unitdata
modifier|*
name|unit
decl_stmt|;
name|int
name|flags
decl_stmt|;
comment|/*      * Something went wrong. Absorb the datagram to keep inetd from looping.      * Allocate storage for address, control and data. If that fails, sleep      * for a couple of seconds in an attempt to keep inetd from looping too      * fast.      */
if|if
condition|(
operator|(
name|unit
operator|=
operator|(
expr|struct
name|t_unitdata
operator|*
operator|)
name|t_alloc
argument_list|(
name|fd
argument_list|,
name|T_UNITDATA
argument_list|,
name|T_ALL
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|tcpd_warn
argument_list|(
literal|"t_alloc: %s"
argument_list|,
name|tli_error
argument_list|()
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|t_rcvudata
argument_list|(
name|fd
argument_list|,
name|unit
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
name|t_free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|unit
argument_list|,
name|T_UNITDATA
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TLI */
end_comment

end_unit

