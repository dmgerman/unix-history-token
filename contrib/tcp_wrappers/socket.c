begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * This module determines the type of socket (datagram, stream), the client   * socket address and port, the server socket address and port. In addition,   * it provides methods to map a transport address to a printable host name   * or address. Socket address information results are in static memory.   *    * The result from the hostname lookup method is STRING_PARANOID when a host   * pretends to have someone elses name, or when a host name is available but   * could not be verified.   *    * When lookup or conversion fails the result is set to STRING_UNKNOWN.   *    * Diagnostics are reported through syslog(3).   *    * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.   */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#) socket.c 1.15 97/03/21 19:27:24"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* System libraries. */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_function_decl
specifier|extern
name|char
modifier|*
name|inet_ntoa
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Local stuff. */
end_comment

begin_include
include|#
directive|include
file|"tcpd.h"
end_include

begin_comment
comment|/* Forward declarations. */
end_comment

begin_function_decl
specifier|static
name|void
name|sock_sink
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|APPEND_DOT
end_ifdef

begin_comment
comment|/*   * Speed up DNS lookups by terminating the host name with a dot. Should be   * done with care. The speedup can give problems with lookups from sources   * that lack DNS-style trailing dot magic, such as local files or NIS maps.   */
end_comment

begin_function
specifier|static
name|struct
name|hostent
modifier|*
name|gethostbyname_dot
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
name|dot_name
index|[
name|MAXHOSTNAMELEN
operator|+
literal|1
index|]
decl_stmt|;
comment|/*      * Don't append dots to unqualified names. Such names are likely to come      * from local hosts files or from NIS.      */
if|if
condition|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
operator|==
literal|0
operator|||
name|strlen
argument_list|(
name|name
argument_list|)
operator|>=
name|MAXHOSTNAMELEN
operator|-
literal|1
condition|)
block|{
return|return
operator|(
name|gethostbyname
argument_list|(
name|name
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|dot_name
argument_list|,
literal|"%s."
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|gethostbyname
argument_list|(
name|dot_name
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|gethostbyname
value|gethostbyname_dot
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sock_host - look up endpoint addresses and install conversion methods */
end_comment

begin_function
name|void
name|sock_host
parameter_list|(
name|request
parameter_list|)
name|struct
name|request_info
modifier|*
name|request
decl_stmt|;
block|{
specifier|static
name|struct
name|sockaddr_in
name|client
decl_stmt|;
specifier|static
name|struct
name|sockaddr_in
name|server
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|fd
init|=
name|request
operator|->
name|fd
decl_stmt|;
name|sock_methods
argument_list|(
name|request
argument_list|)
expr_stmt|;
comment|/*      * Look up the client host address. Hal R. Brand<BRAND@addvax.llnl.gov>      * suggested how to get the client host info in case of UDP connections:      * peek at the first message without actually looking at its contents. We      * really should verify that client.sin_family gets the value AF_INET,      * but this program has already caused too much grief on systems with      * broken library code.      */
name|len
operator|=
sizeof|sizeof
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|getpeername
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|client
argument_list|,
operator|&
name|len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|request
operator|->
name|sink
operator|=
name|sock_sink
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|recvfrom
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|MSG_PEEK
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|client
argument_list|,
operator|&
name|len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|tcpd_warn
argument_list|(
literal|"can't get client address: %m"
argument_list|)
expr_stmt|;
return|return;
comment|/* give up */
block|}
ifdef|#
directive|ifdef
name|really_paranoid
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|request
operator|->
name|client
operator|->
name|sin
operator|=
operator|&
name|client
expr_stmt|;
comment|/*      * Determine the server binding. This is used for client username      * lookups, and for access control rules that trigger on the server      * address or name.      */
name|len
operator|=
sizeof|sizeof
argument_list|(
name|server
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|server
argument_list|,
operator|&
name|len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|tcpd_warn
argument_list|(
literal|"getsockname: %m"
argument_list|)
expr_stmt|;
return|return;
block|}
name|request
operator|->
name|server
operator|->
name|sin
operator|=
operator|&
name|server
expr_stmt|;
block|}
end_function

begin_comment
comment|/* sock_hostaddr - map endpoint address to printable form */
end_comment

begin_function
name|void
name|sock_hostaddr
parameter_list|(
name|host
parameter_list|)
name|struct
name|host_info
modifier|*
name|host
decl_stmt|;
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
init|=
name|host
operator|->
name|sin
decl_stmt|;
if|if
condition|(
name|sin
operator|!=
literal|0
condition|)
name|STRN_CPY
argument_list|(
name|host
operator|->
name|addr
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|->
name|sin_addr
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|host
operator|->
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* sock_hostname - map endpoint address to host name */
end_comment

begin_function
name|void
name|sock_hostname
parameter_list|(
name|host
parameter_list|)
name|struct
name|host_info
modifier|*
name|host
decl_stmt|;
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
init|=
name|host
operator|->
name|sin
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*      * On some systems, for example Solaris 2.3, gethostbyaddr(0.0.0.0) does      * not fail. Instead it returns "INADDR_ANY". Unfortunately, this does      * not work the other way around: gethostbyname("INADDR_ANY") fails. We      * have to special-case 0.0.0.0, in order to avoid false alerts from the      * host name/address checking code below.      */
if|if
condition|(
name|sin
operator|!=
literal|0
operator|&&
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|!=
literal|0
operator|&&
operator|(
name|hp
operator|=
name|gethostbyaddr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|sin
operator|->
name|sin_addr
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|AF_INET
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|STRN_CPY
argument_list|(
name|host
operator|->
name|name
argument_list|,
name|hp
operator|->
name|h_name
argument_list|,
sizeof|sizeof
argument_list|(
name|host
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Verify that the address is a member of the address list returned 	 * by gethostbyname(hostname). 	 *  	 * Verify also that gethostbyaddr() and gethostbyname() return the same 	 * hostname, or rshd and rlogind may still end up being spoofed. 	 *  	 * On some sites, gethostbyname("localhost") returns "localhost.domain". 	 * This is a DNS artefact. We treat it as a special case. When we 	 * can't believe the address list from gethostbyname("localhost") 	 * we're in big trouble anyway. 	 */
if|if
condition|(
operator|(
name|hp
operator|=
name|gethostbyname
argument_list|(
name|host
operator|->
name|name
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 	     * Unable to verify that the host name matches the address. This 	     * may be a transient problem or a botched name server setup. 	     */
name|tcpd_warn
argument_list|(
literal|"can't verify hostname: gethostbyname(%s) failed"
argument_list|,
name|host
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STR_NE
argument_list|(
name|host
operator|->
name|name
argument_list|,
name|hp
operator|->
name|h_name
argument_list|)
operator|&&
name|STR_NE
argument_list|(
name|host
operator|->
name|name
argument_list|,
literal|"localhost"
argument_list|)
condition|)
block|{
comment|/* 	     * The gethostbyaddr() and gethostbyname() calls did not return 	     * the same hostname. This could be a nameserver configuration 	     * problem. It could also be that someone is trying to spoof us. 	     */
name|tcpd_warn
argument_list|(
literal|"host name/name mismatch: %s != %.*s"
argument_list|,
name|host
operator|->
name|name
argument_list|,
name|STRING_LENGTH
argument_list|,
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * The address should be a member of the address list returned by 	     * gethostbyname(). We should first verify that the h_addrtype 	     * field is AF_INET, but this program has already caused too much 	     * grief on systems with broken library code. 	     */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sin
operator|->
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
operator|->
name|sin_addr
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* name is good, keep it */
block|}
comment|/* 	     * The host name does not map to the initial address. Perhaps 	     * someone has messed up. Perhaps someone compromised a name 	     * server. 	     */
name|tcpd_warn
argument_list|(
literal|"host name/address mismatch: %s != %.*s"
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|STRING_LENGTH
argument_list|,
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|host
operator|->
name|name
argument_list|,
name|paranoid
argument_list|)
expr_stmt|;
comment|/* name is bad, clobber it */
block|}
block|}
end_function

begin_comment
comment|/* sock_sink - absorb unreceived IP datagram */
end_comment

begin_function
specifier|static
name|void
name|sock_sink
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|int
name|size
init|=
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
decl_stmt|;
comment|/*      * Eat up the not-yet received datagram. Some systems insist on a      * non-zero source address argument in the recvfrom() call below.      */
operator|(
name|void
operator|)
name|recvfrom
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

