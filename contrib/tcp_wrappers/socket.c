begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * This module determines the type of socket (datagram, stream), the client   * socket address and port, the server socket address and port. In addition,   * it provides methods to map a transport address to a printable host name   * or address. Socket address information results are in static memory.   *    * The result from the hostname lookup method is STRING_PARANOID when a host   * pretends to have someone elses name, or when a host name is available but   * could not be verified.   *    * When lookup or conversion fails the result is set to STRING_UNKNOWN.   *    * Diagnostics are reported through syslog(3).   *    * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.   *   * $FreeBSD$   */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#) socket.c 1.15 97/03/21 19:27:24"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* System libraries. */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|USE_GETIPNODEBY
end_ifndef

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|char
modifier|*
name|inet_ntoa
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Local stuff. */
end_comment

begin_include
include|#
directive|include
file|"tcpd.h"
end_include

begin_comment
comment|/* Forward declarations. */
end_comment

begin_function_decl
specifier|static
name|void
name|sock_sink
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|APPEND_DOT
end_ifdef

begin_comment
comment|/*   * Speed up DNS lookups by terminating the host name with a dot. Should be   * done with care. The speedup can give problems with lookups from sources   * that lack DNS-style trailing dot magic, such as local files or NIS maps.   */
end_comment

begin_function
specifier|static
name|struct
name|hostent
modifier|*
name|gethostbyname_dot
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
name|dot_name
index|[
name|MAXHOSTNAMELEN
operator|+
literal|1
index|]
decl_stmt|;
comment|/*      * Don't append dots to unqualified names. Such names are likely to come      * from local hosts files or from NIS.      */
if|if
condition|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
operator|==
literal|0
operator|||
name|strlen
argument_list|(
name|name
argument_list|)
operator|>=
name|MAXHOSTNAMELEN
operator|-
literal|1
condition|)
block|{
return|return
operator|(
name|gethostbyname
argument_list|(
name|name
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|dot_name
argument_list|,
literal|"%s."
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|gethostbyname
argument_list|(
name|dot_name
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|gethostbyname
value|gethostbyname_dot
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sock_host - look up endpoint addresses and install conversion methods */
end_comment

begin_function
name|void
name|sock_host
parameter_list|(
name|request
parameter_list|)
name|struct
name|request_info
modifier|*
name|request
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|INET6
specifier|static
name|struct
name|sockaddr_storage
name|client
decl_stmt|;
specifier|static
name|struct
name|sockaddr_storage
name|server
decl_stmt|;
else|#
directive|else
specifier|static
name|struct
name|sockaddr_in
name|client
decl_stmt|;
specifier|static
name|struct
name|sockaddr_in
name|server
decl_stmt|;
endif|#
directive|endif
name|int
name|len
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|fd
init|=
name|request
operator|->
name|fd
decl_stmt|;
name|sock_methods
argument_list|(
name|request
argument_list|)
expr_stmt|;
comment|/*      * Look up the client host address. Hal R. Brand<BRAND@addvax.llnl.gov>      * suggested how to get the client host info in case of UDP connections:      * peek at the first message without actually looking at its contents. We      * really should verify that client.sin_family gets the value AF_INET,      * but this program has already caused too much grief on systems with      * broken library code.      */
name|len
operator|=
sizeof|sizeof
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|getpeername
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|client
argument_list|,
operator|&
name|len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|request
operator|->
name|sink
operator|=
name|sock_sink
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|recvfrom
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|MSG_PEEK
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|client
argument_list|,
operator|&
name|len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|tcpd_warn
argument_list|(
literal|"can't get client address: %m"
argument_list|)
expr_stmt|;
return|return;
comment|/* give up */
block|}
ifdef|#
directive|ifdef
name|really_paranoid
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|INET6
name|request
operator|->
name|client
operator|->
name|sin
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|client
expr_stmt|;
else|#
directive|else
name|request
operator|->
name|client
operator|->
name|sin
operator|=
operator|&
name|client
expr_stmt|;
endif|#
directive|endif
comment|/*      * Determine the server binding. This is used for client username      * lookups, and for access control rules that trigger on the server      * address or name.      */
name|len
operator|=
sizeof|sizeof
argument_list|(
name|server
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|server
argument_list|,
operator|&
name|len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|tcpd_warn
argument_list|(
literal|"getsockname: %m"
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|INET6
name|request
operator|->
name|server
operator|->
name|sin
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|server
expr_stmt|;
else|#
directive|else
name|request
operator|->
name|server
operator|->
name|sin
operator|=
operator|&
name|server
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* sock_hostaddr - map endpoint address to printable form */
end_comment

begin_function
name|void
name|sock_hostaddr
parameter_list|(
name|host
parameter_list|)
name|struct
name|host_info
modifier|*
name|host
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr
modifier|*
name|sin
init|=
name|host
operator|->
name|sin
decl_stmt|;
name|char
modifier|*
name|ap
decl_stmt|;
name|int
name|alen
decl_stmt|;
if|if
condition|(
operator|!
name|sin
condition|)
return|return;
switch|switch
condition|(
name|sin
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
name|ap
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sin
operator|)
operator|->
name|sin_addr
expr_stmt|;
name|alen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
name|ap
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sin
operator|)
operator|->
name|sin6_addr
expr_stmt|;
name|alen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return;
block|}
name|host
operator|->
name|addr
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|inet_ntop
argument_list|(
name|sin
operator|->
name|sa_family
argument_list|,
name|ap
argument_list|,
name|host
operator|->
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|host
operator|->
name|addr
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|struct
name|sockaddr_in
modifier|*
name|sin
init|=
name|host
operator|->
name|sin
decl_stmt|;
if|if
condition|(
name|sin
operator|!=
literal|0
condition|)
name|STRN_CPY
argument_list|(
name|host
operator|->
name|addr
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|->
name|sin_addr
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|host
operator|->
name|addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* sock_hostname - map endpoint address to host name */
end_comment

begin_function
name|void
name|sock_hostname
parameter_list|(
name|host
parameter_list|)
name|struct
name|host_info
modifier|*
name|host
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr
modifier|*
name|sin
init|=
name|host
operator|->
name|sin
decl_stmt|;
name|char
name|addr
index|[
literal|128
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_GETIPNODEBY
name|int
name|h_error
decl_stmt|;
else|#
directive|else
name|u_long
name|res_options
decl_stmt|;
endif|#
directive|endif
name|struct
name|hostent
modifier|*
name|hp
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|ap
decl_stmt|;
name|int
name|alen
decl_stmt|;
else|#
directive|else
name|struct
name|sockaddr_in
modifier|*
name|sin
init|=
name|host
operator|->
name|sin
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
endif|#
directive|endif
name|int
name|i
decl_stmt|;
comment|/*      * On some systems, for example Solaris 2.3, gethostbyaddr(0.0.0.0) does      * not fail. Instead it returns "INADDR_ANY". Unfortunately, this does      * not work the other way around: gethostbyname("INADDR_ANY") fails. We      * have to special-case 0.0.0.0, in order to avoid false alerts from the      * host name/address checking code below.      */
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|sin
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|sin
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sin
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|host
operator|->
name|name
argument_list|,
name|paranoid
argument_list|)
expr_stmt|;
comment|/* name is bad, clobber it */
return|return;
block|}
name|ap
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sin
operator|)
operator|->
name|sin_addr
expr_stmt|;
name|alen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
name|ap
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sin
operator|)
operator|->
name|sin6_addr
expr_stmt|;
name|alen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
expr_stmt|;
break|break;
name|defalut
label|:
name|strcpy
argument_list|(
name|host
operator|->
name|name
argument_list|,
name|paranoid
argument_list|)
expr_stmt|;
comment|/* name is bad, clobber it */
return|return;
block|}
ifdef|#
directive|ifdef
name|USE_GETIPNODEBY
name|hp
operator|=
name|getipnodebyaddr
argument_list|(
name|ap
argument_list|,
name|alen
argument_list|,
name|sin
operator|->
name|sa_family
argument_list|,
operator|&
name|h_error
argument_list|)
expr_stmt|;
else|#
directive|else
name|hp
operator|=
name|gethostbyaddr
argument_list|(
name|ap
argument_list|,
name|alen
argument_list|,
name|sin
operator|->
name|sa_family
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|hp
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|sin
operator|!=
literal|0
operator|&&
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|!=
literal|0
operator|&&
operator|(
name|hp
operator|=
name|gethostbyaddr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|sin
operator|->
name|sin_addr
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|AF_INET
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
endif|#
directive|endif
name|STRN_CPY
argument_list|(
name|host
operator|->
name|name
argument_list|,
name|hp
operator|->
name|h_name
argument_list|,
sizeof|sizeof
argument_list|(
name|host
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_GETIPNODEBY
argument_list|)
name|freehostent
argument_list|(
name|hp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Verify that the address is a member of the address list returned 	 * by gethostbyname(hostname). 	 *  	 * Verify also that gethostbyaddr() and gethostbyname() return the same 	 * hostname, or rshd and rlogind may still end up being spoofed. 	 *  	 * On some sites, gethostbyname("localhost") returns "localhost.domain". 	 * This is a DNS artefact. We treat it as a special case. When we 	 * can't believe the address list from gethostbyname("localhost") 	 * we're in big trouble anyway. 	 */
ifdef|#
directive|ifdef
name|INET6
ifdef|#
directive|ifdef
name|USE_GETIPNODEBY
name|hp
operator|=
name|getipnodebyname
argument_list|(
name|host
operator|->
name|name
argument_list|,
name|sin
operator|->
name|sa_family
argument_list|,
name|AI_V4MAPPED
operator||
name|AI_ADDRCONFIG
operator||
name|AI_ALL
argument_list|,
operator|&
name|h_error
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|_res
operator|.
name|options
operator|&
name|RES_INIT
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|res_init
argument_list|()
operator|<
literal|0
condition|)
block|{
name|inet_ntop
argument_list|(
name|sin
operator|->
name|sa_family
argument_list|,
name|ap
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|tcpd_warn
argument_list|(
literal|"can't verify hostname: res_init() for %s failed"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|host
operator|->
name|name
argument_list|,
name|paranoid
argument_list|)
expr_stmt|;
comment|/* name is bad, clobber it */
return|return;
block|}
block|}
name|res_options
operator|=
name|_res
operator|.
name|options
expr_stmt|;
if|if
condition|(
name|sin
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
name|_res
operator|.
name|options
operator||=
name|RES_USE_INET6
expr_stmt|;
else|else
name|_res
operator|.
name|options
operator|&=
operator|~
name|RES_USE_INET6
expr_stmt|;
name|hp
operator|=
name|gethostbyname2
argument_list|(
name|host
operator|->
name|name
argument_list|,
operator|(
name|sin
operator|->
name|sa_family
operator|==
name|AF_INET6
operator|&&
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sin
operator|)
operator|->
name|sin6_addr
argument_list|)
operator|)
condition|?
name|AF_INET
else|:
name|sin
operator|->
name|sa_family
argument_list|)
expr_stmt|;
name|_res
operator|.
name|options
operator|=
name|res_options
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|hp
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|(
name|hp
operator|=
name|gethostbyname
argument_list|(
name|host
operator|->
name|name
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
endif|#
directive|endif
comment|/* 	     * Unable to verify that the host name matches the address. This 	     * may be a transient problem or a botched name server setup. 	     */
ifdef|#
directive|ifdef
name|INET6
ifdef|#
directive|ifdef
name|USE_GETIPNODEBY
name|tcpd_warn
argument_list|(
literal|"can't verify hostname: getipnodebyname(%s, %s) failed"
argument_list|,
else|#
directive|else
argument|tcpd_warn(
literal|"can't verify hostname: gethostbyname2(%s, %s) failed"
argument|,
endif|#
directive|endif
argument|host->name, 		      (sin->sa_family == AF_INET) ?
literal|"AF_INET"
argument|:
literal|"AF_INET6"
argument|);
else|#
directive|else
argument|tcpd_warn(
literal|"can't verify hostname: gethostbyname(%s) failed"
argument|, 		      host->name);
endif|#
directive|endif
argument|} else if (STR_NE(host->name, hp->h_name)&& STR_NE(host->name,
literal|"localhost"
argument|)) {
comment|/* 	     * The gethostbyaddr() and gethostbyname() calls did not return 	     * the same hostname. This could be a nameserver configuration 	     * problem. It could also be that someone is trying to spoof us. 	     */
argument|tcpd_warn(
literal|"host name/name mismatch: %s != %.*s"
argument|, 		      host->name, STRING_LENGTH, hp->h_name);  	} else {
comment|/* 	     * The address should be a member of the address list returned by 	     * gethostbyname(). We should first verify that the h_addrtype 	     * field is AF_INET, but this program has already caused too much 	     * grief on systems with broken library code. 	     */
argument|for (i =
literal|0
argument|; hp->h_addr_list[i]; i++) {
ifdef|#
directive|ifdef
name|INET6
argument|if (memcmp(hp->h_addr_list[i], ap, alen) ==
literal|0
argument|) {
ifdef|#
directive|ifdef
name|USE_GETIPNODEBY
argument|freehostent(hp);
endif|#
directive|endif
argument|return;
comment|/* name is good, keep it */
argument|}
else|#
directive|else
argument|if (memcmp(hp->h_addr_list[i], 			   (char *)&sin->sin_addr, 			   sizeof(sin->sin_addr)) ==
literal|0
argument|) 		    return;
comment|/* name is good, keep it */
endif|#
directive|endif
argument|}
comment|/* 	     * The host name does not map to the initial address. Perhaps 	     * someone has messed up. Perhaps someone compromised a name 	     * server. 	     */
ifdef|#
directive|ifdef
name|INET6
argument|inet_ntop(sin->sa_family, ap, addr, sizeof(addr)); 	    tcpd_warn(
literal|"host name/address mismatch: %s != %.*s"
argument|, 		      addr, STRING_LENGTH, hp->h_name);
else|#
directive|else
argument|tcpd_warn(
literal|"host name/address mismatch: %s != %.*s"
argument|, 		      inet_ntoa(sin->sin_addr), STRING_LENGTH, hp->h_name);
endif|#
directive|endif
argument|} 	strcpy(host->name, paranoid);
comment|/* name is bad, clobber it */
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_GETIPNODEBY
argument_list|)
argument|if (hp) 	    freehostent(hp);
endif|#
directive|endif
argument|} }
comment|/* sock_sink - absorb unreceived IP datagram */
argument|static void sock_sink(fd) int     fd; {     char    buf[BUFSIZ];
ifdef|#
directive|ifdef
name|INET6
argument|struct sockaddr_storage sin;
else|#
directive|else
argument|struct sockaddr_in sin;
endif|#
directive|endif
argument|int     size = sizeof(sin);
comment|/*      * Eat up the not-yet received datagram. Some systems insist on a      * non-zero source address argument in the recvfrom() call below.      */
argument|(void) recvfrom(fd, buf, sizeof(buf),
literal|0
argument|, (struct sockaddr *)& sin,&size); }
end_function

end_unit

