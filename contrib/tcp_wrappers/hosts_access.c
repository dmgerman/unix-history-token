begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * This module implements a simple access control language that is based on   * host (or domain) names, NIS (host) netgroup names, IP addresses (or   * network numbers) and daemon process names. When a match is found the   * search is terminated, and depending on whether PROCESS_OPTIONS is defined,   * a list of options is executed or an optional shell command is executed.   *    * Host and user names are looked up on demand, provided that suitable endpoint   * information is available as sockaddr_in structures or TLI netbufs. As a   * side effect, the pattern matching process may change the contents of   * request structure fields.   *    * Diagnostics are reported through syslog(3).   *    * Compile with -DNETGROUP if your library provides support for netgroups.   *    * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.   */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#) hosts_access.c 1.21 97/02/12 02:13:22"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* System libraries. */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_function_decl
specifier|extern
name|char
modifier|*
name|fgets
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|INADDR_NONE
end_ifndef

begin_define
define|#
directive|define
name|INADDR_NONE
value|(-1)
end_define

begin_comment
comment|/* XXX should be 0xffffffff */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Local stuff. */
end_comment

begin_include
include|#
directive|include
file|"tcpd.h"
end_include

begin_comment
comment|/* Error handling. */
end_comment

begin_decl_stmt
specifier|extern
name|jmp_buf
name|tcpd_buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Delimiters for lists of daemons or clients. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|sep
index|[]
init|=
literal|", \t\r\n"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Constants to be used in assignments only, not in comparisons... */
end_comment

begin_define
define|#
directive|define
name|YES
value|1
end_define

begin_define
define|#
directive|define
name|NO
value|0
end_define

begin_comment
comment|/*   * These variables are globally visible so that they can be redirected in   * verification mode.   */
end_comment

begin_decl_stmt
name|char
modifier|*
name|hosts_allow_table
init|=
name|HOSTS_ALLOW
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|hosts_deny_table
init|=
name|HOSTS_DENY
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|hosts_access_verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   * In a long-running process, we are not at liberty to just go away.   */
end_comment

begin_decl_stmt
name|int
name|resident
init|=
operator|(
operator|-
literal|1
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -1, 0: unknown; +1: yes */
end_comment

begin_comment
comment|/* Forward declarations. */
end_comment

begin_function_decl
specifier|static
name|int
name|table_match
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|list_match
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|server_match
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|client_match
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|host_match
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|string_match
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|masked_match
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Size of logical line buffer. */
end_comment

begin_define
define|#
directive|define
name|BUFLEN
value|2048
end_define

begin_comment
comment|/* hosts_access - host access control facility */
end_comment

begin_function
name|int
name|hosts_access
parameter_list|(
name|request
parameter_list|)
name|struct
name|request_info
modifier|*
name|request
decl_stmt|;
block|{
name|int
name|verdict
decl_stmt|;
comment|/*      * If the (daemon, client) pair is matched by an entry in the file      * /etc/hosts.allow, access is granted. Otherwise, if the (daemon,      * client) pair is matched by an entry in the file /etc/hosts.deny,      * access is denied. Otherwise, access is granted. A non-existent      * access-control file is treated as an empty file.      *       * After a rule has been matched, the optional language extensions may      * decide to grant or refuse service anyway. Or, while a rule is being      * processed, a serious error is found, and it seems better to play safe      * and deny service. All this is done by jumping back into the      * hosts_access() routine, bypassing the regular return from the      * table_match() function calls below.      */
if|if
condition|(
name|resident
operator|<=
literal|0
condition|)
name|resident
operator|++
expr_stmt|;
name|verdict
operator|=
name|setjmp
argument_list|(
name|tcpd_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|verdict
operator|!=
literal|0
condition|)
return|return
operator|(
name|verdict
operator|==
name|AC_PERMIT
operator|)
return|;
if|if
condition|(
name|table_match
argument_list|(
name|hosts_allow_table
argument_list|,
name|request
argument_list|)
condition|)
return|return
operator|(
name|YES
operator|)
return|;
if|if
condition|(
name|table_match
argument_list|(
name|hosts_deny_table
argument_list|,
name|request
argument_list|)
condition|)
return|return
operator|(
name|NO
operator|)
return|;
return|return
operator|(
name|YES
operator|)
return|;
block|}
end_function

begin_comment
comment|/* table_match - match table entries with (daemon, client) pair */
end_comment

begin_function
specifier|static
name|int
name|table_match
parameter_list|(
name|table
parameter_list|,
name|request
parameter_list|)
name|char
modifier|*
name|table
decl_stmt|;
name|struct
name|request_info
modifier|*
name|request
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|sv_list
index|[
name|BUFLEN
index|]
decl_stmt|;
comment|/* becomes list of daemons */
name|char
modifier|*
name|cl_list
decl_stmt|;
comment|/* becomes list of clients */
name|char
modifier|*
name|sh_cmd
decl_stmt|;
comment|/* becomes optional shell command */
name|int
name|match
init|=
name|NO
decl_stmt|;
name|struct
name|tcpd_context
name|saved_context
decl_stmt|;
name|saved_context
operator|=
name|tcpd_context
expr_stmt|;
comment|/* stupid compilers */
comment|/*      * Between the fopen() and fclose() calls, avoid jumps that may cause      * file descriptor leaks.      */
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|table
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|tcpd_context
operator|.
name|file
operator|=
name|table
expr_stmt|;
name|tcpd_context
operator|.
name|line
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|match
operator|==
name|NO
operator|&&
name|xgets
argument_list|(
name|sv_list
argument_list|,
sizeof|sizeof
argument_list|(
name|sv_list
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|sv_list
index|[
name|strlen
argument_list|(
name|sv_list
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|tcpd_warn
argument_list|(
literal|"missing newline or line too long"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sv_list
index|[
literal|0
index|]
operator|==
literal|'#'
operator|||
name|sv_list
index|[
name|strspn
argument_list|(
name|sv_list
argument_list|,
literal|" \t\r\n"
argument_list|)
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|cl_list
operator|=
name|split_at
argument_list|(
name|sv_list
argument_list|,
literal|':'
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|tcpd_warn
argument_list|(
literal|"missing \":\" separator"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sh_cmd
operator|=
name|split_at
argument_list|(
name|cl_list
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|match
operator|=
name|list_match
argument_list|(
name|sv_list
argument_list|,
name|request
argument_list|,
name|server_match
argument_list|)
operator|&&
name|list_match
argument_list|(
name|cl_list
argument_list|,
name|request
argument_list|,
name|client_match
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|tcpd_warn
argument_list|(
literal|"cannot open %s: %m"
argument_list|,
name|table
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|match
condition|)
block|{
if|if
condition|(
name|hosts_access_verbose
operator|>
literal|1
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"matched:  %s line %d"
argument_list|,
name|tcpd_context
operator|.
name|file
argument_list|,
name|tcpd_context
operator|.
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|sh_cmd
condition|)
block|{
ifdef|#
directive|ifdef
name|PROCESS_OPTIONS
name|process_options
argument_list|(
name|sh_cmd
argument_list|,
name|request
argument_list|)
expr_stmt|;
else|#
directive|else
name|char
name|cmd
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|shell_cmd
argument_list|(
name|percent_x
argument_list|(
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
name|sh_cmd
argument_list|,
name|request
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|tcpd_context
operator|=
name|saved_context
expr_stmt|;
return|return
operator|(
name|match
operator|)
return|;
block|}
end_function

begin_comment
comment|/* list_match - match a request against a list of patterns with exceptions */
end_comment

begin_decl_stmt
specifier|static
name|int
name|list_match
argument_list|(
name|list
argument_list|,
name|request
argument_list|,
name|match_fn
argument_list|)
name|char
modifier|*
name|list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|request_info
modifier|*
name|request
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|match_fn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|char
modifier|*
name|tok
decl_stmt|;
comment|/*      * Process tokens one at a time. We have exhausted all possible matches      * when we reach an "EXCEPT" token or the end of the list. If we do find      * a match, look for an "EXCEPT" list and recurse to determine whether      * the match is affected by any exceptions.      */
for|for
control|(
name|tok
operator|=
name|strtok
argument_list|(
name|list
argument_list|,
name|sep
argument_list|)
init|;
name|tok
operator|!=
literal|0
condition|;
name|tok
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|sep
argument_list|)
control|)
block|{
if|if
condition|(
name|STR_EQ
argument_list|(
name|tok
argument_list|,
literal|"EXCEPT"
argument_list|)
condition|)
comment|/* EXCEPT: give up */
return|return
operator|(
name|NO
operator|)
return|;
if|if
condition|(
name|match_fn
argument_list|(
name|tok
argument_list|,
name|request
argument_list|)
condition|)
block|{
comment|/* YES: look for exceptions */
while|while
condition|(
operator|(
name|tok
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|sep
argument_list|)
operator|)
operator|&&
name|STR_NE
argument_list|(
name|tok
argument_list|,
literal|"EXCEPT"
argument_list|)
condition|)
comment|/* VOID */
empty_stmt|;
return|return
operator|(
name|tok
operator|==
literal|0
operator|||
name|list_match
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|request
argument_list|,
name|match_fn
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NO
operator|)
return|;
block|}
end_block

begin_comment
comment|/* server_match - match server information */
end_comment

begin_function
specifier|static
name|int
name|server_match
parameter_list|(
name|tok
parameter_list|,
name|request
parameter_list|)
name|char
modifier|*
name|tok
decl_stmt|;
name|struct
name|request_info
modifier|*
name|request
decl_stmt|;
block|{
name|char
modifier|*
name|host
decl_stmt|;
if|if
condition|(
operator|(
name|host
operator|=
name|split_at
argument_list|(
name|tok
operator|+
literal|1
argument_list|,
literal|'@'
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* plain daemon */
return|return
operator|(
name|string_match
argument_list|(
name|tok
argument_list|,
name|eval_daemon
argument_list|(
name|request
argument_list|)
argument_list|)
operator|)
return|;
block|}
else|else
block|{
comment|/* daemon@host */
return|return
operator|(
name|string_match
argument_list|(
name|tok
argument_list|,
name|eval_daemon
argument_list|(
name|request
argument_list|)
argument_list|)
operator|&&
name|host_match
argument_list|(
name|host
argument_list|,
name|request
operator|->
name|server
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* client_match - match client information */
end_comment

begin_function
specifier|static
name|int
name|client_match
parameter_list|(
name|tok
parameter_list|,
name|request
parameter_list|)
name|char
modifier|*
name|tok
decl_stmt|;
name|struct
name|request_info
modifier|*
name|request
decl_stmt|;
block|{
name|char
modifier|*
name|host
decl_stmt|;
if|if
condition|(
operator|(
name|host
operator|=
name|split_at
argument_list|(
name|tok
operator|+
literal|1
argument_list|,
literal|'@'
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* plain host */
return|return
operator|(
name|host_match
argument_list|(
name|tok
argument_list|,
name|request
operator|->
name|client
argument_list|)
operator|)
return|;
block|}
else|else
block|{
comment|/* user@host */
return|return
operator|(
name|host_match
argument_list|(
name|host
argument_list|,
name|request
operator|->
name|client
argument_list|)
operator|&&
name|string_match
argument_list|(
name|tok
argument_list|,
name|eval_user
argument_list|(
name|request
argument_list|)
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* host_match - match host name and/or address against pattern */
end_comment

begin_function
specifier|static
name|int
name|host_match
parameter_list|(
name|tok
parameter_list|,
name|host
parameter_list|)
name|char
modifier|*
name|tok
decl_stmt|;
name|struct
name|host_info
modifier|*
name|host
decl_stmt|;
block|{
name|char
modifier|*
name|mask
decl_stmt|;
comment|/*      * This code looks a little hairy because we want to avoid unnecessary      * hostname lookups.      *       * The KNOWN pattern requires that both address AND name be known; some      * patterns are specific to host names or to host addresses; all other      * patterns are satisfied when either the address OR the name match.      */
if|if
condition|(
name|tok
index|[
literal|0
index|]
operator|==
literal|'@'
condition|)
block|{
comment|/* netgroup: look it up */
ifdef|#
directive|ifdef
name|NETGROUP
specifier|static
name|char
modifier|*
name|mydomain
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mydomain
operator|==
literal|0
condition|)
name|yp_get_default_domain
argument_list|(
operator|&
name|mydomain
argument_list|)
expr_stmt|;
return|return
operator|(
name|innetgr
argument_list|(
name|tok
operator|+
literal|1
argument_list|,
name|eval_hostname
argument_list|(
name|host
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|mydomain
argument_list|)
operator|)
return|;
else|#
directive|else
name|tcpd_warn
argument_list|(
literal|"netgroup support is disabled"
argument_list|)
expr_stmt|;
comment|/* not tcpd_jump() */
return|return
operator|(
name|NO
operator|)
return|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|STR_EQ
argument_list|(
name|tok
argument_list|,
literal|"KNOWN"
argument_list|)
condition|)
block|{
comment|/* check address and name */
name|char
modifier|*
name|name
init|=
name|eval_hostname
argument_list|(
name|host
argument_list|)
decl_stmt|;
return|return
operator|(
name|STR_NE
argument_list|(
name|eval_hostaddr
argument_list|(
name|host
argument_list|)
argument_list|,
name|unknown
argument_list|)
operator|&&
name|HOSTNAME_KNOWN
argument_list|(
name|name
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|STR_EQ
argument_list|(
name|tok
argument_list|,
literal|"LOCAL"
argument_list|)
condition|)
block|{
comment|/* local: no dots in name */
name|char
modifier|*
name|name
init|=
name|eval_hostname
argument_list|(
name|host
argument_list|)
decl_stmt|;
return|return
operator|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
operator|==
literal|0
operator|&&
name|HOSTNAME_KNOWN
argument_list|(
name|name
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|mask
operator|=
name|split_at
argument_list|(
name|tok
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* net/mask */
return|return
operator|(
name|masked_match
argument_list|(
name|tok
argument_list|,
name|mask
argument_list|,
name|eval_hostaddr
argument_list|(
name|host
argument_list|)
argument_list|)
operator|)
return|;
block|}
else|else
block|{
comment|/* anything else */
return|return
operator|(
name|string_match
argument_list|(
name|tok
argument_list|,
name|eval_hostaddr
argument_list|(
name|host
argument_list|)
argument_list|)
operator|||
operator|(
name|NOT_INADDR
argument_list|(
name|tok
argument_list|)
operator|&&
name|string_match
argument_list|(
name|tok
argument_list|,
name|eval_hostname
argument_list|(
name|host
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* string_match - match string against pattern */
end_comment

begin_function
specifier|static
name|int
name|string_match
parameter_list|(
name|tok
parameter_list|,
name|string
parameter_list|)
name|char
modifier|*
name|tok
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
name|tok
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
comment|/* suffix */
name|n
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
operator|-
name|strlen
argument_list|(
name|tok
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|>
literal|0
operator|&&
name|STR_EQ
argument_list|(
name|tok
argument_list|,
name|string
operator|+
name|n
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|STR_EQ
argument_list|(
name|tok
argument_list|,
literal|"ALL"
argument_list|)
condition|)
block|{
comment|/* all: match any */
return|return
operator|(
name|YES
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|STR_EQ
argument_list|(
name|tok
argument_list|,
literal|"KNOWN"
argument_list|)
condition|)
block|{
comment|/* not unknown */
return|return
operator|(
name|STR_NE
argument_list|(
name|string
argument_list|,
name|unknown
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|tok
index|[
operator|(
name|n
operator|=
name|strlen
argument_list|(
name|tok
argument_list|)
operator|)
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
comment|/* prefix */
return|return
operator|(
name|STRN_EQ
argument_list|(
name|tok
argument_list|,
name|string
argument_list|,
name|n
argument_list|)
operator|)
return|;
block|}
else|else
block|{
comment|/* exact match */
return|return
operator|(
name|STR_EQ
argument_list|(
name|tok
argument_list|,
name|string
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* masked_match - match address against netnumber/netmask */
end_comment

begin_function
specifier|static
name|int
name|masked_match
parameter_list|(
name|net_tok
parameter_list|,
name|mask_tok
parameter_list|,
name|string
parameter_list|)
name|char
modifier|*
name|net_tok
decl_stmt|;
name|char
modifier|*
name|mask_tok
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|unsigned
name|long
name|net
decl_stmt|;
name|unsigned
name|long
name|mask
decl_stmt|;
name|unsigned
name|long
name|addr
decl_stmt|;
comment|/*      * Disallow forms other than dotted quad: the treatment that inet_addr()      * gives to forms with less than four components is inconsistent with the      * access control language. John P. Rouillard<rouilj@cs.umb.edu>.      */
if|if
condition|(
operator|(
name|addr
operator|=
name|dot_quad_addr
argument_list|(
name|string
argument_list|)
operator|)
operator|==
name|INADDR_NONE
condition|)
return|return
operator|(
name|NO
operator|)
return|;
if|if
condition|(
operator|(
name|net
operator|=
name|dot_quad_addr
argument_list|(
name|net_tok
argument_list|)
operator|)
operator|==
name|INADDR_NONE
operator|||
operator|(
name|mask
operator|=
name|dot_quad_addr
argument_list|(
name|mask_tok
argument_list|)
operator|)
operator|==
name|INADDR_NONE
condition|)
block|{
name|tcpd_warn
argument_list|(
literal|"bad net/mask expression: %s/%s"
argument_list|,
name|net_tok
argument_list|,
name|mask_tok
argument_list|)
expr_stmt|;
return|return
operator|(
name|NO
operator|)
return|;
comment|/* not tcpd_jump() */
block|}
return|return
operator|(
operator|(
name|addr
operator|&
name|mask
operator|)
operator|==
name|net
operator|)
return|;
block|}
end_function

end_unit

