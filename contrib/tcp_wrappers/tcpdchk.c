begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * tcpdchk - examine all tcpd access control rules and inetd.conf entries   *    * Usage: tcpdchk [-a] [-d] [-i inet_conf] [-v]   *    * -a: complain about implicit "allow" at end of rule.   *    * -d: rules in current directory.   *    * -i: location of inetd.conf file.   *    * -v: show all rules.   *    * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.   *   * $FreeBSD$   */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#) tcpdchk.c 1.8 97/02/12 02:13:25"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* System libraries. */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|exit
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|optind
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|INADDR_NONE
end_ifndef

begin_define
define|#
directive|define
name|INADDR_NONE
value|(-1)
end_define

begin_comment
comment|/* XXX should be 0xffffffff */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|S_ISDIR
end_ifndef

begin_define
define|#
directive|define
name|S_ISDIR
parameter_list|(
name|m
parameter_list|)
value|(((m)& S_IFMT) == S_IFDIR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Application-specific. */
end_comment

begin_include
include|#
directive|include
file|"tcpd.h"
end_include

begin_include
include|#
directive|include
file|"inetcf.h"
end_include

begin_include
include|#
directive|include
file|"scaffold.h"
end_include

begin_comment
comment|/*   * Stolen from hosts_access.c...   */
end_comment

begin_decl_stmt
specifier|static
name|char
name|sep
index|[]
init|=
literal|", \t\n"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BUFLEN
value|2048
end_define

begin_decl_stmt
name|int
name|resident
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|hosts_access_verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|hosts_allow_table
init|=
name|HOSTS_ALLOW
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|hosts_deny_table
init|=
name|HOSTS_DENY
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|jmp_buf
name|tcpd_buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   * Local stuff.   */
end_comment

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_table
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_list
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_daemon_list
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_client_list
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_daemon
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_user
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_host
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|reserved_name
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|PERMIT
value|1
end_define

begin_define
define|#
directive|define
name|DENY
value|0
end_define

begin_define
define|#
directive|define
name|YES
value|1
end_define

begin_define
define|#
directive|define
name|NO
value|0
end_define

begin_decl_stmt
specifier|static
name|int
name|defl_verdict
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|myname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|allow_check
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|inetcf
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|struct
name|request_info
name|request
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|int
name|c
decl_stmt|;
name|myname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
comment|/*      * Parse the JCL.      */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"adi:v"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|allow_check
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|hosts_allow_table
operator|=
literal|"hosts.allow"
expr_stmt|;
name|hosts_deny_table
operator|=
literal|"hosts.deny"
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|inetcf
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|hosts_access_verbose
operator|++
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
if|if
condition|(
name|argc
operator|!=
name|optind
condition|)
name|usage
argument_list|()
expr_stmt|;
comment|/*      * When confusion really strikes...      */
if|if
condition|(
name|check_path
argument_list|(
name|REAL_DAEMON_DIR
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
name|tcpd_warn
argument_list|(
literal|"REAL_DAEMON_DIR %s: %m"
argument_list|,
name|REAL_DAEMON_DIR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|tcpd_warn
argument_list|(
literal|"REAL_DAEMON_DIR %s is not a directory"
argument_list|,
name|REAL_DAEMON_DIR
argument_list|)
expr_stmt|;
block|}
comment|/*      * Process the inet configuration file (or its moral equivalent). This      * information is used later to find references in hosts.allow/deny to      * unwrapped services, and other possible problems.      */
name|inetcf
operator|=
name|inet_cfg
argument_list|(
name|inetcf
argument_list|)
expr_stmt|;
if|if
condition|(
name|hosts_access_verbose
condition|)
name|printf
argument_list|(
literal|"Using network configuration file: %s\n"
argument_list|,
name|inetcf
argument_list|)
expr_stmt|;
comment|/*      * These are not run from inetd but may have built-in access control.      */
name|inet_set
argument_list|(
literal|"portmap"
argument_list|,
name|WR_NOT
argument_list|)
expr_stmt|;
name|inet_set
argument_list|(
literal|"rpcbind"
argument_list|,
name|WR_NOT
argument_list|)
expr_stmt|;
comment|/*      * Check accessibility of access control files.      */
operator|(
name|void
operator|)
name|check_path
argument_list|(
name|hosts_allow_table
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|check_path
argument_list|(
name|hosts_deny_table
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
comment|/*      * Fake up an arbitrary service request.      */
name|request_init
argument_list|(
operator|&
name|request
argument_list|,
name|RQ_DAEMON
argument_list|,
literal|"daemon_name"
argument_list|,
name|RQ_SERVER_NAME
argument_list|,
literal|"server_hostname"
argument_list|,
name|RQ_SERVER_ADDR
argument_list|,
literal|"server_addr"
argument_list|,
name|RQ_USER
argument_list|,
literal|"user_name"
argument_list|,
name|RQ_CLIENT_NAME
argument_list|,
literal|"client_hostname"
argument_list|,
name|RQ_CLIENT_ADDR
argument_list|,
literal|"client_addr"
argument_list|,
name|RQ_FILE
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*      * Examine all access-control rules.      */
name|defl_verdict
operator|=
name|PERMIT
expr_stmt|;
name|parse_table
argument_list|(
name|hosts_allow_table
argument_list|,
operator|&
name|request
argument_list|)
expr_stmt|;
name|defl_verdict
operator|=
name|DENY
expr_stmt|;
name|parse_table
argument_list|(
name|hosts_deny_table
argument_list|,
operator|&
name|request
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* usage - explain */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [-a] [-d] [-i inet_conf] [-v]\n"
argument_list|,
name|myname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"	-a: report rules with implicit \"ALLOW\" at end\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"	-d: use allow/deny files in current directory\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"	-i: location of inetd.conf file\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"	-v: list all rules\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* parse_table - like table_match(), but examines _all_ entries */
end_comment

begin_function
specifier|static
name|void
name|parse_table
parameter_list|(
name|table
parameter_list|,
name|request
parameter_list|)
name|char
modifier|*
name|table
decl_stmt|;
name|struct
name|request_info
modifier|*
name|request
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|real_verdict
decl_stmt|;
name|char
name|sv_list
index|[
name|BUFLEN
index|]
decl_stmt|;
comment|/* becomes list of daemons */
name|char
modifier|*
name|cl_list
decl_stmt|;
comment|/* becomes list of requests */
name|char
modifier|*
name|sh_cmd
decl_stmt|;
comment|/* becomes optional shell command */
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|verdict
decl_stmt|;
name|struct
name|tcpd_context
name|saved_context
decl_stmt|;
name|saved_context
operator|=
name|tcpd_context
expr_stmt|;
comment|/* stupid compilers */
if|if
condition|(
name|fp
operator|=
name|fopen
argument_list|(
name|table
argument_list|,
literal|"r"
argument_list|)
condition|)
block|{
name|tcpd_context
operator|.
name|file
operator|=
name|table
expr_stmt|;
name|tcpd_context
operator|.
name|line
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|xgets
argument_list|(
name|sv_list
argument_list|,
sizeof|sizeof
argument_list|(
name|sv_list
argument_list|)
argument_list|,
name|fp
argument_list|)
condition|)
block|{
if|if
condition|(
name|sv_list
index|[
name|strlen
argument_list|(
name|sv_list
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|tcpd_warn
argument_list|(
literal|"missing newline or line too long"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sv_list
index|[
literal|0
index|]
operator|==
literal|'#'
operator|||
name|sv_list
index|[
name|strspn
argument_list|(
name|sv_list
argument_list|,
literal|" \t\r\n"
argument_list|)
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|cl_list
operator|=
name|split_at
argument_list|(
name|sv_list
argument_list|,
literal|':'
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|tcpd_warn
argument_list|(
literal|"missing \":\" separator"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sh_cmd
operator|=
name|split_at
argument_list|(
name|cl_list
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|hosts_access_verbose
condition|)
name|printf
argument_list|(
literal|"\n>>> Rule %s line %d:\n"
argument_list|,
name|tcpd_context
operator|.
name|file
argument_list|,
name|tcpd_context
operator|.
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|hosts_access_verbose
condition|)
name|print_list
argument_list|(
literal|"daemons:  "
argument_list|,
name|sv_list
argument_list|)
expr_stmt|;
name|check_daemon_list
argument_list|(
name|sv_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|hosts_access_verbose
condition|)
name|print_list
argument_list|(
literal|"clients:  "
argument_list|,
name|cl_list
argument_list|)
expr_stmt|;
name|check_client_list
argument_list|(
name|cl_list
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROCESS_OPTIONS
name|real_verdict
operator|=
name|defl_verdict
expr_stmt|;
if|if
condition|(
name|sh_cmd
condition|)
block|{
name|verdict
operator|=
name|setjmp
argument_list|(
name|tcpd_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|verdict
operator|!=
literal|0
condition|)
block|{
name|real_verdict
operator|=
operator|(
name|verdict
operator|==
name|AC_PERMIT
operator|)
expr_stmt|;
block|}
else|else
block|{
name|dry_run
operator|=
literal|1
expr_stmt|;
name|process_options
argument_list|(
name|sh_cmd
argument_list|,
name|request
argument_list|)
expr_stmt|;
if|if
condition|(
name|dry_run
operator|==
literal|1
operator|&&
name|real_verdict
operator|&&
name|allow_check
condition|)
name|tcpd_warn
argument_list|(
literal|"implicit \"allow\" at end of rule"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|defl_verdict
operator|&&
name|allow_check
condition|)
block|{
name|tcpd_warn
argument_list|(
literal|"implicit \"allow\" at end of rule"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hosts_access_verbose
condition|)
name|printf
argument_list|(
literal|"access:   %s\n"
argument_list|,
name|real_verdict
condition|?
literal|"granted"
else|:
literal|"denied"
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|sh_cmd
condition|)
name|shell_cmd
argument_list|(
name|percent_x
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|sh_cmd
argument_list|,
name|request
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hosts_access_verbose
condition|)
name|printf
argument_list|(
literal|"access:   %s\n"
argument_list|,
name|defl_verdict
condition|?
literal|"granted"
else|:
literal|"denied"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|tcpd_warn
argument_list|(
literal|"cannot open %s: %m"
argument_list|,
name|table
argument_list|)
expr_stmt|;
block|}
name|tcpd_context
operator|=
name|saved_context
expr_stmt|;
block|}
end_function

begin_comment
comment|/* print_list - pretty-print a list */
end_comment

begin_function
specifier|static
name|void
name|print_list
parameter_list|(
name|title
parameter_list|,
name|list
parameter_list|)
name|char
modifier|*
name|title
decl_stmt|;
name|char
modifier|*
name|list
decl_stmt|;
block|{
name|char
name|buf
index|[
name|BUFLEN
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|next
decl_stmt|;
name|fputs
argument_list|(
name|title
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|list
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|strtok
argument_list|(
name|buf
argument_list|,
name|sep
argument_list|)
init|;
name|cp
operator|!=
literal|0
condition|;
name|cp
operator|=
name|next
control|)
block|{
name|fputs
argument_list|(
name|cp
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|next
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|sep
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|!=
literal|0
condition|)
name|fputs
argument_list|(
literal|" "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* check_daemon_list - criticize daemon list */
end_comment

begin_function
specifier|static
name|void
name|check_daemon_list
parameter_list|(
name|list
parameter_list|)
name|char
modifier|*
name|list
decl_stmt|;
block|{
name|char
name|buf
index|[
name|BUFLEN
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|host
decl_stmt|;
name|int
name|daemons
init|=
literal|0
decl_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|list
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|strtok
argument_list|(
name|buf
argument_list|,
name|sep
argument_list|)
init|;
name|cp
operator|!=
literal|0
condition|;
name|cp
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|sep
argument_list|)
control|)
block|{
if|if
condition|(
name|STR_EQ
argument_list|(
name|cp
argument_list|,
literal|"EXCEPT"
argument_list|)
condition|)
block|{
name|daemons
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|daemons
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|host
operator|=
name|split_at
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|'@'
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|check_host
argument_list|(
name|host
argument_list|)
operator|>
literal|1
condition|)
block|{
name|tcpd_warn
argument_list|(
literal|"host %s has more than one address"
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|tcpd_warn
argument_list|(
literal|"(consider using an address instead)"
argument_list|)
expr_stmt|;
block|}
name|check_daemon
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|daemons
operator|==
literal|0
condition|)
name|tcpd_warn
argument_list|(
literal|"daemon list is empty or ends in EXCEPT"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* check_client_list - criticize client list */
end_comment

begin_function
specifier|static
name|void
name|check_client_list
parameter_list|(
name|list
parameter_list|)
name|char
modifier|*
name|list
decl_stmt|;
block|{
name|char
name|buf
index|[
name|BUFLEN
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|host
decl_stmt|;
name|int
name|clients
init|=
literal|0
decl_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|list
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|strtok
argument_list|(
name|buf
argument_list|,
name|sep
argument_list|)
init|;
name|cp
operator|!=
literal|0
condition|;
name|cp
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|sep
argument_list|)
control|)
block|{
if|if
condition|(
name|STR_EQ
argument_list|(
name|cp
argument_list|,
literal|"EXCEPT"
argument_list|)
condition|)
block|{
name|clients
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|clients
operator|++
expr_stmt|;
if|if
condition|(
name|host
operator|=
name|split_at
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|'@'
argument_list|)
condition|)
block|{
comment|/* user@host */
name|check_user
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|check_host
argument_list|(
name|host
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|check_host
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|clients
operator|==
literal|0
condition|)
name|tcpd_warn
argument_list|(
literal|"client list is empty or ends in EXCEPT"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* check_daemon - criticize daemon pattern */
end_comment

begin_function
specifier|static
name|void
name|check_daemon
parameter_list|(
name|pat
parameter_list|)
name|char
modifier|*
name|pat
decl_stmt|;
block|{
if|if
condition|(
name|pat
index|[
literal|0
index|]
operator|==
literal|'@'
condition|)
block|{
name|tcpd_warn
argument_list|(
literal|"%s: daemon name begins with \"@\""
argument_list|,
name|pat
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pat
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|tcpd_warn
argument_list|(
literal|"%s: daemon name begins with \"/\""
argument_list|,
name|pat
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pat
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
name|tcpd_warn
argument_list|(
literal|"%s: daemon name begins with dot"
argument_list|,
name|pat
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pat
index|[
name|strlen
argument_list|(
name|pat
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
name|tcpd_warn
argument_list|(
literal|"%s: daemon name ends in dot"
argument_list|,
name|pat
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STR_EQ
argument_list|(
name|pat
argument_list|,
literal|"ALL"
argument_list|)
operator|||
name|STR_EQ
argument_list|(
name|pat
argument_list|,
name|unknown
argument_list|)
condition|)
block|{
comment|/* void */
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|STR_EQ
argument_list|(
name|pat
argument_list|,
literal|"FAIL"
argument_list|)
condition|)
block|{
comment|/* obsolete */
name|tcpd_warn
argument_list|(
literal|"FAIL is no longer recognized"
argument_list|)
expr_stmt|;
name|tcpd_warn
argument_list|(
literal|"(use EXCEPT or DENY instead)"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reserved_name
argument_list|(
name|pat
argument_list|)
condition|)
block|{
name|tcpd_warn
argument_list|(
literal|"%s: daemon name may be reserved word"
argument_list|,
name|pat
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|inet_get
argument_list|(
name|pat
argument_list|)
condition|)
block|{
case|case
name|WR_UNKNOWN
case|:
name|tcpd_warn
argument_list|(
literal|"%s: no such process name in %s"
argument_list|,
name|pat
argument_list|,
name|inetcf
argument_list|)
expr_stmt|;
name|inet_set
argument_list|(
name|pat
argument_list|,
name|WR_YES
argument_list|)
expr_stmt|;
comment|/* shut up next time */
break|break;
case|case
name|WR_NOT
case|:
name|tcpd_warn
argument_list|(
literal|"%s: service possibly not wrapped"
argument_list|,
name|pat
argument_list|)
expr_stmt|;
name|inet_set
argument_list|(
name|pat
argument_list|,
name|WR_YES
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* check_user - criticize user pattern */
end_comment

begin_function
specifier|static
name|void
name|check_user
parameter_list|(
name|pat
parameter_list|)
name|char
modifier|*
name|pat
decl_stmt|;
block|{
if|if
condition|(
name|pat
index|[
literal|0
index|]
operator|==
literal|'@'
condition|)
block|{
comment|/* @netgroup */
name|tcpd_warn
argument_list|(
literal|"%s: user name begins with \"@\""
argument_list|,
name|pat
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pat
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|tcpd_warn
argument_list|(
literal|"%s: user name begins with \"/\""
argument_list|,
name|pat
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pat
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
name|tcpd_warn
argument_list|(
literal|"%s: user name begins with dot"
argument_list|,
name|pat
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pat
index|[
name|strlen
argument_list|(
name|pat
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
name|tcpd_warn
argument_list|(
literal|"%s: user name ends in dot"
argument_list|,
name|pat
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STR_EQ
argument_list|(
name|pat
argument_list|,
literal|"ALL"
argument_list|)
operator|||
name|STR_EQ
argument_list|(
name|pat
argument_list|,
name|unknown
argument_list|)
operator|||
name|STR_EQ
argument_list|(
name|pat
argument_list|,
literal|"KNOWN"
argument_list|)
condition|)
block|{
comment|/* void */
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|STR_EQ
argument_list|(
name|pat
argument_list|,
literal|"FAIL"
argument_list|)
condition|)
block|{
comment|/* obsolete */
name|tcpd_warn
argument_list|(
literal|"FAIL is no longer recognized"
argument_list|)
expr_stmt|;
name|tcpd_warn
argument_list|(
literal|"(use EXCEPT or DENY instead)"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reserved_name
argument_list|(
name|pat
argument_list|)
condition|)
block|{
name|tcpd_warn
argument_list|(
literal|"%s: user name may be reserved word"
argument_list|,
name|pat
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function
specifier|static
name|int
name|is_inet6_addr
parameter_list|(
name|pat
parameter_list|)
name|char
modifier|*
name|pat
decl_stmt|;
block|{
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|res
decl_stmt|;
name|int
name|len
decl_stmt|,
name|ret
decl_stmt|;
name|char
name|ch
decl_stmt|;
if|if
condition|(
operator|*
name|pat
operator|!=
literal|'['
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|len
operator|=
name|strlen
argument_list|(
name|pat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|=
name|pat
index|[
name|len
operator|-
literal|1
index|]
operator|)
operator|!=
literal|']'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|pat
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|AF_INET6
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
name|AI_PASSIVE
operator||
name|AI_NUMERICHOST
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|getaddrinfo
argument_list|(
name|pat
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|res
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|freeaddrinfo
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|pat
index|[
name|len
operator|-
literal|1
index|]
operator|=
name|ch
expr_stmt|;
return|return
operator|(
name|ret
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* check_host - criticize host pattern */
end_comment

begin_function
specifier|static
name|int
name|check_host
parameter_list|(
name|pat
parameter_list|)
name|char
modifier|*
name|pat
decl_stmt|;
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|mask
decl_stmt|;
name|int
name|addr_count
init|=
literal|1
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|tcpd_context
name|saved_context
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|wsp
init|=
literal|" \t\r\n"
decl_stmt|;
if|if
condition|(
name|pat
index|[
literal|0
index|]
operator|==
literal|'@'
condition|)
block|{
comment|/* @netgroup */
ifdef|#
directive|ifdef
name|NO_NETGRENT
comment|/* SCO has no *netgrent() support */
else|#
directive|else
ifdef|#
directive|ifdef
name|NETGROUP
name|char
modifier|*
name|machinep
decl_stmt|;
name|char
modifier|*
name|userp
decl_stmt|;
name|char
modifier|*
name|domainp
decl_stmt|;
name|setnetgrent
argument_list|(
name|pat
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|getnetgrent
argument_list|(
operator|&
name|machinep
argument_list|,
operator|&
name|userp
argument_list|,
operator|&
name|domainp
argument_list|)
operator|==
literal|0
condition|)
name|tcpd_warn
argument_list|(
literal|"%s: unknown or empty netgroup"
argument_list|,
name|pat
operator|+
literal|1
argument_list|)
expr_stmt|;
name|endnetgrent
argument_list|()
expr_stmt|;
else|#
directive|else
name|tcpd_warn
argument_list|(
literal|"netgroup support disabled"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|pat
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
comment|/* /path/name */
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|pat
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|saved_context
operator|=
name|tcpd_context
expr_stmt|;
name|tcpd_context
operator|.
name|file
operator|=
name|pat
expr_stmt|;
name|tcpd_context
operator|.
name|line
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
condition|)
block|{
name|tcpd_context
operator|.
name|line
operator|++
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|strtok
argument_list|(
name|buf
argument_list|,
name|wsp
argument_list|)
init|;
name|cp
condition|;
name|cp
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|wsp
argument_list|)
control|)
name|check_host
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
name|tcpd_context
operator|=
name|saved_context
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|tcpd_warn
argument_list|(
literal|"open %s: %m"
argument_list|,
name|pat
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mask
operator|=
name|split_at
argument_list|(
name|pat
argument_list|,
literal|'/'
argument_list|)
condition|)
block|{
comment|/* network/netmask */
ifdef|#
directive|ifdef
name|INET6
name|int
name|mask_len
decl_stmt|;
if|if
condition|(
operator|(
name|dot_quad_addr
argument_list|(
name|pat
argument_list|)
operator|==
name|INADDR_NONE
operator|||
name|dot_quad_addr
argument_list|(
name|mask
argument_list|)
operator|==
name|INADDR_NONE
operator|)
operator|&&
operator|(
operator|!
name|is_inet6_addr
argument_list|(
name|pat
argument_list|)
operator|||
operator|(
operator|(
name|mask_len
operator|=
name|atoi
argument_list|(
name|mask
argument_list|)
operator|)
operator|<
literal|0
operator|||
name|mask_len
operator|>
literal|128
operator|)
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|dot_quad_addr
argument_list|(
name|pat
argument_list|)
operator|==
name|INADDR_NONE
operator|||
name|dot_quad_addr
argument_list|(
name|mask
argument_list|)
operator|==
name|INADDR_NONE
condition|)
endif|#
directive|endif
name|tcpd_warn
argument_list|(
literal|"%s/%s: bad net/mask pattern"
argument_list|,
name|pat
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STR_EQ
argument_list|(
name|pat
argument_list|,
literal|"FAIL"
argument_list|)
condition|)
block|{
comment|/* obsolete */
name|tcpd_warn
argument_list|(
literal|"FAIL is no longer recognized"
argument_list|)
expr_stmt|;
name|tcpd_warn
argument_list|(
literal|"(use EXCEPT or DENY instead)"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reserved_name
argument_list|(
name|pat
argument_list|)
condition|)
block|{
comment|/* other reserved */
comment|/* void */
empty_stmt|;
ifdef|#
directive|ifdef
name|INET6
block|}
elseif|else
if|if
condition|(
name|is_inet6_addr
argument_list|(
name|pat
argument_list|)
condition|)
block|{
comment|/* IPv6 address */
name|addr_count
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|NOT_INADDR
argument_list|(
name|pat
argument_list|)
condition|)
block|{
comment|/* internet name */
if|if
condition|(
name|pat
index|[
name|strlen
argument_list|(
name|pat
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
name|tcpd_warn
argument_list|(
literal|"%s: domain or host name ends in dot"
argument_list|,
name|pat
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pat
index|[
literal|0
index|]
operator|!=
literal|'.'
condition|)
block|{
name|addr_count
operator|=
name|check_dns
argument_list|(
name|pat
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* numeric form */
if|if
condition|(
name|STR_EQ
argument_list|(
name|pat
argument_list|,
literal|"0.0.0.0"
argument_list|)
operator|||
name|STR_EQ
argument_list|(
name|pat
argument_list|,
literal|"255.255.255.255"
argument_list|)
condition|)
block|{
comment|/* void */
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|pat
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
name|tcpd_warn
argument_list|(
literal|"%s: network number begins with dot"
argument_list|,
name|pat
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pat
index|[
name|strlen
argument_list|(
name|pat
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'.'
condition|)
block|{
name|check_dns
argument_list|(
name|pat
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|addr_count
operator|)
return|;
block|}
end_function

begin_comment
comment|/* reserved_name - determine if name is reserved */
end_comment

begin_function
specifier|static
name|int
name|reserved_name
parameter_list|(
name|pat
parameter_list|)
name|char
modifier|*
name|pat
decl_stmt|;
block|{
return|return
operator|(
name|STR_EQ
argument_list|(
name|pat
argument_list|,
name|unknown
argument_list|)
operator|||
name|STR_EQ
argument_list|(
name|pat
argument_list|,
literal|"KNOWN"
argument_list|)
operator|||
name|STR_EQ
argument_list|(
name|pat
argument_list|,
name|paranoid
argument_list|)
operator|||
name|STR_EQ
argument_list|(
name|pat
argument_list|,
literal|"ALL"
argument_list|)
operator|||
name|STR_EQ
argument_list|(
name|pat
argument_list|,
literal|"LOCAL"
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

