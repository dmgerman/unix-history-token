begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*      $NetBSD: meta.c,v 1.67 2016/08/17 15:52:42 sjg Exp $ */
end_comment

begin_comment
comment|/*  * Implement 'meta' mode.  * Adapted from John Birrell's patches to FreeBSD make.  * --sjg  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2009-2016, Juniper Networks, Inc.  * Portions Copyright (c) 2009, John Birrell.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions   * are met:   * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.   * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.    *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.   */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_META
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIBGEN_H
end_ifdef

begin_include
include|#
directive|include
file|<libgen.h>
end_include

begin_elif
elif|#
directive|elif
operator|!
name|defined
argument_list|(
name|HAVE_DIRNAME
argument_list|)
end_elif

begin_function_decl
name|char
modifier|*
name|dirname
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_CONFIG_H
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_ERR_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"make.h"
end_include

begin_include
include|#
directive|include
file|"job.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_FILEMON_H
end_ifdef

begin_include
include|#
directive|include
file|<filemon.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|USE_FILEMON
argument_list|)
operator|&&
name|defined
argument_list|(
name|FILEMON_SET_FD
argument_list|)
end_if

begin_define
define|#
directive|define
name|USE_FILEMON
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|BuildMon
name|Mybm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for compat */
end_comment

begin_decl_stmt
specifier|static
name|Lst
name|metaBailiwick
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* our scope of control */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|metaBailiwickStr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* string storage for the list */
end_comment

begin_decl_stmt
specifier|static
name|Lst
name|metaIgnorePaths
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* paths we deliberately ignore */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|metaIgnorePathsStr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* string storage for the list */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAKE_META_IGNORE_PATHS
end_ifndef

begin_define
define|#
directive|define
name|MAKE_META_IGNORE_PATHS
value|".MAKE.META.IGNORE_PATHS"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAKE_META_IGNORE_PATTERNS
end_ifndef

begin_define
define|#
directive|define
name|MAKE_META_IGNORE_PATTERNS
value|".MAKE.META.IGNORE_PATTERNS"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAKE_META_IGNORE_FILTER
end_ifndef

begin_define
define|#
directive|define
name|MAKE_META_IGNORE_FILTER
value|".MAKE.META.IGNORE_FILTER"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|Boolean
name|useMeta
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Boolean
name|useFilemon
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Boolean
name|writeMeta
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Boolean
name|metaMissing
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* oodate if missing */
end_comment

begin_decl_stmt
specifier|static
name|Boolean
name|filemonMissing
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* oodate if missing */
end_comment

begin_decl_stmt
specifier|static
name|Boolean
name|metaEnv
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't save env unless asked */
end_comment

begin_decl_stmt
specifier|static
name|Boolean
name|metaVerbose
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Boolean
name|metaIgnoreCMDs
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ignore CMDs in .meta files */
end_comment

begin_decl_stmt
specifier|static
name|Boolean
name|metaIgnorePatterns
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* do we need to do pattern matches */
end_comment

begin_decl_stmt
specifier|static
name|Boolean
name|metaIgnoreFilter
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* do we have more complex filtering? */
end_comment

begin_decl_stmt
specifier|static
name|Boolean
name|metaCurdirOk
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* write .meta in .CURDIR Ok? */
end_comment

begin_decl_stmt
specifier|static
name|Boolean
name|metaSilent
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if we have a .meta be SILENT */
end_comment

begin_decl_stmt
specifier|extern
name|Boolean
name|forceJobs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Boolean
name|comatMake
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAKE_META_PREFIX
value|".MAKE.META.PREFIX"
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|N2U
end_ifndef

begin_define
define|#
directive|define
name|N2U
parameter_list|(
name|n
parameter_list|,
name|u
parameter_list|)
value|(((n) + ((u) - 1)) / (u))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ROUNDUP
end_ifndef

begin_define
define|#
directive|define
name|ROUNDUP
parameter_list|(
name|n
parameter_list|,
name|u
parameter_list|)
value|(N2U((n), (u)) * (u))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_STRSEP
argument_list|)
end_if

begin_define
define|#
directive|define
name|strsep
parameter_list|(
name|s
parameter_list|,
name|d
parameter_list|)
value|stresep((s), (d), 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Filemon is a kernel module which snoops certain syscalls.  *  * C chdir  * E exec  * F [v]fork  * L [sym]link  * M rename  * R read  * W write  * S stat  *  * See meta_oodate below - we mainly care about 'E' and 'R'.  *  * We can still use meta mode without filemon, but   * the benefits are more limited.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_FILEMON
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|_PATH_FILEMON
end_ifndef

begin_define
define|#
directive|define
name|_PATH_FILEMON
value|"/dev/filemon"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Open the filemon device.  */
end_comment

begin_function
specifier|static
name|void
name|filemon_open
parameter_list|(
name|BuildMon
modifier|*
name|pbm
parameter_list|)
block|{
name|int
name|retry
decl_stmt|;
name|pbm
operator|->
name|mon_fd
operator|=
name|pbm
operator|->
name|filemon_fd
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|useFilemon
condition|)
return|return;
for|for
control|(
name|retry
operator|=
literal|5
init|;
name|retry
operator|>=
literal|0
condition|;
name|retry
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|pbm
operator|->
name|filemon_fd
operator|=
name|open
argument_list|(
name|_PATH_FILEMON
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|>=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|pbm
operator|->
name|filemon_fd
operator|<
literal|0
condition|)
block|{
name|useFilemon
operator|=
name|FALSE
expr_stmt|;
name|warn
argument_list|(
literal|"Could not open %s"
argument_list|,
name|_PATH_FILEMON
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * We use a file outside of '.'      * to avoid a FreeBSD kernel bug where unlink invalidates      * cwd causing getcwd to do a lot more work.      * We only care about the descriptor.      */
name|pbm
operator|->
name|mon_fd
operator|=
name|mkTempFile
argument_list|(
literal|"filemon.XXXXXX"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|pbm
operator|->
name|filemon_fd
argument_list|,
name|FILEMON_SET_FD
argument_list|,
operator|&
name|pbm
operator|->
name|mon_fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|err
argument_list|(
literal|1
argument_list|,
literal|"Could not set filemon file descriptor!"
argument_list|)
expr_stmt|;
block|}
comment|/* we don't need these once we exec */
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|pbm
operator|->
name|mon_fd
argument_list|,
name|F_SETFD
argument_list|,
name|FD_CLOEXEC
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|pbm
operator|->
name|filemon_fd
argument_list|,
name|F_SETFD
argument_list|,
name|FD_CLOEXEC
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read the build monitor output file and write records to the target's  * metadata file.  */
end_comment

begin_function
specifier|static
name|int
name|filemon_read
parameter_list|(
name|FILE
modifier|*
name|mfp
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Check if we're not writing to a meta data file.*/
if|if
condition|(
name|mfp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* not interested */
return|return
literal|0
return|;
block|}
comment|/* rewind */
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|mfp
argument_list|,
literal|"\n-- filemon acquired metadata --\n"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|int
operator|)
name|fwrite
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|n
argument_list|,
name|mfp
argument_list|)
operator|<
name|n
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
block|}
name|fflush
argument_list|(
name|mfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
name|error
operator|=
name|errno
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * when realpath() fails,  * we use this, to clean up ./ and ../  */
end_comment

begin_function
specifier|static
name|void
name|eat_dots
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|bufsz
parameter_list|,
name|int
name|dots
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|cp2
decl_stmt|;
specifier|const
name|char
modifier|*
name|eat
decl_stmt|;
name|size_t
name|eatlen
decl_stmt|;
switch|switch
condition|(
name|dots
condition|)
block|{
case|case
literal|1
case|:
name|eat
operator|=
literal|"/./"
expr_stmt|;
name|eatlen
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|eat
operator|=
literal|"/../"
expr_stmt|;
name|eatlen
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
return|return;
block|}
do|do
block|{
name|cp
operator|=
name|strstr
argument_list|(
name|buf
argument_list|,
name|eat
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
name|cp2
operator|=
name|cp
operator|+
name|eatlen
expr_stmt|;
if|if
condition|(
name|dots
operator|==
literal|2
operator|&&
name|cp
operator|>
name|buf
condition|)
block|{
do|do
block|{
name|cp
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|cp
operator|>
name|buf
operator|&&
operator|*
name|cp
operator|!=
literal|'/'
condition|)
do|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'/'
condition|)
block|{
name|strlcpy
argument_list|(
name|cp
argument_list|,
name|cp2
argument_list|,
name|bufsz
operator|-
operator|(
name|cp
operator|-
name|buf
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return;
comment|/* can't happen? */
block|}
block|}
block|}
do|while
condition|(
name|cp
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|meta_name
parameter_list|(
name|char
modifier|*
name|mname
parameter_list|,
name|size_t
name|mnamelen
parameter_list|,
specifier|const
name|char
modifier|*
name|dname
parameter_list|,
specifier|const
name|char
modifier|*
name|tname
parameter_list|,
specifier|const
name|char
modifier|*
name|cwd
parameter_list|)
block|{
name|char
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
modifier|*
name|rp
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|tp
decl_stmt|;
comment|/*      * Weed out relative paths from the target file name.      * We have to be careful though since if target is a      * symlink, the result will be unstable.      * So we use realpath() just to get the dirname, and leave the      * basename as given to us.      */
if|if
condition|(
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|tname
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|cached_realpath
argument_list|(
name|tname
argument_list|,
name|buf
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|rp
operator|=
name|strrchr
argument_list|(
name|buf
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|)
block|{
name|rp
operator|++
expr_stmt|;
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
name|rp
argument_list|)
operator|!=
literal|0
condition|)
name|strlcpy
argument_list|(
name|rp
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
operator|(
name|rp
operator|-
name|buf
operator|)
argument_list|)
expr_stmt|;
block|}
name|tname
operator|=
name|buf
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * We likely have a directory which is about to be made. 	     * We pretend realpath() succeeded, to have a chance 	     * of generating the same meta file name that we will 	     * next time through. 	     */
if|if
condition|(
name|tname
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|tname
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|cwd
argument_list|,
name|tname
argument_list|)
expr_stmt|;
block|}
name|eat_dots
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* ./ */
name|eat_dots
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* ../ */
name|tname
operator|=
name|buf
expr_stmt|;
block|}
block|}
comment|/* on some systems dirname may modify its arg */
name|tp
operator|=
name|bmake_strdup
argument_list|(
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|dname
argument_list|,
name|dirname
argument_list|(
name|tp
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|snprintf
argument_list|(
name|mname
argument_list|,
name|mnamelen
argument_list|,
literal|"%s.meta"
argument_list|,
name|tname
argument_list|)
expr_stmt|;
else|else
block|{
name|snprintf
argument_list|(
name|mname
argument_list|,
name|mnamelen
argument_list|,
literal|"%s/%s.meta"
argument_list|,
name|dname
argument_list|,
name|tname
argument_list|)
expr_stmt|;
comment|/* 	 * Replace path separators in the file name after the 	 * current object directory path. 	 */
name|cp
operator|=
name|mname
operator|+
name|strlen
argument_list|(
name|dname
argument_list|)
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'/'
condition|)
operator|*
name|cp
operator|=
literal|'_'
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
name|mname
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return true if running ${.MAKE}  * Bypassed if target is flagged .MAKE  */
end_comment

begin_function
specifier|static
name|int
name|is_submake
parameter_list|(
name|void
modifier|*
name|cmdp
parameter_list|,
name|void
modifier|*
name|gnp
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|p_make
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|p_len
decl_stmt|;
name|char
modifier|*
name|cmd
init|=
name|cmdp
decl_stmt|;
name|GNode
modifier|*
name|gn
init|=
name|gnp
decl_stmt|;
name|char
modifier|*
name|mp
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|cp2
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
comment|/* keep looking */
if|if
condition|(
operator|!
name|p_make
condition|)
block|{
name|p_make
operator|=
name|Var_Value
argument_list|(
literal|".MAKE"
argument_list|,
name|gn
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|p_len
operator|=
name|strlen
argument_list|(
name|p_make
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
name|strchr
argument_list|(
name|cmd
argument_list|,
literal|'$'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|)
condition|)
block|{
name|mp
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|cmd
argument_list|,
name|gn
argument_list|,
name|VARF_WANTRES
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|mp
expr_stmt|;
block|}
name|cp2
operator|=
name|strstr
argument_list|(
name|cmd
argument_list|,
name|p_make
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp2
operator|)
condition|)
block|{
switch|switch
condition|(
name|cp2
index|[
name|p_len
index|]
condition|)
block|{
case|case
literal|'\0'
case|:
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\n'
case|:
name|rc
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cp2
operator|>
name|cmd
operator|&&
name|rc
operator|>
literal|0
condition|)
block|{
switch|switch
condition|(
name|cp2
index|[
operator|-
literal|1
index|]
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\n'
case|:
break|break;
default|default:
name|rc
operator|=
literal|0
expr_stmt|;
comment|/* no match */
break|break;
block|}
block|}
block|}
name|free
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|meta_file_s
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|GNode
modifier|*
name|gn
decl_stmt|;
block|}
name|meta_file_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|printCMD
parameter_list|(
name|void
modifier|*
name|cmdp
parameter_list|,
name|void
modifier|*
name|mfpp
parameter_list|)
block|{
name|meta_file_t
modifier|*
name|mfp
init|=
name|mfpp
decl_stmt|;
name|char
modifier|*
name|cmd
init|=
name|cmdp
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|cmd
argument_list|,
literal|'$'
argument_list|)
condition|)
block|{
name|cmd
operator|=
name|cp
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|cmd
argument_list|,
name|mfp
operator|->
name|gn
argument_list|,
name|VARF_WANTRES
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|mfp
operator|->
name|fp
argument_list|,
literal|"CMD %s\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Certain node types never get a .meta file  */
end_comment

begin_define
define|#
directive|define
name|SKIP_META_TYPE
parameter_list|(
name|_type
parameter_list|)
value|do { \     if ((gn->type& __CONCAT(OP_, _type))) {	\ 	if (verbose) { \ 	    fprintf(debug_file, "Skipping meta for %s: .%s\n", \ 		    gn->name, __STRING(_type));		       \ 	} \ 	return FALSE; \     } \ } while (0)
end_define

begin_comment
comment|/*  * Do we need/want a .meta file ?  */
end_comment

begin_function
specifier|static
name|Boolean
name|meta_needed
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|,
specifier|const
name|char
modifier|*
name|dname
parameter_list|,
name|char
modifier|*
name|objdir
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|struct
name|stat
name|fs
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
name|verbose
operator|=
name|DEBUG
argument_list|(
name|META
argument_list|)
expr_stmt|;
comment|/* This may be a phony node which we don't want meta data for... */
comment|/* Skip .meta for .BEGIN, .END, .ERROR etc as well. */
comment|/* Or it may be explicitly flagged as .NOMETA */
name|SKIP_META_TYPE
argument_list|(
name|NOMETA
argument_list|)
expr_stmt|;
comment|/* Unless it is explicitly flagged as .META */
if|if
condition|(
operator|!
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_META
operator|)
condition|)
block|{
name|SKIP_META_TYPE
argument_list|(
name|PHONY
argument_list|)
expr_stmt|;
name|SKIP_META_TYPE
argument_list|(
name|SPECIAL
argument_list|)
expr_stmt|;
name|SKIP_META_TYPE
argument_list|(
name|MAKE
argument_list|)
expr_stmt|;
block|}
comment|/* Check if there are no commands to execute. */
if|if
condition|(
name|Lst_IsEmpty
argument_list|(
name|gn
operator|->
name|commands
argument_list|)
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"Skipping meta for %s: no commands\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|(
name|gn
operator|->
name|type
operator|&
operator|(
name|OP_META
operator||
name|OP_SUBMAKE
operator|)
operator|)
operator|==
name|OP_SUBMAKE
condition|)
block|{
comment|/* OP_SUBMAKE is a bit too aggressive */
if|if
condition|(
name|Lst_ForEach
argument_list|(
name|gn
operator|->
name|commands
argument_list|,
name|is_submake
argument_list|,
name|gn
argument_list|)
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|META
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"Skipping meta for %s: .SUBMAKE\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
comment|/* The object directory may not exist. Check it.. */
if|if
condition|(
name|cached_stat
argument_list|(
name|dname
argument_list|,
operator|&
name|fs
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"Skipping meta for %s: no .OBJDIR\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* make sure these are canonical */
if|if
condition|(
name|cached_realpath
argument_list|(
name|dname
argument_list|,
name|objdir
argument_list|)
condition|)
name|dname
operator|=
name|objdir
expr_stmt|;
comment|/* If we aren't in the object directory, don't create a meta file. */
if|if
condition|(
operator|!
name|metaCurdirOk
operator|&&
name|strcmp
argument_list|(
name|curdir
argument_list|,
name|dname
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"Skipping meta for %s: .OBJDIR == .CURDIR\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|FILE
modifier|*
name|meta_create
parameter_list|(
name|BuildMon
modifier|*
name|pbm
parameter_list|,
name|GNode
modifier|*
name|gn
parameter_list|)
block|{
name|meta_file_t
name|mf
decl_stmt|;
name|char
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|objdir
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|dname
decl_stmt|;
specifier|const
name|char
modifier|*
name|tname
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|p
index|[
literal|4
index|]
decl_stmt|;
comment|/*>= possible uses */
name|int
name|i
decl_stmt|;
name|mf
operator|.
name|fp
operator|=
name|NULL
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|dname
operator|=
name|Var_Value
argument_list|(
literal|".OBJDIR"
argument_list|,
name|gn
argument_list|,
operator|&
name|p
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
name|tname
operator|=
name|Var_Value
argument_list|(
name|TARGET
argument_list|,
name|gn
argument_list|,
operator|&
name|p
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
comment|/* if this succeeds objdir is realpath of dname */
if|if
condition|(
operator|!
name|meta_needed
argument_list|(
name|gn
argument_list|,
name|dname
argument_list|,
name|objdir
argument_list|,
name|TRUE
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|dname
operator|=
name|objdir
expr_stmt|;
if|if
condition|(
name|metaVerbose
condition|)
block|{
name|char
modifier|*
name|mp
decl_stmt|;
comment|/* Describe the target we are building */
name|mp
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
literal|"${"
name|MAKE_META_PREFIX
literal|"}"
argument_list|,
name|gn
argument_list|,
name|VARF_WANTRES
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s\n"
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
comment|/* Get the basename of the target */
if|if
condition|(
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|tname
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|cp
operator|=
name|tname
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|++
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|writeMeta
condition|)
comment|/* Don't create meta data. */
goto|goto
name|out
goto|;
name|fname
operator|=
name|meta_name
argument_list|(
name|pbm
operator|->
name|meta_fname
argument_list|,
sizeof|sizeof
argument_list|(
name|pbm
operator|->
name|meta_fname
argument_list|)
argument_list|,
name|dname
argument_list|,
name|tname
argument_list|,
name|objdir
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_META_MODE
if|if
condition|(
name|DEBUG
argument_list|(
name|META
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"meta_create: %s\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|mf
operator|.
name|fp
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Could not open meta file '%s'"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|mf
operator|.
name|fp
argument_list|,
literal|"# Meta data file %s\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|mf
operator|.
name|gn
operator|=
name|gn
expr_stmt|;
name|Lst_ForEach
argument_list|(
name|gn
operator|->
name|commands
argument_list|,
name|printCMD
argument_list|,
operator|&
name|mf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|mf
operator|.
name|fp
argument_list|,
literal|"CWD %s\n"
argument_list|,
name|getcwd
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|mf
operator|.
name|fp
argument_list|,
literal|"TARGET %s\n"
argument_list|,
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|metaEnv
condition|)
block|{
for|for
control|(
name|ptr
operator|=
name|environ
init|;
operator|*
name|ptr
operator|!=
name|NULL
condition|;
name|ptr
operator|++
control|)
name|fprintf
argument_list|(
name|mf
operator|.
name|fp
argument_list|,
literal|"ENV %s\n"
argument_list|,
operator|*
name|ptr
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|mf
operator|.
name|fp
argument_list|,
literal|"-- command output --\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|mf
operator|.
name|fp
argument_list|)
expr_stmt|;
name|Var_Append
argument_list|(
literal|".MAKE.META.FILES"
argument_list|,
name|fname
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
name|Var_Append
argument_list|(
literal|".MAKE.META.CREATED"
argument_list|,
name|fname
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
name|gn
operator|->
name|type
operator||=
name|OP_META
expr_stmt|;
comment|/* in case anyone wants to know */
if|if
condition|(
name|metaSilent
condition|)
block|{
name|gn
operator|->
name|type
operator||=
name|OP_SILENT
expr_stmt|;
block|}
name|out
label|:
for|for
control|(
name|i
operator|--
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|free
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|mf
operator|.
name|fp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|Boolean
name|boolValue
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'N'
case|:
case|case
literal|'n'
case|:
case|case
literal|'F'
case|:
case|case
literal|'f'
case|:
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Initialization we need before reading makefiles.  */
end_comment

begin_function
name|void
name|meta_init
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_FILEMON
comment|/* this allows makefiles to test if we have filemon support */
name|Var_Set
argument_list|(
literal|".MAKE.PATH_FILEMON"
argument_list|,
name|_PATH_FILEMON
argument_list|,
name|VAR_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_define
define|#
directive|define
name|get_mode_bf
parameter_list|(
name|bf
parameter_list|,
name|token
parameter_list|)
define|\
value|if ((cp = strstr(make_mode, token))) \ 	bf = boolValue(&cp[sizeof(token) - 1])
end_define

begin_comment
comment|/*  * Initialization we need after reading makefiles.  */
end_comment

begin_function
name|void
name|meta_mode_init
parameter_list|(
specifier|const
name|char
modifier|*
name|make_mode
parameter_list|)
block|{
specifier|static
name|int
name|once
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|useMeta
operator|=
name|TRUE
expr_stmt|;
name|useFilemon
operator|=
name|TRUE
expr_stmt|;
name|writeMeta
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|make_mode
condition|)
block|{
if|if
condition|(
name|strstr
argument_list|(
name|make_mode
argument_list|,
literal|"env"
argument_list|)
condition|)
name|metaEnv
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|strstr
argument_list|(
name|make_mode
argument_list|,
literal|"verb"
argument_list|)
condition|)
name|metaVerbose
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|strstr
argument_list|(
name|make_mode
argument_list|,
literal|"read"
argument_list|)
condition|)
name|writeMeta
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|strstr
argument_list|(
name|make_mode
argument_list|,
literal|"nofilemon"
argument_list|)
condition|)
name|useFilemon
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|strstr
argument_list|(
name|make_mode
argument_list|,
literal|"ignore-cmd"
argument_list|)
condition|)
name|metaIgnoreCMDs
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|useFilemon
condition|)
name|get_mode_bf
argument_list|(
name|filemonMissing
argument_list|,
literal|"missing-filemon="
argument_list|)
expr_stmt|;
name|get_mode_bf
argument_list|(
name|metaCurdirOk
argument_list|,
literal|"curdirok="
argument_list|)
expr_stmt|;
name|get_mode_bf
argument_list|(
name|metaMissing
argument_list|,
literal|"missing-meta="
argument_list|)
expr_stmt|;
name|get_mode_bf
argument_list|(
name|metaSilent
argument_list|,
literal|"silent="
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|metaVerbose
operator|&&
operator|!
name|Var_Exists
argument_list|(
name|MAKE_META_PREFIX
argument_list|,
name|VAR_GLOBAL
argument_list|)
condition|)
block|{
comment|/* 	 * The default value for MAKE_META_PREFIX 	 * prints the absolute path of the target. 	 * This works be cause :H will generate '.' if there is no / 	 * and :tA will resolve that to cwd. 	 */
name|Var_Set
argument_list|(
name|MAKE_META_PREFIX
argument_list|,
literal|"Building ${.TARGET:H:tA}/${.TARGET:T}"
argument_list|,
name|VAR_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|once
condition|)
return|return;
name|once
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|&
name|Mybm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|Mybm
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * We consider ourselves master of all within ${.MAKE.META.BAILIWICK}      */
name|metaBailiwick
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|metaBailiwickStr
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
literal|"${.MAKE.META.BAILIWICK:O:u:tA}"
argument_list|,
name|VAR_GLOBAL
argument_list|,
name|VARF_WANTRES
argument_list|)
expr_stmt|;
if|if
condition|(
name|metaBailiwickStr
condition|)
block|{
name|str2Lst_Append
argument_list|(
name|metaBailiwick
argument_list|,
name|metaBailiwickStr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/*      * We ignore any paths that start with ${.MAKE.META.IGNORE_PATHS}      */
name|metaIgnorePaths
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|Var_Append
argument_list|(
name|MAKE_META_IGNORE_PATHS
argument_list|,
literal|"/dev /etc /proc /tmp /var/run /var/tmp ${TMPDIR}"
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
name|metaIgnorePathsStr
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
literal|"${"
name|MAKE_META_IGNORE_PATHS
literal|":O:u:tA}"
argument_list|,
name|VAR_GLOBAL
argument_list|,
name|VARF_WANTRES
argument_list|)
expr_stmt|;
if|if
condition|(
name|metaIgnorePathsStr
condition|)
block|{
name|str2Lst_Append
argument_list|(
name|metaIgnorePaths
argument_list|,
name|metaIgnorePathsStr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/*      * We ignore any paths that match ${.MAKE.META.IGNORE_PATTERNS}      */
name|cp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|Var_Value
argument_list|(
name|MAKE_META_IGNORE_PATTERNS
argument_list|,
name|VAR_GLOBAL
argument_list|,
operator|&
name|cp
argument_list|)
condition|)
block|{
name|metaIgnorePatterns
operator|=
name|TRUE
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|Var_Value
argument_list|(
name|MAKE_META_IGNORE_FILTER
argument_list|,
name|VAR_GLOBAL
argument_list|,
operator|&
name|cp
argument_list|)
condition|)
block|{
name|metaIgnoreFilter
operator|=
name|TRUE
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * In each case below we allow for job==NULL  */
end_comment

begin_function
name|void
name|meta_job_start
parameter_list|(
name|Job
modifier|*
name|job
parameter_list|,
name|GNode
modifier|*
name|gn
parameter_list|)
block|{
name|BuildMon
modifier|*
name|pbm
decl_stmt|;
if|if
condition|(
name|job
operator|!=
name|NULL
condition|)
block|{
name|pbm
operator|=
operator|&
name|job
operator|->
name|bm
expr_stmt|;
block|}
else|else
block|{
name|pbm
operator|=
operator|&
name|Mybm
expr_stmt|;
block|}
name|pbm
operator|->
name|mfp
operator|=
name|meta_create
argument_list|(
name|pbm
argument_list|,
name|gn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_FILEMON_ONCE
comment|/* compat mode we open the filemon dev once per command */
if|if
condition|(
name|job
operator|==
name|NULL
condition|)
return|return;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_FILEMON
if|if
condition|(
name|pbm
operator|->
name|mfp
operator|!=
name|NULL
operator|&&
name|useFilemon
condition|)
block|{
name|filemon_open
argument_list|(
name|pbm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pbm
operator|->
name|mon_fd
operator|=
name|pbm
operator|->
name|filemon_fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * The child calls this before doing anything.  * It does not disturb our state.  */
end_comment

begin_function
name|void
name|meta_job_child
parameter_list|(
name|Job
modifier|*
name|job
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_FILEMON
name|BuildMon
modifier|*
name|pbm
decl_stmt|;
if|if
condition|(
name|job
operator|!=
name|NULL
condition|)
block|{
name|pbm
operator|=
operator|&
name|job
operator|->
name|bm
expr_stmt|;
block|}
else|else
block|{
name|pbm
operator|=
operator|&
name|Mybm
expr_stmt|;
block|}
if|if
condition|(
name|pbm
operator|->
name|mfp
operator|!=
name|NULL
condition|)
block|{
name|close
argument_list|(
name|fileno
argument_list|(
name|pbm
operator|->
name|mfp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|useFilemon
condition|)
block|{
name|pid_t
name|pid
decl_stmt|;
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|pbm
operator|->
name|filemon_fd
argument_list|,
name|FILEMON_SET_PID
argument_list|,
operator|&
name|pid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|err
argument_list|(
literal|1
argument_list|,
literal|"Could not set filemon pid!"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|meta_job_error
parameter_list|(
name|Job
modifier|*
name|job
parameter_list|,
name|GNode
modifier|*
name|gn
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|status
parameter_list|)
block|{
name|char
name|cwd
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|BuildMon
modifier|*
name|pbm
decl_stmt|;
if|if
condition|(
name|job
operator|!=
name|NULL
condition|)
block|{
name|pbm
operator|=
operator|&
name|job
operator|->
name|bm
expr_stmt|;
if|if
condition|(
operator|!
name|gn
condition|)
name|gn
operator|=
name|job
operator|->
name|node
expr_stmt|;
block|}
else|else
block|{
name|pbm
operator|=
operator|&
name|Mybm
expr_stmt|;
block|}
if|if
condition|(
name|pbm
operator|->
name|mfp
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|pbm
operator|->
name|mfp
argument_list|,
literal|"*** Error code %d%s\n"
argument_list|,
name|status
argument_list|,
operator|(
name|flags
operator|&
name|JOB_IGNERR
operator|)
condition|?
literal|"(ignored)"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gn
condition|)
block|{
name|Var_Set
argument_list|(
literal|".ERROR_TARGET"
argument_list|,
name|gn
operator|->
name|path
condition|?
name|gn
operator|->
name|path
else|:
name|gn
operator|->
name|name
argument_list|,
name|VAR_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|getcwd
argument_list|(
name|cwd
argument_list|,
sizeof|sizeof
argument_list|(
name|cwd
argument_list|)
argument_list|)
expr_stmt|;
name|Var_Set
argument_list|(
literal|".ERROR_CWD"
argument_list|,
name|cwd
argument_list|,
name|VAR_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pbm
operator|->
name|meta_fname
index|[
literal|0
index|]
condition|)
block|{
name|Var_Set
argument_list|(
literal|".ERROR_META_FILE"
argument_list|,
name|pbm
operator|->
name|meta_fname
argument_list|,
name|VAR_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|meta_job_finish
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|meta_job_output
parameter_list|(
name|Job
modifier|*
name|job
parameter_list|,
name|char
modifier|*
name|cp
parameter_list|,
specifier|const
name|char
modifier|*
name|nl
parameter_list|)
block|{
name|BuildMon
modifier|*
name|pbm
decl_stmt|;
if|if
condition|(
name|job
operator|!=
name|NULL
condition|)
block|{
name|pbm
operator|=
operator|&
name|job
operator|->
name|bm
expr_stmt|;
block|}
else|else
block|{
name|pbm
operator|=
operator|&
name|Mybm
expr_stmt|;
block|}
if|if
condition|(
name|pbm
operator|->
name|mfp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|metaVerbose
condition|)
block|{
specifier|static
name|char
modifier|*
name|meta_prefix
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|meta_prefix_len
decl_stmt|;
if|if
condition|(
operator|!
name|meta_prefix
condition|)
block|{
name|char
modifier|*
name|cp2
decl_stmt|;
name|meta_prefix
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
literal|"${"
name|MAKE_META_PREFIX
literal|"}"
argument_list|,
name|VAR_GLOBAL
argument_list|,
name|VARF_WANTRES
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp2
operator|=
name|strchr
argument_list|(
name|meta_prefix
argument_list|,
literal|'$'
argument_list|)
operator|)
condition|)
name|meta_prefix_len
operator|=
name|cp2
operator|-
name|meta_prefix
expr_stmt|;
else|else
name|meta_prefix_len
operator|=
name|strlen
argument_list|(
name|meta_prefix
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
name|meta_prefix
argument_list|,
name|meta_prefix_len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cp
operator|=
name|strchr
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
operator|++
condition|)
return|return;
block|}
block|}
name|fprintf
argument_list|(
name|pbm
operator|->
name|mfp
argument_list|,
literal|"%s%s"
argument_list|,
name|cp
argument_list|,
name|nl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|meta_cmd_finish
parameter_list|(
name|void
modifier|*
name|pbmp
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_FILEMON
name|BuildMon
modifier|*
name|pbm
init|=
name|pbmp
decl_stmt|;
name|int
name|x
decl_stmt|;
if|if
condition|(
operator|!
name|pbm
condition|)
name|pbm
operator|=
operator|&
name|Mybm
expr_stmt|;
if|if
condition|(
name|pbm
operator|->
name|filemon_fd
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|close
argument_list|(
name|pbm
operator|->
name|filemon_fd
argument_list|)
operator|<
literal|0
condition|)
name|error
operator|=
name|errno
expr_stmt|;
name|x
operator|=
name|filemon_read
argument_list|(
name|pbm
operator|->
name|mfp
argument_list|,
name|pbm
operator|->
name|mon_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|x
operator|!=
literal|0
condition|)
name|error
operator|=
name|x
expr_stmt|;
name|pbm
operator|->
name|filemon_fd
operator|=
name|pbm
operator|->
name|mon_fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|meta_job_finish
parameter_list|(
name|Job
modifier|*
name|job
parameter_list|)
block|{
name|BuildMon
modifier|*
name|pbm
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|x
decl_stmt|;
if|if
condition|(
name|job
operator|!=
name|NULL
condition|)
block|{
name|pbm
operator|=
operator|&
name|job
operator|->
name|bm
expr_stmt|;
block|}
else|else
block|{
name|pbm
operator|=
operator|&
name|Mybm
expr_stmt|;
block|}
if|if
condition|(
name|pbm
operator|->
name|mfp
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|meta_cmd_finish
argument_list|(
name|pbm
argument_list|)
expr_stmt|;
name|x
operator|=
name|fclose
argument_list|(
name|pbm
operator|->
name|mfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|x
operator|!=
literal|0
condition|)
name|error
operator|=
name|errno
expr_stmt|;
name|pbm
operator|->
name|mfp
operator|=
name|NULL
expr_stmt|;
name|pbm
operator|->
name|meta_fname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
name|void
name|meta_finish
parameter_list|(
name|void
parameter_list|)
block|{
name|Lst_Destroy
argument_list|(
name|metaBailiwick
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|metaBailiwickStr
argument_list|)
expr_stmt|;
name|Lst_Destroy
argument_list|(
name|metaIgnorePaths
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|metaIgnorePathsStr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Fetch a full line from fp - growing bufp if needed  * Return length in bufp.  */
end_comment

begin_function
specifier|static
name|int
name|fgetLine
parameter_list|(
name|char
modifier|*
modifier|*
name|bufp
parameter_list|,
name|size_t
modifier|*
name|szp
parameter_list|,
name|int
name|o
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|char
modifier|*
name|buf
init|=
operator|*
name|bufp
decl_stmt|;
name|size_t
name|bufsz
init|=
operator|*
name|szp
decl_stmt|;
name|struct
name|stat
name|fs
decl_stmt|;
name|int
name|x
decl_stmt|;
if|if
condition|(
name|fgets
argument_list|(
operator|&
name|buf
index|[
name|o
index|]
argument_list|,
name|bufsz
operator|-
name|o
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|check_newline
label|:
name|x
operator|=
name|o
operator|+
name|strlen
argument_list|(
operator|&
name|buf
index|[
name|o
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
name|x
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
return|return
name|x
return|;
comment|/* 	 * We need to grow the buffer. 	 * The meta file can give us a clue. 	 */
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|fs
argument_list|)
operator|==
literal|0
condition|)
block|{
name|size_t
name|newsz
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|newsz
operator|=
name|ROUNDUP
argument_list|(
operator|(
name|fs
operator|.
name|st_size
operator|/
literal|2
operator|)
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsz
operator|<=
name|bufsz
condition|)
name|newsz
operator|=
name|ROUNDUP
argument_list|(
name|fs
operator|.
name|st_size
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|META
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"growing buffer %u -> %u\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|bufsz
argument_list|,
operator|(
name|unsigned
operator|)
name|newsz
argument_list|)
expr_stmt|;
name|p
operator|=
name|bmake_realloc
argument_list|(
name|buf
argument_list|,
name|newsz
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
operator|*
name|bufp
operator|=
name|buf
operator|=
name|p
expr_stmt|;
operator|*
name|szp
operator|=
name|bufsz
operator|=
name|newsz
expr_stmt|;
comment|/* fetch the rest */
if|if
condition|(
operator|!
name|fgets
argument_list|(
operator|&
name|buf
index|[
name|x
index|]
argument_list|,
name|bufsz
operator|-
name|x
argument_list|,
name|fp
argument_list|)
condition|)
return|return
name|x
return|;
comment|/* truncated! */
goto|goto
name|check_newline
goto|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Lst_ForEach wants 1 to stop search */
end_comment

begin_function
specifier|static
name|int
name|prefix_match
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|q
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|prefix
init|=
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
name|q
decl_stmt|;
name|size_t
name|n
init|=
name|strlen
argument_list|(
name|prefix
argument_list|)
decl_stmt|;
return|return
operator|(
literal|0
operator|==
name|strncmp
argument_list|(
name|path
argument_list|,
name|prefix
argument_list|,
name|n
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * looking for exact or prefix/ match to  * Lst_Find wants 0 to stop search  */
end_comment

begin_function
specifier|static
name|int
name|path_match
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|,
specifier|const
name|void
modifier|*
name|q
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|prefix
init|=
name|q
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
name|p
decl_stmt|;
name|size_t
name|n
init|=
name|strlen
argument_list|(
name|prefix
argument_list|)
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|strncmp
argument_list|(
name|path
argument_list|,
name|prefix
argument_list|,
name|n
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|path
index|[
name|n
index|]
condition|)
block|{
case|case
literal|'\0'
case|:
case|case
literal|'/'
case|:
break|break;
default|default:
name|rc
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/* Lst_Find wants 0 to stop search */
end_comment

begin_function
specifier|static
name|int
name|string_match
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|,
specifier|const
name|void
modifier|*
name|q
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p1
init|=
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|p2
init|=
name|q
decl_stmt|;
return|return
name|strcmp
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|meta_ignore
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
name|char
name|fname
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
block|{
name|cached_realpath
argument_list|(
name|p
argument_list|,
name|fname
argument_list|)
expr_stmt|;
comment|/* clean it up */
if|if
condition|(
name|Lst_ForEach
argument_list|(
name|metaIgnorePaths
argument_list|,
name|prefix_match
argument_list|,
name|fname
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_META_MODE
if|if
condition|(
name|DEBUG
argument_list|(
name|META
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"meta_oodate: ignoring path: %s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|TRUE
return|;
block|}
block|}
if|if
condition|(
name|metaIgnorePatterns
condition|)
block|{
name|char
modifier|*
name|pm
decl_stmt|;
name|snprintf
argument_list|(
name|fname
argument_list|,
sizeof|sizeof
argument_list|(
name|fname
argument_list|)
argument_list|,
literal|"${%s:@m@${%s:L:M$m}@}"
argument_list|,
name|MAKE_META_IGNORE_PATTERNS
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|pm
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|fname
argument_list|,
name|gn
argument_list|,
name|VARF_WANTRES
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pm
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_META_MODE
if|if
condition|(
name|DEBUG
argument_list|(
name|META
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"meta_oodate: ignoring pattern: %s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|pm
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|free
argument_list|(
name|pm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|metaIgnoreFilter
condition|)
block|{
name|char
modifier|*
name|fm
decl_stmt|;
comment|/* skip if filter result is empty */
name|snprintf
argument_list|(
name|fname
argument_list|,
sizeof|sizeof
argument_list|(
name|fname
argument_list|)
argument_list|,
literal|"${%s:L:${%s:ts:}}"
argument_list|,
name|p
argument_list|,
name|MAKE_META_IGNORE_FILTER
argument_list|)
expr_stmt|;
name|fm
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|fname
argument_list|,
name|gn
argument_list|,
name|VARF_WANTRES
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|fm
operator|==
literal|'\0'
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_META_MODE
if|if
condition|(
name|DEBUG
argument_list|(
name|META
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"meta_oodate: ignoring filtered: %s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|fm
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|free
argument_list|(
name|fm
argument_list|)
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/*  * When running with 'meta' functionality, a target can be out-of-date  * if any of the references in its meta data file is more recent.  * We have to track the latestdir on a per-process basis.  */
end_comment

begin_define
define|#
directive|define
name|LCWD_VNAME_FMT
value|".meta.%d.lcwd"
end_define

begin_define
define|#
directive|define
name|LDIR_VNAME_FMT
value|".meta.%d.ldir"
end_define

begin_comment
comment|/*  * It is possible that a .meta file is corrupted,  * if we detect this we want to reproduce it.  * Setting oodate TRUE will have that effect.  */
end_comment

begin_define
define|#
directive|define
name|CHECK_VALID_META
parameter_list|(
name|p
parameter_list|)
value|if (!(p&& *p)) { \     warnx("%s: %d: malformed", fname, lineno); \     oodate = TRUE; \     continue; \     }
end_define

begin_define
define|#
directive|define
name|DEQUOTE
parameter_list|(
name|p
parameter_list|)
value|if (*p == '\'') {	\     char *ep; \     p++; \     if ((ep = strchr(p, '\''))) \ 	*ep = '\0'; \     }
end_define

begin_function
name|Boolean
name|meta_oodate
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|,
name|Boolean
name|oodate
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|tmpdir
init|=
name|NULL
decl_stmt|;
specifier|static
name|char
name|cwd
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|lcwd_vname
index|[
literal|64
index|]
decl_stmt|;
name|char
name|ldir_vname
index|[
literal|64
index|]
decl_stmt|;
name|char
name|lcwd
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|latestdir
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|fname
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|fname1
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|fname2
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|fname3
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|dname
decl_stmt|;
specifier|const
name|char
modifier|*
name|tname
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|link_src
decl_stmt|;
name|char
modifier|*
name|move_target
decl_stmt|;
specifier|static
name|size_t
name|cwdlen
init|=
literal|0
decl_stmt|;
specifier|static
name|size_t
name|tmplen
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|Boolean
name|needOODATE
init|=
name|FALSE
decl_stmt|;
name|Lst
name|missingFiles
decl_stmt|;
name|char
modifier|*
name|pa
index|[
literal|4
index|]
decl_stmt|;
comment|/*>= possible uses */
name|int
name|i
decl_stmt|;
name|int
name|have_filemon
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|oodate
condition|)
return|return
name|oodate
return|;
comment|/* we're done */
name|i
operator|=
literal|0
expr_stmt|;
name|dname
operator|=
name|Var_Value
argument_list|(
literal|".OBJDIR"
argument_list|,
name|gn
argument_list|,
operator|&
name|pa
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
name|tname
operator|=
name|Var_Value
argument_list|(
name|TARGET
argument_list|,
name|gn
argument_list|,
operator|&
name|pa
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
comment|/* if this succeeds fname3 is realpath of dname */
if|if
condition|(
operator|!
name|meta_needed
argument_list|(
name|gn
argument_list|,
name|dname
argument_list|,
name|fname3
argument_list|,
name|FALSE
argument_list|)
condition|)
goto|goto
name|oodate_out
goto|;
name|dname
operator|=
name|fname3
expr_stmt|;
name|missingFiles
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
comment|/*      * We need to check if the target is out-of-date. This includes      * checking if the expanded command has changed. This in turn      * requires that all variables are set in the same way that they      * would be if the target needs to be re-built.      */
name|Make_DoAllVar
argument_list|(
name|gn
argument_list|)
expr_stmt|;
name|meta_name
argument_list|(
name|fname
argument_list|,
sizeof|sizeof
argument_list|(
name|fname
argument_list|)
argument_list|,
name|dname
argument_list|,
name|tname
argument_list|,
name|dname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_META_MODE
if|if
condition|(
name|DEBUG
argument_list|(
name|META
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"meta_oodate: %s\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
specifier|static
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
specifier|static
name|size_t
name|bufsz
decl_stmt|;
name|int
name|lineno
init|=
literal|0
decl_stmt|;
name|int
name|lastpid
init|=
literal|0
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|int
name|x
decl_stmt|;
name|LstNode
name|ln
decl_stmt|;
name|struct
name|stat
name|fs
decl_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
block|{
name|bufsz
operator|=
literal|8
operator|*
name|BUFSIZ
expr_stmt|;
name|buf
operator|=
name|bmake_malloc
argument_list|(
name|bufsz
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cwdlen
condition|)
block|{
if|if
condition|(
name|getcwd
argument_list|(
name|cwd
argument_list|,
sizeof|sizeof
argument_list|(
name|cwd
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Could not get current working directory"
argument_list|)
expr_stmt|;
name|cwdlen
operator|=
name|strlen
argument_list|(
name|cwd
argument_list|)
expr_stmt|;
block|}
name|strlcpy
argument_list|(
name|lcwd
argument_list|,
name|cwd
argument_list|,
sizeof|sizeof
argument_list|(
name|lcwd
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|latestdir
argument_list|,
name|cwd
argument_list|,
sizeof|sizeof
argument_list|(
name|latestdir
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmpdir
condition|)
block|{
name|tmpdir
operator|=
name|getTmpdir
argument_list|()
expr_stmt|;
name|tmplen
operator|=
name|strlen
argument_list|(
name|tmpdir
argument_list|)
expr_stmt|;
block|}
comment|/* we want to track all the .meta we read */
name|Var_Append
argument_list|(
literal|".MAKE.META.FILES"
argument_list|,
name|fname
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
name|ln
operator|=
name|Lst_First
argument_list|(
name|gn
operator|->
name|commands
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|oodate
operator|&&
operator|(
name|x
operator|=
name|fgetLine
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|bufsz
argument_list|,
literal|0
argument_list|,
name|fp
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|lineno
operator|++
expr_stmt|;
if|if
condition|(
name|buf
index|[
name|x
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|buf
index|[
name|x
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
block|{
name|warnx
argument_list|(
literal|"%s: %d: line truncated at %u"
argument_list|,
name|fname
argument_list|,
name|lineno
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|oodate
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|link_src
operator|=
name|NULL
expr_stmt|;
name|move_target
operator|=
name|NULL
expr_stmt|;
comment|/* Find the start of the build monitor section. */
if|if
condition|(
operator|!
name|have_filemon
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"-- filemon"
argument_list|,
literal|10
argument_list|)
operator|==
literal|0
condition|)
block|{
name|have_filemon
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"# buildmon"
argument_list|,
literal|10
argument_list|)
operator|==
literal|0
condition|)
block|{
name|have_filemon
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* Delimit the record type. */
name|p
operator|=
name|buf
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_META_MODE
if|if
condition|(
name|DEBUG
argument_list|(
name|META
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"%s: %d: %s\n"
argument_list|,
name|fname
argument_list|,
name|lineno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|strsep
argument_list|(
operator|&
name|p
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_filemon
condition|)
block|{
comment|/* 		 * We are in the 'filemon' output section. 		 * Each record from filemon follows the general form: 		 * 		 *<key><pid><data> 		 * 		 * Where: 		 *<key> is a single letter, denoting the syscall. 		 *<pid> is the process that made the syscall. 		 *<data> is the arguments (of interest). 		 */
switch|switch
condition|(
name|buf
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'#'
case|:
comment|/* comment */
case|case
literal|'V'
case|:
comment|/* version */
break|break;
default|default:
comment|/* 		     * We need to track pathnames per-process. 		     * 		     * Each process run by make, starts off in the 'CWD' 		     * recorded in the .meta file, if it chdirs ('C') 		     * elsewhere we need to track that - but only for 		     * that process.  If it forks ('F'), we initialize 		     * the child to have the same cwd as its parent. 		     * 		     * We also need to track the 'latestdir' of 		     * interest.  This is usually the same as cwd, but 		     * not if a process is reading directories. 		     * 		     * Each time we spot a different process ('pid') 		     * we save the current value of 'latestdir' in a 		     * variable qualified by 'lastpid', and 		     * re-initialize 'latestdir' to any pre-saved 		     * value for the current 'pid' and 'CWD' if none. 		     */
name|CHECK_VALID_META
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|pid
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|>
literal|0
operator|&&
name|pid
operator|!=
name|lastpid
condition|)
block|{
name|char
modifier|*
name|ldir
decl_stmt|;
name|char
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
name|lastpid
operator|>
literal|0
condition|)
block|{
comment|/* We need to remember these. */
name|Var_Set
argument_list|(
name|lcwd_vname
argument_list|,
name|lcwd
argument_list|,
name|VAR_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Var_Set
argument_list|(
name|ldir_vname
argument_list|,
name|latestdir
argument_list|,
name|VAR_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|lcwd_vname
argument_list|,
sizeof|sizeof
argument_list|(
name|lcwd_vname
argument_list|)
argument_list|,
name|LCWD_VNAME_FMT
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|ldir_vname
argument_list|,
sizeof|sizeof
argument_list|(
name|ldir_vname
argument_list|)
argument_list|,
name|LDIR_VNAME_FMT
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|lastpid
operator|=
name|pid
expr_stmt|;
name|ldir
operator|=
name|Var_Value
argument_list|(
name|ldir_vname
argument_list|,
name|VAR_GLOBAL
argument_list|,
operator|&
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldir
condition|)
block|{
name|strlcpy
argument_list|(
name|latestdir
argument_list|,
name|ldir
argument_list|,
sizeof|sizeof
argument_list|(
name|latestdir
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
name|ldir
operator|=
name|Var_Value
argument_list|(
name|lcwd_vname
argument_list|,
name|VAR_GLOBAL
argument_list|,
operator|&
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldir
condition|)
block|{
name|strlcpy
argument_list|(
name|lcwd
argument_list|,
name|ldir
argument_list|,
sizeof|sizeof
argument_list|(
name|lcwd
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Skip past the pid. */
if|if
condition|(
name|strsep
argument_list|(
operator|&
name|p
argument_list|,
literal|" "
argument_list|)
operator|==
name|NULL
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|DEBUG_META_MODE
if|if
condition|(
name|DEBUG
argument_list|(
name|META
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"%s: %d: %d: %c: cwd=%s lcwd=%s ldir=%s\n"
argument_list|,
name|fname
argument_list|,
name|lineno
argument_list|,
name|pid
argument_list|,
name|buf
index|[
literal|0
index|]
argument_list|,
name|cwd
argument_list|,
name|lcwd
argument_list|,
name|latestdir
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
name|CHECK_VALID_META
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Process according to record type. */
switch|switch
condition|(
name|buf
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'X'
case|:
comment|/* eXit */
name|Var_Delete
argument_list|(
name|lcwd_vname
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
name|Var_Delete
argument_list|(
name|ldir_vname
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
name|lastpid
operator|=
literal|0
expr_stmt|;
comment|/* no need to save ldir_vname */
break|break;
case|case
literal|'F'
case|:
comment|/* [v]Fork */
block|{
name|char
name|cldir
index|[
literal|64
index|]
decl_stmt|;
name|int
name|child
decl_stmt|;
name|child
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|>
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|cldir
argument_list|,
sizeof|sizeof
argument_list|(
name|cldir
argument_list|)
argument_list|,
name|LCWD_VNAME_FMT
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|Var_Set
argument_list|(
name|cldir
argument_list|,
name|lcwd
argument_list|,
name|VAR_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|cldir
argument_list|,
sizeof|sizeof
argument_list|(
name|cldir
argument_list|)
argument_list|,
name|LDIR_VNAME_FMT
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|Var_Set
argument_list|(
name|cldir
argument_list|,
name|latestdir
argument_list|,
name|VAR_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_META_MODE
if|if
condition|(
name|DEBUG
argument_list|(
name|META
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"%s: %d: %d: cwd=%s lcwd=%s ldir=%s\n"
argument_list|,
name|fname
argument_list|,
name|lineno
argument_list|,
name|child
argument_list|,
name|cwd
argument_list|,
name|lcwd
argument_list|,
name|latestdir
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
break|break;
case|case
literal|'C'
case|:
comment|/* Chdir */
comment|/* Update lcwd and latest directory. */
name|strlcpy
argument_list|(
name|latestdir
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|latestdir
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|lcwd
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|lcwd
argument_list|)
argument_list|)
expr_stmt|;
name|Var_Set
argument_list|(
name|lcwd_vname
argument_list|,
name|lcwd
argument_list|,
name|VAR_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Var_Set
argument_list|(
name|ldir_vname
argument_list|,
name|lcwd
argument_list|,
name|VAR_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_META_MODE
if|if
condition|(
name|DEBUG
argument_list|(
name|META
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"%s: %d: cwd=%s ldir=%s\n"
argument_list|,
name|fname
argument_list|,
name|lineno
argument_list|,
name|cwd
argument_list|,
name|lcwd
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'M'
case|:
comment|/* renaMe */
comment|/* 		     * For 'M'oves we want to check 		     * the src as for 'R'ead 		     * and the target as for 'W'rite. 		     */
name|cp
operator|=
name|p
expr_stmt|;
comment|/* save this for a second */
comment|/* now get target */
if|if
condition|(
name|strsep
argument_list|(
operator|&
name|p
argument_list|,
literal|" "
argument_list|)
operator|==
name|NULL
condition|)
continue|continue;
name|CHECK_VALID_META
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|move_target
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|cp
expr_stmt|;
comment|/* 'L' and 'M' put single quotes around the args */
name|DEQUOTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|DEQUOTE
argument_list|(
name|move_target
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|'D'
case|:
comment|/* unlink */
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
operator|&&
operator|!
name|Lst_IsEmpty
argument_list|(
name|missingFiles
argument_list|)
condition|)
block|{
comment|/* remove any missingFiles entries that match p */
if|if
condition|(
operator|(
name|ln
operator|=
name|Lst_Find
argument_list|(
name|missingFiles
argument_list|,
name|p
argument_list|,
name|path_match
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|LstNode
name|nln
decl_stmt|;
name|char
modifier|*
name|tp
decl_stmt|;
do|do
block|{
name|nln
operator|=
name|Lst_FindFrom
argument_list|(
name|missingFiles
argument_list|,
name|Lst_Succ
argument_list|(
name|ln
argument_list|)
argument_list|,
name|p
argument_list|,
name|path_match
argument_list|)
expr_stmt|;
name|tp
operator|=
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|Lst_Remove
argument_list|(
name|missingFiles
argument_list|,
name|ln
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|ln
operator|=
name|nln
operator|)
operator|!=
name|NULL
condition|)
do|;
block|}
block|}
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'M'
condition|)
block|{
comment|/* the target of the mv is a file 'W'ritten */
ifdef|#
directive|ifdef
name|DEBUG_META_MODE
if|if
condition|(
name|DEBUG
argument_list|(
name|META
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"meta_oodate: M %s -> %s\n"
argument_list|,
name|p
argument_list|,
name|move_target
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
name|move_target
expr_stmt|;
goto|goto
name|check_write
goto|;
block|}
break|break;
case|case
literal|'L'
case|:
comment|/* Link */
comment|/* 		     * For 'L'inks check 		     * the src as for 'R'ead 		     * and the target as for 'W'rite. 		     */
name|link_src
operator|=
name|p
expr_stmt|;
comment|/* now get target */
if|if
condition|(
name|strsep
argument_list|(
operator|&
name|p
argument_list|,
literal|" "
argument_list|)
operator|==
name|NULL
condition|)
continue|continue;
name|CHECK_VALID_META
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 'L' and 'M' put single quotes around the args */
name|DEQUOTE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|DEQUOTE
argument_list|(
name|link_src
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_META_MODE
if|if
condition|(
name|DEBUG
argument_list|(
name|META
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"meta_oodate: L %s -> %s\n"
argument_list|,
name|link_src
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FALLTHROUGH */
case|case
literal|'W'
case|:
comment|/* Write */
name|check_write
label|:
comment|/* 		     * If a file we generated within our bailiwick 		     * but outside of .OBJDIR is missing, 		     * we need to do it again.  		     */
comment|/* ignore non-absolute paths */
if|if
condition|(
operator|*
name|p
operator|!=
literal|'/'
condition|)
break|break;
if|if
condition|(
name|Lst_IsEmpty
argument_list|(
name|metaBailiwick
argument_list|)
condition|)
break|break;
comment|/* ignore cwd - normal dependencies handle those */
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
name|cwd
argument_list|,
name|cwdlen
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|Lst_ForEach
argument_list|(
name|metaBailiwick
argument_list|,
name|prefix_match
argument_list|,
name|p
argument_list|)
condition|)
break|break;
comment|/* tmpdir might be within */
if|if
condition|(
name|tmplen
operator|>
literal|0
operator|&&
name|strncmp
argument_list|(
name|p
argument_list|,
name|tmpdir
argument_list|,
name|tmplen
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* ignore anything containing the string "tmp" */
if|if
condition|(
operator|(
name|strstr
argument_list|(
literal|"tmp"
argument_list|,
name|p
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|link_src
operator|!=
name|NULL
operator|&&
name|cached_lstat
argument_list|(
name|p
argument_list|,
operator|&
name|fs
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|link_src
operator|==
name|NULL
operator|&&
name|cached_stat
argument_list|(
name|p
argument_list|,
operator|&
name|fs
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|meta_ignore
argument_list|(
name|gn
argument_list|,
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|Lst_Find
argument_list|(
name|missingFiles
argument_list|,
name|p
argument_list|,
name|string_match
argument_list|)
operator|==
name|NULL
condition|)
name|Lst_AtEnd
argument_list|(
name|missingFiles
argument_list|,
name|bmake_strdup
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
name|check_link_src
label|:
name|p
operator|=
name|link_src
expr_stmt|;
name|link_src
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_META_MODE
if|if
condition|(
name|DEBUG
argument_list|(
name|META
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"meta_oodate: L src %s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FALLTHROUGH */
case|case
literal|'R'
case|:
comment|/* Read */
case|case
literal|'E'
case|:
comment|/* Exec */
comment|/* 		     * Check for runtime files that can't 		     * be part of the dependencies because 		     * they are _expected_ to change. 		     */
if|if
condition|(
name|meta_ignore
argument_list|(
name|gn
argument_list|,
name|p
argument_list|)
condition|)
break|break;
comment|/* 		     * The rest of the record is the file name. 		     * Check if it's not an absolute path. 		     */
block|{
name|char
modifier|*
name|sdirs
index|[
literal|4
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|sdp
decl_stmt|;
name|int
name|sdx
init|=
literal|0
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
block|{
name|sdirs
index|[
name|sdx
operator|++
index|]
operator|=
name|p
expr_stmt|;
comment|/* done */
block|}
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
literal|"."
argument_list|,
name|p
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* no point */
comment|/* Check vs latestdir */
name|snprintf
argument_list|(
name|fname1
argument_list|,
sizeof|sizeof
argument_list|(
name|fname1
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|latestdir
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|sdirs
index|[
name|sdx
operator|++
index|]
operator|=
name|fname1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|latestdir
argument_list|,
name|lcwd
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Check vs lcwd */
name|snprintf
argument_list|(
name|fname2
argument_list|,
sizeof|sizeof
argument_list|(
name|fname2
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|lcwd
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|sdirs
index|[
name|sdx
operator|++
index|]
operator|=
name|fname2
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|lcwd
argument_list|,
name|cwd
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Check vs cwd */
name|snprintf
argument_list|(
name|fname3
argument_list|,
sizeof|sizeof
argument_list|(
name|fname3
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|cwd
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|sdirs
index|[
name|sdx
operator|++
index|]
operator|=
name|fname3
expr_stmt|;
block|}
block|}
name|sdirs
index|[
name|sdx
operator|++
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|sdp
operator|=
name|sdirs
init|;
operator|*
name|sdp
operator|&&
operator|!
name|found
condition|;
name|sdp
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_META_MODE
if|if
condition|(
name|DEBUG
argument_list|(
name|META
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"%s: %d: looking for: %s\n"
argument_list|,
name|fname
argument_list|,
name|lineno
argument_list|,
operator|*
name|sdp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cached_stat
argument_list|(
operator|*
name|sdp
argument_list|,
operator|&
name|fs
argument_list|)
operator|==
literal|0
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
name|p
operator|=
operator|*
name|sdp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_META_MODE
if|if
condition|(
name|DEBUG
argument_list|(
name|META
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"%s: %d: found: %s\n"
argument_list|,
name|fname
argument_list|,
name|lineno
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|fs
operator|.
name|st_mode
argument_list|)
operator|&&
name|fs
operator|.
name|st_mtime
operator|>
name|gn
operator|->
name|mtime
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|META
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"%s: %d: file '%s' is newer than the target...\n"
argument_list|,
name|fname
argument_list|,
name|lineno
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|oodate
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_ISDIR
argument_list|(
name|fs
operator|.
name|st_mode
argument_list|)
condition|)
block|{
comment|/* Update the latest directory. */
name|cached_realpath
argument_list|(
name|p
argument_list|,
name|latestdir
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|errno
operator|==
name|ENOENT
operator|&&
operator|*
name|p
operator|==
literal|'/'
operator|&&
name|strncmp
argument_list|(
name|p
argument_list|,
name|cwd
argument_list|,
name|cwdlen
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			     * A referenced file outside of CWD is missing. 			     * We cannot catch every eventuality here... 			     */
if|if
condition|(
name|Lst_Find
argument_list|(
name|missingFiles
argument_list|,
name|p
argument_list|,
name|string_match
argument_list|)
operator|==
name|NULL
condition|)
name|Lst_AtEnd
argument_list|(
name|missingFiles
argument_list|,
name|bmake_strdup
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'E'
condition|)
block|{
comment|/* previous latestdir is no longer relevant */
name|strlcpy
argument_list|(
name|latestdir
argument_list|,
name|lcwd
argument_list|,
sizeof|sizeof
argument_list|(
name|latestdir
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
operator|!
name|oodate
operator|&&
name|buf
index|[
literal|0
index|]
operator|==
literal|'L'
operator|&&
name|link_src
operator|!=
name|NULL
condition|)
goto|goto
name|check_link_src
goto|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"CMD"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Compare the current command with the one in the 		 * meta data file. 		 */
if|if
condition|(
name|ln
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|META
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"%s: %d: there were more build commands in the meta data file than there are now...\n"
argument_list|,
name|fname
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|oodate
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|cmd
init|=
operator|(
name|char
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
decl_stmt|;
name|Boolean
name|hasOODATE
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|strstr
argument_list|(
name|cmd
argument_list|,
literal|"$?"
argument_list|)
condition|)
name|hasOODATE
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|cp
operator|=
name|strstr
argument_list|(
name|cmd
argument_list|,
literal|".OODATE"
argument_list|)
operator|)
condition|)
block|{
comment|/* check for $[{(].OODATE[:)}] */
if|if
condition|(
name|cp
operator|>
name|cmd
operator|+
literal|2
operator|&&
name|cp
index|[
operator|-
literal|2
index|]
operator|==
literal|'$'
condition|)
name|hasOODATE
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|hasOODATE
condition|)
block|{
name|needOODATE
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|META
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"%s: %d: cannot compare command using .OODATE\n"
argument_list|,
name|fname
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
name|cmd
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|cmd
argument_list|,
name|gn
argument_list|,
name|VARF_WANTRES
operator||
name|VARF_UNDEFERR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|cmd
argument_list|,
literal|'\n'
argument_list|)
operator|)
condition|)
block|{
name|int
name|n
decl_stmt|;
comment|/* 			 * This command contains newlines, we need to 			 * fetch more from the .meta file before we 			 * attempt a comparison. 			 */
comment|/* first put the newline back at buf[x - 1] */
name|buf
index|[
name|x
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
do|do
block|{
comment|/* now fetch the next line */
if|if
condition|(
operator|(
name|n
operator|=
name|fgetLine
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|bufsz
argument_list|,
name|x
argument_list|,
name|fp
argument_list|)
operator|)
operator|<=
literal|0
condition|)
break|break;
name|x
operator|=
name|n
expr_stmt|;
name|lineno
operator|++
expr_stmt|;
if|if
condition|(
name|buf
index|[
name|x
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: %d: line truncated at %u"
argument_list|,
name|fname
argument_list|,
name|lineno
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
block|}
name|cp
operator|=
name|strchr
argument_list|(
operator|++
name|cp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|cp
condition|)
do|;
if|if
condition|(
name|buf
index|[
name|x
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|buf
index|[
name|x
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hasOODATE
operator|&&
operator|!
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_NOMETA_CMP
operator|)
operator|&&
name|strcmp
argument_list|(
name|p
argument_list|,
name|cmd
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|META
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"%s: %d: a build command has changed\n%s\nvs\n%s\n"
argument_list|,
name|fname
argument_list|,
name|lineno
argument_list|,
name|p
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|metaIgnoreCMDs
condition|)
name|oodate
operator|=
name|TRUE
expr_stmt|;
block|}
name|free
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|ln
operator|=
name|Lst_Succ
argument_list|(
name|ln
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"CWD"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Check if there are extra commands now 		 * that weren't in the meta data file. 		 */
if|if
condition|(
operator|!
name|oodate
operator|&&
name|ln
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|META
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"%s: %d: there are extra build commands now that weren't in the meta data file\n"
argument_list|,
name|fname
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|oodate
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
name|cwd
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|META
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"%s: %d: the current working directory has changed from '%s' to '%s'\n"
argument_list|,
name|fname
argument_list|,
name|lineno
argument_list|,
name|p
argument_list|,
name|curdir
argument_list|)
expr_stmt|;
name|oodate
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|missingFiles
argument_list|)
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|META
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"%s: missing files: %s...\n"
argument_list|,
name|fname
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|Lst_First
argument_list|(
name|missingFiles
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|oodate
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|oodate
operator|&&
operator|!
name|have_filemon
operator|&&
name|filemonMissing
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|META
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"%s: missing filemon data\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|oodate
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|writeMeta
operator|&&
name|metaMissing
condition|)
block|{
name|cp
operator|=
name|NULL
expr_stmt|;
comment|/* if target is in .CURDIR we do not need a meta file */
if|if
condition|(
name|gn
operator|->
name|path
operator|&&
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|gn
operator|->
name|path
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|&&
name|cp
operator|>
name|gn
operator|->
name|path
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|curdir
argument_list|,
name|gn
operator|->
name|path
argument_list|,
operator|(
name|cp
operator|-
name|gn
operator|->
name|path
operator|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|cp
operator|=
name|NULL
expr_stmt|;
comment|/* not in .CURDIR */
block|}
block|}
if|if
condition|(
operator|!
name|cp
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|META
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"%s: required but missing\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|oodate
operator|=
name|TRUE
expr_stmt|;
name|needOODATE
operator|=
name|TRUE
expr_stmt|;
comment|/* assume the worst */
block|}
block|}
block|}
name|Lst_Destroy
argument_list|(
name|missingFiles
argument_list|,
operator|(
name|FreeProc
operator|*
operator|)
name|free
argument_list|)
expr_stmt|;
if|if
condition|(
name|oodate
operator|&&
name|needOODATE
condition|)
block|{
comment|/* 	 * Target uses .OODATE which is empty; or we wouldn't be here. 	 * We have decided it is oodate, so .OODATE needs to be set. 	 * All we can sanely do is set it to .ALLSRC. 	 */
name|Var_Delete
argument_list|(
name|OODATE
argument_list|,
name|gn
argument_list|)
expr_stmt|;
name|Var_Set
argument_list|(
name|OODATE
argument_list|,
name|Var_Value
argument_list|(
name|ALLSRC
argument_list|,
name|gn
argument_list|,
operator|&
name|cp
argument_list|)
argument_list|,
name|gn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
name|oodate_out
label|:
for|for
control|(
name|i
operator|--
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|free
argument_list|(
name|pa
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|oodate
return|;
block|}
end_function

begin_comment
comment|/* support for compat mode */
end_comment

begin_decl_stmt
specifier|static
name|int
name|childPipe
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|meta_compat_start
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_FILEMON_ONCE
comment|/*      * We need to re-open filemon for each cmd.      */
name|BuildMon
modifier|*
name|pbm
init|=
operator|&
name|Mybm
decl_stmt|;
if|if
condition|(
name|pbm
operator|->
name|mfp
operator|!=
name|NULL
operator|&&
name|useFilemon
condition|)
block|{
name|filemon_open
argument_list|(
name|pbm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pbm
operator|->
name|mon_fd
operator|=
name|pbm
operator|->
name|filemon_fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|pipe
argument_list|(
name|childPipe
argument_list|)
operator|<
literal|0
condition|)
name|Punt
argument_list|(
literal|"Cannot create pipe: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set close-on-exec flag for both */
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|childPipe
index|[
literal|0
index|]
argument_list|,
name|F_SETFD
argument_list|,
name|FD_CLOEXEC
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|childPipe
index|[
literal|1
index|]
argument_list|,
name|F_SETFD
argument_list|,
name|FD_CLOEXEC
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|meta_compat_child
parameter_list|(
name|void
parameter_list|)
block|{
name|meta_job_child
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup2
argument_list|(
name|childPipe
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
operator|||
name|dup2
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
operator|<
literal|0
condition|)
block|{
name|execError
argument_list|(
literal|"dup2"
argument_list|,
literal|"pipe"
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|meta_compat_parent
parameter_list|(
name|void
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|close
argument_list|(
name|childPipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* child side */
name|fp
operator|=
name|fdopen
argument_list|(
name|childPipe
index|[
literal|0
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
condition|)
block|{
name|meta_job_output
argument_list|(
name|NULL
argument_list|,
name|buf
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_META */
end_comment

end_unit

