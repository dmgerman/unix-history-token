begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: make.c,v 1.87 2012/06/12 19:21:51 joerg Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 1988, 1989, 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Adam de Boor.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1989 by Berkeley Softworks  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Adam de Boor.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAKE_NATIVE
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$NetBSD: make.c,v 1.87 2012/06/12 19:21:51 joerg Exp $"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_else
unit|static char sccsid[] = "@(#)make.c	8.1 (Berkeley) 6/6/93";
else|#
directive|else
end_else

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$NetBSD: make.c,v 1.87 2012/06/12 19:21:51 joerg Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*-  * make.c --  *	The functions which perform the examination of targets and  *	their suitability for creation  *  * Interface:  *	Make_Run 	    	Initialize things for the module and recreate  *	    	  	    	whatever needs recreating. Returns TRUE if  *	    	    	    	work was (or would have been) done and FALSE  *	    	  	    	otherwise.  *  *	Make_Update	    	Update all parents of a given child. Performs  *	    	  	    	various bookkeeping chores like the updating  *	    	  	    	of the cmgn field of the parent, filling  *	    	  	    	of the IMPSRC context variable, etc. It will  *	    	  	    	place the parent on the toBeMade queue if it  *	    	  	    	should be.  *  *	Make_TimeStamp	    	Function to set the parent's cmgn field  *	    	  	    	based on a child's modification time.  *  *	Make_DoAllVar	    	Set up the various local variables for a  *	    	  	    	target, including the .ALLSRC variable, making  *	    	  	    	sure that any variable that needs to exist  *	    	  	    	at the very least has the empty value.  *  *	Make_OODate 	    	Determine if a target is out-of-date.  *  *	Make_HandleUse	    	See if a child is a .USE node for a parent  *				and perform the .USE actions if so.  *  *	Make_ExpandUse	    	Expand .USE nodes  */
end_comment

begin_include
include|#
directive|include
file|"make.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"job.h"
end_include

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|checked
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sequence # to detect recursion */
end_comment

begin_decl_stmt
specifier|static
name|Lst
name|toBeMade
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current fringe of the graph. These 				 * are nodes which await examination by 				 * MakeOODate. It is added to by 				 * Make_Update and subtracted from by 				 * MakeStartJobs */
end_comment

begin_function_decl
specifier|static
name|int
name|MakeAddChild
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|MakeFindChild
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|MakeUnmark
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|MakeAddAllSrc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|MakeTimeStamp
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|MakeHandleUse
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Boolean
name|MakeStartJobs
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|MakePrintStatus
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|MakeCheckOrder
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|MakeBuildChild
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|MakeBuildParent
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|MAKE_ATTR_DEAD
specifier|static
name|void
name|make_abort
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|,
name|int
name|line
parameter_list|)
block|{
specifier|static
name|int
name|two
init|=
literal|2
decl_stmt|;
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"make_abort from line %d\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|Targ_PrintNode
argument_list|(
name|gn
argument_list|,
operator|&
name|two
argument_list|)
expr_stmt|;
name|Lst_ForEach
argument_list|(
name|toBeMade
argument_list|,
name|Targ_PrintNode
argument_list|,
operator|&
name|two
argument_list|)
expr_stmt|;
name|Targ_PrintGraph
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Make_TimeStamp --  *	Set the cmgn field of a parent node based on the mtime stamp in its  *	child. Called from MakeOODate via Lst_ForEach.  *  * Input:  *	pgn		the current parent  *	cgn		the child we've just examined  *  * Results:  *	Always returns 0.  *  * Side Effects:  *	The cmgn of the parent node will be changed if the mtime  *	field of the child is greater than it.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Make_TimeStamp
parameter_list|(
name|GNode
modifier|*
name|pgn
parameter_list|,
name|GNode
modifier|*
name|cgn
parameter_list|)
block|{
if|if
condition|(
name|pgn
operator|->
name|cmgn
operator|==
name|NULL
operator|||
name|cgn
operator|->
name|mtime
operator|>
name|pgn
operator|->
name|cmgn
operator|->
name|mtime
condition|)
block|{
name|pgn
operator|->
name|cmgn
operator|=
name|cgn
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Input:  *	pgn		the current parent  *	cgn		the child we've just examined  *  */
end_comment

begin_function
specifier|static
name|int
name|MakeTimeStamp
parameter_list|(
name|void
modifier|*
name|pgn
parameter_list|,
name|void
modifier|*
name|cgn
parameter_list|)
block|{
return|return
name|Make_TimeStamp
argument_list|(
operator|(
name|GNode
operator|*
operator|)
name|pgn
argument_list|,
operator|(
name|GNode
operator|*
operator|)
name|cgn
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Make_OODate --  *	See if a given node is out of date with respect to its sources.  *	Used by Make_Run when deciding which nodes to place on the  *	toBeMade queue initially and by Make_Update to screen out USE and  *	EXEC nodes. In the latter case, however, any other sort of node  *	must be considered out-of-date since at least one of its children  *	will have been recreated.  *  * Input:  *	gn		the node to check  *  * Results:  *	TRUE if the node is out of date. FALSE otherwise.  *  * Side Effects:  *	The mtime field of the node and the cmgn field of its parents  *	will/may be changed.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|Boolean
name|Make_OODate
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|)
block|{
name|Boolean
name|oodate
decl_stmt|;
comment|/*      * Certain types of targets needn't even be sought as their datedness      * doesn't depend on their modification time...      */
if|if
condition|(
operator|(
name|gn
operator|->
name|type
operator|&
operator|(
name|OP_JOIN
operator||
name|OP_USE
operator||
name|OP_USEBEFORE
operator||
name|OP_EXEC
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|Dir_MTime
argument_list|(
name|gn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
if|if
condition|(
name|gn
operator|->
name|mtime
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"modified %s..."
argument_list|,
name|Targ_FmtTime
argument_list|(
name|gn
operator|->
name|mtime
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"non-existent..."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*      * A target is remade in one of the following circumstances:      *	its modification time is smaller than that of its youngest child      *	    and it would actually be run (has commands or type OP_NOP)      *	it's the object of a force operator      *	it has no children, was on the lhs of an operator and doesn't exist      *	    already.      *      * Libraries are only considered out-of-date if the archive module says      * they are.      *      * These weird rules are brought to you by Backward-Compatibility and      * the strange people who wrote 'Make'.      */
if|if
condition|(
name|gn
operator|->
name|type
operator|&
operator|(
name|OP_USE
operator||
name|OP_USEBEFORE
operator|)
condition|)
block|{
comment|/* 	 * If the node is a USE node it is *never* out of date 	 * no matter *what*. 	 */
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|".USE node..."
argument_list|)
expr_stmt|;
block|}
name|oodate
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_LIB
operator|)
operator|&&
operator|(
operator|(
name|gn
operator|->
name|mtime
operator|==
literal|0
operator|)
operator|||
name|Arch_IsLib
argument_list|(
name|gn
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"library..."
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * always out of date if no children and :: target 	 * or non-existent. 	 */
name|oodate
operator|=
operator|(
name|gn
operator|->
name|mtime
operator|==
literal|0
operator|||
name|Arch_LibOODate
argument_list|(
name|gn
argument_list|)
operator|||
operator|(
name|gn
operator|->
name|cmgn
operator|==
name|NULL
operator|&&
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_DOUBLEDEP
operator|)
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_JOIN
condition|)
block|{
comment|/* 	 * A target with the .JOIN attribute is only considered 	 * out-of-date if any of its children was out-of-date. 	 */
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|".JOIN node..."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"source %smade..."
argument_list|,
name|gn
operator|->
name|flags
operator|&
name|CHILDMADE
condition|?
literal|""
else|:
literal|"not "
argument_list|)
expr_stmt|;
block|}
name|oodate
operator|=
operator|(
name|gn
operator|->
name|flags
operator|&
name|CHILDMADE
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gn
operator|->
name|type
operator|&
operator|(
name|OP_FORCE
operator||
name|OP_EXEC
operator||
name|OP_PHONY
operator|)
condition|)
block|{
comment|/* 	 * A node which is the object of the force (!) operator or which has 	 * the .EXEC attribute is always considered out-of-date. 	 */
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_FORCE
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"! operator..."
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_PHONY
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|".PHONY node..."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|".EXEC node..."
argument_list|)
expr_stmt|;
block|}
block|}
name|oodate
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|gn
operator|->
name|cmgn
operator|!=
name|NULL
operator|&&
name|gn
operator|->
name|mtime
operator|<
name|gn
operator|->
name|cmgn
operator|->
name|mtime
operator|)
operator|||
operator|(
name|gn
operator|->
name|cmgn
operator|==
name|NULL
operator|&&
operator|(
operator|(
name|gn
operator|->
name|mtime
operator|==
literal|0
operator|&&
operator|!
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_OPTIONAL
operator|)
operator|)
operator|||
name|gn
operator|->
name|type
operator|&
name|OP_DOUBLEDEP
operator|)
operator|)
condition|)
block|{
comment|/* 	 * A node whose modification time is less than that of its 	 * youngest child or that has no children (cmgn == NULL) and 	 * either doesn't exist (mtime == 0) and it isn't optional 	 * or was the object of a * :: operator is out-of-date. 	 * Why? Because that's the way Make does it. 	 */
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
if|if
condition|(
name|gn
operator|->
name|cmgn
operator|!=
name|NULL
operator|&&
name|gn
operator|->
name|mtime
operator|<
name|gn
operator|->
name|cmgn
operator|->
name|mtime
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"modified before source %s..."
argument_list|,
name|gn
operator|->
name|cmgn
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gn
operator|->
name|mtime
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"non-existent and no sources..."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|":: operator and no sources..."
argument_list|)
expr_stmt|;
block|}
block|}
name|oodate
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/*  	 * When a non-existing child with no sources 	 * (such as a typically used FORCE source) has been made and 	 * the target of the child (usually a directory) has the same 	 * timestamp as the timestamp just given to the non-existing child 	 * after it was considered made. 	 */
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
if|if
condition|(
name|gn
operator|->
name|flags
operator|&
name|FORCE
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"non existing child..."
argument_list|)
expr_stmt|;
block|}
name|oodate
operator|=
operator|(
name|gn
operator|->
name|flags
operator|&
name|FORCE
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USE_META
if|if
condition|(
name|useMeta
condition|)
block|{
name|oodate
operator|=
name|meta_oodate
argument_list|(
name|gn
argument_list|,
name|oodate
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*      * If the target isn't out-of-date, the parents need to know its      * modification time. Note that targets that appear to be out-of-date      * but aren't, because they have no commands and aren't of type OP_NOP,      * have their mtime stay below their children's mtime to keep parents from      * thinking they're out-of-date.      */
if|if
condition|(
operator|!
name|oodate
condition|)
block|{
name|Lst_ForEach
argument_list|(
name|gn
operator|->
name|parents
argument_list|,
name|MakeTimeStamp
argument_list|,
name|gn
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|oodate
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * MakeAddChild  --  *	Function used by Make_Run to add a child to the list l.  *	It will only add the child if its make field is FALSE.  *  * Input:  *	gnp		the node to add  *	lp		the list to which to add it  *  * Results:  *	Always returns 0  *  * Side Effects:  *	The given list is extended  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|MakeAddChild
parameter_list|(
name|void
modifier|*
name|gnp
parameter_list|,
name|void
modifier|*
name|lp
parameter_list|)
block|{
name|GNode
modifier|*
name|gn
init|=
operator|(
name|GNode
operator|*
operator|)
name|gnp
decl_stmt|;
name|Lst
name|l
init|=
operator|(
name|Lst
operator|)
name|lp
decl_stmt|;
if|if
condition|(
operator|(
name|gn
operator|->
name|flags
operator|&
name|REMAKE
operator|)
operator|==
literal|0
operator|&&
operator|!
operator|(
name|gn
operator|->
name|type
operator|&
operator|(
name|OP_USE
operator||
name|OP_USEBEFORE
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"MakeAddChild: need to examine %s%s\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|,
name|gn
operator|->
name|cohort_num
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_EnQueue
argument_list|(
name|l
argument_list|,
name|gn
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * MakeFindChild  --  *	Function used by Make_Run to find the pathname of a child  *	that was already made.  *  * Input:  *	gnp		the node to find  *  * Results:  *	Always returns 0  *  * Side Effects:  *	The path and mtime of the node and the cmgn of the parent are  *	updated; the unmade children count of the parent is decremented.  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|MakeFindChild
parameter_list|(
name|void
modifier|*
name|gnp
parameter_list|,
name|void
modifier|*
name|pgnp
parameter_list|)
block|{
name|GNode
modifier|*
name|gn
init|=
operator|(
name|GNode
operator|*
operator|)
name|gnp
decl_stmt|;
name|GNode
modifier|*
name|pgn
init|=
operator|(
name|GNode
operator|*
operator|)
name|pgnp
decl_stmt|;
operator|(
name|void
operator|)
name|Dir_MTime
argument_list|(
name|gn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Make_TimeStamp
argument_list|(
name|pgn
argument_list|,
name|gn
argument_list|)
expr_stmt|;
name|pgn
operator|->
name|unmade
operator|--
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Make_HandleUse --  *	Function called by Make_Run and SuffApplyTransform on the downward  *	pass to handle .USE and transformation nodes. It implements the  *	.USE and transformation functionality by copying the node's commands,  *	type flags and children to the parent node.  *  *	A .USE node is much like an explicit transformation rule, except  *	its commands are always added to the target node, even if the  *	target already has commands.  *  * Input:  *	cgn		The .USE node  *	pgn		The target of the .USE node  *  * Results:  *	none  *  * Side Effects:  *	Children and commands may be added to the parent and the parent's  *	type may be changed.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Make_HandleUse
parameter_list|(
name|GNode
modifier|*
name|cgn
parameter_list|,
name|GNode
modifier|*
name|pgn
parameter_list|)
block|{
name|LstNode
name|ln
decl_stmt|;
comment|/* An element in the children list */
ifdef|#
directive|ifdef
name|DEBUG_SRC
if|if
condition|(
operator|(
name|cgn
operator|->
name|type
operator|&
operator|(
name|OP_USE
operator||
name|OP_USEBEFORE
operator||
name|OP_TRANSFORM
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"Make_HandleUse: called for plain node %s\n"
argument_list|,
name|cgn
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|cgn
operator|->
name|type
operator|&
operator|(
name|OP_USE
operator||
name|OP_USEBEFORE
operator|)
operator|)
operator|||
name|Lst_IsEmpty
argument_list|(
name|pgn
operator|->
name|commands
argument_list|)
condition|)
block|{
if|if
condition|(
name|cgn
operator|->
name|type
operator|&
name|OP_USEBEFORE
condition|)
block|{
comment|/* 		 * .USEBEFORE -- 		 *	prepend the child's commands to the parent. 		 */
name|Lst
name|cmds
init|=
name|pgn
operator|->
name|commands
decl_stmt|;
name|pgn
operator|->
name|commands
operator|=
name|Lst_Duplicate
argument_list|(
name|cgn
operator|->
name|commands
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_Concat
argument_list|(
name|pgn
operator|->
name|commands
argument_list|,
name|cmds
argument_list|,
name|LST_CONCNEW
argument_list|)
expr_stmt|;
name|Lst_Destroy
argument_list|(
name|cmds
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * .USE or target has no commands -- 		 *	append the child's commands to the parent. 		 */
operator|(
name|void
operator|)
name|Lst_Concat
argument_list|(
name|pgn
operator|->
name|commands
argument_list|,
name|cgn
operator|->
name|commands
argument_list|,
name|LST_CONCNEW
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Lst_Open
argument_list|(
name|cgn
operator|->
name|children
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
while|while
condition|(
operator|(
name|ln
operator|=
name|Lst_Next
argument_list|(
name|cgn
operator|->
name|children
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|GNode
modifier|*
name|tgn
decl_stmt|,
modifier|*
name|gn
init|=
operator|(
name|GNode
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
decl_stmt|;
comment|/* 	     * Expand variables in the .USE node's name 	     * and save the unexpanded form. 	     * We don't need to do this for commands. 	     * They get expanded properly when we execute. 	     */
if|if
condition|(
name|gn
operator|->
name|uname
operator|==
name|NULL
condition|)
block|{
name|gn
operator|->
name|uname
operator|=
name|gn
operator|->
name|name
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|gn
operator|->
name|name
condition|)
name|free
argument_list|(
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|gn
operator|->
name|name
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|gn
operator|->
name|uname
argument_list|,
name|pgn
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|->
name|name
operator|&&
name|gn
operator|->
name|uname
operator|&&
name|strcmp
argument_list|(
name|gn
operator|->
name|name
argument_list|,
name|gn
operator|->
name|uname
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* See if we have a target for this node. */
name|tgn
operator|=
name|Targ_FindNode
argument_list|(
name|gn
operator|->
name|name
argument_list|,
name|TARG_NOCREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tgn
operator|!=
name|NULL
condition|)
name|gn
operator|=
name|tgn
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|pgn
operator|->
name|children
argument_list|,
name|gn
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|gn
operator|->
name|parents
argument_list|,
name|pgn
argument_list|)
expr_stmt|;
name|pgn
operator|->
name|unmade
operator|+=
literal|1
expr_stmt|;
block|}
name|Lst_Close
argument_list|(
name|cgn
operator|->
name|children
argument_list|)
expr_stmt|;
block|}
name|pgn
operator|->
name|type
operator||=
name|cgn
operator|->
name|type
operator|&
operator|~
operator|(
name|OP_OPMASK
operator||
name|OP_USE
operator||
name|OP_USEBEFORE
operator||
name|OP_TRANSFORM
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * MakeHandleUse --  *	Callback function for Lst_ForEach, used by Make_Run on the downward  *	pass to handle .USE nodes. Should be called before the children  *	are enqueued to be looked at by MakeAddChild.  *	This function calls Make_HandleUse to copy the .USE node's commands,  *	type flags and children to the parent node.  *  * Input:  *	cgnp		the child we've just examined  *	pgnp		the current parent  *  * Results:  *	returns 0.  *  * Side Effects:  *	After expansion, .USE child nodes are removed from the parent  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|MakeHandleUse
parameter_list|(
name|void
modifier|*
name|cgnp
parameter_list|,
name|void
modifier|*
name|pgnp
parameter_list|)
block|{
name|GNode
modifier|*
name|cgn
init|=
operator|(
name|GNode
operator|*
operator|)
name|cgnp
decl_stmt|;
name|GNode
modifier|*
name|pgn
init|=
operator|(
name|GNode
operator|*
operator|)
name|pgnp
decl_stmt|;
name|LstNode
name|ln
decl_stmt|;
comment|/* An element in the children list */
name|int
name|unmarked
decl_stmt|;
name|unmarked
operator|=
operator|(
operator|(
name|cgn
operator|->
name|type
operator|&
name|OP_MARK
operator|)
operator|==
literal|0
operator|)
expr_stmt|;
name|cgn
operator|->
name|type
operator||=
name|OP_MARK
expr_stmt|;
if|if
condition|(
operator|(
name|cgn
operator|->
name|type
operator|&
operator|(
name|OP_USE
operator||
name|OP_USEBEFORE
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|unmarked
condition|)
name|Make_HandleUse
argument_list|(
name|cgn
argument_list|,
name|pgn
argument_list|)
expr_stmt|;
comment|/*      * This child node is now "made", so we decrement the count of      * unmade children in the parent... We also remove the child      * from the parent's list to accurately reflect the number of decent      * children the parent has. This is used by Make_Run to decide      * whether to queue the parent or examine its children...      */
if|if
condition|(
operator|(
name|ln
operator|=
name|Lst_Member
argument_list|(
name|pgn
operator|->
name|children
argument_list|,
name|cgn
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|Lst_Remove
argument_list|(
name|pgn
operator|->
name|children
argument_list|,
name|ln
argument_list|)
expr_stmt|;
name|pgn
operator|->
name|unmade
operator|--
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Make_Recheck --  *	Check the modification time of a gnode, and update it as described  *	in the comments below.  *  * Results:  *	returns 0 if the gnode does not exist, or it's filesystem  *	time if it does.  *  * Side Effects:  *	the gnode's modification time and path name are affected.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|time_t
name|Make_Recheck
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|)
block|{
name|time_t
name|mtime
init|=
name|Dir_MTime
argument_list|(
name|gn
argument_list|,
literal|1
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|RECHECK
comment|/*      * We can't re-stat the thing, but we can at least take care of rules      * where a target depends on a source that actually creates the      * target, but only if it has changed, e.g.      *      * parse.h : parse.o      *      * parse.o : parse.y      *  	yacc -d parse.y      *  	cc -c y.tab.c      *  	mv y.tab.o parse.o      *  	cmp -s y.tab.h parse.h || mv y.tab.h parse.h      *      * In this case, if the definitions produced by yacc haven't changed      * from before, parse.h won't have been updated and gn->mtime will      * reflect the current modification time for parse.h. This is      * something of a kludge, I admit, but it's a useful one..      * XXX: People like to use a rule like      *      * FRC:      *      * To force things that depend on FRC to be made, so we have to      * check for gn->children being empty as well...      */
if|if
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|gn
operator|->
name|commands
argument_list|)
operator|||
name|Lst_IsEmpty
argument_list|(
name|gn
operator|->
name|children
argument_list|)
condition|)
block|{
name|gn
operator|->
name|mtime
operator|=
name|now
expr_stmt|;
block|}
else|#
directive|else
comment|/*      * This is what Make does and it's actually a good thing, as it      * allows rules like      *      *	cmp -s y.tab.h parse.h || cp y.tab.h parse.h      *      * to function as intended. Unfortunately, thanks to the stateless      * nature of NFS (by which I mean the loose coupling of two clients      * using the same file from a common server), there are times      * when the modification time of a file created on a remote      * machine will not be modified before the local stat() implied by      * the Dir_MTime occurs, thus leading us to believe that the file      * is unchanged, wreaking havoc with files that depend on this one.      *      * I have decided it is better to make too much than to make too      * little, so this stuff is commented out unless you're sure it's ok.      * -- ardeb 1/12/88      */
comment|/*      * Christos, 4/9/92: If we are  saving commands pretend that      * the target is made now. Otherwise archives with ... rules      * don't work!      */
if|if
condition|(
name|NoExecute
argument_list|(
name|gn
argument_list|)
operator|||
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_SAVE_CMDS
operator|)
operator|||
operator|(
name|mtime
operator|==
literal|0
operator|&&
operator|!
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_WAIT
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|" recheck(%s): update time from %s to now\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|,
name|Targ_FmtTime
argument_list|(
name|gn
operator|->
name|mtime
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|gn
operator|->
name|mtime
operator|=
name|now
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|" recheck(%s): current update time: %s\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|,
name|Targ_FmtTime
argument_list|(
name|gn
operator|->
name|mtime
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return
name|mtime
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Make_Update  --  *	Perform update on the parents of a node. Used by JobFinish once  *	a node has been dealt with and by MakeStartJobs if it finds an  *	up-to-date node.  *  * Input:  *	cgn		the child node  *  * Results:  *	Always returns 0  *  * Side Effects:  *	The unmade field of pgn is decremented and pgn may be placed on  *	the toBeMade queue if this field becomes 0.  *  * 	If the child was made, the parent's flag CHILDMADE field will be  *	set true.  *  *	If the child is not up-to-date and still does not exist,  *	set the FORCE flag on the parents.  *  *	If the child wasn't made, the cmgn field of the parent will be  *	altered if the child's mtime is big enough.  *  *	Finally, if the child is the implied source for the parent, the  *	parent's IMPSRC variable is set appropriately.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Make_Update
parameter_list|(
name|GNode
modifier|*
name|cgn
parameter_list|)
block|{
name|GNode
modifier|*
name|pgn
decl_stmt|;
comment|/* the parent node */
name|char
modifier|*
name|cname
decl_stmt|;
comment|/* the child's name */
name|LstNode
name|ln
decl_stmt|;
comment|/* Element in parents and iParents lists */
name|time_t
name|mtime
init|=
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|p1
decl_stmt|;
name|Lst
name|parents
decl_stmt|;
name|GNode
modifier|*
name|centurion
decl_stmt|;
comment|/* It is save to re-examine any nodes again */
name|checked
operator|++
expr_stmt|;
name|cname
operator|=
name|Var_Value
argument_list|(
name|TARGET
argument_list|,
name|cgn
argument_list|,
operator|&
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
condition|)
name|free
argument_list|(
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"Make_Update: %s%s\n"
argument_list|,
name|cgn
operator|->
name|name
argument_list|,
name|cgn
operator|->
name|cohort_num
argument_list|)
expr_stmt|;
comment|/*      * If the child was actually made, see what its modification time is      * now -- some rules won't actually update the file. If the file still      * doesn't exist, make its mtime now.      */
if|if
condition|(
name|cgn
operator|->
name|made
operator|!=
name|UPTODATE
condition|)
block|{
name|mtime
operator|=
name|Make_Recheck
argument_list|(
name|cgn
argument_list|)
expr_stmt|;
block|}
comment|/*      * If this is a `::' node, we must consult its first instance      * which is where all parents are linked.      */
if|if
condition|(
operator|(
name|centurion
operator|=
name|cgn
operator|->
name|centurion
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|cgn
operator|->
name|parents
argument_list|)
condition|)
name|Punt
argument_list|(
literal|"%s%s: cohort has parents"
argument_list|,
name|cgn
operator|->
name|name
argument_list|,
name|cgn
operator|->
name|cohort_num
argument_list|)
expr_stmt|;
name|centurion
operator|->
name|unmade_cohorts
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|centurion
operator|->
name|unmade_cohorts
operator|<
literal|0
condition|)
name|Error
argument_list|(
literal|"Graph cycles through centurion %s"
argument_list|,
name|centurion
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|centurion
operator|=
name|cgn
expr_stmt|;
block|}
name|parents
operator|=
name|centurion
operator|->
name|parents
expr_stmt|;
comment|/* If this was a .ORDER node, schedule the RHS */
name|Lst_ForEach
argument_list|(
name|centurion
operator|->
name|order_succ
argument_list|,
name|MakeBuildParent
argument_list|,
name|Lst_First
argument_list|(
name|toBeMade
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now mark all the parents as having one less unmade child */
if|if
condition|(
name|Lst_Open
argument_list|(
name|parents
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
while|while
condition|(
operator|(
name|ln
operator|=
name|Lst_Next
argument_list|(
name|parents
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pgn
operator|=
operator|(
name|GNode
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"inspect parent %s%s: flags %x, "
literal|"type %x, made %d, unmade %d "
argument_list|,
name|pgn
operator|->
name|name
argument_list|,
name|pgn
operator|->
name|cohort_num
argument_list|,
name|pgn
operator|->
name|flags
argument_list|,
name|pgn
operator|->
name|type
argument_list|,
name|pgn
operator|->
name|made
argument_list|,
name|pgn
operator|->
name|unmade
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pgn
operator|->
name|flags
operator|&
name|REMAKE
operator|)
condition|)
block|{
comment|/* This parent isn't needed */
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"- not needed\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|mtime
operator|==
literal|0
operator|&&
operator|!
operator|(
name|cgn
operator|->
name|type
operator|&
name|OP_WAIT
operator|)
condition|)
name|pgn
operator|->
name|flags
operator||=
name|FORCE
expr_stmt|;
comment|/* 	     * If the parent has the .MADE attribute, its timestamp got 	     * updated to that of its newest child, and its unmake 	     * child count got set to zero in Make_ExpandUse(). 	     * However other things might cause us to build one of its 	     * children - and so we mustn't do any processing here when 	     * the child build finishes. 	     */
if|if
condition|(
name|pgn
operator|->
name|type
operator|&
name|OP_MADE
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"- .MADE\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
operator|(
name|cgn
operator|->
name|type
operator|&
operator|(
name|OP_EXEC
operator||
name|OP_USE
operator||
name|OP_USEBEFORE
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|cgn
operator|->
name|made
operator|==
name|MADE
condition|)
name|pgn
operator|->
name|flags
operator||=
name|CHILDMADE
expr_stmt|;
operator|(
name|void
operator|)
name|Make_TimeStamp
argument_list|(
name|pgn
argument_list|,
name|cgn
argument_list|)
expr_stmt|;
block|}
comment|/* 	     * A parent must wait for the completion of all instances 	     * of a `::' dependency. 	     */
if|if
condition|(
name|centurion
operator|->
name|unmade_cohorts
operator|!=
literal|0
operator|||
name|centurion
operator|->
name|made
operator|<
name|MADE
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"- centurion made %d, %d unmade cohorts\n"
argument_list|,
name|centurion
operator|->
name|made
argument_list|,
name|centurion
operator|->
name|unmade_cohorts
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* One more child of this parent is now made */
name|pgn
operator|->
name|unmade
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|pgn
operator|->
name|unmade
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"Graph cycles through %s%s\n"
argument_list|,
name|pgn
operator|->
name|name
argument_list|,
name|pgn
operator|->
name|cohort_num
argument_list|)
expr_stmt|;
name|Targ_PrintGraph
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|Error
argument_list|(
literal|"Graph cycles through %s%s"
argument_list|,
name|pgn
operator|->
name|name
argument_list|,
name|pgn
operator|->
name|cohort_num
argument_list|)
expr_stmt|;
block|}
comment|/* We must always rescan the parents of .WAIT and .ORDER nodes. */
if|if
condition|(
name|pgn
operator|->
name|unmade
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|centurion
operator|->
name|type
operator|&
name|OP_WAIT
operator|)
operator|&&
operator|!
operator|(
name|centurion
operator|->
name|flags
operator|&
name|DONE_ORDER
operator|)
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"- unmade children\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|pgn
operator|->
name|made
operator|!=
name|DEFERRED
condition|)
block|{
comment|/* 		 * Either this parent is on a different branch of the tree, 		 * or it on the RHS of a .WAIT directive 		 * or it is already on the toBeMade list. 		 */
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"- not deferred\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|pgn
operator|->
name|order_pred
operator|&&
name|Lst_ForEach
argument_list|(
name|pgn
operator|->
name|order_pred
argument_list|,
name|MakeCheckOrder
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* A .ORDER rule stops us building this */
continue|continue;
block|}
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
specifier|static
name|int
name|two
init|=
literal|2
decl_stmt|;
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"- %s%s made, schedule %s%s (made %d)\n"
argument_list|,
name|cgn
operator|->
name|name
argument_list|,
name|cgn
operator|->
name|cohort_num
argument_list|,
name|pgn
operator|->
name|name
argument_list|,
name|pgn
operator|->
name|cohort_num
argument_list|,
name|pgn
operator|->
name|made
argument_list|)
expr_stmt|;
name|Targ_PrintNode
argument_list|(
name|pgn
argument_list|,
operator|&
name|two
argument_list|)
expr_stmt|;
block|}
comment|/* Ok, we can schedule the parent again */
name|pgn
operator|->
name|made
operator|=
name|REQUESTED
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_EnQueue
argument_list|(
name|toBeMade
argument_list|,
name|pgn
argument_list|)
expr_stmt|;
block|}
name|Lst_Close
argument_list|(
name|parents
argument_list|)
expr_stmt|;
block|}
comment|/*      * Set the .PREFIX and .IMPSRC variables for all the implied parents      * of this node.      */
if|if
condition|(
name|Lst_Open
argument_list|(
name|cgn
operator|->
name|iParents
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
name|char
modifier|*
name|cpref
init|=
name|Var_Value
argument_list|(
name|PREFIX
argument_list|,
name|cgn
argument_list|,
operator|&
name|p1
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|ln
operator|=
name|Lst_Next
argument_list|(
name|cgn
operator|->
name|iParents
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pgn
operator|=
operator|(
name|GNode
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|pgn
operator|->
name|flags
operator|&
name|REMAKE
condition|)
block|{
name|Var_Set
argument_list|(
name|IMPSRC
argument_list|,
name|cname
argument_list|,
name|pgn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpref
operator|!=
name|NULL
condition|)
name|Var_Set
argument_list|(
name|PREFIX
argument_list|,
name|cpref
argument_list|,
name|pgn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p1
condition|)
name|free
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|Lst_Close
argument_list|(
name|cgn
operator|->
name|iParents
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * MakeAddAllSrc --  *	Add a child's name to the ALLSRC and OODATE variables of the given  *	node. Called from Make_DoAllVar via Lst_ForEach. A child is added only  *	if it has not been given the .EXEC, .USE or .INVISIBLE attributes.  *	.EXEC and .USE children are very rarely going to be files, so...  *	If the child is a .JOIN node, its ALLSRC is propagated to the parent.  *  *	A child is added to the OODATE variable if its modification time is  *	later than that of its parent, as defined by Make, except if the  *	parent is a .JOIN node. In that case, it is only added to the OODATE  *	variable if it was actually made (since .JOIN nodes don't have  *	modification times, the comparison is rather unfair...)..  *  * Results:  *	Always returns 0  *  * Side Effects:  *	The ALLSRC variable for the given node is extended.  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|MakeUnmark
parameter_list|(
name|void
modifier|*
name|cgnp
parameter_list|,
name|void
modifier|*
name|pgnp
name|MAKE_ATTR_UNUSED
parameter_list|)
block|{
name|GNode
modifier|*
name|cgn
init|=
operator|(
name|GNode
operator|*
operator|)
name|cgnp
decl_stmt|;
name|cgn
operator|->
name|type
operator|&=
operator|~
name|OP_MARK
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Input:  *	cgnp		The child to add  *	pgnp		The parent to whose ALLSRC variable it should  *			be added  *  */
end_comment

begin_function
specifier|static
name|int
name|MakeAddAllSrc
parameter_list|(
name|void
modifier|*
name|cgnp
parameter_list|,
name|void
modifier|*
name|pgnp
parameter_list|)
block|{
name|GNode
modifier|*
name|cgn
init|=
operator|(
name|GNode
operator|*
operator|)
name|cgnp
decl_stmt|;
name|GNode
modifier|*
name|pgn
init|=
operator|(
name|GNode
operator|*
operator|)
name|pgnp
decl_stmt|;
if|if
condition|(
name|cgn
operator|->
name|type
operator|&
name|OP_MARK
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|cgn
operator|->
name|type
operator||=
name|OP_MARK
expr_stmt|;
if|if
condition|(
operator|(
name|cgn
operator|->
name|type
operator|&
operator|(
name|OP_EXEC
operator||
name|OP_USE
operator||
name|OP_USEBEFORE
operator||
name|OP_INVISIBLE
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|child
decl_stmt|,
modifier|*
name|allsrc
decl_stmt|;
name|char
modifier|*
name|p1
init|=
name|NULL
decl_stmt|,
modifier|*
name|p2
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|cgn
operator|->
name|type
operator|&
name|OP_ARCHV
condition|)
name|child
operator|=
name|Var_Value
argument_list|(
name|MEMBER
argument_list|,
name|cgn
argument_list|,
operator|&
name|p1
argument_list|)
expr_stmt|;
else|else
name|child
operator|=
name|cgn
operator|->
name|path
condition|?
name|cgn
operator|->
name|path
else|:
name|cgn
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|cgn
operator|->
name|type
operator|&
name|OP_JOIN
condition|)
block|{
name|allsrc
operator|=
name|Var_Value
argument_list|(
name|ALLSRC
argument_list|,
name|cgn
argument_list|,
operator|&
name|p2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|allsrc
operator|=
name|child
expr_stmt|;
block|}
if|if
condition|(
name|allsrc
operator|!=
name|NULL
condition|)
name|Var_Append
argument_list|(
name|ALLSRC
argument_list|,
name|allsrc
argument_list|,
name|pgn
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2
condition|)
name|free
argument_list|(
name|p2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pgn
operator|->
name|type
operator|&
name|OP_JOIN
condition|)
block|{
if|if
condition|(
name|cgn
operator|->
name|made
operator|==
name|MADE
condition|)
block|{
name|Var_Append
argument_list|(
name|OODATE
argument_list|,
name|child
argument_list|,
name|pgn
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|pgn
operator|->
name|mtime
operator|<
name|cgn
operator|->
name|mtime
operator|)
operator|||
operator|(
name|cgn
operator|->
name|mtime
operator|>=
name|now
operator|&&
name|cgn
operator|->
name|made
operator|==
name|MADE
operator|)
condition|)
block|{
comment|/* 	     * It goes in the OODATE variable if the parent is younger than the 	     * child or if the child has been modified more recently than 	     * the start of the make. This is to keep pmake from getting 	     * confused if something else updates the parent after the 	     * make starts (shouldn't happen, I know, but sometimes it 	     * does). In such a case, if we've updated the kid, the parent 	     * is likely to have a modification time later than that of 	     * the kid and anything that relies on the OODATE variable will 	     * be hosed. 	     * 	     * XXX: This will cause all made children to go in the OODATE 	     * variable, even if they're not touched, if RECHECK isn't defined, 	     * since cgn->mtime is set to now in Make_Update. According to 	     * some people, this is good... 	     */
name|Var_Append
argument_list|(
name|OODATE
argument_list|,
name|child
argument_list|,
name|pgn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p1
condition|)
name|free
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Make_DoAllVar --  *	Set up the ALLSRC and OODATE variables. Sad to say, it must be  *	done separately, rather than while traversing the graph. This is  *	because Make defined OODATE to contain all sources whose modification  *	times were later than that of the target, *not* those sources that  *	were out-of-date. Since in both compatibility and native modes,  *	the modification time of the parent isn't found until the child  *	has been dealt with, we have to wait until now to fill in the  *	variable. As for ALLSRC, the ordering is important and not  *	guaranteed when in native mode, so it must be set here, too.  *  * Results:  *	None  *  * Side Effects:  *	The ALLSRC and OODATE variables of the given node is filled in.  *	If the node is a .JOIN node, its TARGET variable will be set to  * 	match its ALLSRC variable.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Make_DoAllVar
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|)
block|{
if|if
condition|(
name|gn
operator|->
name|flags
operator|&
name|DONE_ALLSRC
condition|)
return|return;
name|Lst_ForEach
argument_list|(
name|gn
operator|->
name|children
argument_list|,
name|MakeUnmark
argument_list|,
name|gn
argument_list|)
expr_stmt|;
name|Lst_ForEach
argument_list|(
name|gn
operator|->
name|children
argument_list|,
name|MakeAddAllSrc
argument_list|,
name|gn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Var_Exists
argument_list|(
name|OODATE
argument_list|,
name|gn
argument_list|)
condition|)
block|{
name|Var_Set
argument_list|(
name|OODATE
argument_list|,
literal|""
argument_list|,
name|gn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|Var_Exists
argument_list|(
name|ALLSRC
argument_list|,
name|gn
argument_list|)
condition|)
block|{
name|Var_Set
argument_list|(
name|ALLSRC
argument_list|,
literal|""
argument_list|,
name|gn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_JOIN
condition|)
block|{
name|char
modifier|*
name|p1
decl_stmt|;
name|Var_Set
argument_list|(
name|TARGET
argument_list|,
name|Var_Value
argument_list|(
name|ALLSRC
argument_list|,
name|gn
argument_list|,
operator|&
name|p1
argument_list|)
argument_list|,
name|gn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
condition|)
name|free
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
name|gn
operator|->
name|flags
operator||=
name|DONE_ALLSRC
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * MakeStartJobs --  *	Start as many jobs as possible.  *  * Results:  *	If the query flag was given to pmake, no job will be started,  *	but as soon as an out-of-date target is found, this function  *	returns TRUE. At all other times, this function returns FALSE.  *  * Side Effects:  *	Nodes are removed from the toBeMade queue and job table slots  *	are filled.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|MakeCheckOrder
parameter_list|(
name|void
modifier|*
name|v_bn
parameter_list|,
name|void
modifier|*
name|ignore
name|MAKE_ATTR_UNUSED
parameter_list|)
block|{
name|GNode
modifier|*
name|bn
init|=
name|v_bn
decl_stmt|;
if|if
condition|(
name|bn
operator|->
name|made
operator|>=
name|MADE
operator|||
operator|!
operator|(
name|bn
operator|->
name|flags
operator|&
name|REMAKE
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"MakeCheckOrder: Waiting for .ORDER node %s%s\n"
argument_list|,
name|bn
operator|->
name|name
argument_list|,
name|bn
operator|->
name|cohort_num
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|MakeBuildChild
parameter_list|(
name|void
modifier|*
name|v_cn
parameter_list|,
name|void
modifier|*
name|toBeMade_next
parameter_list|)
block|{
name|GNode
modifier|*
name|cn
init|=
name|v_cn
decl_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"MakeBuildChild: inspect %s%s, made %d, type %x\n"
argument_list|,
name|cn
operator|->
name|name
argument_list|,
name|cn
operator|->
name|cohort_num
argument_list|,
name|cn
operator|->
name|made
argument_list|,
name|cn
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|cn
operator|->
name|made
operator|>
name|DEFERRED
condition|)
return|return
literal|0
return|;
comment|/* If this node is on the RHS of a .ORDER, check LHSs. */
if|if
condition|(
name|cn
operator|->
name|order_pred
operator|&&
name|Lst_ForEach
argument_list|(
name|cn
operator|->
name|order_pred
argument_list|,
name|MakeCheckOrder
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* Can't build this (or anything else in this child list) yet */
name|cn
operator|->
name|made
operator|=
name|DEFERRED
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"MakeBuildChild: schedule %s%s\n"
argument_list|,
name|cn
operator|->
name|name
argument_list|,
name|cn
operator|->
name|cohort_num
argument_list|)
expr_stmt|;
name|cn
operator|->
name|made
operator|=
name|REQUESTED
expr_stmt|;
if|if
condition|(
name|toBeMade_next
operator|==
name|NULL
condition|)
name|Lst_AtEnd
argument_list|(
name|toBeMade
argument_list|,
name|cn
argument_list|)
expr_stmt|;
else|else
name|Lst_InsertBefore
argument_list|(
name|toBeMade
argument_list|,
name|toBeMade_next
argument_list|,
name|cn
argument_list|)
expr_stmt|;
if|if
condition|(
name|cn
operator|->
name|unmade_cohorts
operator|!=
literal|0
condition|)
name|Lst_ForEach
argument_list|(
name|cn
operator|->
name|cohorts
argument_list|,
name|MakeBuildChild
argument_list|,
name|toBeMade_next
argument_list|)
expr_stmt|;
comment|/*      * If this node is a .WAIT node with unmade chlidren      * then don't add the next sibling.      */
return|return
name|cn
operator|->
name|type
operator|&
name|OP_WAIT
operator|&&
name|cn
operator|->
name|unmade
operator|>
literal|0
return|;
block|}
end_function

begin_comment
comment|/* When a .ORDER RHS node completes we do this on each LHS */
end_comment

begin_function
specifier|static
name|int
name|MakeBuildParent
parameter_list|(
name|void
modifier|*
name|v_pn
parameter_list|,
name|void
modifier|*
name|toBeMade_next
parameter_list|)
block|{
name|GNode
modifier|*
name|pn
init|=
name|v_pn
decl_stmt|;
if|if
condition|(
name|pn
operator|->
name|made
operator|!=
name|DEFERRED
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|MakeBuildChild
argument_list|(
name|pn
argument_list|,
name|toBeMade_next
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Mark so that when this node is built we reschedule its parents */
name|pn
operator|->
name|flags
operator||=
name|DONE_ORDER
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|Boolean
name|MakeStartJobs
parameter_list|(
name|void
parameter_list|)
block|{
name|GNode
modifier|*
name|gn
decl_stmt|;
name|int
name|have_token
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|toBeMade
argument_list|)
condition|)
block|{
comment|/* Get token now to avoid cycling job-list when we only have 1 token */
if|if
condition|(
operator|!
name|have_token
operator|&&
operator|!
name|Job_TokenWithdraw
argument_list|()
condition|)
break|break;
name|have_token
operator|=
literal|1
expr_stmt|;
name|gn
operator|=
operator|(
name|GNode
operator|*
operator|)
name|Lst_DeQueue
argument_list|(
name|toBeMade
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"Examining %s%s...\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|,
name|gn
operator|->
name|cohort_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|->
name|made
operator|!=
name|REQUESTED
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"state %d\n"
argument_list|,
name|gn
operator|->
name|made
argument_list|)
expr_stmt|;
name|make_abort
argument_list|(
name|gn
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gn
operator|->
name|checked
operator|==
name|checked
condition|)
block|{
comment|/* We've already looked at this node since a job finished... */
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"already checked %s%s\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|,
name|gn
operator|->
name|cohort_num
argument_list|)
expr_stmt|;
name|gn
operator|->
name|made
operator|=
name|DEFERRED
expr_stmt|;
continue|continue;
block|}
name|gn
operator|->
name|checked
operator|=
name|checked
expr_stmt|;
if|if
condition|(
name|gn
operator|->
name|unmade
operator|!=
literal|0
condition|)
block|{
comment|/* 	     * We can't build this yet, add all unmade children to toBeMade, 	     * just before the current first element. 	     */
name|gn
operator|->
name|made
operator|=
name|DEFERRED
expr_stmt|;
name|Lst_ForEach
argument_list|(
name|gn
operator|->
name|children
argument_list|,
name|MakeBuildChild
argument_list|,
name|Lst_First
argument_list|(
name|toBeMade
argument_list|)
argument_list|)
expr_stmt|;
comment|/* and drop this node on the floor */
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"dropped %s%s\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|,
name|gn
operator|->
name|cohort_num
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|gn
operator|->
name|made
operator|=
name|BEINGMADE
expr_stmt|;
if|if
condition|(
name|Make_OODate
argument_list|(
name|gn
argument_list|)
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"out-of-date\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|queryFlag
condition|)
block|{
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
name|Make_DoAllVar
argument_list|(
name|gn
argument_list|)
expr_stmt|;
name|Job_Make
argument_list|(
name|gn
argument_list|)
expr_stmt|;
name|have_token
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"up-to-date\n"
argument_list|)
expr_stmt|;
block|}
name|gn
operator|->
name|made
operator|=
name|UPTODATE
expr_stmt|;
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_JOIN
condition|)
block|{
comment|/* 		 * Even for an up-to-date .JOIN node, we need it to have its 		 * context variables so references to it get the correct 		 * value for .TARGET when building up the context variables 		 * of its parent(s)... 		 */
name|Make_DoAllVar
argument_list|(
name|gn
argument_list|)
expr_stmt|;
block|}
name|Make_Update
argument_list|(
name|gn
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|have_token
condition|)
name|Job_TokenReturn
argument_list|()
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * MakePrintStatus --  *	Print the status of a top-level node, viz. it being up-to-date  *	already or not created due to an error in a lower level.  *	Callback function for Make_Run via Lst_ForEach.  *  * Input:  *	gnp		Node to examine  *	cyclep		True if gn->unmade being non-zero implies a  *			cycle in the graph, not an error in an  *			inferior.  *  * Results:  *	Always returns 0.  *  * Side Effects:  *	A message may be printed.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|MakePrintStatusOrder
parameter_list|(
name|void
modifier|*
name|ognp
parameter_list|,
name|void
modifier|*
name|gnp
parameter_list|)
block|{
name|GNode
modifier|*
name|ogn
init|=
name|ognp
decl_stmt|;
name|GNode
modifier|*
name|gn
init|=
name|gnp
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ogn
operator|->
name|flags
operator|&
name|REMAKE
operator|)
operator|||
name|ogn
operator|->
name|made
operator|>
name|REQUESTED
condition|)
comment|/* not waiting for this one */
return|return
literal|0
return|;
name|printf
argument_list|(
literal|"    `%s%s' has .ORDER dependency against %s%s "
literal|"(made %d, flags %x, type %x)\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|,
name|gn
operator|->
name|cohort_num
argument_list|,
name|ogn
operator|->
name|name
argument_list|,
name|ogn
operator|->
name|cohort_num
argument_list|,
name|ogn
operator|->
name|made
argument_list|,
name|ogn
operator|->
name|flags
argument_list|,
name|ogn
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
operator|&&
name|debug_file
operator|!=
name|stdout
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"    `%s%s' has .ORDER dependency against %s%s "
literal|"(made %d, flags %x, type %x)\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|,
name|gn
operator|->
name|cohort_num
argument_list|,
name|ogn
operator|->
name|name
argument_list|,
name|ogn
operator|->
name|cohort_num
argument_list|,
name|ogn
operator|->
name|made
argument_list|,
name|ogn
operator|->
name|flags
argument_list|,
name|ogn
operator|->
name|type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|MakePrintStatus
parameter_list|(
name|void
modifier|*
name|gnp
parameter_list|,
name|void
modifier|*
name|v_errors
parameter_list|)
block|{
name|GNode
modifier|*
name|gn
init|=
operator|(
name|GNode
operator|*
operator|)
name|gnp
decl_stmt|;
name|int
modifier|*
name|errors
init|=
name|v_errors
decl_stmt|;
if|if
condition|(
name|gn
operator|->
name|flags
operator|&
name|DONECYCLE
condition|)
comment|/* We've completely processed this node before, don't do it again. */
return|return
literal|0
return|;
if|if
condition|(
name|gn
operator|->
name|unmade
operator|==
literal|0
condition|)
block|{
name|gn
operator|->
name|flags
operator||=
name|DONECYCLE
expr_stmt|;
switch|switch
condition|(
name|gn
operator|->
name|made
condition|)
block|{
case|case
name|UPTODATE
case|:
name|printf
argument_list|(
literal|"`%s%s' is up to date.\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|,
name|gn
operator|->
name|cohort_num
argument_list|)
expr_stmt|;
break|break;
case|case
name|MADE
case|:
break|break;
case|case
name|UNMADE
case|:
case|case
name|DEFERRED
case|:
case|case
name|REQUESTED
case|:
case|case
name|BEINGMADE
case|:
operator|(
operator|*
name|errors
operator|)
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"`%s%s' was not built (made %d, flags %x, type %x)!\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|,
name|gn
operator|->
name|cohort_num
argument_list|,
name|gn
operator|->
name|made
argument_list|,
name|gn
operator|->
name|flags
argument_list|,
name|gn
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
operator|&&
name|debug_file
operator|!=
name|stdout
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"`%s%s' was not built (made %d, flags %x, type %x)!\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|,
name|gn
operator|->
name|cohort_num
argument_list|,
name|gn
operator|->
name|made
argument_list|,
name|gn
operator|->
name|flags
argument_list|,
name|gn
operator|->
name|type
argument_list|)
expr_stmt|;
comment|/* Most likely problem is actually caused by .ORDER */
name|Lst_ForEach
argument_list|(
name|gn
operator|->
name|order_pred
argument_list|,
name|MakePrintStatusOrder
argument_list|,
name|gn
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Errors - already counted */
name|printf
argument_list|(
literal|"`%s%s' not remade because of errors.\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|,
name|gn
operator|->
name|cohort_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
operator|&&
name|debug_file
operator|!=
name|stdout
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"`%s%s' not remade because of errors.\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|,
name|gn
operator|->
name|cohort_num
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"MakePrintStatus: %s%s has %d unmade children\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|,
name|gn
operator|->
name|cohort_num
argument_list|,
name|gn
operator|->
name|unmade
argument_list|)
expr_stmt|;
comment|/*      * If printing cycles and came to one that has unmade children,      * print out the cycle by recursing on its children.      */
if|if
condition|(
operator|!
operator|(
name|gn
operator|->
name|flags
operator|&
name|CYCLE
operator|)
condition|)
block|{
comment|/* Fist time we've seen this node, check all children */
name|gn
operator|->
name|flags
operator||=
name|CYCLE
expr_stmt|;
name|Lst_ForEach
argument_list|(
name|gn
operator|->
name|children
argument_list|,
name|MakePrintStatus
argument_list|,
name|errors
argument_list|)
expr_stmt|;
comment|/* Mark that this node needn't be processed again */
name|gn
operator|->
name|flags
operator||=
name|DONECYCLE
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Only output the error once per node */
name|gn
operator|->
name|flags
operator||=
name|DONECYCLE
expr_stmt|;
name|Error
argument_list|(
literal|"Graph cycles through `%s%s'"
argument_list|,
name|gn
operator|->
name|name
argument_list|,
name|gn
operator|->
name|cohort_num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|errors
operator|)
operator|++
operator|>
literal|100
condition|)
comment|/* Abandon the whole error report */
return|return
literal|1
return|;
comment|/* Reporting for our children will give the rest of the loop */
name|Lst_ForEach
argument_list|(
name|gn
operator|->
name|children
argument_list|,
name|MakePrintStatus
argument_list|,
name|errors
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Make_ExpandUse --  *	Expand .USE nodes and create a new targets list  *  * Input:  *	targs		the initial list of targets  *  * Side Effects:  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Make_ExpandUse
parameter_list|(
name|Lst
name|targs
parameter_list|)
block|{
name|GNode
modifier|*
name|gn
decl_stmt|;
comment|/* a temporary pointer */
name|Lst
name|examine
decl_stmt|;
comment|/* List of targets to examine */
name|examine
operator|=
name|Lst_Duplicate
argument_list|(
name|targs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*      * Make an initial downward pass over the graph, marking nodes to be made      * as we go down. We call Suff_FindDeps to find where a node is and      * to get some children for it if it has none and also has no commands.      * If the node is a leaf, we stick it on the toBeMade queue to      * be looked at in a minute, otherwise we add its children to our queue      * and go on about our business.      */
while|while
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|examine
argument_list|)
condition|)
block|{
name|gn
operator|=
operator|(
name|GNode
operator|*
operator|)
name|Lst_DeQueue
argument_list|(
name|examine
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|->
name|flags
operator|&
name|REMAKE
condition|)
comment|/* We've looked at this one already */
continue|continue;
name|gn
operator|->
name|flags
operator||=
name|REMAKE
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"Make_ExpandUse: examine %s%s\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|,
name|gn
operator|->
name|cohort_num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_DOUBLEDEP
operator|)
operator|&&
operator|!
name|Lst_IsEmpty
argument_list|(
name|gn
operator|->
name|cohorts
argument_list|)
condition|)
block|{
comment|/* Append all the 'cohorts' to the list of things to examine */
name|Lst
name|new
decl_stmt|;
name|new
operator|=
name|Lst_Duplicate
argument_list|(
name|gn
operator|->
name|cohorts
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|Lst_Concat
argument_list|(
name|new
argument_list|,
name|examine
argument_list|,
name|LST_CONCLINK
argument_list|)
expr_stmt|;
name|examine
operator|=
name|new
expr_stmt|;
block|}
comment|/* 	 * Apply any .USE rules before looking for implicit dependencies 	 * to make sure everything has commands that should... 	 * Make sure that the TARGET is set, so that we can make 	 * expansions. 	 */
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_ARCHV
condition|)
block|{
name|char
modifier|*
name|eoa
decl_stmt|,
modifier|*
name|eon
decl_stmt|;
name|eoa
operator|=
name|strchr
argument_list|(
name|gn
operator|->
name|name
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|eon
operator|=
name|strchr
argument_list|(
name|gn
operator|->
name|name
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
name|eoa
operator|==
name|NULL
operator|||
name|eon
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|eoa
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|eon
operator|=
literal|'\0'
expr_stmt|;
name|Var_Set
argument_list|(
name|MEMBER
argument_list|,
name|eoa
operator|+
literal|1
argument_list|,
name|gn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Var_Set
argument_list|(
name|ARCHIVE
argument_list|,
name|gn
operator|->
name|name
argument_list|,
name|gn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|eoa
operator|=
literal|'('
expr_stmt|;
operator|*
name|eon
operator|=
literal|')'
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|Dir_MTime
argument_list|(
name|gn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Var_Set
argument_list|(
name|TARGET
argument_list|,
name|gn
operator|->
name|path
condition|?
name|gn
operator|->
name|path
else|:
name|gn
operator|->
name|name
argument_list|,
name|gn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Lst_ForEach
argument_list|(
name|gn
operator|->
name|children
argument_list|,
name|MakeUnmark
argument_list|,
name|gn
argument_list|)
expr_stmt|;
name|Lst_ForEach
argument_list|(
name|gn
operator|->
name|children
argument_list|,
name|MakeHandleUse
argument_list|,
name|gn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_MADE
operator|)
operator|==
literal|0
condition|)
name|Suff_FindDeps
argument_list|(
name|gn
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Pretend we made all this node's children */
name|Lst_ForEach
argument_list|(
name|gn
operator|->
name|children
argument_list|,
name|MakeFindChild
argument_list|,
name|gn
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|->
name|unmade
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"Warning: %s%s still has %d unmade children\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|,
name|gn
operator|->
name|cohort_num
argument_list|,
name|gn
operator|->
name|unmade
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gn
operator|->
name|unmade
operator|!=
literal|0
condition|)
name|Lst_ForEach
argument_list|(
name|gn
operator|->
name|children
argument_list|,
name|MakeAddChild
argument_list|,
name|examine
argument_list|)
expr_stmt|;
block|}
name|Lst_Destroy
argument_list|(
name|examine
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Make_ProcessWait --  *	Convert .WAIT nodes into dependencies  *  * Input:  *	targs		the initial list of targets  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|link_parent
parameter_list|(
name|void
modifier|*
name|cnp
parameter_list|,
name|void
modifier|*
name|pnp
parameter_list|)
block|{
name|GNode
modifier|*
name|cn
init|=
name|cnp
decl_stmt|;
name|GNode
modifier|*
name|pn
init|=
name|pnp
decl_stmt|;
name|Lst_AtEnd
argument_list|(
name|pn
operator|->
name|children
argument_list|,
name|cn
argument_list|)
expr_stmt|;
name|Lst_AtEnd
argument_list|(
name|cn
operator|->
name|parents
argument_list|,
name|pn
argument_list|)
expr_stmt|;
name|pn
operator|->
name|unmade
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|add_wait_dep
parameter_list|(
name|void
modifier|*
name|v_cn
parameter_list|,
name|void
modifier|*
name|v_wn
parameter_list|)
block|{
name|GNode
modifier|*
name|cn
init|=
name|v_cn
decl_stmt|;
name|GNode
modifier|*
name|wn
init|=
name|v_wn
decl_stmt|;
if|if
condition|(
name|cn
operator|==
name|wn
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|cn
operator|==
name|NULL
operator|||
name|wn
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"bad wait dep %p %p\n"
argument_list|,
name|cn
argument_list|,
name|wn
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|".WAIT: add dependency %s%s -> %s\n"
argument_list|,
name|cn
operator|->
name|name
argument_list|,
name|cn
operator|->
name|cohort_num
argument_list|,
name|wn
operator|->
name|name
argument_list|)
expr_stmt|;
name|Lst_AtEnd
argument_list|(
name|wn
operator|->
name|children
argument_list|,
name|cn
argument_list|)
expr_stmt|;
name|wn
operator|->
name|unmade
operator|++
expr_stmt|;
name|Lst_AtEnd
argument_list|(
name|cn
operator|->
name|parents
argument_list|,
name|wn
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|Make_ProcessWait
parameter_list|(
name|Lst
name|targs
parameter_list|)
block|{
name|GNode
modifier|*
name|pgn
decl_stmt|;
comment|/* 'parent' node we are examining */
name|GNode
modifier|*
name|cgn
decl_stmt|;
comment|/* Each child in turn */
name|LstNode
name|owln
decl_stmt|;
comment|/* Previous .WAIT node */
name|Lst
name|examine
decl_stmt|;
comment|/* List of targets to examine */
name|LstNode
name|ln
decl_stmt|;
comment|/*      * We need all the nodes to have a common parent in order for the      * .WAIT and .ORDER scheduling to work.      * Perhaps this should be done earlier...      */
name|pgn
operator|=
name|Targ_NewGN
argument_list|(
literal|".MAIN"
argument_list|)
expr_stmt|;
name|pgn
operator|->
name|flags
operator|=
name|REMAKE
expr_stmt|;
name|pgn
operator|->
name|type
operator|=
name|OP_PHONY
operator||
name|OP_DEPENDS
expr_stmt|;
comment|/* Get it displayed in the diag dumps */
name|Lst_AtFront
argument_list|(
name|Targ_List
argument_list|()
argument_list|,
name|pgn
argument_list|)
expr_stmt|;
name|Lst_ForEach
argument_list|(
name|targs
argument_list|,
name|link_parent
argument_list|,
name|pgn
argument_list|)
expr_stmt|;
comment|/* Start building with the 'dummy' .MAIN' node */
name|MakeBuildChild
argument_list|(
name|pgn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|examine
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|Lst_AtEnd
argument_list|(
name|examine
argument_list|,
name|pgn
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|examine
argument_list|)
condition|)
block|{
name|pgn
operator|=
name|Lst_DeQueue
argument_list|(
name|examine
argument_list|)
expr_stmt|;
comment|/* We only want to process each child-list once */
if|if
condition|(
name|pgn
operator|->
name|flags
operator|&
name|DONE_WAIT
condition|)
continue|continue;
name|pgn
operator|->
name|flags
operator||=
name|DONE_WAIT
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"Make_ProcessWait: examine %s\n"
argument_list|,
name|pgn
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pgn
operator|->
name|type
operator|&
name|OP_DOUBLEDEP
operator|)
operator|&&
operator|!
name|Lst_IsEmpty
argument_list|(
name|pgn
operator|->
name|cohorts
argument_list|)
condition|)
block|{
comment|/* Append all the 'cohorts' to the list of things to examine */
name|Lst
name|new
decl_stmt|;
name|new
operator|=
name|Lst_Duplicate
argument_list|(
name|pgn
operator|->
name|cohorts
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|Lst_Concat
argument_list|(
name|new
argument_list|,
name|examine
argument_list|,
name|LST_CONCLINK
argument_list|)
expr_stmt|;
name|examine
operator|=
name|new
expr_stmt|;
block|}
name|owln
operator|=
name|Lst_First
argument_list|(
name|pgn
operator|->
name|children
argument_list|)
expr_stmt|;
name|Lst_Open
argument_list|(
name|pgn
operator|->
name|children
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|(
name|ln
operator|=
name|Lst_Next
argument_list|(
name|pgn
operator|->
name|children
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|cgn
operator|=
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|cgn
operator|->
name|type
operator|&
name|OP_WAIT
condition|)
block|{
comment|/* Make the .WAIT node depend on the previous children */
name|Lst_ForEachFrom
argument_list|(
name|pgn
operator|->
name|children
argument_list|,
name|owln
argument_list|,
name|add_wait_dep
argument_list|,
name|cgn
argument_list|)
expr_stmt|;
name|owln
operator|=
name|ln
expr_stmt|;
block|}
else|else
block|{
name|Lst_AtEnd
argument_list|(
name|examine
argument_list|,
name|cgn
argument_list|)
expr_stmt|;
block|}
block|}
name|Lst_Close
argument_list|(
name|pgn
operator|->
name|children
argument_list|)
expr_stmt|;
block|}
name|Lst_Destroy
argument_list|(
name|examine
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Make_Run --  *	Initialize the nodes to remake and the list of nodes which are  *	ready to be made by doing a breadth-first traversal of the graph  *	starting from the nodes in the given list. Once this traversal  *	is finished, all the 'leaves' of the graph are in the toBeMade  *	queue.  *	Using this queue and the Job module, work back up the graph,  *	calling on MakeStartJobs to keep the job table as full as  *	possible.  *  * Input:  *	targs		the initial list of targets  *  * Results:  *	TRUE if work was done. FALSE otherwise.  *  * Side Effects:  *	The make field of all nodes involved in the creation of the given  *	targets is set to 1. The toBeMade list is set to contain all the  *	'leaves' of these subgraphs.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|Boolean
name|Make_Run
parameter_list|(
name|Lst
name|targs
parameter_list|)
block|{
name|int
name|errors
decl_stmt|;
comment|/* Number of errors the Job module reports */
comment|/* Start trying to make the current targets... */
name|toBeMade
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|Make_ExpandUse
argument_list|(
name|targs
argument_list|)
expr_stmt|;
name|Make_ProcessWait
argument_list|(
name|targs
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"#***# full graph\n"
argument_list|)
expr_stmt|;
name|Targ_PrintGraph
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|queryFlag
condition|)
block|{
comment|/* 	 * We wouldn't do any work unless we could start some jobs in the 	 * next loop... (we won't actually start any, of course, this is just 	 * to see if any of the targets was out of date) 	 */
return|return
operator|(
name|MakeStartJobs
argument_list|()
operator|)
return|;
block|}
comment|/*      * Initialization. At the moment, no jobs are running and until some      * get started, nothing will happen since the remaining upward      * traversal of the graph is performed by the routines in job.c upon      * the finishing of a job. So we fill the Job table as much as we can      * before going into our loop.      */
operator|(
name|void
operator|)
name|MakeStartJobs
argument_list|()
expr_stmt|;
comment|/*      * Main Loop: The idea here is that the ending of jobs will take      * care of the maintenance of data structures and the waiting for output      * will cause us to be idle most of the time while our children run as      * much as possible. Because the job table is kept as full as possible,      * the only time when it will be empty is when all the jobs which need      * running have been run, so that is the end condition of this loop.      * Note that the Job module will exit if there were any errors unless the      * keepgoing flag was given.      */
while|while
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|toBeMade
argument_list|)
operator|||
name|jobTokensRunning
operator|>
literal|0
condition|)
block|{
name|Job_CatchOutput
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|MakeStartJobs
argument_list|()
expr_stmt|;
block|}
name|errors
operator|=
name|Job_Finish
argument_list|()
expr_stmt|;
comment|/*      * Print the final status of each target. E.g. if it wasn't made      * because some inferior reported an error.      */
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"done: errors %d\n"
argument_list|,
name|errors
argument_list|)
expr_stmt|;
if|if
condition|(
name|errors
operator|==
literal|0
condition|)
block|{
name|Lst_ForEach
argument_list|(
name|targs
argument_list|,
name|MakePrintStatus
argument_list|,
operator|&
name|errors
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"done: errors %d\n"
argument_list|,
name|errors
argument_list|)
expr_stmt|;
if|if
condition|(
name|errors
condition|)
name|Targ_PrintGraph
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|errors
operator|!=
literal|0
return|;
block|}
end_function

end_unit

