begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: compat.c,v 1.107 2017/07/20 19:29:54 sjg Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 1988, 1989, 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Adam de Boor.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1988, 1989 by Adam de Boor  * Copyright (c) 1989 by Berkeley Softworks  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Adam de Boor.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAKE_NATIVE
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$NetBSD: compat.c,v 1.107 2017/07/20 19:29:54 sjg Exp $"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_else
unit|static char sccsid[] = "@(#)compat.c	8.2 (Berkeley) 3/19/94";
else|#
directive|else
end_else

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$NetBSD: compat.c,v 1.107 2017/07/20 19:29:54 sjg Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*-  * compat.c --  *	The routines in this file implement the full-compatibility  *	mode of PMake. Most of the special functionality of PMake  *	is available in this mode. Things not supported:  *	    - different shells.  *	    - friendly variable substitution.  *  * Interface:  *	Compat_Run	    Initialize things for this module and recreate  *	    	  	    thems as need creatin'  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"make.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"job.h"
end_include

begin_include
include|#
directive|include
file|"metachar.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_decl_stmt
specifier|static
name|GNode
modifier|*
name|curTarg
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|GNode
modifier|*
name|ENDNode
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|CompatInterrupt
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|pid_t
name|compatChild
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compatSigno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * CompatDeleteTarget -- delete a failed, interrupted, or otherwise  * duffed target if not inhibited by .PRECIOUS.  */
end_comment

begin_function
specifier|static
name|void
name|CompatDeleteTarget
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|)
block|{
if|if
condition|(
operator|(
name|gn
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|Targ_Precious
argument_list|(
name|gn
argument_list|)
condition|)
block|{
name|char
modifier|*
name|p1
decl_stmt|;
name|char
modifier|*
name|file
init|=
name|Var_Value
argument_list|(
name|TARGET
argument_list|,
name|gn
argument_list|,
operator|&
name|p1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|noExecute
operator|&&
name|eunlink
argument_list|(
name|file
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|Error
argument_list|(
literal|"*** %s removed"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * CompatInterrupt --  *	Interrupt the creation of the current target and remove it if  *	it ain't precious.  *  * Results:  *	None.  *  * Side Effects:  *	The target is removed and the process exits. If .INTERRUPT exists,  *	its commands are run first WITH INTERRUPTS IGNORED..  *  * XXX: is .PRECIOUS supposed to inhibit .INTERRUPT? I doubt it, but I've  * left the logic alone for now. - dholland 20160826  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|CompatInterrupt
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
name|GNode
modifier|*
name|gn
decl_stmt|;
name|CompatDeleteTarget
argument_list|(
name|curTarg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|curTarg
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|Targ_Precious
argument_list|(
name|curTarg
argument_list|)
condition|)
block|{
comment|/* 	 * Run .INTERRUPT only if hit with interrupt signal 	 */
if|if
condition|(
name|signo
operator|==
name|SIGINT
condition|)
block|{
name|gn
operator|=
name|Targ_FindNode
argument_list|(
literal|".INTERRUPT"
argument_list|,
name|TARG_NOCREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|!=
name|NULL
condition|)
block|{
name|Compat_Make
argument_list|(
name|gn
argument_list|,
name|gn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|signo
operator|==
name|SIGQUIT
condition|)
name|_exit
argument_list|(
name|signo
argument_list|)
expr_stmt|;
comment|/*      * If there is a child running, pass the signal on      * we will exist after it has exited.      */
name|compatSigno
operator|=
name|signo
expr_stmt|;
if|if
condition|(
name|compatChild
operator|>
literal|0
condition|)
block|{
name|KILLPG
argument_list|(
name|compatChild
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bmake_signal
argument_list|(
name|signo
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|myPid
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * CompatRunCommand --  *	Execute the next command for a target. If the command returns an  *	error, the node's made field is set to ERROR and creation stops.  *  * Input:  *	cmdp		Command to execute  *	gnp		Node from which the command came  *  * Results:  *	0 if the command succeeded, 1 if an error occurred.  *  * Side Effects:  *	The node's 'made' field may be set to ERROR.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|CompatRunCommand
parameter_list|(
name|void
modifier|*
name|cmdp
parameter_list|,
name|void
modifier|*
name|gnp
parameter_list|)
block|{
name|char
modifier|*
name|cmdStart
decl_stmt|;
comment|/* Start of expanded command */
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|Boolean
name|silent
decl_stmt|,
comment|/* Don't print command */
name|doIt
decl_stmt|;
comment|/* Execute even if -n */
specifier|volatile
name|Boolean
name|errCheck
decl_stmt|;
comment|/* Check errors */
name|WAIT_T
name|reason
decl_stmt|;
comment|/* Reason for child's death */
name|int
name|status
decl_stmt|;
comment|/* Description of child's death */
name|pid_t
name|cpid
decl_stmt|;
comment|/* Child actually found */
name|pid_t
name|retstat
decl_stmt|;
comment|/* Result of wait */
name|LstNode
name|cmdNode
decl_stmt|;
comment|/* Node where current command is located */
specifier|const
name|char
modifier|*
modifier|*
specifier|volatile
name|av
decl_stmt|;
comment|/* Argument vector for thing to exec */
name|char
modifier|*
modifier|*
specifier|volatile
name|mav
decl_stmt|;
comment|/* Copy of the argument vector for freeing */
name|int
name|argc
decl_stmt|;
comment|/* Number of arguments in av or 0 if not 				 * dynamically allocated */
name|Boolean
name|local
decl_stmt|;
comment|/* TRUE if command should be executed 				 * locally */
name|Boolean
name|useShell
decl_stmt|;
comment|/* TRUE if command should be executed 				 * using a shell */
name|char
modifier|*
specifier|volatile
name|cmd
init|=
operator|(
name|char
operator|*
operator|)
name|cmdp
decl_stmt|;
name|GNode
modifier|*
name|gn
init|=
operator|(
name|GNode
operator|*
operator|)
name|gnp
decl_stmt|;
name|silent
operator|=
name|gn
operator|->
name|type
operator|&
name|OP_SILENT
expr_stmt|;
name|errCheck
operator|=
operator|!
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_IGNORE
operator|)
expr_stmt|;
name|doIt
operator|=
name|FALSE
expr_stmt|;
name|cmdNode
operator|=
name|Lst_Member
argument_list|(
name|gn
operator|->
name|commands
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|cmdStart
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|cmd
argument_list|,
name|gn
argument_list|,
name|VARF_WANTRES
argument_list|)
expr_stmt|;
comment|/*      * brk_string will return an argv with a NULL in av[0], thus causing      * execvp to choke and die horribly. Besides, how can we execute a null      * command? In any case, we warn the user that the command expanded to      * nothing (is this the right thing to do?).      */
if|if
condition|(
operator|*
name|cmdStart
operator|==
literal|'\0'
condition|)
block|{
name|free
argument_list|(
name|cmdStart
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cmd
operator|=
name|cmdStart
expr_stmt|;
name|Lst_Replace
argument_list|(
name|cmdNode
argument_list|,
name|cmdStart
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_SAVE_CMDS
operator|)
operator|&&
operator|(
name|gn
operator|!=
name|ENDNode
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|ENDNode
operator|->
name|commands
argument_list|,
name|cmdStart
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|cmdStart
argument_list|,
literal|"..."
argument_list|)
operator|==
literal|0
condition|)
block|{
name|gn
operator|->
name|type
operator||=
name|OP_SAVE_CMDS
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
while|while
condition|(
operator|(
operator|*
name|cmd
operator|==
literal|'@'
operator|)
operator|||
operator|(
operator|*
name|cmd
operator|==
literal|'-'
operator|)
operator|||
operator|(
operator|*
name|cmd
operator|==
literal|'+'
operator|)
condition|)
block|{
switch|switch
condition|(
operator|*
name|cmd
condition|)
block|{
case|case
literal|'@'
case|:
name|silent
operator|=
name|DEBUG
argument_list|(
name|LOUD
argument_list|)
condition|?
name|FALSE
else|:
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|errCheck
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|doIt
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|shellName
condition|)
comment|/* we came here from jobs */
name|Shell_Init
argument_list|()
expr_stmt|;
break|break;
block|}
name|cmd
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cmd
argument_list|)
condition|)
name|cmd
operator|++
expr_stmt|;
comment|/*      * If we did not end up with a command, just skip it.      */
if|if
condition|(
operator|!
operator|*
name|cmd
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAKE_NATIVE
argument_list|)
comment|/*      * In a non-native build, the host environment might be weird enough      * that it's necessary to go through a shell to get the correct      * behaviour.  Or perhaps the shell has been replaced with something      * that does extra logging, and that should not be bypassed.      */
name|useShell
operator|=
name|TRUE
expr_stmt|;
else|#
directive|else
comment|/*      * Search for meta characters in the command. If there are no meta      * characters, there's no need to execute a shell to execute the      * command.      *      * Additionally variable assignments and empty commands      * go to the shell. Therefore treat '=' and ':' like shell      * meta characters as documented in make(1).      */
name|useShell
operator|=
name|needshell
argument_list|(
name|cmd
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*      * Print the command before echoing if we're not supposed to be quiet for      * this one. We also print the command if -n given.      */
if|if
condition|(
operator|!
name|silent
operator|||
name|NoExecute
argument_list|(
name|gn
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
comment|/*      * If we're not supposed to execute any commands, this is as far as      * we go...      */
if|if
condition|(
operator|!
name|doIt
operator|&&
name|NoExecute
argument_list|(
name|gn
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|DEBUG
argument_list|(
name|JOB
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"Execute: '%s'\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|again
label|:
if|if
condition|(
name|useShell
condition|)
block|{
comment|/* 	 * We need to pass the command off to the shell, typically 	 * because the command contains a "meta" character. 	 */
specifier|static
specifier|const
name|char
modifier|*
name|shargv
index|[
literal|5
index|]
decl_stmt|;
name|int
name|shargc
decl_stmt|;
name|shargc
operator|=
literal|0
expr_stmt|;
name|shargv
index|[
name|shargc
operator|++
index|]
operator|=
name|shellPath
expr_stmt|;
comment|/* 	 * The following work for any of the builtin shell specs. 	 */
if|if
condition|(
name|errCheck
operator|&&
name|shellErrFlag
condition|)
block|{
name|shargv
index|[
name|shargc
operator|++
index|]
operator|=
name|shellErrFlag
expr_stmt|;
block|}
if|if
condition|(
name|DEBUG
argument_list|(
name|SHELL
argument_list|)
condition|)
name|shargv
index|[
name|shargc
operator|++
index|]
operator|=
literal|"-xc"
expr_stmt|;
else|else
name|shargv
index|[
name|shargc
operator|++
index|]
operator|=
literal|"-c"
expr_stmt|;
name|shargv
index|[
name|shargc
operator|++
index|]
operator|=
name|cmd
expr_stmt|;
name|shargv
index|[
name|shargc
operator|++
index|]
operator|=
name|NULL
expr_stmt|;
name|av
operator|=
name|shargv
expr_stmt|;
name|argc
operator|=
literal|0
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
name|mav
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * No meta-characters, so no need to exec a shell. Break the command 	 * into words to form an argument vector we can execute. 	 */
name|mav
operator|=
name|brk_string
argument_list|(
name|cmd
argument_list|,
operator|&
name|argc
argument_list|,
name|TRUE
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mav
operator|==
name|NULL
condition|)
block|{
name|useShell
operator|=
literal|1
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|av
operator|=
operator|(
name|void
operator|*
operator|)
name|mav
expr_stmt|;
block|}
name|local
operator|=
name|TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_META
if|if
condition|(
name|useMeta
condition|)
block|{
name|meta_compat_start
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*      * Fork and execute the single command. If the fork fails, we abort.      */
name|compatChild
operator|=
name|cpid
operator|=
name|vFork
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpid
operator|<
literal|0
condition|)
block|{
name|Fatal
argument_list|(
literal|"Could not fork"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cpid
operator|==
literal|0
condition|)
block|{
name|Var_ExportVars
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_META
if|if
condition|(
name|useMeta
condition|)
block|{
name|meta_compat_child
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|local
condition|)
operator|(
name|void
operator|)
name|execvp
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
operator|(
name|char
operator|*
specifier|const
operator|*
operator|)
name|UNCONST
argument_list|(
name|av
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|execv
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
operator|(
name|char
operator|*
specifier|const
operator|*
operator|)
name|UNCONST
argument_list|(
name|av
argument_list|)
argument_list|)
expr_stmt|;
name|execError
argument_list|(
literal|"exec"
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|mav
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|Lst_Replace
argument_list|(
name|cmdNode
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_META
if|if
condition|(
name|useMeta
condition|)
block|{
name|meta_compat_parent
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*      * The child is off and running. Now all we can do is wait...      */
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
operator|(
name|retstat
operator|=
name|wait
argument_list|(
operator|&
name|reason
argument_list|)
operator|)
operator|!=
name|cpid
condition|)
block|{
if|if
condition|(
name|retstat
operator|>
literal|0
condition|)
name|JobReapChild
argument_list|(
name|retstat
argument_list|,
name|reason
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* not ours? */
if|if
condition|(
name|retstat
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|retstat
operator|>
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|reason
argument_list|)
condition|)
block|{
name|status
operator|=
name|WSTOPSIG
argument_list|(
name|reason
argument_list|)
expr_stmt|;
comment|/* stopped */
block|}
elseif|else
if|if
condition|(
name|WIFEXITED
argument_list|(
name|reason
argument_list|)
condition|)
block|{
name|status
operator|=
name|WEXITSTATUS
argument_list|(
name|reason
argument_list|)
expr_stmt|;
comment|/* exited */
if|#
directive|if
name|defined
argument_list|(
name|USE_META
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_FILEMON_ONCE
argument_list|)
if|if
condition|(
name|useMeta
condition|)
block|{
name|meta_cmd_finish
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|ERROR
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"\n*** Failed target:  %s\n*** Failed command: "
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|cmd
init|;
operator|*
name|cp
condition|;
control|)
block|{
if|if
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"%c"
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"*** Error code %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|status
operator|=
name|WTERMSIG
argument_list|(
name|reason
argument_list|)
expr_stmt|;
comment|/* signaled */
name|printf
argument_list|(
literal|"*** Signal %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|WIFEXITED
argument_list|(
name|reason
argument_list|)
operator|||
operator|(
name|status
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|errCheck
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_META
if|if
condition|(
name|useMeta
condition|)
block|{
name|meta_job_error
argument_list|(
name|NULL
argument_list|,
name|gn
argument_list|,
literal|0
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|gn
operator|->
name|made
operator|=
name|ERROR
expr_stmt|;
if|if
condition|(
name|keepgoing
condition|)
block|{
comment|/* 			 * Abort the current target, but let others 			 * continue. 			 */
name|printf
argument_list|(
literal|" (continuing)\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|deleteOnError
condition|)
block|{
name|CompatDeleteTarget
argument_list|(
name|gn
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		     * Continue executing commands for this target. 		     * If we return 0, this will happen... 		     */
name|printf
argument_list|(
literal|" (ignored)\n"
argument_list|)
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
block|}
else|else
block|{
name|Fatal
argument_list|(
literal|"error in wait: %d: %s"
argument_list|,
name|retstat
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
block|}
name|free
argument_list|(
name|cmdStart
argument_list|)
expr_stmt|;
name|compatChild
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|compatSigno
condition|)
block|{
name|bmake_signal
argument_list|(
name|compatSigno
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|myPid
argument_list|,
name|compatSigno
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Compat_Make --  *	Make a target.  *  * Input:  *	gnp		The node to make  *	pgnp		Parent to abort if necessary  *  * Results:  *	0  *  * Side Effects:  *	If an error is detected and not being ignored, the process exits.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Compat_Make
parameter_list|(
name|void
modifier|*
name|gnp
parameter_list|,
name|void
modifier|*
name|pgnp
parameter_list|)
block|{
name|GNode
modifier|*
name|gn
init|=
operator|(
name|GNode
operator|*
operator|)
name|gnp
decl_stmt|;
name|GNode
modifier|*
name|pgn
init|=
operator|(
name|GNode
operator|*
operator|)
name|pgnp
decl_stmt|;
if|if
condition|(
operator|!
name|shellName
condition|)
comment|/* we came here from jobs */
name|Shell_Init
argument_list|()
expr_stmt|;
if|if
condition|(
name|gn
operator|->
name|made
operator|==
name|UNMADE
operator|&&
operator|(
name|gn
operator|==
name|pgn
operator|||
operator|(
name|pgn
operator|->
name|type
operator|&
name|OP_MADE
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 	 * First mark ourselves to be made, then apply whatever transformations 	 * the suffix module thinks are necessary. Once that's done, we can 	 * descend and make all our children. If any of them has an error 	 * but the -k flag was given, our 'make' field will be set FALSE again. 	 * This is our signal to not attempt to do anything but abort our 	 * parent as well. 	 */
name|gn
operator|->
name|flags
operator||=
name|REMAKE
expr_stmt|;
name|gn
operator|->
name|made
operator|=
name|BEINGMADE
expr_stmt|;
if|if
condition|(
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_MADE
operator|)
operator|==
literal|0
condition|)
name|Suff_FindDeps
argument_list|(
name|gn
argument_list|)
expr_stmt|;
name|Lst_ForEach
argument_list|(
name|gn
operator|->
name|children
argument_list|,
name|Compat_Make
argument_list|,
name|gn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gn
operator|->
name|flags
operator|&
name|REMAKE
operator|)
operator|==
literal|0
condition|)
block|{
name|gn
operator|->
name|made
operator|=
name|ABORTED
expr_stmt|;
name|pgn
operator|->
name|flags
operator|&=
operator|~
name|REMAKE
expr_stmt|;
goto|goto
name|cohorts
goto|;
block|}
if|if
condition|(
name|Lst_Member
argument_list|(
name|gn
operator|->
name|iParents
argument_list|,
name|pgn
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|p1
decl_stmt|;
name|Var_Set
argument_list|(
name|IMPSRC
argument_list|,
name|Var_Value
argument_list|(
name|TARGET
argument_list|,
name|gn
argument_list|,
operator|&
name|p1
argument_list|)
argument_list|,
name|pgn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * All the children were made ok. Now cmgn->mtime contains the 	 * modification time of the newest child, we need to find out if we 	 * exist and when we were modified last. The criteria for datedness 	 * are defined by the Make_OODate function. 	 */
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"Examining %s..."
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|Make_OODate
argument_list|(
name|gn
argument_list|)
condition|)
block|{
name|gn
operator|->
name|made
operator|=
name|UPTODATE
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"up-to-date.\n"
argument_list|)
expr_stmt|;
block|}
goto|goto
name|cohorts
goto|;
block|}
elseif|else
if|if
condition|(
name|DEBUG
argument_list|(
name|MAKE
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"out-of-date.\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the user is just seeing if something is out-of-date, exit now 	 * to tell him/her "yes". 	 */
if|if
condition|(
name|queryFlag
condition|)
block|{
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We need to be re-made. We also have to make sure we've got a $? 	 * variable. To be nice, we also define the $> variable using 	 * Make_DoAllVar(). 	 */
name|Make_DoAllVar
argument_list|(
name|gn
argument_list|)
expr_stmt|;
comment|/* 	 * Alter our type to tell if errors should be ignored or things 	 * should not be printed so CompatRunCommand knows what to do. 	 */
if|if
condition|(
name|Targ_Ignore
argument_list|(
name|gn
argument_list|)
condition|)
block|{
name|gn
operator|->
name|type
operator||=
name|OP_IGNORE
expr_stmt|;
block|}
if|if
condition|(
name|Targ_Silent
argument_list|(
name|gn
argument_list|)
condition|)
block|{
name|gn
operator|->
name|type
operator||=
name|OP_SILENT
expr_stmt|;
block|}
if|if
condition|(
name|Job_CheckCommands
argument_list|(
name|gn
argument_list|,
name|Fatal
argument_list|)
condition|)
block|{
comment|/* 	     * Our commands are ok, but we still have to worry about the -t 	     * flag... 	     */
if|if
condition|(
operator|!
name|touchFlag
operator|||
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_MAKE
operator|)
condition|)
block|{
name|curTarg
operator|=
name|gn
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_META
if|if
condition|(
name|useMeta
operator|&&
operator|!
name|NoExecute
argument_list|(
name|gn
argument_list|)
condition|)
block|{
name|meta_job_start
argument_list|(
name|NULL
argument_list|,
name|gn
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|Lst_ForEach
argument_list|(
name|gn
operator|->
name|commands
argument_list|,
name|CompatRunCommand
argument_list|,
name|gn
argument_list|)
expr_stmt|;
name|curTarg
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|Job_Touch
argument_list|(
name|gn
argument_list|,
name|gn
operator|->
name|type
operator|&
name|OP_SILENT
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|gn
operator|->
name|made
operator|=
name|ERROR
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USE_META
if|if
condition|(
name|useMeta
operator|&&
operator|!
name|NoExecute
argument_list|(
name|gn
argument_list|)
condition|)
block|{
if|if
condition|(
name|meta_job_finish
argument_list|(
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
name|gn
operator|->
name|made
operator|=
name|ERROR
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|gn
operator|->
name|made
operator|!=
name|ERROR
condition|)
block|{
comment|/* 	     * If the node was made successfully, mark it so, update 	     * its modification time and timestamp all its parents. Note 	     * that for .ZEROTIME targets, the timestamping isn't done. 	     * This is to keep its state from affecting that of its parent. 	     */
name|gn
operator|->
name|made
operator|=
name|MADE
expr_stmt|;
name|pgn
operator|->
name|flags
operator||=
name|Make_Recheck
argument_list|(
name|gn
argument_list|)
operator|==
literal|0
condition|?
name|FORCE
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_EXEC
operator|)
condition|)
block|{
name|pgn
operator|->
name|flags
operator||=
name|CHILDMADE
expr_stmt|;
name|Make_TimeStamp
argument_list|(
name|pgn
argument_list|,
name|gn
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|keepgoing
condition|)
block|{
name|pgn
operator|->
name|flags
operator|&=
operator|~
name|REMAKE
expr_stmt|;
block|}
else|else
block|{
name|PrintOnError
argument_list|(
name|gn
argument_list|,
literal|"\nStop."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|gn
operator|->
name|made
operator|==
name|ERROR
condition|)
block|{
comment|/* 	 * Already had an error when making this beastie. Tell the parent 	 * to abort. 	 */
name|pgn
operator|->
name|flags
operator|&=
operator|~
name|REMAKE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Lst_Member
argument_list|(
name|gn
operator|->
name|iParents
argument_list|,
name|pgn
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|p1
decl_stmt|;
name|Var_Set
argument_list|(
name|IMPSRC
argument_list|,
name|Var_Value
argument_list|(
name|TARGET
argument_list|,
name|gn
argument_list|,
operator|&
name|p1
argument_list|)
argument_list|,
name|pgn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|gn
operator|->
name|made
condition|)
block|{
case|case
name|BEINGMADE
case|:
name|Error
argument_list|(
literal|"Graph cycles through %s"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
name|gn
operator|->
name|made
operator|=
name|ERROR
expr_stmt|;
name|pgn
operator|->
name|flags
operator|&=
operator|~
name|REMAKE
expr_stmt|;
break|break;
case|case
name|MADE
case|:
if|if
condition|(
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_EXEC
operator|)
operator|==
literal|0
condition|)
block|{
name|pgn
operator|->
name|flags
operator||=
name|CHILDMADE
expr_stmt|;
name|Make_TimeStamp
argument_list|(
name|pgn
argument_list|,
name|gn
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|UPTODATE
case|:
if|if
condition|(
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_EXEC
operator|)
operator|==
literal|0
condition|)
block|{
name|Make_TimeStamp
argument_list|(
name|pgn
argument_list|,
name|gn
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
name|cohorts
label|:
name|Lst_ForEach
argument_list|(
name|gn
operator|->
name|cohorts
argument_list|,
name|Compat_Make
argument_list|,
name|pgnp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Compat_Run --  *	Initialize this mode and start making.  *  * Input:  *	targs		List of target nodes to re-create  *  * Results:  *	None.  *  * Side Effects:  *	Guess what?  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Compat_Run
parameter_list|(
name|Lst
name|targs
parameter_list|)
block|{
name|GNode
modifier|*
name|gn
init|=
name|NULL
decl_stmt|;
comment|/* Current root target */
name|int
name|errors
decl_stmt|;
comment|/* Number of targets not remade due to errors */
if|if
condition|(
operator|!
name|shellName
condition|)
name|Shell_Init
argument_list|()
expr_stmt|;
if|if
condition|(
name|bmake_signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
block|{
name|bmake_signal
argument_list|(
name|SIGINT
argument_list|,
name|CompatInterrupt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bmake_signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
block|{
name|bmake_signal
argument_list|(
name|SIGTERM
argument_list|,
name|CompatInterrupt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bmake_signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
block|{
name|bmake_signal
argument_list|(
name|SIGHUP
argument_list|,
name|CompatInterrupt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bmake_signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
block|{
name|bmake_signal
argument_list|(
name|SIGQUIT
argument_list|,
name|CompatInterrupt
argument_list|)
expr_stmt|;
block|}
name|ENDNode
operator|=
name|Targ_FindNode
argument_list|(
literal|".END"
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
name|ENDNode
operator|->
name|type
operator|=
name|OP_SPECIAL
expr_stmt|;
comment|/*      * If the user has defined a .BEGIN target, execute the commands attached      * to it.      */
if|if
condition|(
operator|!
name|queryFlag
condition|)
block|{
name|gn
operator|=
name|Targ_FindNode
argument_list|(
literal|".BEGIN"
argument_list|,
name|TARG_NOCREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|!=
name|NULL
condition|)
block|{
name|Compat_Make
argument_list|(
name|gn
argument_list|,
name|gn
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|->
name|made
operator|==
name|ERROR
condition|)
block|{
name|PrintOnError
argument_list|(
name|gn
argument_list|,
literal|"\nStop."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*      * Expand .USE nodes right now, because they can modify the structure      * of the tree.      */
name|Make_ExpandUse
argument_list|(
name|targs
argument_list|)
expr_stmt|;
comment|/*      * For each entry in the list of targets to create, call Compat_Make on      * it to create the thing. Compat_Make will leave the 'made' field of gn      * in one of several states:      *	    UPTODATE	    gn was already up-to-date      *	    MADE  	    gn was recreated successfully      *	    ERROR 	    An error occurred while gn was being created      *	    ABORTED	    gn was not remade because one of its inferiors      *	    	  	    could not be made due to errors.      */
name|errors
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|targs
argument_list|)
condition|)
block|{
name|gn
operator|=
operator|(
name|GNode
operator|*
operator|)
name|Lst_DeQueue
argument_list|(
name|targs
argument_list|)
expr_stmt|;
name|Compat_Make
argument_list|(
name|gn
argument_list|,
name|gn
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|->
name|made
operator|==
name|UPTODATE
condition|)
block|{
name|printf
argument_list|(
literal|"`%s' is up to date.\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gn
operator|->
name|made
operator|==
name|ABORTED
condition|)
block|{
name|printf
argument_list|(
literal|"`%s' not remade because of errors.\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
name|errors
operator|+=
literal|1
expr_stmt|;
block|}
block|}
comment|/*      * If the user has defined a .END target, run its commands.      */
if|if
condition|(
name|errors
operator|==
literal|0
condition|)
block|{
name|Compat_Make
argument_list|(
name|ENDNode
argument_list|,
name|ENDNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|->
name|made
operator|==
name|ERROR
condition|)
block|{
name|PrintOnError
argument_list|(
name|gn
argument_list|,
literal|"\nStop."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

