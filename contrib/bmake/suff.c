begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: suff.c,v 1.75 2015/12/20 22:44:10 sjg Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 1988, 1989, 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Adam de Boor.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1989 by Berkeley Softworks  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Adam de Boor.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAKE_NATIVE
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$NetBSD: suff.c,v 1.75 2015/12/20 22:44:10 sjg Exp $"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_else
unit|static char sccsid[] = "@(#)suff.c	8.4 (Berkeley) 3/21/94";
else|#
directive|else
end_else

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$NetBSD: suff.c,v 1.75 2015/12/20 22:44:10 sjg Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*-  * suff.c --  *	Functions to maintain suffix lists and find implicit dependents  *	using suffix transformation rules  *  * Interface:  *	Suff_Init 	    	Initialize all things to do with suffixes.  *  *	Suff_End 	    	Cleanup the module  *  *	Suff_DoPaths	    	This function is used to make life easier  *	    	  	    	when searching for a file according to its  *	    	  	    	suffix. It takes the global search path,  *	    	  	    	as defined using the .PATH: target, and appends  *	    	  	    	its directories to the path of each of the  *	    	  	    	defined suffixes, as specified using  *	    	  	    	.PATH<suffix>: targets. In addition, all  *	    	  	    	directories given for suffixes labeled as  *	    	  	    	include files or libraries, using the .INCLUDES  *	    	  	    	or .LIBS targets, are played with using  *	    	  	    	Dir_MakeFlags to create the .INCLUDES and  *	    	  	    	.LIBS global variables.  *  *	Suff_ClearSuffixes  	Clear out all the suffixes and defined  *	    	  	    	transformations.  *  *	Suff_IsTransform    	Return TRUE if the passed string is the lhs  *	    	  	    	of a transformation rule.  *  *	Suff_AddSuffix	    	Add the passed string as another known suffix.  *  *	Suff_GetPath	    	Return the search path for the given suffix.  *  *	Suff_AddInclude	    	Mark the given suffix as denoting an include  *	    	  	    	file.  *  *	Suff_AddLib	    	Mark the given suffix as denoting a library.  *  *	Suff_AddTransform   	Add another transformation to the suffix  *	    	  	    	graph. Returns  GNode suitable for framing, I  *	    	  	    	mean, tacking commands, attributes, etc. on.  *  *	Suff_SetNull	    	Define the suffix to consider the suffix of  *	    	  	    	any file that doesn't have a known one.  *  *	Suff_FindDeps	    	Find implicit sources for and the location of  *	    	  	    	a target based on its suffix. Returns the  *	    	  	    	bottom-most node added to the graph or NULL  *	    	  	    	if the target had no implicit sources.  *  *	Suff_FindPath	    	Return the appropriate path to search in  *				order to find the node.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"make.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_decl_stmt
specifier|static
name|Lst
name|sufflist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lst of suffixes */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CLEANUP
end_ifdef

begin_decl_stmt
specifier|static
name|Lst
name|suffClean
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lst of suffixes to be cleaned */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|Lst
name|srclist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lst of sources */
end_comment

begin_decl_stmt
specifier|static
name|Lst
name|transforms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lst of transformation rules */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sNum
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Counter for assigning suffix numbers */
end_comment

begin_comment
comment|/*  * Structure describing an individual suffix.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_Suff
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The suffix itself */
name|int
name|nameLen
decl_stmt|;
comment|/* Length of the suffix */
name|short
name|flags
decl_stmt|;
comment|/* Type of suffix */
define|#
directive|define
name|SUFF_INCLUDE
value|0x01
comment|/* One which is #include'd */
define|#
directive|define
name|SUFF_LIBRARY
value|0x02
comment|/* One which contains a library */
define|#
directive|define
name|SUFF_NULL
value|0x04
comment|/* The empty suffix */
name|Lst
name|searchPath
decl_stmt|;
comment|/* The path along which files of this suffix 				 * may be found */
name|int
name|sNum
decl_stmt|;
comment|/* The suffix number */
name|int
name|refCount
decl_stmt|;
comment|/* Reference count of list membership */
name|Lst
name|parents
decl_stmt|;
comment|/* Suffixes we have a transformation to */
name|Lst
name|children
decl_stmt|;
comment|/* Suffixes we have a transformation from */
name|Lst
name|ref
decl_stmt|;
comment|/* List of lists this suffix is referenced */
block|}
name|Suff
typedef|;
end_typedef

begin_comment
comment|/*  * for SuffSuffIsSuffix  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|ename
decl_stmt|;
comment|/* The end of the name */
name|int
name|len
decl_stmt|;
comment|/* Length of the name */
block|}
name|SuffixCmpData
typedef|;
end_typedef

begin_comment
comment|/*  * Structure used in the search for implied sources.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_Src
block|{
name|char
modifier|*
name|file
decl_stmt|;
comment|/* The file to look for */
name|char
modifier|*
name|pref
decl_stmt|;
comment|/* Prefix from which file was formed */
name|Suff
modifier|*
name|suff
decl_stmt|;
comment|/* The suffix on the file */
name|struct
name|_Src
modifier|*
name|parent
decl_stmt|;
comment|/* The Src for which this is a source */
name|GNode
modifier|*
name|node
decl_stmt|;
comment|/* The node describing the file */
name|int
name|children
decl_stmt|;
comment|/* Count of existing children (so we don't free 				 * this thing too early or never nuke it) */
ifdef|#
directive|ifdef
name|DEBUG_SRC
name|Lst
name|cp
decl_stmt|;
comment|/* Debug; children list */
endif|#
directive|endif
block|}
name|Src
typedef|;
end_typedef

begin_comment
comment|/*  * A structure for passing more than one argument to the Lst-library-invoked  * function...  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|Lst
name|l
decl_stmt|;
name|Src
modifier|*
name|s
decl_stmt|;
block|}
name|LstSrc
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|GNode
modifier|*
modifier|*
name|gn
decl_stmt|;
name|Suff
modifier|*
name|s
decl_stmt|;
name|Boolean
name|r
decl_stmt|;
block|}
name|GNodeSuff
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|Suff
modifier|*
name|suffNull
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The NULL suffix for this run */
end_comment

begin_decl_stmt
specifier|static
name|Suff
modifier|*
name|emptySuff
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The empty suffix required for POSIX 				 * single-suffix transformation rules */
end_comment

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|SuffStrIsPrefix
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|SuffSuffIsSuffix
parameter_list|(
specifier|const
name|Suff
modifier|*
parameter_list|,
specifier|const
name|SuffixCmpData
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|SuffSuffIsSuffixP
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|SuffSuffHasNameP
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|SuffSuffIsPrefix
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|SuffGNHasNameP
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|SuffUnRef
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|SuffFree
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|SuffInsert
parameter_list|(
name|Lst
parameter_list|,
name|Suff
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|SuffRemove
parameter_list|(
name|Lst
parameter_list|,
name|Suff
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Boolean
name|SuffParseTransform
parameter_list|(
name|char
modifier|*
parameter_list|,
name|Suff
modifier|*
modifier|*
parameter_list|,
name|Suff
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|SuffRebuildGraph
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|SuffScanTargets
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|SuffAddSrc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|SuffRemoveSrc
parameter_list|(
name|Lst
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|SuffAddLevel
parameter_list|(
name|Lst
parameter_list|,
name|Src
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Src
modifier|*
name|SuffFindThem
parameter_list|(
name|Lst
parameter_list|,
name|Lst
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Src
modifier|*
name|SuffFindCmds
parameter_list|(
name|Src
modifier|*
parameter_list|,
name|Lst
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|SuffExpandChildren
parameter_list|(
name|LstNode
parameter_list|,
name|GNode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|SuffExpandWildcards
parameter_list|(
name|LstNode
parameter_list|,
name|GNode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Boolean
name|SuffApplyTransform
parameter_list|(
name|GNode
modifier|*
parameter_list|,
name|GNode
modifier|*
parameter_list|,
name|Suff
modifier|*
parameter_list|,
name|Suff
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|SuffFindDeps
parameter_list|(
name|GNode
modifier|*
parameter_list|,
name|Lst
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|SuffFindArchiveDeps
parameter_list|(
name|GNode
modifier|*
parameter_list|,
name|Lst
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|SuffFindNormalDeps
parameter_list|(
name|GNode
modifier|*
parameter_list|,
name|Lst
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|SuffPrintName
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|SuffPrintSuff
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|SuffPrintTrans
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*************** Lst Predicates ****************/
end_comment

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffStrIsPrefix  --  *	See if pref is a prefix of str.  *  * Input:  *	pref		possible prefix  *	str		string to check  *  * Results:  *	NULL if it ain't, pointer to character in str after prefix if so  *  * Side Effects:  *	None  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|SuffStrIsPrefix
parameter_list|(
specifier|const
name|char
modifier|*
name|pref
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
while|while
condition|(
operator|*
name|str
operator|&&
operator|*
name|pref
operator|==
operator|*
name|str
condition|)
block|{
name|pref
operator|++
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
return|return
operator|(
operator|*
name|pref
condition|?
name|NULL
else|:
name|str
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffSuffIsSuffix  --  *	See if suff is a suffix of str. sd->ename should point to THE END  *	of the string to check. (THE END == the null byte)  *  * Input:  *	s		possible suffix  *	sd		string to examine  *  * Results:  *	NULL if it ain't, pointer to character in str before suffix if  *	it is.  *  * Side Effects:  *	None  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|SuffSuffIsSuffix
parameter_list|(
specifier|const
name|Suff
modifier|*
name|s
parameter_list|,
specifier|const
name|SuffixCmpData
modifier|*
name|sd
parameter_list|)
block|{
name|char
modifier|*
name|p1
decl_stmt|;
comment|/* Pointer into suffix name */
name|char
modifier|*
name|p2
decl_stmt|;
comment|/* Pointer into string being examined */
if|if
condition|(
name|sd
operator|->
name|len
operator|<
name|s
operator|->
name|nameLen
condition|)
return|return
name|NULL
return|;
comment|/* this string is shorter than the suffix */
name|p1
operator|=
name|s
operator|->
name|name
operator|+
name|s
operator|->
name|nameLen
expr_stmt|;
name|p2
operator|=
name|sd
operator|->
name|ename
expr_stmt|;
while|while
condition|(
name|p1
operator|>=
name|s
operator|->
name|name
operator|&&
operator|*
name|p1
operator|==
operator|*
name|p2
condition|)
block|{
name|p1
operator|--
expr_stmt|;
name|p2
operator|--
expr_stmt|;
block|}
return|return
operator|(
name|p1
operator|==
name|s
operator|->
name|name
operator|-
literal|1
condition|?
name|p2
else|:
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffSuffIsSuffixP --  *	Predicate form of SuffSuffIsSuffix. Passed as the callback function  *	to Lst_Find.  *  * Results:  *	0 if the suffix is the one desired, non-zero if not.  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SuffSuffIsSuffixP
parameter_list|(
specifier|const
name|void
modifier|*
name|s
parameter_list|,
specifier|const
name|void
modifier|*
name|sd
parameter_list|)
block|{
return|return
operator|(
operator|!
name|SuffSuffIsSuffix
argument_list|(
name|s
argument_list|,
name|sd
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffSuffHasNameP --  *	Callback procedure for finding a suffix based on its name. Used by  *	Suff_GetPath.  *  * Input:  *	s		Suffix to check  *	sd		Desired name  *  * Results:  *	0 if the suffix is of the given name. non-zero otherwise.  *  * Side Effects:  *	None  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SuffSuffHasNameP
parameter_list|(
specifier|const
name|void
modifier|*
name|s
parameter_list|,
specifier|const
name|void
modifier|*
name|sname
parameter_list|)
block|{
return|return
operator|(
name|strcmp
argument_list|(
name|sname
argument_list|,
operator|(
operator|(
specifier|const
name|Suff
operator|*
operator|)
name|s
operator|)
operator|->
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffSuffIsPrefix  --  *	See if the suffix described by s is a prefix of the string. Care  *	must be taken when using this to search for transformations and  *	what-not, since there could well be two suffixes, one of which  *	is a prefix of the other...  *  * Input:  *	s		suffix to compare  *	str		string to examine  *  * Results:  *	0 if s is a prefix of str. non-zero otherwise  *  * Side Effects:  *	None  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SuffSuffIsPrefix
parameter_list|(
specifier|const
name|void
modifier|*
name|s
parameter_list|,
specifier|const
name|void
modifier|*
name|str
parameter_list|)
block|{
return|return
name|SuffStrIsPrefix
argument_list|(
operator|(
operator|(
specifier|const
name|Suff
operator|*
operator|)
name|s
operator|)
operator|->
name|name
argument_list|,
name|str
argument_list|)
operator|==
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffGNHasNameP  --  *	See if the graph node has the desired name  *  * Input:  *	gn		current node we're looking at  *	name		name we're looking for  *  * Results:  *	0 if it does. non-zero if it doesn't  *  * Side Effects:  *	None  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SuffGNHasNameP
parameter_list|(
specifier|const
name|void
modifier|*
name|gn
parameter_list|,
specifier|const
name|void
modifier|*
name|name
parameter_list|)
block|{
return|return
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
operator|(
operator|(
specifier|const
name|GNode
operator|*
operator|)
name|gn
operator|)
operator|->
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********** Maintenance Functions ************/
end_comment

begin_function
specifier|static
name|void
name|SuffUnRef
parameter_list|(
name|void
modifier|*
name|lp
parameter_list|,
name|void
modifier|*
name|sp
parameter_list|)
block|{
name|Lst
name|l
init|=
operator|(
name|Lst
operator|)
name|lp
decl_stmt|;
name|LstNode
name|ln
init|=
name|Lst_Member
argument_list|(
name|l
argument_list|,
name|sp
argument_list|)
decl_stmt|;
if|if
condition|(
name|ln
operator|!=
name|NULL
condition|)
block|{
name|Lst_Remove
argument_list|(
name|l
argument_list|,
name|ln
argument_list|)
expr_stmt|;
operator|(
operator|(
name|Suff
operator|*
operator|)
name|sp
operator|)
operator|->
name|refCount
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffFree  --  *	Free up all memory associated with the given suffix structure.  *  * Results:  *	none  *  * Side Effects:  *	the suffix entry is detroyed  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|SuffFree
parameter_list|(
name|void
modifier|*
name|sp
parameter_list|)
block|{
name|Suff
modifier|*
name|s
init|=
operator|(
name|Suff
operator|*
operator|)
name|sp
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|suffNull
condition|)
name|suffNull
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|emptySuff
condition|)
name|emptySuff
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
comment|/* We don't delete suffixes in order, so we cannot use this */
if|if
condition|(
name|s
operator|->
name|refCount
condition|)
name|Punt
argument_list|(
literal|"Internal error deleting suffix `%s' with refcount = %d"
argument_list|,
name|s
operator|->
name|name
argument_list|,
name|s
operator|->
name|refCount
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Lst_Destroy
argument_list|(
name|s
operator|->
name|ref
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|Lst_Destroy
argument_list|(
name|s
operator|->
name|children
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|Lst_Destroy
argument_list|(
name|s
operator|->
name|parents
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|Lst_Destroy
argument_list|(
name|s
operator|->
name|searchPath
argument_list|,
name|Dir_Destroy
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffRemove  --  *	Remove the suffix into the list  *  * Results:  *	None  *  * Side Effects:  *	The reference count for the suffix is decremented and the  *	suffix is possibly freed  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|SuffRemove
parameter_list|(
name|Lst
name|l
parameter_list|,
name|Suff
modifier|*
name|s
parameter_list|)
block|{
name|SuffUnRef
argument_list|(
name|l
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|refCount
operator|==
literal|0
condition|)
block|{
name|SuffUnRef
argument_list|(
name|sufflist
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|SuffFree
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffInsert  --  *	Insert the suffix into the list keeping the list ordered by suffix  *	numbers.  *  * Input:  *	l		the list where in s should be inserted  *	s		the suffix to insert  *  * Results:  *	None  *  * Side Effects:  *	The reference count of the suffix is incremented  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|SuffInsert
parameter_list|(
name|Lst
name|l
parameter_list|,
name|Suff
modifier|*
name|s
parameter_list|)
block|{
name|LstNode
name|ln
decl_stmt|;
comment|/* current element in l we're examining */
name|Suff
modifier|*
name|s2
init|=
name|NULL
decl_stmt|;
comment|/* the suffix descriptor in this element */
if|if
condition|(
name|Lst_Open
argument_list|(
name|l
argument_list|)
operator|==
name|FAILURE
condition|)
block|{
return|return;
block|}
while|while
condition|(
operator|(
name|ln
operator|=
name|Lst_Next
argument_list|(
name|l
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|s2
operator|=
operator|(
name|Suff
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|s2
operator|->
name|sNum
operator|>=
name|s
operator|->
name|sNum
condition|)
block|{
break|break;
block|}
block|}
name|Lst_Close
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"inserting %s(%d)..."
argument_list|,
name|s
operator|->
name|name
argument_list|,
name|s
operator|->
name|sNum
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ln
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"at end of list\n"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|l
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|->
name|refCount
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|s
operator|->
name|ref
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s2
operator|->
name|sNum
operator|!=
name|s
operator|->
name|sNum
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"before %s(%d)\n"
argument_list|,
name|s2
operator|->
name|name
argument_list|,
name|s2
operator|->
name|sNum
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|Lst_InsertBefore
argument_list|(
name|l
argument_list|,
name|ln
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|->
name|refCount
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|s
operator|->
name|ref
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"already there\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Suff_ClearSuffixes --  *	This is gross. Nuke the list of suffixes but keep all transformation  *	rules around. The transformation graph is destroyed in this process,  *	but we leave the list of rules so when a new graph is formed the rules  *	will remain.  *	This function is called from the parse module when a  *	.SUFFIXES:\n line is encountered.  *  * Results:  *	none  *  * Side Effects:  *	the sufflist and its graph nodes are destroyed  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Suff_ClearSuffixes
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CLEANUP
name|Lst_Concat
argument_list|(
name|suffClean
argument_list|,
name|sufflist
argument_list|,
name|LST_CONCLINK
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sufflist
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|sNum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|suffNull
condition|)
name|SuffFree
argument_list|(
name|suffNull
argument_list|)
expr_stmt|;
name|emptySuff
operator|=
name|suffNull
operator|=
name|bmake_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Suff
argument_list|)
argument_list|)
expr_stmt|;
name|suffNull
operator|->
name|name
operator|=
name|bmake_strdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|suffNull
operator|->
name|nameLen
operator|=
literal|0
expr_stmt|;
name|suffNull
operator|->
name|searchPath
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|Dir_Concat
argument_list|(
name|suffNull
operator|->
name|searchPath
argument_list|,
name|dirSearchPath
argument_list|)
expr_stmt|;
name|suffNull
operator|->
name|children
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|suffNull
operator|->
name|parents
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|suffNull
operator|->
name|ref
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|suffNull
operator|->
name|sNum
operator|=
name|sNum
operator|++
expr_stmt|;
name|suffNull
operator|->
name|flags
operator|=
name|SUFF_NULL
expr_stmt|;
name|suffNull
operator|->
name|refCount
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffParseTransform --  *	Parse a transformation string to find its two component suffixes.  *  * Input:  *	str		String being parsed  *	srcPtr		Place to store source of trans.  *	targPtr		Place to store target of trans.  *  * Results:  *	TRUE if the string is a valid transformation and FALSE otherwise.  *  * Side Effects:  *	The passed pointers are overwritten.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Boolean
name|SuffParseTransform
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|Suff
modifier|*
modifier|*
name|srcPtr
parameter_list|,
name|Suff
modifier|*
modifier|*
name|targPtr
parameter_list|)
block|{
name|LstNode
name|srcLn
decl_stmt|;
comment|/* element in suffix list of trans source*/
name|Suff
modifier|*
name|src
decl_stmt|;
comment|/* Source of transformation */
name|LstNode
name|targLn
decl_stmt|;
comment|/* element in suffix list of trans target*/
name|char
modifier|*
name|str2
decl_stmt|;
comment|/* Extra pointer (maybe target suffix) */
name|LstNode
name|singleLn
decl_stmt|;
comment|/* element in suffix list of any suffix 				     * that exactly matches str */
name|Suff
modifier|*
name|single
init|=
name|NULL
decl_stmt|;
comment|/* Source of possible transformation to 				     * null suffix */
name|srcLn
operator|=
name|NULL
expr_stmt|;
name|singleLn
operator|=
name|NULL
expr_stmt|;
comment|/*      * Loop looking first for a suffix that matches the start of the      * string and then for one that exactly matches the rest of it. If      * we can find two that meet these criteria, we've successfully      * parsed the string.      */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|srcLn
operator|==
name|NULL
condition|)
block|{
name|srcLn
operator|=
name|Lst_Find
argument_list|(
name|sufflist
argument_list|,
name|str
argument_list|,
name|SuffSuffIsPrefix
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|srcLn
operator|=
name|Lst_FindFrom
argument_list|(
name|sufflist
argument_list|,
name|Lst_Succ
argument_list|(
name|srcLn
argument_list|)
argument_list|,
name|str
argument_list|,
name|SuffSuffIsPrefix
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|srcLn
operator|==
name|NULL
condition|)
block|{
comment|/* 	     * Ran out of source suffixes -- no such rule 	     */
if|if
condition|(
name|singleLn
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Not so fast Mr. Smith! There was a suffix that encompassed 		 * the entire string, so we assume it was a transformation 		 * to the null suffix (thank you POSIX). We still prefer to 		 * find a double rule over a singleton, hence we leave this 		 * check until the end. 		 * 		 * XXX: Use emptySuff over suffNull? 		 */
operator|*
name|srcPtr
operator|=
name|single
expr_stmt|;
operator|*
name|targPtr
operator|=
name|suffNull
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|src
operator|=
operator|(
name|Suff
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|srcLn
argument_list|)
expr_stmt|;
name|str2
operator|=
name|str
operator|+
name|src
operator|->
name|nameLen
expr_stmt|;
if|if
condition|(
operator|*
name|str2
operator|==
literal|'\0'
condition|)
block|{
name|single
operator|=
name|src
expr_stmt|;
name|singleLn
operator|=
name|srcLn
expr_stmt|;
block|}
else|else
block|{
name|targLn
operator|=
name|Lst_Find
argument_list|(
name|sufflist
argument_list|,
name|str2
argument_list|,
name|SuffSuffHasNameP
argument_list|)
expr_stmt|;
if|if
condition|(
name|targLn
operator|!=
name|NULL
condition|)
block|{
operator|*
name|srcPtr
operator|=
name|src
expr_stmt|;
operator|*
name|targPtr
operator|=
operator|(
name|Suff
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|targLn
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Suff_IsTransform  --  *	Return TRUE if the given string is a transformation rule  *  *  * Input:  *	str		string to check  *  * Results:  *	TRUE if the string is a concatenation of two known suffixes.  *	FALSE otherwise  *  * Side Effects:  *	None  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|Boolean
name|Suff_IsTransform
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|Suff
modifier|*
name|src
decl_stmt|,
modifier|*
name|targ
decl_stmt|;
return|return
operator|(
name|SuffParseTransform
argument_list|(
name|str
argument_list|,
operator|&
name|src
argument_list|,
operator|&
name|targ
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Suff_AddTransform --  *	Add the transformation rule described by the line to the  *	list of rules and place the transformation itself in the graph  *  * Input:  *	line		name of transformation to add  *  * Results:  *	The node created for the transformation in the transforms list  *  * Side Effects:  *	The node is placed on the end of the transforms Lst and links are  *	made between the two suffixes mentioned in the target name  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|GNode
modifier|*
name|Suff_AddTransform
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
name|GNode
modifier|*
name|gn
decl_stmt|;
comment|/* GNode of transformation rule */
name|Suff
modifier|*
name|s
decl_stmt|,
comment|/* source suffix */
modifier|*
name|t
decl_stmt|;
comment|/* target suffix */
name|LstNode
name|ln
decl_stmt|;
comment|/* Node for existing transformation */
name|ln
operator|=
name|Lst_Find
argument_list|(
name|transforms
argument_list|,
name|line
argument_list|,
name|SuffGNHasNameP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|==
name|NULL
condition|)
block|{
comment|/* 	 * Make a new graph node for the transformation. It will be filled in 	 * by the Parse module. 	 */
name|gn
operator|=
name|Targ_NewGN
argument_list|(
name|line
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|transforms
argument_list|,
name|gn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * New specification for transformation rule. Just nuke the old list 	 * of commands so they can be filled in again... We don't actually 	 * free the commands themselves, because a given command can be 	 * attached to several different transformations. 	 */
name|gn
operator|=
operator|(
name|GNode
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|Lst_Destroy
argument_list|(
name|gn
operator|->
name|commands
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|Lst_Destroy
argument_list|(
name|gn
operator|->
name|children
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gn
operator|->
name|commands
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|gn
operator|->
name|children
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|gn
operator|->
name|type
operator|=
name|OP_TRANSFORM
expr_stmt|;
operator|(
name|void
operator|)
name|SuffParseTransform
argument_list|(
name|line
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
comment|/*      * link the two together in the proper relationship and order      */
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"defining transformation from `%s' to `%s'\n"
argument_list|,
name|s
operator|->
name|name
argument_list|,
name|t
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|SuffInsert
argument_list|(
name|t
operator|->
name|children
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|SuffInsert
argument_list|(
name|s
operator|->
name|parents
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|gn
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Suff_EndTransform --  *	Handle the finish of a transformation definition, removing the  *	transformation from the graph if it has neither commands nor  *	sources. This is a callback procedure for the Parse module via  *	Lst_ForEach  *  * Input:  *	gnp		Node for transformation  *	dummy		Node for transformation  *  * Results:  *	=== 0  *  * Side Effects:  *	If the node has no commands or children, the children and parents  *	lists of the affected suffixes are altered.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Suff_EndTransform
parameter_list|(
name|void
modifier|*
name|gnp
parameter_list|,
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|GNode
modifier|*
name|gn
init|=
operator|(
name|GNode
operator|*
operator|)
name|gnp
decl_stmt|;
if|if
condition|(
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_DOUBLEDEP
operator|)
operator|&&
operator|!
name|Lst_IsEmpty
argument_list|(
name|gn
operator|->
name|cohorts
argument_list|)
condition|)
name|gn
operator|=
operator|(
name|GNode
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|Lst_Last
argument_list|(
name|gn
operator|->
name|cohorts
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_TRANSFORM
operator|)
operator|&&
name|Lst_IsEmpty
argument_list|(
name|gn
operator|->
name|commands
argument_list|)
operator|&&
name|Lst_IsEmpty
argument_list|(
name|gn
operator|->
name|children
argument_list|)
condition|)
block|{
name|Suff
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
comment|/* 	 * SuffParseTransform() may fail for special rules which are not 	 * actual transformation rules. (e.g. .DEFAULT) 	 */
if|if
condition|(
name|SuffParseTransform
argument_list|(
name|gn
operator|->
name|name
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|t
argument_list|)
condition|)
block|{
name|Lst
name|p
decl_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"deleting transformation from `%s' to `%s'\n"
argument_list|,
name|s
operator|->
name|name
argument_list|,
name|t
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* 	     * Store s->parents because s could be deleted in SuffRemove 	     */
name|p
operator|=
name|s
operator|->
name|parents
expr_stmt|;
comment|/* 	     * Remove the source from the target's children list. We check for a 	     * nil return to handle a beanhead saying something like 	     *  .c.o .c.o: 	     * 	     * We'll be called twice when the next target is seen, but .c and .o 	     * are only linked once... 	     */
name|SuffRemove
argument_list|(
name|t
operator|->
name|children
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* 	     * Remove the target from the source's parents list 	     */
name|SuffRemove
argument_list|(
name|p
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_TRANSFORM
operator|)
operator|&&
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"transformation %s complete\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|dummy
condition|?
literal|0
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffRebuildGraph --  *	Called from Suff_AddSuffix via Lst_ForEach to search through the  *	list of existing transformation rules and rebuild the transformation  *	graph when it has been destroyed by Suff_ClearSuffixes. If the  *	given rule is a transformation involving this suffix and another,  *	existing suffix, the proper relationship is established between  *	the two.  *  * Input:  *	transformp	Transformation to test  *	sp		Suffix to rebuild  *  * Results:  *	Always 0.  *  * Side Effects:  *	The appropriate links will be made between this suffix and  *	others if transformation rules exist for it.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SuffRebuildGraph
parameter_list|(
name|void
modifier|*
name|transformp
parameter_list|,
name|void
modifier|*
name|sp
parameter_list|)
block|{
name|GNode
modifier|*
name|transform
init|=
operator|(
name|GNode
operator|*
operator|)
name|transformp
decl_stmt|;
name|Suff
modifier|*
name|s
init|=
operator|(
name|Suff
operator|*
operator|)
name|sp
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|LstNode
name|ln
decl_stmt|;
name|Suff
modifier|*
name|s2
decl_stmt|;
name|SuffixCmpData
name|sd
decl_stmt|;
comment|/*      * First see if it is a transformation from this suffix.      */
name|cp
operator|=
name|UNCONST
argument_list|(
name|SuffStrIsPrefix
argument_list|(
name|s
operator|->
name|name
argument_list|,
name|transform
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|ln
operator|=
name|Lst_Find
argument_list|(
name|sufflist
argument_list|,
name|cp
argument_list|,
name|SuffSuffHasNameP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|!=
name|NULL
condition|)
block|{
comment|/* 	     * Found target. Link in and return, since it can't be anything 	     * else. 	     */
name|s2
operator|=
operator|(
name|Suff
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|SuffInsert
argument_list|(
name|s2
operator|->
name|children
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|SuffInsert
argument_list|(
name|s
operator|->
name|parents
argument_list|,
name|s2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/*      * Not from, maybe to?      */
name|sd
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|transform
operator|->
name|name
argument_list|)
expr_stmt|;
name|sd
operator|.
name|ename
operator|=
name|transform
operator|->
name|name
operator|+
name|sd
operator|.
name|len
expr_stmt|;
name|cp
operator|=
name|SuffSuffIsSuffix
argument_list|(
name|s
argument_list|,
operator|&
name|sd
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
comment|/* 	 * Null-terminate the source suffix in order to find it. 	 */
name|cp
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ln
operator|=
name|Lst_Find
argument_list|(
name|sufflist
argument_list|,
name|transform
operator|->
name|name
argument_list|,
name|SuffSuffHasNameP
argument_list|)
expr_stmt|;
comment|/* 	 * Replace the start of the target suffix 	 */
name|cp
index|[
literal|1
index|]
operator|=
name|s
operator|->
name|name
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|ln
operator|!=
name|NULL
condition|)
block|{
comment|/* 	     * Found it -- establish the proper relationship 	     */
name|s2
operator|=
operator|(
name|Suff
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|SuffInsert
argument_list|(
name|s
operator|->
name|children
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|SuffInsert
argument_list|(
name|s2
operator|->
name|parents
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffScanTargets --  *	Called from Suff_AddSuffix via Lst_ForEach to search through the  *	list of existing targets and find if any of the existing targets  *	can be turned into a transformation rule.  *  * Results:  *	1 if a new main target has been selected, 0 otherwise.  *  * Side Effects:  *	If such a target is found and the target is the current main  *	target, the main target is set to NULL and the next target  *	examined (if that exists) becomes the main target.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SuffScanTargets
parameter_list|(
name|void
modifier|*
name|targetp
parameter_list|,
name|void
modifier|*
name|gsp
parameter_list|)
block|{
name|GNode
modifier|*
name|target
init|=
operator|(
name|GNode
operator|*
operator|)
name|targetp
decl_stmt|;
name|GNodeSuff
modifier|*
name|gs
init|=
operator|(
name|GNodeSuff
operator|*
operator|)
name|gsp
decl_stmt|;
name|Suff
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
operator|*
name|gs
operator|->
name|gn
operator|==
name|NULL
operator|&&
name|gs
operator|->
name|r
operator|&&
operator|(
name|target
operator|->
name|type
operator|&
name|OP_NOTARGET
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|gs
operator|->
name|gn
operator|=
name|target
expr_stmt|;
name|Targ_SetMain
argument_list|(
name|target
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|unsigned
name|int
operator|)
name|target
operator|->
name|type
operator|==
name|OP_TRANSFORM
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|ptr
operator|=
name|strstr
argument_list|(
name|target
operator|->
name|name
argument_list|,
name|gs
operator|->
name|s
operator|->
name|name
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|ptr
operator|==
name|target
operator|->
name|name
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|SuffParseTransform
argument_list|(
name|target
operator|->
name|name
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|gs
operator|->
name|gn
operator|==
name|target
condition|)
block|{
name|gs
operator|->
name|r
operator|=
name|TRUE
expr_stmt|;
operator|*
name|gs
operator|->
name|gn
operator|=
name|NULL
expr_stmt|;
name|Targ_SetMain
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
name|Lst_Destroy
argument_list|(
name|target
operator|->
name|children
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|target
operator|->
name|children
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|target
operator|->
name|type
operator|=
name|OP_TRANSFORM
expr_stmt|;
comment|/* 	 * link the two together in the proper relationship and order 	 */
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"defining transformation from `%s' to `%s'\n"
argument_list|,
name|s
operator|->
name|name
argument_list|,
name|t
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|SuffInsert
argument_list|(
name|t
operator|->
name|children
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|SuffInsert
argument_list|(
name|s
operator|->
name|parents
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Suff_AddSuffix --  *	Add the suffix in string to the end of the list of known suffixes.  *	Should we restructure the suffix graph? Make doesn't...  *  * Input:  *	str		the name of the suffix to add  *  * Results:  *	None  *  * Side Effects:  *	A GNode is created for the suffix and a Suff structure is created and  *	added to the suffixes list unless the suffix was already known.  *	The mainNode passed can be modified if a target mutated into a  *	transform and that target happened to be the main target.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Suff_AddSuffix
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|GNode
modifier|*
modifier|*
name|gn
parameter_list|)
block|{
name|Suff
modifier|*
name|s
decl_stmt|;
comment|/* new suffix descriptor */
name|LstNode
name|ln
decl_stmt|;
name|GNodeSuff
name|gs
decl_stmt|;
name|ln
operator|=
name|Lst_Find
argument_list|(
name|sufflist
argument_list|,
name|str
argument_list|,
name|SuffSuffHasNameP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|==
name|NULL
condition|)
block|{
name|s
operator|=
name|bmake_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Suff
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|name
operator|=
name|bmake_strdup
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|s
operator|->
name|nameLen
operator|=
name|strlen
argument_list|(
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
name|s
operator|->
name|searchPath
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|s
operator|->
name|children
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|s
operator|->
name|parents
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|s
operator|->
name|ref
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|s
operator|->
name|sNum
operator|=
name|sNum
operator|++
expr_stmt|;
name|s
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|refCount
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|sufflist
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * We also look at our existing targets list to see if adding 	 * this suffix will make one of our current targets mutate into 	 * a suffix rule. This is ugly, but other makes treat all targets 	 * that start with a . as suffix rules. 	 */
name|gs
operator|.
name|gn
operator|=
name|gn
expr_stmt|;
name|gs
operator|.
name|s
operator|=
name|s
expr_stmt|;
name|gs
operator|.
name|r
operator|=
name|FALSE
expr_stmt|;
name|Lst_ForEach
argument_list|(
name|Targ_List
argument_list|()
argument_list|,
name|SuffScanTargets
argument_list|,
operator|&
name|gs
argument_list|)
expr_stmt|;
comment|/* 	 * Look for any existing transformations from or to this suffix. 	 * XXX: Only do this after a Suff_ClearSuffixes? 	 */
name|Lst_ForEach
argument_list|(
name|transforms
argument_list|,
name|SuffRebuildGraph
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Suff_GetPath --  *	Return the search path for the given suffix, if it's defined.  *  * Results:  *	The searchPath for the desired suffix or NULL if the suffix isn't  *	defined.  *  * Side Effects:  *	None  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|Lst
name|Suff_GetPath
parameter_list|(
name|char
modifier|*
name|sname
parameter_list|)
block|{
name|LstNode
name|ln
decl_stmt|;
name|Suff
modifier|*
name|s
decl_stmt|;
name|ln
operator|=
name|Lst_Find
argument_list|(
name|sufflist
argument_list|,
name|sname
argument_list|,
name|SuffSuffHasNameP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
else|else
block|{
name|s
operator|=
operator|(
name|Suff
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|->
name|searchPath
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Suff_DoPaths --  *	Extend the search paths for all suffixes to include the default  *	search path.  *  * Results:  *	None.  *  * Side Effects:  *	The searchPath field of all the suffixes is extended by the  *	directories in dirSearchPath. If paths were specified for the  *	".h" suffix, the directories are stuffed into a global variable  *	called ".INCLUDES" with each directory preceded by a -I. The same  *	is done for the ".a" suffix, except the variable is called  *	".LIBS" and the flag is -L.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Suff_DoPaths
parameter_list|(
name|void
parameter_list|)
block|{
name|Suff
modifier|*
name|s
decl_stmt|;
name|LstNode
name|ln
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|Lst
name|inIncludes
decl_stmt|;
comment|/* Cumulative .INCLUDES path */
name|Lst
name|inLibs
decl_stmt|;
comment|/* Cumulative .LIBS path */
if|if
condition|(
name|Lst_Open
argument_list|(
name|sufflist
argument_list|)
operator|==
name|FAILURE
condition|)
block|{
return|return;
block|}
name|inIncludes
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|inLibs
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ln
operator|=
name|Lst_Next
argument_list|(
name|sufflist
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|s
operator|=
operator|(
name|Suff
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|s
operator|->
name|searchPath
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|INCLUDES
if|if
condition|(
name|s
operator|->
name|flags
operator|&
name|SUFF_INCLUDE
condition|)
block|{
name|Dir_Concat
argument_list|(
name|inIncludes
argument_list|,
name|s
operator|->
name|searchPath
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* INCLUDES */
ifdef|#
directive|ifdef
name|LIBRARIES
if|if
condition|(
name|s
operator|->
name|flags
operator|&
name|SUFF_LIBRARY
condition|)
block|{
name|Dir_Concat
argument_list|(
name|inLibs
argument_list|,
name|s
operator|->
name|searchPath
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* LIBRARIES */
name|Dir_Concat
argument_list|(
name|s
operator|->
name|searchPath
argument_list|,
name|dirSearchPath
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Lst_Destroy
argument_list|(
name|s
operator|->
name|searchPath
argument_list|,
name|Dir_Destroy
argument_list|)
expr_stmt|;
name|s
operator|->
name|searchPath
operator|=
name|Lst_Duplicate
argument_list|(
name|dirSearchPath
argument_list|,
name|Dir_CopyDir
argument_list|)
expr_stmt|;
block|}
block|}
name|Var_Set
argument_list|(
literal|".INCLUDES"
argument_list|,
name|ptr
operator|=
name|Dir_MakeFlags
argument_list|(
literal|"-I"
argument_list|,
name|inIncludes
argument_list|)
argument_list|,
name|VAR_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|Var_Set
argument_list|(
literal|".LIBS"
argument_list|,
name|ptr
operator|=
name|Dir_MakeFlags
argument_list|(
literal|"-L"
argument_list|,
name|inLibs
argument_list|)
argument_list|,
name|VAR_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|Lst_Destroy
argument_list|(
name|inIncludes
argument_list|,
name|Dir_Destroy
argument_list|)
expr_stmt|;
name|Lst_Destroy
argument_list|(
name|inLibs
argument_list|,
name|Dir_Destroy
argument_list|)
expr_stmt|;
name|Lst_Close
argument_list|(
name|sufflist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Suff_AddInclude --  *	Add the given suffix as a type of file which gets included.  *	Called from the parse module when a .INCLUDES line is parsed.  *	The suffix must have already been defined.  *  * Input:  *	sname		Name of the suffix to mark  *  * Results:  *	None.  *  * Side Effects:  *	The SUFF_INCLUDE bit is set in the suffix's flags field  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Suff_AddInclude
parameter_list|(
name|char
modifier|*
name|sname
parameter_list|)
block|{
name|LstNode
name|ln
decl_stmt|;
name|Suff
modifier|*
name|s
decl_stmt|;
name|ln
operator|=
name|Lst_Find
argument_list|(
name|sufflist
argument_list|,
name|sname
argument_list|,
name|SuffSuffHasNameP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|!=
name|NULL
condition|)
block|{
name|s
operator|=
operator|(
name|Suff
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|s
operator|->
name|flags
operator||=
name|SUFF_INCLUDE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Suff_AddLib --  *	Add the given suffix as a type of file which is a library.  *	Called from the parse module when parsing a .LIBS line. The  *	suffix must have been defined via .SUFFIXES before this is  *	called.  *  * Input:  *	sname		Name of the suffix to mark  *  * Results:  *	None.  *  * Side Effects:  *	The SUFF_LIBRARY bit is set in the suffix's flags field  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Suff_AddLib
parameter_list|(
name|char
modifier|*
name|sname
parameter_list|)
block|{
name|LstNode
name|ln
decl_stmt|;
name|Suff
modifier|*
name|s
decl_stmt|;
name|ln
operator|=
name|Lst_Find
argument_list|(
name|sufflist
argument_list|,
name|sname
argument_list|,
name|SuffSuffHasNameP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|!=
name|NULL
condition|)
block|{
name|s
operator|=
operator|(
name|Suff
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|s
operator|->
name|flags
operator||=
name|SUFF_LIBRARY
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/********** Implicit Source Search Functions *********/
end_comment

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffAddSrc  --  *	Add a suffix as a Src structure to the given list with its parent  *	being the given Src structure. If the suffix is the null suffix,  *	the prefix is used unaltered as the file name in the Src structure.  *  * Input:  *	sp		suffix for which to create a Src structure  *	lsp		list and parent for the new Src  *  * Results:  *	always returns 0  *  * Side Effects:  *	A Src structure is created and tacked onto the end of the list  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SuffAddSrc
parameter_list|(
name|void
modifier|*
name|sp
parameter_list|,
name|void
modifier|*
name|lsp
parameter_list|)
block|{
name|Suff
modifier|*
name|s
init|=
operator|(
name|Suff
operator|*
operator|)
name|sp
decl_stmt|;
name|LstSrc
modifier|*
name|ls
init|=
operator|(
name|LstSrc
operator|*
operator|)
name|lsp
decl_stmt|;
name|Src
modifier|*
name|s2
decl_stmt|;
comment|/* new Src structure */
name|Src
modifier|*
name|targ
decl_stmt|;
comment|/* Target structure */
name|targ
operator|=
name|ls
operator|->
name|s
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SUFF_NULL
operator|)
operator|&&
operator|(
operator|*
name|s
operator|->
name|name
operator|!=
literal|'\0'
operator|)
condition|)
block|{
comment|/* 	 * If the suffix has been marked as the NULL suffix, also create a Src 	 * structure for a file with no suffix attached. Two birds, and all 	 * that... 	 */
name|s2
operator|=
name|bmake_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Src
argument_list|)
argument_list|)
expr_stmt|;
name|s2
operator|->
name|file
operator|=
name|bmake_strdup
argument_list|(
name|targ
operator|->
name|pref
argument_list|)
expr_stmt|;
name|s2
operator|->
name|pref
operator|=
name|targ
operator|->
name|pref
expr_stmt|;
name|s2
operator|->
name|parent
operator|=
name|targ
expr_stmt|;
name|s2
operator|->
name|node
operator|=
name|NULL
expr_stmt|;
name|s2
operator|->
name|suff
operator|=
name|s
expr_stmt|;
name|s
operator|->
name|refCount
operator|++
expr_stmt|;
name|s2
operator|->
name|children
operator|=
literal|0
expr_stmt|;
name|targ
operator|->
name|children
operator|+=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|ls
operator|->
name|l
argument_list|,
name|s2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_SRC
name|s2
operator|->
name|cp
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|Lst_AtEnd
argument_list|(
name|targ
operator|->
name|cp
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"1 add %x %x to %x:"
argument_list|,
name|targ
argument_list|,
name|s2
argument_list|,
name|ls
operator|->
name|l
argument_list|)
expr_stmt|;
name|Lst_ForEach
argument_list|(
name|ls
operator|->
name|l
argument_list|,
name|PrintAddr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|s2
operator|=
name|bmake_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Src
argument_list|)
argument_list|)
expr_stmt|;
name|s2
operator|->
name|file
operator|=
name|str_concat
argument_list|(
name|targ
operator|->
name|pref
argument_list|,
name|s
operator|->
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|s2
operator|->
name|pref
operator|=
name|targ
operator|->
name|pref
expr_stmt|;
name|s2
operator|->
name|parent
operator|=
name|targ
expr_stmt|;
name|s2
operator|->
name|node
operator|=
name|NULL
expr_stmt|;
name|s2
operator|->
name|suff
operator|=
name|s
expr_stmt|;
name|s
operator|->
name|refCount
operator|++
expr_stmt|;
name|s2
operator|->
name|children
operator|=
literal|0
expr_stmt|;
name|targ
operator|->
name|children
operator|+=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|ls
operator|->
name|l
argument_list|,
name|s2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_SRC
name|s2
operator|->
name|cp
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|Lst_AtEnd
argument_list|(
name|targ
operator|->
name|cp
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"2 add %x %x to %x:"
argument_list|,
name|targ
argument_list|,
name|s2
argument_list|,
name|ls
operator|->
name|l
argument_list|)
expr_stmt|;
name|Lst_ForEach
argument_list|(
name|ls
operator|->
name|l
argument_list|,
name|PrintAddr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffAddLevel  --  *	Add all the children of targ as Src structures to the given list  *  * Input:  *	l		list to which to add the new level  *	targ		Src structure to use as the parent  *  * Results:  *	None  *  * Side Effects:  * 	Lots of structures are created and added to the list  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|SuffAddLevel
parameter_list|(
name|Lst
name|l
parameter_list|,
name|Src
modifier|*
name|targ
parameter_list|)
block|{
name|LstSrc
name|ls
decl_stmt|;
name|ls
operator|.
name|s
operator|=
name|targ
expr_stmt|;
name|ls
operator|.
name|l
operator|=
name|l
expr_stmt|;
name|Lst_ForEach
argument_list|(
name|targ
operator|->
name|suff
operator|->
name|children
argument_list|,
name|SuffAddSrc
argument_list|,
operator|&
name|ls
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *----------------------------------------------------------------------  * SuffRemoveSrc --  *	Free all src structures in list that don't have a reference count  *  * Results:  *	Ture if an src was removed  *  * Side Effects:  *	The memory is free'd.  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|SuffRemoveSrc
parameter_list|(
name|Lst
name|l
parameter_list|)
block|{
name|LstNode
name|ln
decl_stmt|;
name|Src
modifier|*
name|s
decl_stmt|;
name|int
name|t
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|Lst_Open
argument_list|(
name|l
argument_list|)
operator|==
name|FAILURE
condition|)
block|{
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG_SRC
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"cleaning %lx: "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|l
argument_list|)
expr_stmt|;
name|Lst_ForEach
argument_list|(
name|l
argument_list|,
name|PrintAddr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|(
name|ln
operator|=
name|Lst_Next
argument_list|(
name|l
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|s
operator|=
operator|(
name|Src
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|children
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|s
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|parent
condition|)
name|free
argument_list|(
name|s
operator|->
name|pref
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG_SRC
name|LstNode
name|ln
init|=
name|Lst_Member
argument_list|(
name|s
operator|->
name|parent
operator|->
name|cp
argument_list|,
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|ln
operator|!=
name|NULL
condition|)
name|Lst_Remove
argument_list|(
name|s
operator|->
name|parent
operator|->
name|cp
argument_list|,
name|ln
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|--
name|s
operator|->
name|parent
operator|->
name|children
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG_SRC
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"free: [l=%x] p=%x %d\n"
argument_list|,
name|l
argument_list|,
name|s
argument_list|,
name|s
operator|->
name|children
argument_list|)
expr_stmt|;
name|Lst_Destroy
argument_list|(
name|s
operator|->
name|cp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Lst_Remove
argument_list|(
name|l
argument_list|,
name|ln
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|t
operator||=
literal|1
expr_stmt|;
name|Lst_Close
argument_list|(
name|l
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG_SRC
else|else
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"keep: [l=%x] p=%x %d: "
argument_list|,
name|l
argument_list|,
name|s
argument_list|,
name|s
operator|->
name|children
argument_list|)
expr_stmt|;
name|Lst_ForEach
argument_list|(
name|s
operator|->
name|cp
argument_list|,
name|PrintAddr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|Lst_Close
argument_list|(
name|l
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffFindThem --  *	Find the first existing file/target in the list srcs  *  * Input:  *	srcs		list of Src structures to search through  *  * Results:  *	The lowest structure in the chain of transformations  *  * Side Effects:  *	None  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Src
modifier|*
name|SuffFindThem
parameter_list|(
name|Lst
name|srcs
parameter_list|,
name|Lst
name|slst
parameter_list|)
block|{
name|Src
modifier|*
name|s
decl_stmt|;
comment|/* current Src */
name|Src
modifier|*
name|rs
decl_stmt|;
comment|/* returned Src */
name|char
modifier|*
name|ptr
decl_stmt|;
name|rs
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|srcs
argument_list|)
condition|)
block|{
name|s
operator|=
operator|(
name|Src
operator|*
operator|)
name|Lst_DeQueue
argument_list|(
name|srcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"\ttrying %s..."
argument_list|,
name|s
operator|->
name|file
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * A file is considered to exist if either a node exists in the 	 * graph for it or the file actually exists. 	 */
if|if
condition|(
name|Targ_FindNode
argument_list|(
name|s
operator|->
name|file
argument_list|,
name|TARG_NOCREATE
argument_list|)
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_SRC
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"remove %x from %x\n"
argument_list|,
name|s
argument_list|,
name|srcs
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rs
operator|=
name|s
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|ptr
operator|=
name|Dir_FindFile
argument_list|(
name|s
operator|->
name|file
argument_list|,
name|s
operator|->
name|suff
operator|->
name|searchPath
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|rs
operator|=
name|s
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_SRC
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"remove %x from %x\n"
argument_list|,
name|s
argument_list|,
name|srcs
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"not there\n"
argument_list|)
expr_stmt|;
block|}
name|SuffAddLevel
argument_list|(
name|srcs
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|Lst_AtEnd
argument_list|(
name|slst
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
operator|&&
name|rs
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"got it\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rs
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffFindCmds --  *	See if any of the children of the target in the Src structure is  *	one from which the target can be transformed. If there is one,  *	a Src structure is put together for it and returned.  *  * Input:  *	targ		Src structure to play with  *  * Results:  *	The Src structure of the "winning" child, or NULL if no such beast.  *  * Side Effects:  *	A Src structure may be allocated.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Src
modifier|*
name|SuffFindCmds
parameter_list|(
name|Src
modifier|*
name|targ
parameter_list|,
name|Lst
name|slst
parameter_list|)
block|{
name|LstNode
name|ln
decl_stmt|;
comment|/* General-purpose list node */
name|GNode
modifier|*
name|t
decl_stmt|,
comment|/* Target GNode */
modifier|*
name|s
decl_stmt|;
comment|/* Source GNode */
name|int
name|prefLen
decl_stmt|;
comment|/* The length of the defined prefix */
name|Suff
modifier|*
name|suff
decl_stmt|;
comment|/* Suffix on matching beastie */
name|Src
modifier|*
name|ret
decl_stmt|;
comment|/* Return value */
name|char
modifier|*
name|cp
decl_stmt|;
name|t
operator|=
name|targ
operator|->
name|node
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_Open
argument_list|(
name|t
operator|->
name|children
argument_list|)
expr_stmt|;
name|prefLen
operator|=
name|strlen
argument_list|(
name|targ
operator|->
name|pref
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ln
operator|=
name|Lst_Next
argument_list|(
name|t
operator|->
name|children
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|==
name|NULL
condition|)
block|{
name|Lst_Close
argument_list|(
name|t
operator|->
name|children
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|s
operator|=
operator|(
name|GNode
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|type
operator|&
name|OP_OPTIONAL
operator|&&
name|Lst_IsEmpty
argument_list|(
name|t
operator|->
name|commands
argument_list|)
condition|)
block|{
comment|/* 	     * We haven't looked to see if .OPTIONAL files exist yet, so 	     * don't use one as the implicit source. 	     * This allows us to use .OPTIONAL in .depend files so make won't 	     * complain "don't know how to make xxx.h' when a dependent file 	     * has been moved/deleted. 	     */
continue|continue;
block|}
name|cp
operator|=
name|strrchr
argument_list|(
name|s
operator|->
name|name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|cp
operator|=
name|s
operator|->
name|name
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
name|targ
operator|->
name|pref
argument_list|,
name|prefLen
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* 	 * The node matches the prefix ok, see if it has a known 	 * suffix. 	 */
name|ln
operator|=
name|Lst_Find
argument_list|(
name|sufflist
argument_list|,
operator|&
name|cp
index|[
name|prefLen
index|]
argument_list|,
name|SuffSuffHasNameP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|==
name|NULL
condition|)
continue|continue;
comment|/* 	 * It even has a known suffix, see if there's a transformation 	 * defined between the node's suffix and the target's suffix. 	 * 	 * XXX: Handle multi-stage transformations here, too. 	 */
name|suff
operator|=
operator|(
name|Suff
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|Lst_Member
argument_list|(
name|suff
operator|->
name|parents
argument_list|,
name|targ
operator|->
name|suff
argument_list|)
operator|!=
name|NULL
condition|)
break|break;
block|}
comment|/*      * Hot Damn! Create a new Src structure to describe      * this transformation (making sure to duplicate the      * source node's name so Suff_FindDeps can free it      * again (ick)), and return the new structure.      */
name|ret
operator|=
name|bmake_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Src
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|->
name|file
operator|=
name|bmake_strdup
argument_list|(
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
name|ret
operator|->
name|pref
operator|=
name|targ
operator|->
name|pref
expr_stmt|;
name|ret
operator|->
name|suff
operator|=
name|suff
expr_stmt|;
name|suff
operator|->
name|refCount
operator|++
expr_stmt|;
name|ret
operator|->
name|parent
operator|=
name|targ
expr_stmt|;
name|ret
operator|->
name|node
operator|=
name|s
expr_stmt|;
name|ret
operator|->
name|children
operator|=
literal|0
expr_stmt|;
name|targ
operator|->
name|children
operator|+=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_SRC
name|ret
operator|->
name|cp
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"3 add %x %x\n"
argument_list|,
name|targ
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|Lst_AtEnd
argument_list|(
name|targ
operator|->
name|cp
argument_list|,
name|ret
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Lst_AtEnd
argument_list|(
name|slst
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"\tusing existing source %s\n"
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffExpandChildren --  *	Expand the names of any children of a given node that contain  *	variable invocations or file wildcards into actual targets.  *  * Input:  *	cln		Child to examine  *	pgn		Parent node being processed  *  * Results:  *	=== 0 (continue)  *  * Side Effects:  *	The expanded node is removed from the parent's list of children,  *	and the parent's unmade counter is decremented, but other nodes  * 	may be added.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|SuffExpandChildren
parameter_list|(
name|LstNode
name|cln
parameter_list|,
name|GNode
modifier|*
name|pgn
parameter_list|)
block|{
name|GNode
modifier|*
name|cgn
init|=
operator|(
name|GNode
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|cln
argument_list|)
decl_stmt|;
name|GNode
modifier|*
name|gn
decl_stmt|;
comment|/* New source 8) */
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* Expanded value */
if|if
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|cgn
operator|->
name|order_pred
argument_list|)
operator|||
operator|!
name|Lst_IsEmpty
argument_list|(
name|cgn
operator|->
name|order_succ
argument_list|)
condition|)
comment|/* It is all too hard to process the result of .ORDER */
return|return;
if|if
condition|(
name|cgn
operator|->
name|type
operator|&
name|OP_WAIT
condition|)
comment|/* Ignore these (& OP_PHONY ?) */
return|return;
comment|/*      * First do variable expansion -- this takes precedence over      * wildcard expansion. If the result contains wildcards, they'll be gotten      * to later since the resulting words are tacked on to the end of      * the children list.      */
if|if
condition|(
name|strchr
argument_list|(
name|cgn
operator|->
name|name
argument_list|,
literal|'$'
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|SuffExpandWildcards
argument_list|(
name|cln
argument_list|,
name|pgn
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"Expanding \"%s\"..."
argument_list|,
name|cgn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|cgn
operator|->
name|name
argument_list|,
name|pgn
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|Lst
name|members
init|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
decl_stmt|;
if|if
condition|(
name|cgn
operator|->
name|type
operator|&
name|OP_ARCHV
condition|)
block|{
comment|/* 	     * Node was an archive(member) target, so we want to call 	     * on the Arch module to find the nodes for us, expanding 	     * variables in the parent's context. 	     */
name|char
modifier|*
name|sacrifice
init|=
name|cp
decl_stmt|;
operator|(
name|void
operator|)
name|Arch_ParseArchive
argument_list|(
operator|&
name|sacrifice
argument_list|,
name|members
argument_list|,
name|pgn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * Break the result into a vector of strings whose nodes 	     * we can find, then add those nodes to the members list. 	     * Unfortunately, we can't use brk_string b/c it 	     * doesn't understand about variable specifications with 	     * spaces in them... 	     */
name|char
modifier|*
name|start
decl_stmt|;
name|char
modifier|*
name|initcp
init|=
name|cp
decl_stmt|;
comment|/* For freeing... */
for|for
control|(
name|start
operator|=
name|cp
init|;
operator|*
name|start
operator|==
literal|' '
operator|||
operator|*
name|start
operator|==
literal|'\t'
condition|;
name|start
operator|++
control|)
continue|continue;
for|for
control|(
name|cp
operator|=
name|start
init|;
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|'\t'
condition|)
block|{
comment|/* 		     * White-space -- terminate element, find the node, 		     * add it, skip any further spaces. 		     */
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|gn
operator|=
name|Targ_FindNode
argument_list|(
name|start
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|members
argument_list|,
name|gn
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|'\t'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
comment|/* 		     * Adjust cp for increment at start of loop, but 		     * set start to first non-space. 		     */
name|start
operator|=
name|cp
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'$'
condition|)
block|{
comment|/* 		     * Start of a variable spec -- contact variable module 		     * to find the end so we can skip over it. 		     */
name|char
modifier|*
name|junk
decl_stmt|;
name|int
name|len
decl_stmt|;
name|void
modifier|*
name|freeIt
decl_stmt|;
name|junk
operator|=
name|Var_Parse
argument_list|(
name|cp
argument_list|,
name|pgn
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|freeIt
argument_list|)
expr_stmt|;
if|if
condition|(
name|junk
operator|!=
name|var_Error
condition|)
block|{
name|cp
operator|+=
name|len
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|freeIt
condition|)
name|free
argument_list|(
name|freeIt
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\\'
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
comment|/* 		     * Escaped something -- skip over it 		     */
name|cp
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cp
operator|!=
name|start
condition|)
block|{
comment|/* 		 * Stuff left over -- add it to the list too 		 */
name|gn
operator|=
name|Targ_FindNode
argument_list|(
name|start
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|members
argument_list|,
name|gn
argument_list|)
expr_stmt|;
block|}
comment|/* 	     * Point cp back at the beginning again so the variable value 	     * can be freed. 	     */
name|cp
operator|=
name|initcp
expr_stmt|;
block|}
comment|/* 	 * Add all elements of the members list to the parent node. 	 */
while|while
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|members
argument_list|)
condition|)
block|{
name|gn
operator|=
operator|(
name|GNode
operator|*
operator|)
name|Lst_DeQueue
argument_list|(
name|members
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"%s..."
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Add gn to the parents child list before the original child */
operator|(
name|void
operator|)
name|Lst_InsertBefore
argument_list|(
name|pgn
operator|->
name|children
argument_list|,
name|cln
argument_list|,
name|gn
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|gn
operator|->
name|parents
argument_list|,
name|pgn
argument_list|)
expr_stmt|;
name|pgn
operator|->
name|unmade
operator|++
expr_stmt|;
comment|/* Expand wildcards on new node */
name|SuffExpandWildcards
argument_list|(
name|Lst_Prev
argument_list|(
name|cln
argument_list|)
argument_list|,
name|pgn
argument_list|)
expr_stmt|;
block|}
name|Lst_Destroy
argument_list|(
name|members
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Free the result 	 */
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/*      * Now the source is expanded, remove it from the list of children to      * keep it from being processed.      */
name|pgn
operator|->
name|unmade
operator|--
expr_stmt|;
name|Lst_Remove
argument_list|(
name|pgn
operator|->
name|children
argument_list|,
name|cln
argument_list|)
expr_stmt|;
name|Lst_Remove
argument_list|(
name|cgn
operator|->
name|parents
argument_list|,
name|Lst_Member
argument_list|(
name|cgn
operator|->
name|parents
argument_list|,
name|pgn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|SuffExpandWildcards
parameter_list|(
name|LstNode
name|cln
parameter_list|,
name|GNode
modifier|*
name|pgn
parameter_list|)
block|{
name|GNode
modifier|*
name|cgn
init|=
operator|(
name|GNode
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|cln
argument_list|)
decl_stmt|;
name|GNode
modifier|*
name|gn
decl_stmt|;
comment|/* New source 8) */
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* Expanded value */
name|Lst
name|explist
decl_stmt|;
comment|/* List of expansions */
if|if
condition|(
operator|!
name|Dir_HasWildcards
argument_list|(
name|cgn
operator|->
name|name
argument_list|)
condition|)
return|return;
comment|/*      * Expand the word along the chosen path      */
name|explist
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|Dir_Expand
argument_list|(
name|cgn
operator|->
name|name
argument_list|,
name|Suff_FindPath
argument_list|(
name|cgn
argument_list|)
argument_list|,
name|explist
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|explist
argument_list|)
condition|)
block|{
comment|/* 	 * Fetch next expansion off the list and find its GNode 	 */
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|Lst_DeQueue
argument_list|(
name|explist
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"%s..."
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
name|gn
operator|=
name|Targ_FindNode
argument_list|(
name|cp
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
comment|/* Add gn to the parents child list before the original child */
operator|(
name|void
operator|)
name|Lst_InsertBefore
argument_list|(
name|pgn
operator|->
name|children
argument_list|,
name|cln
argument_list|,
name|gn
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|gn
operator|->
name|parents
argument_list|,
name|pgn
argument_list|)
expr_stmt|;
name|pgn
operator|->
name|unmade
operator|++
expr_stmt|;
block|}
comment|/*      * Nuke what's left of the list      */
name|Lst_Destroy
argument_list|(
name|explist
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/*      * Now the source is expanded, remove it from the list of children to      * keep it from being processed.      */
name|pgn
operator|->
name|unmade
operator|--
expr_stmt|;
name|Lst_Remove
argument_list|(
name|pgn
operator|->
name|children
argument_list|,
name|cln
argument_list|)
expr_stmt|;
name|Lst_Remove
argument_list|(
name|cgn
operator|->
name|parents
argument_list|,
name|Lst_Member
argument_list|(
name|cgn
operator|->
name|parents
argument_list|,
name|pgn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Suff_FindPath --  *	Find a path along which to expand the node.  *  *	If the word has a known suffix, use that path.  *	If it has no known suffix, use the default system search path.  *  * Input:  *	gn		Node being examined  *  * Results:  *	The appropriate path to search for the GNode.  *  * Side Effects:  *	XXX: We could set the suffix here so that we don't have to scan  *	again.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|Lst
name|Suff_FindPath
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|)
block|{
name|Suff
modifier|*
name|suff
init|=
name|gn
operator|->
name|suffix
decl_stmt|;
if|if
condition|(
name|suff
operator|==
name|NULL
condition|)
block|{
name|SuffixCmpData
name|sd
decl_stmt|;
comment|/* Search string data */
name|LstNode
name|ln
decl_stmt|;
name|sd
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
name|sd
operator|.
name|ename
operator|=
name|gn
operator|->
name|name
operator|+
name|sd
operator|.
name|len
expr_stmt|;
name|ln
operator|=
name|Lst_Find
argument_list|(
name|sufflist
argument_list|,
operator|&
name|sd
argument_list|,
name|SuffSuffIsSuffixP
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"Wildcard expanding \"%s\"..."
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ln
operator|!=
name|NULL
condition|)
name|suff
operator|=
operator|(
name|Suff
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
comment|/* XXX: Here we can save the suffix so we don't have to do this again */
block|}
if|if
condition|(
name|suff
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"suffix is \"%s\"..."
argument_list|,
name|suff
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|suff
operator|->
name|searchPath
return|;
block|}
else|else
block|{
comment|/* 	 * Use default search path 	 */
return|return
name|dirSearchPath
return|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffApplyTransform --  *	Apply a transformation rule, given the source and target nodes  *	and suffixes.  *  * Input:  *	tGn		Target node  *	sGn		Source node  *	t		Target suffix  *	s		Source suffix  *  * Results:  *	TRUE if successful, FALSE if not.  *  * Side Effects:  *	The source and target are linked and the commands from the  *	transformation are added to the target node's commands list.  *	All attributes but OP_DEPMASK and OP_TRANSFORM are applied  *	to the target. The target also inherits all the sources for  *	the transformation rule.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Boolean
name|SuffApplyTransform
parameter_list|(
name|GNode
modifier|*
name|tGn
parameter_list|,
name|GNode
modifier|*
name|sGn
parameter_list|,
name|Suff
modifier|*
name|t
parameter_list|,
name|Suff
modifier|*
name|s
parameter_list|)
block|{
name|LstNode
name|ln
decl_stmt|,
name|nln
decl_stmt|;
comment|/* General node */
name|char
modifier|*
name|tname
decl_stmt|;
comment|/* Name of transformation rule */
name|GNode
modifier|*
name|gn
decl_stmt|;
comment|/* Node for same */
comment|/*      * Form the proper links between the target and source.      */
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|tGn
operator|->
name|children
argument_list|,
name|sGn
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|sGn
operator|->
name|parents
argument_list|,
name|tGn
argument_list|)
expr_stmt|;
name|tGn
operator|->
name|unmade
operator|+=
literal|1
expr_stmt|;
comment|/*      * Locate the transformation rule itself      */
name|tname
operator|=
name|str_concat
argument_list|(
name|s
operator|->
name|name
argument_list|,
name|t
operator|->
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ln
operator|=
name|Lst_Find
argument_list|(
name|transforms
argument_list|,
name|tname
argument_list|,
name|SuffGNHasNameP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|==
name|NULL
condition|)
block|{
comment|/* 	 * Not really such a transformation rule (can happen when we're 	 * called to link an OP_MEMBER and OP_ARCHV node), so return 	 * FALSE. 	 */
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|gn
operator|=
operator|(
name|GNode
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"\tapplying %s -> %s to \"%s\"\n"
argument_list|,
name|s
operator|->
name|name
argument_list|,
name|t
operator|->
name|name
argument_list|,
name|tGn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
comment|/*      * Record last child for expansion purposes      */
name|ln
operator|=
name|Lst_Last
argument_list|(
name|tGn
operator|->
name|children
argument_list|)
expr_stmt|;
comment|/*      * Pass the buck to Make_HandleUse to apply the rule      */
operator|(
name|void
operator|)
name|Make_HandleUse
argument_list|(
name|gn
argument_list|,
name|tGn
argument_list|)
expr_stmt|;
comment|/*      * Deal with wildcards and variables in any acquired sources      */
for|for
control|(
name|ln
operator|=
name|Lst_Succ
argument_list|(
name|ln
argument_list|)
init|;
name|ln
operator|!=
name|NULL
condition|;
name|ln
operator|=
name|nln
control|)
block|{
name|nln
operator|=
name|Lst_Succ
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|SuffExpandChildren
argument_list|(
name|ln
argument_list|,
name|tGn
argument_list|)
expr_stmt|;
block|}
comment|/*      * Keep track of another parent to which this beast is transformed so      * the .IMPSRC variable can be set correctly for the parent.      */
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|sGn
operator|->
name|iParents
argument_list|,
name|tGn
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffFindArchiveDeps --  *	Locate dependencies for an OP_ARCHV node.  *  * Input:  *	gn		Node for which to locate dependencies  *  * Results:  *	None  *  * Side Effects:  *	Same as Suff_FindDeps  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|SuffFindArchiveDeps
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|,
name|Lst
name|slst
parameter_list|)
block|{
name|char
modifier|*
name|eoarch
decl_stmt|;
comment|/* End of archive portion */
name|char
modifier|*
name|eoname
decl_stmt|;
comment|/* End of member portion */
name|GNode
modifier|*
name|mem
decl_stmt|;
comment|/* Node for member */
specifier|static
specifier|const
name|char
modifier|*
name|copy
index|[]
init|=
block|{
comment|/* Variables to be copied from the member node */
name|TARGET
block|,
comment|/* Must be first */
name|PREFIX
block|,
comment|/* Must be second */
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Index into copy and vals */
name|Suff
modifier|*
name|ms
decl_stmt|;
comment|/* Suffix descriptor for member */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Start of member's name */
comment|/*      * The node is an archive(member) pair. so we must find a      * suffix for both of them.      */
name|eoarch
operator|=
name|strchr
argument_list|(
name|gn
operator|->
name|name
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|eoname
operator|=
name|strchr
argument_list|(
name|eoarch
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
operator|*
name|eoname
operator|=
literal|'\0'
expr_stmt|;
comment|/* Nuke parentheses during suffix search */
operator|*
name|eoarch
operator|=
literal|'\0'
expr_stmt|;
comment|/* So a suffix can be found */
name|name
operator|=
name|eoarch
operator|+
literal|1
expr_stmt|;
comment|/*      * To simplify things, call Suff_FindDeps recursively on the member now,      * so we can simply compare the member's .PREFIX and .TARGET variables      * to locate its suffix. This allows us to figure out the suffix to      * use for the archive without having to do a quadratic search over the      * suffix list, backtracking for each one...      */
name|mem
operator|=
name|Targ_FindNode
argument_list|(
name|name
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
name|SuffFindDeps
argument_list|(
name|mem
argument_list|,
name|slst
argument_list|)
expr_stmt|;
comment|/*      * Create the link between the two nodes right off      */
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|gn
operator|->
name|children
argument_list|,
name|mem
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|mem
operator|->
name|parents
argument_list|,
name|gn
argument_list|)
expr_stmt|;
name|gn
operator|->
name|unmade
operator|+=
literal|1
expr_stmt|;
comment|/*      * Copy in the variables from the member node to this one.      */
for|for
control|(
name|i
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|copy
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|copy
index|[
literal|0
index|]
argument_list|)
operator|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|char
modifier|*
name|p1
decl_stmt|;
name|Var_Set
argument_list|(
name|copy
index|[
name|i
index|]
argument_list|,
name|Var_Value
argument_list|(
name|copy
index|[
name|i
index|]
argument_list|,
name|mem
argument_list|,
operator|&
name|p1
argument_list|)
argument_list|,
name|gn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
condition|)
name|free
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
name|ms
operator|=
name|mem
operator|->
name|suffix
expr_stmt|;
if|if
condition|(
name|ms
operator|==
name|NULL
condition|)
block|{
comment|/* 	 * Didn't know what it was -- use .NULL suffix if not in make mode 	 */
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"using null suffix\n"
argument_list|)
expr_stmt|;
block|}
name|ms
operator|=
name|suffNull
expr_stmt|;
block|}
comment|/*      * Set the other two local variables required for this target.      */
name|Var_Set
argument_list|(
name|MEMBER
argument_list|,
name|name
argument_list|,
name|gn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Var_Set
argument_list|(
name|ARCHIVE
argument_list|,
name|gn
operator|->
name|name
argument_list|,
name|gn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ms
operator|!=
name|NULL
condition|)
block|{
comment|/* 	 * Member has a known suffix, so look for a transformation rule from 	 * it to a possible suffix of the archive. Rather than searching 	 * through the entire list, we just look at suffixes to which the 	 * member's suffix may be transformed... 	 */
name|LstNode
name|ln
decl_stmt|;
name|SuffixCmpData
name|sd
decl_stmt|;
comment|/* Search string data */
comment|/* 	 * Use first matching suffix... 	 */
name|sd
operator|.
name|len
operator|=
name|eoarch
operator|-
name|gn
operator|->
name|name
expr_stmt|;
name|sd
operator|.
name|ename
operator|=
name|eoarch
expr_stmt|;
name|ln
operator|=
name|Lst_Find
argument_list|(
name|ms
operator|->
name|parents
argument_list|,
operator|&
name|sd
argument_list|,
name|SuffSuffIsSuffixP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|!=
name|NULL
condition|)
block|{
comment|/* 	     * Got one -- apply it 	     */
if|if
condition|(
operator|!
name|SuffApplyTransform
argument_list|(
name|gn
argument_list|,
name|mem
argument_list|,
operator|(
name|Suff
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
argument_list|,
name|ms
argument_list|)
operator|&&
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"\tNo transformation from %s -> %s\n"
argument_list|,
name|ms
operator|->
name|name
argument_list|,
operator|(
operator|(
name|Suff
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
operator|)
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*      * Replace the opening and closing parens now we've no need of the separate      * pieces.      */
operator|*
name|eoarch
operator|=
literal|'('
expr_stmt|;
operator|*
name|eoname
operator|=
literal|')'
expr_stmt|;
comment|/*      * Pretend gn appeared to the left of a dependency operator so      * the user needn't provide a transformation from the member to the      * archive.      */
if|if
condition|(
name|OP_NOP
argument_list|(
name|gn
operator|->
name|type
argument_list|)
condition|)
block|{
name|gn
operator|->
name|type
operator||=
name|OP_DEPENDS
expr_stmt|;
block|}
comment|/*      * Flag the member as such so we remember to look in the archive for      * its modification time.      */
name|mem
operator|->
name|type
operator||=
name|OP_MEMBER
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * SuffFindNormalDeps --  *	Locate implicit dependencies for regular targets.  *  * Input:  *	gn		Node for which to find sources  *  * Results:  *	None.  *  * Side Effects:  *	Same as Suff_FindDeps...  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|SuffFindNormalDeps
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|,
name|Lst
name|slst
parameter_list|)
block|{
name|char
modifier|*
name|eoname
decl_stmt|;
comment|/* End of name */
name|char
modifier|*
name|sopref
decl_stmt|;
comment|/* Start of prefix */
name|LstNode
name|ln
decl_stmt|,
name|nln
decl_stmt|;
comment|/* Next suffix node to check */
name|Lst
name|srcs
decl_stmt|;
comment|/* List of sources at which to look */
name|Lst
name|targs
decl_stmt|;
comment|/* List of targets to which things can be 			     * transformed. They all have the same file, 			     * but different suff and pref fields */
name|Src
modifier|*
name|bottom
decl_stmt|;
comment|/* Start of found transformation path */
name|Src
modifier|*
name|src
decl_stmt|;
comment|/* General Src pointer */
name|char
modifier|*
name|pref
decl_stmt|;
comment|/* Prefix to use */
name|Src
modifier|*
name|targ
decl_stmt|;
comment|/* General Src target pointer */
name|SuffixCmpData
name|sd
decl_stmt|;
comment|/* Search string data */
name|sd
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
name|sd
operator|.
name|ename
operator|=
name|eoname
operator|=
name|gn
operator|->
name|name
operator|+
name|sd
operator|.
name|len
expr_stmt|;
name|sopref
operator|=
name|gn
operator|->
name|name
expr_stmt|;
comment|/*      * Begin at the beginning...      */
name|ln
operator|=
name|Lst_First
argument_list|(
name|sufflist
argument_list|)
expr_stmt|;
name|srcs
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|targs
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
comment|/*      * We're caught in a catch-22 here. On the one hand, we want to use any      * transformation implied by the target's sources, but we can't examine      * the sources until we've expanded any variables/wildcards they may hold,      * and we can't do that until we've set up the target's local variables      * and we can't do that until we know what the proper suffix for the      * target is (in case there are two suffixes one of which is a suffix of      * the other) and we can't know that until we've found its implied      * source, which we may not want to use if there's an existing source      * that implies a different transformation.      *      * In an attempt to get around this, which may not work all the time,      * but should work most of the time, we look for implied sources first,      * checking transformations to all possible suffixes of the target,      * use what we find to set the target's local variables, expand the      * children, then look for any overriding transformations they imply.      * Should we find one, we discard the one we found before.      */
name|bottom
operator|=
name|NULL
expr_stmt|;
name|targ
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_PHONY
operator|)
condition|)
block|{
while|while
condition|(
name|ln
operator|!=
name|NULL
condition|)
block|{
comment|/* 	     * Look for next possible suffix... 	     */
name|ln
operator|=
name|Lst_FindFrom
argument_list|(
name|sufflist
argument_list|,
name|ln
argument_list|,
operator|&
name|sd
argument_list|,
name|SuffSuffIsSuffixP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|!=
name|NULL
condition|)
block|{
name|int
name|prefLen
decl_stmt|;
comment|/* Length of the prefix */
comment|/* 		 * Allocate a Src structure to which things can be transformed 		 */
name|targ
operator|=
name|bmake_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Src
argument_list|)
argument_list|)
expr_stmt|;
name|targ
operator|->
name|file
operator|=
name|bmake_strdup
argument_list|(
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
name|targ
operator|->
name|suff
operator|=
operator|(
name|Suff
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|targ
operator|->
name|suff
operator|->
name|refCount
operator|++
expr_stmt|;
name|targ
operator|->
name|node
operator|=
name|gn
expr_stmt|;
name|targ
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
name|targ
operator|->
name|children
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_SRC
name|targ
operator|->
name|cp
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Allocate room for the prefix, whose end is found by 		 * subtracting the length of the suffix from 		 * the end of the name. 		 */
name|prefLen
operator|=
operator|(
name|eoname
operator|-
name|targ
operator|->
name|suff
operator|->
name|nameLen
operator|)
operator|-
name|sopref
expr_stmt|;
name|targ
operator|->
name|pref
operator|=
name|bmake_malloc
argument_list|(
name|prefLen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|targ
operator|->
name|pref
argument_list|,
name|sopref
argument_list|,
name|prefLen
argument_list|)
expr_stmt|;
name|targ
operator|->
name|pref
index|[
name|prefLen
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 		 * Add nodes from which the target can be made 		 */
name|SuffAddLevel
argument_list|(
name|srcs
argument_list|,
name|targ
argument_list|)
expr_stmt|;
comment|/* 		 * Record the target so we can nuke it 		 */
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|targs
argument_list|,
name|targ
argument_list|)
expr_stmt|;
comment|/* 		 * Search from this suffix's successor... 		 */
name|ln
operator|=
name|Lst_Succ
argument_list|(
name|ln
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Handle target of unknown suffix... 	 */
if|if
condition|(
name|Lst_IsEmpty
argument_list|(
name|targs
argument_list|)
operator|&&
name|suffNull
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"\tNo known suffix on %s. Using .NULL suffix\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|targ
operator|=
name|bmake_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Src
argument_list|)
argument_list|)
expr_stmt|;
name|targ
operator|->
name|file
operator|=
name|bmake_strdup
argument_list|(
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
name|targ
operator|->
name|suff
operator|=
name|suffNull
expr_stmt|;
name|targ
operator|->
name|suff
operator|->
name|refCount
operator|++
expr_stmt|;
name|targ
operator|->
name|node
operator|=
name|gn
expr_stmt|;
name|targ
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
name|targ
operator|->
name|children
operator|=
literal|0
expr_stmt|;
name|targ
operator|->
name|pref
operator|=
name|bmake_strdup
argument_list|(
name|sopref
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_SRC
name|targ
operator|->
name|cp
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	     * Only use the default suffix rules if we don't have commands 	     * defined for this gnode; traditional make programs used to 	     * not define suffix rules if the gnode had children but we 	     * don't do this anymore. 	     */
if|if
condition|(
name|Lst_IsEmpty
argument_list|(
name|gn
operator|->
name|commands
argument_list|)
condition|)
name|SuffAddLevel
argument_list|(
name|srcs
argument_list|,
name|targ
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"not "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"adding suffix rules\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|targs
argument_list|,
name|targ
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Using the list of possible sources built up from the target 	 * suffix(es), try and find an existing file/target that matches. 	 */
name|bottom
operator|=
name|SuffFindThem
argument_list|(
name|srcs
argument_list|,
name|slst
argument_list|)
expr_stmt|;
if|if
condition|(
name|bottom
operator|==
name|NULL
condition|)
block|{
comment|/* 	     * No known transformations -- use the first suffix found 	     * for setting the local variables. 	     */
if|if
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|targs
argument_list|)
condition|)
block|{
name|targ
operator|=
operator|(
name|Src
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|Lst_First
argument_list|(
name|targs
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|targ
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	     * Work up the transformation path to find the suffix of the 	     * target to which the transformation was made. 	     */
for|for
control|(
name|targ
operator|=
name|bottom
init|;
name|targ
operator|->
name|parent
operator|!=
name|NULL
condition|;
name|targ
operator|=
name|targ
operator|->
name|parent
control|)
continue|continue;
block|}
block|}
name|Var_Set
argument_list|(
name|TARGET
argument_list|,
name|gn
operator|->
name|path
condition|?
name|gn
operator|->
name|path
else|:
name|gn
operator|->
name|name
argument_list|,
name|gn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pref
operator|=
operator|(
name|targ
operator|!=
name|NULL
operator|)
condition|?
name|targ
operator|->
name|pref
else|:
name|gn
operator|->
name|name
expr_stmt|;
name|Var_Set
argument_list|(
name|PREFIX
argument_list|,
name|pref
argument_list|,
name|gn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*      * Now we've got the important local variables set, expand any sources      * that still contain variables or wildcards in their names.      */
for|for
control|(
name|ln
operator|=
name|Lst_First
argument_list|(
name|gn
operator|->
name|children
argument_list|)
init|;
name|ln
operator|!=
name|NULL
condition|;
name|ln
operator|=
name|nln
control|)
block|{
name|nln
operator|=
name|Lst_Succ
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|SuffExpandChildren
argument_list|(
name|ln
argument_list|,
name|gn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|targ
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"\tNo valid suffix on %s\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|sfnd_abort
label|:
comment|/* 	 * Deal with finding the thing on the default search path. We 	 * always do that, not only if the node is only a source (not 	 * on the lhs of a dependency operator or [XXX] it has neither 	 * children or commands) as the old pmake did. 	 */
if|if
condition|(
operator|(
name|gn
operator|->
name|type
operator|&
operator|(
name|OP_PHONY
operator||
name|OP_NOPATH
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|gn
operator|->
name|path
argument_list|)
expr_stmt|;
name|gn
operator|->
name|path
operator|=
name|Dir_FindFile
argument_list|(
name|gn
operator|->
name|name
argument_list|,
operator|(
name|targ
operator|==
name|NULL
condition|?
name|dirSearchPath
else|:
name|targ
operator|->
name|suff
operator|->
name|searchPath
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|->
name|path
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|Var_Set
argument_list|(
name|TARGET
argument_list|,
name|gn
operator|->
name|path
argument_list|,
name|gn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ
operator|!=
name|NULL
condition|)
block|{
comment|/* 		     * Suffix known for the thing -- trim the suffix off 		     * the path to form the proper .PREFIX variable. 		     */
name|int
name|savep
init|=
name|strlen
argument_list|(
name|gn
operator|->
name|path
argument_list|)
operator|-
name|targ
operator|->
name|suff
operator|->
name|nameLen
decl_stmt|;
name|char
name|savec
decl_stmt|;
if|if
condition|(
name|gn
operator|->
name|suffix
condition|)
name|gn
operator|->
name|suffix
operator|->
name|refCount
operator|--
expr_stmt|;
name|gn
operator|->
name|suffix
operator|=
name|targ
operator|->
name|suff
expr_stmt|;
name|gn
operator|->
name|suffix
operator|->
name|refCount
operator|++
expr_stmt|;
name|savec
operator|=
name|gn
operator|->
name|path
index|[
name|savep
index|]
expr_stmt|;
name|gn
operator|->
name|path
index|[
name|savep
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|=
name|strrchr
argument_list|(
name|gn
operator|->
name|path
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|ptr
operator|++
expr_stmt|;
else|else
name|ptr
operator|=
name|gn
operator|->
name|path
expr_stmt|;
name|Var_Set
argument_list|(
name|PREFIX
argument_list|,
name|ptr
argument_list|,
name|gn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gn
operator|->
name|path
index|[
name|savep
index|]
operator|=
name|savec
expr_stmt|;
block|}
else|else
block|{
comment|/* 		     * The .PREFIX gets the full path if the target has 		     * no known suffix. 		     */
if|if
condition|(
name|gn
operator|->
name|suffix
condition|)
name|gn
operator|->
name|suffix
operator|->
name|refCount
operator|--
expr_stmt|;
name|gn
operator|->
name|suffix
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|=
name|strrchr
argument_list|(
name|gn
operator|->
name|path
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|ptr
operator|++
expr_stmt|;
else|else
name|ptr
operator|=
name|gn
operator|->
name|path
expr_stmt|;
name|Var_Set
argument_list|(
name|PREFIX
argument_list|,
name|ptr
argument_list|,
name|gn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
goto|goto
name|sfnd_return
goto|;
block|}
comment|/*      * If the suffix indicates that the target is a library, mark that in      * the node's type field.      */
if|if
condition|(
name|targ
operator|->
name|suff
operator|->
name|flags
operator|&
name|SUFF_LIBRARY
condition|)
block|{
name|gn
operator|->
name|type
operator||=
name|OP_LIB
expr_stmt|;
block|}
comment|/*      * Check for overriding transformation rule implied by sources      */
if|if
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|gn
operator|->
name|children
argument_list|)
condition|)
block|{
name|src
operator|=
name|SuffFindCmds
argument_list|(
name|targ
argument_list|,
name|slst
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|!=
name|NULL
condition|)
block|{
comment|/* 	     * Free up all the Src structures in the transformation path 	     * up to, but not including, the parent node. 	     */
while|while
condition|(
name|bottom
operator|&&
name|bottom
operator|->
name|parent
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|Lst_Member
argument_list|(
name|slst
argument_list|,
name|bottom
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|Lst_AtEnd
argument_list|(
name|slst
argument_list|,
name|bottom
argument_list|)
expr_stmt|;
block|}
name|bottom
operator|=
name|bottom
operator|->
name|parent
expr_stmt|;
block|}
name|bottom
operator|=
name|src
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bottom
operator|==
name|NULL
condition|)
block|{
comment|/* 	 * No idea from where it can come -- return now. 	 */
goto|goto
name|sfnd_abort
goto|;
block|}
comment|/*      * We now have a list of Src structures headed by 'bottom' and linked via      * their 'parent' pointers. What we do next is create links between      * source and target nodes (which may or may not have been created)      * and set the necessary local variables in each target. The      * commands for each target are set from the commands of the      * transformation rule used to get from the src suffix to the targ      * suffix. Note that this causes the commands list of the original      * node, gn, to be replaced by the commands of the final      * transformation rule. Also, the unmade field of gn is incremented.      * Etc.      */
if|if
condition|(
name|bottom
operator|->
name|node
operator|==
name|NULL
condition|)
block|{
name|bottom
operator|->
name|node
operator|=
name|Targ_FindNode
argument_list|(
name|bottom
operator|->
name|file
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|src
operator|=
name|bottom
init|;
name|src
operator|->
name|parent
operator|!=
name|NULL
condition|;
name|src
operator|=
name|src
operator|->
name|parent
control|)
block|{
name|targ
operator|=
name|src
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|node
operator|->
name|suffix
condition|)
name|src
operator|->
name|node
operator|->
name|suffix
operator|->
name|refCount
operator|--
expr_stmt|;
name|src
operator|->
name|node
operator|->
name|suffix
operator|=
name|src
operator|->
name|suff
expr_stmt|;
name|src
operator|->
name|node
operator|->
name|suffix
operator|->
name|refCount
operator|++
expr_stmt|;
if|if
condition|(
name|targ
operator|->
name|node
operator|==
name|NULL
condition|)
block|{
name|targ
operator|->
name|node
operator|=
name|Targ_FindNode
argument_list|(
name|targ
operator|->
name|file
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
block|}
name|SuffApplyTransform
argument_list|(
name|targ
operator|->
name|node
argument_list|,
name|src
operator|->
name|node
argument_list|,
name|targ
operator|->
name|suff
argument_list|,
name|src
operator|->
name|suff
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ
operator|->
name|node
operator|!=
name|gn
condition|)
block|{
comment|/* 	     * Finish off the dependency-search process for any nodes 	     * between bottom and gn (no point in questing around the 	     * filesystem for their implicit source when it's already 	     * known). Note that the node can't have any sources that 	     * need expanding, since SuffFindThem will stop on an existing 	     * node, so all we need to do is set the standard and System V 	     * variables. 	     */
name|targ
operator|->
name|node
operator|->
name|type
operator||=
name|OP_DEPS_FOUND
expr_stmt|;
name|Var_Set
argument_list|(
name|PREFIX
argument_list|,
name|targ
operator|->
name|pref
argument_list|,
name|targ
operator|->
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Var_Set
argument_list|(
name|TARGET
argument_list|,
name|targ
operator|->
name|node
operator|->
name|name
argument_list|,
name|targ
operator|->
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gn
operator|->
name|suffix
condition|)
name|gn
operator|->
name|suffix
operator|->
name|refCount
operator|--
expr_stmt|;
name|gn
operator|->
name|suffix
operator|=
name|src
operator|->
name|suff
expr_stmt|;
name|gn
operator|->
name|suffix
operator|->
name|refCount
operator|++
expr_stmt|;
comment|/*      * Nuke the transformation path and the Src structures left over in the      * two lists.      */
name|sfnd_return
label|:
if|if
condition|(
name|bottom
condition|)
if|if
condition|(
name|Lst_Member
argument_list|(
name|slst
argument_list|,
name|bottom
argument_list|)
operator|==
name|NULL
condition|)
name|Lst_AtEnd
argument_list|(
name|slst
argument_list|,
name|bottom
argument_list|)
expr_stmt|;
while|while
condition|(
name|SuffRemoveSrc
argument_list|(
name|srcs
argument_list|)
operator|||
name|SuffRemoveSrc
argument_list|(
name|targs
argument_list|)
condition|)
continue|continue;
name|Lst_Concat
argument_list|(
name|slst
argument_list|,
name|srcs
argument_list|,
name|LST_CONCLINK
argument_list|)
expr_stmt|;
name|Lst_Concat
argument_list|(
name|slst
argument_list|,
name|targs
argument_list|,
name|LST_CONCLINK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Suff_FindDeps  --  *	Find implicit sources for the target described by the graph node  *	gn  *  * Results:  *	Nothing.  *  * Side Effects:  *	Nodes are added to the graph below the passed-in node. The nodes  *	are marked to have their IMPSRC variable filled in. The  *	PREFIX variable is set for the given node and all its  *	implied children.  *  * Notes:  *	The path found by this target is the shortest path in the  *	transformation graph, which may pass through non-existent targets,  *	to an existing target. The search continues on all paths from the  *	root suffix until a file is found. I.e. if there's a path  *	.o -> .c -> .l -> .l,v from the root and the .l,v file exists but  *	the .c and .l files don't, the search will branch out in  *	all directions from .o and again from all the nodes on the  *	next level until the .l,v node is encountered.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Suff_FindDeps
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|)
block|{
name|SuffFindDeps
argument_list|(
name|gn
argument_list|,
name|srclist
argument_list|)
expr_stmt|;
while|while
condition|(
name|SuffRemoveSrc
argument_list|(
name|srclist
argument_list|)
condition|)
continue|continue;
block|}
end_function

begin_comment
comment|/*  * Input:  *	gn		node we're dealing with  *  */
end_comment

begin_function
specifier|static
name|void
name|SuffFindDeps
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|,
name|Lst
name|slst
parameter_list|)
block|{
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_DEPS_FOUND
condition|)
block|{
comment|/* 	 * If dependencies already found, no need to do it again... 	 */
return|return;
block|}
else|else
block|{
name|gn
operator|->
name|type
operator||=
name|OP_DEPS_FOUND
expr_stmt|;
block|}
comment|/*      * Make sure we have these set, may get revised below.      */
name|Var_Set
argument_list|(
name|TARGET
argument_list|,
name|gn
operator|->
name|path
condition|?
name|gn
operator|->
name|path
else|:
name|gn
operator|->
name|name
argument_list|,
name|gn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Var_Set
argument_list|(
name|PREFIX
argument_list|,
name|gn
operator|->
name|name
argument_list|,
name|gn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|SUFF
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"SuffFindDeps (%s)\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_ARCHV
condition|)
block|{
name|SuffFindArchiveDeps
argument_list|(
name|gn
argument_list|,
name|slst
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_LIB
condition|)
block|{
comment|/* 	 * If the node is a library, it is the arch module's job to find it 	 * and set the TARGET variable accordingly. We merely provide the 	 * search path, assuming all libraries end in ".a" (if the suffix 	 * hasn't been defined, there's nothing we can do for it, so we just 	 * set the TARGET variable to the node's name in order to give it a 	 * value). 	 */
name|LstNode
name|ln
decl_stmt|;
name|Suff
modifier|*
name|s
decl_stmt|;
name|ln
operator|=
name|Lst_Find
argument_list|(
name|sufflist
argument_list|,
name|LIBSUFF
argument_list|,
name|SuffSuffHasNameP
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|->
name|suffix
condition|)
name|gn
operator|->
name|suffix
operator|->
name|refCount
operator|--
expr_stmt|;
if|if
condition|(
name|ln
operator|!=
name|NULL
condition|)
block|{
name|gn
operator|->
name|suffix
operator|=
name|s
operator|=
operator|(
name|Suff
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|gn
operator|->
name|suffix
operator|->
name|refCount
operator|++
expr_stmt|;
name|Arch_FindLib
argument_list|(
name|gn
argument_list|,
name|s
operator|->
name|searchPath
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gn
operator|->
name|suffix
operator|=
name|NULL
expr_stmt|;
name|Var_Set
argument_list|(
name|TARGET
argument_list|,
name|gn
operator|->
name|name
argument_list|,
name|gn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Because a library (-lfoo) target doesn't follow the standard 	 * filesystem conventions, we don't set the regular variables for 	 * the thing. .PREFIX is simply made empty... 	 */
name|Var_Set
argument_list|(
name|PREFIX
argument_list|,
literal|""
argument_list|,
name|gn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SuffFindNormalDeps
argument_list|(
name|gn
argument_list|,
name|slst
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Suff_SetNull --  *	Define which suffix is the null suffix.  *  * Input:  *	name		Name of null suffix  *  * Results:  *	None.  *  * Side Effects:  *	'suffNull' is altered.  *  * Notes:  *	Need to handle the changing of the null suffix gracefully so the  *	old transformation rules don't just go away.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Suff_SetNull
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|Suff
modifier|*
name|s
decl_stmt|;
name|LstNode
name|ln
decl_stmt|;
name|ln
operator|=
name|Lst_Find
argument_list|(
name|sufflist
argument_list|,
name|name
argument_list|,
name|SuffSuffHasNameP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|!=
name|NULL
condition|)
block|{
name|s
operator|=
operator|(
name|Suff
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|suffNull
operator|!=
name|NULL
condition|)
block|{
name|suffNull
operator|->
name|flags
operator|&=
operator|~
name|SUFF_NULL
expr_stmt|;
block|}
name|s
operator|->
name|flags
operator||=
name|SUFF_NULL
expr_stmt|;
comment|/* 	 * XXX: Here's where the transformation mangling would take place 	 */
name|suffNull
operator|=
name|s
expr_stmt|;
block|}
else|else
block|{
name|Parse_Error
argument_list|(
name|PARSE_WARNING
argument_list|,
literal|"Desired null suffix %s not defined."
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Suff_Init --  *	Initialize suffixes module  *  * Results:  *	None  *  * Side Effects:  *	Many  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Suff_Init
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CLEANUP
name|suffClean
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|srclist
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|transforms
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
comment|/*      * Create null suffix for single-suffix rules (POSIX). The thing doesn't      * actually go on the suffix list or everyone will think that's its      * suffix.      */
name|Suff_ClearSuffixes
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *----------------------------------------------------------------------  * Suff_End --  *	Cleanup the this module  *  * Results:  *	None  *  * Side Effects:  *	The memory is free'd.  *----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Suff_End
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CLEANUP
name|Lst_Destroy
argument_list|(
name|sufflist
argument_list|,
name|SuffFree
argument_list|)
expr_stmt|;
name|Lst_Destroy
argument_list|(
name|suffClean
argument_list|,
name|SuffFree
argument_list|)
expr_stmt|;
if|if
condition|(
name|suffNull
condition|)
name|SuffFree
argument_list|(
name|suffNull
argument_list|)
expr_stmt|;
name|Lst_Destroy
argument_list|(
name|srclist
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|Lst_Destroy
argument_list|(
name|transforms
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/********************* DEBUGGING FUNCTIONS **********************/
end_comment

begin_function
specifier|static
name|int
name|SuffPrintName
parameter_list|(
name|void
modifier|*
name|s
parameter_list|,
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"%s "
argument_list|,
operator|(
operator|(
name|Suff
operator|*
operator|)
name|s
operator|)
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|dummy
condition|?
literal|0
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|SuffPrintSuff
parameter_list|(
name|void
modifier|*
name|sp
parameter_list|,
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|Suff
modifier|*
name|s
init|=
operator|(
name|Suff
operator|*
operator|)
name|sp
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"# `%s' [%d] "
argument_list|,
name|s
operator|->
name|name
argument_list|,
name|s
operator|->
name|refCount
argument_list|)
expr_stmt|;
name|flags
operator|=
name|s
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|flags
condition|)
block|{
name|fputs
argument_list|(
literal|" ("
argument_list|,
name|debug_file
argument_list|)
expr_stmt|;
while|while
condition|(
name|flags
condition|)
block|{
name|flag
operator|=
literal|1
operator|<<
operator|(
name|ffs
argument_list|(
name|flags
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|flag
expr_stmt|;
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
name|SUFF_NULL
case|:
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"NULL"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUFF_INCLUDE
case|:
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"INCLUDE"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUFF_LIBRARY
case|:
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"LIBRARY"
argument_list|)
expr_stmt|;
break|break;
block|}
name|fputc
argument_list|(
name|flags
condition|?
literal|'|'
else|:
literal|')'
argument_list|,
name|debug_file
argument_list|)
expr_stmt|;
block|}
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|debug_file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"#\tTo: "
argument_list|)
expr_stmt|;
name|Lst_ForEach
argument_list|(
name|s
operator|->
name|parents
argument_list|,
name|SuffPrintName
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|debug_file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"#\tFrom: "
argument_list|)
expr_stmt|;
name|Lst_ForEach
argument_list|(
name|s
operator|->
name|children
argument_list|,
name|SuffPrintName
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|debug_file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"#\tSearch Path: "
argument_list|)
expr_stmt|;
name|Dir_PrintPath
argument_list|(
name|s
operator|->
name|searchPath
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|debug_file
argument_list|)
expr_stmt|;
return|return
operator|(
name|dummy
condition|?
literal|0
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|SuffPrintTrans
parameter_list|(
name|void
modifier|*
name|tp
parameter_list|,
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|GNode
modifier|*
name|t
init|=
operator|(
name|GNode
operator|*
operator|)
name|tp
decl_stmt|;
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"%-16s: "
argument_list|,
name|t
operator|->
name|name
argument_list|)
expr_stmt|;
name|Targ_PrintType
argument_list|(
name|t
operator|->
name|type
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|debug_file
argument_list|)
expr_stmt|;
name|Lst_ForEach
argument_list|(
name|t
operator|->
name|commands
argument_list|,
name|Targ_PrintCmd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|debug_file
argument_list|)
expr_stmt|;
return|return
operator|(
name|dummy
condition|?
literal|0
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|Suff_PrintAll
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"#*** Suffixes:\n"
argument_list|)
expr_stmt|;
name|Lst_ForEach
argument_list|(
name|sufflist
argument_list|,
name|SuffPrintSuff
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"#*** Transformations:\n"
argument_list|)
expr_stmt|;
name|Lst_ForEach
argument_list|(
name|transforms
argument_list|,
name|SuffPrintTrans
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

