begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: dir.c,v 1.71 2017/04/16 21:14:47 riastradh Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 1988, 1989, 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Adam de Boor.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1988, 1989 by Adam de Boor  * Copyright (c) 1989 by Berkeley Softworks  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Adam de Boor.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAKE_NATIVE
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$NetBSD: dir.c,v 1.71 2017/04/16 21:14:47 riastradh Exp $"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_else
unit|static char sccsid[] = "@(#)dir.c	8.2 (Berkeley) 1/2/94";
else|#
directive|else
end_else

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$NetBSD: dir.c,v 1.71 2017/04/16 21:14:47 riastradh Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*-  * dir.c --  *	Directory searching using wildcards and/or normal names...  *	Used both for source wildcarding in the Makefile and for finding  *	implicit sources.  *  * The interface for this module is:  *	Dir_Init  	    Initialize the module.  *  *	Dir_InitCur	    Set the cur Path.  *  *	Dir_InitDot	    Set the dot Path.  *  *	Dir_End  	    Cleanup the module.  *  *	Dir_SetPATH	    Set ${.PATH} to reflect state of dirSearchPath.  *  *	Dir_HasWildcards    Returns TRUE if the name given it needs to  *	    	  	    be wildcard-expanded.  *  *	Dir_Expand	    Given a pattern and a path, return a Lst of names  *	    	  	    which match the pattern on the search path.  *  *	Dir_FindFile	    Searches for a file on a given search path.  *	    	  	    If it exists, the entire path is returned.  *	    	  	    Otherwise NULL is returned.  *  *	Dir_FindHereOrAbove Search for a path in the current directory and  *			    then all the directories above it in turn until  *			    the path is found or we reach the root ("/").  *   *	Dir_MTime 	    Return the modification time of a node. The file  *	    	  	    is searched for along the default search path.  *	    	  	    The path and mtime fields of the node are filled  *	    	  	    in.  *  *	Dir_AddDir	    Add a directory to a search path.  *  *	Dir_MakeFlags	    Given a search path and a command flag, create  *	    	  	    a string with each of the directories in the path  *	    	  	    preceded by the command flag and all of them  *	    	  	    separated by a space.  *  *	Dir_Destroy	    Destroy an element of a search path. Frees up all  *	    	  	    things that can be freed for the element as long  *	    	  	    as the element is no longer referenced by any other  *	    	  	    search path.  *	Dir_ClearPath	    Resets a search path to the empty list.  *  * For debugging:  *	Dir_PrintDirectories	Print stats about the directory cache.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"make.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"job.h"
end_include

begin_comment
comment|/*  *	A search path consists of a Lst of Path structures. A Path structure  *	has in it the name of the directory and a hash table of all the files  *	in the directory. This is used to cut down on the number of system  *	calls necessary to find implicit dependents and their like. Since  *	these searches are made before any actions are taken, we need not  *	worry about the directory changing due to creation commands. If this  *	hampers the style of some makefiles, they must be changed.  *  *	A list of all previously-read directories is kept in the  *	openDirectories Lst. This list is checked first before a directory  *	is opened.  *  *	The need for the caching of whole directories is brought about by  *	the multi-level transformation code in suff.c, which tends to search  *	for far more files than regular make does. In the initial  *	implementation, the amount of time spent performing "stat" calls was  *	truly astronomical. The problem with hashing at the start is,  *	of course, that pmake doesn't then detect changes to these directories  *	during the course of the make. Three possibilities suggest themselves:  *  *	    1) just use stat to test for a file's existence. As mentioned  *	       above, this is very inefficient due to the number of checks  *	       engendered by the multi-level transformation code.  *	    2) use readdir() and company to search the directories, keeping  *	       them open between checks. I have tried this and while it  *	       didn't slow down the process too much, it could severely  *	       affect the amount of parallelism available as each directory  *	       open would take another file descriptor out of play for  *	       handling I/O for another job. Given that it is only recently  *	       that UNIX OS's have taken to allowing more than 20 or 32  *	       file descriptors for a process, this doesn't seem acceptable  *	       to me.  *	    3) record the mtime of the directory in the Path structure and  *	       verify the directory hasn't changed since the contents were  *	       hashed. This will catch the creation or deletion of files,  *	       but not the updating of files. However, since it is the  *	       creation and deletion that is the problem, this could be  *	       a good thing to do. Unfortunately, if the directory (say ".")  *	       were fairly large and changed fairly frequently, the constant  *	       rehashing could seriously degrade performance. It might be  *	       good in such cases to keep track of the number of rehashes  *	       and if the number goes over a (small) limit, resort to using  *	       stat in its place.  *  *	An additional thing to consider is that pmake is used primarily  *	to create C programs and until recently pcc-based compilers refused  *	to allow you to specify where the resulting object file should be  *	placed. This forced all objects to be created in the current  *	directory. This isn't meant as a full excuse, just an explanation of  *	some of the reasons for the caching used here.  *  *	One more note: the location of a target's file is only performed  *	on the downward traversal of the graph and then only for terminal  *	nodes in the graph. This could be construed as wrong in some cases,  *	but prevents inadvertent modification of files when the "installed"  *	directory for a file is provided in the search path.  *  *	Another data structure maintained by this module is an mtime  *	cache used when the searching of cached directories fails to find  *	a file. In the past, Dir_FindFile would simply perform an access()  *	call in such a case to determine if the file could be found using  *	just the name given. When this hit, however, all that was gained  *	was the knowledge that the file existed. Given that an access() is  *	essentially a stat() without the copyout() call, and that the same  *	filesystem overhead would have to be incurred in Dir_MTime, it made  *	sense to replace the access() with a stat() and record the mtime  *	in a cache for when Dir_MTime was actually called.  */
end_comment

begin_decl_stmt
name|Lst
name|dirSearchPath
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* main search path */
end_comment

begin_decl_stmt
specifier|static
name|Lst
name|openDirectories
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the list of all open directories */
end_comment

begin_comment
comment|/*  * Variables for gathering statistics on the efficiency of the hashing  * mechanism.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hits
decl_stmt|,
comment|/* Found in directory cache */
name|misses
decl_stmt|,
comment|/* Sad, but not evil misses */
name|nearmisses
decl_stmt|,
comment|/* Found under search path */
name|bigmisses
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sought by itself */
end_comment

begin_decl_stmt
specifier|static
name|Path
modifier|*
name|dot
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* contents of current directory */
end_comment

begin_decl_stmt
specifier|static
name|Path
modifier|*
name|cur
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* contents of current directory, if not dot */
end_comment

begin_decl_stmt
specifier|static
name|Path
modifier|*
name|dotLast
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a fake path entry indicating we need to 			     * look for . last */
end_comment

begin_decl_stmt
specifier|static
name|Hash_Table
name|mtimes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Results of doing a last-resort stat in 			     * Dir_FindFile -- if we have to go to the 			     * system to find the file, we might as well 			     * have its mtime on record. XXX: If this is done 			     * way early, there's a chance other rules will 			     * have already updated the file, in which case 			     * we'll update it again. Generally, there won't 			     * be two rules to update a single file, so this 			     * should be ok, but... */
end_comment

begin_decl_stmt
specifier|static
name|Hash_Table
name|lmtimes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* same as mtimes but for lstat */
end_comment

begin_function_decl
specifier|static
name|int
name|DirFindName
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|DirMatchFiles
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|Path
modifier|*
parameter_list|,
name|Lst
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|DirExpandCurly
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|Lst
parameter_list|,
name|Lst
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|DirExpandInt
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|Lst
parameter_list|,
name|Lst
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|DirPrintWord
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|DirPrintDir
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|DirLookup
parameter_list|(
name|Path
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|Boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|DirLookupSubdir
parameter_list|(
name|Path
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|DirFindDot
parameter_list|(
name|Boolean
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|DirLookupAbs
parameter_list|(
name|Path
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * We use stat(2) a lot, cache the results  * mtime and mode are all we care about.  */
end_comment

begin_struct
struct|struct
name|cache_st
block|{
name|time_t
name|mtime
decl_stmt|;
name|mode_t
name|mode
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* minimize changes below */
end_comment

begin_function
specifier|static
name|time_t
name|Hash_GetTimeValue
parameter_list|(
name|Hash_Entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|cache_st
modifier|*
name|cst
decl_stmt|;
name|cst
operator|=
name|entry
operator|->
name|clientPtr
expr_stmt|;
return|return
name|cst
operator|->
name|mtime
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CST_LSTAT
value|1
end_define

begin_define
define|#
directive|define
name|CST_UPDATE
value|2
end_define

begin_function
specifier|static
name|int
name|cached_stats
parameter_list|(
name|Hash_Table
modifier|*
name|htp
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|struct
name|stat
modifier|*
name|st
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|Hash_Entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|cache_st
modifier|*
name|cst
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
operator|!
name|pathname
operator|||
operator|!
name|pathname
index|[
literal|0
index|]
condition|)
return|return
operator|-
literal|1
return|;
name|entry
operator|=
name|Hash_FindEntry
argument_list|(
name|htp
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|&&
operator|(
name|flags
operator|&
name|CST_UPDATE
operator|)
operator|==
literal|0
condition|)
block|{
name|cst
operator|=
name|entry
operator|->
name|clientPtr
expr_stmt|;
name|memset
argument_list|(
name|st
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|st
argument_list|)
argument_list|)
expr_stmt|;
name|st
operator|->
name|st_mtime
operator|=
name|cst
operator|->
name|mtime
expr_stmt|;
name|st
operator|->
name|st_mode
operator|=
name|cst
operator|->
name|mode
expr_stmt|;
return|return
literal|0
return|;
block|}
name|rc
operator|=
operator|(
name|flags
operator|&
name|CST_LSTAT
operator|)
condition|?
name|lstat
argument_list|(
name|pathname
argument_list|,
name|st
argument_list|)
else|:
name|stat
argument_list|(
name|pathname
argument_list|,
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|st
operator|->
name|st_mtime
operator|==
literal|0
condition|)
name|st
operator|->
name|st_mtime
operator|=
literal|1
expr_stmt|;
comment|/* avoid confusion with missing file */
if|if
condition|(
operator|!
name|entry
condition|)
name|entry
operator|=
name|Hash_CreateEntry
argument_list|(
name|htp
argument_list|,
name|pathname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|entry
operator|->
name|clientPtr
condition|)
name|entry
operator|->
name|clientPtr
operator|=
name|bmake_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cst
argument_list|)
argument_list|)
expr_stmt|;
name|cst
operator|=
name|entry
operator|->
name|clientPtr
expr_stmt|;
name|cst
operator|->
name|mtime
operator|=
name|st
operator|->
name|st_mtime
expr_stmt|;
name|cst
operator|->
name|mode
operator|=
name|st
operator|->
name|st_mode
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|cached_stat
parameter_list|(
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|void
modifier|*
name|st
parameter_list|)
block|{
return|return
name|cached_stats
argument_list|(
operator|&
name|mtimes
argument_list|,
name|pathname
argument_list|,
name|st
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|cached_lstat
parameter_list|(
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|void
modifier|*
name|st
parameter_list|)
block|{
return|return
name|cached_stats
argument_list|(
operator|&
name|lmtimes
argument_list|,
name|pathname
argument_list|,
name|st
argument_list|,
name|CST_LSTAT
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Dir_Init --  *	initialize things for this module  *  * Results:  *	none  *  * Side Effects:  *	some directories may be opened.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Dir_Init
parameter_list|(
specifier|const
name|char
modifier|*
name|cdname
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cdname
condition|)
block|{
name|dirSearchPath
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|openDirectories
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|Hash_InitTable
argument_list|(
operator|&
name|mtimes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Hash_InitTable
argument_list|(
operator|&
name|lmtimes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|Dir_InitCur
argument_list|(
name|cdname
argument_list|)
expr_stmt|;
name|dotLast
operator|=
name|bmake_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Path
argument_list|)
argument_list|)
expr_stmt|;
name|dotLast
operator|->
name|refCount
operator|=
literal|1
expr_stmt|;
name|dotLast
operator|->
name|hits
operator|=
literal|0
expr_stmt|;
name|dotLast
operator|->
name|name
operator|=
name|bmake_strdup
argument_list|(
literal|".DOTLAST"
argument_list|)
expr_stmt|;
name|Hash_InitTable
argument_list|(
operator|&
name|dotLast
operator|->
name|files
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called by Dir_Init() and whenever .CURDIR is assigned to.  */
end_comment

begin_function
name|void
name|Dir_InitCur
parameter_list|(
specifier|const
name|char
modifier|*
name|cdname
parameter_list|)
block|{
name|Path
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|cdname
operator|!=
name|NULL
condition|)
block|{
comment|/* 	 * Our build directory is not the same as our source directory. 	 * Keep this one around too. 	 */
if|if
condition|(
operator|(
name|p
operator|=
name|Dir_AddDir
argument_list|(
name|NULL
argument_list|,
name|cdname
argument_list|)
operator|)
condition|)
block|{
name|p
operator|->
name|refCount
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|cur
operator|&&
name|cur
operator|!=
name|p
condition|)
block|{
comment|/* 		 * We've been here before, cleanup. 		 */
name|cur
operator|->
name|refCount
operator|-=
literal|1
expr_stmt|;
name|Dir_Destroy
argument_list|(
name|cur
argument_list|)
expr_stmt|;
block|}
name|cur
operator|=
name|p
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Dir_InitDot --  *	(re)initialize "dot" (current/object directory) path hash  *  * Results:  *	none  *  * Side Effects:  *	some directories may be opened.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Dir_InitDot
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|dot
operator|!=
name|NULL
condition|)
block|{
name|LstNode
name|ln
decl_stmt|;
comment|/* Remove old entry from openDirectories, but do not destroy. */
name|ln
operator|=
name|Lst_Member
argument_list|(
name|openDirectories
argument_list|,
name|dot
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_Remove
argument_list|(
name|openDirectories
argument_list|,
name|ln
argument_list|)
expr_stmt|;
block|}
name|dot
operator|=
name|Dir_AddDir
argument_list|(
name|NULL
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
if|if
condition|(
name|dot
operator|==
name|NULL
condition|)
block|{
name|Error
argument_list|(
literal|"Cannot open `.' (%s)"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*      * We always need to have dot around, so we increment its reference count      * to make sure it's not destroyed.      */
name|dot
operator|->
name|refCount
operator|+=
literal|1
expr_stmt|;
name|Dir_SetPATH
argument_list|()
expr_stmt|;
comment|/* initialize */
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Dir_End --  *	cleanup things for this module  *  * Results:  *	none  *  * Side Effects:  *	none  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Dir_End
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CLEANUP
if|if
condition|(
name|cur
condition|)
block|{
name|cur
operator|->
name|refCount
operator|-=
literal|1
expr_stmt|;
name|Dir_Destroy
argument_list|(
name|cur
argument_list|)
expr_stmt|;
block|}
name|dot
operator|->
name|refCount
operator|-=
literal|1
expr_stmt|;
name|dotLast
operator|->
name|refCount
operator|-=
literal|1
expr_stmt|;
name|Dir_Destroy
argument_list|(
name|dotLast
argument_list|)
expr_stmt|;
name|Dir_Destroy
argument_list|(
name|dot
argument_list|)
expr_stmt|;
name|Dir_ClearPath
argument_list|(
name|dirSearchPath
argument_list|)
expr_stmt|;
name|Lst_Destroy
argument_list|(
name|dirSearchPath
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|Dir_ClearPath
argument_list|(
name|openDirectories
argument_list|)
expr_stmt|;
name|Lst_Destroy
argument_list|(
name|openDirectories
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|Hash_DeleteTable
argument_list|(
operator|&
name|mtimes
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * We want ${.PATH} to indicate the order in which we will actually  * search, so we rebuild it after any .PATH: target.  * This is the simplest way to deal with the effect of .DOTLAST.  */
end_comment

begin_function
name|void
name|Dir_SetPATH
parameter_list|(
name|void
parameter_list|)
block|{
name|LstNode
name|ln
decl_stmt|;
comment|/* a list element */
name|Path
modifier|*
name|p
decl_stmt|;
name|Boolean
name|hasLastDot
init|=
name|FALSE
decl_stmt|;
comment|/* true we should search dot last */
name|Var_Delete
argument_list|(
literal|".PATH"
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|Lst_Open
argument_list|(
name|dirSearchPath
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
if|if
condition|(
operator|(
name|ln
operator|=
name|Lst_First
argument_list|(
name|dirSearchPath
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
operator|(
name|Path
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|dotLast
condition|)
block|{
name|hasLastDot
operator|=
name|TRUE
expr_stmt|;
name|Var_Append
argument_list|(
literal|".PATH"
argument_list|,
name|dotLast
operator|->
name|name
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|hasLastDot
condition|)
block|{
if|if
condition|(
name|dot
condition|)
name|Var_Append
argument_list|(
literal|".PATH"
argument_list|,
name|dot
operator|->
name|name
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
condition|)
name|Var_Append
argument_list|(
literal|".PATH"
argument_list|,
name|cur
operator|->
name|name
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|ln
operator|=
name|Lst_Next
argument_list|(
name|dirSearchPath
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
operator|(
name|Path
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|dotLast
condition|)
continue|continue;
if|if
condition|(
name|p
operator|==
name|dot
operator|&&
name|hasLastDot
condition|)
continue|continue;
name|Var_Append
argument_list|(
literal|".PATH"
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hasLastDot
condition|)
block|{
if|if
condition|(
name|dot
condition|)
name|Var_Append
argument_list|(
literal|".PATH"
argument_list|,
name|dot
operator|->
name|name
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
condition|)
name|Var_Append
argument_list|(
literal|".PATH"
argument_list|,
name|cur
operator|->
name|name
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
block|}
name|Lst_Close
argument_list|(
name|dirSearchPath
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * DirFindName --  *	See if the Path structure describes the same directory as the  *	given one by comparing their names. Called from Dir_AddDir via  *	Lst_Find when searching the list of open directories.  *  * Input:  *	p		Current name  *	dname		Desired name  *  * Results:  *	0 if it is the same. Non-zero otherwise  *  * Side Effects:  *	None  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|DirFindName
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|,
specifier|const
name|void
modifier|*
name|dname
parameter_list|)
block|{
return|return
operator|(
name|strcmp
argument_list|(
operator|(
operator|(
specifier|const
name|Path
operator|*
operator|)
name|p
operator|)
operator|->
name|name
argument_list|,
name|dname
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Dir_HasWildcards  --  *	see if the given name has any wildcard characters in it  *	be careful not to expand unmatching brackets or braces.  *	XXX: This code is not 100% correct. ([^]] fails etc.)   *	I really don't think that make(1) should be expanding  *	patterns, because then you have to set a mechanism for  *	escaping the expansion!  *  * Input:  *	name		name to check  *  * Results:  *	returns TRUE if the word should be expanded, FALSE otherwise  *  * Side Effects:  *	none  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|Boolean
name|Dir_HasWildcards
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|wild
init|=
literal|0
decl_stmt|,
name|brace
init|=
literal|0
decl_stmt|,
name|bracket
init|=
literal|0
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|name
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
case|case
literal|'{'
case|:
name|brace
operator|++
expr_stmt|;
name|wild
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
name|brace
operator|--
expr_stmt|;
break|break;
case|case
literal|'['
case|:
name|bracket
operator|++
expr_stmt|;
name|wild
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|']'
case|:
name|bracket
operator|--
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
case|case
literal|'*'
case|:
name|wild
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|wild
operator|&&
name|bracket
operator|==
literal|0
operator|&&
name|brace
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * DirMatchFiles --  * 	Given a pattern and a Path structure, see if any files  *	match the pattern and add their names to the 'expansions' list if  *	any do. This is incomplete -- it doesn't take care of patterns like  *	src / *src / *.c properly (just *.c on any of the directories), but it  *	will do for now.  *  * Input:  *	pattern		Pattern to look for  *	p		Directory to search  *	expansion	Place to store the results  *  * Results:  *	Always returns 0  *  * Side Effects:  *	File names are added to the expansions lst. The directory will be  *	fully hashed when this is done.  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|DirMatchFiles
parameter_list|(
specifier|const
name|char
modifier|*
name|pattern
parameter_list|,
name|Path
modifier|*
name|p
parameter_list|,
name|Lst
name|expansions
parameter_list|)
block|{
name|Hash_Search
name|search
decl_stmt|;
comment|/* Index into the directory's table */
name|Hash_Entry
modifier|*
name|entry
decl_stmt|;
comment|/* Current entry in the table */
name|Boolean
name|isDot
decl_stmt|;
comment|/* TRUE if the directory being searched is . */
name|isDot
operator|=
operator|(
operator|*
name|p
operator|->
name|name
operator|==
literal|'.'
operator|&&
name|p
operator|->
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
expr_stmt|;
for|for
control|(
name|entry
operator|=
name|Hash_EnumFirst
argument_list|(
operator|&
name|p
operator|->
name|files
argument_list|,
operator|&
name|search
argument_list|)
init|;
name|entry
operator|!=
name|NULL
condition|;
name|entry
operator|=
name|Hash_EnumNext
argument_list|(
operator|&
name|search
argument_list|)
control|)
block|{
comment|/* 	 * See if the file matches the given pattern. Note we follow the UNIX 	 * convention that dot files will only be found if the pattern 	 * begins with a dot (note also that as a side effect of the hashing 	 * scheme, .* won't match . or .. since they aren't hashed). 	 */
if|if
condition|(
name|Str_Match
argument_list|(
name|entry
operator|->
name|name
argument_list|,
name|pattern
argument_list|)
operator|&&
operator|(
operator|(
name|entry
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|'.'
operator|)
operator|||
operator|(
name|pattern
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|expansions
argument_list|,
operator|(
name|isDot
condition|?
name|bmake_strdup
argument_list|(
name|entry
operator|->
name|name
argument_list|)
else|:
name|str_concat
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|entry
operator|->
name|name
argument_list|,
name|STR_ADDSLASH
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * DirExpandCurly --  *	Expand curly braces like the C shell. Does this recursively.  *	Note the special case: if after the piece of the curly brace is  *	done there are no wildcard characters in the result, the result is  *	placed on the list WITHOUT CHECKING FOR ITS EXISTENCE.  *  * Input:  *	word		Entire word to expand  *	brace		First curly brace in it  *	path		Search path to use  *	expansions	Place to store the expansions  *  * Results:  *	None.  *  * Side Effects:  *	The given list is filled with the expansions...  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|DirExpandCurly
parameter_list|(
specifier|const
name|char
modifier|*
name|word
parameter_list|,
specifier|const
name|char
modifier|*
name|brace
parameter_list|,
name|Lst
name|path
parameter_list|,
name|Lst
name|expansions
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|end
decl_stmt|;
comment|/* Character after the closing brace */
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* Current position in brace clause */
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
comment|/* Start of current piece of brace clause */
name|int
name|bracelevel
decl_stmt|;
comment|/* Number of braces we've seen. If we see a 				 * right brace when this is 0, we've hit the 				 * end of the clause. */
name|char
modifier|*
name|file
decl_stmt|;
comment|/* Current expansion */
name|int
name|otherLen
decl_stmt|;
comment|/* The length of the other pieces of the 				 * expansion (chars before and after the 				 * clause in 'word') */
name|char
modifier|*
name|cp2
decl_stmt|;
comment|/* Pointer for checking for wildcards in 				 * expansion before calling Dir_Expand */
name|start
operator|=
name|brace
operator|+
literal|1
expr_stmt|;
comment|/*      * Find the end of the brace clause first, being wary of nested brace      * clauses.      */
for|for
control|(
name|end
operator|=
name|start
operator|,
name|bracelevel
operator|=
literal|0
init|;
operator|*
name|end
operator|!=
literal|'\0'
condition|;
name|end
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|end
operator|==
literal|'{'
condition|)
block|{
name|bracelevel
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|end
operator|==
literal|'}'
operator|)
operator|&&
operator|(
name|bracelevel
operator|--
operator|==
literal|0
operator|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|end
operator|==
literal|'\0'
condition|)
block|{
name|Error
argument_list|(
literal|"Unterminated {} clause \"%s\""
argument_list|,
name|start
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|end
operator|++
expr_stmt|;
block|}
name|otherLen
operator|=
name|brace
operator|-
name|word
operator|+
name|strlen
argument_list|(
name|end
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|start
init|;
name|cp
operator|<
name|end
condition|;
name|cp
operator|++
control|)
block|{
comment|/* 	 * Find the end of this piece of the clause. 	 */
name|bracelevel
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|','
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'{'
condition|)
block|{
name|bracelevel
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|'}'
operator|)
operator|&&
operator|(
name|bracelevel
operator|--
operator|<=
literal|0
operator|)
condition|)
block|{
break|break;
block|}
name|cp
operator|++
expr_stmt|;
block|}
comment|/* 	 * Allocate room for the combination and install the three pieces. 	 */
name|file
operator|=
name|bmake_malloc
argument_list|(
name|otherLen
operator|+
name|cp
operator|-
name|start
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|brace
operator|!=
name|word
condition|)
block|{
name|strncpy
argument_list|(
name|file
argument_list|,
name|word
argument_list|,
name|brace
operator|-
name|word
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|!=
name|start
condition|)
block|{
name|strncpy
argument_list|(
operator|&
name|file
index|[
name|brace
operator|-
name|word
index|]
argument_list|,
name|start
argument_list|,
name|cp
operator|-
name|start
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
operator|&
name|file
index|[
operator|(
name|brace
operator|-
name|word
operator|)
operator|+
operator|(
name|cp
operator|-
name|start
operator|)
index|]
argument_list|,
name|end
argument_list|)
expr_stmt|;
comment|/* 	 * See if the result has any wildcards in it. If we find one, call 	 * Dir_Expand right away, telling it to place the result on our list 	 * of expansions. 	 */
for|for
control|(
name|cp2
operator|=
name|file
init|;
operator|*
name|cp2
operator|!=
literal|'\0'
condition|;
name|cp2
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|cp2
condition|)
block|{
case|case
literal|'*'
case|:
case|case
literal|'?'
case|:
case|case
literal|'{'
case|:
case|case
literal|'['
case|:
name|Dir_Expand
argument_list|(
name|file
argument_list|,
name|path
argument_list|,
name|expansions
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
block|}
if|if
condition|(
operator|*
name|cp2
operator|==
literal|'\0'
condition|)
block|{
comment|/* 	     * Hit the end w/o finding any wildcards, so stick the expansion 	     * on the end of the list. 	     */
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|expansions
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|next
label|:
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
name|start
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * DirExpandInt --  *	Internal expand routine. Passes through the directories in the  *	path one by one, calling DirMatchFiles for each. NOTE: This still  *	doesn't handle patterns in directories...  *  * Input:  *	word		Word to expand  *	path		Path on which to look  *	expansions	Place to store the result  *  * Results:  *	None.  *  * Side Effects:  *	Things are added to the expansions list.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|DirExpandInt
parameter_list|(
specifier|const
name|char
modifier|*
name|word
parameter_list|,
name|Lst
name|path
parameter_list|,
name|Lst
name|expansions
parameter_list|)
block|{
name|LstNode
name|ln
decl_stmt|;
comment|/* Current node */
name|Path
modifier|*
name|p
decl_stmt|;
comment|/* Directory in the node */
if|if
condition|(
name|Lst_Open
argument_list|(
name|path
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
while|while
condition|(
operator|(
name|ln
operator|=
name|Lst_Next
argument_list|(
name|path
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
operator|(
name|Path
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|DirMatchFiles
argument_list|(
name|word
argument_list|,
name|p
argument_list|,
name|expansions
argument_list|)
expr_stmt|;
block|}
name|Lst_Close
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * DirPrintWord --  *	Print a word in the list of expansions. Callback for Dir_Expand  *	when DEBUG(DIR), via Lst_ForEach.  *  * Results:  *	=== 0  *  * Side Effects:  *	The passed word is printed, followed by a space.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|DirPrintWord
parameter_list|(
name|void
modifier|*
name|word
parameter_list|,
name|void
modifier|*
name|dummy
name|MAKE_ATTR_UNUSED
parameter_list|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"%s "
argument_list|,
operator|(
name|char
operator|*
operator|)
name|word
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Dir_Expand  --  *	Expand the given word into a list of words by globbing it looking  *	in the directories on the given search path.  *  * Input:  *	word		the word to expand  *	path		the list of directories in which to find the  *			resulting files  *	expansions	the list on which to place the results  *  * Results:  *	A list of words consisting of the files which exist along the search  *	path matching the given pattern.  *  * Side Effects:  *	Directories may be opened. Who knows?  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Dir_Expand
parameter_list|(
specifier|const
name|char
modifier|*
name|word
parameter_list|,
name|Lst
name|path
parameter_list|,
name|Lst
name|expansions
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"Expanding \"%s\"... "
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
name|strchr
argument_list|(
name|word
argument_list|,
literal|'{'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
name|DirExpandCurly
argument_list|(
name|word
argument_list|,
name|cp
argument_list|,
name|path
argument_list|,
name|expansions
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
name|strchr
argument_list|(
name|word
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
comment|/* 	     * The thing has a directory component -- find the first wildcard 	     * in the string. 	     */
for|for
control|(
name|cp
operator|=
name|word
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'?'
operator|||
operator|*
name|cp
operator|==
literal|'['
operator|||
operator|*
name|cp
operator|==
literal|'*'
operator|||
operator|*
name|cp
operator|==
literal|'{'
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'{'
condition|)
block|{
comment|/* 		 * This one will be fun. 		 */
name|DirExpandCurly
argument_list|(
name|word
argument_list|,
name|cp
argument_list|,
name|path
argument_list|,
name|expansions
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
comment|/* 		 * Back up to the start of the component 		 */
name|char
modifier|*
name|dirpath
decl_stmt|;
while|while
condition|(
name|cp
operator|>
name|word
operator|&&
operator|*
name|cp
operator|!=
literal|'/'
condition|)
block|{
name|cp
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|!=
name|word
condition|)
block|{
name|char
name|sc
decl_stmt|;
comment|/* 		     * If the glob isn't in the first component, try and find 		     * all the components up to the one with a wildcard. 		     */
name|sc
operator|=
name|cp
index|[
literal|1
index|]
expr_stmt|;
operator|(
operator|(
name|char
operator|*
operator|)
name|UNCONST
argument_list|(
name|cp
argument_list|)
operator|)
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dirpath
operator|=
name|Dir_FindFile
argument_list|(
name|word
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|(
operator|(
name|char
operator|*
operator|)
name|UNCONST
argument_list|(
name|cp
argument_list|)
operator|)
index|[
literal|1
index|]
operator|=
name|sc
expr_stmt|;
comment|/* 		     * dirpath is null if can't find the leading component 		     * XXX: Dir_FindFile won't find internal components. 		     * i.e. if the path contains ../Etc/Object and we're 		     * looking for Etc, it won't be found. Ah well. 		     * Probably not important. 		     */
if|if
condition|(
name|dirpath
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|dp
init|=
operator|&
name|dirpath
index|[
name|strlen
argument_list|(
name|dirpath
argument_list|)
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|dp
operator|==
literal|'/'
condition|)
operator|*
name|dp
operator|=
literal|'\0'
expr_stmt|;
name|path
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Dir_AddDir
argument_list|(
name|path
argument_list|,
name|dirpath
argument_list|)
expr_stmt|;
name|DirExpandInt
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
name|path
argument_list|,
name|expansions
argument_list|)
expr_stmt|;
name|Lst_Destroy
argument_list|(
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		     * Start the search from the local directory 		     */
name|DirExpandInt
argument_list|(
name|word
argument_list|,
name|path
argument_list|,
name|expansions
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Return the file -- this should never happen. 		 */
name|DirExpandInt
argument_list|(
name|word
argument_list|,
name|path
argument_list|,
name|expansions
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	     * First the files in dot 	     */
name|DirMatchFiles
argument_list|(
name|word
argument_list|,
name|dot
argument_list|,
name|expansions
argument_list|)
expr_stmt|;
comment|/* 	     * Then the files in every other directory on the path. 	     */
name|DirExpandInt
argument_list|(
name|word
argument_list|,
name|path
argument_list|,
name|expansions
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|Lst_ForEach
argument_list|(
name|expansions
argument_list|,
name|DirPrintWord
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * DirLookup  --  *	Find if the file with the given name exists in the given path.  *  * Results:  *	The path to the file or NULL. This path is guaranteed to be in a  *	different part of memory than name and so may be safely free'd.  *  * Side Effects:  *	None.  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|DirLookup
parameter_list|(
name|Path
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|name
name|MAKE_ATTR_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|cp
parameter_list|,
name|Boolean
name|hasSlash
name|MAKE_ATTR_UNUSED
parameter_list|)
block|{
name|char
modifier|*
name|file
decl_stmt|;
comment|/* the current filename to check */
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"   %s ...\n"
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Hash_FindEntry
argument_list|(
operator|&
name|p
operator|->
name|files
argument_list|,
name|cp
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|file
operator|=
name|str_concat
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|cp
argument_list|,
name|STR_ADDSLASH
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"   returning %s\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|hits
operator|+=
literal|1
expr_stmt|;
name|hits
operator|+=
literal|1
expr_stmt|;
return|return
name|file
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * DirLookupSubdir  --  *	Find if the file with the given name exists in the given path.  *  * Results:  *	The path to the file or NULL. This path is guaranteed to be in a  *	different part of memory than name and so may be safely free'd.  *  * Side Effects:  *	If the file is found, it is added in the modification times hash  *	table.  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|DirLookupSubdir
parameter_list|(
name|Path
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|stat
name|stb
decl_stmt|;
comment|/* Buffer for stat, if necessary */
name|char
modifier|*
name|file
decl_stmt|;
comment|/* the current filename to check */
if|if
condition|(
name|p
operator|!=
name|dot
condition|)
block|{
name|file
operator|=
name|str_concat
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|STR_ADDSLASH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * Checking in dot -- DON'T put a leading ./ on the thing. 	 */
name|file
operator|=
name|bmake_strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"checking %s ...\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cached_stat
argument_list|(
name|file
argument_list|,
operator|&
name|stb
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 	 * Save the modification time so if it's needed, we don't have 	 * to fetch it again. 	 */
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"   Caching %s for %s\n"
argument_list|,
name|Targ_FmtTime
argument_list|(
name|stb
operator|.
name|st_mtime
argument_list|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|nearmisses
operator|+=
literal|1
expr_stmt|;
return|return
operator|(
name|file
operator|)
return|;
block|}
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * DirLookupAbs  --  *	Find if the file with the given name exists in the given path.  *  * Results:  *	The path to the file, the empty string or NULL. If the file is  *	the empty string, the search should be terminated.  *	This path is guaranteed to be in a different part of memory  *	than name and so may be safely free'd.  *  * Side Effects:  *	None.  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|DirLookupAbs
parameter_list|(
name|Path
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|cp
parameter_list|)
block|{
name|char
modifier|*
name|p1
decl_stmt|;
comment|/* pointer into p->name */
specifier|const
name|char
modifier|*
name|p2
decl_stmt|;
comment|/* pointer into name */
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"   %s ...\n"
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the file has a leading path component and that component 	 * exactly matches the entire name of the current search 	 * directory, we can attempt another cache lookup. And if we don't 	 * have a hit, we can safely assume the file does not exist at all. 	 */
for|for
control|(
name|p1
operator|=
name|p
operator|->
name|name
operator|,
name|p2
operator|=
name|name
init|;
operator|*
name|p1
operator|&&
operator|*
name|p1
operator|==
operator|*
name|p2
condition|;
name|p1
operator|++
operator|,
name|p2
operator|++
control|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|*
name|p1
operator|!=
literal|'\0'
operator|||
name|p2
operator|!=
name|cp
operator|-
literal|1
condition|)
block|{
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|Hash_FindEntry
argument_list|(
operator|&
name|p
operator|->
name|files
argument_list|,
name|cp
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"   must be here but isn't -- returning\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Return empty string: terminates search */
return|return
name|bmake_strdup
argument_list|(
literal|""
argument_list|)
return|;
block|}
name|p
operator|->
name|hits
operator|+=
literal|1
expr_stmt|;
name|hits
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"   returning %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|bmake_strdup
argument_list|(
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * DirFindDot  --  *	Find the file given on "." or curdir  *  * Results:  *	The path to the file or NULL. This path is guaranteed to be in a  *	different part of memory than name and so may be safely free'd.  *  * Side Effects:  *	Hit counts change  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|DirFindDot
parameter_list|(
name|Boolean
name|hasSlash
name|MAKE_ATTR_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|cp
parameter_list|)
block|{
if|if
condition|(
name|Hash_FindEntry
argument_list|(
operator|&
name|dot
operator|->
name|files
argument_list|,
name|cp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"   in '.'\n"
argument_list|)
expr_stmt|;
block|}
name|hits
operator|+=
literal|1
expr_stmt|;
name|dot
operator|->
name|hits
operator|+=
literal|1
expr_stmt|;
return|return
operator|(
name|bmake_strdup
argument_list|(
name|name
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|cur
operator|&&
name|Hash_FindEntry
argument_list|(
operator|&
name|cur
operator|->
name|files
argument_list|,
name|cp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"   in ${.CURDIR} = %s\n"
argument_list|,
name|cur
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|hits
operator|+=
literal|1
expr_stmt|;
name|cur
operator|->
name|hits
operator|+=
literal|1
expr_stmt|;
return|return
name|str_concat
argument_list|(
name|cur
operator|->
name|name
argument_list|,
name|cp
argument_list|,
name|STR_ADDSLASH
argument_list|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Dir_FindFile  --  *	Find the file with the given name along the given search path.  *  * Input:  *	name		the file to find  *	path		the Lst of directories to search  *  * Results:  *	The path to the file or NULL. This path is guaranteed to be in a  *	different part of memory than name and so may be safely free'd.  *  * Side Effects:  *	If the file is found in a directory which is not on the path  *	already (either 'name' is absolute or it is a relative path  *	[ dir1/.../dirn/file ] which exists below one of the directories  *	already on the search path), its directory is added to the end  *	of the path on the assumption that there will be more files in  *	that directory later on. Sometimes this is true. Sometimes not.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|Dir_FindFile
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|Lst
name|path
parameter_list|)
block|{
name|LstNode
name|ln
decl_stmt|;
comment|/* a list element */
name|char
modifier|*
name|file
decl_stmt|;
comment|/* the current filename to check */
name|Path
modifier|*
name|p
decl_stmt|;
comment|/* current path member */
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* Terminal name of file */
name|Boolean
name|hasLastDot
init|=
name|FALSE
decl_stmt|;
comment|/* true we should search dot last */
name|Boolean
name|hasSlash
decl_stmt|;
comment|/* true if 'name' contains a / */
name|struct
name|stat
name|stb
decl_stmt|;
comment|/* Buffer for stat, if necessary */
name|Hash_Entry
modifier|*
name|entry
decl_stmt|;
comment|/* Entry for mtimes table */
specifier|const
name|char
modifier|*
name|trailing_dot
init|=
literal|"."
decl_stmt|;
comment|/*      * Find the final component of the name and note whether it has a      * slash in it (the name, I mean)      */
name|cp
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
name|hasSlash
operator|=
name|TRUE
expr_stmt|;
name|cp
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|hasSlash
operator|=
name|FALSE
expr_stmt|;
name|cp
operator|=
name|name
expr_stmt|;
block|}
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"Searching for %s ..."
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Lst_Open
argument_list|(
name|path
argument_list|)
operator|==
name|FAILURE
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"couldn't open path, file not found\n"
argument_list|)
expr_stmt|;
block|}
name|misses
operator|+=
literal|1
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|ln
operator|=
name|Lst_First
argument_list|(
name|path
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
operator|(
name|Path
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|dotLast
condition|)
block|{
name|hasLastDot
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"[dot last]..."
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/*      * If there's no leading directory components or if the leading      * directory component is exactly `./', consult the cached contents      * of each of the directories on the search path.      */
if|if
condition|(
operator|!
name|hasSlash
operator|||
operator|(
name|cp
operator|-
name|name
operator|==
literal|2
operator|&&
operator|*
name|name
operator|==
literal|'.'
operator|)
condition|)
block|{
comment|/* 	     * We look through all the directories on the path seeking one which 	     * contains the final component of the given name.  If such a beast 	     * is found, we concatenate the directory name and the final 	     * component and return the resulting string. If we don't find any 	     * such thing, we go on to phase two... 	     *  	     * No matter what, we always look for the file in the current 	     * directory before anywhere else (unless we found the magic 	     * DOTLAST path, in which case we search it last) and we *do not* 	     * add the ./ to it if it exists. 	     * This is so there are no conflicts between what the user 	     * specifies (fish.c) and what pmake finds (./fish.c). 	     */
if|if
condition|(
operator|!
name|hasLastDot
operator|&&
operator|(
name|file
operator|=
name|DirFindDot
argument_list|(
name|hasSlash
argument_list|,
name|name
argument_list|,
name|cp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|Lst_Close
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
name|file
return|;
block|}
while|while
condition|(
operator|(
name|ln
operator|=
name|Lst_Next
argument_list|(
name|path
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
operator|(
name|Path
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|dotLast
condition|)
continue|continue;
if|if
condition|(
operator|(
name|file
operator|=
name|DirLookup
argument_list|(
name|p
argument_list|,
name|name
argument_list|,
name|cp
argument_list|,
name|hasSlash
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|Lst_Close
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
name|file
return|;
block|}
block|}
if|if
condition|(
name|hasLastDot
operator|&&
operator|(
name|file
operator|=
name|DirFindDot
argument_list|(
name|hasSlash
argument_list|,
name|name
argument_list|,
name|cp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|Lst_Close
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
name|file
return|;
block|}
block|}
name|Lst_Close
argument_list|(
name|path
argument_list|)
expr_stmt|;
comment|/*      * We didn't find the file on any directory in the search path.      * If the name doesn't contain a slash, that means it doesn't exist.      * If it *does* contain a slash, however, there is still hope: it      * could be in a subdirectory of one of the members of the search      * path. (eg. /usr/include and sys/types.h. The above search would      * fail to turn up types.h in /usr/include, but it *is* in      * /usr/include/sys/types.h).      * [ This no longer applies: If we find such a beast, we assume there      * will be more (what else can we assume?) and add all but the last      * component of the resulting name onto the search path (at the      * end).]      * This phase is only performed if the file is *not* absolute.      */
if|if
condition|(
operator|!
name|hasSlash
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"   failed.\n"
argument_list|)
expr_stmt|;
block|}
name|misses
operator|+=
literal|1
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
comment|/* we were given a trailing "/" */
name|cp
operator|=
name|trailing_dot
expr_stmt|;
block|}
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
name|Boolean
name|checkedDot
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"   Trying subdirectories...\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hasLastDot
condition|)
block|{
if|if
condition|(
name|dot
condition|)
block|{
name|checkedDot
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|file
operator|=
name|DirLookupSubdir
argument_list|(
name|dot
argument_list|,
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|file
return|;
block|}
if|if
condition|(
name|cur
operator|&&
operator|(
name|file
operator|=
name|DirLookupSubdir
argument_list|(
name|cur
argument_list|,
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|file
return|;
block|}
operator|(
name|void
operator|)
name|Lst_Open
argument_list|(
name|path
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ln
operator|=
name|Lst_Next
argument_list|(
name|path
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
operator|(
name|Path
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|dotLast
condition|)
continue|continue;
if|if
condition|(
name|p
operator|==
name|dot
condition|)
block|{
if|if
condition|(
name|checkedDot
condition|)
continue|continue;
name|checkedDot
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|file
operator|=
name|DirLookupSubdir
argument_list|(
name|p
argument_list|,
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|Lst_Close
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
name|file
return|;
block|}
block|}
name|Lst_Close
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasLastDot
condition|)
block|{
if|if
condition|(
name|dot
operator|&&
operator|!
name|checkedDot
condition|)
block|{
name|checkedDot
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|file
operator|=
name|DirLookupSubdir
argument_list|(
name|dot
argument_list|,
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|file
return|;
block|}
if|if
condition|(
name|cur
operator|&&
operator|(
name|file
operator|=
name|DirLookupSubdir
argument_list|(
name|cur
argument_list|,
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|file
return|;
block|}
if|if
condition|(
name|checkedDot
condition|)
block|{
comment|/* 	     * Already checked by the given name, since . was in the path, 	     * so no point in proceeding... 	     */
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"   Checked . already, returning NULL\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
block|}
else|else
block|{
comment|/* name[0] == '/' */
comment|/* 	 * For absolute names, compare directory path prefix against the 	 * the directory path of each member on the search path for an exact 	 * match. If we have an exact match on any member of the search path, 	 * use the cached contents of that member to lookup the final file 	 * component. If that lookup fails we can safely assume that the 	 * file does not exist at all.  This is signified by DirLookupAbs() 	 * returning an empty string. 	 */
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"   Trying exact path matches...\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hasLastDot
operator|&&
name|cur
operator|&&
operator|(
operator|(
name|file
operator|=
name|DirLookupAbs
argument_list|(
name|cur
argument_list|,
name|name
argument_list|,
name|cp
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|file
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|file
return|;
block|}
operator|(
name|void
operator|)
name|Lst_Open
argument_list|(
name|path
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ln
operator|=
name|Lst_Next
argument_list|(
name|path
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
operator|(
name|Path
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|dotLast
condition|)
continue|continue;
if|if
condition|(
operator|(
name|file
operator|=
name|DirLookupAbs
argument_list|(
name|p
argument_list|,
name|name
argument_list|,
name|cp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|Lst_Close
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|file
return|;
block|}
block|}
name|Lst_Close
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasLastDot
operator|&&
name|cur
operator|&&
operator|(
operator|(
name|file
operator|=
name|DirLookupAbs
argument_list|(
name|cur
argument_list|,
name|name
argument_list|,
name|cp
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|file
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|file
return|;
block|}
block|}
comment|/*      * Didn't find it that way, either. Sigh. Phase 3. Add its directory      * onto the search path in any case, just in case, then look for the      * thing in the hash table. If we find it, grand. We return a new      * copy of the name. Otherwise we sadly return a NULL pointer. Sigh.      * Note that if the directory holding the file doesn't exist, this will      * do an extra search of the final directory on the path. Unless something      * weird happens, this search won't succeed and life will be groovy.      *      * Sigh. We cannot add the directory onto the search path because      * of this amusing case:      * $(INSTALLDIR)/$(FILE): $(FILE)      *      * $(FILE) exists in $(INSTALLDIR) but not in the current one.      * When searching for $(FILE), we will find it in $(INSTALLDIR)      * b/c we added it here. This is not good...      */
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|cp
operator|==
name|traling_dot
condition|)
block|{
name|cp
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|cp
operator|+=
literal|1
expr_stmt|;
block|}
name|cp
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|Dir_AddDir
argument_list|(
name|path
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|cp
index|[
operator|-
literal|1
index|]
operator|=
literal|'/'
expr_stmt|;
name|bigmisses
operator|+=
literal|1
expr_stmt|;
name|ln
operator|=
name|Lst_Last
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
else|else
block|{
name|p
operator|=
operator|(
name|Path
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Hash_FindEntry
argument_list|(
operator|&
name|p
operator|->
name|files
argument_list|,
name|cp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
return|return
operator|(
name|bmake_strdup
argument_list|(
name|name
argument_list|)
operator|)
return|;
block|}
else|else
block|{
return|return
name|NULL
return|;
block|}
else|#
directive|else
comment|/* !notdef */
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"   Looking for \"%s\" ...\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|bigmisses
operator|+=
literal|1
expr_stmt|;
name|entry
operator|=
name|Hash_FindEntry
argument_list|(
operator|&
name|mtimes
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"   got it (in mtime cache)\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|bmake_strdup
argument_list|(
name|name
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|cached_stat
argument_list|(
name|name
argument_list|,
operator|&
name|stb
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"   Caching %s for %s\n"
argument_list|,
name|Targ_FmtTime
argument_list|(
name|stb
operator|.
name|st_mtime
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|bmake_strdup
argument_list|(
name|name
argument_list|)
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"   failed. Returning NULL\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
endif|#
directive|endif
comment|/* notdef */
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Dir_FindHereOrAbove  --  *	search for a path starting at a given directory and then working   *	our way up towards the root.  *  * Input:  *	here		starting directory  *	search_path	the path we are looking for  *	result		the result of a successful search is placed here  *	rlen		the length of the result buffer   *			(typically MAXPATHLEN + 1)  *  * Results:  *	0 on failure, 1 on success [in which case the found path is put  *	in the result buffer].  *  * Side Effects:  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Dir_FindHereOrAbove
parameter_list|(
name|char
modifier|*
name|here
parameter_list|,
name|char
modifier|*
name|search_path
parameter_list|,
name|char
modifier|*
name|result
parameter_list|,
name|int
name|rlen
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|char
name|dirbase
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|,
modifier|*
name|db_end
decl_stmt|;
name|char
name|try
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|,
modifier|*
name|try_end
decl_stmt|;
comment|/* copy out our starting point */
name|snprintf
argument_list|(
name|dirbase
argument_list|,
sizeof|sizeof
argument_list|(
name|dirbase
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|here
argument_list|)
expr_stmt|;
name|db_end
operator|=
name|dirbase
operator|+
name|strlen
argument_list|(
name|dirbase
argument_list|)
expr_stmt|;
comment|/* loop until we determine a result */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* try and stat(2) it ... */
name|snprintf
argument_list|(
name|try
argument_list|,
sizeof|sizeof
argument_list|(
name|try
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|dirbase
argument_list|,
name|search_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|cached_stat
argument_list|(
name|try
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* 			 * success!  if we found a file, chop off 			 * the filename so we return a directory. 			 */
if|if
condition|(
operator|(
name|st
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFDIR
condition|)
block|{
name|try_end
operator|=
name|try
operator|+
name|strlen
argument_list|(
name|try
argument_list|)
expr_stmt|;
while|while
condition|(
name|try_end
operator|>
name|try
operator|&&
operator|*
name|try_end
operator|!=
literal|'/'
condition|)
name|try_end
operator|--
expr_stmt|;
if|if
condition|(
name|try_end
operator|>
name|try
condition|)
operator|*
name|try_end
operator|=
literal|0
expr_stmt|;
comment|/* chop! */
block|}
comment|/* 			 * done! 			 */
name|snprintf
argument_list|(
name|result
argument_list|,
name|rlen
argument_list|,
literal|"%s"
argument_list|,
name|try
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/*  		 * nope, we didn't find it.  if we used up dirbase we've 		 * reached the root and failed. 		 */
if|if
condition|(
name|db_end
operator|==
name|dirbase
condition|)
break|break;
comment|/* failed! */
comment|/* 		 * truncate dirbase from the end to move up a dir 		 */
while|while
condition|(
name|db_end
operator|>
name|dirbase
operator|&&
operator|*
name|db_end
operator|!=
literal|'/'
condition|)
name|db_end
operator|--
expr_stmt|;
operator|*
name|db_end
operator|=
literal|0
expr_stmt|;
comment|/* chop! */
block|}
comment|/* while (1) */
comment|/* 	 * we failed...  	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Dir_MTime  --  *	Find the modification time of the file described by gn along the  *	search path dirSearchPath.  *  * Input:  *	gn		the file whose modification time is desired  *  * Results:  *	The modification time or 0 if it doesn't exist  *  * Side Effects:  *	The modification time is placed in the node's mtime slot.  *	If the node didn't have a path entry before, and Dir_FindFile  *	found one for it, the full name is placed in the path slot.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Dir_MTime
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|,
name|Boolean
name|recheck
parameter_list|)
block|{
name|char
modifier|*
name|fullName
decl_stmt|;
comment|/* the full pathname of name */
name|struct
name|stat
name|stb
decl_stmt|;
comment|/* buffer for finding the mod time */
name|Hash_Entry
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_ARCHV
condition|)
block|{
return|return
name|Arch_MTime
argument_list|(
name|gn
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_PHONY
condition|)
block|{
name|gn
operator|->
name|mtime
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|gn
operator|->
name|path
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_NOPATH
condition|)
name|fullName
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|fullName
operator|=
name|Dir_FindFile
argument_list|(
name|gn
operator|->
name|name
argument_list|,
name|Suff_FindPath
argument_list|(
name|gn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullName
operator|==
name|NULL
operator|&&
name|gn
operator|->
name|flags
operator|&
name|FROM_DEPEND
operator|&&
operator|!
name|Lst_IsEmpty
argument_list|(
name|gn
operator|->
name|iParents
argument_list|)
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|strrchr
argument_list|(
name|gn
operator|->
name|name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
comment|/* 		     * This is an implied source, and it may have moved, 		     * see if we can find it via the current .PATH 		     */
name|cp
operator|++
expr_stmt|;
name|fullName
operator|=
name|Dir_FindFile
argument_list|(
name|cp
argument_list|,
name|Suff_FindPath
argument_list|(
name|gn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullName
condition|)
block|{
comment|/* 			 * Put the found file in gn->path 			 * so that we give that to the compiler. 			 */
name|gn
operator|->
name|path
operator|=
name|bmake_strdup
argument_list|(
name|fullName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Job_RunTarget
argument_list|(
literal|".STALE"
argument_list|,
name|gn
operator|->
name|fname
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s: %s, %d: ignoring stale %s for %s, "
literal|"found %s\n"
argument_list|,
name|progname
argument_list|,
name|gn
operator|->
name|fname
argument_list|,
name|gn
operator|->
name|lineno
argument_list|,
name|makeDependfile
argument_list|,
name|gn
operator|->
name|name
argument_list|,
name|fullName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"Found '%s' as '%s'\n"
argument_list|,
name|gn
operator|->
name|name
argument_list|,
name|fullName
condition|?
name|fullName
else|:
literal|"(not found)"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fullName
operator|=
name|gn
operator|->
name|path
expr_stmt|;
block|}
if|if
condition|(
name|fullName
operator|==
name|NULL
condition|)
block|{
name|fullName
operator|=
name|bmake_strdup
argument_list|(
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|recheck
condition|)
name|entry
operator|=
name|Hash_FindEntry
argument_list|(
operator|&
name|mtimes
argument_list|,
name|fullName
argument_list|)
expr_stmt|;
else|else
name|entry
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
name|stb
operator|.
name|st_mtime
operator|=
name|Hash_GetTimeValue
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"Using cached time %s for %s\n"
argument_list|,
name|Targ_FmtTime
argument_list|(
name|stb
operator|.
name|st_mtime
argument_list|)
argument_list|,
name|fullName
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|cached_stats
argument_list|(
operator|&
name|mtimes
argument_list|,
name|fullName
argument_list|,
operator|&
name|stb
argument_list|,
name|recheck
condition|?
name|CST_UPDATE
else|:
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|gn
operator|->
name|type
operator|&
name|OP_MEMBER
condition|)
block|{
if|if
condition|(
name|fullName
operator|!=
name|gn
operator|->
name|path
condition|)
name|free
argument_list|(
name|fullName
argument_list|)
expr_stmt|;
return|return
name|Arch_MemMTime
argument_list|(
name|gn
argument_list|)
return|;
block|}
else|else
block|{
name|stb
operator|.
name|st_mtime
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fullName
operator|&&
name|gn
operator|->
name|path
operator|==
name|NULL
condition|)
block|{
name|gn
operator|->
name|path
operator|=
name|fullName
expr_stmt|;
block|}
name|gn
operator|->
name|mtime
operator|=
name|stb
operator|.
name|st_mtime
expr_stmt|;
return|return
operator|(
name|gn
operator|->
name|mtime
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Dir_AddDir --  *	Add the given name to the end of the given path. The order of  *	the arguments is backwards so ParseDoDependency can do a  *	Lst_ForEach of its list of paths...  *  * Input:  *	path		the path to which the directory should be  *			added  *	name		the name of the directory to add  *  * Results:  *	none  *  * Side Effects:  *	A structure is added to the list and the directory is  *	read and hashed.  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|Path
modifier|*
name|Dir_AddDir
parameter_list|(
name|Lst
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|LstNode
name|ln
init|=
name|NULL
decl_stmt|;
comment|/* node in case Path structure is found */
name|Path
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
comment|/* pointer to new Path structure */
name|DIR
modifier|*
name|d
decl_stmt|;
comment|/* for reading directory */
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
comment|/* entry in directory */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".DOTLAST"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ln
operator|=
name|Lst_Find
argument_list|(
name|path
argument_list|,
name|name
argument_list|,
name|DirFindName
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|!=
name|NULL
condition|)
return|return
operator|(
name|Path
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
return|;
else|else
block|{
name|dotLast
operator|->
name|refCount
operator|+=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtFront
argument_list|(
name|path
argument_list|,
name|dotLast
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|path
condition|)
name|ln
operator|=
name|Lst_Find
argument_list|(
name|openDirectories
argument_list|,
name|name
argument_list|,
name|DirFindName
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
operator|(
name|Path
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|&&
name|Lst_Member
argument_list|(
name|path
argument_list|,
name|p
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|p
operator|->
name|refCount
operator|+=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|path
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"Caching %s ..."
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|d
operator|=
name|opendir
argument_list|(
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|bmake_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Path
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|bmake_strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|p
operator|->
name|hits
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|refCount
operator|=
literal|1
expr_stmt|;
name|Hash_InitTable
argument_list|(
operator|&
name|p
operator|->
name|files
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|d
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
operator|&&
name|defined
argument_list|(
name|d_ino
argument_list|)
comment|/* d_ino is a sunos4 #define for d_fileno */
comment|/* 		 * The sun directory library doesn't check for a 0 inode 		 * (0-inode slots just take up space), so we have to do 		 * it ourselves. 		 */
if|if
condition|(
name|dp
operator|->
name|d_fileno
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
endif|#
directive|endif
comment|/* sun&& d_ino */
operator|(
name|void
operator|)
name|Hash_CreateEntry
argument_list|(
operator|&
name|p
operator|->
name|files
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|d
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|openDirectories
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|path
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DEBUG
argument_list|(
name|DIR
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"done\n"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Dir_CopyDir --  *	Callback function for duplicating a search path via Lst_Duplicate.  *	Ups the reference count for the directory.  *  * Results:  *	Returns the Path it was given.  *  * Side Effects:  *	The refCount of the path is incremented.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
modifier|*
name|Dir_CopyDir
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
operator|(
operator|(
name|Path
operator|*
operator|)
name|p
operator|)
operator|->
name|refCount
operator|+=
literal|1
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Dir_MakeFlags --  *	Make a string by taking all the directories in the given search  *	path and preceding them by the given flag. Used by the suffix  *	module to create variables for compilers based on suffix search  *	paths.  *  * Input:  *	flag		flag which should precede each directory  *	path		list of directories  *  * Results:  *	The string mentioned above. Note that there is no space between  *	the given flag and each directory. The empty string is returned if  *	Things don't go well.  *  * Side Effects:  *	None  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|char
modifier|*
name|Dir_MakeFlags
parameter_list|(
specifier|const
name|char
modifier|*
name|flag
parameter_list|,
name|Lst
name|path
parameter_list|)
block|{
name|char
modifier|*
name|str
decl_stmt|;
comment|/* the string which will be returned */
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
comment|/* the current directory preceded by 'flag' */
name|LstNode
name|ln
decl_stmt|;
comment|/* the node of the current directory */
name|Path
modifier|*
name|p
decl_stmt|;
comment|/* the structure describing the current directory */
name|str
operator|=
name|bmake_strdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|Lst_Open
argument_list|(
name|path
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
while|while
condition|(
operator|(
name|ln
operator|=
name|Lst_Next
argument_list|(
name|path
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
operator|(
name|Path
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|s2
operator|=
name|str_concat
argument_list|(
name|flag
argument_list|,
name|p
operator|->
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|str
operator|=
name|str_concat
argument_list|(
name|s1
operator|=
name|str
argument_list|,
name|s2
argument_list|,
name|STR_ADDSPACE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s2
argument_list|)
expr_stmt|;
block|}
name|Lst_Close
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|str
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Dir_Destroy --  *	Nuke a directory descriptor, if possible. Callback procedure  *	for the suffixes module when destroying a search path.  *  * Input:  *	pp		The directory descriptor to nuke  *  * Results:  *	None.  *  * Side Effects:  *	If no other path references this directory (refCount == 0),  *	the Path and all its data are freed.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Dir_Destroy
parameter_list|(
name|void
modifier|*
name|pp
parameter_list|)
block|{
name|Path
modifier|*
name|p
init|=
operator|(
name|Path
operator|*
operator|)
name|pp
decl_stmt|;
name|p
operator|->
name|refCount
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|refCount
operator|==
literal|0
condition|)
block|{
name|LstNode
name|ln
decl_stmt|;
name|ln
operator|=
name|Lst_Member
argument_list|(
name|openDirectories
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_Remove
argument_list|(
name|openDirectories
argument_list|,
name|ln
argument_list|)
expr_stmt|;
name|Hash_DeleteTable
argument_list|(
operator|&
name|p
operator|->
name|files
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Dir_ClearPath --  *	Clear out all elements of the given search path. This is different  *	from destroying the list, notice.  *  * Input:  *	path		Path to clear  *  * Results:  *	None.  *  * Side Effects:  *	The path is set to the empty list.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Dir_ClearPath
parameter_list|(
name|Lst
name|path
parameter_list|)
block|{
name|Path
modifier|*
name|p
decl_stmt|;
while|while
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|p
operator|=
operator|(
name|Path
operator|*
operator|)
name|Lst_DeQueue
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|Dir_Destroy
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Dir_Concat --  *	Concatenate two paths, adding the second to the end of the first.  *	Makes sure to avoid duplicates.  *  * Input:  *	path1		Dest  *	path2		Source  *  * Results:  *	None  *  * Side Effects:  *	Reference counts for added dirs are upped.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Dir_Concat
parameter_list|(
name|Lst
name|path1
parameter_list|,
name|Lst
name|path2
parameter_list|)
block|{
name|LstNode
name|ln
decl_stmt|;
name|Path
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|ln
operator|=
name|Lst_First
argument_list|(
name|path2
argument_list|)
init|;
name|ln
operator|!=
name|NULL
condition|;
name|ln
operator|=
name|Lst_Succ
argument_list|(
name|ln
argument_list|)
control|)
block|{
name|p
operator|=
operator|(
name|Path
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|Lst_Member
argument_list|(
name|path1
argument_list|,
name|p
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|p
operator|->
name|refCount
operator|+=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|path1
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/********** DEBUG INFO **********/
end_comment

begin_function
name|void
name|Dir_PrintDirectories
parameter_list|(
name|void
parameter_list|)
block|{
name|LstNode
name|ln
decl_stmt|;
name|Path
modifier|*
name|p
decl_stmt|;
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"#*** Directory Cache:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"# Stats: %d hits %d misses %d near misses %d losers (%d%%)\n"
argument_list|,
name|hits
argument_list|,
name|misses
argument_list|,
name|nearmisses
argument_list|,
name|bigmisses
argument_list|,
operator|(
name|hits
operator|+
name|bigmisses
operator|+
name|nearmisses
condition|?
name|hits
operator|*
literal|100
operator|/
operator|(
name|hits
operator|+
name|bigmisses
operator|+
name|nearmisses
operator|)
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"# %-20s referenced\thits\n"
argument_list|,
literal|"directory"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Lst_Open
argument_list|(
name|openDirectories
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
while|while
condition|(
operator|(
name|ln
operator|=
name|Lst_Next
argument_list|(
name|openDirectories
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
operator|(
name|Path
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|ln
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"# %-20s %10d\t%4d\n"
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|refCount
argument_list|,
name|p
operator|->
name|hits
argument_list|)
expr_stmt|;
block|}
name|Lst_Close
argument_list|(
name|openDirectories
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|DirPrintDir
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|dummy
name|MAKE_ATTR_UNUSED
parameter_list|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"%s "
argument_list|,
operator|(
operator|(
name|Path
operator|*
operator|)
name|p
operator|)
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|Dir_PrintPath
parameter_list|(
name|Lst
name|path
parameter_list|)
block|{
name|Lst_ForEach
argument_list|(
name|path
argument_list|,
name|DirPrintDir
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

