begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: parse.c,v 1.218 2017/03/01 16:39:49 sjg Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 1988, 1989, 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Adam de Boor.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1989 by Berkeley Softworks  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Adam de Boor.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAKE_NATIVE
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$NetBSD: parse.c,v 1.218 2017/03/01 16:39:49 sjg Exp $"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_else
unit|static char sccsid[] = "@(#)parse.c	8.3 (Berkeley) 3/19/94";
else|#
directive|else
end_else

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$NetBSD: parse.c,v 1.218 2017/03/01 16:39:49 sjg Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*-  * parse.c --  *	Functions to parse a makefile.  *  *	One function, Parse_Init, must be called before any functions  *	in this module are used. After that, the function Parse_File is the  *	main entry point and controls most of the other functions in this  *	module.  *  *	Most important structures are kept in Lsts. Directories for  *	the .include "..." function are kept in the 'parseIncPath' Lst, while  *	those for the .include<...> are kept in the 'sysIncPath' Lst. The  *	targets currently being defined are kept in the 'targets' Lst.  *  *	The variables 'fname' and 'lineno' are used to track the name  *	of the current file and the line number in that file so that error  *	messages can be more meaningful.  *  * Interface:  *	Parse_Init	    	    Initialization function which must be  *	    	  	    	    called before anything else in this module  *	    	  	    	    is used.  *  *	Parse_End		    Cleanup the module  *  *	Parse_File	    	    Function used to parse a makefile. It must  *	    	  	    	    be given the name of the file, which should  *	    	  	    	    already have been opened, and a function  *	    	  	    	    to call to read a character from the file.  *  *	Parse_IsVar	    	    Returns TRUE if the given line is a  *	    	  	    	    variable assignment. Used by MainParseArgs  *	    	  	    	    to determine if an argument is a target  *	    	  	    	    or a variable assignment. Used internally  *	    	  	    	    for pretty much the same thing...  *  *	Parse_Error	    	    Function called when an error occurs in  *	    	  	    	    parsing. Used by the variable and  *	    	  	    	    conditional modules.  *	Parse_MainName	    	    Returns a Lst of the main target to create.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"make.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"job.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_MMAP
end_ifdef

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MAP_COPY
end_ifndef

begin_define
define|#
directive|define
name|MAP_COPY
value|MAP_PRIVATE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAP_FILE
end_ifndef

begin_define
define|#
directive|define
name|MAP_FILE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|// types and constants
end_comment

begin_comment
comment|/*  * Structure for a file being read ("included file")  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|IFile
block|{
name|char
modifier|*
name|fname
decl_stmt|;
comment|/* name of file */
name|int
name|lineno
decl_stmt|;
comment|/* current line number in file */
name|int
name|first_lineno
decl_stmt|;
comment|/* line number of start of text */
name|int
name|cond_depth
decl_stmt|;
comment|/* 'if' nesting when file opened */
name|Boolean
name|depending
decl_stmt|;
comment|/* state of doing_depend on EOF */
name|char
modifier|*
name|P_str
decl_stmt|;
comment|/* point to base of string buffer */
name|char
modifier|*
name|P_ptr
decl_stmt|;
comment|/* point to next char of string buffer */
name|char
modifier|*
name|P_end
decl_stmt|;
comment|/* point to the end of string buffer */
name|char
modifier|*
function_decl|(
modifier|*
name|nextbuf
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
comment|/* Function to get more data */
name|void
modifier|*
name|nextbuf_arg
decl_stmt|;
comment|/* Opaque arg for nextbuf() */
name|struct
name|loadedfile
modifier|*
name|lf
decl_stmt|;
comment|/* loadedfile object, if any */
block|}
name|IFile
typedef|;
end_typedef

begin_comment
comment|/*  * These values are returned by ParseEOF to tell Parse_File whether to  * CONTINUE parsing, i.e. it had only reached the end of an include file,  * or if it's DONE.  */
end_comment

begin_define
define|#
directive|define
name|CONTINUE
value|1
end_define

begin_define
define|#
directive|define
name|DONE
value|0
end_define

begin_comment
comment|/*  * Tokens for target attributes  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|Begin
block|,
comment|/* .BEGIN */
name|Default
block|,
comment|/* .DEFAULT */
name|DeleteOnError
block|,
comment|/* .DELETE_ON_ERROR */
name|End
block|,
comment|/* .END */
name|dotError
block|,
comment|/* .ERROR */
name|Ignore
block|,
comment|/* .IGNORE */
name|Includes
block|,
comment|/* .INCLUDES */
name|Interrupt
block|,
comment|/* .INTERRUPT */
name|Libs
block|,
comment|/* .LIBS */
name|Meta
block|,
comment|/* .META */
name|MFlags
block|,
comment|/* .MFLAGS or .MAKEFLAGS */
name|Main
block|,
comment|/* .MAIN and we don't have anything user-specified to 		     * make */
name|NoExport
block|,
comment|/* .NOEXPORT */
name|NoMeta
block|,
comment|/* .NOMETA */
name|NoMetaCmp
block|,
comment|/* .NOMETA_CMP */
name|NoPath
block|,
comment|/* .NOPATH */
name|Not
block|,
comment|/* Not special */
name|NotParallel
block|,
comment|/* .NOTPARALLEL */
name|Null
block|,
comment|/* .NULL */
name|ExObjdir
block|,
comment|/* .OBJDIR */
name|Order
block|,
comment|/* .ORDER */
name|Parallel
block|,
comment|/* .PARALLEL */
name|ExPath
block|,
comment|/* .PATH */
name|Phony
block|,
comment|/* .PHONY */
ifdef|#
directive|ifdef
name|POSIX
name|Posix
block|,
comment|/* .POSIX */
endif|#
directive|endif
name|Precious
block|,
comment|/* .PRECIOUS */
name|ExShell
block|,
comment|/* .SHELL */
name|Silent
block|,
comment|/* .SILENT */
name|SingleShell
block|,
comment|/* .SINGLESHELL */
name|Stale
block|,
comment|/* .STALE */
name|Suffixes
block|,
comment|/* .SUFFIXES */
name|Wait
block|,
comment|/* .WAIT */
name|Attribute
comment|/* Generic attribute */
block|}
name|ParseSpecial
typedef|;
end_typedef

begin_comment
comment|/*  * Other tokens  */
end_comment

begin_define
define|#
directive|define
name|LPAREN
value|'('
end_define

begin_define
define|#
directive|define
name|RPAREN
value|')'
end_define

begin_comment
comment|////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|// result data
end_comment

begin_comment
comment|/*  * The main target to create. This is the first target on the first  * dependency line in the first makefile.  */
end_comment

begin_decl_stmt
specifier|static
name|GNode
modifier|*
name|mainNode
decl_stmt|;
end_decl_stmt

begin_comment
comment|////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|// eval state
end_comment

begin_comment
comment|/* targets we're working on */
end_comment

begin_decl_stmt
specifier|static
name|Lst
name|targets
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CLEANUP
end_ifdef

begin_comment
comment|/* command lines for targets */
end_comment

begin_decl_stmt
specifier|static
name|Lst
name|targCmds
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * specType contains the SPECial TYPE of the current target. It is  * Not if the target is unspecial. If it *is* special, however, the children  * are linked as children of the parent but not vice versa. This variable is  * set in ParseDoDependency  */
end_comment

begin_decl_stmt
specifier|static
name|ParseSpecial
name|specType
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Predecessor node for handling .ORDER. Initialized to NULL when .ORDER  * seen, then set to each successive source on the line.  */
end_comment

begin_decl_stmt
specifier|static
name|GNode
modifier|*
name|predecessor
decl_stmt|;
end_decl_stmt

begin_comment
comment|////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|// parser state
end_comment

begin_comment
comment|/* true if currently in a dependency line or its commands */
end_comment

begin_decl_stmt
specifier|static
name|Boolean
name|inLine
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of fatal errors */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fatals
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Variables for doing includes  */
end_comment

begin_comment
comment|/* current file being read */
end_comment

begin_decl_stmt
specifier|static
name|IFile
modifier|*
name|curFile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stack of IFiles generated by .includes */
end_comment

begin_decl_stmt
specifier|static
name|Lst
name|includes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* include paths (lists of directories) */
end_comment

begin_decl_stmt
name|Lst
name|parseIncPath
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* dirs for "..." includes */
end_comment

begin_decl_stmt
name|Lst
name|sysIncPath
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* dirs for<...> includes */
end_comment

begin_decl_stmt
name|Lst
name|defIncPath
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default for sysIncPath */
end_comment

begin_comment
comment|////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|// parser tables
end_comment

begin_comment
comment|/*  * The parseKeywords table is searched using binary search when deciding  * if a target or source is special. The 'spec' field is the ParseSpecial  * type of the keyword ("Not" if the keyword isn't special as a target) while  * the 'op' field is the operator to apply to the list of targets if the  * keyword is used as a source ("0" if the keyword isn't special as a source)  */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of keyword */
name|ParseSpecial
name|spec
decl_stmt|;
comment|/* Type when used as a target */
name|int
name|op
decl_stmt|;
comment|/* Operator when used as a source */
block|}
name|parseKeywords
index|[]
init|=
block|{
block|{
literal|".BEGIN"
block|,
name|Begin
block|,
literal|0
block|}
block|,
block|{
literal|".DEFAULT"
block|,
name|Default
block|,
literal|0
block|}
block|,
block|{
literal|".DELETE_ON_ERROR"
block|,
name|DeleteOnError
block|,
literal|0
block|}
block|,
block|{
literal|".END"
block|,
name|End
block|,
literal|0
block|}
block|,
block|{
literal|".ERROR"
block|,
name|dotError
block|,
literal|0
block|}
block|,
block|{
literal|".EXEC"
block|,
name|Attribute
block|,
name|OP_EXEC
block|}
block|,
block|{
literal|".IGNORE"
block|,
name|Ignore
block|,
name|OP_IGNORE
block|}
block|,
block|{
literal|".INCLUDES"
block|,
name|Includes
block|,
literal|0
block|}
block|,
block|{
literal|".INTERRUPT"
block|,
name|Interrupt
block|,
literal|0
block|}
block|,
block|{
literal|".INVISIBLE"
block|,
name|Attribute
block|,
name|OP_INVISIBLE
block|}
block|,
block|{
literal|".JOIN"
block|,
name|Attribute
block|,
name|OP_JOIN
block|}
block|,
block|{
literal|".LIBS"
block|,
name|Libs
block|,
literal|0
block|}
block|,
block|{
literal|".MADE"
block|,
name|Attribute
block|,
name|OP_MADE
block|}
block|,
block|{
literal|".MAIN"
block|,
name|Main
block|,
literal|0
block|}
block|,
block|{
literal|".MAKE"
block|,
name|Attribute
block|,
name|OP_MAKE
block|}
block|,
block|{
literal|".MAKEFLAGS"
block|,
name|MFlags
block|,
literal|0
block|}
block|,
block|{
literal|".META"
block|,
name|Meta
block|,
name|OP_META
block|}
block|,
block|{
literal|".MFLAGS"
block|,
name|MFlags
block|,
literal|0
block|}
block|,
block|{
literal|".NOMETA"
block|,
name|NoMeta
block|,
name|OP_NOMETA
block|}
block|,
block|{
literal|".NOMETA_CMP"
block|,
name|NoMetaCmp
block|,
name|OP_NOMETA_CMP
block|}
block|,
block|{
literal|".NOPATH"
block|,
name|NoPath
block|,
name|OP_NOPATH
block|}
block|,
block|{
literal|".NOTMAIN"
block|,
name|Attribute
block|,
name|OP_NOTMAIN
block|}
block|,
block|{
literal|".NOTPARALLEL"
block|,
name|NotParallel
block|,
literal|0
block|}
block|,
block|{
literal|".NO_PARALLEL"
block|,
name|NotParallel
block|,
literal|0
block|}
block|,
block|{
literal|".NULL"
block|,
name|Null
block|,
literal|0
block|}
block|,
block|{
literal|".OBJDIR"
block|,
name|ExObjdir
block|,
literal|0
block|}
block|,
block|{
literal|".OPTIONAL"
block|,
name|Attribute
block|,
name|OP_OPTIONAL
block|}
block|,
block|{
literal|".ORDER"
block|,
name|Order
block|,
literal|0
block|}
block|,
block|{
literal|".PARALLEL"
block|,
name|Parallel
block|,
literal|0
block|}
block|,
block|{
literal|".PATH"
block|,
name|ExPath
block|,
literal|0
block|}
block|,
block|{
literal|".PHONY"
block|,
name|Phony
block|,
name|OP_PHONY
block|}
block|,
ifdef|#
directive|ifdef
name|POSIX
block|{
literal|".POSIX"
block|,
name|Posix
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
literal|".PRECIOUS"
block|,
name|Precious
block|,
name|OP_PRECIOUS
block|}
block|,
block|{
literal|".RECURSIVE"
block|,
name|Attribute
block|,
name|OP_MAKE
block|}
block|,
block|{
literal|".SHELL"
block|,
name|ExShell
block|,
literal|0
block|}
block|,
block|{
literal|".SILENT"
block|,
name|Silent
block|,
name|OP_SILENT
block|}
block|,
block|{
literal|".SINGLESHELL"
block|,
name|SingleShell
block|,
literal|0
block|}
block|,
block|{
literal|".STALE"
block|,
name|Stale
block|,
literal|0
block|}
block|,
block|{
literal|".SUFFIXES"
block|,
name|Suffixes
block|,
literal|0
block|}
block|,
block|{
literal|".USE"
block|,
name|Attribute
block|,
name|OP_USE
block|}
block|,
block|{
literal|".USEBEFORE"
block|,
name|Attribute
block|,
name|OP_USEBEFORE
block|}
block|,
block|{
literal|".WAIT"
block|,
name|Wait
block|,
literal|0
block|}
block|, }
struct|;
end_struct

begin_comment
comment|////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|// local functions
end_comment

begin_function_decl
specifier|static
name|int
name|ParseIsEscaped
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ParseErrorInternal
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|MAKE_ATTR_PRINTFLIKE
parameter_list|(
function_decl|4
operator|,
function_decl|5
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|void
name|ParseVErrorInternal
parameter_list|(
name|FILE
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|va_list
parameter_list|)
function_decl|MAKE_ATTR_PRINTFLIKE
parameter_list|(
function_decl|5
operator|,
function_decl|0
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|int
name|ParseFindKeyword
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ParseLinkSrc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ParseDoOp
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ParseDoSrc
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ParseFindMain
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ParseAddDir
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ParseClearPath
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ParseDoDependency
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ParseAddCmd
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ParseHasCommands
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ParseDoInclude
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ParseSetParseFile
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ParseSetIncludedFile
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SYSVINCLUDE
end_ifdef

begin_function_decl
specifier|static
name|void
name|ParseTraditionalInclude
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|GMAKEEXPORT
end_ifdef

begin_function_decl
specifier|static
name|void
name|ParseGmakeExport
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|ParseEOF
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|ParseReadLine
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ParseFinishLine
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ParseMark
parameter_list|(
name|GNode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|// file loader
end_comment

begin_struct
struct|struct
name|loadedfile
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* name, for error reports */
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* contents buffer */
name|size_t
name|len
decl_stmt|;
comment|/* length of contents */
name|size_t
name|maplen
decl_stmt|;
comment|/* length of mmap area, or 0 */
name|Boolean
name|used
decl_stmt|;
comment|/* XXX: have we used the data yet */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Constructor/destructor for loadedfile  */
end_comment

begin_function
specifier|static
name|struct
name|loadedfile
modifier|*
name|loadedfile_create
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|loadedfile
modifier|*
name|lf
decl_stmt|;
name|lf
operator|=
name|bmake_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|lf
argument_list|)
argument_list|)
expr_stmt|;
name|lf
operator|->
name|path
operator|=
operator|(
name|path
operator|==
name|NULL
condition|?
literal|"(stdin)"
else|:
name|path
operator|)
expr_stmt|;
name|lf
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
name|lf
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|lf
operator|->
name|maplen
operator|=
literal|0
expr_stmt|;
name|lf
operator|->
name|used
operator|=
name|FALSE
expr_stmt|;
return|return
name|lf
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|loadedfile_destroy
parameter_list|(
name|struct
name|loadedfile
modifier|*
name|lf
parameter_list|)
block|{
if|if
condition|(
name|lf
operator|->
name|buf
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|lf
operator|->
name|maplen
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_MMAP
name|munmap
argument_list|(
name|lf
operator|->
name|buf
argument_list|,
name|lf
operator|->
name|maplen
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|free
argument_list|(
name|lf
operator|->
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|lf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * nextbuf() operation for loadedfile, as needed by the weird and twisted  * logic below. Once that's cleaned up, we can get rid of lf->used...  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|loadedfile_nextbuf
parameter_list|(
name|void
modifier|*
name|x
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|loadedfile
modifier|*
name|lf
init|=
name|x
decl_stmt|;
if|if
condition|(
name|lf
operator|->
name|used
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|lf
operator|->
name|used
operator|=
name|TRUE
expr_stmt|;
operator|*
name|len
operator|=
name|lf
operator|->
name|len
expr_stmt|;
return|return
name|lf
operator|->
name|buf
return|;
block|}
end_function

begin_comment
comment|/*  * Try to get the size of a file.  */
end_comment

begin_function
specifier|static
name|ReturnStatus
name|load_getsize
parameter_list|(
name|int
name|fd
parameter_list|,
name|size_t
modifier|*
name|ret
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
name|FAILURE
return|;
block|}
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
return|return
name|FAILURE
return|;
block|}
comment|/* 	 * st_size is an off_t, which is 64 bits signed; *ret is 	 * size_t, which might be 32 bits unsigned or 64 bits 	 * unsigned. Rather than being elaborate, just punt on 	 * files that are more than 2^31 bytes. We should never 	 * see a makefile that size in practice... 	 * 	 * While we're at it reject negative sizes too, just in case. 	 */
if|if
condition|(
name|st
operator|.
name|st_size
operator|<
literal|0
operator|||
name|st
operator|.
name|st_size
operator|>
literal|0x7fffffff
condition|)
block|{
return|return
name|FAILURE
return|;
block|}
operator|*
name|ret
operator|=
operator|(
name|size_t
operator|)
name|st
operator|.
name|st_size
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*  * Read in a file.  *  * Until the path search logic can be moved under here instead of  * being in the caller in another source file, we need to have the fd  * passed in already open. Bleh.  *  * If the path is NULL use stdin and (to insure against fd leaks)  * assert that the caller passed in -1.  */
end_comment

begin_function
specifier|static
name|struct
name|loadedfile
modifier|*
name|loadfile
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|struct
name|loadedfile
modifier|*
name|lf
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_MMAP
name|long
name|pagesize
decl_stmt|;
endif|#
directive|endif
name|ssize_t
name|result
decl_stmt|;
name|size_t
name|bufpos
decl_stmt|;
name|lf
operator|=
name|loadedfile_create
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|fd
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fd
operator|=
name|STDIN_FILENO
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
literal|0
comment|/* notyet */
block|fd = open(path, O_RDONLY); 		if (fd< 0) { 			... 			Error("%s: %s", path, strerror(errno)); 			exit(1); 		}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|HAVE_MMAP
if|if
condition|(
name|load_getsize
argument_list|(
name|fd
argument_list|,
operator|&
name|lf
operator|->
name|len
argument_list|)
operator|==
name|SUCCESS
condition|)
block|{
comment|/* found a size, try mmap */
ifdef|#
directive|ifdef
name|_SC_PAGESIZE
name|pagesize
operator|=
name|sysconf
argument_list|(
name|_SC_PAGESIZE
argument_list|)
expr_stmt|;
else|#
directive|else
name|pagesize
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pagesize
operator|<=
literal|0
condition|)
block|{
name|pagesize
operator|=
literal|0x1000
expr_stmt|;
block|}
comment|/* round size up to a page */
name|lf
operator|->
name|maplen
operator|=
name|pagesize
operator|*
operator|(
operator|(
name|lf
operator|->
name|len
operator|+
name|pagesize
operator|-
literal|1
operator|)
operator|/
name|pagesize
operator|)
expr_stmt|;
comment|/* 		 * XXX hack for dealing with empty files; remove when 		 * we're no longer limited by interfacing to the old 		 * logic elsewhere in this file. 		 */
if|if
condition|(
name|lf
operator|->
name|maplen
operator|==
literal|0
condition|)
block|{
name|lf
operator|->
name|maplen
operator|=
name|pagesize
expr_stmt|;
block|}
comment|/* 		 * FUTURE: remove PROT_WRITE when the parser no longer 		 * needs to scribble on the input. 		 */
name|lf
operator|->
name|buf
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
name|lf
operator|->
name|maplen
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_FILE
operator||
name|MAP_COPY
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lf
operator|->
name|buf
operator|!=
name|MAP_FAILED
condition|)
block|{
comment|/* succeeded */
if|if
condition|(
name|lf
operator|->
name|len
operator|==
name|lf
operator|->
name|maplen
operator|&&
name|lf
operator|->
name|buf
index|[
name|lf
operator|->
name|len
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|char
modifier|*
name|b
init|=
name|malloc
argument_list|(
name|lf
operator|->
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|b
index|[
name|lf
operator|->
name|len
index|]
operator|=
literal|'\n'
expr_stmt|;
name|memcpy
argument_list|(
name|b
argument_list|,
name|lf
operator|->
name|buf
argument_list|,
name|lf
operator|->
name|len
operator|++
argument_list|)
expr_stmt|;
name|munmap
argument_list|(
name|lf
operator|->
name|buf
argument_list|,
name|lf
operator|->
name|maplen
argument_list|)
expr_stmt|;
name|lf
operator|->
name|maplen
operator|=
literal|0
expr_stmt|;
name|lf
operator|->
name|buf
operator|=
name|b
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* cannot mmap; load the traditional way */
name|lf
operator|->
name|maplen
operator|=
literal|0
expr_stmt|;
name|lf
operator|->
name|len
operator|=
literal|1024
expr_stmt|;
name|lf
operator|->
name|buf
operator|=
name|bmake_malloc
argument_list|(
name|lf
operator|->
name|len
argument_list|)
expr_stmt|;
name|bufpos
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|assert
argument_list|(
name|bufpos
operator|<=
name|lf
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufpos
operator|==
name|lf
operator|->
name|len
condition|)
block|{
name|lf
operator|->
name|len
operator|*=
literal|2
expr_stmt|;
name|lf
operator|->
name|buf
operator|=
name|bmake_realloc
argument_list|(
name|lf
operator|->
name|buf
argument_list|,
name|lf
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|lf
operator|->
name|buf
operator|+
name|bufpos
argument_list|,
name|lf
operator|->
name|len
operator|-
name|bufpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
name|Error
argument_list|(
literal|"%s: read error: %s"
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|bufpos
operator|+=
name|result
expr_stmt|;
block|}
name|assert
argument_list|(
name|bufpos
operator|<=
name|lf
operator|->
name|len
argument_list|)
expr_stmt|;
name|lf
operator|->
name|len
operator|=
name|bufpos
expr_stmt|;
comment|/* truncate malloc region to actual length (maybe not useful) */
if|if
condition|(
name|lf
operator|->
name|len
operator|>
literal|0
condition|)
block|{
comment|/* as for mmap case, ensure trailing \n */
if|if
condition|(
name|lf
operator|->
name|buf
index|[
name|lf
operator|->
name|len
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|lf
operator|->
name|len
operator|++
expr_stmt|;
name|lf
operator|->
name|buf
operator|=
name|bmake_realloc
argument_list|(
name|lf
operator|->
name|buf
argument_list|,
name|lf
operator|->
name|len
argument_list|)
expr_stmt|;
name|lf
operator|->
name|buf
index|[
name|lf
operator|->
name|len
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_MMAP
name|done
label|:
endif|#
directive|endif
if|if
condition|(
name|path
operator|!=
name|NULL
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
return|return
name|lf
return|;
block|}
end_function

begin_comment
comment|////////////////////////////////////////////////////////////
end_comment

begin_comment
comment|// old code
end_comment

begin_comment
comment|/*-  *----------------------------------------------------------------------  * ParseIsEscaped --  *	Check if the current character is escaped on the current line  *  * Results:  *	0 if the character is not backslash escaped, 1 otherwise  *  * Side Effects:  *	None  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|ParseIsEscaped
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|c
parameter_list|)
block|{
name|int
name|active
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|line
operator|==
name|c
condition|)
return|return
name|active
return|;
if|if
condition|(
operator|*
operator|--
name|c
operator|!=
literal|'\\'
condition|)
return|return
name|active
return|;
name|active
operator|=
operator|!
name|active
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *----------------------------------------------------------------------  * ParseFindKeyword --  *	Look in the table of keywords for one matching the given string.  *  * Input:  *	str		String to find  *  * Results:  *	The index of the keyword, or -1 if it isn't there.  *  * Side Effects:  *	None  *----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|ParseFindKeyword
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|int
name|start
decl_stmt|,
name|end
decl_stmt|,
name|cur
decl_stmt|;
name|int
name|diff
decl_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
name|end
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|parseKeywords
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|parseKeywords
index|[
literal|0
index|]
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
do|do
block|{
name|cur
operator|=
name|start
operator|+
operator|(
operator|(
name|end
operator|-
name|start
operator|)
operator|/
literal|2
operator|)
expr_stmt|;
name|diff
operator|=
name|strcmp
argument_list|(
name|str
argument_list|,
name|parseKeywords
index|[
name|cur
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|cur
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
block|{
name|end
operator|=
name|cur
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|start
operator|=
name|cur
operator|+
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
name|start
operator|<=
name|end
condition|)
do|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  * ParseVErrorInternal  --  *	Error message abort function for parsing. Prints out the context  *	of the error (line number and file) as well as the message with  *	two optional arguments.  *  * Results:  *	None  *  * Side Effects:  *	"fatals" is incremented if the level is PARSE_FATAL.  */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_function
specifier|static
name|void
name|ParseVErrorInternal
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
specifier|const
name|char
modifier|*
name|cfname
parameter_list|,
name|size_t
name|clineno
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
specifier|static
name|Boolean
name|fatal_warning_error_printed
init|=
name|FALSE
decl_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfname
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cfname
operator|!=
literal|'/'
operator|&&
name|strcmp
argument_list|(
name|cfname
argument_list|,
literal|"(stdin)"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
specifier|const
name|char
modifier|*
name|dir
decl_stmt|;
comment|/* 			 * Nothing is more annoying than not knowing 			 * which Makefile is the culprit. 			 */
name|dir
operator|=
name|Var_Value
argument_list|(
literal|".PARSEDIR"
argument_list|,
name|VAR_GLOBAL
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|NULL
operator|||
operator|*
name|dir
operator|==
literal|'\0'
operator|||
operator|(
operator|*
name|dir
operator|==
literal|'.'
operator|&&
name|dir
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
condition|)
name|dir
operator|=
name|Var_Value
argument_list|(
literal|".CURDIR"
argument_list|,
name|VAR_GLOBAL
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|NULL
condition|)
name|dir
operator|=
literal|"."
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|cfname
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s"
argument_list|,
name|cfname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\" line %d: "
argument_list|,
operator|(
name|int
operator|)
name|clineno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|PARSE_WARNING
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"warning: "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vfprintf
argument_list|(
name|f
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|PARSE_FATAL
operator|||
name|parseWarnFatal
condition|)
name|fatals
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|parseWarnFatal
operator|&&
operator|!
name|fatal_warning_error_printed
condition|)
block|{
name|Error
argument_list|(
literal|"parsing warnings being treated as errors"
argument_list|)
expr_stmt|;
name|fatal_warning_error_printed
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  * ParseErrorInternal  --  *	Error function  *  * Results:  *	None  *  * Side Effects:  *	None  */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_function
specifier|static
name|void
name|ParseErrorInternal
parameter_list|(
specifier|const
name|char
modifier|*
name|cfname
parameter_list|,
name|size_t
name|clineno
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|ParseVErrorInternal
argument_list|(
name|stderr
argument_list|,
name|cfname
argument_list|,
name|clineno
argument_list|,
name|type
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_file
operator|!=
name|stderr
operator|&&
name|debug_file
operator|!=
name|stdout
condition|)
block|{
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|ParseVErrorInternal
argument_list|(
name|debug_file
argument_list|,
name|cfname
argument_list|,
name|clineno
argument_list|,
name|type
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  * Parse_Error  --  *	External interface to ParseErrorInternal; uses the default filename  *	Line number.  *  * Results:  *	None  *  * Side Effects:  *	None  */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|void
name|Parse_Error
parameter_list|(
name|int
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|size_t
name|lineno
decl_stmt|;
if|if
condition|(
name|curFile
operator|==
name|NULL
condition|)
block|{
name|fname
operator|=
name|NULL
expr_stmt|;
name|lineno
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fname
operator|=
name|curFile
operator|->
name|fname
expr_stmt|;
name|lineno
operator|=
name|curFile
operator|->
name|lineno
expr_stmt|;
block|}
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|ParseVErrorInternal
argument_list|(
name|stderr
argument_list|,
name|fname
argument_list|,
name|lineno
argument_list|,
name|type
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_file
operator|!=
name|stderr
operator|&&
name|debug_file
operator|!=
name|stdout
condition|)
block|{
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|ParseVErrorInternal
argument_list|(
name|debug_file
argument_list|,
name|fname
argument_list|,
name|lineno
argument_list|,
name|type
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * ParseMessage  *	Parse a .info .warning or .error directive  *  *	The input is the line minus the ".".  We substitute  *	variables, print the message and exit(1) (for .error) or just print  *	a warning if the directive is malformed.  */
end_comment

begin_function
specifier|static
name|Boolean
name|ParseMessage
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
name|int
name|mtype
decl_stmt|;
switch|switch
condition|(
operator|*
name|line
condition|)
block|{
case|case
literal|'i'
case|:
name|mtype
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|mtype
operator|=
name|PARSE_WARNING
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|mtype
operator|=
name|PARSE_FATAL
expr_stmt|;
break|break;
default|default:
name|Parse_Error
argument_list|(
name|PARSE_WARNING
argument_list|,
literal|"invalid syntax: \".%s\""
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
while|while
condition|(
name|isalpha
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|line
argument_list|)
condition|)
name|line
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|line
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* not for us */
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|line
argument_list|)
condition|)
name|line
operator|++
expr_stmt|;
name|line
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|line
argument_list|,
name|VAR_CMD
argument_list|,
name|VARF_WANTRES
argument_list|)
expr_stmt|;
name|Parse_Error
argument_list|(
name|mtype
argument_list|,
literal|"%s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtype
operator|==
name|PARSE_FATAL
condition|)
block|{
comment|/* Terminate immediately. */
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*-  *---------------------------------------------------------------------  * ParseLinkSrc  --  *	Link the parent node to its new child. Used in a Lst_ForEach by  *	ParseDoDependency. If the specType isn't 'Not', the parent  *	isn't linked as a parent of the child.  *  * Input:  *	pgnp		The parent node  *	cgpn		The child node  *  * Results:  *	Always = 0  *  * Side Effects:  *	New elements are added to the parents list of cgn and the  *	children list of cgn. the unmade field of pgn is updated  *	to reflect the additional child.  *---------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|ParseLinkSrc
parameter_list|(
name|void
modifier|*
name|pgnp
parameter_list|,
name|void
modifier|*
name|cgnp
parameter_list|)
block|{
name|GNode
modifier|*
name|pgn
init|=
operator|(
name|GNode
operator|*
operator|)
name|pgnp
decl_stmt|;
name|GNode
modifier|*
name|cgn
init|=
operator|(
name|GNode
operator|*
operator|)
name|cgnp
decl_stmt|;
if|if
condition|(
operator|(
name|pgn
operator|->
name|type
operator|&
name|OP_DOUBLEDEP
operator|)
operator|&&
operator|!
name|Lst_IsEmpty
argument_list|(
name|pgn
operator|->
name|cohorts
argument_list|)
condition|)
name|pgn
operator|=
operator|(
name|GNode
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|Lst_Last
argument_list|(
name|pgn
operator|->
name|cohorts
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|pgn
operator|->
name|children
argument_list|,
name|cgn
argument_list|)
expr_stmt|;
if|if
condition|(
name|specType
operator|==
name|Not
condition|)
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|cgn
operator|->
name|parents
argument_list|,
name|pgn
argument_list|)
expr_stmt|;
name|pgn
operator|->
name|unmade
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|PARSE
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"# %s: added child %s - %s\n"
argument_list|,
name|__func__
argument_list|,
name|pgn
operator|->
name|name
argument_list|,
name|cgn
operator|->
name|name
argument_list|)
expr_stmt|;
name|Targ_PrintNode
argument_list|(
name|pgn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Targ_PrintNode
argument_list|(
name|cgn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *---------------------------------------------------------------------  * ParseDoOp  --  *	Apply the parsed operator to the given target node. Used in a  *	Lst_ForEach call by ParseDoDependency once all targets have  *	been found and their operator parsed. If the previous and new  *	operators are incompatible, a major error is taken.  *  * Input:  *	gnp		The node to which the operator is to be applied  *	opp		The operator to apply  *  * Results:  *	Always 0  *  * Side Effects:  *	The type field of the node is altered to reflect any new bits in  *	the op.  *---------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|ParseDoOp
parameter_list|(
name|void
modifier|*
name|gnp
parameter_list|,
name|void
modifier|*
name|opp
parameter_list|)
block|{
name|GNode
modifier|*
name|gn
init|=
operator|(
name|GNode
operator|*
operator|)
name|gnp
decl_stmt|;
name|int
name|op
init|=
operator|*
operator|(
name|int
operator|*
operator|)
name|opp
decl_stmt|;
comment|/*      * If the dependency mask of the operator and the node don't match and      * the node has actually had an operator applied to it before, and      * the operator actually has some dependency information in it, complain.      */
if|if
condition|(
operator|(
operator|(
name|op
operator|&
name|OP_OPMASK
operator|)
operator|!=
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_OPMASK
operator|)
operator|)
operator|&&
operator|!
name|OP_NOP
argument_list|(
name|gn
operator|->
name|type
argument_list|)
operator|&&
operator|!
name|OP_NOP
argument_list|(
name|op
argument_list|)
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Inconsistent operator for %s"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|op
operator|==
name|OP_DOUBLEDEP
operator|)
operator|&&
operator|(
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_OPMASK
operator|)
operator|==
name|OP_DOUBLEDEP
operator|)
condition|)
block|{
comment|/* 	 * If the node was the object of a :: operator, we need to create a 	 * new instance of it for the children and commands on this dependency 	 * line. The new instance is placed on the 'cohorts' list of the 	 * initial one (note the initial one is not on its own cohorts list) 	 * and the new instance is linked to all parents of the initial 	 * instance. 	 */
name|GNode
modifier|*
name|cohort
decl_stmt|;
comment|/* 	 * Propagate copied bits to the initial node.  They'll be propagated 	 * back to the rest of the cohorts later. 	 */
name|gn
operator|->
name|type
operator||=
name|op
operator|&
operator|~
name|OP_OPMASK
expr_stmt|;
name|cohort
operator|=
name|Targ_FindNode
argument_list|(
name|gn
operator|->
name|name
argument_list|,
name|TARG_NOHASH
argument_list|)
expr_stmt|;
if|if
condition|(
name|doing_depend
condition|)
name|ParseMark
argument_list|(
name|cohort
argument_list|)
expr_stmt|;
comment|/* 	 * Make the cohort invisible as well to avoid duplicating it into 	 * other variables. True, parents of this target won't tend to do 	 * anything with their local variables, but better safe than 	 * sorry. (I think this is pointless now, since the relevant list 	 * traversals will no longer see this node anyway. -mycroft) 	 */
name|cohort
operator|->
name|type
operator|=
name|op
operator||
name|OP_INVISIBLE
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|gn
operator|->
name|cohorts
argument_list|,
name|cohort
argument_list|)
expr_stmt|;
name|cohort
operator|->
name|centurion
operator|=
name|gn
expr_stmt|;
name|gn
operator|->
name|unmade_cohorts
operator|+=
literal|1
expr_stmt|;
name|snprintf
argument_list|(
name|cohort
operator|->
name|cohort_num
argument_list|,
sizeof|sizeof
name|cohort
operator|->
name|cohort_num
argument_list|,
literal|"#%d"
argument_list|,
name|gn
operator|->
name|unmade_cohorts
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * We don't want to nuke any previous flags (whatever they were) so we 	 * just OR the new operator into the old 	 */
name|gn
operator|->
name|type
operator||=
name|op
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *---------------------------------------------------------------------  * ParseDoSrc  --  *	Given the name of a source, figure out if it is an attribute  *	and apply it to the targets if it is. Else decide if there is  *	some attribute which should be applied *to* the source because  *	of some special target and apply it if so. Otherwise, make the  *	source be a child of the targets in the list 'targets'  *  * Input:  *	tOp		operator (if any) from special targets  *	src		name of the source to handle  *  * Results:  *	None  *  * Side Effects:  *	Operator bits may be added to the list of targets or to the source.  *	The targets may have a new source added to their lists of children.  *---------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|ParseDoSrc
parameter_list|(
name|int
name|tOp
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
name|GNode
modifier|*
name|gn
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|wait_number
init|=
literal|0
decl_stmt|;
name|char
name|wait_src
index|[
literal|16
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|src
operator|==
literal|'.'
operator|&&
name|isupper
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|src
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|int
name|keywd
init|=
name|ParseFindKeyword
argument_list|(
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
name|keywd
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|op
init|=
name|parseKeywords
index|[
name|keywd
index|]
operator|.
name|op
decl_stmt|;
if|if
condition|(
name|op
operator|!=
literal|0
condition|)
block|{
name|Lst_ForEach
argument_list|(
name|targets
argument_list|,
name|ParseDoOp
argument_list|,
operator|&
name|op
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|parseKeywords
index|[
name|keywd
index|]
operator|.
name|spec
operator|==
name|Wait
condition|)
block|{
comment|/* 		 * We add a .WAIT node in the dependency list. 		 * After any dynamic dependencies (and filename globbing) 		 * have happened, it is given a dependency on the each 		 * previous child back to and previous .WAIT node. 		 * The next child won't be scheduled until the .WAIT node 		 * is built. 		 * We give each .WAIT node a unique name (mainly for diag). 		 */
name|snprintf
argument_list|(
name|wait_src
argument_list|,
sizeof|sizeof
name|wait_src
argument_list|,
literal|".WAIT_%u"
argument_list|,
operator|++
name|wait_number
argument_list|)
expr_stmt|;
name|gn
operator|=
name|Targ_FindNode
argument_list|(
name|wait_src
argument_list|,
name|TARG_NOHASH
argument_list|)
expr_stmt|;
if|if
condition|(
name|doing_depend
condition|)
name|ParseMark
argument_list|(
name|gn
argument_list|)
expr_stmt|;
name|gn
operator|->
name|type
operator|=
name|OP_WAIT
operator||
name|OP_PHONY
operator||
name|OP_DEPENDS
operator||
name|OP_NOTMAIN
expr_stmt|;
name|Lst_ForEach
argument_list|(
name|targets
argument_list|,
name|ParseLinkSrc
argument_list|,
name|gn
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
switch|switch
condition|(
name|specType
condition|)
block|{
case|case
name|Main
case|:
comment|/* 	 * If we have noted the existence of a .MAIN, it means we need 	 * to add the sources of said target to the list of things 	 * to create. The string 'src' is likely to be free, so we 	 * must make a new copy of it. Note that this will only be 	 * invoked if the user didn't specify a target on the command 	 * line. This is to allow #ifmake's to succeed, or something... 	 */
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|create
argument_list|,
name|bmake_strdup
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Add the name to the .TARGETS variable as well, so the user can 	 * employ that, if desired. 	 */
name|Var_Append
argument_list|(
literal|".TARGETS"
argument_list|,
name|src
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
return|return;
case|case
name|Order
case|:
comment|/* 	 * Create proper predecessor/successor links between the previous 	 * source and the current one. 	 */
name|gn
operator|=
name|Targ_FindNode
argument_list|(
name|src
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|doing_depend
condition|)
name|ParseMark
argument_list|(
name|gn
argument_list|)
expr_stmt|;
if|if
condition|(
name|predecessor
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|predecessor
operator|->
name|order_succ
argument_list|,
name|gn
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|gn
operator|->
name|order_pred
argument_list|,
name|predecessor
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|PARSE
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"# %s: added Order dependency %s - %s\n"
argument_list|,
name|__func__
argument_list|,
name|predecessor
operator|->
name|name
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
name|Targ_PrintNode
argument_list|(
name|predecessor
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Targ_PrintNode
argument_list|(
name|gn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * The current source now becomes the predecessor for the next one. 	 */
name|predecessor
operator|=
name|gn
expr_stmt|;
break|break;
default|default:
comment|/* 	 * If the source is not an attribute, we need to find/create 	 * a node for it. After that we can apply any operator to it 	 * from a special target or link it to its parents, as 	 * appropriate. 	 * 	 * In the case of a source that was the object of a :: operator, 	 * the attribute is applied to all of its instances (as kept in 	 * the 'cohorts' list of the node) or all the cohorts are linked 	 * to all the targets. 	 */
comment|/* Find/create the 'src' node and attach to all targets */
name|gn
operator|=
name|Targ_FindNode
argument_list|(
name|src
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|doing_depend
condition|)
name|ParseMark
argument_list|(
name|gn
argument_list|)
expr_stmt|;
if|if
condition|(
name|tOp
condition|)
block|{
name|gn
operator|->
name|type
operator||=
name|tOp
expr_stmt|;
block|}
else|else
block|{
name|Lst_ForEach
argument_list|(
name|targets
argument_list|,
name|ParseLinkSrc
argument_list|,
name|gn
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * ParseFindMain --  *	Find a real target in the list and set it to be the main one.  *	Called by ParseDoDependency when a main target hasn't been found  *	yet.  *  * Input:  *	gnp		Node to examine  *  * Results:  *	0 if main not found yet, 1 if it is.  *  * Side Effects:  *	mainNode is changed and Targ_SetMain is called.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|ParseFindMain
parameter_list|(
name|void
modifier|*
name|gnp
parameter_list|,
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|GNode
modifier|*
name|gn
init|=
operator|(
name|GNode
operator|*
operator|)
name|gnp
decl_stmt|;
if|if
condition|(
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_NOTARGET
operator|)
operator|==
literal|0
condition|)
block|{
name|mainNode
operator|=
name|gn
expr_stmt|;
name|Targ_SetMain
argument_list|(
name|gn
argument_list|)
expr_stmt|;
return|return
operator|(
name|dummy
condition|?
literal|1
else|:
literal|1
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|dummy
condition|?
literal|0
else|:
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * ParseAddDir --  *	Front-end for Dir_AddDir to make sure Lst_ForEach keeps going  *  * Results:  *	=== 0  *  * Side Effects:  *	See Dir_AddDir.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|ParseAddDir
parameter_list|(
name|void
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|name
parameter_list|)
block|{
operator|(
name|void
operator|)
name|Dir_AddDir
argument_list|(
operator|(
name|Lst
operator|)
name|path
argument_list|,
operator|(
name|char
operator|*
operator|)
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * ParseClearPath --  *	Front-end for Dir_ClearPath to make sure Lst_ForEach keeps going  *  * Results:  *	=== 0  *  * Side Effects:  *	See Dir_ClearPath  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|ParseClearPath
parameter_list|(
name|void
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|Dir_ClearPath
argument_list|(
operator|(
name|Lst
operator|)
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|dummy
condition|?
literal|0
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *---------------------------------------------------------------------  * ParseDoDependency  --  *	Parse the dependency line in line.  *  * Input:  *	line		the line to parse  *  * Results:  *	None  *  * Side Effects:  *	The nodes of the sources are linked as children to the nodes of the  *	targets. Some nodes may be created.  *  *	We parse a dependency line by first extracting words from the line and  * finding nodes in the list of all targets with that name. This is done  * until a character is encountered which is an operator character. Currently  * these are only ! and :. At this point the operator is parsed and the  * pointer into the line advanced until the first source is encountered.  * 	The parsed operator is applied to each node in the 'targets' list,  * which is where the nodes found for the targets are kept, by means of  * the ParseDoOp function.  *	The sources are read in much the same way as the targets were except  * that now they are expanded using the wildcarding scheme of the C-Shell  * and all instances of the resulting words in the list of all targets  * are found. Each of the resulting nodes is then linked to each of the  * targets as one of its children.  *	Certain targets are handled specially. These are the ones detailed  * by the specType variable.  *	The storing of transformation rules is also taken care of here.  * A target is recognized as a transformation rule by calling  * Suff_IsTransform. If it is a transformation rule, its node is gotten  * from the suffix module via Suff_AddTransform rather than the standard  * Targ_FindNode in the target module.  *---------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|ParseDoDependency
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* our current position */
name|GNode
modifier|*
name|gn
init|=
name|NULL
decl_stmt|;
comment|/* a general purpose temporary node */
name|int
name|op
decl_stmt|;
comment|/* the operator on the line */
name|char
name|savec
decl_stmt|;
comment|/* a place to save a character */
name|Lst
name|paths
decl_stmt|;
comment|/* List of search paths to alter when parsing 				 * a list of .PATH targets */
name|int
name|tOp
decl_stmt|;
comment|/* operator from special target */
name|Lst
name|sources
decl_stmt|;
comment|/* list of archive source names after 				 * expansion */
name|Lst
name|curTargs
decl_stmt|;
comment|/* list of target names to be found and added 				 * to the targets list */
name|char
modifier|*
name|lstart
init|=
name|line
decl_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|PARSE
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"ParseDoDependency(%s)\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|tOp
operator|=
literal|0
expr_stmt|;
name|specType
operator|=
name|Not
expr_stmt|;
name|paths
operator|=
name|NULL
expr_stmt|;
name|curTargs
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
comment|/*      * First, grind through the targets.      */
do|do
block|{
comment|/* 	 * Here LINE points to the beginning of the next word, and 	 * LSTART points to the actual beginning of the line. 	 */
comment|/* Find the end of the next word. */
for|for
control|(
name|cp
operator|=
name|line
init|;
operator|*
name|cp
operator|&&
operator|(
name|ParseIsEscaped
argument_list|(
name|lstart
argument_list|,
name|cp
argument_list|)
operator|||
operator|!
operator|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
operator|||
operator|*
name|cp
operator|==
literal|'!'
operator|||
operator|*
name|cp
operator|==
literal|':'
operator|||
operator|*
name|cp
operator|==
name|LPAREN
operator|)
operator|)
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'$'
condition|)
block|{
comment|/* 		 * Must be a dynamic source (would have been expanded 		 * otherwise), so call the Var module to parse the puppy 		 * so we can safely advance beyond it...There should be 		 * no errors in this, as they would have been discovered 		 * in the initial Var_Subst and we wouldn't be here. 		 */
name|int
name|length
decl_stmt|;
name|void
modifier|*
name|freeIt
decl_stmt|;
operator|(
name|void
operator|)
name|Var_Parse
argument_list|(
name|cp
argument_list|,
name|VAR_CMD
argument_list|,
name|VARF_UNDEFERR
operator||
name|VARF_WANTRES
argument_list|,
operator|&
name|length
argument_list|,
operator|&
name|freeIt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|freeIt
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|length
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * If the word is followed by a left parenthesis, it's the 	 * name of an object file inside an archive (ar file). 	 */
if|if
condition|(
operator|!
name|ParseIsEscaped
argument_list|(
name|lstart
argument_list|,
name|cp
argument_list|)
operator|&&
operator|*
name|cp
operator|==
name|LPAREN
condition|)
block|{
comment|/* 	     * Archives must be handled specially to make sure the OP_ARCHV 	     * flag is set in their 'type' field, for one thing, and because 	     * things like "archive(file1.o file2.o file3.o)" are permissible. 	     * Arch_ParseArchive will set 'line' to be the first non-blank 	     * after the archive-spec. It creates/finds nodes for the members 	     * and places them on the given list, returning SUCCESS if all 	     * went well and FAILURE if there was an error in the 	     * specification. On error, line should remain untouched. 	     */
if|if
condition|(
name|Arch_ParseArchive
argument_list|(
operator|&
name|line
argument_list|,
name|targets
argument_list|,
name|VAR_CMD
argument_list|)
operator|!=
name|SUCCESS
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Error in archive specification: \"%s\""
argument_list|,
name|line
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
else|else
block|{
comment|/* Done with this word; on to the next. */
name|cp
operator|=
name|line
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
operator|!
operator|*
name|cp
condition|)
block|{
comment|/* 	     * We got to the end of the line while we were still 	     * looking at targets. 	     * 	     * Ending a dependency line without an operator is a Bozo 	     * no-no.  As a heuristic, this is also often triggered by 	     * undetected conflicts from cvs/rcs merges. 	     */
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"<<<<<<"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"======"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|">>>>>>"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Makefile appears to contain unresolved cvs/rcs/??? merge conflicts"
argument_list|)
expr_stmt|;
else|else
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
name|lstart
index|[
literal|0
index|]
operator|==
literal|'.'
condition|?
literal|"Unknown directive"
else|:
literal|"Need an operator"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Insert a null terminator. */
name|savec
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * Got the word. See if it's a special target and if so set 	 * specType to match it. 	 */
if|if
condition|(
operator|*
name|line
operator|==
literal|'.'
operator|&&
name|isupper
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|line
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* 	     * See if the target is a special target that must have it 	     * or its sources handled specially. 	     */
name|int
name|keywd
init|=
name|ParseFindKeyword
argument_list|(
name|line
argument_list|)
decl_stmt|;
if|if
condition|(
name|keywd
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|specType
operator|==
name|ExPath
operator|&&
name|parseKeywords
index|[
name|keywd
index|]
operator|.
name|spec
operator|!=
name|ExPath
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Mismatched special targets"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|specType
operator|=
name|parseKeywords
index|[
name|keywd
index|]
operator|.
name|spec
expr_stmt|;
name|tOp
operator|=
name|parseKeywords
index|[
name|keywd
index|]
operator|.
name|op
expr_stmt|;
comment|/* 		 * Certain special targets have special semantics: 		 *	.PATH		Have to set the dirSearchPath 		 *			variable too 		 *	.MAIN		Its sources are only used if 		 *			nothing has been specified to 		 *			create. 		 *	.DEFAULT    	Need to create a node to hang 		 *			commands on, but we don't want 		 *			it in the graph, nor do we want 		 *			it to be the Main Target, so we 		 *			create it, set OP_NOTMAIN and 		 *			add it to the list, setting 		 *			DEFAULT to the new node for 		 *			later use. We claim the node is 		 *	    	    	A transformation rule to make 		 *	    	    	life easier later, when we'll 		 *	    	    	use Make_HandleUse to actually 		 *	    	    	apply the .DEFAULT commands. 		 *	.PHONY		The list of targets 		 *	.NOPATH		Don't search for file in the path 		 *	.STALE 		 *	.BEGIN 		 *	.END 		 *	.ERROR 		 *	.DELETE_ON_ERROR 		 *	.INTERRUPT  	Are not to be considered the 		 *			main target. 		 *  	.NOTPARALLEL	Make only one target at a time. 		 *  	.SINGLESHELL	Create a shell for each command. 		 *  	.ORDER	    	Must set initial predecessor to NULL 		 */
switch|switch
condition|(
name|specType
condition|)
block|{
case|case
name|ExPath
case|:
if|if
condition|(
name|paths
operator|==
name|NULL
condition|)
block|{
name|paths
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|paths
argument_list|,
name|dirSearchPath
argument_list|)
expr_stmt|;
break|break;
case|case
name|Main
case|:
if|if
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|create
argument_list|)
condition|)
block|{
name|specType
operator|=
name|Not
expr_stmt|;
block|}
break|break;
case|case
name|Begin
case|:
case|case
name|End
case|:
case|case
name|Stale
case|:
case|case
name|dotError
case|:
case|case
name|Interrupt
case|:
name|gn
operator|=
name|Targ_FindNode
argument_list|(
name|line
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|doing_depend
condition|)
name|ParseMark
argument_list|(
name|gn
argument_list|)
expr_stmt|;
name|gn
operator|->
name|type
operator||=
name|OP_NOTMAIN
operator||
name|OP_SPECIAL
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|targets
argument_list|,
name|gn
argument_list|)
expr_stmt|;
break|break;
case|case
name|Default
case|:
name|gn
operator|=
name|Targ_NewGN
argument_list|(
literal|".DEFAULT"
argument_list|)
expr_stmt|;
name|gn
operator|->
name|type
operator||=
operator|(
name|OP_NOTMAIN
operator||
name|OP_TRANSFORM
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|targets
argument_list|,
name|gn
argument_list|)
expr_stmt|;
name|DEFAULT
operator|=
name|gn
expr_stmt|;
break|break;
case|case
name|DeleteOnError
case|:
name|deleteOnError
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|NotParallel
case|:
name|maxJobs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SingleShell
case|:
name|compatMake
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|Order
case|:
name|predecessor
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|".PATH"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * .PATH<suffix> has to be handled specially. 		 * Call on the suffix module to give us a path to 		 * modify. 		 */
name|Lst
name|path
decl_stmt|;
name|specType
operator|=
name|ExPath
expr_stmt|;
name|path
operator|=
name|Suff_GetPath
argument_list|(
operator|&
name|line
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Suffix '%s' not defined (yet)"
argument_list|,
operator|&
name|line
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
else|else
block|{
if|if
condition|(
name|paths
operator|==
name|NULL
condition|)
block|{
name|paths
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|paths
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Have word in line. Get or create its node and stick it at 	 * the end of the targets list 	 */
if|if
condition|(
operator|(
name|specType
operator|==
name|Not
operator|)
operator|&&
operator|(
operator|*
name|line
operator|!=
literal|'\0'
operator|)
condition|)
block|{
if|if
condition|(
name|Dir_HasWildcards
argument_list|(
name|line
argument_list|)
condition|)
block|{
comment|/* 		 * Targets are to be sought only in the current directory, 		 * so create an empty path for the thing. Note we need to 		 * use Dir_Destroy in the destruction of the path as the 		 * Dir module could have added a directory to the path... 		 */
name|Lst
name|emptyPath
init|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
decl_stmt|;
name|Dir_Expand
argument_list|(
name|line
argument_list|,
name|emptyPath
argument_list|,
name|curTargs
argument_list|)
expr_stmt|;
name|Lst_Destroy
argument_list|(
name|emptyPath
argument_list|,
name|Dir_Destroy
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * No wildcards, but we want to avoid code duplication, 		 * so create a list with the word on it. 		 */
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|curTargs
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
comment|/* Apply the targets. */
while|while
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|curTargs
argument_list|)
condition|)
block|{
name|char
modifier|*
name|targName
init|=
operator|(
name|char
operator|*
operator|)
name|Lst_DeQueue
argument_list|(
name|curTargs
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Suff_IsTransform
argument_list|(
name|targName
argument_list|)
condition|)
block|{
name|gn
operator|=
name|Targ_FindNode
argument_list|(
name|targName
argument_list|,
name|TARG_CREATE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gn
operator|=
name|Suff_AddTransform
argument_list|(
name|targName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|doing_depend
condition|)
name|ParseMark
argument_list|(
name|gn
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|targets
argument_list|,
name|gn
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|specType
operator|==
name|ExPath
operator|&&
operator|*
name|line
operator|!=
literal|'.'
operator|&&
operator|*
name|line
operator|!=
literal|'\0'
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_WARNING
argument_list|,
literal|"Extra target (%s) ignored"
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
comment|/* Don't need the inserted null terminator any more. */
operator|*
name|cp
operator|=
name|savec
expr_stmt|;
comment|/* 	 * If it is a special type and not .PATH, it's the only target we 	 * allow on this line... 	 */
if|if
condition|(
name|specType
operator|!=
name|Not
operator|&&
name|specType
operator|!=
name|ExPath
condition|)
block|{
name|Boolean
name|warning
init|=
name|FALSE
decl_stmt|;
while|while
condition|(
operator|*
name|cp
operator|&&
operator|(
name|ParseIsEscaped
argument_list|(
name|lstart
argument_list|,
name|cp
argument_list|)
operator|||
operator|(
operator|(
operator|*
name|cp
operator|!=
literal|'!'
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|!=
literal|':'
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|ParseIsEscaped
argument_list|(
name|lstart
argument_list|,
name|cp
argument_list|)
operator|||
operator|(
operator|*
name|cp
operator|!=
literal|' '
operator|&&
operator|*
name|cp
operator|!=
literal|'\t'
operator|)
condition|)
block|{
name|warning
operator|=
name|TRUE
expr_stmt|;
block|}
name|cp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|warning
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_WARNING
argument_list|,
literal|"Extra target ignored"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
operator|*
name|cp
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
block|}
name|line
operator|=
name|cp
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|line
operator|&&
operator|(
name|ParseIsEscaped
argument_list|(
name|lstart
argument_list|,
name|line
argument_list|)
operator|||
operator|(
operator|(
operator|*
name|line
operator|!=
literal|'!'
operator|)
operator|&&
operator|(
operator|*
name|line
operator|!=
literal|':'
operator|)
operator|)
operator|)
condition|)
do|;
comment|/*      * Don't need the list of target names anymore...      */
name|Lst_Destroy
argument_list|(
name|curTargs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|curTargs
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|targets
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|specType
condition|)
block|{
default|default:
name|Parse_Error
argument_list|(
name|PARSE_WARNING
argument_list|,
literal|"Special and mundane targets don't mix. Mundane ones ignored"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Default
case|:
case|case
name|Stale
case|:
case|case
name|Begin
case|:
case|case
name|End
case|:
case|case
name|dotError
case|:
case|case
name|Interrupt
case|:
comment|/* 		 * These four create nodes on which to hang commands, so 		 * targets shouldn't be empty... 		 */
case|case
name|Not
case|:
comment|/* 		 * Nothing special here -- targets can be empty if it wants. 		 */
break|break;
block|}
block|}
comment|/*      * Have now parsed all the target names. Must parse the operator next. The      * result is left in  op .      */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'!'
condition|)
block|{
name|op
operator|=
name|OP_FORCE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|cp
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|op
operator|=
name|OP_DOUBLEDEP
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
else|else
block|{
name|op
operator|=
name|OP_DEPENDS
expr_stmt|;
block|}
block|}
else|else
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
name|lstart
index|[
literal|0
index|]
operator|==
literal|'.'
condition|?
literal|"Unknown directive"
else|:
literal|"Missing dependency operator"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Advance beyond the operator */
name|cp
operator|++
expr_stmt|;
comment|/*      * Apply the operator to the target. This is how we remember which      * operator a target was defined with. It fails if the operator      * used isn't consistent across all references.      */
name|Lst_ForEach
argument_list|(
name|targets
argument_list|,
name|ParseDoOp
argument_list|,
operator|&
name|op
argument_list|)
expr_stmt|;
comment|/*      * Onward to the sources.      *      * LINE will now point to the first source word, if any, or the      * end of the string if not.      */
while|while
condition|(
operator|*
name|cp
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
name|line
operator|=
name|cp
expr_stmt|;
comment|/*      * Several special targets take different actions if present with no      * sources:      *	a .SUFFIXES line with no sources clears out all old suffixes      *	a .PRECIOUS line makes all targets precious      *	a .IGNORE line ignores errors for all targets      *	a .SILENT line creates silence when making all targets      *	a .PATH removes all directories from the search path(s).      */
if|if
condition|(
operator|!
operator|*
name|line
condition|)
block|{
switch|switch
condition|(
name|specType
condition|)
block|{
case|case
name|Suffixes
case|:
name|Suff_ClearSuffixes
argument_list|()
expr_stmt|;
break|break;
case|case
name|Precious
case|:
name|allPrecious
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|Ignore
case|:
name|ignoreErrors
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|Silent
case|:
name|beSilent
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|ExPath
case|:
name|Lst_ForEach
argument_list|(
name|paths
argument_list|,
name|ParseClearPath
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|Dir_SetPATH
argument_list|()
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|POSIX
case|case
name|Posix
case|:
name|Var_Set
argument_list|(
literal|"%POSIX"
argument_list|,
literal|"1003.2"
argument_list|,
name|VAR_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|specType
operator|==
name|MFlags
condition|)
block|{
comment|/* 	 * Call on functions in main.c to deal with these arguments and 	 * set the initial character to a null-character so the loop to 	 * get sources won't get anything 	 */
name|Main_ParseArgLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
operator|*
name|line
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|specType
operator|==
name|ExShell
condition|)
block|{
if|if
condition|(
name|Job_ParseShell
argument_list|(
name|line
argument_list|)
operator|!=
name|SUCCESS
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"improper shell specification"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
operator|*
name|line
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|specType
operator|==
name|NotParallel
operator|)
operator|||
operator|(
name|specType
operator|==
name|SingleShell
operator|)
operator|||
operator|(
name|specType
operator|==
name|DeleteOnError
operator|)
condition|)
block|{
operator|*
name|line
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/*      * NOW GO FOR THE SOURCES      */
if|if
condition|(
operator|(
name|specType
operator|==
name|Suffixes
operator|)
operator|||
operator|(
name|specType
operator|==
name|ExPath
operator|)
operator|||
operator|(
name|specType
operator|==
name|Includes
operator|)
operator|||
operator|(
name|specType
operator|==
name|Libs
operator|)
operator|||
operator|(
name|specType
operator|==
name|Null
operator|)
operator|||
operator|(
name|specType
operator|==
name|ExObjdir
operator|)
condition|)
block|{
while|while
condition|(
operator|*
name|line
condition|)
block|{
comment|/* 	     * If the target was one that doesn't take files as its sources 	     * but takes something like suffixes, we take each 	     * space-separated word on the line as a something and deal 	     * with it accordingly. 	     * 	     * If the target was .SUFFIXES, we take each source as a 	     * suffix and add it to the list of suffixes maintained by the 	     * Suff module. 	     * 	     * If the target was a .PATH, we add the source as a directory 	     * to search on the search path. 	     * 	     * If it was .INCLUDES, the source is taken to be the suffix of 	     * files which will be #included and whose search path should 	     * be present in the .INCLUDES variable. 	     * 	     * If it was .LIBS, the source is taken to be the suffix of 	     * files which are considered libraries and whose search path 	     * should be present in the .LIBS variable. 	     * 	     * If it was .NULL, the source is the suffix to use when a file 	     * has no valid suffix. 	     * 	     * If it was .OBJDIR, the source is a new definition for .OBJDIR, 	     * and will cause make to do a new chdir to that path. 	     */
while|while
condition|(
operator|*
name|cp
operator|&&
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
name|savec
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
switch|switch
condition|(
name|specType
condition|)
block|{
case|case
name|Suffixes
case|:
name|Suff_AddSuffix
argument_list|(
name|line
argument_list|,
operator|&
name|mainNode
argument_list|)
expr_stmt|;
break|break;
case|case
name|ExPath
case|:
name|Lst_ForEach
argument_list|(
name|paths
argument_list|,
name|ParseAddDir
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|Includes
case|:
name|Suff_AddInclude
argument_list|(
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|Libs
case|:
name|Suff_AddLib
argument_list|(
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|Null
case|:
name|Suff_SetNull
argument_list|(
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
name|ExObjdir
case|:
name|Main_SetObjdir
argument_list|(
literal|"%s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
operator|*
name|cp
operator|=
name|savec
expr_stmt|;
if|if
condition|(
name|savec
operator|!=
literal|'\0'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|cp
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
name|line
operator|=
name|cp
expr_stmt|;
block|}
if|if
condition|(
name|paths
condition|)
block|{
name|Lst_Destroy
argument_list|(
name|paths
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|specType
operator|==
name|ExPath
condition|)
name|Dir_SetPATH
argument_list|()
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|*
name|line
condition|)
block|{
comment|/* 	     * The targets take real sources, so we must beware of archive 	     * specifications (i.e. things with left parentheses in them) 	     * and handle them accordingly. 	     */
for|for
control|(
init|;
operator|*
name|cp
operator|&&
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
name|LPAREN
operator|)
operator|&&
operator|(
name|cp
operator|>
name|line
operator|)
operator|&&
operator|(
name|cp
index|[
operator|-
literal|1
index|]
operator|!=
literal|'$'
operator|)
condition|)
block|{
comment|/* 		     * Only stop for a left parenthesis if it isn't at the 		     * start of a word (that'll be for variable changes 		     * later) and isn't preceded by a dollar sign (a dynamic 		     * source). 		     */
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|cp
operator|==
name|LPAREN
condition|)
block|{
name|sources
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|Arch_ParseArchive
argument_list|(
operator|&
name|line
argument_list|,
name|sources
argument_list|,
name|VAR_CMD
argument_list|)
operator|!=
name|SUCCESS
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Error in source archive spec \"%s\""
argument_list|,
name|line
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
while|while
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|sources
argument_list|)
condition|)
block|{
name|gn
operator|=
operator|(
name|GNode
operator|*
operator|)
name|Lst_DeQueue
argument_list|(
name|sources
argument_list|)
expr_stmt|;
name|ParseDoSrc
argument_list|(
name|tOp
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|Lst_Destroy
argument_list|(
name|sources
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cp
operator|=
name|line
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|cp
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|+=
literal|1
expr_stmt|;
block|}
name|ParseDoSrc
argument_list|(
name|tOp
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|cp
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
name|line
operator|=
name|cp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mainNode
operator|==
name|NULL
condition|)
block|{
comment|/* 	 * If we have yet to decide on a main target to make, in the 	 * absence of any user input, we want the first target on 	 * the first dependency line that is actually a real target 	 * (i.e. isn't a .USE or .EXEC rule) to be made. 	 */
name|Lst_ForEach
argument_list|(
name|targets
argument_list|,
name|ParseFindMain
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|curTargs
condition|)
name|Lst_Destroy
argument_list|(
name|curTargs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *---------------------------------------------------------------------  * Parse_IsVar  --  *	Return TRUE if the passed line is a variable assignment. A variable  *	assignment consists of a single word followed by optional whitespace  *	followed by either a += or an = operator.  *	This function is used both by the Parse_File function and main when  *	parsing the command-line arguments.  *  * Input:  *	line		the line to check  *  * Results:  *	TRUE if it is. FALSE if it ain't  *  * Side Effects:  *	none  *---------------------------------------------------------------------  */
end_comment

begin_function
name|Boolean
name|Parse_IsVar
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
name|Boolean
name|wasSpace
init|=
name|FALSE
decl_stmt|;
comment|/* set TRUE if found a space */
name|char
name|ch
decl_stmt|;
name|int
name|level
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|ISEQOPERATOR
parameter_list|(
name|c
parameter_list|)
define|\
value|(((c) == '+') || ((c) == ':') || ((c) == '?') || ((c) == '!'))
comment|/*      * Skip to variable name      */
for|for
control|(
init|;
operator|(
operator|*
name|line
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|line
operator|==
literal|'\t'
operator|)
condition|;
name|line
operator|++
control|)
continue|continue;
comment|/* Scan for one of the assignment operators outside a variable expansion */
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|line
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'('
operator|||
name|ch
operator|==
literal|'{'
condition|)
block|{
name|level
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ch
operator|==
literal|')'
operator|||
name|ch
operator|==
literal|'}'
condition|)
block|{
name|level
operator|--
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|level
operator|!=
literal|0
condition|)
continue|continue;
while|while
condition|(
name|ch
operator|==
literal|' '
operator|||
name|ch
operator|==
literal|'\t'
condition|)
block|{
name|ch
operator|=
operator|*
name|line
operator|++
expr_stmt|;
name|wasSpace
operator|=
name|TRUE
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SUNSHCMD
if|if
condition|(
name|ch
operator|==
literal|':'
operator|&&
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"sh"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|line
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
if|if
condition|(
name|ch
operator|==
literal|'='
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|*
name|line
operator|==
literal|'='
operator|&&
name|ISEQOPERATOR
argument_list|(
name|ch
argument_list|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|wasSpace
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/*-  *---------------------------------------------------------------------  * Parse_DoVar  --  *	Take the variable assignment in the passed line and do it in the  *	global context.  *  *	Note: There is a lexical ambiguity with assignment modifier characters  *	in variable names. This routine interprets the character before the =  *	as a modifier. Therefore, an assignment like  *	    C++=/usr/bin/CC  *	is interpreted as "C+ +=" instead of "C++ =".  *  * Input:  *	line		a line guaranteed to be a variable assignment.  *			This reduces error checks  *	ctxt		Context in which to do the assignment  *  * Results:  *	none  *  * Side Effects:  *	the variable structure of the given variable name is altered in the  *	global context.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Parse_DoVar
parameter_list|(
name|char
modifier|*
name|line
parameter_list|,
name|GNode
modifier|*
name|ctxt
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* pointer into line */
enum|enum
block|{
name|VAR_SUBST
block|,
name|VAR_APPEND
block|,
name|VAR_SHELL
block|,
name|VAR_NORMAL
block|}
name|type
enum|;
comment|/* Type of assignment */
name|char
modifier|*
name|opc
decl_stmt|;
comment|/* ptr to operator character to 				 * null-terminate the variable name */
name|Boolean
name|freeCp
init|=
name|FALSE
decl_stmt|;
comment|/* TRUE if cp needs to be freed, 				    * i.e. if any variable expansion was 				    * performed */
name|int
name|depth
decl_stmt|;
comment|/*      * Skip to variable name      */
while|while
condition|(
operator|(
operator|*
name|line
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|line
operator|==
literal|'\t'
operator|)
condition|)
block|{
name|line
operator|++
expr_stmt|;
block|}
comment|/*      * Skip to operator character, nulling out whitespace as we go      * XXX Rather than counting () and {} we should look for $ and      * then expand the variable.      */
for|for
control|(
name|depth
operator|=
literal|0
operator|,
name|cp
operator|=
name|line
operator|+
literal|1
init|;
name|depth
operator|>
literal|0
operator|||
operator|*
name|cp
operator|!=
literal|'='
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'('
operator|||
operator|*
name|cp
operator|==
literal|'{'
condition|)
block|{
name|depth
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|')'
operator|||
operator|*
name|cp
operator|==
literal|'}'
condition|)
block|{
name|depth
operator|--
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|depth
operator|==
literal|0
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
name|opc
operator|=
name|cp
operator|-
literal|1
expr_stmt|;
comment|/* operator is the previous character */
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* nuke the = */
comment|/*      * Check operator type      */
switch|switch
condition|(
operator|*
name|opc
condition|)
block|{
case|case
literal|'+'
case|:
name|type
operator|=
name|VAR_APPEND
expr_stmt|;
operator|*
name|opc
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
comment|/* 	     * If the variable already has a value, we don't do anything. 	     */
operator|*
name|opc
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|Var_Exists
argument_list|(
name|line
argument_list|,
name|ctxt
argument_list|)
condition|)
block|{
return|return;
block|}
else|else
block|{
name|type
operator|=
name|VAR_NORMAL
expr_stmt|;
block|}
break|break;
case|case
literal|':'
case|:
name|type
operator|=
name|VAR_SUBST
expr_stmt|;
operator|*
name|opc
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
name|type
operator|=
name|VAR_SHELL
expr_stmt|;
operator|*
name|opc
operator|=
literal|'\0'
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|SUNSHCMD
while|while
condition|(
name|opc
operator|>
name|line
operator|&&
operator|*
name|opc
operator|!=
literal|':'
condition|)
name|opc
operator|--
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|opc
argument_list|,
literal|":sh"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|type
operator|=
name|VAR_SHELL
expr_stmt|;
operator|*
name|opc
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|type
operator|=
name|VAR_NORMAL
expr_stmt|;
break|break;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|VAR_APPEND
condition|)
block|{
name|Var_Append
argument_list|(
name|line
argument_list|,
name|cp
argument_list|,
name|ctxt
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|VAR_SUBST
condition|)
block|{
comment|/* 	 * Allow variables in the old value to be undefined, but leave their 	 * invocation alone -- this is done by forcing oldVars to be false. 	 * XXX: This can cause recursive variables, but that's not hard to do, 	 * and this allows someone to do something like 	 * 	 *  CFLAGS = $(.INCLUDES) 	 *  CFLAGS := -I.. $(CFLAGS) 	 * 	 * And not get an error. 	 */
name|Boolean
name|oldOldVars
init|=
name|oldVars
decl_stmt|;
name|oldVars
operator|=
name|FALSE
expr_stmt|;
comment|/* 	 * make sure that we set the variable the first time to nothing 	 * so that it gets substituted! 	 */
if|if
condition|(
operator|!
name|Var_Exists
argument_list|(
name|line
argument_list|,
name|ctxt
argument_list|)
condition|)
name|Var_Set
argument_list|(
name|line
argument_list|,
literal|""
argument_list|,
name|ctxt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cp
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|cp
argument_list|,
name|ctxt
argument_list|,
name|VARF_WANTRES
operator||
name|VARF_ASSIGN
argument_list|)
expr_stmt|;
name|oldVars
operator|=
name|oldOldVars
expr_stmt|;
name|freeCp
operator|=
name|TRUE
expr_stmt|;
name|Var_Set
argument_list|(
name|line
argument_list|,
name|cp
argument_list|,
name|ctxt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|VAR_SHELL
condition|)
block|{
name|char
modifier|*
name|res
decl_stmt|;
specifier|const
name|char
modifier|*
name|error
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'$'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 	     * There's a dollar sign in the command, so perform variable 	     * expansion on the whole thing. The resulting string will need 	     * freeing when we're done, so set freeCmd to TRUE. 	     */
name|cp
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|cp
argument_list|,
name|VAR_CMD
argument_list|,
name|VARF_UNDEFERR
operator||
name|VARF_WANTRES
argument_list|)
expr_stmt|;
name|freeCp
operator|=
name|TRUE
expr_stmt|;
block|}
name|res
operator|=
name|Cmd_Exec
argument_list|(
name|cp
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
name|Var_Set
argument_list|(
name|line
argument_list|,
name|res
argument_list|,
name|ctxt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|Parse_Error
argument_list|(
name|PARSE_WARNING
argument_list|,
name|error
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * Normal assignment -- just do it. 	 */
name|Var_Set
argument_list|(
name|line
argument_list|,
name|cp
argument_list|,
name|ctxt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|line
argument_list|,
name|MAKEOVERRIDES
argument_list|)
operator|==
literal|0
condition|)
name|Main_ExportMAKEFLAGS
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
comment|/* re-export MAKEFLAGS */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|line
argument_list|,
literal|".CURDIR"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 	 * Somone is being (too?) clever... 	 * Let's pretend they know what they are doing and 	 * re-initialize the 'cur' Path. 	 */
name|Dir_InitCur
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|Dir_SetPATH
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|line
argument_list|,
name|MAKE_JOB_PREFIX
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Job_SetPrefix
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|line
argument_list|,
name|MAKE_EXPORTED
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Var_Export
argument_list|(
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|freeCp
condition|)
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ParseMaybeSubMake --  * 	Scan the command string to see if it a possible submake node  * Input:  *	cmd		the command to scan  * Results:  *	TRUE if the command is possibly a submake, FALSE if not.  */
end_comment

begin_function
specifier|static
name|Boolean
name|ParseMaybeSubMake
parameter_list|(
specifier|const
name|char
modifier|*
name|cmd
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
specifier|static
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|}
name|vals
index|[]
init|=
block|{
define|#
directive|define
name|MKV
parameter_list|(
name|A
parameter_list|)
value|{	A, sizeof(A) - 1	}
name|MKV
argument_list|(
literal|"${MAKE}"
argument_list|)
block|,
name|MKV
argument_list|(
literal|"${.MAKE}"
argument_list|)
block|,
name|MKV
argument_list|(
literal|"$(MAKE)"
argument_list|)
block|,
name|MKV
argument_list|(
literal|"$(.MAKE)"
argument_list|)
block|,
name|MKV
argument_list|(
literal|"make"
argument_list|)
block|,     }
struct|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|vals
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|vals
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|=
name|strstr
argument_list|(
name|cmd
argument_list|,
name|vals
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ptr
operator|==
name|cmd
operator|||
operator|!
name|isalnum
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|ptr
index|[
operator|-
literal|1
index|]
argument_list|)
operator|)
operator|&&
operator|!
name|isalnum
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|ptr
index|[
name|vals
index|[
name|i
index|]
operator|.
name|len
index|]
argument_list|)
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/*-  * ParseAddCmd  --  *	Lst_ForEach function to add a command line to all targets  *  * Input:  *	gnp		the node to which the command is to be added  *	cmd		the command to add  *  * Results:  *	Always 0  *  * Side Effects:  *	A new element is added to the commands list of the node,  *	and the node can be marked as a submake node if the command is  *	determined to be that.  */
end_comment

begin_function
specifier|static
name|int
name|ParseAddCmd
parameter_list|(
name|void
modifier|*
name|gnp
parameter_list|,
name|void
modifier|*
name|cmd
parameter_list|)
block|{
name|GNode
modifier|*
name|gn
init|=
operator|(
name|GNode
operator|*
operator|)
name|gnp
decl_stmt|;
comment|/* Add to last (ie current) cohort for :: targets */
if|if
condition|(
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_DOUBLEDEP
operator|)
operator|&&
operator|!
name|Lst_IsEmpty
argument_list|(
name|gn
operator|->
name|cohorts
argument_list|)
condition|)
name|gn
operator|=
operator|(
name|GNode
operator|*
operator|)
name|Lst_Datum
argument_list|(
name|Lst_Last
argument_list|(
name|gn
operator|->
name|cohorts
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if target already supplied, ignore commands */
if|if
condition|(
operator|!
operator|(
name|gn
operator|->
name|type
operator|&
name|OP_HAS_COMMANDS
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|gn
operator|->
name|commands
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ParseMaybeSubMake
argument_list|(
name|cmd
argument_list|)
condition|)
name|gn
operator|->
name|type
operator||=
name|OP_SUBMAKE
expr_stmt|;
name|ParseMark
argument_list|(
name|gn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|notyet
comment|/* XXX: We cannot do this until we fix the tree */
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|gn
operator|->
name|commands
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|Parse_Error
argument_list|(
name|PARSE_WARNING
argument_list|,
literal|"overriding commands for target \"%s\"; "
literal|"previous commands defined at %s: %d ignored"
argument_list|,
name|gn
operator|->
name|name
argument_list|,
name|gn
operator|->
name|fname
argument_list|,
name|gn
operator|->
name|lineno
argument_list|)
expr_stmt|;
else|#
directive|else
name|Parse_Error
argument_list|(
name|PARSE_WARNING
argument_list|,
literal|"duplicate script for target \"%s\" ignored"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
name|ParseErrorInternal
argument_list|(
name|gn
operator|->
name|fname
argument_list|,
name|gn
operator|->
name|lineno
argument_list|,
name|PARSE_WARNING
argument_list|,
literal|"using previous script for \"%s\" defined here"
argument_list|,
name|gn
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * ParseHasCommands --  *	Callback procedure for Parse_File when destroying the list of  *	targets on the last dependency line. Marks a target as already  *	having commands if it does, to keep from having shell commands  *	on multiple dependency lines.  *  * Input:  *	gnp		Node to examine  *  * Results:  *	None  *  * Side Effects:  *	OP_HAS_COMMANDS may be set for the target.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|ParseHasCommands
parameter_list|(
name|void
modifier|*
name|gnp
parameter_list|)
block|{
name|GNode
modifier|*
name|gn
init|=
operator|(
name|GNode
operator|*
operator|)
name|gnp
decl_stmt|;
if|if
condition|(
operator|!
name|Lst_IsEmpty
argument_list|(
name|gn
operator|->
name|commands
argument_list|)
condition|)
block|{
name|gn
operator|->
name|type
operator||=
name|OP_HAS_COMMANDS
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Parse_AddIncludeDir --  *	Add a directory to the path searched for included makefiles  *	bracketed by double-quotes. Used by functions in main.c  *  * Input:  *	dir		The name of the directory to add  *  * Results:  *	None.  *  * Side Effects:  *	The directory is appended to the list.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Parse_AddIncludeDir
parameter_list|(
name|char
modifier|*
name|dir
parameter_list|)
block|{
operator|(
name|void
operator|)
name|Dir_AddDir
argument_list|(
name|parseIncPath
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *---------------------------------------------------------------------  * ParseDoInclude  --  *	Push to another file.  *  *	The input is the line minus the `.'. A file spec is a string  *	enclosed in<> or "". The former is looked for only in sysIncPath.  *	The latter in . and the directories specified by -I command line  *	options  *  * Results:  *	None  *  * Side Effects:  *	A structure is added to the includes Lst and readProc, lineno,  *	fname and curFILE are altered for the new file  *---------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|Parse_include_file
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|Boolean
name|isSystem
parameter_list|,
name|Boolean
name|depinc
parameter_list|,
name|int
name|silent
parameter_list|)
block|{
name|struct
name|loadedfile
modifier|*
name|lf
decl_stmt|;
name|char
modifier|*
name|fullname
decl_stmt|;
comment|/* full pathname of file */
name|char
modifier|*
name|newName
decl_stmt|;
name|char
modifier|*
name|prefEnd
decl_stmt|,
modifier|*
name|incdir
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*      * Now we know the file's name and its search path, we attempt to      * find the durn thing. A return of NULL indicates the file don't      * exist.      */
name|fullname
operator|=
name|file
index|[
literal|0
index|]
operator|==
literal|'/'
condition|?
name|bmake_strdup
argument_list|(
name|file
argument_list|)
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|fullname
operator|==
name|NULL
operator|&&
operator|!
name|isSystem
condition|)
block|{
comment|/* 	 * Include files contained in double-quotes are first searched for 	 * relative to the including file's location. We don't want to 	 * cd there, of course, so we just tack on the old file's 	 * leading path components and call Dir_FindFile to see if 	 * we can locate the beast. 	 */
name|incdir
operator|=
name|bmake_strdup
argument_list|(
name|curFile
operator|->
name|fname
argument_list|)
expr_stmt|;
name|prefEnd
operator|=
name|strrchr
argument_list|(
name|incdir
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefEnd
operator|!=
name|NULL
condition|)
block|{
operator|*
name|prefEnd
operator|=
literal|'\0'
expr_stmt|;
comment|/* Now do lexical processing of leading "../" on the filename */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|strncmp
argument_list|(
name|file
operator|+
name|i
argument_list|,
literal|"../"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|;
name|i
operator|+=
literal|3
control|)
block|{
name|prefEnd
operator|=
name|strrchr
argument_list|(
name|incdir
operator|+
literal|1
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefEnd
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|prefEnd
argument_list|,
literal|"/.."
argument_list|)
operator|==
literal|0
condition|)
break|break;
operator|*
name|prefEnd
operator|=
literal|'\0'
expr_stmt|;
block|}
name|newName
operator|=
name|str_concat
argument_list|(
name|incdir
argument_list|,
name|file
operator|+
name|i
argument_list|,
name|STR_ADDSLASH
argument_list|)
expr_stmt|;
name|fullname
operator|=
name|Dir_FindFile
argument_list|(
name|newName
argument_list|,
name|parseIncPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullname
operator|==
name|NULL
condition|)
name|fullname
operator|=
name|Dir_FindFile
argument_list|(
name|newName
argument_list|,
name|dirSearchPath
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newName
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|incdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullname
operator|==
name|NULL
condition|)
block|{
comment|/*     	     * Makefile wasn't found in same directory as included makefile. 	     * Search for it first on the -I search path, 	     * then on the .PATH search path, if not found in a -I directory. 	     * If we have a suffix specific path we should use that. 	     */
name|char
modifier|*
name|suff
decl_stmt|;
name|Lst
name|suffPath
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|suff
operator|=
name|strrchr
argument_list|(
name|file
argument_list|,
literal|'.'
argument_list|)
operator|)
condition|)
block|{
name|suffPath
operator|=
name|Suff_GetPath
argument_list|(
name|suff
argument_list|)
expr_stmt|;
if|if
condition|(
name|suffPath
operator|!=
name|NULL
condition|)
block|{
name|fullname
operator|=
name|Dir_FindFile
argument_list|(
name|file
argument_list|,
name|suffPath
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fullname
operator|==
name|NULL
condition|)
block|{
name|fullname
operator|=
name|Dir_FindFile
argument_list|(
name|file
argument_list|,
name|parseIncPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullname
operator|==
name|NULL
condition|)
block|{
name|fullname
operator|=
name|Dir_FindFile
argument_list|(
name|file
argument_list|,
name|dirSearchPath
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Looking for a system file or file still not found */
if|if
condition|(
name|fullname
operator|==
name|NULL
condition|)
block|{
comment|/* 	 * Look for it on the system path 	 */
name|fullname
operator|=
name|Dir_FindFile
argument_list|(
name|file
argument_list|,
name|Lst_IsEmpty
argument_list|(
name|sysIncPath
argument_list|)
condition|?
name|defIncPath
else|:
name|sysIncPath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fullname
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|silent
condition|)
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Could not find %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Actually open the file... */
name|fd
operator|=
name|open
argument_list|(
name|fullname
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|silent
condition|)
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Cannot open %s"
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fullname
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* load it */
name|lf
operator|=
name|loadfile
argument_list|(
name|fullname
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|ParseSetIncludedFile
argument_list|()
expr_stmt|;
comment|/* Start reading from this file next */
name|Parse_SetInput
argument_list|(
name|fullname
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|loadedfile_nextbuf
argument_list|,
name|lf
argument_list|)
expr_stmt|;
name|curFile
operator|->
name|lf
operator|=
name|lf
expr_stmt|;
if|if
condition|(
name|depinc
condition|)
name|doing_depend
operator|=
name|depinc
expr_stmt|;
comment|/* only turn it on */
block|}
end_function

begin_function
specifier|static
name|void
name|ParseDoInclude
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
name|char
name|endc
decl_stmt|;
comment|/* the character which ends the file spec */
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* current position in file spec */
name|int
name|silent
init|=
operator|(
operator|*
name|line
operator|!=
literal|'i'
operator|)
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|char
modifier|*
name|file
init|=
operator|&
name|line
index|[
literal|7
operator|+
name|silent
index|]
decl_stmt|;
comment|/* Skip to delimiter character so we know where to look */
while|while
condition|(
operator|*
name|file
operator|==
literal|' '
operator|||
operator|*
name|file
operator|==
literal|'\t'
condition|)
name|file
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|file
operator|!=
literal|'"'
operator|&&
operator|*
name|file
operator|!=
literal|'<'
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|".include filename must be delimited by '\"' or '<'"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * Set the search path on which to find the include file based on the      * characters which bracket its name. Angle-brackets imply it's      * a system Makefile while double-quotes imply it's a user makefile      */
if|if
condition|(
operator|*
name|file
operator|==
literal|'<'
condition|)
block|{
name|endc
operator|=
literal|'>'
expr_stmt|;
block|}
else|else
block|{
name|endc
operator|=
literal|'"'
expr_stmt|;
block|}
comment|/* Skip to matching delimiter */
for|for
control|(
name|cp
operator|=
operator|++
name|file
init|;
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|!=
name|endc
condition|;
name|cp
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|cp
operator|!=
name|endc
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Unclosed %cinclude filename. '%c' expected"
argument_list|,
literal|'.'
argument_list|,
name|endc
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/*      * Substitute for any variables in the file name before trying to      * find the thing.      */
name|file
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|VAR_CMD
argument_list|,
name|VARF_WANTRES
argument_list|)
expr_stmt|;
name|Parse_include_file
argument_list|(
name|file
argument_list|,
name|endc
operator|==
literal|'>'
argument_list|,
operator|(
operator|*
name|line
operator|==
literal|'d'
operator|)
argument_list|,
name|silent
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *---------------------------------------------------------------------  * ParseSetIncludedFile  --  *	Set the .INCLUDEDFROMFILE variable to the contents of .PARSEFILE  *	and the .INCLUDEDFROMDIR variable to the contents of .PARSEDIR  *  * Results:  *	None  *  * Side Effects:  *	The .INCLUDEDFROMFILE variable is overwritten by the contents  *	of .PARSEFILE and the .INCLUDEDFROMDIR variable is overwriten  *	by the contents of .PARSEDIR  *---------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|ParseSetIncludedFile
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|pf
decl_stmt|,
modifier|*
name|fp
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|pd
decl_stmt|,
modifier|*
name|dp
init|=
name|NULL
decl_stmt|;
name|pf
operator|=
name|Var_Value
argument_list|(
literal|".PARSEFILE"
argument_list|,
name|VAR_GLOBAL
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
name|Var_Set
argument_list|(
literal|".INCLUDEDFROMFILE"
argument_list|,
name|pf
argument_list|,
name|VAR_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pd
operator|=
name|Var_Value
argument_list|(
literal|".PARSEDIR"
argument_list|,
name|VAR_GLOBAL
argument_list|,
operator|&
name|dp
argument_list|)
expr_stmt|;
name|Var_Set
argument_list|(
literal|".INCLUDEDFROMDIR"
argument_list|,
name|pd
argument_list|,
name|VAR_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|PARSE
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"%s: ${.INCLUDEDFROMDIR} = `%s' "
literal|"${.INCLUDEDFROMFILE} = `%s'\n"
argument_list|,
name|__func__
argument_list|,
name|pd
argument_list|,
name|pf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  *---------------------------------------------------------------------  * ParseSetParseFile  --  *	Set the .PARSEDIR and .PARSEFILE variables to the dirname and  *	basename of the given filename  *  * Results:  *	None  *  * Side Effects:  *	The .PARSEDIR and .PARSEFILE variables are overwritten by the  *	dirname and basename of the given filename.  *---------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|ParseSetParseFile
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|char
modifier|*
name|slash
decl_stmt|,
modifier|*
name|dirname
decl_stmt|;
specifier|const
name|char
modifier|*
name|pd
decl_stmt|,
modifier|*
name|pf
decl_stmt|;
name|int
name|len
decl_stmt|;
name|slash
operator|=
name|strrchr
argument_list|(
name|filename
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
operator|==
name|NULL
condition|)
block|{
name|Var_Set
argument_list|(
literal|".PARSEDIR"
argument_list|,
name|pd
operator|=
name|curdir
argument_list|,
name|VAR_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Var_Set
argument_list|(
literal|".PARSEFILE"
argument_list|,
name|pf
operator|=
name|filename
argument_list|,
name|VAR_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dirname
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|slash
operator|-
name|filename
expr_stmt|;
name|dirname
operator|=
name|bmake_malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dirname
argument_list|,
name|filename
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|dirname
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|Var_Set
argument_list|(
literal|".PARSEDIR"
argument_list|,
name|pd
operator|=
name|dirname
argument_list|,
name|VAR_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Var_Set
argument_list|(
literal|".PARSEFILE"
argument_list|,
name|pf
operator|=
name|slash
operator|+
literal|1
argument_list|,
name|VAR_GLOBAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DEBUG
argument_list|(
name|PARSE
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"%s: ${.PARSEDIR} = `%s' ${.PARSEFILE} = `%s'\n"
argument_list|,
name|__func__
argument_list|,
name|pd
argument_list|,
name|pf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Track the makefiles we read - so makefiles can  * set dependencies on them.  * Avoid adding anything more than once.  */
end_comment

begin_function
specifier|static
name|void
name|ParseTrackInput
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|old
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
name|char
modifier|*
name|fp
init|=
name|NULL
decl_stmt|;
name|size_t
name|name_len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|old
operator|=
name|Var_Value
argument_list|(
name|MAKE_MAKEFILES
argument_list|,
name|VAR_GLOBAL
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
condition|)
block|{
name|ep
operator|=
name|old
operator|+
name|strlen
argument_list|(
name|old
argument_list|)
operator|-
name|name_len
expr_stmt|;
comment|/* does it contain name? */
for|for
control|(
init|;
name|old
operator|!=
name|NULL
condition|;
name|old
operator|=
name|strchr
argument_list|(
name|old
argument_list|,
literal|' '
argument_list|)
control|)
block|{
if|if
condition|(
operator|*
name|old
operator|==
literal|' '
condition|)
name|old
operator|++
expr_stmt|;
if|if
condition|(
name|old
operator|>=
name|ep
condition|)
break|break;
comment|/* cannot contain name */
if|if
condition|(
name|memcmp
argument_list|(
name|old
argument_list|,
name|name
argument_list|,
name|name_len
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|old
index|[
name|name_len
index|]
operator|==
literal|0
operator|||
name|old
index|[
name|name_len
index|]
operator|==
literal|' '
operator|)
condition|)
goto|goto
name|cleanup
goto|;
block|}
block|}
name|Var_Append
argument_list|(
name|MAKE_MAKEFILES
argument_list|,
name|name
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
name|cleanup
label|:
if|if
condition|(
name|fp
condition|)
block|{
name|free
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *---------------------------------------------------------------------  * Parse_setInput  --  *	Start Parsing from the given source  *  * Results:  *	None  *  * Side Effects:  *	A structure is added to the includes Lst and readProc, lineno,  *	fname and curFile are altered for the new file  *---------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Parse_SetInput
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|fd
parameter_list|,
name|char
modifier|*
function_decl|(
modifier|*
name|nextbuf
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|len
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
name|curFile
operator|->
name|fname
expr_stmt|;
else|else
name|ParseTrackInput
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|PARSE
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"%s: file %s, line %d, fd %d, nextbuf %p, arg %p\n"
argument_list|,
name|__func__
argument_list|,
name|name
argument_list|,
name|line
argument_list|,
name|fd
argument_list|,
name|nextbuf
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
operator|&&
name|nextbuf
operator|==
name|NULL
condition|)
comment|/* sanity */
return|return;
if|if
condition|(
name|curFile
operator|!=
name|NULL
condition|)
comment|/* Save exiting file info */
name|Lst_AtFront
argument_list|(
name|includes
argument_list|,
name|curFile
argument_list|)
expr_stmt|;
comment|/* Allocate and fill in new structure */
name|curFile
operator|=
name|bmake_malloc
argument_list|(
sizeof|sizeof
expr|*
name|curFile
argument_list|)
expr_stmt|;
comment|/*      * Once the previous state has been saved, we can get down to reading      * the new file. We set up the name of the file to be the absolute      * name of the include file so error messages refer to the right      * place.      */
name|curFile
operator|->
name|fname
operator|=
name|bmake_strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|curFile
operator|->
name|lineno
operator|=
name|line
expr_stmt|;
name|curFile
operator|->
name|first_lineno
operator|=
name|line
expr_stmt|;
name|curFile
operator|->
name|nextbuf
operator|=
name|nextbuf
expr_stmt|;
name|curFile
operator|->
name|nextbuf_arg
operator|=
name|arg
expr_stmt|;
name|curFile
operator|->
name|lf
operator|=
name|NULL
expr_stmt|;
name|curFile
operator|->
name|depending
operator|=
name|doing_depend
expr_stmt|;
comment|/* restore this on EOF */
name|assert
argument_list|(
name|nextbuf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Get first block of input data */
name|buf
operator|=
name|curFile
operator|->
name|nextbuf
argument_list|(
name|curFile
operator|->
name|nextbuf_arg
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
comment|/* Was all a waste of time ... */
if|if
condition|(
name|curFile
operator|->
name|fname
condition|)
name|free
argument_list|(
name|curFile
operator|->
name|fname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|curFile
argument_list|)
expr_stmt|;
return|return;
block|}
name|curFile
operator|->
name|P_str
operator|=
name|buf
expr_stmt|;
name|curFile
operator|->
name|P_ptr
operator|=
name|buf
expr_stmt|;
name|curFile
operator|->
name|P_end
operator|=
name|buf
operator|+
name|len
expr_stmt|;
name|curFile
operator|->
name|cond_depth
operator|=
name|Cond_save_depth
argument_list|()
expr_stmt|;
name|ParseSetParseFile
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SYSVINCLUDE
end_ifdef

begin_comment
comment|/*-  *---------------------------------------------------------------------  * ParseTraditionalInclude  --  *	Push to another file.  *  *	The input is the current line. The file name(s) are  *	following the "include".  *  * Results:  *	None  *  * Side Effects:  *	A structure is added to the includes Lst and readProc, lineno,  *	fname and curFILE are altered for the new file  *---------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|ParseTraditionalInclude
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* current position in file spec */
name|int
name|done
init|=
literal|0
decl_stmt|;
name|int
name|silent
init|=
operator|(
name|line
index|[
literal|0
index|]
operator|!=
literal|'i'
operator|)
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|char
modifier|*
name|file
init|=
operator|&
name|line
index|[
name|silent
operator|+
literal|7
index|]
decl_stmt|;
name|char
modifier|*
name|all_files
decl_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|PARSE
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|__func__
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
comment|/*      * Skip over whitespace      */
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|file
argument_list|)
condition|)
name|file
operator|++
expr_stmt|;
comment|/*      * Substitute for any variables in the file name before trying to      * find the thing.      */
name|all_files
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|file
argument_list|,
name|VAR_CMD
argument_list|,
name|VARF_WANTRES
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|file
operator|==
literal|'\0'
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Filename missing from \"include\""
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|file
operator|=
name|all_files
init|;
operator|!
name|done
condition|;
name|file
operator|=
name|cp
operator|+
literal|1
control|)
block|{
comment|/* Skip to end of line or next whitespace */
for|for
control|(
name|cp
operator|=
name|file
init|;
operator|*
name|cp
operator|&&
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|;
name|cp
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|cp
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
else|else
name|done
operator|=
literal|1
expr_stmt|;
name|Parse_include_file
argument_list|(
name|file
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|silent
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|all_files
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|GMAKEEXPORT
end_ifdef

begin_comment
comment|/*-  *---------------------------------------------------------------------  * ParseGmakeExport  --  *	Parse export<variable>=<value>  *  *	And set the environment with it.  *  * Results:  *	None  *  * Side Effects:  *	None  *---------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|ParseGmakeExport
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
name|char
modifier|*
name|variable
init|=
operator|&
name|line
index|[
literal|6
index|]
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|PARSE
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|__func__
argument_list|,
name|variable
argument_list|)
expr_stmt|;
block|}
comment|/*      * Skip over whitespace      */
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|variable
argument_list|)
condition|)
name|variable
operator|++
expr_stmt|;
for|for
control|(
name|value
operator|=
name|variable
init|;
operator|*
name|value
operator|&&
operator|*
name|value
operator|!=
literal|'='
condition|;
name|value
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|value
operator|!=
literal|'='
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Variable/Value missing from \"export\""
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|value
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* terminate variable */
comment|/*      * Expand the value before putting it in the environment.      */
name|value
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|value
argument_list|,
name|VAR_CMD
argument_list|,
name|VARF_WANTRES
argument_list|)
expr_stmt|;
name|setenv
argument_list|(
name|variable
argument_list|,
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*-  *---------------------------------------------------------------------  * ParseEOF  --  *	Called when EOF is reached in the current file. If we were reading  *	an include file, the includes stack is popped and things set up  *	to go back to reading the previous file at the previous location.  *  * Results:  *	CONTINUE if there's more to do. DONE if not.  *  * Side Effects:  *	The old curFILE, is closed. The includes list is shortened.  *	lineno, curFILE, and fname are changed if CONTINUE is returned.  *---------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|ParseEOF
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|assert
argument_list|(
name|curFile
operator|->
name|nextbuf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|doing_depend
operator|=
name|curFile
operator|->
name|depending
expr_stmt|;
comment|/* restore this */
comment|/* get next input buffer, if any */
name|ptr
operator|=
name|curFile
operator|->
name|nextbuf
argument_list|(
name|curFile
operator|->
name|nextbuf_arg
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|curFile
operator|->
name|P_ptr
operator|=
name|ptr
expr_stmt|;
name|curFile
operator|->
name|P_str
operator|=
name|ptr
expr_stmt|;
name|curFile
operator|->
name|P_end
operator|=
name|ptr
operator|+
name|len
expr_stmt|;
name|curFile
operator|->
name|lineno
operator|=
name|curFile
operator|->
name|first_lineno
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
comment|/* Iterate again */
return|return
name|CONTINUE
return|;
block|}
comment|/* Ensure the makefile (or loop) didn't have mismatched conditionals */
name|Cond_restore_depth
argument_list|(
name|curFile
operator|->
name|cond_depth
argument_list|)
expr_stmt|;
if|if
condition|(
name|curFile
operator|->
name|lf
operator|!=
name|NULL
condition|)
block|{
name|loadedfile_destroy
argument_list|(
name|curFile
operator|->
name|lf
argument_list|)
expr_stmt|;
name|curFile
operator|->
name|lf
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Dispose of curFile info */
comment|/* Leak curFile->fname because all the gnodes have pointers to it */
name|free
argument_list|(
name|curFile
operator|->
name|P_str
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|curFile
argument_list|)
expr_stmt|;
name|curFile
operator|=
name|Lst_DeQueue
argument_list|(
name|includes
argument_list|)
expr_stmt|;
if|if
condition|(
name|curFile
operator|==
name|NULL
condition|)
block|{
comment|/* We've run out of input */
name|Var_Delete
argument_list|(
literal|".PARSEDIR"
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
name|Var_Delete
argument_list|(
literal|".PARSEFILE"
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
name|Var_Delete
argument_list|(
literal|".INCLUDEDFROMDIR"
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
name|Var_Delete
argument_list|(
literal|".INCLUDEDFROMFILE"
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
return|return
name|DONE
return|;
block|}
if|if
condition|(
name|DEBUG
argument_list|(
name|PARSE
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"ParseEOF: returning to file %s, line %d\n"
argument_list|,
name|curFile
operator|->
name|fname
argument_list|,
name|curFile
operator|->
name|lineno
argument_list|)
expr_stmt|;
comment|/* Restore the PARSEDIR/PARSEFILE variables */
name|ParseSetParseFile
argument_list|(
name|curFile
operator|->
name|fname
argument_list|)
expr_stmt|;
return|return
operator|(
name|CONTINUE
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PARSE_RAW
value|1
end_define

begin_define
define|#
directive|define
name|PARSE_SKIP
value|2
end_define

begin_function
specifier|static
name|char
modifier|*
name|ParseGetLine
parameter_list|(
name|int
name|flags
parameter_list|,
name|int
modifier|*
name|length
parameter_list|)
block|{
name|IFile
modifier|*
name|cf
init|=
name|curFile
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
name|ch
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|char
modifier|*
name|line_end
decl_stmt|;
name|char
modifier|*
name|escaped
decl_stmt|;
name|char
modifier|*
name|comment
decl_stmt|;
name|char
modifier|*
name|tp
decl_stmt|;
comment|/* Loop through blank lines and comment lines */
for|for
control|(
init|;
condition|;
control|)
block|{
name|cf
operator|->
name|lineno
operator|++
expr_stmt|;
name|line
operator|=
name|cf
operator|->
name|P_ptr
expr_stmt|;
name|ptr
operator|=
name|line
expr_stmt|;
name|line_end
operator|=
name|line
expr_stmt|;
name|escaped
operator|=
name|NULL
expr_stmt|;
name|comment
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|cf
operator|->
name|P_end
operator|!=
name|NULL
operator|&&
name|ptr
operator|==
name|cf
operator|->
name|P_end
condition|)
block|{
comment|/* end of buffer */
name|ch
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|ch
operator|=
operator|*
name|ptr
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|0
operator|||
operator|(
name|ch
operator|==
literal|'\\'
operator|&&
name|ptr
index|[
literal|1
index|]
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|cf
operator|->
name|P_end
operator|==
name|NULL
condition|)
comment|/* End of string (aka for loop) data */
break|break;
comment|/* see if there is more we can parse */
while|while
condition|(
name|ptr
operator|++
operator|<
name|cf
operator|->
name|P_end
condition|)
block|{
if|if
condition|(
operator|(
name|ch
operator|=
operator|*
name|ptr
operator|)
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|ptr
operator|>
name|line
operator|&&
name|ptr
index|[
operator|-
literal|1
index|]
operator|==
literal|'\\'
condition|)
continue|continue;
name|Parse_Error
argument_list|(
name|PARSE_WARNING
argument_list|,
literal|"Zero byte read from file, skipping rest of line."
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|cf
operator|->
name|nextbuf
operator|!=
name|NULL
condition|)
block|{
comment|/* 		     * End of this buffer; return EOF and outer logic 		     * will get the next one. (eww) 		     */
break|break;
block|}
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Zero byte read from file"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
block|{
comment|/* Don't treat next character as special, remember first one */
if|if
condition|(
name|escaped
operator|==
name|NULL
condition|)
name|escaped
operator|=
name|ptr
expr_stmt|;
if|if
condition|(
name|ptr
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|cf
operator|->
name|lineno
operator|++
expr_stmt|;
name|ptr
operator|+=
literal|2
expr_stmt|;
name|line_end
operator|=
name|ptr
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ch
operator|==
literal|'#'
operator|&&
name|comment
operator|==
name|NULL
condition|)
block|{
comment|/* Remember first '#' for comment stripping */
comment|/* Unless previous char was '[', as in modifier :[#] */
if|if
condition|(
operator|!
operator|(
name|ptr
operator|>
name|line
operator|&&
name|ptr
index|[
operator|-
literal|1
index|]
operator|==
literal|'['
operator|)
condition|)
name|comment
operator|=
name|line_end
expr_stmt|;
block|}
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
break|break;
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|ch
argument_list|)
condition|)
comment|/* We are not interested in trailing whitespace */
name|line_end
operator|=
name|ptr
expr_stmt|;
block|}
comment|/* Save next 'to be processed' location */
name|cf
operator|->
name|P_ptr
operator|=
name|ptr
expr_stmt|;
comment|/* Check we have a non-comment, non-blank line */
if|if
condition|(
name|line_end
operator|==
name|line
operator|||
name|comment
operator|==
name|line
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|0
condition|)
comment|/* At end of file */
return|return
name|NULL
return|;
comment|/* Parse another line */
continue|continue;
block|}
comment|/* We now have a line of data */
operator|*
name|line_end
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PARSE_RAW
condition|)
block|{
comment|/* Leave '\' (etc) in line buffer (eg 'for' lines) */
operator|*
name|length
operator|=
name|line_end
operator|-
name|line
expr_stmt|;
return|return
name|line
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|PARSE_SKIP
condition|)
block|{
comment|/* Completely ignore non-directives */
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|!=
literal|'.'
condition|)
continue|continue;
comment|/* We could do more of the .else/.elif/.endif checks here */
block|}
break|break;
block|}
comment|/* Brutally ignore anything after a non-escaped '#' in non-commands */
if|if
condition|(
name|comment
operator|!=
name|NULL
operator|&&
name|line
index|[
literal|0
index|]
operator|!=
literal|'\t'
condition|)
block|{
name|line_end
operator|=
name|comment
expr_stmt|;
operator|*
name|line_end
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If we didn't see a '\\' then the in-situ data is fine */
if|if
condition|(
name|escaped
operator|==
name|NULL
condition|)
block|{
operator|*
name|length
operator|=
name|line_end
operator|-
name|line
expr_stmt|;
return|return
name|line
return|;
block|}
comment|/* Remove escapes from '\n' and '#' */
name|tp
operator|=
name|ptr
operator|=
name|escaped
expr_stmt|;
name|escaped
operator|=
name|line
expr_stmt|;
for|for
control|(
init|;
condition|;
operator|*
name|tp
operator|++
operator|=
name|ch
control|)
block|{
name|ch
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
literal|'\\'
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|0
condition|)
break|break;
continue|continue;
block|}
name|ch
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|0
condition|)
block|{
comment|/* Delete '\\' at end of buffer */
name|tp
operator|--
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ch
operator|==
literal|'#'
operator|&&
name|line
index|[
literal|0
index|]
operator|!=
literal|'\t'
condition|)
comment|/* Delete '\\' from before '#' on non-command lines */
continue|continue;
if|if
condition|(
name|ch
operator|!=
literal|'\n'
condition|)
block|{
comment|/* Leave '\\' in buffer for later */
operator|*
name|tp
operator|++
operator|=
literal|'\\'
expr_stmt|;
comment|/* Make sure we don't delete an escaped ' ' from the line end */
name|escaped
operator|=
name|tp
operator|+
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* Escaped '\n' replace following whitespace with a single ' ' */
while|while
condition|(
name|ptr
index|[
literal|0
index|]
operator|==
literal|' '
operator|||
name|ptr
index|[
literal|0
index|]
operator|==
literal|'\t'
condition|)
name|ptr
operator|++
expr_stmt|;
name|ch
operator|=
literal|' '
expr_stmt|;
block|}
comment|/* Delete any trailing spaces - eg from empty continuations */
while|while
condition|(
name|tp
operator|>
name|escaped
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|tp
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|tp
operator|--
expr_stmt|;
operator|*
name|tp
operator|=
literal|0
expr_stmt|;
operator|*
name|length
operator|=
name|tp
operator|-
name|line
expr_stmt|;
return|return
name|line
return|;
block|}
end_function

begin_comment
comment|/*-  *---------------------------------------------------------------------  * ParseReadLine --  *	Read an entire line from the input file. Called only by Parse_File.  *  * Results:  *	A line w/o its newline  *  * Side Effects:  *	Only those associated with reading a character  *---------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|ParseReadLine
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|line
decl_stmt|;
comment|/* Result */
name|int
name|lineLength
decl_stmt|;
comment|/* Length of result */
name|int
name|lineno
decl_stmt|;
comment|/* Saved line # */
name|int
name|rval
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|line
operator|=
name|ParseGetLine
argument_list|(
literal|0
argument_list|,
operator|&
name|lineLength
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|!=
literal|'.'
condition|)
return|return
name|line
return|;
comment|/* 	 * The line might be a conditional. Ask the conditional module 	 * about it and act accordingly 	 */
switch|switch
condition|(
name|Cond_Eval
argument_list|(
name|line
argument_list|)
condition|)
block|{
case|case
name|COND_SKIP
case|:
comment|/* Skip to next conditional that evaluates to COND_PARSE.  */
do|do
block|{
name|line
operator|=
name|ParseGetLine
argument_list|(
name|PARSE_SKIP
argument_list|,
operator|&
name|lineLength
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|line
operator|&&
name|Cond_Eval
argument_list|(
name|line
argument_list|)
operator|!=
name|COND_PARSE
condition|)
do|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
break|break;
continue|continue;
case|case
name|COND_PARSE
case|:
continue|continue;
case|case
name|COND_INVALID
case|:
comment|/* Not a conditional line */
comment|/* Check for .for loops */
name|rval
operator|=
name|For_Eval
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
literal|0
condition|)
comment|/* Not a .for line */
break|break;
if|if
condition|(
name|rval
operator|<
literal|0
condition|)
comment|/* Syntax error - error printed, ignore line */
continue|continue;
comment|/* Start of a .for loop */
name|lineno
operator|=
name|curFile
operator|->
name|lineno
expr_stmt|;
comment|/* Accumulate loop lines until matching .endfor */
do|do
block|{
name|line
operator|=
name|ParseGetLine
argument_list|(
name|PARSE_RAW
argument_list|,
operator|&
name|lineLength
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Unexpected end of file in for loop."
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|For_Accum
argument_list|(
name|line
argument_list|)
condition|)
do|;
comment|/* Stash each iteration as a new 'input file' */
name|For_Run
argument_list|(
name|lineno
argument_list|)
expr_stmt|;
comment|/* Read next line from for-loop buffer */
continue|continue;
block|}
return|return
operator|(
name|line
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * ParseFinishLine --  *	Handle the end of a dependency group.  *  * Results:  *	Nothing.  *  * Side Effects:  *	inLine set FALSE. 'targets' list destroyed.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|ParseFinishLine
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|inLine
condition|)
block|{
name|Lst_ForEach
argument_list|(
name|targets
argument_list|,
name|Suff_EndTransform
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|Lst_Destroy
argument_list|(
name|targets
argument_list|,
name|ParseHasCommands
argument_list|)
expr_stmt|;
name|targets
operator|=
name|NULL
expr_stmt|;
name|inLine
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *---------------------------------------------------------------------  * Parse_File --  *	Parse a file into its component parts, incorporating it into the  *	current dependency graph. This is the main function and controls  *	almost every other function in this module  *  * Input:  *	name		the name of the file being read  *	fd		Open file to makefile to parse  *  * Results:  *	None  *  * Side Effects:  *	closes fd.  *	Loads. Nodes are added to the list of all targets, nodes and links  *	are added to the dependency graph. etc. etc. etc.  *---------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Parse_File
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* pointer into the line */
name|char
modifier|*
name|line
decl_stmt|;
comment|/* the line we're working on */
name|struct
name|loadedfile
modifier|*
name|lf
decl_stmt|;
name|lf
operator|=
name|loadfile
argument_list|(
name|name
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|inLine
operator|=
name|FALSE
expr_stmt|;
name|fatals
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|name
operator|=
literal|"(stdin)"
expr_stmt|;
block|}
name|Parse_SetInput
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|loadedfile_nextbuf
argument_list|,
name|lf
argument_list|)
expr_stmt|;
name|curFile
operator|->
name|lf
operator|=
name|lf
expr_stmt|;
do|do
block|{
for|for
control|(
init|;
operator|(
name|line
operator|=
name|ParseReadLine
argument_list|()
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
name|DEBUG
argument_list|(
name|PARSE
argument_list|)
condition|)
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"ParseReadLine (%d): '%s'\n"
argument_list|,
name|curFile
operator|->
name|lineno
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|line
operator|==
literal|'.'
condition|)
block|{
comment|/* 		 * Lines that begin with the special character may be 		 * include or undef directives. 		 * On the other hand they can be suffix rules (.c.o: ...) 		 * or just dependencies for filenames that start '.'. 		 */
for|for
control|(
name|cp
operator|=
name|line
operator|+
literal|1
init|;
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|;
name|cp
operator|++
control|)
block|{
continue|continue;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"include"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
operator|||
operator|(
operator|(
name|cp
index|[
literal|0
index|]
operator|==
literal|'d'
operator|||
name|cp
index|[
literal|0
index|]
operator|==
literal|'s'
operator|||
name|cp
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
operator|&&
name|strncmp
argument_list|(
operator|&
name|cp
index|[
literal|1
index|]
argument_list|,
literal|"include"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|ParseDoInclude
argument_list|(
name|cp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"undef"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|cp2
decl_stmt|;
for|for
control|(
name|cp
operator|+=
literal|5
init|;
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|;
name|cp
operator|++
control|)
continue|continue;
for|for
control|(
name|cp2
operator|=
name|cp
init|;
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp2
argument_list|)
operator|&&
operator|(
operator|*
name|cp2
operator|!=
literal|'\0'
operator|)
condition|;
name|cp2
operator|++
control|)
continue|continue;
operator|*
name|cp2
operator|=
literal|'\0'
expr_stmt|;
name|Var_Delete
argument_list|(
name|cp
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"export"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|cp
operator|+=
literal|6
init|;
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|;
name|cp
operator|++
control|)
continue|continue;
name|Var_Export
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"unexport"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Var_UnExport
argument_list|(
name|cp
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"info"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"error"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"warning"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ParseMessage
argument_list|(
name|cp
argument_list|)
condition|)
continue|continue;
block|}
block|}
if|if
condition|(
operator|*
name|line
operator|==
literal|'\t'
condition|)
block|{
comment|/* 		 * If a line starts with a tab, it can only hope to be 		 * a creation command. 		 */
name|cp
operator|=
name|line
operator|+
literal|1
expr_stmt|;
name|shellCommand
label|:
for|for
control|(
init|;
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|;
name|cp
operator|++
control|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|*
name|cp
condition|)
block|{
if|if
condition|(
operator|!
name|inLine
condition|)
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Unassociated shell command \"%s\""
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|/* 		     * So long as it's not a blank line and we're actually 		     * in a dependency spec, add the command to the list of 		     * commands of all targets in the dependency spec 		     */
if|if
condition|(
name|targets
condition|)
block|{
name|cp
operator|=
name|bmake_strdup
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|Lst_ForEach
argument_list|(
name|targets
argument_list|,
name|ParseAddCmd
argument_list|,
name|cp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CLEANUP
name|Lst_AtEnd
argument_list|(
name|targCmds
argument_list|,
name|cp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
continue|continue;
block|}
ifdef|#
directive|ifdef
name|SYSVINCLUDE
if|if
condition|(
operator|(
operator|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"include"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|line
index|[
literal|7
index|]
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|line
index|[
literal|0
index|]
operator|==
literal|'s'
operator|||
name|line
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
operator|&&
name|strncmp
argument_list|(
operator|&
name|line
index|[
literal|1
index|]
argument_list|,
literal|"include"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|line
index|[
literal|8
index|]
argument_list|)
operator|)
operator|)
operator|&&
name|strchr
argument_list|(
name|line
argument_list|,
literal|':'
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * It's an S3/S5-style "include". 		 */
name|ParseTraditionalInclude
argument_list|(
name|line
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|GMAKEEXPORT
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"export"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|line
index|[
literal|6
index|]
argument_list|)
operator|&&
name|strchr
argument_list|(
name|line
argument_list|,
literal|':'
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * It's a Gmake "export". 		 */
name|ParseGmakeExport
argument_list|(
name|line
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
if|if
condition|(
name|Parse_IsVar
argument_list|(
name|line
argument_list|)
condition|)
block|{
name|ParseFinishLine
argument_list|()
expr_stmt|;
name|Parse_DoVar
argument_list|(
name|line
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifndef|#
directive|ifndef
name|POSIX
comment|/* 	     * To make life easier on novices, if the line is indented we 	     * first make sure the line has a dependency operator in it. 	     * If it doesn't have an operator and we're in a dependency 	     * line's script, we assume it's actually a shell command 	     * and add it to the current list of targets. 	     */
name|cp
operator|=
name|line
expr_stmt|;
if|if
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|line
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
while|while
condition|(
operator|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|)
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|&&
operator|(
name|ParseIsEscaped
argument_list|(
name|line
argument_list|,
name|cp
argument_list|)
operator|||
operator|(
operator|*
name|cp
operator|!=
literal|':'
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|!=
literal|'!'
operator|)
operator|)
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|inLine
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_WARNING
argument_list|,
literal|"Shell command needs a leading tab"
argument_list|)
expr_stmt|;
goto|goto
name|shellCommand
goto|;
block|}
block|}
block|}
endif|#
directive|endif
name|ParseFinishLine
argument_list|()
expr_stmt|;
comment|/* 	     * For some reason - probably to make the parser impossible - 	     * a ';' can be used to separate commands from dependencies. 	     * Attempt to avoid ';' inside substitution patterns. 	     */
block|{
name|int
name|level
init|=
literal|0
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|line
init|;
operator|*
name|cp
operator|!=
literal|0
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\\'
operator|&&
name|cp
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
name|cp
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'$'
operator|&&
operator|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'('
operator|||
name|cp
index|[
literal|1
index|]
operator|==
literal|'{'
operator|)
condition|)
block|{
name|level
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|level
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|')'
operator|||
operator|*
name|cp
operator|==
literal|'}'
condition|)
block|{
name|level
operator|--
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|';'
condition|)
block|{
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|*
name|cp
operator|!=
literal|0
condition|)
comment|/* Terminate the dependency list at the ';' */
operator|*
name|cp
operator|++
operator|=
literal|0
expr_stmt|;
else|else
name|cp
operator|=
name|NULL
expr_stmt|;
comment|/* 	     * We now know it's a dependency line so it needs to have all 	     * variables expanded before being parsed. Tell the variable 	     * module to complain if some variable is undefined... 	     */
name|line
operator|=
name|Var_Subst
argument_list|(
name|NULL
argument_list|,
name|line
argument_list|,
name|VAR_CMD
argument_list|,
name|VARF_UNDEFERR
operator||
name|VARF_WANTRES
argument_list|)
expr_stmt|;
comment|/* 	     * Need a non-circular list for the target nodes 	     */
if|if
condition|(
name|targets
condition|)
name|Lst_Destroy
argument_list|(
name|targets
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|targets
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|inLine
operator|=
name|TRUE
expr_stmt|;
name|ParseDoDependency
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|/* If there were commands after a ';', add them now */
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
goto|goto
name|shellCommand
goto|;
block|}
block|}
comment|/* 	 * Reached EOF, but it may be just EOF of an include file... 	 */
block|}
do|while
condition|(
name|ParseEOF
argument_list|()
operator|==
name|CONTINUE
condition|)
do|;
if|if
condition|(
name|fatals
condition|)
block|{
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Fatal errors encountered -- cannot continue"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|PrintOnError
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  *---------------------------------------------------------------------  * Parse_Init --  *	initialize the parsing module  *  * Results:  *	none  *  * Side Effects:  *	the parseIncPath list is initialized...  *---------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Parse_Init
parameter_list|(
name|void
parameter_list|)
block|{
name|mainNode
operator|=
name|NULL
expr_stmt|;
name|parseIncPath
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|sysIncPath
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|defIncPath
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|includes
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CLEANUP
name|targCmds
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|Parse_End
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CLEANUP
name|Lst_Destroy
argument_list|(
name|targCmds
argument_list|,
operator|(
name|FreeProc
operator|*
operator|)
name|free
argument_list|)
expr_stmt|;
if|if
condition|(
name|targets
condition|)
name|Lst_Destroy
argument_list|(
name|targets
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|Lst_Destroy
argument_list|(
name|defIncPath
argument_list|,
name|Dir_Destroy
argument_list|)
expr_stmt|;
name|Lst_Destroy
argument_list|(
name|sysIncPath
argument_list|,
name|Dir_Destroy
argument_list|)
expr_stmt|;
name|Lst_Destroy
argument_list|(
name|parseIncPath
argument_list|,
name|Dir_Destroy
argument_list|)
expr_stmt|;
name|Lst_Destroy
argument_list|(
name|includes
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Should be empty now */
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Parse_MainName --  *	Return a Lst of the main target to create for main()'s sake. If  *	no such target exists, we Punt with an obnoxious error message.  *  * Results:  *	A Lst of the single node to create.  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|Lst
name|Parse_MainName
parameter_list|(
name|void
parameter_list|)
block|{
name|Lst
name|mainList
decl_stmt|;
comment|/* result list */
name|mainList
operator|=
name|Lst_Init
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mainNode
operator|==
name|NULL
condition|)
block|{
name|Punt
argument_list|(
literal|"no target to make."
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
elseif|else
if|if
condition|(
name|mainNode
operator|->
name|type
operator|&
name|OP_DOUBLEDEP
condition|)
block|{
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|mainList
argument_list|,
name|mainNode
argument_list|)
expr_stmt|;
name|Lst_Concat
argument_list|(
name|mainList
argument_list|,
name|mainNode
operator|->
name|cohorts
argument_list|,
name|LST_CONCNEW
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|Lst_AtEnd
argument_list|(
name|mainList
argument_list|,
name|mainNode
argument_list|)
expr_stmt|;
name|Var_Append
argument_list|(
literal|".TARGETS"
argument_list|,
name|mainNode
operator|->
name|name
argument_list|,
name|VAR_GLOBAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|mainList
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * ParseMark --  *	Add the filename and lineno to the GNode so that we remember  *	where it was first defined.  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|ParseMark
parameter_list|(
name|GNode
modifier|*
name|gn
parameter_list|)
block|{
name|gn
operator|->
name|fname
operator|=
name|curFile
operator|->
name|fname
expr_stmt|;
name|gn
operator|->
name|lineno
operator|=
name|curFile
operator|->
name|lineno
expr_stmt|;
block|}
end_function

end_unit

