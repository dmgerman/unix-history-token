begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: cond.c,v 1.67 2012/11/03 13:59:27 christos Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 1988, 1989, 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Adam de Boor.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1988, 1989 by Adam de Boor  * Copyright (c) 1989 by Berkeley Softworks  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Adam de Boor.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAKE_NATIVE
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$NetBSD: cond.c,v 1.67 2012/11/03 13:59:27 christos Exp $"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_else
unit|static char sccsid[] = "@(#)cond.c	8.2 (Berkeley) 1/2/94";
else|#
directive|else
end_else

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$NetBSD: cond.c,v 1.67 2012/11/03 13:59:27 christos Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*-  * cond.c --  *	Functions to handle conditionals in a makefile.  *  * Interface:  *	Cond_Eval 	Evaluate the conditional in the passed line.  *  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* For strtoul() error checking */
end_comment

begin_include
include|#
directive|include
file|"make.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_comment
comment|/*  * The parsing of conditional expressions is based on this grammar:  *	E -> F || E  *	E -> F  *	F -> T&& F  *	F -> T  *	T -> defined(variable)  *	T -> make(target)  *	T -> exists(file)  *	T -> empty(varspec)  *	T -> target(name)  *	T -> commands(name)  *	T -> symbol  *	T -> $(varspec) op value  *	T -> $(varspec) == "string"  *	T -> $(varspec) != "string"  *	T -> "string"  *	T -> ( E )  *	T -> ! T  *	op -> == | != |> |< |>= |<=  *  * 'symbol' is some other symbol to which the default function (condDefProc)  * is applied.  *  * Tokens are scanned from the 'condExpr' string. The scanner (CondToken)  * will return TOK_AND for '&' and '&&', TOK_OR for '|' and '||',  * TOK_NOT for '!', TOK_LPAREN for '(', TOK_RPAREN for ')' and will evaluate  * the other terminal symbols, using either the default function or the  * function given in the terminal, and return the result as either TOK_TRUE  * or TOK_FALSE.  *  * TOK_FALSE is 0 and TOK_TRUE 1 so we can directly assign C comparisons.  *  * All Non-Terminal functions (CondE, CondF and CondT) return TOK_ERROR on  * error.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|TOK_FALSE
init|=
literal|0
block|,
name|TOK_TRUE
init|=
literal|1
block|,
name|TOK_AND
block|,
name|TOK_OR
block|,
name|TOK_NOT
block|,
name|TOK_LPAREN
block|,
name|TOK_RPAREN
block|,
name|TOK_EOF
block|,
name|TOK_NONE
block|,
name|TOK_ERROR
block|}
name|Token
typedef|;
end_typedef

begin_comment
comment|/*-  * Structures to handle elegantly the different forms of #if's. The  * last two fields are stored in condInvert and condDefProc, respectively.  */
end_comment

begin_function_decl
specifier|static
name|void
name|CondPushBack
parameter_list|(
name|Token
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|CondGetArg
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Boolean
name|CondDoDefined
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|CondStrMatch
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Boolean
name|CondDoMake
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Boolean
name|CondDoExists
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Boolean
name|CondDoTarget
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Boolean
name|CondDoCommands
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Boolean
name|CondCvtArg
parameter_list|(
name|char
modifier|*
parameter_list|,
name|double
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Token
name|CondToken
parameter_list|(
name|Boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Token
name|CondT
parameter_list|(
name|Boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Token
name|CondF
parameter_list|(
name|Boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Token
name|CondE
parameter_list|(
name|Boolean
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_Cond_EvalExpression
parameter_list|(
name|Boolean
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_struct
specifier|static
specifier|const
struct|struct
name|If
block|{
specifier|const
name|char
modifier|*
name|form
decl_stmt|;
comment|/* Form of if */
name|int
name|formlen
decl_stmt|;
comment|/* Length of form */
name|Boolean
name|doNot
decl_stmt|;
comment|/* TRUE if default function should be negated */
name|Boolean
function_decl|(
modifier|*
name|defProc
function_decl|)
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
comment|/* Default function to apply */
block|}
name|ifs
index|[]
init|=
block|{
block|{
literal|"def"
block|,
literal|3
block|,
name|FALSE
block|,
name|CondDoDefined
block|}
block|,
block|{
literal|"ndef"
block|,
literal|4
block|,
name|TRUE
block|,
name|CondDoDefined
block|}
block|,
block|{
literal|"make"
block|,
literal|4
block|,
name|FALSE
block|,
name|CondDoMake
block|}
block|,
block|{
literal|"nmake"
block|,
literal|5
block|,
name|TRUE
block|,
name|CondDoMake
block|}
block|,
block|{
literal|""
block|,
literal|0
block|,
name|FALSE
block|,
name|CondDoDefined
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|FALSE
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|If
modifier|*
name|if_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Info for current statement */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|condExpr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The expression to parse */
end_comment

begin_decl_stmt
specifier|static
name|Token
name|condPushBack
init|=
name|TOK_NONE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Single push-back token used in 					 * parsing */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|cond_depth
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current .if nesting level */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|cond_min_depth
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* depth at makefile open */
end_comment

begin_function
specifier|static
name|int
name|istoken
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
specifier|const
name|char
modifier|*
name|tok
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
return|return
name|strncmp
argument_list|(
name|str
argument_list|,
name|tok
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|isalpha
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|str
index|[
name|len
index|]
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * CondPushBack --  *	Push back the most recent token read. We only need one level of  *	this, so the thing is just stored in 'condPushback'.  *  * Input:  *	t		Token to push back into the "stream"  *  * Results:  *	None.  *  * Side Effects:  *	condPushback is overwritten.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|void
name|CondPushBack
parameter_list|(
name|Token
name|t
parameter_list|)
block|{
name|condPushBack
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * CondGetArg --  *	Find the argument of a built-in function.  *  * Input:  *	parens		TRUE if arg should be bounded by parens  *  * Results:  *	The length of the argument and the address of the argument.  *  * Side Effects:  *	The pointer is set to point to the closing parenthesis of the  *	function call.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|CondGetArg
parameter_list|(
name|char
modifier|*
modifier|*
name|linePtr
parameter_list|,
name|char
modifier|*
modifier|*
name|argPtr
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|argLen
decl_stmt|;
name|Buffer
name|buf
decl_stmt|;
name|int
name|paren_depth
decl_stmt|;
name|char
name|ch
decl_stmt|;
name|cp
operator|=
operator|*
name|linePtr
expr_stmt|;
if|if
condition|(
name|func
operator|!=
name|NULL
condition|)
comment|/* Skip opening '(' - verfied by caller */
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
comment|/* 	 * No arguments whatsoever. Because 'make' and 'defined' aren't really 	 * "reserved words", we don't print a message. I think this is better 	 * than hitting the user with a warning message every time s/he uses 	 * the word 'make' or 'defined' at the beginning of a symbol... 	 */
operator|*
name|argPtr
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
while|while
condition|(
operator|*
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|'\t'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
comment|/*      * Create a buffer for the argument and start it out at 16 characters      * long. Why 16? Why not?      */
name|Buf_Init
argument_list|(
operator|&
name|buf
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|paren_depth
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ch
operator|=
operator|*
name|cp
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|0
operator|||
name|ch
operator|==
literal|' '
operator|||
name|ch
operator|==
literal|'\t'
condition|)
break|break;
if|if
condition|(
operator|(
name|ch
operator|==
literal|'&'
operator|||
name|ch
operator|==
literal|'|'
operator|)
operator|&&
name|paren_depth
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'$'
condition|)
block|{
comment|/* 	     * Parse the variable spec and install it as part of the argument 	     * if it's valid. We tell Var_Parse to complain on an undefined 	     * variable, so we don't do it too. Nor do we return an error, 	     * though perhaps we should... 	     */
name|char
modifier|*
name|cp2
decl_stmt|;
name|int
name|len
decl_stmt|;
name|void
modifier|*
name|freeIt
decl_stmt|;
name|cp2
operator|=
name|Var_Parse
argument_list|(
name|cp
argument_list|,
name|VAR_CMD
argument_list|,
name|TRUE
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|freeIt
argument_list|)
expr_stmt|;
name|Buf_AddBytes
argument_list|(
operator|&
name|buf
argument_list|,
name|strlen
argument_list|(
name|cp2
argument_list|)
argument_list|,
name|cp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeIt
condition|)
name|free
argument_list|(
name|freeIt
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|len
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ch
operator|==
literal|'('
condition|)
name|paren_depth
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|')'
operator|&&
operator|--
name|paren_depth
operator|<
literal|0
condition|)
break|break;
name|Buf_AddByte
argument_list|(
operator|&
name|buf
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
operator|*
name|argPtr
operator|=
name|Buf_GetAll
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|argLen
argument_list|)
expr_stmt|;
name|Buf_Destroy
argument_list|(
operator|&
name|buf
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|'\t'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|func
operator|!=
name|NULL
operator|&&
operator|*
name|cp
operator|++
operator|!=
literal|')'
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_WARNING
argument_list|,
literal|"Missing closing parenthesis for %s()"
argument_list|,
name|func
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|linePtr
operator|=
name|cp
expr_stmt|;
return|return
operator|(
name|argLen
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * CondDoDefined --  *	Handle the 'defined' function for conditionals.  *  * Results:  *	TRUE if the given variable is defined.  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Boolean
name|CondDoDefined
parameter_list|(
name|int
name|argLen
name|MAKE_ATTR_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|char
modifier|*
name|p1
decl_stmt|;
name|Boolean
name|result
decl_stmt|;
if|if
condition|(
name|Var_Value
argument_list|(
name|arg
argument_list|,
name|VAR_CMD
argument_list|,
operator|&
name|p1
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|p1
condition|)
name|free
argument_list|(
name|p1
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * CondStrMatch --  *	Front-end for Str_Match so it returns 0 on match and non-zero  *	on mismatch. Callback function for CondDoMake via Lst_Find  *  * Results:  *	0 if string matches pattern  *  * Side Effects:  *	None  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|int
name|CondStrMatch
parameter_list|(
specifier|const
name|void
modifier|*
name|string
parameter_list|,
specifier|const
name|void
modifier|*
name|pattern
parameter_list|)
block|{
return|return
operator|(
operator|!
name|Str_Match
argument_list|(
name|string
argument_list|,
name|pattern
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * CondDoMake --  *	Handle the 'make' function for conditionals.  *  * Results:  *	TRUE if the given target is being made.  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Boolean
name|CondDoMake
parameter_list|(
name|int
name|argLen
name|MAKE_ATTR_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
block|{
return|return
name|Lst_Find
argument_list|(
name|create
argument_list|,
name|arg
argument_list|,
name|CondStrMatch
argument_list|)
operator|!=
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * CondDoExists --  *	See if the given file exists.  *  * Results:  *	TRUE if the file exists and FALSE if it does not.  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Boolean
name|CondDoExists
parameter_list|(
name|int
name|argLen
name|MAKE_ATTR_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|Boolean
name|result
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|path
operator|=
name|Dir_FindFile
argument_list|(
name|arg
argument_list|,
name|dirSearchPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG
argument_list|(
name|COND
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"exists(%s) result is \"%s\"\n"
argument_list|,
name|arg
argument_list|,
name|path
condition|?
name|path
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|path
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|TRUE
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * CondDoTarget --  *	See if the given node exists and is an actual target.  *  * Results:  *	TRUE if the node exists as a target and FALSE if it does not.  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Boolean
name|CondDoTarget
parameter_list|(
name|int
name|argLen
name|MAKE_ATTR_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|GNode
modifier|*
name|gn
decl_stmt|;
name|gn
operator|=
name|Targ_FindNode
argument_list|(
name|arg
argument_list|,
name|TARG_NOCREATE
argument_list|)
expr_stmt|;
return|return
operator|(
name|gn
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|OP_NOP
argument_list|(
name|gn
operator|->
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * CondDoCommands --  *	See if the given node exists and is an actual target with commands  *	associated with it.  *  * Results:  *	TRUE if the node exists as a target and has commands associated with  *	it and FALSE if it does not.  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Boolean
name|CondDoCommands
parameter_list|(
name|int
name|argLen
name|MAKE_ATTR_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|GNode
modifier|*
name|gn
decl_stmt|;
name|gn
operator|=
name|Targ_FindNode
argument_list|(
name|arg
argument_list|,
name|TARG_NOCREATE
argument_list|)
expr_stmt|;
return|return
operator|(
name|gn
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|OP_NOP
argument_list|(
name|gn
operator|->
name|type
argument_list|)
operator|&&
operator|!
name|Lst_IsEmpty
argument_list|(
name|gn
operator|->
name|commands
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * CondCvtArg --  *	Convert the given number into a double.  *	We try a base 10 or 16 integer conversion first, if that fails  *	then we try a floating point conversion instead.  *  * Results:  *	Sets 'value' to double value of string.  *	Returns 'true' if the convertion suceeded  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Boolean
name|CondCvtArg
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|double
modifier|*
name|value
parameter_list|)
block|{
name|char
modifier|*
name|eptr
decl_stmt|,
name|ech
decl_stmt|;
name|unsigned
name|long
name|l_val
decl_stmt|;
name|double
name|d_val
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|l_val
operator|=
name|strtoul
argument_list|(
name|str
argument_list|,
operator|&
name|eptr
argument_list|,
name|str
index|[
literal|1
index|]
operator|==
literal|'x'
condition|?
literal|16
else|:
literal|10
argument_list|)
expr_stmt|;
name|ech
operator|=
operator|*
name|eptr
expr_stmt|;
if|if
condition|(
name|ech
operator|==
literal|0
operator|&&
name|errno
operator|!=
name|ERANGE
condition|)
block|{
name|d_val
operator|=
name|str
index|[
literal|0
index|]
operator|==
literal|'-'
condition|?
operator|-
operator|(
name|double
operator|)
operator|-
name|l_val
else|:
operator|(
name|double
operator|)
name|l_val
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ech
operator|!=
literal|0
operator|&&
name|ech
operator|!=
literal|'.'
operator|&&
name|ech
operator|!=
literal|'e'
operator|&&
name|ech
operator|!=
literal|'E'
condition|)
return|return
name|FALSE
return|;
name|d_val
operator|=
name|strtod
argument_list|(
name|str
argument_list|,
operator|&
name|eptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|eptr
condition|)
return|return
name|FALSE
return|;
block|}
operator|*
name|value
operator|=
name|d_val
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * CondGetString --  *	Get a string from a variable reference or an optionally quoted  *	string.  This is called for the lhs and rhs of string compares.  *  * Results:  *	Sets freeIt if needed,  *	Sets quoted if string was quoted,  *	Returns NULL on error,  *	else returns string - absent any quotes.  *  * Side Effects:  *	Moves condExpr to end of this token.  *  *  *-----------------------------------------------------------------------  */
end_comment

begin_comment
comment|/* coverity:[+alloc : arg-*2] */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|CondGetString
parameter_list|(
name|Boolean
name|doEval
parameter_list|,
name|Boolean
modifier|*
name|quoted
parameter_list|,
name|void
modifier|*
modifier|*
name|freeIt
parameter_list|)
block|{
name|Buffer
name|buf
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|qt
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|Buf_Init
argument_list|(
operator|&
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|str
operator|=
name|NULL
expr_stmt|;
operator|*
name|freeIt
operator|=
name|NULL
expr_stmt|;
operator|*
name|quoted
operator|=
name|qt
operator|=
operator|*
name|condExpr
operator|==
literal|'"'
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|qt
condition|)
name|condExpr
operator|++
expr_stmt|;
for|for
control|(
name|start
operator|=
name|condExpr
init|;
operator|*
name|condExpr
operator|&&
name|str
operator|==
name|NULL
condition|;
name|condExpr
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|condExpr
condition|)
block|{
case|case
literal|'\\'
case|:
if|if
condition|(
name|condExpr
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|condExpr
operator|++
expr_stmt|;
name|Buf_AddByte
argument_list|(
operator|&
name|buf
argument_list|,
operator|*
name|condExpr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'"'
case|:
if|if
condition|(
name|qt
condition|)
block|{
name|condExpr
operator|++
expr_stmt|;
comment|/* we don't want the quotes */
goto|goto
name|got_str
goto|;
block|}
else|else
name|Buf_AddByte
argument_list|(
operator|&
name|buf
argument_list|,
operator|*
name|condExpr
argument_list|)
expr_stmt|;
comment|/* likely? */
break|break;
case|case
literal|')'
case|:
case|case
literal|'!'
case|:
case|case
literal|'='
case|:
case|case
literal|'>'
case|:
case|case
literal|'<'
case|:
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
if|if
condition|(
operator|!
name|qt
condition|)
goto|goto
name|got_str
goto|;
else|else
name|Buf_AddByte
argument_list|(
operator|&
name|buf
argument_list|,
operator|*
name|condExpr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
comment|/* if we are in quotes, then an undefined variable is ok */
name|str
operator|=
name|Var_Parse
argument_list|(
name|condExpr
argument_list|,
name|VAR_CMD
argument_list|,
operator|(
name|qt
condition|?
literal|0
else|:
name|doEval
operator|)
argument_list|,
operator|&
name|len
argument_list|,
name|freeIt
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|var_Error
condition|)
block|{
if|if
condition|(
operator|*
name|freeIt
condition|)
block|{
name|free
argument_list|(
operator|*
name|freeIt
argument_list|)
expr_stmt|;
operator|*
name|freeIt
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 		 * Even if !doEval, we still report syntax errors, which 		 * is what getting var_Error back with !doEval means. 		 */
name|str
operator|=
name|NULL
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|condExpr
operator|+=
name|len
expr_stmt|;
comment|/* 	     * If the '$' was first char (no quotes), and we are 	     * followed by space, the operator or end of expression, 	     * we are done. 	     */
if|if
condition|(
operator|(
name|condExpr
operator|==
name|start
operator|+
name|len
operator|)
operator|&&
operator|(
operator|*
name|condExpr
operator|==
literal|'\0'
operator|||
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|condExpr
argument_list|)
operator|||
name|strchr
argument_list|(
literal|"!=><)"
argument_list|,
operator|*
name|condExpr
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|cleanup
goto|;
block|}
comment|/* 	     * Nope, we better copy str to buf 	     */
for|for
control|(
name|cp
operator|=
name|str
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
name|Buf_AddByte
argument_list|(
operator|&
name|buf
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|freeIt
condition|)
block|{
name|free
argument_list|(
operator|*
name|freeIt
argument_list|)
expr_stmt|;
operator|*
name|freeIt
operator|=
name|NULL
expr_stmt|;
block|}
name|str
operator|=
name|NULL
expr_stmt|;
comment|/* not finished yet */
name|condExpr
operator|--
expr_stmt|;
comment|/* don't skip over next char */
break|break;
default|default:
name|Buf_AddByte
argument_list|(
operator|&
name|buf
argument_list|,
operator|*
name|condExpr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|got_str
label|:
name|str
operator|=
name|Buf_GetAll
argument_list|(
operator|&
name|buf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|freeIt
operator|=
name|str
expr_stmt|;
name|cleanup
label|:
name|Buf_Destroy
argument_list|(
operator|&
name|buf
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * CondToken --  *	Return the next token from the input.  *  * Results:  *	A Token for the next lexical token in the stream.  *  * Side Effects:  *	condPushback will be set back to TOK_NONE if it is used.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Token
name|compare_expression
parameter_list|(
name|Boolean
name|doEval
parameter_list|)
block|{
name|Token
name|t
decl_stmt|;
name|char
modifier|*
name|lhs
decl_stmt|;
name|char
modifier|*
name|rhs
decl_stmt|;
name|char
modifier|*
name|op
decl_stmt|;
name|void
modifier|*
name|lhsFree
decl_stmt|;
name|void
modifier|*
name|rhsFree
decl_stmt|;
name|Boolean
name|lhsQuoted
decl_stmt|;
name|Boolean
name|rhsQuoted
decl_stmt|;
name|double
name|left
decl_stmt|,
name|right
decl_stmt|;
name|t
operator|=
name|TOK_ERROR
expr_stmt|;
name|rhs
operator|=
name|NULL
expr_stmt|;
name|lhsFree
operator|=
name|rhsFree
operator|=
name|FALSE
expr_stmt|;
name|lhsQuoted
operator|=
name|rhsQuoted
operator|=
name|FALSE
expr_stmt|;
comment|/*      * Parse the variable spec and skip over it, saving its      * value in lhs.      */
name|lhs
operator|=
name|CondGetString
argument_list|(
name|doEval
argument_list|,
operator|&
name|lhsQuoted
argument_list|,
operator|&
name|lhsFree
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lhs
condition|)
goto|goto
name|done
goto|;
comment|/*      * Skip whitespace to get to the operator      */
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|condExpr
argument_list|)
condition|)
name|condExpr
operator|++
expr_stmt|;
comment|/*      * Make sure the operator is a valid one. If it isn't a      * known relational operator, pretend we got a      * != 0 comparison.      */
name|op
operator|=
name|condExpr
expr_stmt|;
switch|switch
condition|(
operator|*
name|condExpr
condition|)
block|{
case|case
literal|'!'
case|:
case|case
literal|'='
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
if|if
condition|(
name|condExpr
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
block|{
name|condExpr
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|condExpr
operator|+=
literal|1
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
operator|!
name|doEval
condition|)
block|{
name|t
operator|=
name|TOK_FALSE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* For .ifxxx "..." check for non-empty string. */
if|if
condition|(
name|lhsQuoted
condition|)
block|{
name|t
operator|=
name|lhs
index|[
literal|0
index|]
operator|!=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* For .ifxxx<number> compare against zero */
if|if
condition|(
name|CondCvtArg
argument_list|(
name|lhs
argument_list|,
operator|&
name|left
argument_list|)
condition|)
block|{
name|t
operator|=
name|left
operator|!=
literal|0.0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* For .if ${...} check for non-empty string (defProc is ifdef). */
if|if
condition|(
name|if_info
operator|->
name|form
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|t
operator|=
name|lhs
index|[
literal|0
index|]
operator|!=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Otherwise action default test ... */
name|t
operator|=
name|if_info
operator|->
name|defProc
argument_list|(
name|strlen
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|lhs
argument_list|)
operator|!=
name|if_info
operator|->
name|doNot
expr_stmt|;
goto|goto
name|done
goto|;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|condExpr
argument_list|)
condition|)
name|condExpr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|condExpr
operator|==
literal|'\0'
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_WARNING
argument_list|,
literal|"Missing right-hand-side of operator"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|rhs
operator|=
name|CondGetString
argument_list|(
name|doEval
argument_list|,
operator|&
name|rhsQuoted
argument_list|,
operator|&
name|rhsFree
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rhs
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|rhsQuoted
operator|||
name|lhsQuoted
condition|)
block|{
name|do_string_compare
label|:
if|if
condition|(
operator|(
operator|(
operator|*
name|op
operator|!=
literal|'!'
operator|)
operator|&&
operator|(
operator|*
name|op
operator|!=
literal|'='
operator|)
operator|)
operator|||
operator|(
name|op
index|[
literal|1
index|]
operator|!=
literal|'='
operator|)
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_WARNING
argument_list|,
literal|"String comparison operator should be either == or !="
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|DEBUG
argument_list|(
name|COND
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"lhs = \"%s\", rhs = \"%s\", op = %.2s\n"
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Null-terminate rhs and perform the comparison. 	 * t is set to the result. 	 */
if|if
condition|(
operator|*
name|op
operator|==
literal|'='
condition|)
block|{
name|t
operator|=
name|strcmp
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
operator|==
literal|0
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|strcmp
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
operator|!=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	 * rhs is either a float or an integer. Convert both the 	 * lhs and the rhs to a double and compare the two. 	 */
if|if
condition|(
operator|!
name|CondCvtArg
argument_list|(
name|lhs
argument_list|,
operator|&
name|left
argument_list|)
operator|||
operator|!
name|CondCvtArg
argument_list|(
name|rhs
argument_list|,
operator|&
name|right
argument_list|)
condition|)
goto|goto
name|do_string_compare
goto|;
if|if
condition|(
name|DEBUG
argument_list|(
name|COND
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|debug_file
argument_list|,
literal|"left = %f, right = %f, op = %.2s\n"
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|op
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'!'
case|:
if|if
condition|(
name|op
index|[
literal|1
index|]
operator|!=
literal|'='
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_WARNING
argument_list|,
literal|"Unknown operator"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|t
operator|=
operator|(
name|left
operator|!=
name|right
operator|)
expr_stmt|;
break|break;
case|case
literal|'='
case|:
if|if
condition|(
name|op
index|[
literal|1
index|]
operator|!=
literal|'='
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_WARNING
argument_list|,
literal|"Unknown operator"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|t
operator|=
operator|(
name|left
operator|==
name|right
operator|)
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
if|if
condition|(
name|op
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
block|{
name|t
operator|=
operator|(
name|left
operator|<=
name|right
operator|)
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
operator|(
name|left
operator|<
name|right
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
name|op
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
block|{
name|t
operator|=
operator|(
name|left
operator|>=
name|right
operator|)
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
operator|(
name|left
operator|>
name|right
operator|)
expr_stmt|;
block|}
break|break;
block|}
block|}
name|done
label|:
if|if
condition|(
name|lhsFree
condition|)
name|free
argument_list|(
name|lhsFree
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhsFree
condition|)
name|free
argument_list|(
name|rhsFree
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_mpt_arg
parameter_list|(
name|char
modifier|*
modifier|*
name|linePtr
parameter_list|,
name|char
modifier|*
modifier|*
name|argPtr
parameter_list|,
specifier|const
name|char
modifier|*
name|func
name|MAKE_ATTR_UNUSED
parameter_list|)
block|{
comment|/*      * Use Var_Parse to parse the spec in parens and return      * TOK_TRUE if the resulting string is empty.      */
name|int
name|length
decl_stmt|;
name|void
modifier|*
name|freeIt
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|char
modifier|*
name|cp
init|=
operator|*
name|linePtr
decl_stmt|;
comment|/* We do all the work here and return the result as the length */
operator|*
name|argPtr
operator|=
name|NULL
expr_stmt|;
name|val
operator|=
name|Var_Parse
argument_list|(
name|cp
operator|-
literal|1
argument_list|,
name|VAR_CMD
argument_list|,
name|FALSE
argument_list|,
operator|&
name|length
argument_list|,
operator|&
name|freeIt
argument_list|)
expr_stmt|;
comment|/*      * Advance *linePtr to beyond the closing ). Note that      * we subtract one because 'length' is calculated from 'cp - 1'.      */
operator|*
name|linePtr
operator|=
name|cp
operator|-
literal|1
operator|+
name|length
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|var_Error
condition|)
block|{
name|free
argument_list|(
name|freeIt
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* A variable is empty when it just contains spaces... 4/15/92, christos */
while|while
condition|(
name|isspace
argument_list|(
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|val
argument_list|)
condition|)
name|val
operator|++
expr_stmt|;
comment|/*      * For consistency with the other functions we can't generate the      * true/false here.      */
name|length
operator|=
operator|*
name|val
condition|?
literal|2
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|freeIt
condition|)
name|free
argument_list|(
name|freeIt
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
end_function

begin_function
specifier|static
name|Boolean
name|CondDoEmpty
parameter_list|(
name|int
name|arglen
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
name|MAKE_ATTR_UNUSED
parameter_list|)
block|{
return|return
name|arglen
operator|==
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|Token
name|compare_function
parameter_list|(
name|Boolean
name|doEval
parameter_list|)
block|{
specifier|static
specifier|const
struct|struct
name|fn_def
block|{
specifier|const
name|char
modifier|*
name|fn_name
decl_stmt|;
name|int
name|fn_name_len
decl_stmt|;
name|int
function_decl|(
modifier|*
name|fn_getarg
function_decl|)
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|Boolean
function_decl|(
modifier|*
name|fn_proc
function_decl|)
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
block|}
name|fn_defs
index|[]
init|=
block|{
block|{
literal|"defined"
block|,
literal|7
block|,
name|CondGetArg
block|,
name|CondDoDefined
block|}
block|,
block|{
literal|"make"
block|,
literal|4
block|,
name|CondGetArg
block|,
name|CondDoMake
block|}
block|,
block|{
literal|"exists"
block|,
literal|6
block|,
name|CondGetArg
block|,
name|CondDoExists
block|}
block|,
block|{
literal|"empty"
block|,
literal|5
block|,
name|get_mpt_arg
block|,
name|CondDoEmpty
block|}
block|,
block|{
literal|"target"
block|,
literal|6
block|,
name|CondGetArg
block|,
name|CondDoTarget
block|}
block|,
block|{
literal|"commands"
block|,
literal|8
block|,
name|CondGetArg
block|,
name|CondDoCommands
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|,     }
struct|;
specifier|const
name|struct
name|fn_def
modifier|*
name|fn_def
decl_stmt|;
name|Token
name|t
decl_stmt|;
name|char
modifier|*
name|arg
init|=
name|NULL
decl_stmt|;
name|int
name|arglen
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|condExpr
decl_stmt|;
name|char
modifier|*
name|cp1
decl_stmt|;
for|for
control|(
name|fn_def
operator|=
name|fn_defs
init|;
name|fn_def
operator|->
name|fn_name
operator|!=
name|NULL
condition|;
name|fn_def
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|istoken
argument_list|(
name|cp
argument_list|,
name|fn_def
operator|->
name|fn_name
argument_list|,
name|fn_def
operator|->
name|fn_name_len
argument_list|)
condition|)
continue|continue;
name|cp
operator|+=
name|fn_def
operator|->
name|fn_name_len
expr_stmt|;
comment|/* There can only be whitespace before the '(' */
while|while
condition|(
name|isspace
argument_list|(
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'('
condition|)
break|break;
name|arglen
operator|=
name|fn_def
operator|->
name|fn_getarg
argument_list|(
operator|&
name|cp
argument_list|,
operator|&
name|arg
argument_list|,
name|fn_def
operator|->
name|fn_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglen
operator|<=
literal|0
condition|)
block|{
name|condExpr
operator|=
name|cp
expr_stmt|;
return|return
name|arglen
operator|<
literal|0
condition|?
name|TOK_ERROR
else|:
name|TOK_FALSE
return|;
block|}
comment|/* Evaluate the argument using the required function. */
name|t
operator|=
operator|!
name|doEval
operator|||
name|fn_def
operator|->
name|fn_proc
argument_list|(
name|arglen
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
condition|)
name|free
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|condExpr
operator|=
name|cp
expr_stmt|;
return|return
name|t
return|;
block|}
comment|/* Push anything numeric through the compare expression */
name|cp
operator|=
name|condExpr
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|cp
index|[
literal|0
index|]
argument_list|)
operator|||
name|strchr
argument_list|(
literal|"+-"
argument_list|,
name|cp
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
name|compare_expression
argument_list|(
name|doEval
argument_list|)
return|;
comment|/*      * Most likely we have a naked token to apply the default function to.      * However ".if a == b" gets here when the "a" is unquoted and doesn't      * start with a '$'. This surprises people.      * If what follows the function argument is a '=' or '!' then the syntax      * would be invalid if we did "defined(a)" - so instead treat as an      * expression.      */
name|arglen
operator|=
name|CondGetArg
argument_list|(
operator|&
name|cp
argument_list|,
operator|&
name|arg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|cp1
operator|=
name|cp
init|;
name|isspace
argument_list|(
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|cp1
argument_list|)
condition|;
name|cp1
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|cp1
operator|==
literal|'='
operator|||
operator|*
name|cp1
operator|==
literal|'!'
condition|)
return|return
name|compare_expression
argument_list|(
name|doEval
argument_list|)
return|;
name|condExpr
operator|=
name|cp
expr_stmt|;
comment|/*      * Evaluate the argument using the default function.      * This path always treats .if as .ifdef. To get here the character      * after .if must have been taken literally, so the argument cannot      * be empty - even if it contained a variable expansion.      */
name|t
operator|=
operator|!
name|doEval
operator|||
name|if_info
operator|->
name|defProc
argument_list|(
name|arglen
argument_list|,
name|arg
argument_list|)
operator|!=
name|if_info
operator|->
name|doNot
expr_stmt|;
if|if
condition|(
name|arg
condition|)
name|free
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
specifier|static
name|Token
name|CondToken
parameter_list|(
name|Boolean
name|doEval
parameter_list|)
block|{
name|Token
name|t
decl_stmt|;
name|t
operator|=
name|condPushBack
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|TOK_NONE
condition|)
block|{
name|condPushBack
operator|=
name|TOK_NONE
expr_stmt|;
return|return
name|t
return|;
block|}
while|while
condition|(
operator|*
name|condExpr
operator|==
literal|' '
operator|||
operator|*
name|condExpr
operator|==
literal|'\t'
condition|)
block|{
name|condExpr
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
operator|*
name|condExpr
condition|)
block|{
case|case
literal|'('
case|:
name|condExpr
operator|++
expr_stmt|;
return|return
name|TOK_LPAREN
return|;
case|case
literal|')'
case|:
name|condExpr
operator|++
expr_stmt|;
return|return
name|TOK_RPAREN
return|;
case|case
literal|'|'
case|:
if|if
condition|(
name|condExpr
index|[
literal|1
index|]
operator|==
literal|'|'
condition|)
block|{
name|condExpr
operator|++
expr_stmt|;
block|}
name|condExpr
operator|++
expr_stmt|;
return|return
name|TOK_OR
return|;
case|case
literal|'&'
case|:
if|if
condition|(
name|condExpr
index|[
literal|1
index|]
operator|==
literal|'&'
condition|)
block|{
name|condExpr
operator|++
expr_stmt|;
block|}
name|condExpr
operator|++
expr_stmt|;
return|return
name|TOK_AND
return|;
case|case
literal|'!'
case|:
name|condExpr
operator|++
expr_stmt|;
return|return
name|TOK_NOT
return|;
case|case
literal|'#'
case|:
case|case
literal|'\n'
case|:
case|case
literal|'\0'
case|:
return|return
name|TOK_EOF
return|;
case|case
literal|'"'
case|:
case|case
literal|'$'
case|:
return|return
name|compare_expression
argument_list|(
name|doEval
argument_list|)
return|;
default|default:
return|return
name|compare_function
argument_list|(
name|doEval
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * CondT --  *	Parse a single term in the expression. This consists of a terminal  *	symbol or TOK_NOT and a terminal symbol (not including the binary  *	operators):  *	    T -> defined(variable) | make(target) | exists(file) | symbol  *	    T -> ! T | ( E )  *  * Results:  *	TOK_TRUE, TOK_FALSE or TOK_ERROR.  *  * Side Effects:  *	Tokens are consumed.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Token
name|CondT
parameter_list|(
name|Boolean
name|doEval
parameter_list|)
block|{
name|Token
name|t
decl_stmt|;
name|t
operator|=
name|CondToken
argument_list|(
name|doEval
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|TOK_EOF
condition|)
block|{
comment|/* 	 * If we reached the end of the expression, the expression 	 * is malformed... 	 */
name|t
operator|=
name|TOK_ERROR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|TOK_LPAREN
condition|)
block|{
comment|/* 	 * T -> ( E ) 	 */
name|t
operator|=
name|CondE
argument_list|(
name|doEval
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|TOK_ERROR
condition|)
block|{
if|if
condition|(
name|CondToken
argument_list|(
name|doEval
argument_list|)
operator|!=
name|TOK_RPAREN
condition|)
block|{
name|t
operator|=
name|TOK_ERROR
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|TOK_NOT
condition|)
block|{
name|t
operator|=
name|CondT
argument_list|(
name|doEval
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|TOK_TRUE
condition|)
block|{
name|t
operator|=
name|TOK_FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|TOK_FALSE
condition|)
block|{
name|t
operator|=
name|TOK_TRUE
expr_stmt|;
block|}
block|}
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * CondF --  *	Parse a conjunctive factor (nice name, wot?)  *	    F -> T&& F | T  *  * Results:  *	TOK_TRUE, TOK_FALSE or TOK_ERROR  *  * Side Effects:  *	Tokens are consumed.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Token
name|CondF
parameter_list|(
name|Boolean
name|doEval
parameter_list|)
block|{
name|Token
name|l
decl_stmt|,
name|o
decl_stmt|;
name|l
operator|=
name|CondT
argument_list|(
name|doEval
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|!=
name|TOK_ERROR
condition|)
block|{
name|o
operator|=
name|CondToken
argument_list|(
name|doEval
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|TOK_AND
condition|)
block|{
comment|/* 	     * F -> T&& F 	     * 	     * If T is TOK_FALSE, the whole thing will be TOK_FALSE, but we have to 	     * parse the r.h.s. anyway (to throw it away). 	     * If T is TOK_TRUE, the result is the r.h.s., be it an TOK_ERROR or no. 	     */
if|if
condition|(
name|l
operator|==
name|TOK_TRUE
condition|)
block|{
name|l
operator|=
name|CondF
argument_list|(
name|doEval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|CondF
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	     * F -> T 	     */
name|CondPushBack
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|l
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * CondE --  *	Main expression production.  *	    E -> F || E | F  *  * Results:  *	TOK_TRUE, TOK_FALSE or TOK_ERROR.  *  * Side Effects:  *	Tokens are, of course, consumed.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
specifier|static
name|Token
name|CondE
parameter_list|(
name|Boolean
name|doEval
parameter_list|)
block|{
name|Token
name|l
decl_stmt|,
name|o
decl_stmt|;
name|l
operator|=
name|CondF
argument_list|(
name|doEval
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|!=
name|TOK_ERROR
condition|)
block|{
name|o
operator|=
name|CondToken
argument_list|(
name|doEval
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|TOK_OR
condition|)
block|{
comment|/* 	     * E -> F || E 	     * 	     * A similar thing occurs for ||, except that here we make sure 	     * the l.h.s. is TOK_FALSE before we bother to evaluate the r.h.s. 	     * Once again, if l is TOK_FALSE, the result is the r.h.s. and once 	     * again if l is TOK_TRUE, we parse the r.h.s. to throw it away. 	     */
if|if
condition|(
name|l
operator|==
name|TOK_FALSE
condition|)
block|{
name|l
operator|=
name|CondE
argument_list|(
name|doEval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|CondE
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	     * E -> F 	     */
name|CondPushBack
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|l
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Cond_EvalExpression --  *	Evaluate an expression in the passed line. The expression  *	consists of&&, ||, !, make(target), defined(variable)  *	and parenthetical groupings thereof.  *  * Results:  *	COND_PARSE	if the condition was valid grammatically  *	COND_INVALID  	if not a valid conditional.  *  *	(*value) is set to the boolean value of the condition  *  * Side Effects:  *	None.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Cond_EvalExpression
parameter_list|(
specifier|const
name|struct
name|If
modifier|*
name|info
parameter_list|,
name|char
modifier|*
name|line
parameter_list|,
name|Boolean
modifier|*
name|value
parameter_list|,
name|int
name|eprint
parameter_list|)
block|{
specifier|static
specifier|const
name|struct
name|If
modifier|*
name|dflt_info
decl_stmt|;
specifier|const
name|struct
name|If
modifier|*
name|sv_if_info
init|=
name|if_info
decl_stmt|;
name|char
modifier|*
name|sv_condExpr
init|=
name|condExpr
decl_stmt|;
name|Token
name|sv_condPushBack
init|=
name|condPushBack
decl_stmt|;
name|int
name|rval
decl_stmt|;
while|while
condition|(
operator|*
name|line
operator|==
literal|' '
operator|||
operator|*
name|line
operator|==
literal|'\t'
condition|)
name|line
operator|++
expr_stmt|;
if|if
condition|(
name|info
operator|==
name|NULL
operator|&&
operator|(
name|info
operator|=
name|dflt_info
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* Scan for the entry for .if - it can't be first */
for|for
control|(
name|info
operator|=
name|ifs
init|;
condition|;
name|info
operator|++
control|)
if|if
condition|(
name|info
operator|->
name|form
index|[
literal|0
index|]
operator|==
literal|0
condition|)
break|break;
name|dflt_info
operator|=
name|info
expr_stmt|;
block|}
name|if_info
operator|=
name|info
operator|!=
name|NULL
condition|?
name|info
else|:
name|ifs
operator|+
literal|4
expr_stmt|;
name|condExpr
operator|=
name|line
expr_stmt|;
name|condPushBack
operator|=
name|TOK_NONE
expr_stmt|;
name|rval
operator|=
name|do_Cond_EvalExpression
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|COND_INVALID
operator|&&
name|eprint
condition|)
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"Malformed conditional (%s)"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|if_info
operator|=
name|sv_if_info
expr_stmt|;
name|condExpr
operator|=
name|sv_condExpr
expr_stmt|;
name|condPushBack
operator|=
name|sv_condPushBack
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_Cond_EvalExpression
parameter_list|(
name|Boolean
modifier|*
name|value
parameter_list|)
block|{
switch|switch
condition|(
name|CondE
argument_list|(
name|TRUE
argument_list|)
condition|)
block|{
case|case
name|TOK_TRUE
case|:
if|if
condition|(
name|CondToken
argument_list|(
name|TRUE
argument_list|)
operator|==
name|TOK_EOF
condition|)
block|{
operator|*
name|value
operator|=
name|TRUE
expr_stmt|;
return|return
name|COND_PARSE
return|;
block|}
break|break;
case|case
name|TOK_FALSE
case|:
if|if
condition|(
name|CondToken
argument_list|(
name|TRUE
argument_list|)
operator|==
name|TOK_EOF
condition|)
block|{
operator|*
name|value
operator|=
name|FALSE
expr_stmt|;
return|return
name|COND_PARSE
return|;
block|}
break|break;
default|default:
case|case
name|TOK_ERROR
case|:
break|break;
block|}
return|return
name|COND_INVALID
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Cond_Eval --  *	Evaluate the conditional in the passed line. The line  *	looks like this:  *	    .<cond-type><expr>  *	where<cond-type> is any of if, ifmake, ifnmake, ifdef,  *	ifndef, elif, elifmake, elifnmake, elifdef, elifndef  *	and<expr> consists of&&, ||, !, make(target), defined(variable)  *	and parenthetical groupings thereof.  *  * Input:  *	line		Line to parse  *  * Results:  *	COND_PARSE	if should parse lines after the conditional  *	COND_SKIP	if should skip lines after the conditional  *	COND_INVALID  	if not a valid conditional.  *  * Side Effects:  *	None.  *  * Note that the states IF_ACTIVE and ELSE_ACTIVE are only different in order  * to detect splurious .else lines (as are SKIP_TO_ELSE and SKIP_TO_ENDIF)  * otherwise .else could be treated as '.elif 1'.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|int
name|Cond_Eval
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
define|#
directive|define
name|MAXIF
value|128
comment|/* maximum depth of .if'ing */
define|#
directive|define
name|MAXIF_BUMP
value|32
comment|/* how much to grow by */
enum|enum
name|if_states
block|{
name|IF_ACTIVE
block|,
comment|/* .if or .elif part active */
name|ELSE_ACTIVE
block|,
comment|/* .else part active */
name|SEARCH_FOR_ELIF
block|,
comment|/* searching for .elif/else to execute */
name|SKIP_TO_ELSE
block|,
comment|/* has been true, but not seen '.else' */
name|SKIP_TO_ENDIF
comment|/* nothing else to execute */
block|}
enum|;
specifier|static
name|enum
name|if_states
modifier|*
name|cond_state
init|=
name|NULL
decl_stmt|;
specifier|static
name|unsigned
name|int
name|max_if_depth
init|=
name|MAXIF
decl_stmt|;
specifier|const
name|struct
name|If
modifier|*
name|ifp
decl_stmt|;
name|Boolean
name|isElif
decl_stmt|;
name|Boolean
name|value
decl_stmt|;
name|int
name|level
decl_stmt|;
comment|/* Level at which to report errors. */
name|enum
name|if_states
name|state
decl_stmt|;
name|level
operator|=
name|PARSE_FATAL
expr_stmt|;
if|if
condition|(
operator|!
name|cond_state
condition|)
block|{
name|cond_state
operator|=
name|bmake_malloc
argument_list|(
name|max_if_depth
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cond_state
argument_list|)
argument_list|)
expr_stmt|;
name|cond_state
index|[
literal|0
index|]
operator|=
name|IF_ACTIVE
expr_stmt|;
block|}
comment|/* skip leading character (the '.') and any whitespace */
for|for
control|(
name|line
operator|++
init|;
operator|*
name|line
operator|==
literal|' '
operator|||
operator|*
name|line
operator|==
literal|'\t'
condition|;
name|line
operator|++
control|)
continue|continue;
comment|/* Find what type of if we're dealing with.  */
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|line
index|[
literal|1
index|]
operator|!=
literal|'l'
condition|)
block|{
if|if
condition|(
operator|!
name|istoken
argument_list|(
name|line
operator|+
literal|1
argument_list|,
literal|"ndif"
argument_list|,
literal|4
argument_list|)
condition|)
return|return
name|COND_INVALID
return|;
comment|/* End of conditional section */
if|if
condition|(
name|cond_depth
operator|==
name|cond_min_depth
condition|)
block|{
name|Parse_Error
argument_list|(
name|level
argument_list|,
literal|"if-less endif"
argument_list|)
expr_stmt|;
return|return
name|COND_PARSE
return|;
block|}
comment|/* Return state for previous conditional */
name|cond_depth
operator|--
expr_stmt|;
return|return
name|cond_state
index|[
name|cond_depth
index|]
operator|<=
name|ELSE_ACTIVE
condition|?
name|COND_PARSE
else|:
name|COND_SKIP
return|;
block|}
comment|/* Quite likely this is 'else' or 'elif' */
name|line
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|istoken
argument_list|(
name|line
argument_list|,
literal|"se"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* It is else... */
if|if
condition|(
name|cond_depth
operator|==
name|cond_min_depth
condition|)
block|{
name|Parse_Error
argument_list|(
name|level
argument_list|,
literal|"if-less else"
argument_list|)
expr_stmt|;
return|return
name|COND_PARSE
return|;
block|}
name|state
operator|=
name|cond_state
index|[
name|cond_depth
index|]
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|SEARCH_FOR_ELIF
case|:
name|state
operator|=
name|ELSE_ACTIVE
expr_stmt|;
break|break;
case|case
name|ELSE_ACTIVE
case|:
case|case
name|SKIP_TO_ENDIF
case|:
name|Parse_Error
argument_list|(
name|PARSE_WARNING
argument_list|,
literal|"extra else"
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
case|case
name|IF_ACTIVE
case|:
case|case
name|SKIP_TO_ELSE
case|:
name|state
operator|=
name|SKIP_TO_ENDIF
expr_stmt|;
break|break;
block|}
name|cond_state
index|[
name|cond_depth
index|]
operator|=
name|state
expr_stmt|;
return|return
name|state
operator|<=
name|ELSE_ACTIVE
condition|?
name|COND_PARSE
else|:
name|COND_SKIP
return|;
block|}
comment|/* Assume for now it is an elif */
name|isElif
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|isElif
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|!=
literal|'i'
operator|||
name|line
index|[
literal|1
index|]
operator|!=
literal|'f'
condition|)
comment|/* Not an ifxxx or elifxxx line */
return|return
name|COND_INVALID
return|;
comment|/*      * Figure out what sort of conditional it is -- what its default      * function is, etc. -- by looking in the table of valid "ifs"      */
name|line
operator|+=
literal|2
expr_stmt|;
for|for
control|(
name|ifp
operator|=
name|ifs
init|;
condition|;
name|ifp
operator|++
control|)
block|{
if|if
condition|(
name|ifp
operator|->
name|form
operator|==
name|NULL
condition|)
return|return
name|COND_INVALID
return|;
if|if
condition|(
name|istoken
argument_list|(
name|ifp
operator|->
name|form
argument_list|,
name|line
argument_list|,
name|ifp
operator|->
name|formlen
argument_list|)
condition|)
block|{
name|line
operator|+=
name|ifp
operator|->
name|formlen
expr_stmt|;
break|break;
block|}
block|}
comment|/* Now we know what sort of 'if' it is... */
if|if
condition|(
name|isElif
condition|)
block|{
if|if
condition|(
name|cond_depth
operator|==
name|cond_min_depth
condition|)
block|{
name|Parse_Error
argument_list|(
name|level
argument_list|,
literal|"if-less elif"
argument_list|)
expr_stmt|;
return|return
name|COND_PARSE
return|;
block|}
name|state
operator|=
name|cond_state
index|[
name|cond_depth
index|]
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|SKIP_TO_ENDIF
operator|||
name|state
operator|==
name|ELSE_ACTIVE
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_WARNING
argument_list|,
literal|"extra elif"
argument_list|)
expr_stmt|;
name|cond_state
index|[
name|cond_depth
index|]
operator|=
name|SKIP_TO_ENDIF
expr_stmt|;
return|return
name|COND_SKIP
return|;
block|}
if|if
condition|(
name|state
operator|!=
name|SEARCH_FOR_ELIF
condition|)
block|{
comment|/* Either just finished the 'true' block, or already SKIP_TO_ELSE */
name|cond_state
index|[
name|cond_depth
index|]
operator|=
name|SKIP_TO_ELSE
expr_stmt|;
return|return
name|COND_SKIP
return|;
block|}
block|}
else|else
block|{
comment|/* Normal .if */
if|if
condition|(
name|cond_depth
operator|+
literal|1
operator|>=
name|max_if_depth
condition|)
block|{
comment|/* 	     * This is rare, but not impossible. 	     * In meta mode, dirdeps.mk (only runs at level 0) 	     * can need more than the default. 	     */
name|max_if_depth
operator|+=
name|MAXIF_BUMP
expr_stmt|;
name|cond_state
operator|=
name|bmake_realloc
argument_list|(
name|cond_state
argument_list|,
name|max_if_depth
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cond_state
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|state
operator|=
name|cond_state
index|[
name|cond_depth
index|]
expr_stmt|;
name|cond_depth
operator|++
expr_stmt|;
if|if
condition|(
name|state
operator|>
name|ELSE_ACTIVE
condition|)
block|{
comment|/* If we aren't parsing the data, treat as always false */
name|cond_state
index|[
name|cond_depth
index|]
operator|=
name|SKIP_TO_ELSE
expr_stmt|;
return|return
name|COND_SKIP
return|;
block|}
block|}
comment|/* And evaluate the conditional expresssion */
if|if
condition|(
name|Cond_EvalExpression
argument_list|(
name|ifp
argument_list|,
name|line
argument_list|,
operator|&
name|value
argument_list|,
literal|1
argument_list|)
operator|==
name|COND_INVALID
condition|)
block|{
comment|/* Syntax error in conditional, error message already output. */
comment|/* Skip everything to matching .endif */
name|cond_state
index|[
name|cond_depth
index|]
operator|=
name|SKIP_TO_ELSE
expr_stmt|;
return|return
name|COND_SKIP
return|;
block|}
if|if
condition|(
operator|!
name|value
condition|)
block|{
name|cond_state
index|[
name|cond_depth
index|]
operator|=
name|SEARCH_FOR_ELIF
expr_stmt|;
return|return
name|COND_SKIP
return|;
block|}
name|cond_state
index|[
name|cond_depth
index|]
operator|=
name|IF_ACTIVE
expr_stmt|;
return|return
name|COND_PARSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*-  *-----------------------------------------------------------------------  * Cond_End --  *	Make sure everything's clean at the end of a makefile.  *  * Results:  *	None.  *  * Side Effects:  *	Parse_Error will be called if open conditionals are around.  *  *-----------------------------------------------------------------------  */
end_comment

begin_function
name|void
name|Cond_restore_depth
parameter_list|(
name|unsigned
name|int
name|saved_depth
parameter_list|)
block|{
name|int
name|open_conds
init|=
name|cond_depth
operator|-
name|cond_min_depth
decl_stmt|;
if|if
condition|(
name|open_conds
operator|!=
literal|0
operator|||
name|saved_depth
operator|>
name|cond_depth
condition|)
block|{
name|Parse_Error
argument_list|(
name|PARSE_FATAL
argument_list|,
literal|"%d open conditional%s"
argument_list|,
name|open_conds
argument_list|,
name|open_conds
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
name|cond_depth
operator|=
name|cond_min_depth
expr_stmt|;
block|}
name|cond_min_depth
operator|=
name|saved_depth
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|int
name|Cond_save_depth
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|depth
init|=
name|cond_min_depth
decl_stmt|;
name|cond_min_depth
operator|=
name|cond_depth
expr_stmt|;
return|return
name|depth
return|;
block|}
end_function

end_unit

