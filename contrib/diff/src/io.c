begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* File I/O for GNU DIFF.     Copyright (C) 1988, 1989, 1992, 1993, 1994, 1995, 1998, 2001, 2002,    2004 Free Software Foundation, Inc.     This file is part of GNU DIFF.     GNU DIFF is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GNU DIFF is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; see the file COPYING.    If not, write to the Free Software Foundation,    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"diff.h"
end_include

begin_include
include|#
directive|include
file|<cmpbuf.h>
end_include

begin_include
include|#
directive|include
file|<file-type.h>
end_include

begin_include
include|#
directive|include
file|<setmode.h>
end_include

begin_include
include|#
directive|include
file|<xalloc.h>
end_include

begin_comment
comment|/* Rotate an unsigned value to the left.  */
end_comment

begin_define
define|#
directive|define
name|ROL
parameter_list|(
name|v
parameter_list|,
name|n
parameter_list|)
value|((v)<< (n) | (v)>> (sizeof (v) * CHAR_BIT - (n)))
end_define

begin_comment
comment|/* Given a hash value and a new character, return a new hash value.  */
end_comment

begin_define
define|#
directive|define
name|HASH
parameter_list|(
name|h
parameter_list|,
name|c
parameter_list|)
value|((c) + ROL (h, 7))
end_define

begin_escape
end_escape

begin_comment
comment|/* The type of a hash value.  */
end_comment

begin_typedef
typedef|typedef
name|size_t
name|hash_value
typedef|;
end_typedef

begin_expr_stmt
name|verify
argument_list|(
name|hash_value_is_unsigned
argument_list|,
operator|!
name|TYPE_SIGNED
argument_list|(
name|hash_value
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Lines are put into equivalence classes of lines that match in lines_differ.    Each equivalence class is represented by one of these structures,    but only while the classes are being computed.    Afterward, each class is represented by a number.  */
end_comment

begin_struct
struct|struct
name|equivclass
block|{
name|lin
name|next
decl_stmt|;
comment|/* Next item in this bucket.  */
name|hash_value
name|hash
decl_stmt|;
comment|/* Hash of lines in this class.  */
name|char
specifier|const
modifier|*
name|line
decl_stmt|;
comment|/* A line that fits this class.  */
name|size_t
name|length
decl_stmt|;
comment|/* That line's length, not counting its newline.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Hash-table: array of buckets, each being a chain of equivalence classes.    buckets[-1] is reserved for incomplete lines.  */
end_comment

begin_decl_stmt
specifier|static
name|lin
modifier|*
name|buckets
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of buckets in the hash table array, not counting buckets[-1].  */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|nbuckets
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array in which the equivalence classes are allocated.    The bucket-chains go through the elements in this array.    The number of an equivalence class is its index in this array.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|equivclass
modifier|*
name|equivs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index of first free element in the array `equivs'.  */
end_comment

begin_decl_stmt
specifier|static
name|lin
name|equivs_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements allocated in the array `equivs'.  */
end_comment

begin_decl_stmt
specifier|static
name|lin
name|equivs_alloc
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Read a block of data into a file buffer, checking for EOF and error.  */
end_comment

begin_function
name|void
name|file_block_read
parameter_list|(
name|struct
name|file_data
modifier|*
name|current
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
if|if
condition|(
name|size
operator|&&
operator|!
name|current
operator|->
name|eof
condition|)
block|{
name|size_t
name|s
init|=
name|block_read
argument_list|(
name|current
operator|->
name|desc
argument_list|,
name|FILE_BUFFER
argument_list|(
name|current
argument_list|)
operator|+
name|current
operator|->
name|buffered
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|SIZE_MAX
condition|)
name|pfatal_with_name
argument_list|(
name|current
operator|->
name|name
argument_list|)
expr_stmt|;
name|current
operator|->
name|buffered
operator|+=
name|s
expr_stmt|;
name|current
operator|->
name|eof
operator|=
name|s
operator|<
name|size
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check for binary files and compare them for exact identity.  */
end_comment

begin_comment
comment|/* Return 1 if BUF contains a non text character.    SIZE is the number of characters in BUF.  */
end_comment

begin_define
define|#
directive|define
name|binary_file_p
parameter_list|(
name|buf
parameter_list|,
name|size
parameter_list|)
value|(memchr (buf, 0, size) != 0)
end_define

begin_comment
comment|/* Get ready to read the current file.    Return nonzero if SKIP_TEST is zero,    and if it appears to be a binary file.  */
end_comment

begin_function
specifier|static
name|bool
name|sip
parameter_list|(
name|struct
name|file_data
modifier|*
name|current
parameter_list|,
name|bool
name|skip_test
parameter_list|)
block|{
comment|/* If we have a nonexistent file at this stage, treat it as empty.  */
if|if
condition|(
name|current
operator|->
name|desc
operator|<
literal|0
condition|)
block|{
comment|/* Leave room for a sentinel.  */
name|current
operator|->
name|bufsize
operator|=
sizeof|sizeof
argument_list|(
name|word
argument_list|)
expr_stmt|;
name|current
operator|->
name|buffer
operator|=
name|xmalloc
argument_list|(
name|current
operator|->
name|bufsize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|current
operator|->
name|bufsize
operator|=
name|buffer_lcm
argument_list|(
sizeof|sizeof
argument_list|(
name|word
argument_list|)
argument_list|,
name|STAT_BLOCKSIZE
argument_list|(
name|current
operator|->
name|stat
argument_list|)
argument_list|,
name|PTRDIFF_MAX
operator|-
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|word
argument_list|)
argument_list|)
expr_stmt|;
name|current
operator|->
name|buffer
operator|=
name|xmalloc
argument_list|(
name|current
operator|->
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|skip_test
condition|)
block|{
comment|/* Check first part of file to see if it's a binary file.  */
name|bool
name|was_binary
init|=
name|set_binary_mode
argument_list|(
name|current
operator|->
name|desc
argument_list|,
name|true
argument_list|)
decl_stmt|;
name|off_t
name|buffered
decl_stmt|;
name|file_block_read
argument_list|(
name|current
argument_list|,
name|current
operator|->
name|bufsize
argument_list|)
expr_stmt|;
name|buffered
operator|=
name|current
operator|->
name|buffered
expr_stmt|;
if|if
condition|(
operator|!
name|was_binary
condition|)
block|{
comment|/* Revert to text mode and seek back to the beginning to 		 reread the file.  Use relative seek, since file 		 descriptors like stdin might not start at offset 		 zero.  */
if|if
condition|(
name|lseek
argument_list|(
name|current
operator|->
name|desc
argument_list|,
operator|-
name|buffered
argument_list|,
name|SEEK_CUR
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|pfatal_with_name
argument_list|(
name|current
operator|->
name|name
argument_list|)
expr_stmt|;
name|set_binary_mode
argument_list|(
name|current
operator|->
name|desc
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|current
operator|->
name|buffered
operator|=
literal|0
expr_stmt|;
name|current
operator|->
name|eof
operator|=
name|false
expr_stmt|;
block|}
return|return
name|binary_file_p
argument_list|(
name|current
operator|->
name|buffer
argument_list|,
name|buffered
argument_list|)
return|;
block|}
block|}
name|current
operator|->
name|buffered
operator|=
literal|0
expr_stmt|;
name|current
operator|->
name|eof
operator|=
name|false
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Slurp the rest of the current file completely into memory.  */
end_comment

begin_function
specifier|static
name|void
name|slurp
parameter_list|(
name|struct
name|file_data
modifier|*
name|current
parameter_list|)
block|{
name|size_t
name|cc
decl_stmt|;
if|if
condition|(
name|current
operator|->
name|desc
operator|<
literal|0
condition|)
block|{
comment|/* The file is nonexistent.  */
return|return;
block|}
if|if
condition|(
name|S_ISREG
argument_list|(
name|current
operator|->
name|stat
operator|.
name|st_mode
argument_list|)
condition|)
block|{
comment|/* It's a regular file; slurp in the rest all at once.  */
comment|/* Get the size out of the stat block. 	 Allocate just enough room for appended newline plus word sentinel, 	 plus word-alignment since we want the buffer word-aligned.  */
name|size_t
name|file_size
init|=
name|current
operator|->
name|stat
operator|.
name|st_size
decl_stmt|;
name|cc
operator|=
name|file_size
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|word
argument_list|)
operator|-
name|file_size
operator|%
sizeof|sizeof
argument_list|(
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_size
operator|!=
name|current
operator|->
name|stat
operator|.
name|st_size
operator|||
name|cc
operator|<
name|file_size
operator|||
name|PTRDIFF_MAX
operator|<=
name|cc
condition|)
name|xalloc_die
argument_list|()
expr_stmt|;
if|if
condition|(
name|current
operator|->
name|bufsize
operator|<
name|cc
condition|)
block|{
name|current
operator|->
name|bufsize
operator|=
name|cc
expr_stmt|;
name|current
operator|->
name|buffer
operator|=
name|xrealloc
argument_list|(
name|current
operator|->
name|buffer
argument_list|,
name|cc
argument_list|)
expr_stmt|;
block|}
comment|/* Try to read at least 1 more byte than the size indicates, to 	 detect whether the file is growing.  This is a nicety for 	 users who run 'diff' on files while they are changing.  */
if|if
condition|(
name|current
operator|->
name|buffered
operator|<=
name|file_size
condition|)
block|{
name|file_block_read
argument_list|(
name|current
argument_list|,
name|file_size
operator|+
literal|1
operator|-
name|current
operator|->
name|buffered
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|->
name|buffered
operator|<=
name|file_size
condition|)
return|return;
block|}
block|}
comment|/* It's not a regular file, or it's a growing regular file; read it,      growing the buffer as needed.  */
name|file_block_read
argument_list|(
name|current
argument_list|,
name|current
operator|->
name|bufsize
operator|-
name|current
operator|->
name|buffered
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|->
name|buffered
condition|)
block|{
while|while
condition|(
name|current
operator|->
name|buffered
operator|==
name|current
operator|->
name|bufsize
condition|)
block|{
if|if
condition|(
name|PTRDIFF_MAX
operator|/
literal|2
operator|-
sizeof|sizeof
argument_list|(
name|word
argument_list|)
operator|<
name|current
operator|->
name|bufsize
condition|)
name|xalloc_die
argument_list|()
expr_stmt|;
name|current
operator|->
name|bufsize
operator|*=
literal|2
expr_stmt|;
name|current
operator|->
name|buffer
operator|=
name|xrealloc
argument_list|(
name|current
operator|->
name|buffer
argument_list|,
name|current
operator|->
name|bufsize
argument_list|)
expr_stmt|;
name|file_block_read
argument_list|(
name|current
argument_list|,
name|current
operator|->
name|bufsize
operator|-
name|current
operator|->
name|buffered
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate just enough room for appended newline plus word 	 sentinel, plus word-alignment.  */
name|cc
operator|=
name|current
operator|->
name|buffered
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|word
argument_list|)
expr_stmt|;
name|current
operator|->
name|bufsize
operator|=
name|cc
operator|-
name|cc
operator|%
sizeof|sizeof
argument_list|(
name|word
argument_list|)
expr_stmt|;
name|current
operator|->
name|buffer
operator|=
name|xrealloc
argument_list|(
name|current
operator|->
name|buffer
argument_list|,
name|current
operator|->
name|bufsize
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Split the file into lines, simultaneously computing the equivalence    class for each line.  */
end_comment

begin_function
specifier|static
name|void
name|find_and_hash_each_line
parameter_list|(
name|struct
name|file_data
modifier|*
name|current
parameter_list|)
block|{
name|hash_value
name|h
decl_stmt|;
name|char
specifier|const
modifier|*
name|p
init|=
name|current
operator|->
name|prefix_end
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
name|lin
name|i
decl_stmt|,
modifier|*
name|bucket
decl_stmt|;
name|size_t
name|length
decl_stmt|;
comment|/* Cache often-used quantities in local variables to help the compiler.  */
name|char
specifier|const
modifier|*
modifier|*
name|linbuf
init|=
name|current
operator|->
name|linbuf
decl_stmt|;
name|lin
name|alloc_lines
init|=
name|current
operator|->
name|alloc_lines
decl_stmt|;
name|lin
name|line
init|=
literal|0
decl_stmt|;
name|lin
name|linbuf_base
init|=
name|current
operator|->
name|linbuf_base
decl_stmt|;
name|lin
modifier|*
name|cureqs
init|=
name|xmalloc
argument_list|(
name|alloc_lines
operator|*
sizeof|sizeof
expr|*
name|cureqs
argument_list|)
decl_stmt|;
name|struct
name|equivclass
modifier|*
name|eqs
init|=
name|equivs
decl_stmt|;
name|lin
name|eqs_index
init|=
name|equivs_index
decl_stmt|;
name|lin
name|eqs_alloc
init|=
name|equivs_alloc
decl_stmt|;
name|char
specifier|const
modifier|*
name|suffix_begin
init|=
name|current
operator|->
name|suffix_begin
decl_stmt|;
name|char
specifier|const
modifier|*
name|bufend
init|=
name|FILE_BUFFER
argument_list|(
name|current
argument_list|)
operator|+
name|current
operator|->
name|buffered
decl_stmt|;
name|bool
name|diff_length_compare_anyway
init|=
name|ignore_white_space
operator|!=
name|IGNORE_NO_WHITE_SPACE
decl_stmt|;
name|bool
name|same_length_diff_contents_compare_anyway
init|=
name|diff_length_compare_anyway
operator||
name|ignore_case
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|suffix_begin
condition|)
block|{
name|char
specifier|const
modifier|*
name|ip
init|=
name|p
decl_stmt|;
name|h
operator|=
literal|0
expr_stmt|;
comment|/* Hash this line until we find a newline.  */
if|if
condition|(
name|ignore_case
condition|)
switch|switch
condition|(
name|ignore_white_space
condition|)
block|{
case|case
name|IGNORE_ALL_SPACE
case|:
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\n'
condition|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
name|h
operator|=
name|HASH
argument_list|(
name|h
argument_list|,
name|tolower
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IGNORE_SPACE_CHANGE
case|:
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
do|do
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|==
literal|'\n'
condition|)
goto|goto
name|hashing_done
goto|;
do|while
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
do|;
name|h
operator|=
name|HASH
argument_list|(
name|h
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
comment|/* C is now the first non-space.  */
name|h
operator|=
name|HASH
argument_list|(
name|h
argument_list|,
name|tolower
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IGNORE_TAB_EXPANSION
case|:
block|{
name|size_t
name|column
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\n'
condition|)
block|{
name|size_t
name|repetitions
init|=
literal|1
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\b'
case|:
name|column
operator|-=
literal|0
operator|<
name|column
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|c
operator|=
literal|' '
expr_stmt|;
name|repetitions
operator|=
name|tabsize
operator|-
name|column
operator|%
name|tabsize
expr_stmt|;
name|column
operator|=
operator|(
name|column
operator|+
name|repetitions
operator|<
name|column
condition|?
literal|0
else|:
name|column
operator|+
name|repetitions
operator|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|column
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|c
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|column
operator|++
expr_stmt|;
break|break;
block|}
do|do
name|h
operator|=
name|HASH
argument_list|(
name|h
argument_list|,
name|c
argument_list|)
expr_stmt|;
do|while
condition|(
operator|--
name|repetitions
operator|!=
literal|0
condition|)
do|;
block|}
block|}
break|break;
default|default:
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\n'
condition|)
name|h
operator|=
name|HASH
argument_list|(
name|h
argument_list|,
name|tolower
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
switch|switch
condition|(
name|ignore_white_space
condition|)
block|{
case|case
name|IGNORE_ALL_SPACE
case|:
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\n'
condition|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
name|h
operator|=
name|HASH
argument_list|(
name|h
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
name|IGNORE_SPACE_CHANGE
case|:
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
do|do
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|==
literal|'\n'
condition|)
goto|goto
name|hashing_done
goto|;
do|while
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
do|;
name|h
operator|=
name|HASH
argument_list|(
name|h
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
comment|/* C is now the first non-space.  */
name|h
operator|=
name|HASH
argument_list|(
name|h
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IGNORE_TAB_EXPANSION
case|:
block|{
name|size_t
name|column
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\n'
condition|)
block|{
name|size_t
name|repetitions
init|=
literal|1
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\b'
case|:
name|column
operator|-=
literal|0
operator|<
name|column
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|c
operator|=
literal|' '
expr_stmt|;
name|repetitions
operator|=
name|tabsize
operator|-
name|column
operator|%
name|tabsize
expr_stmt|;
name|column
operator|=
operator|(
name|column
operator|+
name|repetitions
operator|<
name|column
condition|?
literal|0
else|:
name|column
operator|+
name|repetitions
operator|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|column
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|column
operator|++
expr_stmt|;
break|break;
block|}
do|do
name|h
operator|=
name|HASH
argument_list|(
name|h
argument_list|,
name|c
argument_list|)
expr_stmt|;
do|while
condition|(
operator|--
name|repetitions
operator|!=
literal|0
condition|)
do|;
block|}
block|}
break|break;
default|default:
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\n'
condition|)
name|h
operator|=
name|HASH
argument_list|(
name|h
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
name|hashing_done
label|:
empty_stmt|;
name|bucket
operator|=
operator|&
name|buckets
index|[
name|h
operator|%
name|nbuckets
index|]
expr_stmt|;
name|length
operator|=
name|p
operator|-
name|ip
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|bufend
operator|&&
name|current
operator|->
name|missing_newline
operator|&&
name|ROBUST_OUTPUT_STYLE
argument_list|(
name|output_style
argument_list|)
condition|)
block|{
comment|/* This line is incomplete.  If this is significant, 	     put the line into buckets[-1].  */
if|if
condition|(
name|ignore_white_space
operator|<
name|IGNORE_SPACE_CHANGE
condition|)
name|bucket
operator|=
operator|&
name|buckets
index|[
operator|-
literal|1
index|]
expr_stmt|;
comment|/* Omit the inserted newline when computing linbuf later.  */
name|p
operator|--
expr_stmt|;
name|bufend
operator|=
name|suffix_begin
operator|=
name|p
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
operator|*
name|bucket
init|;
condition|;
name|i
operator|=
name|eqs
index|[
name|i
index|]
operator|.
name|next
control|)
if|if
condition|(
operator|!
name|i
condition|)
block|{
comment|/* Create a new equivalence class in this bucket.  */
name|i
operator|=
name|eqs_index
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|eqs_alloc
condition|)
block|{
if|if
condition|(
name|PTRDIFF_MAX
operator|/
operator|(
literal|2
operator|*
sizeof|sizeof
expr|*
name|eqs
operator|)
operator|<=
name|eqs_alloc
condition|)
name|xalloc_die
argument_list|()
expr_stmt|;
name|eqs_alloc
operator|*=
literal|2
expr_stmt|;
name|eqs
operator|=
name|xrealloc
argument_list|(
name|eqs
argument_list|,
name|eqs_alloc
operator|*
sizeof|sizeof
expr|*
name|eqs
argument_list|)
expr_stmt|;
block|}
name|eqs
index|[
name|i
index|]
operator|.
name|next
operator|=
operator|*
name|bucket
expr_stmt|;
name|eqs
index|[
name|i
index|]
operator|.
name|hash
operator|=
name|h
expr_stmt|;
name|eqs
index|[
name|i
index|]
operator|.
name|line
operator|=
name|ip
expr_stmt|;
name|eqs
index|[
name|i
index|]
operator|.
name|length
operator|=
name|length
expr_stmt|;
operator|*
name|bucket
operator|=
name|i
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|eqs
index|[
name|i
index|]
operator|.
name|hash
operator|==
name|h
condition|)
block|{
name|char
specifier|const
modifier|*
name|eqline
init|=
name|eqs
index|[
name|i
index|]
operator|.
name|line
decl_stmt|;
comment|/* Reuse existing class if lines_differ reports the lines                equal.  */
if|if
condition|(
name|eqs
index|[
name|i
index|]
operator|.
name|length
operator|==
name|length
condition|)
block|{
comment|/* Reuse existing equivalence class if the lines are identical. 		   This detects the common case of exact identity 		   faster than lines_differ would.  */
if|if
condition|(
name|memcmp
argument_list|(
name|eqline
argument_list|,
name|ip
argument_list|,
name|length
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|same_length_diff_contents_compare_anyway
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
name|diff_length_compare_anyway
condition|)
continue|continue;
if|if
condition|(
operator|!
name|lines_differ
argument_list|(
name|eqline
argument_list|,
name|ip
argument_list|)
condition|)
break|break;
block|}
comment|/* Maybe increase the size of the line table.  */
if|if
condition|(
name|line
operator|==
name|alloc_lines
condition|)
block|{
comment|/* Double (alloc_lines - linbuf_base) by adding to alloc_lines.  */
if|if
condition|(
name|PTRDIFF_MAX
operator|/
literal|3
operator|<=
name|alloc_lines
operator|||
name|PTRDIFF_MAX
operator|/
sizeof|sizeof
expr|*
name|cureqs
operator|<=
literal|2
operator|*
name|alloc_lines
operator|-
name|linbuf_base
operator|||
name|PTRDIFF_MAX
operator|/
sizeof|sizeof
expr|*
name|linbuf
operator|<=
name|alloc_lines
operator|-
name|linbuf_base
condition|)
name|xalloc_die
argument_list|()
expr_stmt|;
name|alloc_lines
operator|=
literal|2
operator|*
name|alloc_lines
operator|-
name|linbuf_base
expr_stmt|;
name|cureqs
operator|=
name|xrealloc
argument_list|(
name|cureqs
argument_list|,
name|alloc_lines
operator|*
sizeof|sizeof
expr|*
name|cureqs
argument_list|)
expr_stmt|;
name|linbuf
operator|+=
name|linbuf_base
expr_stmt|;
name|linbuf
operator|=
name|xrealloc
argument_list|(
name|linbuf
argument_list|,
operator|(
name|alloc_lines
operator|-
name|linbuf_base
operator|)
operator|*
sizeof|sizeof
expr|*
name|linbuf
argument_list|)
expr_stmt|;
name|linbuf
operator|-=
name|linbuf_base
expr_stmt|;
block|}
name|linbuf
index|[
name|line
index|]
operator|=
name|ip
expr_stmt|;
name|cureqs
index|[
name|line
index|]
operator|=
name|i
expr_stmt|;
operator|++
name|line
expr_stmt|;
block|}
name|current
operator|->
name|buffered_lines
operator|=
name|line
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
comment|/* Record the line start for lines in the suffix that we care about. 	 Record one more line start than lines, 	 so that we can compute the length of any buffered line.  */
if|if
condition|(
name|line
operator|==
name|alloc_lines
condition|)
block|{
comment|/* Double (alloc_lines - linbuf_base) by adding to alloc_lines.  */
if|if
condition|(
name|PTRDIFF_MAX
operator|/
literal|3
operator|<=
name|alloc_lines
operator|||
name|PTRDIFF_MAX
operator|/
sizeof|sizeof
expr|*
name|cureqs
operator|<=
literal|2
operator|*
name|alloc_lines
operator|-
name|linbuf_base
operator|||
name|PTRDIFF_MAX
operator|/
sizeof|sizeof
expr|*
name|linbuf
operator|<=
name|alloc_lines
operator|-
name|linbuf_base
condition|)
name|xalloc_die
argument_list|()
expr_stmt|;
name|alloc_lines
operator|=
literal|2
operator|*
name|alloc_lines
operator|-
name|linbuf_base
expr_stmt|;
name|linbuf
operator|+=
name|linbuf_base
expr_stmt|;
name|linbuf
operator|=
name|xrealloc
argument_list|(
name|linbuf
argument_list|,
operator|(
name|alloc_lines
operator|-
name|linbuf_base
operator|)
operator|*
sizeof|sizeof
expr|*
name|linbuf
argument_list|)
expr_stmt|;
name|linbuf
operator|-=
name|linbuf_base
expr_stmt|;
block|}
name|linbuf
index|[
name|line
index|]
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|bufend
condition|)
break|break;
if|if
condition|(
name|context
operator|<=
name|i
operator|&&
name|no_diff_means_no_output
condition|)
break|break;
name|line
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'\n'
condition|)
continue|continue;
block|}
comment|/* Done with cache in local variables.  */
name|current
operator|->
name|linbuf
operator|=
name|linbuf
expr_stmt|;
name|current
operator|->
name|valid_lines
operator|=
name|line
expr_stmt|;
name|current
operator|->
name|alloc_lines
operator|=
name|alloc_lines
expr_stmt|;
name|current
operator|->
name|equivs
operator|=
name|cureqs
expr_stmt|;
name|equivs
operator|=
name|eqs
expr_stmt|;
name|equivs_alloc
operator|=
name|eqs_alloc
expr_stmt|;
name|equivs_index
operator|=
name|eqs_index
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Prepare the text.  Make sure the text end is initialized.    Make sure text ends in a newline,    but remember that we had to add one.    Strip trailing CRs, if that was requested.  */
end_comment

begin_function
specifier|static
name|void
name|prepare_text
parameter_list|(
name|struct
name|file_data
modifier|*
name|current
parameter_list|)
block|{
name|size_t
name|buffered
init|=
name|current
operator|->
name|buffered
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|FILE_BUFFER
argument_list|(
name|current
argument_list|)
decl_stmt|;
name|char
modifier|*
name|dst
decl_stmt|;
if|if
condition|(
name|buffered
operator|==
literal|0
operator|||
name|p
index|[
name|buffered
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|current
operator|->
name|missing_newline
operator|=
name|false
expr_stmt|;
else|else
block|{
name|p
index|[
name|buffered
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|current
operator|->
name|missing_newline
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|p
condition|)
return|return;
comment|/* Don't use uninitialized storage when planting or using sentinels.  */
name|memset
argument_list|(
name|p
operator|+
name|buffered
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|word
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strip_trailing_cr
operator|&&
operator|(
name|dst
operator|=
name|memchr
argument_list|(
name|p
argument_list|,
literal|'\r'
argument_list|,
name|buffered
argument_list|)
operator|)
condition|)
block|{
name|char
specifier|const
modifier|*
name|src
init|=
name|dst
decl_stmt|;
name|char
specifier|const
modifier|*
name|srclim
init|=
name|p
operator|+
name|buffered
decl_stmt|;
do|do
name|dst
operator|+=
operator|!
operator|(
operator|(
operator|*
name|dst
operator|=
operator|*
name|src
operator|++
operator|)
operator|==
literal|'\r'
operator|&&
operator|*
name|src
operator|==
literal|'\n'
operator|)
expr_stmt|;
do|while
condition|(
name|src
operator|<
name|srclim
condition|)
do|;
name|buffered
operator|-=
name|src
operator|-
name|dst
expr_stmt|;
block|}
name|current
operator|->
name|buffered
operator|=
name|buffered
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We have found N lines in a buffer of size S; guess the    proportionate number of lines that will be found in a buffer of    size T.  However, do not guess a number of lines so large that the    resulting line table might cause overflow in size calculations.  */
end_comment

begin_function
specifier|static
name|lin
name|guess_lines
parameter_list|(
name|lin
name|n
parameter_list|,
name|size_t
name|s
parameter_list|,
name|size_t
name|t
parameter_list|)
block|{
name|size_t
name|guessed_bytes_per_line
init|=
name|n
operator|<
literal|10
condition|?
literal|32
else|:
name|s
operator|/
operator|(
name|n
operator|-
literal|1
operator|)
decl_stmt|;
name|lin
name|guessed_lines
init|=
name|MAX
argument_list|(
literal|1
argument_list|,
name|t
operator|/
name|guessed_bytes_per_line
argument_list|)
decl_stmt|;
return|return
name|MIN
argument_list|(
name|guessed_lines
argument_list|,
name|PTRDIFF_MAX
operator|/
operator|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|+
literal|1
operator|)
operator|-
literal|5
argument_list|)
operator|+
literal|5
return|;
block|}
end_function

begin_comment
comment|/* Given a vector of two file_data objects, find the identical    prefixes and suffixes of each object.  */
end_comment

begin_function
specifier|static
name|void
name|find_identical_ends
parameter_list|(
name|struct
name|file_data
name|filevec
index|[]
parameter_list|)
block|{
name|word
modifier|*
name|w0
decl_stmt|,
modifier|*
name|w1
decl_stmt|;
name|char
modifier|*
name|p0
decl_stmt|,
modifier|*
name|p1
decl_stmt|,
modifier|*
name|buffer0
decl_stmt|,
modifier|*
name|buffer1
decl_stmt|;
name|char
specifier|const
modifier|*
name|end0
decl_stmt|,
modifier|*
name|beg0
decl_stmt|;
name|char
specifier|const
modifier|*
modifier|*
name|linbuf0
decl_stmt|,
modifier|*
modifier|*
name|linbuf1
decl_stmt|;
name|lin
name|i
decl_stmt|,
name|lines
decl_stmt|;
name|size_t
name|n0
decl_stmt|,
name|n1
decl_stmt|;
name|lin
name|alloc_lines0
decl_stmt|,
name|alloc_lines1
decl_stmt|;
name|lin
name|buffered_prefix
decl_stmt|,
name|prefix_count
decl_stmt|,
name|prefix_mask
decl_stmt|;
name|lin
name|middle_guess
decl_stmt|,
name|suffix_guess
decl_stmt|;
name|slurp
argument_list|(
operator|&
name|filevec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|prepare_text
argument_list|(
operator|&
name|filevec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|filevec
index|[
literal|0
index|]
operator|.
name|desc
operator|!=
name|filevec
index|[
literal|1
index|]
operator|.
name|desc
condition|)
block|{
name|slurp
argument_list|(
operator|&
name|filevec
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|prepare_text
argument_list|(
operator|&
name|filevec
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|filevec
index|[
literal|1
index|]
operator|.
name|buffer
operator|=
name|filevec
index|[
literal|0
index|]
operator|.
name|buffer
expr_stmt|;
name|filevec
index|[
literal|1
index|]
operator|.
name|bufsize
operator|=
name|filevec
index|[
literal|0
index|]
operator|.
name|bufsize
expr_stmt|;
name|filevec
index|[
literal|1
index|]
operator|.
name|buffered
operator|=
name|filevec
index|[
literal|0
index|]
operator|.
name|buffered
expr_stmt|;
name|filevec
index|[
literal|1
index|]
operator|.
name|missing_newline
operator|=
name|filevec
index|[
literal|0
index|]
operator|.
name|missing_newline
expr_stmt|;
block|}
comment|/* Find identical prefix.  */
name|w0
operator|=
name|filevec
index|[
literal|0
index|]
operator|.
name|buffer
expr_stmt|;
name|w1
operator|=
name|filevec
index|[
literal|1
index|]
operator|.
name|buffer
expr_stmt|;
name|p0
operator|=
name|buffer0
operator|=
operator|(
name|char
operator|*
operator|)
name|w0
expr_stmt|;
name|p1
operator|=
name|buffer1
operator|=
operator|(
name|char
operator|*
operator|)
name|w1
expr_stmt|;
name|n0
operator|=
name|filevec
index|[
literal|0
index|]
operator|.
name|buffered
expr_stmt|;
name|n1
operator|=
name|filevec
index|[
literal|1
index|]
operator|.
name|buffered
expr_stmt|;
if|if
condition|(
name|p0
operator|==
name|p1
condition|)
comment|/* The buffers are the same; sentinels won't work.  */
name|p0
operator|=
name|p1
operator|+=
name|n1
expr_stmt|;
else|else
block|{
comment|/* Insert end sentinels, in this case characters that are guaranteed 	 to make the equality test false, and thus terminate the loop.  */
if|if
condition|(
name|n0
operator|<
name|n1
condition|)
name|p0
index|[
name|n0
index|]
operator|=
operator|~
name|p1
index|[
name|n0
index|]
expr_stmt|;
else|else
name|p1
index|[
name|n1
index|]
operator|=
operator|~
name|p0
index|[
name|n1
index|]
expr_stmt|;
comment|/* Loop until first mismatch, or to the sentinel characters.  */
comment|/* Compare a word at a time for speed.  */
while|while
condition|(
operator|*
name|w0
operator|==
operator|*
name|w1
condition|)
name|w0
operator|++
operator|,
name|w1
operator|++
expr_stmt|;
comment|/* Do the last few bytes of comparison a byte at a time.  */
name|p0
operator|=
operator|(
name|char
operator|*
operator|)
name|w0
expr_stmt|;
name|p1
operator|=
operator|(
name|char
operator|*
operator|)
name|w1
expr_stmt|;
while|while
condition|(
operator|*
name|p0
operator|==
operator|*
name|p1
condition|)
name|p0
operator|++
operator|,
name|p1
operator|++
expr_stmt|;
comment|/* Don't mistakenly count missing newline as part of prefix.  */
if|if
condition|(
name|ROBUST_OUTPUT_STYLE
argument_list|(
name|output_style
argument_list|)
operator|&&
operator|(
operator|(
name|buffer0
operator|+
name|n0
operator|-
name|filevec
index|[
literal|0
index|]
operator|.
name|missing_newline
operator|<
name|p0
operator|)
operator|!=
operator|(
name|buffer1
operator|+
name|n1
operator|-
name|filevec
index|[
literal|1
index|]
operator|.
name|missing_newline
operator|<
name|p1
operator|)
operator|)
condition|)
name|p0
operator|--
operator|,
name|p1
operator|--
expr_stmt|;
block|}
comment|/* Now P0 and P1 point at the first nonmatching characters.  */
comment|/* Skip back to last line-beginning in the prefix,      and then discard up to HORIZON_LINES lines from the prefix.  */
name|i
operator|=
name|horizon_lines
expr_stmt|;
while|while
condition|(
name|p0
operator|!=
name|buffer0
operator|&&
operator|(
name|p0
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
operator|||
name|i
operator|--
operator|)
condition|)
name|p0
operator|--
operator|,
name|p1
operator|--
expr_stmt|;
comment|/* Record the prefix.  */
name|filevec
index|[
literal|0
index|]
operator|.
name|prefix_end
operator|=
name|p0
expr_stmt|;
name|filevec
index|[
literal|1
index|]
operator|.
name|prefix_end
operator|=
name|p1
expr_stmt|;
comment|/* Find identical suffix.  */
comment|/* P0 and P1 point beyond the last chars not yet compared.  */
name|p0
operator|=
name|buffer0
operator|+
name|n0
expr_stmt|;
name|p1
operator|=
name|buffer1
operator|+
name|n1
expr_stmt|;
if|if
condition|(
operator|!
name|ROBUST_OUTPUT_STYLE
argument_list|(
name|output_style
argument_list|)
operator|||
name|filevec
index|[
literal|0
index|]
operator|.
name|missing_newline
operator|==
name|filevec
index|[
literal|1
index|]
operator|.
name|missing_newline
condition|)
block|{
name|end0
operator|=
name|p0
expr_stmt|;
comment|/* Addr of last char in file 0.  */
comment|/* Get value of P0 at which we should stop scanning backward: 	 this is when either P0 or P1 points just past the last char 	 of the identical prefix.  */
name|beg0
operator|=
name|filevec
index|[
literal|0
index|]
operator|.
name|prefix_end
operator|+
operator|(
name|n0
operator|<
name|n1
condition|?
literal|0
else|:
name|n0
operator|-
name|n1
operator|)
expr_stmt|;
comment|/* Scan back until chars don't match or we reach that point.  */
for|for
control|(
init|;
name|p0
operator|!=
name|beg0
condition|;
name|p0
operator|--
operator|,
name|p1
operator|--
control|)
if|if
condition|(
operator|*
name|p0
operator|!=
operator|*
name|p1
condition|)
block|{
comment|/* Point at the first char of the matching suffix.  */
name|beg0
operator|=
name|p0
expr_stmt|;
break|break;
block|}
comment|/* Are we at a line-beginning in both files?  If not, add the rest of 	 this line to the main body.  Discard up to HORIZON_LINES lines from 	 the identical suffix.  Also, discard one extra line, 	 because shift_boundaries may need it.  */
name|i
operator|=
name|horizon_lines
operator|+
operator|!
operator|(
operator|(
name|buffer0
operator|==
name|p0
operator|||
name|p0
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
operator|&&
operator|(
name|buffer1
operator|==
name|p1
operator|||
name|p1
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
operator|)
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|&&
name|p0
operator|!=
name|end0
condition|)
while|while
condition|(
operator|*
name|p0
operator|++
operator|!=
literal|'\n'
condition|)
continue|continue;
name|p1
operator|+=
name|p0
operator|-
name|beg0
expr_stmt|;
block|}
comment|/* Record the suffix.  */
name|filevec
index|[
literal|0
index|]
operator|.
name|suffix_begin
operator|=
name|p0
expr_stmt|;
name|filevec
index|[
literal|1
index|]
operator|.
name|suffix_begin
operator|=
name|p1
expr_stmt|;
comment|/* Calculate number of lines of prefix to save.       prefix_count == 0 means save the whole prefix;      we need this for options like -D that output the whole file,      or for enormous contexts (to avoid worrying about arithmetic overflow).      We also need it for options like -F that output some preceding line;      at least we will need to find the last few lines,      but since we don't know how many, it's easiest to find them all.       Otherwise, prefix_count != 0.  Save just prefix_count lines at start      of the line buffer; they'll be moved to the proper location later.      Handle 1 more line than the context says (because we count 1 too many),      rounded up to the next power of 2 to speed index computation.  */
if|if
condition|(
name|no_diff_means_no_output
operator|&&
operator|!
name|function_regexp
operator|.
name|fastmap
operator|&&
name|context
operator|<
name|LIN_MAX
operator|/
literal|4
operator|&&
name|context
operator|<
name|n0
condition|)
block|{
name|middle_guess
operator|=
name|guess_lines
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|p0
operator|-
name|filevec
index|[
literal|0
index|]
operator|.
name|prefix_end
argument_list|)
expr_stmt|;
name|suffix_guess
operator|=
name|guess_lines
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|buffer0
operator|+
name|n0
operator|-
name|p0
argument_list|)
expr_stmt|;
for|for
control|(
name|prefix_count
operator|=
literal|1
init|;
name|prefix_count
operator|<=
name|context
condition|;
name|prefix_count
operator|*=
literal|2
control|)
continue|continue;
name|alloc_lines0
operator|=
operator|(
name|prefix_count
operator|+
name|middle_guess
operator|+
name|MIN
argument_list|(
name|context
argument_list|,
name|suffix_guess
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|prefix_count
operator|=
literal|0
expr_stmt|;
name|alloc_lines0
operator|=
name|guess_lines
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|n0
argument_list|)
expr_stmt|;
block|}
name|prefix_mask
operator|=
name|prefix_count
operator|-
literal|1
expr_stmt|;
name|lines
operator|=
literal|0
expr_stmt|;
name|linbuf0
operator|=
name|xmalloc
argument_list|(
name|alloc_lines0
operator|*
sizeof|sizeof
expr|*
name|linbuf0
argument_list|)
expr_stmt|;
name|p0
operator|=
name|buffer0
expr_stmt|;
comment|/* If the prefix is needed, find the prefix lines.  */
if|if
condition|(
operator|!
operator|(
name|no_diff_means_no_output
operator|&&
name|filevec
index|[
literal|0
index|]
operator|.
name|prefix_end
operator|==
name|p0
operator|&&
name|filevec
index|[
literal|1
index|]
operator|.
name|prefix_end
operator|==
name|p1
operator|)
condition|)
block|{
name|end0
operator|=
name|filevec
index|[
literal|0
index|]
operator|.
name|prefix_end
expr_stmt|;
while|while
condition|(
name|p0
operator|!=
name|end0
condition|)
block|{
name|lin
name|l
init|=
name|lines
operator|++
operator|&
name|prefix_mask
decl_stmt|;
if|if
condition|(
name|l
operator|==
name|alloc_lines0
condition|)
block|{
if|if
condition|(
name|PTRDIFF_MAX
operator|/
operator|(
literal|2
operator|*
sizeof|sizeof
expr|*
name|linbuf0
operator|)
operator|<=
name|alloc_lines0
condition|)
name|xalloc_die
argument_list|()
expr_stmt|;
name|alloc_lines0
operator|*=
literal|2
expr_stmt|;
name|linbuf0
operator|=
name|xrealloc
argument_list|(
name|linbuf0
argument_list|,
name|alloc_lines0
operator|*
sizeof|sizeof
expr|*
name|linbuf0
argument_list|)
expr_stmt|;
block|}
name|linbuf0
index|[
name|l
index|]
operator|=
name|p0
expr_stmt|;
while|while
condition|(
operator|*
name|p0
operator|++
operator|!=
literal|'\n'
condition|)
continue|continue;
block|}
block|}
name|buffered_prefix
operator|=
name|prefix_count
operator|&&
name|context
operator|<
name|lines
condition|?
name|context
else|:
name|lines
expr_stmt|;
comment|/* Allocate line buffer 1.  */
name|middle_guess
operator|=
name|guess_lines
argument_list|(
name|lines
argument_list|,
name|p0
operator|-
name|buffer0
argument_list|,
name|p1
operator|-
name|filevec
index|[
literal|1
index|]
operator|.
name|prefix_end
argument_list|)
expr_stmt|;
name|suffix_guess
operator|=
name|guess_lines
argument_list|(
name|lines
argument_list|,
name|p0
operator|-
name|buffer0
argument_list|,
name|buffer1
operator|+
name|n1
operator|-
name|p1
argument_list|)
expr_stmt|;
name|alloc_lines1
operator|=
name|buffered_prefix
operator|+
name|middle_guess
operator|+
name|MIN
argument_list|(
name|context
argument_list|,
name|suffix_guess
argument_list|)
expr_stmt|;
if|if
condition|(
name|alloc_lines1
operator|<
name|buffered_prefix
operator|||
name|PTRDIFF_MAX
operator|/
sizeof|sizeof
expr|*
name|linbuf1
operator|<=
name|alloc_lines1
condition|)
name|xalloc_die
argument_list|()
expr_stmt|;
name|linbuf1
operator|=
name|xmalloc
argument_list|(
name|alloc_lines1
operator|*
sizeof|sizeof
expr|*
name|linbuf1
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffered_prefix
operator|!=
name|lines
condition|)
block|{
comment|/* Rotate prefix lines to proper location.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|buffered_prefix
condition|;
name|i
operator|++
control|)
name|linbuf1
index|[
name|i
index|]
operator|=
name|linbuf0
index|[
operator|(
name|lines
operator|-
name|context
operator|+
name|i
operator|)
operator|&
name|prefix_mask
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|buffered_prefix
condition|;
name|i
operator|++
control|)
name|linbuf0
index|[
name|i
index|]
operator|=
name|linbuf1
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* Initialize line buffer 1 from line buffer 0.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|buffered_prefix
condition|;
name|i
operator|++
control|)
name|linbuf1
index|[
name|i
index|]
operator|=
name|linbuf0
index|[
name|i
index|]
operator|-
name|buffer0
operator|+
name|buffer1
expr_stmt|;
comment|/* Record the line buffer, adjusted so that      linbuf[0] points at the first differing line.  */
name|filevec
index|[
literal|0
index|]
operator|.
name|linbuf
operator|=
name|linbuf0
operator|+
name|buffered_prefix
expr_stmt|;
name|filevec
index|[
literal|1
index|]
operator|.
name|linbuf
operator|=
name|linbuf1
operator|+
name|buffered_prefix
expr_stmt|;
name|filevec
index|[
literal|0
index|]
operator|.
name|linbuf_base
operator|=
name|filevec
index|[
literal|1
index|]
operator|.
name|linbuf_base
operator|=
operator|-
name|buffered_prefix
expr_stmt|;
name|filevec
index|[
literal|0
index|]
operator|.
name|alloc_lines
operator|=
name|alloc_lines0
operator|-
name|buffered_prefix
expr_stmt|;
name|filevec
index|[
literal|1
index|]
operator|.
name|alloc_lines
operator|=
name|alloc_lines1
operator|-
name|buffered_prefix
expr_stmt|;
name|filevec
index|[
literal|0
index|]
operator|.
name|prefix_lines
operator|=
name|filevec
index|[
literal|1
index|]
operator|.
name|prefix_lines
operator|=
name|lines
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If 1< k, then (2**k - prime_offset[k]) is the largest prime less    than 2**k.  This table is derived from Chris K. Caldwell's list<http://www.utm.edu/research/primes/lists/2small/>.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
specifier|const
name|prime_offset
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|1
block|,
literal|3
block|,
literal|1
block|,
literal|5
block|,
literal|3
block|,
literal|3
block|,
literal|9
block|,
literal|3
block|,
literal|1
block|,
literal|3
block|,
literal|19
block|,
literal|15
block|,
literal|1
block|,
literal|5
block|,
literal|1
block|,
literal|3
block|,
literal|9
block|,
literal|3
block|,
literal|15
block|,
literal|3
block|,
literal|39
block|,
literal|5
block|,
literal|39
block|,
literal|57
block|,
literal|3
block|,
literal|35
block|,
literal|1
block|,
literal|5
block|,
literal|9
block|,
literal|41
block|,
literal|31
block|,
literal|5
block|,
literal|25
block|,
literal|45
block|,
literal|7
block|,
literal|87
block|,
literal|21
block|,
literal|11
block|,
literal|57
block|,
literal|17
block|,
literal|55
block|,
literal|21
block|,
literal|115
block|,
literal|59
block|,
literal|81
block|,
literal|27
block|,
literal|129
block|,
literal|47
block|,
literal|111
block|,
literal|33
block|,
literal|55
block|,
literal|5
block|,
literal|13
block|,
literal|27
block|,
literal|55
block|,
literal|93
block|,
literal|1
block|,
literal|57
block|,
literal|25
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Verify that this host's size_t is not too wide for the above table.  */
end_comment

begin_expr_stmt
name|verify
argument_list|(
name|enough_prime_offsets
argument_list|,
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|*
name|CHAR_BIT
operator|<=
sizeof|sizeof
name|prime_offset
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Given a vector of two file_data objects, read the file associated    with each one, and build the table of equivalence classes.    Return nonzero if either file appears to be a binary file.    If PRETEND_BINARY is nonzero, pretend they are binary regardless.  */
end_comment

begin_function
name|bool
name|read_files
parameter_list|(
name|struct
name|file_data
name|filevec
index|[]
parameter_list|,
name|bool
name|pretend_binary
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|bool
name|skip_test
init|=
name|text
operator||
name|pretend_binary
decl_stmt|;
name|bool
name|appears_binary
init|=
name|pretend_binary
operator||
name|sip
argument_list|(
operator|&
name|filevec
index|[
literal|0
index|]
argument_list|,
name|skip_test
argument_list|)
decl_stmt|;
if|if
condition|(
name|filevec
index|[
literal|0
index|]
operator|.
name|desc
operator|!=
name|filevec
index|[
literal|1
index|]
operator|.
name|desc
condition|)
name|appears_binary
operator||=
name|sip
argument_list|(
operator|&
name|filevec
index|[
literal|1
index|]
argument_list|,
name|skip_test
operator||
name|appears_binary
argument_list|)
expr_stmt|;
else|else
block|{
name|filevec
index|[
literal|1
index|]
operator|.
name|buffer
operator|=
name|filevec
index|[
literal|0
index|]
operator|.
name|buffer
expr_stmt|;
name|filevec
index|[
literal|1
index|]
operator|.
name|bufsize
operator|=
name|filevec
index|[
literal|0
index|]
operator|.
name|bufsize
expr_stmt|;
name|filevec
index|[
literal|1
index|]
operator|.
name|buffered
operator|=
name|filevec
index|[
literal|0
index|]
operator|.
name|buffered
expr_stmt|;
block|}
if|if
condition|(
name|appears_binary
condition|)
block|{
name|set_binary_mode
argument_list|(
name|filevec
index|[
literal|0
index|]
operator|.
name|desc
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|set_binary_mode
argument_list|(
name|filevec
index|[
literal|1
index|]
operator|.
name|desc
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|find_identical_ends
argument_list|(
name|filevec
argument_list|)
expr_stmt|;
name|equivs_alloc
operator|=
name|filevec
index|[
literal|0
index|]
operator|.
name|alloc_lines
operator|+
name|filevec
index|[
literal|1
index|]
operator|.
name|alloc_lines
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|PTRDIFF_MAX
operator|/
sizeof|sizeof
expr|*
name|equivs
operator|<=
name|equivs_alloc
condition|)
name|xalloc_die
argument_list|()
expr_stmt|;
name|equivs
operator|=
name|xmalloc
argument_list|(
name|equivs_alloc
operator|*
sizeof|sizeof
expr|*
name|equivs
argument_list|)
expr_stmt|;
comment|/* Equivalence class 0 is permanently safe for lines that were not      hashed.  Real equivalence classes start at 1.  */
name|equivs_index
operator|=
literal|1
expr_stmt|;
comment|/* Allocate (one plus) a prime number of hash buckets.  Use a prime      number between 1/3 and 2/3 of the value of equiv_allocs,      approximately.  */
for|for
control|(
name|i
operator|=
literal|9
init|;
operator|(
name|size_t
operator|)
literal|1
operator|<<
name|i
operator|<
name|equivs_alloc
operator|/
literal|3
condition|;
name|i
operator|++
control|)
continue|continue;
name|nbuckets
operator|=
operator|(
operator|(
name|size_t
operator|)
literal|1
operator|<<
name|i
operator|)
operator|-
name|prime_offset
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|PTRDIFF_MAX
operator|/
sizeof|sizeof
expr|*
name|buckets
operator|<=
name|nbuckets
condition|)
name|xalloc_die
argument_list|()
expr_stmt|;
name|buckets
operator|=
name|zalloc
argument_list|(
operator|(
name|nbuckets
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
expr|*
name|buckets
argument_list|)
expr_stmt|;
name|buckets
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
name|find_and_hash_each_line
argument_list|(
operator|&
name|filevec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|filevec
index|[
literal|0
index|]
operator|.
name|equiv_max
operator|=
name|filevec
index|[
literal|1
index|]
operator|.
name|equiv_max
operator|=
name|equivs_index
expr_stmt|;
name|free
argument_list|(
name|equivs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buckets
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

end_unit

