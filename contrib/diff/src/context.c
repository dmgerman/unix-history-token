begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Context-format output routines for GNU DIFF.     Copyright (C) 1988, 1989, 1991, 1992, 1993, 1994, 1995, 1998, 2001,    2002, 2004 Free Software Foundation, Inc.     This file is part of GNU DIFF.     GNU DIFF is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GNU DIFF is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; see the file COPYING.    If not, write to the Free Software Foundation,    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"diff.h"
end_include

begin_include
include|#
directive|include
file|<inttostr.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ST_MTIM_NSEC
end_ifdef

begin_define
define|#
directive|define
name|TIMESPEC_NS
parameter_list|(
name|timespec
parameter_list|)
value|((timespec).ST_MTIM_NSEC)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TIMESPEC_NS
parameter_list|(
name|timespec
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|size_t
name|nstrftime
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|,
name|struct
name|tm
specifier|const
modifier|*
parameter_list|,
name|int
parameter_list|,
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
specifier|const
modifier|*
name|find_function
parameter_list|(
name|char
specifier|const
modifier|*
specifier|const
modifier|*
parameter_list|,
name|lin
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|change
modifier|*
name|find_hunk
parameter_list|(
name|struct
name|change
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_ignorable
parameter_list|(
name|struct
name|change
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pr_context_hunk
parameter_list|(
name|struct
name|change
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pr_unidiff_hunk
parameter_list|(
name|struct
name|change
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Last place find_function started searching from.  */
end_comment

begin_decl_stmt
specifier|static
name|lin
name|find_function_last_search
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The value find_function returned when it started searching there.  */
end_comment

begin_decl_stmt
specifier|static
name|lin
name|find_function_last_match
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Print a label for a context diff, with a file name and date or a label.  */
end_comment

begin_function
specifier|static
name|void
name|print_context_label
parameter_list|(
name|char
specifier|const
modifier|*
name|mark
parameter_list|,
name|struct
name|file_data
modifier|*
name|inf
parameter_list|,
name|char
specifier|const
modifier|*
name|label
parameter_list|)
block|{
if|if
condition|(
name|label
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%s %s\n"
argument_list|,
name|mark
argument_list|,
name|label
argument_list|)
expr_stmt|;
else|else
block|{
name|char
name|buf
index|[
name|MAX
argument_list|(
name|INT_STRLEN_BOUND
argument_list|(
name|int
argument_list|)
operator|+
literal|32
argument_list|,
name|INT_STRLEN_BOUND
argument_list|(
name|time_t
argument_list|)
operator|+
literal|11
argument_list|)
index|]
decl_stmt|;
name|struct
name|tm
specifier|const
modifier|*
name|tm
init|=
name|localtime
argument_list|(
operator|&
name|inf
operator|->
name|stat
operator|.
name|st_mtime
argument_list|)
decl_stmt|;
name|long
name|nsec
init|=
name|TIMESPEC_NS
argument_list|(
name|inf
operator|->
name|stat
operator|.
name|st_mtim
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|tm
operator|&&
name|nstrftime
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|time_format
argument_list|,
name|tm
argument_list|,
literal|0
argument_list|,
name|nsec
argument_list|)
operator|)
condition|)
block|{
name|time_t
name|sec
init|=
name|inf
operator|->
name|stat
operator|.
name|st_mtime
decl_stmt|;
name|verify
argument_list|(
name|info_preserved
argument_list|,
sizeof|sizeof
name|inf
operator|->
name|stat
operator|.
name|st_mtime
operator|<=
sizeof|sizeof
name|sec
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%jd.%.9d"
argument_list|,
operator|(
name|intmax_t
operator|)
name|sec
argument_list|,
name|nsec
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%s %s\t%s\n"
argument_list|,
name|mark
argument_list|,
name|inf
operator|->
name|name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print a header for a context diff, with the file names and dates.  */
end_comment

begin_function
name|void
name|print_context_header
parameter_list|(
name|struct
name|file_data
name|inf
index|[]
parameter_list|,
name|bool
name|unidiff
parameter_list|)
block|{
if|if
condition|(
name|unidiff
condition|)
block|{
name|print_context_label
argument_list|(
literal|"---"
argument_list|,
operator|&
name|inf
index|[
literal|0
index|]
argument_list|,
name|file_label
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|print_context_label
argument_list|(
literal|"+++"
argument_list|,
operator|&
name|inf
index|[
literal|1
index|]
argument_list|,
name|file_label
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|print_context_label
argument_list|(
literal|"***"
argument_list|,
operator|&
name|inf
index|[
literal|0
index|]
argument_list|,
name|file_label
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|print_context_label
argument_list|(
literal|"---"
argument_list|,
operator|&
name|inf
index|[
literal|1
index|]
argument_list|,
name|file_label
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print an edit script in context format.  */
end_comment

begin_function
name|void
name|print_context_script
parameter_list|(
name|struct
name|change
modifier|*
name|script
parameter_list|,
name|bool
name|unidiff
parameter_list|)
block|{
if|if
condition|(
name|ignore_blank_lines
operator|||
name|ignore_regexp
operator|.
name|fastmap
condition|)
name|mark_ignorable
argument_list|(
name|script
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|change
modifier|*
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|script
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|link
control|)
name|e
operator|->
name|ignore
operator|=
name|false
expr_stmt|;
block|}
name|find_function_last_search
operator|=
operator|-
name|files
index|[
literal|0
index|]
operator|.
name|prefix_lines
expr_stmt|;
name|find_function_last_match
operator|=
name|LIN_MAX
expr_stmt|;
if|if
condition|(
name|unidiff
condition|)
name|print_script
argument_list|(
name|script
argument_list|,
name|find_hunk
argument_list|,
name|pr_unidiff_hunk
argument_list|)
expr_stmt|;
else|else
name|print_script
argument_list|(
name|script
argument_list|,
name|find_hunk
argument_list|,
name|pr_context_hunk
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print a pair of line numbers with a comma, translated for file FILE.    If the second number is not greater, use the first in place of it.     Args A and B are internal line numbers.    We print the translated (real) line numbers.  */
end_comment

begin_function
specifier|static
name|void
name|print_context_number_range
parameter_list|(
name|struct
name|file_data
specifier|const
modifier|*
name|file
parameter_list|,
name|lin
name|a
parameter_list|,
name|lin
name|b
parameter_list|)
block|{
name|long
name|int
name|trans_a
decl_stmt|,
name|trans_b
decl_stmt|;
name|translate_range
argument_list|(
name|file
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
operator|&
name|trans_a
argument_list|,
operator|&
name|trans_b
argument_list|)
expr_stmt|;
comment|/* We can have B<= A in the case of a range of no lines.      In this case, we should print the line number before the range,      which is B.       POSIX 1003.1-2001 requires two line numbers separated by a comma      even if the line numbers are the same.  However, this does not      match existing practice and is surely an error in the      specification.  */
if|if
condition|(
name|trans_b
operator|<=
name|trans_a
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%ld"
argument_list|,
name|trans_b
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%ld,%ld"
argument_list|,
name|trans_a
argument_list|,
name|trans_b
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print FUNCTION in a context header.  */
end_comment

begin_function
specifier|static
name|void
name|print_context_function
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|,
name|char
specifier|const
modifier|*
name|function
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|putc
argument_list|(
literal|' '
argument_list|,
name|out
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|40
operator|&&
name|function
index|[
name|i
index|]
operator|!=
literal|'\n'
condition|;
name|i
operator|++
control|)
continue|continue;
name|fwrite
argument_list|(
name|function
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|i
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print a portion of an edit script in context format.    HUNK is the beginning of the portion to be printed.    The end is marked by a `link' that has been nulled out.     Prints out lines from both files, and precedes each    line with the appropriate flag-character.  */
end_comment

begin_function
specifier|static
name|void
name|pr_context_hunk
parameter_list|(
name|struct
name|change
modifier|*
name|hunk
parameter_list|)
block|{
name|lin
name|first0
decl_stmt|,
name|last0
decl_stmt|,
name|first1
decl_stmt|,
name|last1
decl_stmt|,
name|i
decl_stmt|;
name|char
specifier|const
modifier|*
name|prefix
decl_stmt|;
name|char
specifier|const
modifier|*
name|function
decl_stmt|;
name|FILE
modifier|*
name|out
decl_stmt|;
comment|/* Determine range of line numbers involved in each file.  */
name|enum
name|changes
name|changes
init|=
name|analyze_hunk
argument_list|(
name|hunk
argument_list|,
operator|&
name|first0
argument_list|,
operator|&
name|last0
argument_list|,
operator|&
name|first1
argument_list|,
operator|&
name|last1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|changes
condition|)
return|return;
comment|/* Include a context's width before and after.  */
name|i
operator|=
operator|-
name|files
index|[
literal|0
index|]
operator|.
name|prefix_lines
expr_stmt|;
name|first0
operator|=
name|MAX
argument_list|(
name|first0
operator|-
name|context
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|first1
operator|=
name|MAX
argument_list|(
name|first1
operator|-
name|context
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|last0
operator|<
name|files
index|[
literal|0
index|]
operator|.
name|valid_lines
operator|-
name|context
condition|)
name|last0
operator|+=
name|context
expr_stmt|;
else|else
name|last0
operator|=
name|files
index|[
literal|0
index|]
operator|.
name|valid_lines
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|last1
operator|<
name|files
index|[
literal|1
index|]
operator|.
name|valid_lines
operator|-
name|context
condition|)
name|last1
operator|+=
name|context
expr_stmt|;
else|else
name|last1
operator|=
name|files
index|[
literal|1
index|]
operator|.
name|valid_lines
operator|-
literal|1
expr_stmt|;
comment|/* If desired, find the preceding function definition line in file 0.  */
name|function
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|function_regexp
operator|.
name|fastmap
condition|)
name|function
operator|=
name|find_function
argument_list|(
name|files
index|[
literal|0
index|]
operator|.
name|linbuf
argument_list|,
name|first0
argument_list|)
expr_stmt|;
name|begin_output
argument_list|()
expr_stmt|;
name|out
operator|=
name|outfile
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"***************"
argument_list|)
expr_stmt|;
if|if
condition|(
name|function
condition|)
name|print_context_function
argument_list|(
name|out
argument_list|,
name|function
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n*** "
argument_list|)
expr_stmt|;
name|print_context_number_range
argument_list|(
operator|&
name|files
index|[
literal|0
index|]
argument_list|,
name|first0
argument_list|,
name|last0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" ****\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|changes
operator|&
name|OLD
condition|)
block|{
name|struct
name|change
modifier|*
name|next
init|=
name|hunk
decl_stmt|;
for|for
control|(
name|i
operator|=
name|first0
init|;
name|i
operator|<=
name|last0
condition|;
name|i
operator|++
control|)
block|{
comment|/* Skip past changes that apply (in file 0) 	     only to lines before line I.  */
while|while
condition|(
name|next
operator|&&
name|next
operator|->
name|line0
operator|+
name|next
operator|->
name|deleted
operator|<=
name|i
condition|)
name|next
operator|=
name|next
operator|->
name|link
expr_stmt|;
comment|/* Compute the marking for line I.  */
name|prefix
operator|=
literal|" "
expr_stmt|;
if|if
condition|(
name|next
operator|&&
name|next
operator|->
name|line0
operator|<=
name|i
condition|)
comment|/* The change NEXT covers this line. 	       If lines were inserted here in file 1, this is "changed". 	       Otherwise it is "deleted".  */
name|prefix
operator|=
operator|(
name|next
operator|->
name|inserted
operator|>
literal|0
condition|?
literal|"!"
else|:
literal|"-"
operator|)
expr_stmt|;
name|print_1_line
argument_list|(
name|prefix
argument_list|,
operator|&
name|files
index|[
literal|0
index|]
operator|.
name|linbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"--- "
argument_list|)
expr_stmt|;
name|print_context_number_range
argument_list|(
operator|&
name|files
index|[
literal|1
index|]
argument_list|,
name|first1
argument_list|,
name|last1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" ----\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|changes
operator|&
name|NEW
condition|)
block|{
name|struct
name|change
modifier|*
name|next
init|=
name|hunk
decl_stmt|;
for|for
control|(
name|i
operator|=
name|first1
init|;
name|i
operator|<=
name|last1
condition|;
name|i
operator|++
control|)
block|{
comment|/* Skip past changes that apply (in file 1) 	     only to lines before line I.  */
while|while
condition|(
name|next
operator|&&
name|next
operator|->
name|line1
operator|+
name|next
operator|->
name|inserted
operator|<=
name|i
condition|)
name|next
operator|=
name|next
operator|->
name|link
expr_stmt|;
comment|/* Compute the marking for line I.  */
name|prefix
operator|=
literal|" "
expr_stmt|;
if|if
condition|(
name|next
operator|&&
name|next
operator|->
name|line1
operator|<=
name|i
condition|)
comment|/* The change NEXT covers this line. 	       If lines were deleted here in file 0, this is "changed". 	       Otherwise it is "inserted".  */
name|prefix
operator|=
operator|(
name|next
operator|->
name|deleted
operator|>
literal|0
condition|?
literal|"!"
else|:
literal|"+"
operator|)
expr_stmt|;
name|print_1_line
argument_list|(
name|prefix
argument_list|,
operator|&
name|files
index|[
literal|1
index|]
operator|.
name|linbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print a pair of line numbers with a comma, translated for file FILE.    If the second number is smaller, use the first in place of it.    If the numbers are equal, print just one number.     Args A and B are internal line numbers.    We print the translated (real) line numbers.  */
end_comment

begin_function
specifier|static
name|void
name|print_unidiff_number_range
parameter_list|(
name|struct
name|file_data
specifier|const
modifier|*
name|file
parameter_list|,
name|lin
name|a
parameter_list|,
name|lin
name|b
parameter_list|)
block|{
name|long
name|int
name|trans_a
decl_stmt|,
name|trans_b
decl_stmt|;
name|translate_range
argument_list|(
name|file
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
operator|&
name|trans_a
argument_list|,
operator|&
name|trans_b
argument_list|)
expr_stmt|;
comment|/* We can have B< A in the case of a range of no lines.      In this case, we print the line number before the range,      which is B.  It would be more logical to print A, but      'patch' expects B in order to detect diffs against empty files.  */
if|if
condition|(
name|trans_b
operator|<=
name|trans_a
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|trans_b
operator|<
name|trans_a
condition|?
literal|"%ld,0"
else|:
literal|"%ld"
argument_list|,
name|trans_b
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%ld,%ld"
argument_list|,
name|trans_a
argument_list|,
name|trans_b
operator|-
name|trans_a
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print a portion of an edit script in unidiff format.    HUNK is the beginning of the portion to be printed.    The end is marked by a `link' that has been nulled out.     Prints out lines from both files, and precedes each    line with the appropriate flag-character.  */
end_comment

begin_function
specifier|static
name|void
name|pr_unidiff_hunk
parameter_list|(
name|struct
name|change
modifier|*
name|hunk
parameter_list|)
block|{
name|lin
name|first0
decl_stmt|,
name|last0
decl_stmt|,
name|first1
decl_stmt|,
name|last1
decl_stmt|;
name|lin
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|struct
name|change
modifier|*
name|next
decl_stmt|;
name|char
specifier|const
modifier|*
name|function
decl_stmt|;
name|FILE
modifier|*
name|out
decl_stmt|;
comment|/* Determine range of line numbers involved in each file.  */
if|if
condition|(
operator|!
name|analyze_hunk
argument_list|(
name|hunk
argument_list|,
operator|&
name|first0
argument_list|,
operator|&
name|last0
argument_list|,
operator|&
name|first1
argument_list|,
operator|&
name|last1
argument_list|)
condition|)
return|return;
comment|/* Include a context's width before and after.  */
name|i
operator|=
operator|-
name|files
index|[
literal|0
index|]
operator|.
name|prefix_lines
expr_stmt|;
name|first0
operator|=
name|MAX
argument_list|(
name|first0
operator|-
name|context
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|first1
operator|=
name|MAX
argument_list|(
name|first1
operator|-
name|context
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|last0
operator|<
name|files
index|[
literal|0
index|]
operator|.
name|valid_lines
operator|-
name|context
condition|)
name|last0
operator|+=
name|context
expr_stmt|;
else|else
name|last0
operator|=
name|files
index|[
literal|0
index|]
operator|.
name|valid_lines
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|last1
operator|<
name|files
index|[
literal|1
index|]
operator|.
name|valid_lines
operator|-
name|context
condition|)
name|last1
operator|+=
name|context
expr_stmt|;
else|else
name|last1
operator|=
name|files
index|[
literal|1
index|]
operator|.
name|valid_lines
operator|-
literal|1
expr_stmt|;
comment|/* If desired, find the preceding function definition line in file 0.  */
name|function
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|function_regexp
operator|.
name|fastmap
condition|)
name|function
operator|=
name|find_function
argument_list|(
name|files
index|[
literal|0
index|]
operator|.
name|linbuf
argument_list|,
name|first0
argument_list|)
expr_stmt|;
name|begin_output
argument_list|()
expr_stmt|;
name|out
operator|=
name|outfile
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"@@ -"
argument_list|)
expr_stmt|;
name|print_unidiff_number_range
argument_list|(
operator|&
name|files
index|[
literal|0
index|]
argument_list|,
name|first0
argument_list|,
name|last0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" +"
argument_list|)
expr_stmt|;
name|print_unidiff_number_range
argument_list|(
operator|&
name|files
index|[
literal|1
index|]
argument_list|,
name|first1
argument_list|,
name|last1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" @@"
argument_list|)
expr_stmt|;
if|if
condition|(
name|function
condition|)
name|print_context_function
argument_list|(
name|out
argument_list|,
name|function
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|next
operator|=
name|hunk
expr_stmt|;
name|i
operator|=
name|first0
expr_stmt|;
name|j
operator|=
name|first1
expr_stmt|;
while|while
condition|(
name|i
operator|<=
name|last0
operator|||
name|j
operator|<=
name|last1
condition|)
block|{
comment|/* If the line isn't a difference, output the context from file 0. */
if|if
condition|(
operator|!
name|next
operator|||
name|i
operator|<
name|next
operator|->
name|line0
condition|)
block|{
name|putc
argument_list|(
name|initial_tab
condition|?
literal|'\t'
else|:
literal|' '
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|print_1_line
argument_list|(
literal|0
argument_list|,
operator|&
name|files
index|[
literal|0
index|]
operator|.
name|linbuf
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* For each difference, first output the deleted part. */
name|k
operator|=
name|next
operator|->
name|deleted
expr_stmt|;
while|while
condition|(
name|k
operator|--
condition|)
block|{
name|putc
argument_list|(
literal|'-'
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|initial_tab
condition|)
name|putc
argument_list|(
literal|'\t'
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|print_1_line
argument_list|(
literal|0
argument_list|,
operator|&
name|files
index|[
literal|0
index|]
operator|.
name|linbuf
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Then output the inserted part. */
name|k
operator|=
name|next
operator|->
name|inserted
expr_stmt|;
while|while
condition|(
name|k
operator|--
condition|)
block|{
name|putc
argument_list|(
literal|'+'
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|initial_tab
condition|)
name|putc
argument_list|(
literal|'\t'
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|print_1_line
argument_list|(
literal|0
argument_list|,
operator|&
name|files
index|[
literal|1
index|]
operator|.
name|linbuf
index|[
name|j
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* We're done with this hunk, so on to the next! */
name|next
operator|=
name|next
operator|->
name|link
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan a (forward-ordered) edit script for the first place that more than    2*CONTEXT unchanged lines appear, and return a pointer    to the `struct change' for the last change before those lines.  */
end_comment

begin_function
specifier|static
name|struct
name|change
modifier|*
name|find_hunk
parameter_list|(
name|struct
name|change
modifier|*
name|start
parameter_list|)
block|{
name|struct
name|change
modifier|*
name|prev
decl_stmt|;
name|lin
name|top0
decl_stmt|,
name|top1
decl_stmt|;
name|lin
name|thresh
decl_stmt|;
comment|/* Threshold distance is 2 * CONTEXT + 1 between two non-ignorable      changes, but only CONTEXT if one is ignorable.  Watch out for      integer overflow, though.  */
name|lin
name|non_ignorable_threshold
init|=
operator|(
name|LIN_MAX
operator|-
literal|1
operator|)
operator|/
literal|2
operator|<
name|context
condition|?
name|LIN_MAX
else|:
literal|2
operator|*
name|context
operator|+
literal|1
decl_stmt|;
name|lin
name|ignorable_threshold
init|=
name|context
decl_stmt|;
do|do
block|{
comment|/* Compute number of first line in each file beyond this changed.  */
name|top0
operator|=
name|start
operator|->
name|line0
operator|+
name|start
operator|->
name|deleted
expr_stmt|;
name|top1
operator|=
name|start
operator|->
name|line1
operator|+
name|start
operator|->
name|inserted
expr_stmt|;
name|prev
operator|=
name|start
expr_stmt|;
name|start
operator|=
name|start
operator|->
name|link
expr_stmt|;
name|thresh
operator|=
operator|(
name|prev
operator|->
name|ignore
operator|||
operator|(
name|start
operator|&&
name|start
operator|->
name|ignore
operator|)
condition|?
name|ignorable_threshold
else|:
name|non_ignorable_threshold
operator|)
expr_stmt|;
comment|/* It is not supposed to matter which file we check in the end-test. 	 If it would matter, crash.  */
if|if
condition|(
name|start
operator|&&
name|start
operator|->
name|line0
operator|-
name|top0
operator|!=
name|start
operator|->
name|line1
operator|-
name|top1
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|start
comment|/* Keep going if less than THRESH lines 		elapse before the affected line.  */
operator|&&
name|start
operator|->
name|line0
operator|-
name|top0
operator|<
name|thresh
condition|)
do|;
return|return
name|prev
return|;
block|}
end_function

begin_comment
comment|/* Set the `ignore' flag properly in each change in SCRIPT.    It should be 1 if all the lines inserted or deleted in that change    are ignorable lines.  */
end_comment

begin_function
specifier|static
name|void
name|mark_ignorable
parameter_list|(
name|struct
name|change
modifier|*
name|script
parameter_list|)
block|{
while|while
condition|(
name|script
condition|)
block|{
name|struct
name|change
modifier|*
name|next
init|=
name|script
operator|->
name|link
decl_stmt|;
name|lin
name|first0
decl_stmt|,
name|last0
decl_stmt|,
name|first1
decl_stmt|,
name|last1
decl_stmt|;
comment|/* Turn this change into a hunk: detach it from the others.  */
name|script
operator|->
name|link
operator|=
literal|0
expr_stmt|;
comment|/* Determine whether this change is ignorable.  */
name|script
operator|->
name|ignore
operator|=
operator|!
name|analyze_hunk
argument_list|(
name|script
argument_list|,
operator|&
name|first0
argument_list|,
operator|&
name|last0
argument_list|,
operator|&
name|first1
argument_list|,
operator|&
name|last1
argument_list|)
expr_stmt|;
comment|/* Reconnect the chain as before.  */
name|script
operator|->
name|link
operator|=
name|next
expr_stmt|;
comment|/* Advance to the following change.  */
name|script
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find the last function-header line in LINBUF prior to line number LINENUM.    This is a line containing a match for the regexp in `function_regexp'.    Return the address of the text, or 0 if no function-header is found.  */
end_comment

begin_function
specifier|static
name|char
specifier|const
modifier|*
name|find_function
parameter_list|(
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|linbuf
parameter_list|,
name|lin
name|linenum
parameter_list|)
block|{
name|lin
name|i
init|=
name|linenum
decl_stmt|;
name|lin
name|last
init|=
name|find_function_last_search
decl_stmt|;
name|find_function_last_search
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|last
operator|<=
operator|--
name|i
condition|)
block|{
comment|/* See if this line is what we want.  */
name|char
specifier|const
modifier|*
name|line
init|=
name|linbuf
index|[
name|i
index|]
decl_stmt|;
name|size_t
name|linelen
init|=
name|linbuf
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|line
operator|-
literal|1
decl_stmt|;
comment|/* FIXME: re_search's size args should be size_t, not int.  */
name|int
name|len
init|=
name|MIN
argument_list|(
name|linelen
argument_list|,
name|INT_MAX
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|<=
name|re_search
argument_list|(
operator|&
name|function_regexp
argument_list|,
name|line
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|find_function_last_match
operator|=
name|i
expr_stmt|;
return|return
name|line
return|;
block|}
block|}
comment|/* If we search back to where we started searching the previous time,      find the line we found last time.  */
if|if
condition|(
name|find_function_last_match
operator|!=
name|LIN_MAX
condition|)
return|return
name|linbuf
index|[
name|find_function_last_match
index|]
return|;
return|return
literal|0
return|;
block|}
end_function

end_unit

