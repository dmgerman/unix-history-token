begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* cmp - compare two files byte by byte     Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 2001,    2002, 2004 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.    See the GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; see the file COPYING.    If not, write to the Free Software Foundation,    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"paths.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<c-stack.h>
end_include

begin_include
include|#
directive|include
file|<cmpbuf.h>
end_include

begin_include
include|#
directive|include
file|<error.h>
end_include

begin_include
include|#
directive|include
file|<exit.h>
end_include

begin_include
include|#
directive|include
file|<exitfail.h>
end_include

begin_include
include|#
directive|include
file|<file-type.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<hard-locale.h>
end_include

begin_include
include|#
directive|include
file|<inttostr.h>
end_include

begin_include
include|#
directive|include
file|<setmode.h>
end_include

begin_include
include|#
directive|include
file|<unlocked-io.h>
end_include

begin_include
include|#
directive|include
file|<version-etc.h>
end_include

begin_include
include|#
directive|include
file|<xalloc.h>
end_include

begin_include
include|#
directive|include
file|<xstrtol.h>
end_include

begin_if
if|#
directive|if
name|defined
name|LC_MESSAGES
operator|&&
name|ENABLE_NLS
end_if

begin_define
define|#
directive|define
name|hard_locale_LC_MESSAGES
value|hard_locale (LC_MESSAGES)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|hard_locale_LC_MESSAGES
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|cmp
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|off_t
name|file_position
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|block_compare
parameter_list|(
name|word
specifier|const
modifier|*
parameter_list|,
name|word
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|block_compare_and_count
parameter_list|(
name|word
specifier|const
modifier|*
parameter_list|,
name|word
specifier|const
modifier|*
parameter_list|,
name|off_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sprintc
parameter_list|(
name|char
modifier|*
parameter_list|,
name|unsigned
name|char
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Name under which this program was invoked.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Filenames of the compared files.  */
end_comment

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|file
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File descriptors of the files.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|file_desc
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Status of the files.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|stat
name|stat_buf
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read buffers for the files.  */
end_comment

begin_decl_stmt
specifier|static
name|word
modifier|*
name|buffer
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Optimal block size for the files.  */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|buf_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initial prefix to ignore for each file.  */
end_comment

begin_decl_stmt
specifier|static
name|off_t
name|ignore_initial
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of bytes to compare.  */
end_comment

begin_decl_stmt
specifier|static
name|uintmax_t
name|bytes
init|=
name|UINTMAX_MAX
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output format.  */
end_comment

begin_enum
specifier|static
enum|enum
name|comparison_type
block|{
name|type_first_diff
block|,
comment|/* Print the first difference.  */
name|type_all_diffs
block|,
comment|/* Print all differences.  */
name|type_status
comment|/* Exit status only.  */
block|}
name|comparison_type
enum|;
end_enum

begin_comment
comment|/* If nonzero, print values of bytes quoted like cat -t does. */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|opt_print_bytes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Values for long options that do not have single-letter equivalents.  */
end_comment

begin_enum
enum|enum
block|{
name|HELP_OPTION
init|=
name|CHAR_MAX
operator|+
literal|1
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|struct
name|option
specifier|const
name|long_options
index|[]
init|=
block|{
block|{
literal|"print-bytes"
block|,
literal|0
block|,
literal|0
block|,
literal|'b'
block|}
block|,
block|{
literal|"print-chars"
block|,
literal|0
block|,
literal|0
block|,
literal|'c'
block|}
block|,
comment|/* obsolescent as of diffutils 2.7.3 */
block|{
literal|"ignore-initial"
block|,
literal|1
block|,
literal|0
block|,
literal|'i'
block|}
block|,
block|{
literal|"verbose"
block|,
literal|0
block|,
literal|0
block|,
literal|'l'
block|}
block|,
block|{
literal|"bytes"
block|,
literal|1
block|,
literal|0
block|,
literal|'n'
block|}
block|,
block|{
literal|"silent"
block|,
literal|0
block|,
literal|0
block|,
literal|'s'
block|}
block|,
block|{
literal|"quiet"
block|,
literal|0
block|,
literal|0
block|,
literal|'s'
block|}
block|,
block|{
literal|"version"
block|,
literal|0
block|,
literal|0
block|,
literal|'v'
block|}
block|,
block|{
literal|"help"
block|,
literal|0
block|,
literal|0
block|,
name|HELP_OPTION
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function_decl
specifier|static
name|void
name|try_help
parameter_list|(
name|char
specifier|const
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(noreturn
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_function
specifier|static
name|void
name|try_help
parameter_list|(
name|char
specifier|const
modifier|*
name|reason_msgid
parameter_list|,
name|char
specifier|const
modifier|*
name|operand
parameter_list|)
block|{
if|if
condition|(
name|reason_msgid
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
name|reason_msgid
argument_list|)
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|EXIT_TROUBLE
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Try `%s --help' for more information."
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
specifier|const
name|valid_suffixes
index|[]
init|=
literal|"kKMGTPEZY0"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Update ignore_initial[F] according to the result of parsing an    *operand ARGPTR of --ignore-initial, updating *ARGPTR to point    *after the operand.  If DELIMITER is nonzero, the operand may be    *followed by DELIMITER; otherwise it must be null-terminated.  */
end_comment

begin_function
specifier|static
name|void
name|specify_ignore_initial
parameter_list|(
name|int
name|f
parameter_list|,
name|char
modifier|*
modifier|*
name|argptr
parameter_list|,
name|char
name|delimiter
parameter_list|)
block|{
name|uintmax_t
name|val
decl_stmt|;
name|off_t
name|o
decl_stmt|;
name|char
specifier|const
modifier|*
name|arg
init|=
operator|*
name|argptr
decl_stmt|;
name|strtol_error
name|e
init|=
name|xstrtoumax
argument_list|(
name|arg
argument_list|,
name|argptr
argument_list|,
literal|0
argument_list|,
operator|&
name|val
argument_list|,
name|valid_suffixes
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|e
operator|==
name|LONGINT_OK
operator|||
operator|(
name|e
operator|==
name|LONGINT_INVALID_SUFFIX_CHAR
operator|&&
operator|*
operator|*
name|argptr
operator|==
name|delimiter
operator|)
operator|)
operator|||
operator|(
name|o
operator|=
name|val
operator|)
operator|<
literal|0
operator|||
name|o
operator|!=
name|val
operator|||
name|val
operator|==
name|UINTMAX_MAX
condition|)
name|try_help
argument_list|(
literal|"invalid --ignore-initial value `%s'"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ignore_initial
index|[
name|f
index|]
operator|<
name|o
condition|)
name|ignore_initial
index|[
name|f
index|]
operator|=
name|o
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Specify the output format.  */
end_comment

begin_function
specifier|static
name|void
name|specify_comparison_type
parameter_list|(
name|enum
name|comparison_type
name|t
parameter_list|)
block|{
if|if
condition|(
name|comparison_type
operator|&&
name|comparison_type
operator|!=
name|t
condition|)
name|try_help
argument_list|(
literal|"options -l and -s are incompatible"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|comparison_type
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_stdout
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
name|error
argument_list|(
name|EXIT_TROUBLE
argument_list|,
literal|0
argument_list|,
literal|"%s"
argument_list|,
name|_
argument_list|(
literal|"write failed"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fclose
argument_list|(
name|stdout
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
name|EXIT_TROUBLE
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|_
argument_list|(
literal|"standard output"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
specifier|const
name|option_help_msgid
index|[]
init|=
block|{
name|N_
argument_list|(
literal|"-b  --print-bytes  Print differing bytes."
argument_list|)
block|,
name|N_
argument_list|(
literal|"-i SKIP  --ignore-initial=SKIP  Skip the first SKIP bytes of input."
argument_list|)
block|,
name|N_
argument_list|(
literal|"-i SKIP1:SKIP2  --ignore-initial=SKIP1:SKIP2"
argument_list|)
block|,
name|N_
argument_list|(
literal|"  Skip the first SKIP1 bytes of FILE1 and the first SKIP2 bytes of FILE2."
argument_list|)
block|,
name|N_
argument_list|(
literal|"-l  --verbose  Output byte numbers and values of all differing bytes."
argument_list|)
block|,
name|N_
argument_list|(
literal|"-n LIMIT  --bytes=LIMIT  Compare at most LIMIT bytes."
argument_list|)
block|,
name|N_
argument_list|(
literal|"-s  --quiet  --silent  Output nothing; yield exit status only."
argument_list|)
block|,
name|N_
argument_list|(
literal|"-v  --version  Output version info."
argument_list|)
block|,
name|N_
argument_list|(
literal|"--help  Output this help."
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|p
decl_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"Usage: %s [OPTION]... FILE1 [FILE2 [SKIP1 [SKIP2]]]\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n\n"
argument_list|,
name|_
argument_list|(
literal|"Compare two files byte by byte."
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|option_help_msgid
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
name|printf
argument_list|(
literal|"  %s\n"
argument_list|,
name|_
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n%s\n%s\n\n%s\n%s\n\n%s\n"
argument_list|,
name|_
argument_list|(
literal|"SKIP1 and SKIP2 are the number of bytes to skip in each file."
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"SKIP values may be followed by the following multiplicative suffixes:\n\ kB 1000, K 1024, MB 1,000,000, M 1,048,576,\n\ GB 1,000,000,000, G 1,073,741,824, and so on for T, P, E, Z, Y."
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"If a FILE is `-' or missing, read standard input."
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Report bugs to<bug-gnu-utils@gnu.org>."
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|f
decl_stmt|,
name|exit_status
decl_stmt|;
name|size_t
name|words_per_buffer
decl_stmt|;
name|exit_failure
operator|=
name|EXIT_TROUBLE
expr_stmt|;
name|initialize_main
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|bindtextdomain
argument_list|(
name|PACKAGE
argument_list|,
name|LOCALEDIR
argument_list|)
expr_stmt|;
name|textdomain
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
name|c_stack_action
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Parse command line options.  */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"bci:ln:sv"
argument_list|,
name|long_options
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
comment|/* 'c' is obsolescent as of diffutils 2.7.3 */
name|opt_print_bytes
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|specify_ignore_initial
argument_list|(
literal|0
argument_list|,
operator|&
name|optarg
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|optarg
operator|++
operator|==
literal|':'
condition|)
name|specify_ignore_initial
argument_list|(
literal|1
argument_list|,
operator|&
name|optarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ignore_initial
index|[
literal|1
index|]
operator|<
name|ignore_initial
index|[
literal|0
index|]
condition|)
name|ignore_initial
index|[
literal|1
index|]
operator|=
name|ignore_initial
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|specify_comparison_type
argument_list|(
name|type_all_diffs
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
block|{
name|uintmax_t
name|n
decl_stmt|;
if|if
condition|(
name|xstrtoumax
argument_list|(
name|optarg
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|n
argument_list|,
name|valid_suffixes
argument_list|)
operator|!=
name|LONGINT_OK
condition|)
name|try_help
argument_list|(
literal|"invalid --bytes value `%s'"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
name|bytes
condition|)
name|bytes
operator|=
name|n
expr_stmt|;
block|}
break|break;
case|case
literal|'s'
case|:
name|specify_comparison_type
argument_list|(
name|type_status
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* TRANSLATORS: Please translate the second "o" in "Torbjorn 	   Granlund" to an o-with-umlaut (U+00F6, LATIN SMALL LETTER O 	   WITH DIAERESIS) if possible.  */
name|version_etc
argument_list|(
name|stdout
argument_list|,
literal|"cmp"
argument_list|,
name|PACKAGE_NAME
argument_list|,
name|PACKAGE_VERSION
argument_list|,
name|_
argument_list|(
literal|"Torbjorn Granlund"
argument_list|)
argument_list|,
literal|"David MacKenzie"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|check_stdout
argument_list|()
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
case|case
name|HELP_OPTION
case|:
name|usage
argument_list|()
expr_stmt|;
name|check_stdout
argument_list|()
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
default|default:
name|try_help
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
name|try_help
argument_list|(
literal|"missing operand after `%s'"
argument_list|,
name|argv
index|[
name|argc
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|file
index|[
literal|0
index|]
operator|=
name|argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
name|file
index|[
literal|1
index|]
operator|=
name|optind
operator|<
name|argc
condition|?
name|argv
index|[
name|optind
operator|++
index|]
else|:
literal|"-"
expr_stmt|;
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
literal|2
operator|&&
name|optind
operator|<
name|argc
condition|;
name|f
operator|++
control|)
block|{
name|char
modifier|*
name|arg
init|=
name|argv
index|[
name|optind
operator|++
index|]
decl_stmt|;
name|specify_ignore_initial
argument_list|(
name|f
argument_list|,
operator|&
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
name|try_help
argument_list|(
literal|"extra operand `%s'"
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
literal|2
condition|;
name|f
operator|++
control|)
block|{
comment|/* If file[1] is "-", treat it first; this avoids a misdiagnostic if 	 stdin is closed and opening file[0] yields file descriptor 0.  */
name|int
name|f1
init|=
name|f
operator|^
operator|(
name|strcmp
argument_list|(
name|file
index|[
literal|1
index|]
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
operator|)
decl_stmt|;
comment|/* Two files with the same name and offset are identical. 	 But wait until we open the file once, for proper diagnostics.  */
if|if
condition|(
name|f
operator|&&
name|ignore_initial
index|[
literal|0
index|]
operator|==
name|ignore_initial
index|[
literal|1
index|]
operator|&&
name|file_name_cmp
argument_list|(
name|file
index|[
literal|0
index|]
argument_list|,
name|file
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
return|return
name|EXIT_SUCCESS
return|;
name|file_desc
index|[
name|f1
index|]
operator|=
operator|(
name|strcmp
argument_list|(
name|file
index|[
name|f1
index|]
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|?
name|STDIN_FILENO
else|:
name|open
argument_list|(
name|file
index|[
name|f1
index|]
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|file_desc
index|[
name|f1
index|]
operator|<
literal|0
operator|||
name|fstat
argument_list|(
name|file_desc
index|[
name|f1
index|]
argument_list|,
name|stat_buf
operator|+
name|f1
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|file_desc
index|[
name|f1
index|]
operator|<
literal|0
operator|&&
name|comparison_type
operator|==
name|type_status
condition|)
name|exit
argument_list|(
name|EXIT_TROUBLE
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
name|EXIT_TROUBLE
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file
index|[
name|f1
index|]
argument_list|)
expr_stmt|;
block|}
name|set_binary_mode
argument_list|(
name|file_desc
index|[
name|f1
index|]
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
comment|/* If the files are links to the same inode and have the same file position,      they are identical.  */
if|if
condition|(
literal|0
operator|<
name|same_file
argument_list|(
operator|&
name|stat_buf
index|[
literal|0
index|]
argument_list|,
operator|&
name|stat_buf
index|[
literal|1
index|]
argument_list|)
operator|&&
name|same_file_attributes
argument_list|(
operator|&
name|stat_buf
index|[
literal|0
index|]
argument_list|,
operator|&
name|stat_buf
index|[
literal|1
index|]
argument_list|)
operator|&&
name|file_position
argument_list|(
literal|0
argument_list|)
operator|==
name|file_position
argument_list|(
literal|1
argument_list|)
condition|)
return|return
name|EXIT_SUCCESS
return|;
comment|/* If output is redirected to the null device, we may assume `-s'.  */
if|if
condition|(
name|comparison_type
operator|!=
name|type_status
condition|)
block|{
name|struct
name|stat
name|outstat
decl_stmt|,
name|nullstat
decl_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|STDOUT_FILENO
argument_list|,
operator|&
name|outstat
argument_list|)
operator|==
literal|0
operator|&&
name|stat
argument_list|(
name|NULL_DEVICE
argument_list|,
operator|&
name|nullstat
argument_list|)
operator|==
literal|0
operator|&&
literal|0
operator|<
name|same_file
argument_list|(
operator|&
name|outstat
argument_list|,
operator|&
name|nullstat
argument_list|)
condition|)
name|comparison_type
operator|=
name|type_status
expr_stmt|;
block|}
comment|/* If only a return code is needed,      and if both input descriptors are associated with plain files,      conclude that the files differ if they have different sizes      and if more bytes will be compared than are in the smaller file.  */
if|if
condition|(
name|comparison_type
operator|==
name|type_status
operator|&&
name|S_ISREG
argument_list|(
name|stat_buf
index|[
literal|0
index|]
operator|.
name|st_mode
argument_list|)
operator|&&
name|S_ISREG
argument_list|(
name|stat_buf
index|[
literal|1
index|]
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|off_t
name|s0
init|=
name|stat_buf
index|[
literal|0
index|]
operator|.
name|st_size
operator|-
name|file_position
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|off_t
name|s1
init|=
name|stat_buf
index|[
literal|1
index|]
operator|.
name|st_size
operator|-
name|file_position
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|s0
operator|<
literal|0
condition|)
name|s0
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s1
operator|<
literal|0
condition|)
name|s1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s0
operator|!=
name|s1
operator|&&
name|MIN
argument_list|(
name|s0
argument_list|,
name|s1
argument_list|)
operator|<
name|bytes
condition|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
comment|/* Get the optimal block size of the files.  */
name|buf_size
operator|=
name|buffer_lcm
argument_list|(
name|STAT_BLOCKSIZE
argument_list|(
name|stat_buf
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|STAT_BLOCKSIZE
argument_list|(
name|stat_buf
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|PTRDIFF_MAX
operator|-
sizeof|sizeof
argument_list|(
name|word
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate word-aligned buffers, with space for sentinels at the end.  */
name|words_per_buffer
operator|=
operator|(
name|buf_size
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|word
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|word
argument_list|)
expr_stmt|;
name|buffer
index|[
literal|0
index|]
operator|=
name|xmalloc
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|word
argument_list|)
operator|*
name|words_per_buffer
argument_list|)
expr_stmt|;
name|buffer
index|[
literal|1
index|]
operator|=
name|buffer
index|[
literal|0
index|]
operator|+
name|words_per_buffer
expr_stmt|;
name|exit_status
operator|=
name|cmp
argument_list|()
expr_stmt|;
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
literal|2
condition|;
name|f
operator|++
control|)
if|if
condition|(
name|close
argument_list|(
name|file_desc
index|[
name|f
index|]
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
name|EXIT_TROUBLE
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file
index|[
name|f
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|exit_status
operator|!=
literal|0
operator|&&
name|comparison_type
operator|!=
name|type_status
condition|)
name|check_stdout
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|exit_status
argument_list|)
expr_stmt|;
return|return
name|exit_status
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compare the two files already open on `file_desc[0]' and `file_desc[1]',    using `buffer[0]' and `buffer[1]'.    Return EXIT_SUCCESS if identical, EXIT_FAILURE if different,>1 if error.  */
end_comment

begin_function
specifier|static
name|int
name|cmp
parameter_list|(
name|void
parameter_list|)
block|{
name|off_t
name|line_number
init|=
literal|1
decl_stmt|;
comment|/* Line number (1...) of difference. */
name|off_t
name|byte_number
init|=
literal|1
decl_stmt|;
comment|/* Byte number (1...) of difference. */
name|uintmax_t
name|remaining
init|=
name|bytes
decl_stmt|;
comment|/* Remaining number of bytes to compare.  */
name|size_t
name|read0
decl_stmt|,
name|read1
decl_stmt|;
comment|/* Number of bytes read from each file. */
name|size_t
name|first_diff
decl_stmt|;
comment|/* Offset (0...) in buffers of 1st diff. */
name|size_t
name|smaller
decl_stmt|;
comment|/* The lesser of `read0' and `read1'. */
name|word
modifier|*
name|buffer0
init|=
name|buffer
index|[
literal|0
index|]
decl_stmt|;
name|word
modifier|*
name|buffer1
init|=
name|buffer
index|[
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|buf0
init|=
operator|(
name|char
operator|*
operator|)
name|buffer0
decl_stmt|;
name|char
modifier|*
name|buf1
init|=
operator|(
name|char
operator|*
operator|)
name|buffer1
decl_stmt|;
name|int
name|ret
init|=
name|EXIT_SUCCESS
decl_stmt|;
name|int
name|f
decl_stmt|;
name|int
name|offset_width
decl_stmt|;
if|if
condition|(
name|comparison_type
operator|==
name|type_all_diffs
condition|)
block|{
name|off_t
name|byte_number_max
init|=
name|MIN
argument_list|(
name|bytes
argument_list|,
name|TYPE_MAXIMUM
argument_list|(
name|off_t
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
literal|2
condition|;
name|f
operator|++
control|)
if|if
condition|(
name|S_ISREG
argument_list|(
name|stat_buf
index|[
name|f
index|]
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|off_t
name|file_bytes
init|=
name|stat_buf
index|[
name|f
index|]
operator|.
name|st_size
operator|-
name|file_position
argument_list|(
name|f
argument_list|)
decl_stmt|;
if|if
condition|(
name|file_bytes
operator|<
name|byte_number_max
condition|)
name|byte_number_max
operator|=
name|file_bytes
expr_stmt|;
block|}
for|for
control|(
name|offset_width
operator|=
literal|1
init|;
operator|(
name|byte_number_max
operator|/=
literal|10
operator|)
operator|!=
literal|0
condition|;
name|offset_width
operator|++
control|)
continue|continue;
block|}
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
literal|2
condition|;
name|f
operator|++
control|)
block|{
name|off_t
name|ig
init|=
name|ignore_initial
index|[
name|f
index|]
decl_stmt|;
if|if
condition|(
name|ig
operator|&&
name|file_position
argument_list|(
name|f
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* lseek failed; read and discard the ignored initial prefix.  */
do|do
block|{
name|size_t
name|bytes_to_read
init|=
name|MIN
argument_list|(
name|ig
argument_list|,
name|buf_size
argument_list|)
decl_stmt|;
name|size_t
name|r
init|=
name|block_read
argument_list|(
name|file_desc
index|[
name|f
index|]
argument_list|,
name|buf0
argument_list|,
name|bytes_to_read
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|!=
name|bytes_to_read
condition|)
block|{
if|if
condition|(
name|r
operator|==
name|SIZE_MAX
condition|)
name|error
argument_list|(
name|EXIT_TROUBLE
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file
index|[
name|f
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|ig
operator|-=
name|r
expr_stmt|;
block|}
do|while
condition|(
name|ig
condition|)
do|;
block|}
block|}
do|do
block|{
name|size_t
name|bytes_to_read
init|=
name|buf_size
decl_stmt|;
if|if
condition|(
name|remaining
operator|!=
name|UINTMAX_MAX
condition|)
block|{
if|if
condition|(
name|remaining
operator|<
name|bytes_to_read
condition|)
name|bytes_to_read
operator|=
name|remaining
expr_stmt|;
name|remaining
operator|-=
name|bytes_to_read
expr_stmt|;
block|}
name|read0
operator|=
name|block_read
argument_list|(
name|file_desc
index|[
literal|0
index|]
argument_list|,
name|buf0
argument_list|,
name|bytes_to_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|read0
operator|==
name|SIZE_MAX
condition|)
name|error
argument_list|(
name|EXIT_TROUBLE
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|read1
operator|=
name|block_read
argument_list|(
name|file_desc
index|[
literal|1
index|]
argument_list|,
name|buf1
argument_list|,
name|bytes_to_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|read1
operator|==
name|SIZE_MAX
condition|)
name|error
argument_list|(
name|EXIT_TROUBLE
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Insert sentinels for the block compare.  */
name|buf0
index|[
name|read0
index|]
operator|=
operator|~
name|buf1
index|[
name|read0
index|]
expr_stmt|;
name|buf1
index|[
name|read1
index|]
operator|=
operator|~
name|buf0
index|[
name|read1
index|]
expr_stmt|;
comment|/* If the line number should be written for differing files, 	 compare the blocks and count the number of newlines 	 simultaneously.  */
name|first_diff
operator|=
operator|(
name|comparison_type
operator|==
name|type_first_diff
condition|?
name|block_compare_and_count
argument_list|(
name|buffer0
argument_list|,
name|buffer1
argument_list|,
operator|&
name|line_number
argument_list|)
else|:
name|block_compare
argument_list|(
name|buffer0
argument_list|,
name|buffer1
argument_list|)
operator|)
expr_stmt|;
name|byte_number
operator|+=
name|first_diff
expr_stmt|;
name|smaller
operator|=
name|MIN
argument_list|(
name|read0
argument_list|,
name|read1
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_diff
operator|<
name|smaller
condition|)
block|{
switch|switch
condition|(
name|comparison_type
condition|)
block|{
case|case
name|type_first_diff
case|:
block|{
name|char
name|byte_buf
index|[
name|INT_BUFSIZE_BOUND
argument_list|(
name|off_t
argument_list|)
index|]
decl_stmt|;
name|char
name|line_buf
index|[
name|INT_BUFSIZE_BOUND
argument_list|(
name|off_t
argument_list|)
index|]
decl_stmt|;
name|char
specifier|const
modifier|*
name|byte_num
init|=
name|offtostr
argument_list|(
name|byte_number
argument_list|,
name|byte_buf
argument_list|)
decl_stmt|;
name|char
specifier|const
modifier|*
name|line_num
init|=
name|offtostr
argument_list|(
name|line_number
argument_list|,
name|line_buf
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|opt_print_bytes
condition|)
block|{
comment|/* See POSIX 1003.1-2001 for this format.  This 		       message is used only in the POSIX locale, so it 		       need not be translated.  */
specifier|static
name|char
specifier|const
name|char_message
index|[]
init|=
literal|"%s %s differ: char %s, line %s\n"
decl_stmt|;
comment|/* The POSIX rationale recommends using the word 		       "byte" outside the POSIX locale.  Some gettext 		       implementations translate even in the POSIX 		       locale if certain other environment variables 		       are set, so use "byte" if a translation is 		       available, or if outside the POSIX locale.  */
specifier|static
name|char
specifier|const
name|byte_msgid
index|[]
init|=
name|N_
argument_list|(
literal|"%s %s differ: byte %s, line %s\n"
argument_list|)
decl_stmt|;
name|char
specifier|const
modifier|*
name|byte_message
init|=
name|_
argument_list|(
name|byte_msgid
argument_list|)
decl_stmt|;
name|bool
name|use_byte_message
init|=
operator|(
name|byte_message
operator|!=
name|byte_msgid
operator|||
name|hard_locale_LC_MESSAGES
operator|)
decl_stmt|;
name|printf
argument_list|(
name|use_byte_message
condition|?
name|byte_message
else|:
name|char_message
argument_list|,
name|file
index|[
literal|0
index|]
argument_list|,
name|file
index|[
literal|1
index|]
argument_list|,
name|byte_num
argument_list|,
name|line_num
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|char
name|c0
init|=
name|buf0
index|[
name|first_diff
index|]
decl_stmt|;
name|unsigned
name|char
name|c1
init|=
name|buf1
index|[
name|first_diff
index|]
decl_stmt|;
name|char
name|s0
index|[
literal|5
index|]
decl_stmt|;
name|char
name|s1
index|[
literal|5
index|]
decl_stmt|;
name|sprintc
argument_list|(
name|s0
argument_list|,
name|c0
argument_list|)
expr_stmt|;
name|sprintc
argument_list|(
name|s1
argument_list|,
name|c1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"%s %s differ: byte %s, line %s is %3o %s %3o %s\n"
argument_list|)
argument_list|,
name|file
index|[
literal|0
index|]
argument_list|,
name|file
index|[
literal|1
index|]
argument_list|,
name|byte_num
argument_list|,
name|line_num
argument_list|,
name|c0
argument_list|,
name|s0
argument_list|,
name|c1
argument_list|,
name|s1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Fall through.  */
case|case
name|type_status
case|:
return|return
name|EXIT_FAILURE
return|;
case|case
name|type_all_diffs
case|:
do|do
block|{
name|unsigned
name|char
name|c0
init|=
name|buf0
index|[
name|first_diff
index|]
decl_stmt|;
name|unsigned
name|char
name|c1
init|=
name|buf1
index|[
name|first_diff
index|]
decl_stmt|;
if|if
condition|(
name|c0
operator|!=
name|c1
condition|)
block|{
name|char
name|byte_buf
index|[
name|INT_BUFSIZE_BOUND
argument_list|(
name|off_t
argument_list|)
index|]
decl_stmt|;
name|char
specifier|const
modifier|*
name|byte_num
init|=
name|offtostr
argument_list|(
name|byte_number
argument_list|,
name|byte_buf
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|opt_print_bytes
condition|)
block|{
comment|/* See POSIX 1003.1-2001 for this format.  */
name|printf
argument_list|(
literal|"%*s %3o %3o\n"
argument_list|,
name|offset_width
argument_list|,
name|byte_num
argument_list|,
name|c0
argument_list|,
name|c1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|s0
index|[
literal|5
index|]
decl_stmt|;
name|char
name|s1
index|[
literal|5
index|]
decl_stmt|;
name|sprintc
argument_list|(
name|s0
argument_list|,
name|c0
argument_list|)
expr_stmt|;
name|sprintc
argument_list|(
name|s1
argument_list|,
name|c1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*s %3o %-4s %3o %s\n"
argument_list|,
name|offset_width
argument_list|,
name|byte_num
argument_list|,
name|c0
argument_list|,
name|s0
argument_list|,
name|c1
argument_list|,
name|s1
argument_list|)
expr_stmt|;
block|}
block|}
name|byte_number
operator|++
expr_stmt|;
name|first_diff
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|first_diff
operator|<
name|smaller
condition|)
do|;
name|ret
operator|=
name|EXIT_FAILURE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|read0
operator|!=
name|read1
condition|)
block|{
if|if
condition|(
name|comparison_type
operator|!=
name|type_status
condition|)
block|{
comment|/* See POSIX 1003.1-2001 for this format.  */
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"cmp: EOF on %s\n"
argument_list|)
argument_list|,
name|file
index|[
name|read1
operator|<
name|read0
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|EXIT_FAILURE
return|;
block|}
block|}
do|while
condition|(
name|read0
operator|==
name|buf_size
condition|)
do|;
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compare two blocks of memory P0 and P1 until they differ,    and count the number of '\n' occurrences in the common    part of P0 and P1.    If the blocks are not guaranteed to be different, put sentinels at the ends    of the blocks before calling this function.     Return the offset of the first byte that differs.    Increment *COUNT by the count of '\n' occurrences.  */
end_comment

begin_function
specifier|static
name|size_t
name|block_compare_and_count
parameter_list|(
name|word
specifier|const
modifier|*
name|p0
parameter_list|,
name|word
specifier|const
modifier|*
name|p1
parameter_list|,
name|off_t
modifier|*
name|count
parameter_list|)
block|{
name|word
name|l
decl_stmt|;
comment|/* One word from first buffer. */
name|word
specifier|const
modifier|*
name|l0
decl_stmt|,
modifier|*
name|l1
decl_stmt|;
comment|/* Pointers into each buffer. */
name|char
specifier|const
modifier|*
name|c0
decl_stmt|,
modifier|*
name|c1
decl_stmt|;
comment|/* Pointers for finding exact address. */
name|size_t
name|cnt
init|=
literal|0
decl_stmt|;
comment|/* Number of '\n' occurrences. */
name|word
name|nnnn
decl_stmt|;
comment|/* Newline, sizeof (word) times.  */
name|int
name|i
decl_stmt|;
name|nnnn
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|nnnn
condition|;
name|i
operator|++
control|)
name|nnnn
operator|=
operator|(
name|nnnn
operator|<<
name|CHAR_BIT
operator|)
operator||
literal|'\n'
expr_stmt|;
comment|/* Find the rough position of the first difference by reading words,      not bytes.  */
for|for
control|(
name|l0
operator|=
name|p0
operator|,
name|l1
operator|=
name|p1
init|;
operator|(
name|l
operator|=
operator|*
name|l0
operator|)
operator|==
operator|*
name|l1
condition|;
name|l0
operator|++
operator|,
name|l1
operator|++
control|)
block|{
name|l
operator|^=
name|nnnn
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|l
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|char
name|uc
init|=
name|l
decl_stmt|;
name|cnt
operator|+=
operator|!
name|uc
expr_stmt|;
name|l
operator|>>=
name|CHAR_BIT
expr_stmt|;
block|}
block|}
comment|/* Find the exact differing position (endianness independent).  */
for|for
control|(
name|c0
operator|=
operator|(
name|char
specifier|const
operator|*
operator|)
name|l0
operator|,
name|c1
operator|=
operator|(
name|char
specifier|const
operator|*
operator|)
name|l1
init|;
operator|*
name|c0
operator|==
operator|*
name|c1
condition|;
name|c0
operator|++
operator|,
name|c1
operator|++
control|)
name|cnt
operator|+=
operator|*
name|c0
operator|==
literal|'\n'
expr_stmt|;
operator|*
name|count
operator|+=
name|cnt
expr_stmt|;
return|return
name|c0
operator|-
operator|(
name|char
specifier|const
operator|*
operator|)
name|p0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compare two blocks of memory P0 and P1 until they differ.    If the blocks are not guaranteed to be different, put sentinels at the ends    of the blocks before calling this function.     Return the offset of the first byte that differs.  */
end_comment

begin_function
specifier|static
name|size_t
name|block_compare
parameter_list|(
name|word
specifier|const
modifier|*
name|p0
parameter_list|,
name|word
specifier|const
modifier|*
name|p1
parameter_list|)
block|{
name|word
specifier|const
modifier|*
name|l0
decl_stmt|,
modifier|*
name|l1
decl_stmt|;
name|char
specifier|const
modifier|*
name|c0
decl_stmt|,
modifier|*
name|c1
decl_stmt|;
comment|/* Find the rough position of the first difference by reading words,      not bytes.  */
for|for
control|(
name|l0
operator|=
name|p0
operator|,
name|l1
operator|=
name|p1
init|;
operator|*
name|l0
operator|==
operator|*
name|l1
condition|;
name|l0
operator|++
operator|,
name|l1
operator|++
control|)
continue|continue;
comment|/* Find the exact differing position (endianness independent).  */
for|for
control|(
name|c0
operator|=
operator|(
name|char
specifier|const
operator|*
operator|)
name|l0
operator|,
name|c1
operator|=
operator|(
name|char
specifier|const
operator|*
operator|)
name|l1
init|;
operator|*
name|c0
operator|==
operator|*
name|c1
condition|;
name|c0
operator|++
operator|,
name|c1
operator|++
control|)
continue|continue;
return|return
name|c0
operator|-
operator|(
name|char
specifier|const
operator|*
operator|)
name|p0
return|;
block|}
end_function

begin_comment
comment|/* Put into BUF the unsigned char C, making unprintable bytes    visible by quoting like cat -t does.  */
end_comment

begin_function
specifier|static
name|void
name|sprintc
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|char
name|c
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|>=
literal|128
condition|)
block|{
operator|*
name|buf
operator|++
operator|=
literal|'M'
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
literal|'-'
expr_stmt|;
name|c
operator|-=
literal|128
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|<
literal|32
condition|)
block|{
operator|*
name|buf
operator|++
operator|=
literal|'^'
expr_stmt|;
name|c
operator|+=
literal|64
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|127
condition|)
block|{
operator|*
name|buf
operator|++
operator|=
literal|'^'
expr_stmt|;
name|c
operator|=
literal|'?'
expr_stmt|;
block|}
block|}
operator|*
name|buf
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|buf
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Position file F to ignore_initial[F] bytes from its initial position,    and yield its new position.  Don't try more than once.  */
end_comment

begin_function
specifier|static
name|off_t
name|file_position
parameter_list|(
name|int
name|f
parameter_list|)
block|{
specifier|static
name|bool
name|positioned
index|[
literal|2
index|]
decl_stmt|;
specifier|static
name|off_t
name|position
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|positioned
index|[
name|f
index|]
condition|)
block|{
name|positioned
index|[
name|f
index|]
operator|=
name|true
expr_stmt|;
name|position
index|[
name|f
index|]
operator|=
name|lseek
argument_list|(
name|file_desc
index|[
name|f
index|]
argument_list|,
name|ignore_initial
index|[
name|f
index|]
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
block|}
return|return
name|position
index|[
name|f
index|]
return|;
block|}
end_function

end_unit

