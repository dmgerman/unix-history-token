begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* sdiff - side-by-side merge of file differences     Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 2001, 2002, 2004    Free Software Foundation, Inc.     This file is part of GNU DIFF.     GNU DIFF is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GNU DIFF is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.    See the GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; see the file COPYING.    If not, write to the Free Software Foundation,    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"paths.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<unlocked-io.h>
end_include

begin_include
include|#
directive|include
file|<c-stack.h>
end_include

begin_include
include|#
directive|include
file|<dirname.h>
end_include

begin_include
include|#
directive|include
file|<error.h>
end_include

begin_include
include|#
directive|include
file|<exit.h>
end_include

begin_include
include|#
directive|include
file|<exitfail.h>
end_include

begin_include
include|#
directive|include
file|<file-type.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<quotesys.h>
end_include

begin_include
include|#
directive|include
file|<version-etc.h>
end_include

begin_include
include|#
directive|include
file|<xalloc.h>
end_include

begin_comment
comment|/* Size of chunks read from files which must be parsed into lines.  */
end_comment

begin_define
define|#
directive|define
name|SDIFF_BUFSIZE
value|((size_t) 65536)
end_define

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|editor_program
init|=
name|DEFAULT_EDITOR_PROGRAM
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
modifier|*
name|diffargv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
specifier|volatile
name|tmpname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|tmp
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|HAVE_WORKING_FORK
operator|||
name|HAVE_WORKING_VFORK
end_if

begin_decl_stmt
specifier|static
name|pid_t
specifier|volatile
name|diffpid
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_struct_decl
struct_decl|struct
name|line_filter
struct_decl|;
end_struct_decl

begin_function_decl
specifier|static
name|void
name|catchsig
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|edit
parameter_list|(
name|struct
name|line_filter
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|,
name|lin
parameter_list|,
name|lin
parameter_list|,
name|struct
name|line_filter
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|,
name|lin
parameter_list|,
name|lin
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|interact
parameter_list|(
name|struct
name|line_filter
modifier|*
parameter_list|,
name|struct
name|line_filter
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|,
name|struct
name|line_filter
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|checksigs
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|diffarg
parameter_list|(
name|char
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fatal
parameter_list|(
name|char
specifier|const
modifier|*
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(noreturn
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|void
name|perror_fatal
parameter_list|(
name|char
specifier|const
modifier|*
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(noreturn
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|void
name|trapsigs
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|untrapsig
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|NUM_SIGS
value|(sizeof sigs / sizeof *sigs)
end_define

begin_decl_stmt
specifier|static
name|int
specifier|const
name|sigs
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|SIGHUP
name|SIGHUP
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGQUIT
name|SIGQUIT
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTERM
name|SIGTERM
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGXCPU
name|SIGXCPU
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGXFSZ
name|SIGXFSZ
block|,
endif|#
directive|endif
name|SIGINT
block|,
name|SIGPIPE
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|handler_index_of_SIGINT
value|(NUM_SIGS - 2)
end_define

begin_define
define|#
directive|define
name|handler_index_of_SIGPIPE
value|(NUM_SIGS - 1)
end_define

begin_if
if|#
directive|if
name|HAVE_SIGACTION
end_if

begin_comment
comment|/* Prefer `sigaction' if available, since `signal' can lose signals.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sigaction
name|initial_action
index|[
name|NUM_SIGS
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|initial_handler
parameter_list|(
name|i
parameter_list|)
value|(initial_action[i].sa_handler)
end_define

begin_function_decl
specifier|static
name|void
name|signal_handler
parameter_list|(
name|int
parameter_list|,
name|void
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|int
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|initial_action
index|[
name|NUM_SIGS
index|]
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|initial_handler
parameter_list|(
name|i
parameter_list|)
value|(initial_action[i])
end_define

begin_define
define|#
directive|define
name|signal_handler
parameter_list|(
name|sig
parameter_list|,
name|handler
parameter_list|)
value|signal (sig, handler)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|HAVE_SIGPROCMASK
end_if

begin_define
define|#
directive|define
name|sigset_t
value|int
end_define

begin_define
define|#
directive|define
name|sigemptyset
parameter_list|(
name|s
parameter_list|)
value|(*(s) = 0)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|sigmask
end_ifndef

begin_define
define|#
directive|define
name|sigmask
parameter_list|(
name|sig
parameter_list|)
value|(1<< ((sig) - 1))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|sigaddset
parameter_list|(
name|s
parameter_list|,
name|sig
parameter_list|)
value|(*(s) |= sigmask (sig))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|SIG_BLOCK
end_ifndef

begin_define
define|#
directive|define
name|SIG_BLOCK
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SIG_SETMASK
end_ifndef

begin_define
define|#
directive|define
name|SIG_SETMASK
value|(! SIG_BLOCK)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|sigprocmask
parameter_list|(
name|how
parameter_list|,
name|n
parameter_list|,
name|o
parameter_list|)
define|\
value|((how) == SIG_BLOCK ? *(o) = sigblock (*(n)) : sigsetmask (*(n)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|bool
name|diraccess
parameter_list|(
name|char
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|temporary_file
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Options: */
end_comment

begin_comment
comment|/* Name of output file if -o specified.  */
end_comment

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|output
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Do not print common lines.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|suppress_common_lines
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Value for the long option that does not have single-letter equivalents.  */
end_comment

begin_enum
enum|enum
block|{
name|DIFF_PROGRAM_OPTION
init|=
name|CHAR_MAX
operator|+
literal|1
block|,
name|HELP_OPTION
block|,
name|STRIP_TRAILING_CR_OPTION
block|,
name|TABSIZE_OPTION
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|struct
name|option
specifier|const
name|longopts
index|[]
init|=
block|{
block|{
literal|"diff-program"
block|,
literal|1
block|,
literal|0
block|,
name|DIFF_PROGRAM_OPTION
block|}
block|,
block|{
literal|"expand-tabs"
block|,
literal|0
block|,
literal|0
block|,
literal|'t'
block|}
block|,
block|{
literal|"help"
block|,
literal|0
block|,
literal|0
block|,
name|HELP_OPTION
block|}
block|,
block|{
literal|"ignore-all-space"
block|,
literal|0
block|,
literal|0
block|,
literal|'W'
block|}
block|,
comment|/* swap W and w for historical reasons */
block|{
literal|"ignore-blank-lines"
block|,
literal|0
block|,
literal|0
block|,
literal|'B'
block|}
block|,
block|{
literal|"ignore-case"
block|,
literal|0
block|,
literal|0
block|,
literal|'i'
block|}
block|,
block|{
literal|"ignore-matching-lines"
block|,
literal|1
block|,
literal|0
block|,
literal|'I'
block|}
block|,
block|{
literal|"ignore-space-change"
block|,
literal|0
block|,
literal|0
block|,
literal|'b'
block|}
block|,
block|{
literal|"ignore-tab-expansion"
block|,
literal|0
block|,
literal|0
block|,
literal|'E'
block|}
block|,
block|{
literal|"left-column"
block|,
literal|0
block|,
literal|0
block|,
literal|'l'
block|}
block|,
block|{
literal|"minimal"
block|,
literal|0
block|,
literal|0
block|,
literal|'d'
block|}
block|,
block|{
literal|"output"
block|,
literal|1
block|,
literal|0
block|,
literal|'o'
block|}
block|,
block|{
literal|"speed-large-files"
block|,
literal|0
block|,
literal|0
block|,
literal|'H'
block|}
block|,
block|{
literal|"strip-trailing-cr"
block|,
literal|0
block|,
literal|0
block|,
name|STRIP_TRAILING_CR_OPTION
block|}
block|,
block|{
literal|"suppress-common-lines"
block|,
literal|0
block|,
literal|0
block|,
literal|'s'
block|}
block|,
block|{
literal|"tabsize"
block|,
literal|1
block|,
literal|0
block|,
name|TABSIZE_OPTION
block|}
block|,
block|{
literal|"text"
block|,
literal|0
block|,
literal|0
block|,
literal|'a'
block|}
block|,
block|{
literal|"version"
block|,
literal|0
block|,
literal|0
block|,
literal|'v'
block|}
block|,
block|{
literal|"width"
block|,
literal|1
block|,
literal|0
block|,
literal|'w'
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|try_help
parameter_list|(
name|char
specifier|const
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(noreturn
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_function
specifier|static
name|void
name|try_help
parameter_list|(
name|char
specifier|const
modifier|*
name|reason_msgid
parameter_list|,
name|char
specifier|const
modifier|*
name|operand
parameter_list|)
block|{
if|if
condition|(
name|reason_msgid
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
name|reason_msgid
argument_list|)
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|EXIT_TROUBLE
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Try `%s --help' for more information."
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_stdout
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"write failed"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fclose
argument_list|(
name|stdout
argument_list|)
operator|!=
literal|0
condition|)
name|perror_fatal
argument_list|(
name|_
argument_list|(
literal|"standard output"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
specifier|const
name|option_help_msgid
index|[]
init|=
block|{
name|N_
argument_list|(
literal|"-o FILE  --output=FILE  Operate interactively, sending output to FILE."
argument_list|)
block|,
literal|""
block|,
name|N_
argument_list|(
literal|"-i  --ignore-case  Consider upper- and lower-case to be the same."
argument_list|)
block|,
name|N_
argument_list|(
literal|"-E  --ignore-tab-expansion  Ignore changes due to tab expansion."
argument_list|)
block|,
name|N_
argument_list|(
literal|"-b  --ignore-space-change  Ignore changes in the amount of white space."
argument_list|)
block|,
name|N_
argument_list|(
literal|"-W  --ignore-all-space  Ignore all white space."
argument_list|)
block|,
name|N_
argument_list|(
literal|"-B  --ignore-blank-lines  Ignore changes whose lines are all blank."
argument_list|)
block|,
name|N_
argument_list|(
literal|"-I RE  --ignore-matching-lines=RE  Ignore changes whose lines all match RE."
argument_list|)
block|,
name|N_
argument_list|(
literal|"--strip-trailing-cr  Strip trailing carriage return on input."
argument_list|)
block|,
name|N_
argument_list|(
literal|"-a  --text  Treat all files as text."
argument_list|)
block|,
literal|""
block|,
name|N_
argument_list|(
literal|"-w NUM  --width=NUM  Output at most NUM (default 130) print columns."
argument_list|)
block|,
name|N_
argument_list|(
literal|"-l  --left-column  Output only the left column of common lines."
argument_list|)
block|,
name|N_
argument_list|(
literal|"-s  --suppress-common-lines  Do not output common lines."
argument_list|)
block|,
literal|""
block|,
name|N_
argument_list|(
literal|"-t  --expand-tabs  Expand tabs to spaces in output."
argument_list|)
block|,
name|N_
argument_list|(
literal|"--tabsize=NUM  Tab stops are every NUM (default 8) print columns."
argument_list|)
block|,
literal|""
block|,
name|N_
argument_list|(
literal|"-d  --minimal  Try hard to find a smaller set of changes."
argument_list|)
block|,
name|N_
argument_list|(
literal|"-H  --speed-large-files  Assume large files and many scattered small changes."
argument_list|)
block|,
name|N_
argument_list|(
literal|"--diff-program=PROGRAM  Use PROGRAM to compare files."
argument_list|)
block|,
literal|""
block|,
name|N_
argument_list|(
literal|"-v  --version  Output version info."
argument_list|)
block|,
name|N_
argument_list|(
literal|"--help  Output this help."
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|p
decl_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"Usage: %s [OPTION]... FILE1 FILE2\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n\n"
argument_list|,
name|_
argument_list|(
literal|"Side-by-side merge of file differences."
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|option_help_msgid
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
operator|*
name|p
condition|)
name|printf
argument_list|(
literal|"  %s\n"
argument_list|,
name|_
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n%s\n%s\n\n%s\n"
argument_list|,
name|_
argument_list|(
literal|"If a FILE is `-', read standard input."
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Report bugs to<bug-gnu-utils@gnu.org>."
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clean up after a signal or other failure.  This function is    async-signal-safe.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|cleanup
argument_list|(
name|int
name|signo
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
argument_list|)
block|{
if|#
directive|if
name|HAVE_WORKING_FORK
operator|||
name|HAVE_WORKING_VFORK
if|if
condition|(
literal|0
operator|<
name|diffpid
condition|)
name|kill
argument_list|(
name|diffpid
argument_list|,
name|SIGPIPE
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tmpname
condition|)
name|unlink
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|exiterr
parameter_list|(
name|void
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(noreturn
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_function
specifier|static
name|void
name|exiterr
parameter_list|(
name|void
parameter_list|)
block|{
name|cleanup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|untrapsig
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|checksigs
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|EXIT_TROUBLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fatal
parameter_list|(
name|char
specifier|const
modifier|*
name|msgid
parameter_list|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s"
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|)
expr_stmt|;
name|exiterr
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|perror_fatal
parameter_list|(
name|char
specifier|const
modifier|*
name|msg
parameter_list|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|checksigs
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|e
argument_list|,
literal|"%s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|exiterr
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_child_status
parameter_list|(
name|int
name|werrno
parameter_list|,
name|int
name|wstatus
parameter_list|,
name|int
name|max_ok_status
parameter_list|,
name|char
specifier|const
modifier|*
name|subsidiary_program
parameter_list|)
block|{
name|int
name|status
init|=
operator|(
operator|!
name|werrno
operator|&&
name|WIFEXITED
argument_list|(
name|wstatus
argument_list|)
condition|?
name|WEXITSTATUS
argument_list|(
name|wstatus
argument_list|)
else|:
name|INT_MAX
operator|)
decl_stmt|;
if|if
condition|(
name|max_ok_status
operator|<
name|status
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|werrno
argument_list|,
name|_
argument_list|(
name|status
operator|==
literal|126
condition|?
literal|"subsidiary program `%s' could not be invoked"
else|:
name|status
operator|==
literal|127
condition|?
literal|"subsidiary program `%s' not found"
else|:
name|status
operator|==
name|INT_MAX
condition|?
literal|"subsidiary program `%s' failed"
else|:
literal|"subsidiary program `%s' failed (exit status %d)"
argument_list|)
argument_list|,
name|subsidiary_program
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|exiterr
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|FILE
modifier|*
name|ck_fopen
parameter_list|(
name|char
specifier|const
modifier|*
name|fname
parameter_list|,
name|char
specifier|const
modifier|*
name|type
parameter_list|)
block|{
name|FILE
modifier|*
name|r
init|=
name|fopen
argument_list|(
name|fname
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
name|perror_fatal
argument_list|(
name|fname
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ck_fclose
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
condition|)
name|perror_fatal
argument_list|(
literal|"fclose"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|ck_fread
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|size_t
name|r
init|=
name|fread
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|size
argument_list|,
name|f
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
operator|&&
name|ferror
argument_list|(
name|f
argument_list|)
condition|)
name|perror_fatal
argument_list|(
name|_
argument_list|(
literal|"read failed"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ck_fwrite
parameter_list|(
name|char
specifier|const
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|FILE
modifier|*
name|f
parameter_list|)
block|{
if|if
condition|(
name|fwrite
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|size
argument_list|,
name|f
argument_list|)
operator|!=
name|size
condition|)
name|perror_fatal
argument_list|(
name|_
argument_list|(
literal|"write failed"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ck_fflush
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
if|if
condition|(
name|fflush
argument_list|(
name|f
argument_list|)
operator|!=
literal|0
condition|)
name|perror_fatal
argument_list|(
name|_
argument_list|(
literal|"write failed"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
specifier|const
modifier|*
name|expand_name
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|bool
name|is_dir
parameter_list|,
name|char
specifier|const
modifier|*
name|other_name
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"cannot interactively merge standard input"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_dir
condition|)
return|return
name|name
return|;
else|else
block|{
comment|/* Yield NAME/BASE, where BASE is OTHER_NAME's basename.  */
name|char
specifier|const
modifier|*
name|base
init|=
name|base_name
argument_list|(
name|other_name
argument_list|)
decl_stmt|;
name|size_t
name|namelen
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|,
name|baselen
init|=
name|strlen
argument_list|(
name|base
argument_list|)
decl_stmt|;
name|bool
name|insert_slash
init|=
operator|*
name|base_name
argument_list|(
name|name
argument_list|)
operator|&&
name|name
index|[
name|namelen
operator|-
literal|1
index|]
operator|!=
literal|'/'
decl_stmt|;
name|char
modifier|*
name|r
init|=
name|xmalloc
argument_list|(
name|namelen
operator|+
name|insert_slash
operator|+
name|baselen
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|r
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|r
index|[
name|namelen
index|]
operator|=
literal|'/'
expr_stmt|;
name|memcpy
argument_list|(
name|r
operator|+
name|namelen
operator|+
name|insert_slash
argument_list|,
name|base
argument_list|,
name|baselen
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|line_filter
block|{
name|FILE
modifier|*
name|infile
decl_stmt|;
name|char
modifier|*
name|bufpos
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|char
modifier|*
name|buflim
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|lf_init
parameter_list|(
name|struct
name|line_filter
modifier|*
name|lf
parameter_list|,
name|FILE
modifier|*
name|infile
parameter_list|)
block|{
name|lf
operator|->
name|infile
operator|=
name|infile
expr_stmt|;
name|lf
operator|->
name|bufpos
operator|=
name|lf
operator|->
name|buffer
operator|=
name|lf
operator|->
name|buflim
operator|=
name|xmalloc
argument_list|(
name|SDIFF_BUFSIZE
operator|+
literal|1
argument_list|)
expr_stmt|;
name|lf
operator|->
name|buflim
index|[
literal|0
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fill an exhausted line_filter buffer from its INFILE */
end_comment

begin_function
specifier|static
name|size_t
name|lf_refill
parameter_list|(
name|struct
name|line_filter
modifier|*
name|lf
parameter_list|)
block|{
name|size_t
name|s
init|=
name|ck_fread
argument_list|(
name|lf
operator|->
name|buffer
argument_list|,
name|SDIFF_BUFSIZE
argument_list|,
name|lf
operator|->
name|infile
argument_list|)
decl_stmt|;
name|lf
operator|->
name|bufpos
operator|=
name|lf
operator|->
name|buffer
expr_stmt|;
name|lf
operator|->
name|buflim
operator|=
name|lf
operator|->
name|buffer
operator|+
name|s
expr_stmt|;
name|lf
operator|->
name|buflim
index|[
literal|0
index|]
operator|=
literal|'\n'
expr_stmt|;
name|checksigs
argument_list|()
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Advance LINES on LF's infile, copying lines to OUTFILE */
end_comment

begin_function
specifier|static
name|void
name|lf_copy
parameter_list|(
name|struct
name|line_filter
modifier|*
name|lf
parameter_list|,
name|lin
name|lines
parameter_list|,
name|FILE
modifier|*
name|outfile
parameter_list|)
block|{
name|char
modifier|*
name|start
init|=
name|lf
operator|->
name|bufpos
decl_stmt|;
while|while
condition|(
name|lines
condition|)
block|{
name|lf
operator|->
name|bufpos
operator|=
operator|(
name|char
operator|*
operator|)
name|memchr
argument_list|(
name|lf
operator|->
name|bufpos
argument_list|,
literal|'\n'
argument_list|,
name|lf
operator|->
name|buflim
operator|-
name|lf
operator|->
name|bufpos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lf
operator|->
name|bufpos
condition|)
block|{
name|ck_fwrite
argument_list|(
name|start
argument_list|,
name|lf
operator|->
name|buflim
operator|-
name|start
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lf_refill
argument_list|(
name|lf
argument_list|)
condition|)
return|return;
name|start
operator|=
name|lf
operator|->
name|bufpos
expr_stmt|;
block|}
else|else
block|{
operator|--
name|lines
expr_stmt|;
operator|++
name|lf
operator|->
name|bufpos
expr_stmt|;
block|}
block|}
name|ck_fwrite
argument_list|(
name|start
argument_list|,
name|lf
operator|->
name|bufpos
operator|-
name|start
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Advance LINES on LF's infile without doing output */
end_comment

begin_function
specifier|static
name|void
name|lf_skip
parameter_list|(
name|struct
name|line_filter
modifier|*
name|lf
parameter_list|,
name|lin
name|lines
parameter_list|)
block|{
while|while
condition|(
name|lines
condition|)
block|{
name|lf
operator|->
name|bufpos
operator|=
operator|(
name|char
operator|*
operator|)
name|memchr
argument_list|(
name|lf
operator|->
name|bufpos
argument_list|,
literal|'\n'
argument_list|,
name|lf
operator|->
name|buflim
operator|-
name|lf
operator|->
name|bufpos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lf
operator|->
name|bufpos
condition|)
block|{
if|if
condition|(
operator|!
name|lf_refill
argument_list|(
name|lf
argument_list|)
condition|)
break|break;
block|}
else|else
block|{
operator|--
name|lines
expr_stmt|;
operator|++
name|lf
operator|->
name|bufpos
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Snarf a line into a buffer.  Return EOF if EOF, 0 if error, 1 if OK.  */
end_comment

begin_function
specifier|static
name|int
name|lf_snarf
parameter_list|(
name|struct
name|line_filter
modifier|*
name|lf
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
name|bufsize
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
modifier|*
name|start
init|=
name|lf
operator|->
name|bufpos
decl_stmt|;
name|char
modifier|*
name|next
init|=
operator|(
name|char
operator|*
operator|)
name|memchr
argument_list|(
name|start
argument_list|,
literal|'\n'
argument_list|,
name|lf
operator|->
name|buflim
operator|+
literal|1
operator|-
name|start
argument_list|)
decl_stmt|;
name|size_t
name|s
init|=
name|next
operator|-
name|start
decl_stmt|;
if|if
condition|(
name|bufsize
operator|<=
name|s
condition|)
return|return
literal|0
return|;
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|start
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|<
name|lf
operator|->
name|buflim
condition|)
block|{
name|buffer
index|[
name|s
index|]
operator|=
literal|0
expr_stmt|;
name|lf
operator|->
name|bufpos
operator|=
name|next
operator|+
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|lf_refill
argument_list|(
name|lf
argument_list|)
condition|)
return|return
name|s
condition|?
literal|0
else|:
name|EOF
return|;
name|buffer
operator|+=
name|s
expr_stmt|;
name|bufsize
operator|-=
name|s
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|opt
decl_stmt|;
name|char
specifier|const
modifier|*
name|prog
decl_stmt|;
name|exit_failure
operator|=
name|EXIT_TROUBLE
expr_stmt|;
name|initialize_main
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|bindtextdomain
argument_list|(
name|PACKAGE
argument_list|,
name|LOCALEDIR
argument_list|)
expr_stmt|;
name|textdomain
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
name|c_stack_action
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
name|prog
operator|=
name|getenv
argument_list|(
literal|"EDITOR"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prog
condition|)
name|editor_program
operator|=
name|prog
expr_stmt|;
name|diffarg
argument_list|(
name|DEFAULT_DIFF_PROGRAM
argument_list|)
expr_stmt|;
comment|/* parse command line args */
while|while
condition|(
operator|(
name|opt
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"abBdEHiI:lo:stvw:W"
argument_list|,
name|longopts
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'a'
case|:
name|diffarg
argument_list|(
literal|"-a"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|diffarg
argument_list|(
literal|"-b"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|diffarg
argument_list|(
literal|"-B"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|diffarg
argument_list|(
literal|"-d"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|diffarg
argument_list|(
literal|"-E"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|diffarg
argument_list|(
literal|"-H"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|diffarg
argument_list|(
literal|"-i"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|diffarg
argument_list|(
literal|"-I"
argument_list|)
expr_stmt|;
name|diffarg
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|diffarg
argument_list|(
literal|"--left-column"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|output
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|suppress_common_lines
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|diffarg
argument_list|(
literal|"-t"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|version_etc
argument_list|(
name|stdout
argument_list|,
literal|"sdiff"
argument_list|,
name|PACKAGE_NAME
argument_list|,
name|PACKAGE_VERSION
argument_list|,
literal|"Thomas Lord"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|check_stdout
argument_list|()
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
case|case
literal|'w'
case|:
name|diffarg
argument_list|(
literal|"-W"
argument_list|)
expr_stmt|;
name|diffarg
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|diffarg
argument_list|(
literal|"-w"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIFF_PROGRAM_OPTION
case|:
name|diffargv
index|[
literal|0
index|]
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
name|HELP_OPTION
case|:
name|usage
argument_list|()
expr_stmt|;
name|check_stdout
argument_list|()
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
case|case
name|STRIP_TRAILING_CR_OPTION
case|:
name|diffarg
argument_list|(
literal|"--strip-trailing-cr"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TABSIZE_OPTION
case|:
name|diffarg
argument_list|(
literal|"--tabsize"
argument_list|)
expr_stmt|;
name|diffarg
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|try_help
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|argc
operator|-
name|optind
operator|!=
literal|2
condition|)
block|{
if|if
condition|(
name|argc
operator|-
name|optind
operator|<
literal|2
condition|)
name|try_help
argument_list|(
literal|"missing operand after `%s'"
argument_list|,
name|argv
index|[
name|argc
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|try_help
argument_list|(
literal|"extra operand `%s'"
argument_list|,
name|argv
index|[
name|optind
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|output
condition|)
block|{
comment|/* easy case: diff does everything for us */
if|if
condition|(
name|suppress_common_lines
condition|)
name|diffarg
argument_list|(
literal|"--suppress-common-lines"
argument_list|)
expr_stmt|;
name|diffarg
argument_list|(
literal|"-y"
argument_list|)
expr_stmt|;
name|diffarg
argument_list|(
literal|"--"
argument_list|)
expr_stmt|;
name|diffarg
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
name|diffarg
argument_list|(
name|argv
index|[
name|optind
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|diffarg
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|execvp
argument_list|(
name|diffargv
index|[
literal|0
index|]
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|diffargv
argument_list|)
expr_stmt|;
name|perror_fatal
argument_list|(
name|diffargv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
specifier|const
modifier|*
name|lname
decl_stmt|,
modifier|*
name|rname
decl_stmt|;
name|FILE
modifier|*
name|left
decl_stmt|,
modifier|*
name|right
decl_stmt|,
modifier|*
name|out
decl_stmt|,
modifier|*
name|diffout
decl_stmt|;
name|bool
name|interact_ok
decl_stmt|;
name|struct
name|line_filter
name|lfilt
decl_stmt|;
name|struct
name|line_filter
name|rfilt
decl_stmt|;
name|struct
name|line_filter
name|diff_filt
decl_stmt|;
name|bool
name|leftdir
init|=
name|diraccess
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
decl_stmt|;
name|bool
name|rightdir
init|=
name|diraccess
argument_list|(
name|argv
index|[
name|optind
operator|+
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|leftdir
operator|&
name|rightdir
condition|)
name|fatal
argument_list|(
literal|"both files to be compared are directories"
argument_list|)
expr_stmt|;
name|lname
operator|=
name|expand_name
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
name|leftdir
argument_list|,
name|argv
index|[
name|optind
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|left
operator|=
name|ck_fopen
argument_list|(
name|lname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|rname
operator|=
name|expand_name
argument_list|(
name|argv
index|[
name|optind
operator|+
literal|1
index|]
argument_list|,
name|rightdir
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
name|right
operator|=
name|ck_fopen
argument_list|(
name|rname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|out
operator|=
name|ck_fopen
argument_list|(
name|output
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|diffarg
argument_list|(
literal|"--sdiff-merge-assist"
argument_list|)
expr_stmt|;
name|diffarg
argument_list|(
literal|"--"
argument_list|)
expr_stmt|;
name|diffarg
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
name|diffarg
argument_list|(
name|argv
index|[
name|optind
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|diffarg
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|trapsigs
argument_list|()
expr_stmt|;
if|#
directive|if
operator|!
operator|(
name|HAVE_WORKING_FORK
operator|||
name|HAVE_WORKING_VFORK
operator|)
block|{
name|size_t
name|cmdsize
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|command
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|diffargv
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|cmdsize
operator|+=
name|quote_system_arg
argument_list|(
literal|0
argument_list|,
name|diffargv
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
name|command
operator|=
name|p
operator|=
name|xmalloc
argument_list|(
name|cmdsize
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|diffargv
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|+=
name|quote_system_arg
argument_list|(
name|p
argument_list|,
name|diffargv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
name|p
index|[
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|diffout
operator|=
name|popen
argument_list|(
name|command
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|diffout
condition|)
name|perror_fatal
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|command
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
block|{
name|int
name|diff_fds
index|[
literal|2
index|]
decl_stmt|;
if|#
directive|if
name|HAVE_WORKING_VFORK
name|sigset_t
name|procmask
decl_stmt|;
name|sigset_t
name|blocked
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pipe
argument_list|(
name|diff_fds
argument_list|)
operator|!=
literal|0
condition|)
name|perror_fatal
argument_list|(
literal|"pipe"
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_WORKING_VFORK
comment|/* Block SIGINT and SIGPIPE.  */
name|sigemptyset
argument_list|(
operator|&
name|blocked
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|blocked
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|blocked
argument_list|,
name|SIGPIPE
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|blocked
argument_list|,
operator|&
name|procmask
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|diffpid
operator|=
name|vfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|diffpid
operator|<
literal|0
condition|)
name|perror_fatal
argument_list|(
literal|"fork"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|diffpid
condition|)
block|{
comment|/* Alter the child's SIGINT and SIGPIPE handlers; 	       this may munge the parent. 	       The child ignores SIGINT in case the user interrupts the editor. 	       The child does not ignore SIGPIPE, even if the parent does.  */
if|if
condition|(
name|initial_handler
argument_list|(
name|handler_index_of_SIGINT
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal_handler
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal_handler
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_WORKING_VFORK
comment|/* Stop blocking SIGINT and SIGPIPE in the child.  */
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|procmask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|close
argument_list|(
name|diff_fds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff_fds
index|[
literal|1
index|]
operator|!=
name|STDOUT_FILENO
condition|)
block|{
name|dup2
argument_list|(
name|diff_fds
index|[
literal|1
index|]
argument_list|,
name|STDOUT_FILENO
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|diff_fds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|execvp
argument_list|(
name|diffargv
index|[
literal|0
index|]
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|diffargv
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|errno
operator|==
name|ENOENT
condition|?
literal|127
else|:
literal|126
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|HAVE_WORKING_VFORK
comment|/* Restore the parent's SIGINT and SIGPIPE behavior.  */
if|if
condition|(
name|initial_handler
argument_list|(
name|handler_index_of_SIGINT
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal_handler
argument_list|(
name|SIGINT
argument_list|,
name|catchsig
argument_list|)
expr_stmt|;
if|if
condition|(
name|initial_handler
argument_list|(
name|handler_index_of_SIGPIPE
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal_handler
argument_list|(
name|SIGPIPE
argument_list|,
name|catchsig
argument_list|)
expr_stmt|;
else|else
name|signal_handler
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* Stop blocking SIGINT and SIGPIPE in the parent.  */
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|procmask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|close
argument_list|(
name|diff_fds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|diffout
operator|=
name|fdopen
argument_list|(
name|diff_fds
index|[
literal|0
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|diffout
condition|)
name|perror_fatal
argument_list|(
literal|"fdopen"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|lf_init
argument_list|(
operator|&
name|diff_filt
argument_list|,
name|diffout
argument_list|)
expr_stmt|;
name|lf_init
argument_list|(
operator|&
name|lfilt
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|lf_init
argument_list|(
operator|&
name|rfilt
argument_list|,
name|right
argument_list|)
expr_stmt|;
name|interact_ok
operator|=
name|interact
argument_list|(
operator|&
name|diff_filt
argument_list|,
operator|&
name|lfilt
argument_list|,
name|lname
argument_list|,
operator|&
name|rfilt
argument_list|,
name|rname
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|ck_fclose
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|ck_fclose
argument_list|(
name|right
argument_list|)
expr_stmt|;
name|ck_fclose
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|{
name|int
name|wstatus
decl_stmt|;
name|int
name|werrno
init|=
literal|0
decl_stmt|;
if|#
directive|if
operator|!
operator|(
name|HAVE_WORKING_FORK
operator|||
name|HAVE_WORKING_VFORK
operator|)
name|wstatus
operator|=
name|pclose
argument_list|(
name|diffout
argument_list|)
expr_stmt|;
if|if
condition|(
name|wstatus
operator|==
operator|-
literal|1
condition|)
name|werrno
operator|=
name|errno
expr_stmt|;
else|#
directive|else
name|ck_fclose
argument_list|(
name|diffout
argument_list|)
expr_stmt|;
while|while
condition|(
name|waitpid
argument_list|(
name|diffpid
argument_list|,
operator|&
name|wstatus
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
name|checksigs
argument_list|()
expr_stmt|;
else|else
name|perror_fatal
argument_list|(
literal|"waitpid"
argument_list|)
expr_stmt|;
name|diffpid
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tmpname
condition|)
block|{
name|unlink
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
name|tmpname
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|interact_ok
condition|)
name|exiterr
argument_list|()
expr_stmt|;
name|check_child_status
argument_list|(
name|werrno
argument_list|,
name|wstatus
argument_list|,
name|EXIT_FAILURE
argument_list|,
name|diffargv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|untrapsig
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|checksigs
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|WEXITSTATUS
argument_list|(
name|wstatus
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|EXIT_SUCCESS
return|;
comment|/* Fool `-Wall'.  */
block|}
end_function

begin_function
specifier|static
name|void
name|diffarg
parameter_list|(
name|char
specifier|const
modifier|*
name|a
parameter_list|)
block|{
specifier|static
name|size_t
name|diffargs
decl_stmt|,
name|diffarglim
decl_stmt|;
if|if
condition|(
name|diffargs
operator|==
name|diffarglim
condition|)
block|{
if|if
condition|(
operator|!
name|diffarglim
condition|)
name|diffarglim
operator|=
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
name|PTRDIFF_MAX
operator|/
operator|(
literal|2
operator|*
sizeof|sizeof
expr|*
name|diffargv
operator|)
operator|<=
name|diffarglim
condition|)
name|xalloc_die
argument_list|()
expr_stmt|;
else|else
name|diffarglim
operator|*=
literal|2
expr_stmt|;
name|diffargv
operator|=
name|xrealloc
argument_list|(
name|diffargv
argument_list|,
name|diffarglim
operator|*
sizeof|sizeof
expr|*
name|diffargv
argument_list|)
expr_stmt|;
block|}
name|diffargv
index|[
name|diffargs
operator|++
index|]
operator|=
name|a
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Signal handling */
end_comment

begin_decl_stmt
specifier|static
name|bool
specifier|volatile
name|ignore_SIGINT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
specifier|volatile
name|signal_received
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|sigs_trapped
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|catchsig
parameter_list|(
name|int
name|s
parameter_list|)
block|{
if|#
directive|if
operator|!
name|HAVE_SIGACTION
name|signal
argument_list|(
name|s
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|s
operator|==
name|SIGINT
operator|&&
name|ignore_SIGINT
operator|)
condition|)
name|signal_received
operator|=
name|s
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|HAVE_SIGACTION
end_if

begin_decl_stmt
specifier|static
name|struct
name|sigaction
name|catchaction
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|signal_handler
parameter_list|(
name|int
name|sig
parameter_list|,
name|void
function_decl|(
modifier|*
name|handler
function_decl|)
parameter_list|(
name|int
parameter_list|)
parameter_list|)
block|{
name|catchaction
operator|.
name|sa_handler
operator|=
name|handler
expr_stmt|;
name|sigaction
argument_list|(
name|sig
argument_list|,
operator|&
name|catchaction
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|trapsigs
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|#
directive|if
name|HAVE_SIGACTION
name|catchaction
operator|.
name|sa_flags
operator|=
name|SA_RESTART
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|catchaction
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_SIGS
condition|;
name|i
operator|++
control|)
name|sigaddset
argument_list|(
operator|&
name|catchaction
operator|.
name|sa_mask
argument_list|,
name|sigs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_SIGS
condition|;
name|i
operator|++
control|)
block|{
if|#
directive|if
name|HAVE_SIGACTION
name|sigaction
argument_list|(
name|sigs
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
operator|&
name|initial_action
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|initial_action
index|[
name|i
index|]
operator|=
name|signal
argument_list|(
name|sigs
index|[
name|i
index|]
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|initial_handler
argument_list|(
name|i
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal_handler
argument_list|(
name|sigs
index|[
name|i
index|]
argument_list|,
name|catchsig
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SIGCHLD
comment|/* System V fork+wait does not work if SIGCHLD is ignored.  */
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sigs_trapped
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Untrap signal S, or all trapped signals if S is zero.  */
end_comment

begin_function
specifier|static
name|void
name|untrapsig
parameter_list|(
name|int
name|s
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sigs_trapped
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_SIGS
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|!
name|s
operator|||
name|sigs
index|[
name|i
index|]
operator|==
name|s
operator|)
operator|&&
name|initial_handler
argument_list|(
name|i
argument_list|)
operator|!=
name|SIG_IGN
condition|)
block|{
if|#
directive|if
name|HAVE_SIGACTION
name|sigaction
argument_list|(
name|sigs
index|[
name|i
index|]
argument_list|,
operator|&
name|initial_action
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|signal
argument_list|(
name|sigs
index|[
name|i
index|]
argument_list|,
name|initial_action
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Exit if a signal has been received.  */
end_comment

begin_function
specifier|static
name|void
name|checksigs
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|s
init|=
name|signal_received
decl_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|cleanup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Yield an exit status indicating that a signal was received.  */
name|untrapsig
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* That didn't work, so exit with error status.  */
name|exit
argument_list|(
name|EXIT_TROUBLE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|give_help
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|_
argument_list|(
literal|"\ ed:\tEdit then use both versions, each decorated with a header.\n\ eb:\tEdit then use both versions.\n\ el or e1:\tEdit then use the left version.\n\ er or e2:\tEdit then use the right version.\n\ e:\tDiscard both versions then edit a new one.\n\ l or 1:\tUse the left version.\n\ r or 2:\tUse the right version.\n\ s:\tSilently include common lines.\n\ v:\tVerbosely include common lines.\n\ q:\tQuit.\n\ "
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|skip_white
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'\n'
condition|)
break|break;
name|checksigs
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|stdin
argument_list|)
condition|)
name|perror_fatal
argument_list|(
name|_
argument_list|(
literal|"read failed"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|flush_line
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
continue|continue;
if|if
condition|(
name|ferror
argument_list|(
name|stdin
argument_list|)
condition|)
name|perror_fatal
argument_list|(
name|_
argument_list|(
literal|"read failed"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* interpret an edit command */
end_comment

begin_function
specifier|static
name|bool
name|edit
parameter_list|(
name|struct
name|line_filter
modifier|*
name|left
parameter_list|,
name|char
specifier|const
modifier|*
name|lname
parameter_list|,
name|lin
name|lline
parameter_list|,
name|lin
name|llen
parameter_list|,
name|struct
name|line_filter
modifier|*
name|right
parameter_list|,
name|char
specifier|const
modifier|*
name|rname
parameter_list|,
name|lin
name|rline
parameter_list|,
name|lin
name|rlen
parameter_list|,
name|FILE
modifier|*
name|outfile
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|cmd0
decl_stmt|,
name|cmd1
decl_stmt|;
name|bool
name|gotcmd
init|=
name|false
decl_stmt|;
name|cmd1
operator|=
literal|0
expr_stmt|;
comment|/* Pacify `gcc -W'.  */
while|while
condition|(
operator|!
name|gotcmd
condition|)
block|{
if|if
condition|(
name|putchar
argument_list|(
literal|'%'
argument_list|)
operator|!=
literal|'%'
condition|)
name|perror_fatal
argument_list|(
name|_
argument_list|(
literal|"write failed"
argument_list|)
argument_list|)
expr_stmt|;
name|ck_fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|cmd0
operator|=
name|skip_white
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|cmd0
condition|)
block|{
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'l'
case|:
case|case
literal|'r'
case|:
case|case
literal|'s'
case|:
case|case
literal|'v'
case|:
case|case
literal|'q'
case|:
if|if
condition|(
name|skip_white
argument_list|()
operator|!=
literal|'\n'
condition|)
block|{
name|give_help
argument_list|()
expr_stmt|;
name|flush_line
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|gotcmd
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|cmd1
operator|=
name|skip_white
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|cmd1
condition|)
block|{
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'b'
case|:
case|case
literal|'d'
case|:
case|case
literal|'l'
case|:
case|case
literal|'r'
case|:
if|if
condition|(
name|skip_white
argument_list|()
operator|!=
literal|'\n'
condition|)
block|{
name|give_help
argument_list|()
expr_stmt|;
name|flush_line
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|gotcmd
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|gotcmd
operator|=
name|true
expr_stmt|;
break|break;
default|default:
name|give_help
argument_list|()
expr_stmt|;
name|flush_line
argument_list|()
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|EOF
case|:
if|if
condition|(
name|feof
argument_list|(
name|stdin
argument_list|)
condition|)
block|{
name|gotcmd
operator|=
name|true
expr_stmt|;
name|cmd0
operator|=
literal|'q'
expr_stmt|;
break|break;
block|}
comment|/* Fall through.  */
default|default:
name|flush_line
argument_list|()
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|'\n'
case|:
name|give_help
argument_list|()
expr_stmt|;
continue|continue;
block|}
block|}
switch|switch
condition|(
name|cmd0
condition|)
block|{
case|case
literal|'1'
case|:
case|case
literal|'l'
case|:
name|lf_copy
argument_list|(
name|left
argument_list|,
name|llen
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|lf_skip
argument_list|(
name|right
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
literal|'2'
case|:
case|case
literal|'r'
case|:
name|lf_copy
argument_list|(
name|right
argument_list|,
name|rlen
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|lf_skip
argument_list|(
name|left
argument_list|,
name|llen
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
literal|'s'
case|:
name|suppress_common_lines
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|suppress_common_lines
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
return|return
name|false
return|;
case|case
literal|'e'
case|:
block|{
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|tmpname
condition|)
name|tmp
operator|=
name|fopen
argument_list|(
name|tmpname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|fd
operator|=
name|temporary_file
argument_list|()
operator|)
operator|<
literal|0
condition|)
name|perror_fatal
argument_list|(
literal|"mkstemp"
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tmp
condition|)
name|perror_fatal
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd1
condition|)
block|{
case|case
literal|'d'
case|:
if|if
condition|(
name|llen
condition|)
block|{
if|if
condition|(
name|llen
operator|==
literal|1
condition|)
name|fprintf
argument_list|(
name|tmp
argument_list|,
literal|"--- %s %ld\n"
argument_list|,
name|lname
argument_list|,
operator|(
name|long
name|int
operator|)
name|lline
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|tmp
argument_list|,
literal|"--- %s %ld,%ld\n"
argument_list|,
name|lname
argument_list|,
operator|(
name|long
name|int
operator|)
name|lline
argument_list|,
call|(
name|long
name|int
call|)
argument_list|(
name|lline
operator|+
name|llen
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Fall through.  */
case|case
literal|'1'
case|:
case|case
literal|'b'
case|:
case|case
literal|'l'
case|:
name|lf_copy
argument_list|(
name|left
argument_list|,
name|llen
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|lf_skip
argument_list|(
name|left
argument_list|,
name|llen
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|cmd1
condition|)
block|{
case|case
literal|'d'
case|:
if|if
condition|(
name|rlen
condition|)
block|{
if|if
condition|(
name|rlen
operator|==
literal|1
condition|)
name|fprintf
argument_list|(
name|tmp
argument_list|,
literal|"+++ %s %ld\n"
argument_list|,
name|rname
argument_list|,
operator|(
name|long
name|int
operator|)
name|rline
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|tmp
argument_list|,
literal|"+++ %s %ld,%ld\n"
argument_list|,
name|rname
argument_list|,
operator|(
name|long
name|int
operator|)
name|rline
argument_list|,
call|(
name|long
name|int
call|)
argument_list|(
name|rline
operator|+
name|rlen
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Fall through.  */
case|case
literal|'2'
case|:
case|case
literal|'b'
case|:
case|case
literal|'r'
case|:
name|lf_copy
argument_list|(
name|right
argument_list|,
name|rlen
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|lf_skip
argument_list|(
name|right
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
break|break;
block|}
name|ck_fclose
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|{
name|int
name|wstatus
decl_stmt|;
name|int
name|werrno
init|=
literal|0
decl_stmt|;
name|ignore_SIGINT
operator|=
name|true
expr_stmt|;
name|checksigs
argument_list|()
expr_stmt|;
block|{
if|#
directive|if
operator|!
operator|(
name|HAVE_WORKING_FORK
operator|||
name|HAVE_WORKING_VFORK
operator|)
name|char
modifier|*
name|command
init|=
name|xmalloc
argument_list|(
name|quote_system_arg
argument_list|(
literal|0
argument_list|,
name|editor_program
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|tmpname
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|command
operator|+
name|quote_system_arg
argument_list|(
name|command
argument_list|,
name|editor_program
argument_list|)
argument_list|,
literal|" %s"
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
name|wstatus
operator|=
name|system
argument_list|(
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
name|wstatus
operator|==
operator|-
literal|1
condition|)
name|werrno
operator|=
name|errno
expr_stmt|;
name|free
argument_list|(
name|command
argument_list|)
expr_stmt|;
else|#
directive|else
name|pid_t
name|pid
decl_stmt|;
name|pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
name|char
specifier|const
modifier|*
name|argv
index|[
literal|3
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|argv
index|[
name|i
operator|++
index|]
operator|=
name|editor_program
expr_stmt|;
name|argv
index|[
name|i
operator|++
index|]
operator|=
name|tmpname
expr_stmt|;
name|argv
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|execvp
argument_list|(
name|editor_program
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|errno
operator|==
name|ENOENT
condition|?
literal|127
else|:
literal|126
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
name|perror_fatal
argument_list|(
literal|"fork"
argument_list|)
expr_stmt|;
while|while
condition|(
name|waitpid
argument_list|(
name|pid
argument_list|,
operator|&
name|wstatus
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
name|checksigs
argument_list|()
expr_stmt|;
else|else
name|perror_fatal
argument_list|(
literal|"waitpid"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|ignore_SIGINT
operator|=
name|false
expr_stmt|;
name|check_child_status
argument_list|(
name|werrno
argument_list|,
name|wstatus
argument_list|,
name|EXIT_SUCCESS
argument_list|,
name|editor_program
argument_list|)
expr_stmt|;
block|}
block|{
name|char
name|buf
index|[
name|SDIFF_BUFSIZE
index|]
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|tmp
operator|=
name|ck_fopen
argument_list|(
name|tmpname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|size
operator|=
name|ck_fread
argument_list|(
name|buf
argument_list|,
name|SDIFF_BUFSIZE
argument_list|,
name|tmp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|checksigs
argument_list|()
expr_stmt|;
name|ck_fwrite
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
name|ck_fclose
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
default|default:
name|give_help
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Alternately reveal bursts of diff output and handle user commands.  */
end_comment

begin_function
specifier|static
name|bool
name|interact
parameter_list|(
name|struct
name|line_filter
modifier|*
name|diff
parameter_list|,
name|struct
name|line_filter
modifier|*
name|left
parameter_list|,
name|char
specifier|const
modifier|*
name|lname
parameter_list|,
name|struct
name|line_filter
modifier|*
name|right
parameter_list|,
name|char
specifier|const
modifier|*
name|rname
parameter_list|,
name|FILE
modifier|*
name|outfile
parameter_list|)
block|{
name|lin
name|lline
init|=
literal|1
decl_stmt|,
name|rline
init|=
literal|1
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|diff_help
index|[
literal|256
index|]
decl_stmt|;
name|int
name|snarfed
init|=
name|lf_snarf
argument_list|(
name|diff
argument_list|,
name|diff_help
argument_list|,
sizeof|sizeof
name|diff_help
argument_list|)
decl_stmt|;
if|if
condition|(
name|snarfed
operator|<=
literal|0
condition|)
return|return
name|snarfed
operator|!=
literal|0
return|;
name|checksigs
argument_list|()
expr_stmt|;
if|if
condition|(
name|diff_help
index|[
literal|0
index|]
operator|==
literal|' '
condition|)
name|puts
argument_list|(
name|diff_help
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|numend
decl_stmt|;
name|uintmax_t
name|val
decl_stmt|;
name|lin
name|llen
decl_stmt|,
name|rlen
decl_stmt|,
name|lenmax
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|llen
operator|=
name|val
operator|=
name|strtoumax
argument_list|(
name|diff_help
operator|+
literal|1
argument_list|,
operator|&
name|numend
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|llen
operator|<
literal|0
operator|||
name|llen
operator|!=
name|val
operator|||
name|errno
operator|||
operator|*
name|numend
operator|!=
literal|','
condition|)
name|fatal
argument_list|(
name|diff_help
argument_list|)
expr_stmt|;
name|rlen
operator|=
name|val
operator|=
name|strtoumax
argument_list|(
name|numend
operator|+
literal|1
argument_list|,
operator|&
name|numend
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|rlen
operator|<
literal|0
operator|||
name|rlen
operator|!=
name|val
operator|||
name|errno
operator|||
operator|*
name|numend
condition|)
name|fatal
argument_list|(
name|diff_help
argument_list|)
expr_stmt|;
name|lenmax
operator|=
name|MAX
argument_list|(
name|llen
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|diff_help
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'i'
case|:
if|if
condition|(
name|suppress_common_lines
condition|)
name|lf_skip
argument_list|(
name|diff
argument_list|,
name|lenmax
argument_list|)
expr_stmt|;
else|else
name|lf_copy
argument_list|(
name|diff
argument_list|,
name|lenmax
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|lf_copy
argument_list|(
name|left
argument_list|,
name|llen
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|lf_skip
argument_list|(
name|right
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|lf_copy
argument_list|(
name|diff
argument_list|,
name|lenmax
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|edit
argument_list|(
name|left
argument_list|,
name|lname
argument_list|,
name|lline
argument_list|,
name|llen
argument_list|,
name|right
argument_list|,
name|rname
argument_list|,
name|rline
argument_list|,
name|rlen
argument_list|,
name|outfile
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
default|default:
name|fatal
argument_list|(
name|diff_help
argument_list|)
expr_stmt|;
block|}
name|lline
operator|+=
name|llen
expr_stmt|;
name|rline
operator|+=
name|rlen
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return true if DIR is an existing directory.  */
end_comment

begin_function
specifier|static
name|bool
name|diraccess
parameter_list|(
name|char
specifier|const
modifier|*
name|dir
parameter_list|)
block|{
name|struct
name|stat
name|buf
decl_stmt|;
return|return
name|stat
argument_list|(
name|dir
argument_list|,
operator|&
name|buf
argument_list|)
operator|==
literal|0
operator|&&
name|S_ISDIR
argument_list|(
name|buf
operator|.
name|st_mode
argument_list|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|P_tmpdir
end_ifndef

begin_define
define|#
directive|define
name|P_tmpdir
value|"/tmp"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TMPDIR_ENV
end_ifndef

begin_define
define|#
directive|define
name|TMPDIR_ENV
value|"TMPDIR"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Open a temporary file and return its file descriptor.  Put into    tmpname the address of a newly allocated buffer that holds the    file's name.  Use the prefix "sdiff".  */
end_comment

begin_function
specifier|static
name|int
name|temporary_file
parameter_list|(
name|void
parameter_list|)
block|{
name|char
specifier|const
modifier|*
name|tmpdir
init|=
name|getenv
argument_list|(
name|TMPDIR_ENV
argument_list|)
decl_stmt|;
name|char
specifier|const
modifier|*
name|dir
init|=
name|tmpdir
condition|?
name|tmpdir
else|:
name|P_tmpdir
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
literal|1
operator|+
literal|5
operator|+
literal|6
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|e
decl_stmt|;
name|sigset_t
name|procmask
decl_stmt|;
name|sigset_t
name|blocked
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/sdiffXXXXXX"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|blocked
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|blocked
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|blocked
argument_list|,
operator|&
name|procmask
argument_list|)
expr_stmt|;
name|fd
operator|=
name|mkstemp
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|e
operator|=
name|errno
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|fd
condition|)
name|tmpname
operator|=
name|buf
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|procmask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|errno
operator|=
name|e
expr_stmt|;
return|return
name|fd
return|;
block|}
end_function

end_unit

