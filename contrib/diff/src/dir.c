begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Read, sort and compare two directories.  Used for GNU DIFF.     Copyright (C) 1988, 1989, 1992, 1993, 1994, 1995, 1998, 2001, 2002,    2004 Free Software Foundation, Inc.     This file is part of GNU DIFF.     GNU DIFF is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GNU DIFF is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; see the file COPYING.    If not, write to the Free Software Foundation,    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"diff.h"
end_include

begin_include
include|#
directive|include
file|<error.h>
end_include

begin_include
include|#
directive|include
file|<exclude.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<strcase.h>
end_include

begin_include
include|#
directive|include
file|<xalloc.h>
end_include

begin_comment
comment|/* Read the directory named by DIR and store into DIRDATA a sorted vector    of filenames for its contents.  DIR->desc == -1 means this directory is    known to be nonexistent, so set DIRDATA to an empty vector.    Return -1 (setting errno) if error, 0 otherwise.  */
end_comment

begin_struct
struct|struct
name|dirdata
block|{
name|size_t
name|nnames
decl_stmt|;
comment|/* Number of names.  */
name|char
specifier|const
modifier|*
modifier|*
name|names
decl_stmt|;
comment|/* Sorted names of files in dir, followed by 0.  */
name|char
modifier|*
name|data
decl_stmt|;
comment|/* Allocated storage for file names.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Whether file names in directories should be compared with    locale-specific sorting.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|locale_specific_sorting
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Where to go if locale-specific sorting fails.  */
end_comment

begin_decl_stmt
specifier|static
name|jmp_buf
name|failed_locale_specific_sorting
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|bool
name|dir_loop
parameter_list|(
name|struct
name|comparison
specifier|const
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|compare_names_for_qsort
parameter_list|(
name|void
specifier|const
modifier|*
parameter_list|,
name|void
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Read a directory and get its vector of names.  */
end_comment

begin_function
specifier|static
name|bool
name|dir_read
parameter_list|(
name|struct
name|file_data
specifier|const
modifier|*
name|dir
parameter_list|,
name|struct
name|dirdata
modifier|*
name|dirdata
parameter_list|)
block|{
specifier|register
name|struct
name|dirent
modifier|*
name|next
decl_stmt|;
specifier|register
name|size_t
name|i
decl_stmt|;
comment|/* Address of block containing the files that are described.  */
name|char
specifier|const
modifier|*
modifier|*
name|names
decl_stmt|;
comment|/* Number of files in directory.  */
name|size_t
name|nnames
decl_stmt|;
comment|/* Allocated and used storage for file name data.  */
name|char
modifier|*
name|data
decl_stmt|;
name|size_t
name|data_alloc
decl_stmt|,
name|data_used
decl_stmt|;
name|dirdata
operator|->
name|names
operator|=
literal|0
expr_stmt|;
name|dirdata
operator|->
name|data
operator|=
literal|0
expr_stmt|;
name|nnames
operator|=
literal|0
expr_stmt|;
name|data
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dir
operator|->
name|desc
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* Open the directory and check for errors.  */
specifier|register
name|DIR
modifier|*
name|reading
init|=
name|opendir
argument_list|(
name|dir
operator|->
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|reading
condition|)
return|return
name|false
return|;
comment|/* Initialize the table of filenames.  */
name|data_alloc
operator|=
literal|512
expr_stmt|;
name|data_used
operator|=
literal|0
expr_stmt|;
name|dirdata
operator|->
name|data
operator|=
name|data
operator|=
name|xmalloc
argument_list|(
name|data_alloc
argument_list|)
expr_stmt|;
comment|/* Read the directory entries, and insert the subfiles 	 into the `data' table.  */
while|while
condition|(
operator|(
name|errno
operator|=
literal|0
operator|,
operator|(
name|next
operator|=
name|readdir
argument_list|(
name|reading
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|char
modifier|*
name|d_name
init|=
name|next
operator|->
name|d_name
decl_stmt|;
name|size_t
name|d_size
init|=
name|NAMLEN
argument_list|(
name|next
argument_list|)
operator|+
literal|1
decl_stmt|;
comment|/* Ignore "." and "..".  */
if|if
condition|(
name|d_name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|d_name
index|[
literal|1
index|]
operator|==
literal|0
operator|||
operator|(
name|d_name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|d_name
index|[
literal|2
index|]
operator|==
literal|0
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|excluded_filename
argument_list|(
name|excluded
argument_list|,
name|d_name
argument_list|)
condition|)
continue|continue;
while|while
condition|(
name|data_alloc
operator|<
name|data_used
operator|+
name|d_size
condition|)
block|{
if|if
condition|(
name|PTRDIFF_MAX
operator|/
literal|2
operator|<=
name|data_alloc
condition|)
name|xalloc_die
argument_list|()
expr_stmt|;
name|dirdata
operator|->
name|data
operator|=
name|data
operator|=
name|xrealloc
argument_list|(
name|data
argument_list|,
name|data_alloc
operator|*=
literal|2
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|data
operator|+
name|data_used
argument_list|,
name|d_name
argument_list|,
name|d_size
argument_list|)
expr_stmt|;
name|data_used
operator|+=
name|d_size
expr_stmt|;
name|nnames
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|errno
condition|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|closedir
argument_list|(
name|reading
argument_list|)
expr_stmt|;
name|errno
operator|=
name|e
expr_stmt|;
return|return
name|false
return|;
block|}
if|#
directive|if
name|CLOSEDIR_VOID
name|closedir
argument_list|(
name|reading
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|closedir
argument_list|(
name|reading
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
endif|#
directive|endif
block|}
comment|/* Create the `names' table from the `data' table.  */
if|if
condition|(
name|PTRDIFF_MAX
operator|/
sizeof|sizeof
expr|*
name|names
operator|-
literal|1
operator|<=
name|nnames
condition|)
name|xalloc_die
argument_list|()
expr_stmt|;
name|dirdata
operator|->
name|names
operator|=
name|names
operator|=
name|xmalloc
argument_list|(
operator|(
name|nnames
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
expr|*
name|names
argument_list|)
expr_stmt|;
name|dirdata
operator|->
name|nnames
operator|=
name|nnames
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nnames
condition|;
name|i
operator|++
control|)
block|{
name|names
index|[
name|i
index|]
operator|=
name|data
expr_stmt|;
name|data
operator|+=
name|strlen
argument_list|(
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|names
index|[
name|nnames
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Compare file names, returning a value compatible with strcmp.  */
end_comment

begin_function
specifier|static
name|int
name|compare_names
parameter_list|(
name|char
specifier|const
modifier|*
name|name1
parameter_list|,
name|char
specifier|const
modifier|*
name|name2
parameter_list|)
block|{
if|if
condition|(
name|locale_specific_sorting
condition|)
block|{
name|int
name|r
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ignore_file_name_case
condition|)
name|r
operator|=
name|strcasecoll
argument_list|(
name|name1
argument_list|,
name|name2
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|strcoll
argument_list|(
name|name1
argument_list|,
name|name2
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
name|_
argument_list|(
literal|"cannot compare file names `%s' and `%s'"
argument_list|)
argument_list|,
name|name1
argument_list|,
name|name2
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|failed_locale_specific_sorting
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
return|return
operator|(
name|ignore_file_name_case
condition|?
name|strcasecmp
argument_list|(
name|name1
argument_list|,
name|name2
argument_list|)
else|:
name|file_name_cmp
argument_list|(
name|name1
argument_list|,
name|name2
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* A wrapper for compare_names suitable as an argument for qsort.  */
end_comment

begin_function
specifier|static
name|int
name|compare_names_for_qsort
parameter_list|(
name|void
specifier|const
modifier|*
name|file1
parameter_list|,
name|void
specifier|const
modifier|*
name|file2
parameter_list|)
block|{
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|f1
init|=
name|file1
decl_stmt|;
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|f2
init|=
name|file2
decl_stmt|;
return|return
name|compare_names
argument_list|(
operator|*
name|f1
argument_list|,
operator|*
name|f2
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compare the contents of two directories named in CMP.    This is a top-level routine; it does everything necessary for diff    on two directories.     CMP->file[0].desc == -1 says directory CMP->file[0] doesn't exist,    but pretend it is empty.  Likewise for CMP->file[1].     HANDLE_FILE is a caller-provided subroutine called to handle each file.    It gets three operands: CMP, name of file in dir 0, name of file in dir 1.    These names are relative to the original working directory.     For a file that appears in only one of the dirs, one of the name-args    to HANDLE_FILE is zero.     Returns the maximum of all the values returned by HANDLE_FILE,    or EXIT_TROUBLE if trouble is encountered in opening files.  */
end_comment

begin_function
name|int
name|diff_dirs
parameter_list|(
name|struct
name|comparison
specifier|const
modifier|*
name|cmp
parameter_list|,
name|int
function_decl|(
modifier|*
name|handle_file
function_decl|)
parameter_list|(
name|struct
name|comparison
specifier|const
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|)
parameter_list|)
block|{
name|struct
name|dirdata
name|dirdata
index|[
literal|2
index|]
decl_stmt|;
name|int
specifier|volatile
name|val
init|=
name|EXIT_SUCCESS
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|cmp
operator|->
name|file
index|[
literal|0
index|]
operator|.
name|desc
operator|==
operator|-
literal|1
operator|||
name|dir_loop
argument_list|(
name|cmp
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
operator|(
name|cmp
operator|->
name|file
index|[
literal|1
index|]
operator|.
name|desc
operator|==
operator|-
literal|1
operator|||
name|dir_loop
argument_list|(
name|cmp
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: recursive directory loop"
argument_list|,
name|cmp
operator|->
name|file
index|[
name|cmp
operator|->
name|file
index|[
literal|0
index|]
operator|.
name|desc
operator|==
operator|-
literal|1
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
name|EXIT_TROUBLE
return|;
block|}
comment|/* Get contents of both dirs.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|dir_read
argument_list|(
operator|&
name|cmp
operator|->
name|file
index|[
name|i
index|]
argument_list|,
operator|&
name|dirdata
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|perror_with_name
argument_list|(
name|cmp
operator|->
name|file
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|val
operator|=
name|EXIT_TROUBLE
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|==
name|EXIT_SUCCESS
condition|)
block|{
name|char
specifier|const
modifier|*
modifier|*
specifier|volatile
name|names
index|[
literal|2
index|]
decl_stmt|;
name|names
index|[
literal|0
index|]
operator|=
name|dirdata
index|[
literal|0
index|]
operator|.
name|names
expr_stmt|;
name|names
index|[
literal|1
index|]
operator|=
name|dirdata
index|[
literal|1
index|]
operator|.
name|names
expr_stmt|;
comment|/* Use locale-specific sorting if possible, else native byte order.  */
name|locale_specific_sorting
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|failed_locale_specific_sorting
argument_list|)
condition|)
name|locale_specific_sorting
operator|=
name|false
expr_stmt|;
comment|/* Sort the directories.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
name|qsort
argument_list|(
name|names
index|[
name|i
index|]
argument_list|,
name|dirdata
index|[
name|i
index|]
operator|.
name|nnames
argument_list|,
sizeof|sizeof
expr|*
name|dirdata
index|[
name|i
index|]
operator|.
name|names
argument_list|,
name|compare_names_for_qsort
argument_list|)
expr_stmt|;
comment|/* If `-S name' was given, and this is the topmost level of comparison, 	 ignore all file names less than the specified starting name.  */
if|if
condition|(
name|starting_file
operator|&&
operator|!
name|cmp
operator|->
name|parent
condition|)
block|{
while|while
condition|(
operator|*
name|names
index|[
literal|0
index|]
operator|&&
name|compare_names
argument_list|(
operator|*
name|names
index|[
literal|0
index|]
argument_list|,
name|starting_file
argument_list|)
operator|<
literal|0
condition|)
name|names
index|[
literal|0
index|]
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|names
index|[
literal|1
index|]
operator|&&
name|compare_names
argument_list|(
operator|*
name|names
index|[
literal|1
index|]
argument_list|,
name|starting_file
argument_list|)
operator|<
literal|0
condition|)
name|names
index|[
literal|1
index|]
operator|++
expr_stmt|;
block|}
comment|/* Loop while files remain in one or both dirs.  */
while|while
condition|(
operator|*
name|names
index|[
literal|0
index|]
operator|||
operator|*
name|names
index|[
literal|1
index|]
condition|)
block|{
comment|/* Compare next name in dir 0 with next name in dir 1. 	     At the end of a dir, 	     pretend the "next name" in that dir is very large.  */
name|int
name|nameorder
init|=
operator|(
operator|!
operator|*
name|names
index|[
literal|0
index|]
condition|?
literal|1
else|:
operator|!
operator|*
name|names
index|[
literal|1
index|]
condition|?
operator|-
literal|1
else|:
name|compare_names
argument_list|(
operator|*
name|names
index|[
literal|0
index|]
argument_list|,
operator|*
name|names
index|[
literal|1
index|]
argument_list|)
operator|)
decl_stmt|;
name|int
name|v1
init|=
call|(
modifier|*
name|handle_file
call|)
argument_list|(
name|cmp
argument_list|,
literal|0
operator|<
name|nameorder
condition|?
literal|0
else|:
operator|*
name|names
index|[
literal|0
index|]
operator|++
argument_list|,
name|nameorder
operator|<
literal|0
condition|?
literal|0
else|:
operator|*
name|names
index|[
literal|1
index|]
operator|++
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|<
name|v1
condition|)
name|val
operator|=
name|v1
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dirdata
index|[
name|i
index|]
operator|.
name|names
condition|)
name|free
argument_list|(
name|dirdata
index|[
name|i
index|]
operator|.
name|names
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirdata
index|[
name|i
index|]
operator|.
name|data
condition|)
name|free
argument_list|(
name|dirdata
index|[
name|i
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if CMP is looping recursively in argument I.  */
end_comment

begin_function
specifier|static
name|bool
name|dir_loop
parameter_list|(
name|struct
name|comparison
specifier|const
modifier|*
name|cmp
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|struct
name|comparison
specifier|const
modifier|*
name|p
init|=
name|cmp
decl_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|p
operator|->
name|parent
operator|)
condition|)
if|if
condition|(
literal|0
operator|<
name|same_file
argument_list|(
operator|&
name|p
operator|->
name|file
index|[
name|i
index|]
operator|.
name|stat
argument_list|,
operator|&
name|cmp
operator|->
name|file
index|[
name|i
index|]
operator|.
name|stat
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

end_unit

