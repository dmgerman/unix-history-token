begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* diff - compare files line by line     Copyright (C) 1988, 1989, 1992, 1993, 1994, 1996, 1998, 2001, 2002,    2004 Free Software Foundation, Inc.     This file is part of GNU DIFF.     GNU DIFF is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GNU DIFF is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.    See the GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GNU DIFF; see the file COPYING.    If not, write to the Free Software Foundation,    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_define
define|#
directive|define
name|GDIFF_MAIN
end_define

begin_include
include|#
directive|include
file|"diff.h"
end_include

begin_include
include|#
directive|include
file|"paths.h"
end_include

begin_include
include|#
directive|include
file|<c-stack.h>
end_include

begin_include
include|#
directive|include
file|<dirname.h>
end_include

begin_include
include|#
directive|include
file|<error.h>
end_include

begin_include
include|#
directive|include
file|<exclude.h>
end_include

begin_include
include|#
directive|include
file|<exit.h>
end_include

begin_include
include|#
directive|include
file|<exitfail.h>
end_include

begin_include
include|#
directive|include
file|<file-type.h>
end_include

begin_include
include|#
directive|include
file|<fnmatch.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<hard-locale.h>
end_include

begin_include
include|#
directive|include
file|<posixver.h>
end_include

begin_include
include|#
directive|include
file|<prepargs.h>
end_include

begin_include
include|#
directive|include
file|<quotesys.h>
end_include

begin_include
include|#
directive|include
file|<setmode.h>
end_include

begin_include
include|#
directive|include
file|<version-etc.h>
end_include

begin_include
include|#
directive|include
file|<xalloc.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|GUTTER_WIDTH_MINIMUM
end_ifndef

begin_define
define|#
directive|define
name|GUTTER_WIDTH_MINIMUM
value|3
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|regexp_list
block|{
name|char
modifier|*
name|regexps
decl_stmt|;
comment|/* chars representing disjunction of the regexps */
name|size_t
name|len
decl_stmt|;
comment|/* chars used in `regexps' */
name|size_t
name|size
decl_stmt|;
comment|/* size malloc'ed for `regexps'; 0 if not malloc'ed */
name|bool
name|multiple_regexps
decl_stmt|;
comment|/* Does `regexps' represent a disjunction?  */
name|struct
name|re_pattern_buffer
modifier|*
name|buf
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|compare_files
parameter_list|(
name|struct
name|comparison
specifier|const
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_regexp
parameter_list|(
name|struct
name|regexp_list
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|summarize_regexp_list
parameter_list|(
name|struct
name|regexp_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|specify_style
parameter_list|(
name|enum
name|output_style
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|specify_value
parameter_list|(
name|char
specifier|const
modifier|*
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|try_help
parameter_list|(
name|char
specifier|const
modifier|*
parameter_list|,
name|char
specifier|const
modifier|*
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(noreturn
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|void
name|check_stdout
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* If comparing directories, compare their common subdirectories    recursively.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|recursive
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In context diffs, show previous lines that match these regexps.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|regexp_list
name|function_regexp_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Ignore changes affecting only lines that match these regexps.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|regexp_list
name|ignore_regexp_list
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|HAVE_SETMODE_DOS
end_if

begin_comment
comment|/* Use binary I/O when reading and writing data (--binary).    On POSIX hosts, this has no effect.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|binary
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_enum
enum|enum
block|{
name|binary
init|=
name|true
block|}
enum|;
end_enum

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* When comparing directories, if a file appears only in one    directory, treat it as present but empty in the other (-N).    Then `patch' would create the file with appropriate contents.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|new_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When comparing directories, if a file appears only in the second    directory of the two, treat it as present but empty in the other    (--unidirectional-new-file).    Then `patch' would create the file with appropriate contents.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|unidirectional_new_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Report files compared that are the same (-s).    Normally nothing is output when that happens.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|report_identical_files
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return a string containing the command options with which diff was invoked.    Spaces appear between what were separate ARGV-elements.    There is a space at the beginning but none at the end.    If there were no options, the result is an empty string.     Arguments: OPTIONVEC, a vector containing separate ARGV-elements, and COUNT,    the length of that vector.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|option_list
parameter_list|(
name|char
modifier|*
modifier|*
name|optionvec
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|size_t
name|size
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|size
operator|+=
literal|1
operator|+
name|quote_system_arg
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|optionvec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|p
operator|=
name|result
operator|=
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
name|p
operator|+=
name|quote_system_arg
argument_list|(
name|p
argument_list|,
name|optionvec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Return an option value suitable for add_exclude.  */
end_comment

begin_function
specifier|static
name|int
name|exclude_options
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|EXCLUDE_WILDCARDS
operator||
operator|(
name|ignore_file_name_case
condition|?
name|FNM_CASEFOLD
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|char
specifier|const
name|shortopts
index|[]
init|=
literal|"0123456789abBcC:dD:eEfF:hHiI:lL:nNpPqrsS:tTuU:vwW:x:X:y"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Values for long options that do not have single-letter equivalents.  */
end_comment

begin_enum
enum|enum
block|{
name|BINARY_OPTION
init|=
name|CHAR_MAX
operator|+
literal|1
block|,
name|FROM_FILE_OPTION
block|,
name|HELP_OPTION
block|,
name|HORIZON_LINES_OPTION
block|,
name|IGNORE_FILE_NAME_CASE_OPTION
block|,
name|INHIBIT_HUNK_MERGE_OPTION
block|,
name|LEFT_COLUMN_OPTION
block|,
name|LINE_FORMAT_OPTION
block|,
name|NO_IGNORE_FILE_NAME_CASE_OPTION
block|,
name|NORMAL_OPTION
block|,
name|SDIFF_MERGE_ASSIST_OPTION
block|,
name|STRIP_TRAILING_CR_OPTION
block|,
name|SUPPRESS_COMMON_LINES_OPTION
block|,
name|TABSIZE_OPTION
block|,
name|TO_FILE_OPTION
block|,
comment|/* These options must be in sequence.  */
name|UNCHANGED_LINE_FORMAT_OPTION
block|,
name|OLD_LINE_FORMAT_OPTION
block|,
name|NEW_LINE_FORMAT_OPTION
block|,
comment|/* These options must be in sequence.  */
name|UNCHANGED_GROUP_FORMAT_OPTION
block|,
name|OLD_GROUP_FORMAT_OPTION
block|,
name|NEW_GROUP_FORMAT_OPTION
block|,
name|CHANGED_GROUP_FORMAT_OPTION
block|}
enum|;
end_enum

begin_expr_stmt
specifier|static
name|char
specifier|const
name|group_format_option
index|[]
index|[
sizeof|sizeof
expr|"--unchanged-group-format"]
operator|=
block|{
literal|"--unchanged-group-format"
block|,
literal|"--old-group-format"
block|,
literal|"--new-group-format"
block|,
literal|"--changed-group-format"
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|char
specifier|const
name|line_format_option
index|[]
index|[
sizeof|sizeof
expr|"--unchanged-line-format"]
operator|=
block|{
literal|"--unchanged-line-format"
block|,
literal|"--old-line-format"
block|,
literal|"--new-line-format"
block|}
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|option
specifier|const
name|longopts
index|[]
init|=
block|{
block|{
literal|"binary"
block|,
literal|0
block|,
literal|0
block|,
name|BINARY_OPTION
block|}
block|,
block|{
literal|"brief"
block|,
literal|0
block|,
literal|0
block|,
literal|'q'
block|}
block|,
block|{
literal|"changed-group-format"
block|,
literal|1
block|,
literal|0
block|,
name|CHANGED_GROUP_FORMAT_OPTION
block|}
block|,
block|{
literal|"context"
block|,
literal|2
block|,
literal|0
block|,
literal|'C'
block|}
block|,
block|{
literal|"ed"
block|,
literal|0
block|,
literal|0
block|,
literal|'e'
block|}
block|,
block|{
literal|"exclude"
block|,
literal|1
block|,
literal|0
block|,
literal|'x'
block|}
block|,
block|{
literal|"exclude-from"
block|,
literal|1
block|,
literal|0
block|,
literal|'X'
block|}
block|,
block|{
literal|"expand-tabs"
block|,
literal|0
block|,
literal|0
block|,
literal|'t'
block|}
block|,
block|{
literal|"forward-ed"
block|,
literal|0
block|,
literal|0
block|,
literal|'f'
block|}
block|,
block|{
literal|"from-file"
block|,
literal|1
block|,
literal|0
block|,
name|FROM_FILE_OPTION
block|}
block|,
block|{
literal|"help"
block|,
literal|0
block|,
literal|0
block|,
name|HELP_OPTION
block|}
block|,
block|{
literal|"horizon-lines"
block|,
literal|1
block|,
literal|0
block|,
name|HORIZON_LINES_OPTION
block|}
block|,
block|{
literal|"ifdef"
block|,
literal|1
block|,
literal|0
block|,
literal|'D'
block|}
block|,
block|{
literal|"ignore-all-space"
block|,
literal|0
block|,
literal|0
block|,
literal|'w'
block|}
block|,
block|{
literal|"ignore-blank-lines"
block|,
literal|0
block|,
literal|0
block|,
literal|'B'
block|}
block|,
block|{
literal|"ignore-case"
block|,
literal|0
block|,
literal|0
block|,
literal|'i'
block|}
block|,
block|{
literal|"ignore-file-name-case"
block|,
literal|0
block|,
literal|0
block|,
name|IGNORE_FILE_NAME_CASE_OPTION
block|}
block|,
block|{
literal|"ignore-matching-lines"
block|,
literal|1
block|,
literal|0
block|,
literal|'I'
block|}
block|,
block|{
literal|"ignore-space-change"
block|,
literal|0
block|,
literal|0
block|,
literal|'b'
block|}
block|,
block|{
literal|"ignore-tab-expansion"
block|,
literal|0
block|,
literal|0
block|,
literal|'E'
block|}
block|,
block|{
literal|"inhibit-hunk-merge"
block|,
literal|0
block|,
literal|0
block|,
name|INHIBIT_HUNK_MERGE_OPTION
block|}
block|,
block|{
literal|"initial-tab"
block|,
literal|0
block|,
literal|0
block|,
literal|'T'
block|}
block|,
block|{
literal|"label"
block|,
literal|1
block|,
literal|0
block|,
literal|'L'
block|}
block|,
block|{
literal|"left-column"
block|,
literal|0
block|,
literal|0
block|,
name|LEFT_COLUMN_OPTION
block|}
block|,
block|{
literal|"line-format"
block|,
literal|1
block|,
literal|0
block|,
name|LINE_FORMAT_OPTION
block|}
block|,
block|{
literal|"minimal"
block|,
literal|0
block|,
literal|0
block|,
literal|'d'
block|}
block|,
block|{
literal|"new-file"
block|,
literal|0
block|,
literal|0
block|,
literal|'N'
block|}
block|,
block|{
literal|"new-group-format"
block|,
literal|1
block|,
literal|0
block|,
name|NEW_GROUP_FORMAT_OPTION
block|}
block|,
block|{
literal|"new-line-format"
block|,
literal|1
block|,
literal|0
block|,
name|NEW_LINE_FORMAT_OPTION
block|}
block|,
block|{
literal|"no-ignore-file-name-case"
block|,
literal|0
block|,
literal|0
block|,
name|NO_IGNORE_FILE_NAME_CASE_OPTION
block|}
block|,
block|{
literal|"normal"
block|,
literal|0
block|,
literal|0
block|,
name|NORMAL_OPTION
block|}
block|,
block|{
literal|"old-group-format"
block|,
literal|1
block|,
literal|0
block|,
name|OLD_GROUP_FORMAT_OPTION
block|}
block|,
block|{
literal|"old-line-format"
block|,
literal|1
block|,
literal|0
block|,
name|OLD_LINE_FORMAT_OPTION
block|}
block|,
block|{
literal|"paginate"
block|,
literal|0
block|,
literal|0
block|,
literal|'l'
block|}
block|,
block|{
literal|"rcs"
block|,
literal|0
block|,
literal|0
block|,
literal|'n'
block|}
block|,
block|{
literal|"recursive"
block|,
literal|0
block|,
literal|0
block|,
literal|'r'
block|}
block|,
block|{
literal|"report-identical-files"
block|,
literal|0
block|,
literal|0
block|,
literal|'s'
block|}
block|,
block|{
literal|"sdiff-merge-assist"
block|,
literal|0
block|,
literal|0
block|,
name|SDIFF_MERGE_ASSIST_OPTION
block|}
block|,
block|{
literal|"show-c-function"
block|,
literal|0
block|,
literal|0
block|,
literal|'p'
block|}
block|,
block|{
literal|"show-function-line"
block|,
literal|1
block|,
literal|0
block|,
literal|'F'
block|}
block|,
block|{
literal|"side-by-side"
block|,
literal|0
block|,
literal|0
block|,
literal|'y'
block|}
block|,
block|{
literal|"speed-large-files"
block|,
literal|0
block|,
literal|0
block|,
literal|'H'
block|}
block|,
block|{
literal|"starting-file"
block|,
literal|1
block|,
literal|0
block|,
literal|'S'
block|}
block|,
block|{
literal|"strip-trailing-cr"
block|,
literal|0
block|,
literal|0
block|,
name|STRIP_TRAILING_CR_OPTION
block|}
block|,
block|{
literal|"suppress-common-lines"
block|,
literal|0
block|,
literal|0
block|,
name|SUPPRESS_COMMON_LINES_OPTION
block|}
block|,
block|{
literal|"tabsize"
block|,
literal|1
block|,
literal|0
block|,
name|TABSIZE_OPTION
block|}
block|,
block|{
literal|"text"
block|,
literal|0
block|,
literal|0
block|,
literal|'a'
block|}
block|,
block|{
literal|"to-file"
block|,
literal|1
block|,
literal|0
block|,
name|TO_FILE_OPTION
block|}
block|,
block|{
literal|"unchanged-group-format"
block|,
literal|1
block|,
literal|0
block|,
name|UNCHANGED_GROUP_FORMAT_OPTION
block|}
block|,
block|{
literal|"unchanged-line-format"
block|,
literal|1
block|,
literal|0
block|,
name|UNCHANGED_LINE_FORMAT_OPTION
block|}
block|,
block|{
literal|"unidirectional-new-file"
block|,
literal|0
block|,
literal|0
block|,
literal|'P'
block|}
block|,
block|{
literal|"unified"
block|,
literal|2
block|,
literal|0
block|,
literal|'U'
block|}
block|,
block|{
literal|"version"
block|,
literal|0
block|,
literal|0
block|,
literal|'v'
block|}
block|,
block|{
literal|"width"
block|,
literal|1
block|,
literal|0
block|,
literal|'W'
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|exit_status
init|=
name|EXIT_SUCCESS
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|prev
init|=
operator|-
literal|1
decl_stmt|;
name|lin
name|ocontext
init|=
operator|-
literal|1
decl_stmt|;
name|bool
name|explicit_context
init|=
name|false
decl_stmt|;
name|size_t
name|width
init|=
literal|0
decl_stmt|;
name|bool
name|show_c_function
init|=
name|false
decl_stmt|;
name|char
specifier|const
modifier|*
name|from_file
init|=
literal|0
decl_stmt|;
name|char
specifier|const
modifier|*
name|to_file
init|=
literal|0
decl_stmt|;
name|uintmax_t
name|numval
decl_stmt|;
name|char
modifier|*
name|numend
decl_stmt|;
comment|/* Do our initializations.  */
name|exit_failure
operator|=
literal|2
expr_stmt|;
name|initialize_main
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|bindtextdomain
argument_list|(
name|PACKAGE
argument_list|,
name|LOCALEDIR
argument_list|)
expr_stmt|;
name|textdomain
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
name|c_stack_action
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|function_regexp_list
operator|.
name|buf
operator|=
operator|&
name|function_regexp
expr_stmt|;
name|ignore_regexp_list
operator|.
name|buf
operator|=
operator|&
name|ignore_regexp
expr_stmt|;
name|re_set_syntax
argument_list|(
name|RE_SYNTAX_GREP
operator||
name|RE_NO_POSIX_BACKTRACKING
argument_list|)
expr_stmt|;
name|excluded
operator|=
name|new_exclude
argument_list|()
expr_stmt|;
comment|/* Decode the options.  */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|shortopts
argument_list|,
name|longopts
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
name|prev
argument_list|)
condition|)
name|ocontext
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|LIN_MAX
operator|/
literal|10
operator|<
name|ocontext
operator|||
operator|(
operator|(
name|ocontext
operator|=
literal|10
operator|*
name|ocontext
operator|+
name|c
operator|-
literal|'0'
operator|)
operator|<
literal|0
operator|)
condition|)
name|ocontext
operator|=
name|LIN_MAX
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|text
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
if|if
condition|(
name|ignore_white_space
operator|<
name|IGNORE_SPACE_CHANGE
condition|)
name|ignore_white_space
operator|=
name|IGNORE_SPACE_CHANGE
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|ignore_blank_lines
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
case|case
literal|'U'
case|:
block|{
if|if
condition|(
name|optarg
condition|)
block|{
name|numval
operator|=
name|strtoumax
argument_list|(
name|optarg
argument_list|,
operator|&
name|numend
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|numend
condition|)
name|try_help
argument_list|(
literal|"invalid context length `%s'"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIN_MAX
operator|<
name|numval
condition|)
name|numval
operator|=
name|LIN_MAX
expr_stmt|;
block|}
else|else
name|numval
operator|=
literal|3
expr_stmt|;
name|specify_style
argument_list|(
name|c
operator|==
literal|'U'
condition|?
name|OUTPUT_UNIFIED
else|:
name|OUTPUT_CONTEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|<
name|numval
condition|)
name|context
operator|=
name|numval
expr_stmt|;
name|explicit_context
operator|=
name|true
expr_stmt|;
block|}
break|break;
case|case
literal|'c'
case|:
name|specify_style
argument_list|(
name|OUTPUT_CONTEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|<
literal|3
condition|)
name|context
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|minimal
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|specify_style
argument_list|(
name|OUTPUT_IFDEF
argument_list|)
expr_stmt|;
block|{
specifier|static
name|char
specifier|const
name|C_ifdef_group_formats
index|[]
init|=
literal|"%%=%c#ifndef %s\n%%<#endif /* ! %s */\n%c#ifdef %s\n%%>#endif /* %s */\n%c#ifndef %s\n%%<#else /* %s */\n%%>#endif /* %s */\n"
decl_stmt|;
name|char
modifier|*
name|b
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
name|C_ifdef_group_formats
operator|+
literal|7
operator|*
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|-
literal|14
comment|/* 7*"%s" */
operator|-
literal|8
comment|/* 5*"%%" + 3*"%c" */
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|b
argument_list|,
name|C_ifdef_group_formats
argument_list|,
literal|0
argument_list|,
name|optarg
argument_list|,
name|optarg
argument_list|,
literal|0
argument_list|,
name|optarg
argument_list|,
name|optarg
argument_list|,
literal|0
argument_list|,
name|optarg
argument_list|,
name|optarg
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|group_format
operator|/
sizeof|sizeof
expr|*
name|group_format
condition|;
name|i
operator|++
control|)
block|{
name|specify_value
argument_list|(
operator|&
name|group_format
index|[
name|i
index|]
argument_list|,
name|b
argument_list|,
literal|"-D"
argument_list|)
expr_stmt|;
name|b
operator|+=
name|strlen
argument_list|(
name|b
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'e'
case|:
name|specify_style
argument_list|(
name|OUTPUT_ED
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|ignore_white_space
operator|<
name|IGNORE_TAB_EXPANSION
condition|)
name|ignore_white_space
operator|=
name|IGNORE_TAB_EXPANSION
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|specify_style
argument_list|(
name|OUTPUT_FORWARD_ED
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|add_regexp
argument_list|(
operator|&
name|function_regexp_list
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* Split the files into chunks for faster processing. 	     Usually does not change the result.  	     This currently has no effect.  */
break|break;
case|case
literal|'H'
case|:
name|speed_large_files
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|ignore_case
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|add_regexp
argument_list|(
operator|&
name|ignore_regexp_list
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
operator|!
name|pr_program
index|[
literal|0
index|]
condition|)
name|try_help
argument_list|(
literal|"pagination not supported on this host"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|paginate
operator|=
name|true
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGCHLD
comment|/* Pagination requires forking and waiting, and 	     System V fork+wait does not work if SIGCHLD is ignored.  */
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'L'
case|:
if|if
condition|(
operator|!
name|file_label
index|[
literal|0
index|]
condition|)
name|file_label
index|[
literal|0
index|]
operator|=
name|optarg
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|file_label
index|[
literal|1
index|]
condition|)
name|file_label
index|[
literal|1
index|]
operator|=
name|optarg
expr_stmt|;
else|else
name|fatal
argument_list|(
literal|"too many file label options"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|specify_style
argument_list|(
name|OUTPUT_RCS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|new_file
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|show_c_function
operator|=
name|true
expr_stmt|;
name|add_regexp
argument_list|(
operator|&
name|function_regexp_list
argument_list|,
literal|"^[[:alpha:]$_]"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|unidirectional_new_file
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|brief
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|recursive
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|report_identical_files
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|specify_value
argument_list|(
operator|&
name|starting_file
argument_list|,
name|optarg
argument_list|,
literal|"-S"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|expand_tabs
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|initial_tab
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|specify_style
argument_list|(
name|OUTPUT_UNIFIED
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|<
literal|3
condition|)
name|context
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|version_etc
argument_list|(
name|stdout
argument_list|,
literal|"diff"
argument_list|,
name|PACKAGE_NAME
argument_list|,
name|PACKAGE_VERSION
argument_list|,
literal|"Paul Eggert"
argument_list|,
literal|"Mike Haertel"
argument_list|,
literal|"David Hayes"
argument_list|,
literal|"Richard Stallman"
argument_list|,
literal|"Len Tower"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|check_stdout
argument_list|()
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
case|case
literal|'w'
case|:
name|ignore_white_space
operator|=
name|IGNORE_ALL_SPACE
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|add_exclude
argument_list|(
name|excluded
argument_list|,
name|optarg
argument_list|,
name|exclude_options
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
if|if
condition|(
name|add_exclude_file
argument_list|(
name|add_exclude
argument_list|,
name|excluded
argument_list|,
name|optarg
argument_list|,
name|exclude_options
argument_list|()
argument_list|,
literal|'\n'
argument_list|)
condition|)
name|pfatal_with_name
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
name|specify_style
argument_list|(
name|OUTPUT_SDIFF
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|numval
operator|=
name|strtoumax
argument_list|(
name|optarg
argument_list|,
operator|&
name|numend
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
literal|0
operator|<
name|numval
operator|&&
name|numval
operator|<=
name|SIZE_MAX
operator|)
operator|||
operator|*
name|numend
condition|)
name|try_help
argument_list|(
literal|"invalid width `%s'"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|!=
name|numval
condition|)
block|{
if|if
condition|(
name|width
condition|)
name|fatal
argument_list|(
literal|"conflicting width options"
argument_list|)
expr_stmt|;
name|width
operator|=
name|numval
expr_stmt|;
block|}
break|break;
case|case
name|BINARY_OPTION
case|:
if|#
directive|if
name|HAVE_SETMODE_DOS
name|binary
operator|=
name|true
expr_stmt|;
name|set_binary_mode
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|true
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|FROM_FILE_OPTION
case|:
name|specify_value
argument_list|(
operator|&
name|from_file
argument_list|,
name|optarg
argument_list|,
literal|"--from-file"
argument_list|)
expr_stmt|;
break|break;
case|case
name|HELP_OPTION
case|:
name|usage
argument_list|()
expr_stmt|;
name|check_stdout
argument_list|()
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
case|case
name|HORIZON_LINES_OPTION
case|:
name|numval
operator|=
name|strtoumax
argument_list|(
name|optarg
argument_list|,
operator|&
name|numend
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|numend
condition|)
name|try_help
argument_list|(
literal|"invalid horizon length `%s'"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|horizon_lines
operator|=
name|MAX
argument_list|(
name|horizon_lines
argument_list|,
name|MIN
argument_list|(
name|numval
argument_list|,
name|LIN_MAX
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IGNORE_FILE_NAME_CASE_OPTION
case|:
name|ignore_file_name_case
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|INHIBIT_HUNK_MERGE_OPTION
case|:
comment|/* This option is obsolete, but accept it for backward              compatibility.  */
break|break;
case|case
name|LEFT_COLUMN_OPTION
case|:
name|left_column
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|LINE_FORMAT_OPTION
case|:
name|specify_style
argument_list|(
name|OUTPUT_IFDEF
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|line_format
operator|/
sizeof|sizeof
expr|*
name|line_format
condition|;
name|i
operator|++
control|)
name|specify_value
argument_list|(
operator|&
name|line_format
index|[
name|i
index|]
argument_list|,
name|optarg
argument_list|,
literal|"--line-format"
argument_list|)
expr_stmt|;
break|break;
case|case
name|NO_IGNORE_FILE_NAME_CASE_OPTION
case|:
name|ignore_file_name_case
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|NORMAL_OPTION
case|:
name|specify_style
argument_list|(
name|OUTPUT_NORMAL
argument_list|)
expr_stmt|;
break|break;
case|case
name|SDIFF_MERGE_ASSIST_OPTION
case|:
name|specify_style
argument_list|(
name|OUTPUT_SDIFF
argument_list|)
expr_stmt|;
name|sdiff_merge_assist
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|STRIP_TRAILING_CR_OPTION
case|:
name|strip_trailing_cr
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|SUPPRESS_COMMON_LINES_OPTION
case|:
name|suppress_common_lines
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|TABSIZE_OPTION
case|:
name|numval
operator|=
name|strtoumax
argument_list|(
name|optarg
argument_list|,
operator|&
name|numend
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
literal|0
operator|<
name|numval
operator|&&
name|numval
operator|<=
name|SIZE_MAX
operator|)
operator|||
operator|*
name|numend
condition|)
name|try_help
argument_list|(
literal|"invalid tabsize `%s'"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|tabsize
operator|!=
name|numval
condition|)
block|{
if|if
condition|(
name|tabsize
condition|)
name|fatal
argument_list|(
literal|"conflicting tabsize options"
argument_list|)
expr_stmt|;
name|tabsize
operator|=
name|numval
expr_stmt|;
block|}
break|break;
case|case
name|TO_FILE_OPTION
case|:
name|specify_value
argument_list|(
operator|&
name|to_file
argument_list|,
name|optarg
argument_list|,
literal|"--to-file"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNCHANGED_LINE_FORMAT_OPTION
case|:
case|case
name|OLD_LINE_FORMAT_OPTION
case|:
case|case
name|NEW_LINE_FORMAT_OPTION
case|:
name|specify_style
argument_list|(
name|OUTPUT_IFDEF
argument_list|)
expr_stmt|;
name|c
operator|-=
name|UNCHANGED_LINE_FORMAT_OPTION
expr_stmt|;
name|specify_value
argument_list|(
operator|&
name|line_format
index|[
name|c
index|]
argument_list|,
name|optarg
argument_list|,
name|line_format_option
index|[
name|c
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNCHANGED_GROUP_FORMAT_OPTION
case|:
case|case
name|OLD_GROUP_FORMAT_OPTION
case|:
case|case
name|NEW_GROUP_FORMAT_OPTION
case|:
case|case
name|CHANGED_GROUP_FORMAT_OPTION
case|:
name|specify_style
argument_list|(
name|OUTPUT_IFDEF
argument_list|)
expr_stmt|;
name|c
operator|-=
name|UNCHANGED_GROUP_FORMAT_OPTION
expr_stmt|;
name|specify_value
argument_list|(
operator|&
name|group_format
index|[
name|c
index|]
argument_list|,
name|optarg
argument_list|,
name|group_format_option
index|[
name|c
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|try_help
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|prev
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|output_style
operator|==
name|OUTPUT_UNSPECIFIED
condition|)
block|{
if|if
condition|(
name|show_c_function
condition|)
block|{
name|specify_style
argument_list|(
name|OUTPUT_CONTEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ocontext
operator|<
literal|0
condition|)
name|context
operator|=
literal|3
expr_stmt|;
block|}
else|else
name|specify_style
argument_list|(
name|OUTPUT_NORMAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|output_style
operator|!=
name|OUTPUT_CONTEXT
operator|||
name|hard_locale
argument_list|(
name|LC_TIME
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|ST_MTIM_NSEC
name|time_format
operator|=
literal|"%Y-%m-%d %H:%M:%S.%N %z"
expr_stmt|;
else|#
directive|else
name|time_format
operator|=
literal|"%Y-%m-%d %H:%M:%S %z"
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* See POSIX 1003.1-2001 for this format.  */
name|time_format
operator|=
literal|"%a %b %e %T %Y"
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|<=
name|ocontext
condition|)
block|{
name|bool
name|modern_usage
init|=
literal|200112
operator|<=
name|posix2_version
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|output_style
operator|==
name|OUTPUT_CONTEXT
operator|||
name|output_style
operator|==
name|OUTPUT_UNIFIED
operator|)
operator|&&
operator|(
name|context
operator|<
name|ocontext
operator|||
operator|(
name|ocontext
operator|<
name|context
operator|&&
operator|!
name|explicit_context
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|modern_usage
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"`-%ld' option is obsolete; use `-%c %ld'"
argument_list|)
argument_list|,
operator|(
name|long
name|int
operator|)
name|ocontext
argument_list|,
name|output_style
operator|==
name|OUTPUT_CONTEXT
condition|?
literal|'C'
else|:
literal|'U'
argument_list|,
operator|(
name|long
name|int
operator|)
name|ocontext
argument_list|)
expr_stmt|;
name|try_help
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|context
operator|=
name|ocontext
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|modern_usage
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"`-%ld' option is obsolete; omit it"
argument_list|)
argument_list|,
operator|(
name|long
name|int
operator|)
name|ocontext
argument_list|)
expr_stmt|;
name|try_help
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|tabsize
condition|)
name|tabsize
operator|=
literal|8
expr_stmt|;
if|if
condition|(
operator|!
name|width
condition|)
name|width
operator|=
literal|130
expr_stmt|;
block|{
comment|/* Maximize first the half line width, and then the gutter width,        according to the following constraints:  	1.  Two half lines plus a gutter must fit in a line. 	2.  If the half line width is nonzero: 	    a.  The gutter width is at least GUTTER_WIDTH_MINIMUM. 	    b.  If tabs are not expanded to spaces, 		a half line plus a gutter is an integral number of tabs, 		so that tabs in the right column line up.  */
name|intmax_t
name|t
init|=
name|expand_tabs
condition|?
literal|1
else|:
name|tabsize
decl_stmt|;
name|intmax_t
name|w
init|=
name|width
decl_stmt|;
name|intmax_t
name|off
init|=
operator|(
name|w
operator|+
name|t
operator|+
name|GUTTER_WIDTH_MINIMUM
operator|)
operator|/
operator|(
literal|2
operator|*
name|t
operator|)
operator|*
name|t
decl_stmt|;
name|sdiff_half_width
operator|=
name|MAX
argument_list|(
literal|0
argument_list|,
name|MIN
argument_list|(
name|off
operator|-
name|GUTTER_WIDTH_MINIMUM
argument_list|,
name|w
operator|-
name|off
argument_list|)
argument_list|)
operator|,
name|sdiff_column2_offset
operator|=
name|sdiff_half_width
condition|?
name|off
else|:
name|w
expr_stmt|;
block|}
comment|/* Make the horizon at least as large as the context, so that      shift_boundaries has more freedom to shift the first and last hunks.  */
if|if
condition|(
name|horizon_lines
operator|<
name|context
condition|)
name|horizon_lines
operator|=
name|context
expr_stmt|;
name|summarize_regexp_list
argument_list|(
operator|&
name|function_regexp_list
argument_list|)
expr_stmt|;
name|summarize_regexp_list
argument_list|(
operator|&
name|ignore_regexp_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_style
operator|==
name|OUTPUT_IFDEF
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|line_format
operator|/
sizeof|sizeof
expr|*
name|line_format
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|line_format
index|[
name|i
index|]
condition|)
name|line_format
index|[
name|i
index|]
operator|=
literal|"%l\n"
expr_stmt|;
if|if
condition|(
operator|!
name|group_format
index|[
name|OLD
index|]
condition|)
name|group_format
index|[
name|OLD
index|]
operator|=
name|group_format
index|[
name|CHANGED
index|]
condition|?
name|group_format
index|[
name|CHANGED
index|]
else|:
literal|"%<"
expr_stmt|;
if|if
condition|(
operator|!
name|group_format
index|[
name|NEW
index|]
condition|)
name|group_format
index|[
name|NEW
index|]
operator|=
name|group_format
index|[
name|CHANGED
index|]
condition|?
name|group_format
index|[
name|CHANGED
index|]
else|:
literal|"%>"
expr_stmt|;
if|if
condition|(
operator|!
name|group_format
index|[
name|UNCHANGED
index|]
condition|)
name|group_format
index|[
name|UNCHANGED
index|]
operator|=
literal|"%="
expr_stmt|;
if|if
condition|(
operator|!
name|group_format
index|[
name|CHANGED
index|]
condition|)
name|group_format
index|[
name|CHANGED
index|]
operator|=
name|concat
argument_list|(
name|group_format
index|[
name|OLD
index|]
argument_list|,
name|group_format
index|[
name|NEW
index|]
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|no_diff_means_no_output
operator|=
operator|(
name|output_style
operator|==
name|OUTPUT_IFDEF
condition|?
operator|(
operator|!
operator|*
name|group_format
index|[
name|UNCHANGED
index|]
operator|||
operator|(
name|strcmp
argument_list|(
name|group_format
index|[
name|UNCHANGED
index|]
argument_list|,
literal|"%="
argument_list|)
operator|==
literal|0
operator|&&
operator|!
operator|*
name|line_format
index|[
name|UNCHANGED
index|]
operator|)
operator|)
else|:
operator|(
name|output_style
operator|!=
name|OUTPUT_SDIFF
operator|)
operator||
name|suppress_common_lines
operator|)
expr_stmt|;
name|files_can_be_treated_as_binary
operator|=
operator|(
name|brief
operator|&
name|binary
operator|&
operator|~
operator|(
name|ignore_blank_lines
operator||
name|ignore_case
operator||
name|strip_trailing_cr
operator||
operator|(
name|ignore_regexp_list
operator|.
name|regexps
operator|||
name|ignore_white_space
operator|)
operator|)
operator|)
expr_stmt|;
name|switch_string
operator|=
name|option_list
argument_list|(
name|argv
operator|+
literal|1
argument_list|,
name|optind
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_file
condition|)
block|{
if|if
condition|(
name|to_file
condition|)
name|fatal
argument_list|(
literal|"--from-file and --to-file both specified"
argument_list|)
expr_stmt|;
else|else
for|for
control|(
init|;
name|optind
operator|<
name|argc
condition|;
name|optind
operator|++
control|)
block|{
name|int
name|status
init|=
name|compare_files
argument_list|(
operator|(
expr|struct
name|comparison
operator|*
operator|)
literal|0
argument_list|,
name|from_file
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|exit_status
operator|<
name|status
condition|)
name|exit_status
operator|=
name|status
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|to_file
condition|)
for|for
control|(
init|;
name|optind
operator|<
name|argc
condition|;
name|optind
operator|++
control|)
block|{
name|int
name|status
init|=
name|compare_files
argument_list|(
operator|(
expr|struct
name|comparison
operator|*
operator|)
literal|0
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|,
name|to_file
argument_list|)
decl_stmt|;
if|if
condition|(
name|exit_status
operator|<
name|status
condition|)
name|exit_status
operator|=
name|status
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|argc
operator|-
name|optind
operator|!=
literal|2
condition|)
block|{
if|if
condition|(
name|argc
operator|-
name|optind
operator|<
literal|2
condition|)
name|try_help
argument_list|(
literal|"missing operand after `%s'"
argument_list|,
name|argv
index|[
name|argc
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|try_help
argument_list|(
literal|"extra operand `%s'"
argument_list|,
name|argv
index|[
name|optind
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
name|exit_status
operator|=
name|compare_files
argument_list|(
operator|(
expr|struct
name|comparison
operator|*
operator|)
literal|0
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|,
name|argv
index|[
name|optind
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Print any messages that were saved up for last.  */
name|print_message_queue
argument_list|()
expr_stmt|;
name|check_stdout
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|exit_status
argument_list|)
expr_stmt|;
return|return
name|exit_status
return|;
block|}
end_function

begin_comment
comment|/* Append to REGLIST the regexp PATTERN.  */
end_comment

begin_function
specifier|static
name|void
name|add_regexp
parameter_list|(
name|struct
name|regexp_list
modifier|*
name|reglist
parameter_list|,
name|char
specifier|const
modifier|*
name|pattern
parameter_list|)
block|{
name|size_t
name|patlen
init|=
name|strlen
argument_list|(
name|pattern
argument_list|)
decl_stmt|;
name|char
specifier|const
modifier|*
name|m
init|=
name|re_compile_pattern
argument_list|(
name|pattern
argument_list|,
name|patlen
argument_list|,
name|reglist
operator|->
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: %s"
argument_list|,
name|pattern
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|regexps
init|=
name|reglist
operator|->
name|regexps
decl_stmt|;
name|size_t
name|len
init|=
name|reglist
operator|->
name|len
decl_stmt|;
name|bool
name|multiple_regexps
init|=
name|reglist
operator|->
name|multiple_regexps
operator|=
name|regexps
operator|!=
literal|0
decl_stmt|;
name|size_t
name|newlen
init|=
name|reglist
operator|->
name|len
operator|=
name|len
operator|+
literal|2
operator|*
name|multiple_regexps
operator|+
name|patlen
decl_stmt|;
name|size_t
name|size
init|=
name|reglist
operator|->
name|size
decl_stmt|;
if|if
condition|(
name|size
operator|<=
name|newlen
condition|)
block|{
if|if
condition|(
operator|!
name|size
condition|)
name|size
operator|=
literal|1
expr_stmt|;
do|do
name|size
operator|*=
literal|2
expr_stmt|;
do|while
condition|(
name|size
operator|<=
name|newlen
condition|)
do|;
name|reglist
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|reglist
operator|->
name|regexps
operator|=
name|regexps
operator|=
name|xrealloc
argument_list|(
name|regexps
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|multiple_regexps
condition|)
block|{
name|regexps
index|[
name|len
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
name|regexps
index|[
name|len
operator|++
index|]
operator|=
literal|'|'
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|regexps
operator|+
name|len
argument_list|,
name|pattern
argument_list|,
name|patlen
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Ensure that REGLIST represents the disjunction of its regexps.    This is done here, rather than earlier, to avoid O(N^2) behavior.  */
end_comment

begin_function
specifier|static
name|void
name|summarize_regexp_list
parameter_list|(
name|struct
name|regexp_list
modifier|*
name|reglist
parameter_list|)
block|{
if|if
condition|(
name|reglist
operator|->
name|regexps
condition|)
block|{
comment|/* At least one regexp was specified.  Allocate a fastmap for it.  */
name|reglist
operator|->
name|buf
operator|->
name|fastmap
operator|=
name|xmalloc
argument_list|(
literal|1
operator|<<
name|CHAR_BIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|reglist
operator|->
name|multiple_regexps
condition|)
block|{
comment|/* Compile the disjunction of the regexps. 	     (If just one regexp was specified, it is already compiled.)  */
name|char
specifier|const
modifier|*
name|m
init|=
name|re_compile_pattern
argument_list|(
name|reglist
operator|->
name|regexps
argument_list|,
name|reglist
operator|->
name|len
argument_list|,
name|reglist
operator|->
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|!=
literal|0
condition|)
name|error
argument_list|(
name|EXIT_TROUBLE
argument_list|,
literal|0
argument_list|,
literal|"%s: %s"
argument_list|,
name|reglist
operator|->
name|regexps
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|try_help
parameter_list|(
name|char
specifier|const
modifier|*
name|reason_msgid
parameter_list|,
name|char
specifier|const
modifier|*
name|operand
parameter_list|)
block|{
if|if
condition|(
name|reason_msgid
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
name|reason_msgid
argument_list|)
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|EXIT_TROUBLE
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Try `%s --help' for more information."
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_stdout
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"write failed"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fclose
argument_list|(
name|stdout
argument_list|)
operator|!=
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|_
argument_list|(
literal|"standard output"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
specifier|const
name|option_help_msgid
index|[]
init|=
block|{
name|N_
argument_list|(
literal|"Compare files line by line."
argument_list|)
block|,
literal|""
block|,
name|N_
argument_list|(
literal|"-i  --ignore-case  Ignore case differences in file contents."
argument_list|)
block|,
name|N_
argument_list|(
literal|"--ignore-file-name-case  Ignore case when comparing file names."
argument_list|)
block|,
name|N_
argument_list|(
literal|"--no-ignore-file-name-case  Consider case when comparing file names."
argument_list|)
block|,
name|N_
argument_list|(
literal|"-E  --ignore-tab-expansion  Ignore changes due to tab expansion."
argument_list|)
block|,
name|N_
argument_list|(
literal|"-b  --ignore-space-change  Ignore changes in the amount of white space."
argument_list|)
block|,
name|N_
argument_list|(
literal|"-w  --ignore-all-space  Ignore all white space."
argument_list|)
block|,
name|N_
argument_list|(
literal|"-B  --ignore-blank-lines  Ignore changes whose lines are all blank."
argument_list|)
block|,
name|N_
argument_list|(
literal|"-I RE  --ignore-matching-lines=RE  Ignore changes whose lines all match RE."
argument_list|)
block|,
name|N_
argument_list|(
literal|"--strip-trailing-cr  Strip trailing carriage return on input."
argument_list|)
block|,
if|#
directive|if
name|HAVE_SETMODE_DOS
name|N_
argument_list|(
literal|"--binary  Read and write data in binary mode."
argument_list|)
block|,
endif|#
directive|endif
name|N_
argument_list|(
literal|"-a  --text  Treat all files as text."
argument_list|)
block|,
literal|""
block|,
name|N_
argument_list|(
literal|"-c  -C NUM  --context[=NUM]  Output NUM (default 3) lines of copied context.\n\ -u  -U NUM  --unified[=NUM]  Output NUM (default 3) lines of unified context.\n\   --label LABEL  Use LABEL instead of file name.\n\   -p  --show-c-function  Show which C function each change is in.\n\   -F RE  --show-function-line=RE  Show the most recent line matching RE."
argument_list|)
block|,
name|N_
argument_list|(
literal|"-q  --brief  Output only whether files differ."
argument_list|)
block|,
name|N_
argument_list|(
literal|"-e  --ed  Output an ed script."
argument_list|)
block|,
name|N_
argument_list|(
literal|"--normal  Output a normal diff."
argument_list|)
block|,
name|N_
argument_list|(
literal|"-n  --rcs  Output an RCS format diff."
argument_list|)
block|,
name|N_
argument_list|(
literal|"-y  --side-by-side  Output in two columns.\n\   -W NUM  --width=NUM  Output at most NUM (default 130) print columns.\n\   --left-column  Output only the left column of common lines.\n\   --suppress-common-lines  Do not output common lines."
argument_list|)
block|,
name|N_
argument_list|(
literal|"-D NAME  --ifdef=NAME  Output merged file to show `#ifdef NAME' diffs."
argument_list|)
block|,
name|N_
argument_list|(
literal|"--GTYPE-group-format=GFMT  Similar, but format GTYPE input groups with GFMT."
argument_list|)
block|,
name|N_
argument_list|(
literal|"--line-format=LFMT  Similar, but format all input lines with LFMT."
argument_list|)
block|,
name|N_
argument_list|(
literal|"--LTYPE-line-format=LFMT  Similar, but format LTYPE input lines with LFMT."
argument_list|)
block|,
name|N_
argument_list|(
literal|"  LTYPE is `old', `new', or `unchanged'.  GTYPE is LTYPE or `changed'."
argument_list|)
block|,
name|N_
argument_list|(
literal|"  GFMT may contain:\n\     %<  lines from FILE1\n\     %>  lines from FILE2\n\     %=  lines common to FILE1 and FILE2\n\     %[-][WIDTH][.[PREC]]{doxX}LETTER  printf-style spec for LETTER\n\       LETTERs are as follows for new group, lower case for old group:\n\         F  first line number\n\         L  last line number\n\         N  number of lines = L-F+1\n\         E  F-1\n\         M  L+1"
argument_list|)
block|,
name|N_
argument_list|(
literal|"  LFMT may contain:\n\     %L  contents of line\n\     %l  contents of line, excluding any trailing newline\n\     %[-][WIDTH][.[PREC]]{doxX}n  printf-style spec for input line number"
argument_list|)
block|,
name|N_
argument_list|(
literal|"  Either GFMT or LFMT may contain:\n\     %%  %\n\     %c'C'  the single character C\n\     %c'\\OOO'  the character with octal code OOO"
argument_list|)
block|,
literal|""
block|,
name|N_
argument_list|(
literal|"-l  --paginate  Pass the output through `pr' to paginate it."
argument_list|)
block|,
name|N_
argument_list|(
literal|"-t  --expand-tabs  Expand tabs to spaces in output."
argument_list|)
block|,
name|N_
argument_list|(
literal|"-T  --initial-tab  Make tabs line up by prepending a tab."
argument_list|)
block|,
name|N_
argument_list|(
literal|"--tabsize=NUM  Tab stops are every NUM (default 8) print columns."
argument_list|)
block|,
literal|""
block|,
name|N_
argument_list|(
literal|"-r  --recursive  Recursively compare any subdirectories found."
argument_list|)
block|,
name|N_
argument_list|(
literal|"-N  --new-file  Treat absent files as empty."
argument_list|)
block|,
name|N_
argument_list|(
literal|"--unidirectional-new-file  Treat absent first files as empty."
argument_list|)
block|,
name|N_
argument_list|(
literal|"-s  --report-identical-files  Report when two files are the same."
argument_list|)
block|,
name|N_
argument_list|(
literal|"-x PAT  --exclude=PAT  Exclude files that match PAT."
argument_list|)
block|,
name|N_
argument_list|(
literal|"-X FILE  --exclude-from=FILE  Exclude files that match any pattern in FILE."
argument_list|)
block|,
name|N_
argument_list|(
literal|"-S FILE  --starting-file=FILE  Start with FILE when comparing directories."
argument_list|)
block|,
name|N_
argument_list|(
literal|"--from-file=FILE1  Compare FILE1 to all operands.  FILE1 can be a directory."
argument_list|)
block|,
name|N_
argument_list|(
literal|"--to-file=FILE2  Compare all operands to FILE2.  FILE2 can be a directory."
argument_list|)
block|,
literal|""
block|,
name|N_
argument_list|(
literal|"--horizon-lines=NUM  Keep NUM lines of the common prefix and suffix."
argument_list|)
block|,
name|N_
argument_list|(
literal|"-d  --minimal  Try hard to find a smaller set of changes."
argument_list|)
block|,
name|N_
argument_list|(
literal|"--speed-large-files  Assume large files and many scattered small changes."
argument_list|)
block|,
literal|""
block|,
name|N_
argument_list|(
literal|"-v  --version  Output version info."
argument_list|)
block|,
name|N_
argument_list|(
literal|"--help  Output this help."
argument_list|)
block|,
literal|""
block|,
name|N_
argument_list|(
literal|"FILES are `FILE1 FILE2' or `DIR1 DIR2' or `DIR FILE...' or `FILE... DIR'."
argument_list|)
block|,
name|N_
argument_list|(
literal|"If --from-file or --to-file is given, there are no restrictions on FILES."
argument_list|)
block|,
name|N_
argument_list|(
literal|"If a FILE is `-', read standard input."
argument_list|)
block|,
name|N_
argument_list|(
literal|"Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."
argument_list|)
block|,
literal|""
block|,
name|N_
argument_list|(
literal|"Report bugs to<bug-gnu-utils@gnu.org>."
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|p
decl_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"Usage: %s [OPTION]... FILES\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|option_help_msgid
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|*
operator|*
name|p
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
else|else
block|{
name|char
specifier|const
modifier|*
name|msg
init|=
name|_
argument_list|(
operator|*
name|p
argument_list|)
decl_stmt|;
name|char
specifier|const
modifier|*
name|nl
decl_stmt|;
while|while
condition|(
operator|(
name|nl
operator|=
name|strchr
argument_list|(
name|msg
argument_list|,
literal|'\n'
argument_list|)
operator|)
condition|)
block|{
name|int
name|msglen
init|=
name|nl
operator|+
literal|1
operator|-
name|msg
decl_stmt|;
name|printf
argument_list|(
literal|"  %.*s"
argument_list|,
name|msglen
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|msg
operator|=
name|nl
operator|+
literal|1
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  %s\n"
operator|+
literal|2
operator|*
operator|(
operator|*
name|msg
operator|!=
literal|' '
operator|&&
operator|*
name|msg
operator|!=
literal|'-'
operator|)
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Set VAR to VALUE, reporting an OPTION error if this is a    conflict.  */
end_comment

begin_function
specifier|static
name|void
name|specify_value
parameter_list|(
name|char
specifier|const
modifier|*
modifier|*
name|var
parameter_list|,
name|char
specifier|const
modifier|*
name|value
parameter_list|,
name|char
specifier|const
modifier|*
name|option
parameter_list|)
block|{
if|if
condition|(
operator|*
name|var
operator|&&
name|strcmp
argument_list|(
operator|*
name|var
argument_list|,
name|value
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"conflicting %s option value `%s'"
argument_list|)
argument_list|,
name|option
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|try_help
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
operator|*
name|var
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the output style to STYLE, diagnosing conflicts.  */
end_comment

begin_function
specifier|static
name|void
name|specify_style
parameter_list|(
name|enum
name|output_style
name|style
parameter_list|)
block|{
if|if
condition|(
name|output_style
operator|!=
name|style
condition|)
block|{
if|if
condition|(
name|output_style
operator|!=
name|OUTPUT_UNSPECIFIED
condition|)
name|try_help
argument_list|(
literal|"conflicting output style options"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|output_style
operator|=
name|style
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set the last-modified time of *ST to be the current time.  */
end_comment

begin_function
specifier|static
name|void
name|set_mtime_to_now
parameter_list|(
name|struct
name|stat
modifier|*
name|st
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ST_MTIM_NSEC
if|#
directive|if
name|HAVE_CLOCK_GETTIME
operator|&&
name|defined
name|CLOCK_REALTIME
if|if
condition|(
name|clock_gettime
argument_list|(
name|CLOCK_REALTIME
argument_list|,
operator|&
name|st
operator|->
name|st_mtim
argument_list|)
operator|==
literal|0
condition|)
return|return;
endif|#
directive|endif
if|#
directive|if
name|HAVE_GETTIMEOFDAY
block|{
name|struct
name|timeval
name|timeval
decl_stmt|;
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|timeval
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|st
operator|->
name|st_mtime
operator|=
name|timeval
operator|.
name|tv_sec
expr_stmt|;
name|st
operator|->
name|st_mtim
operator|.
name|ST_MTIM_NSEC
operator|=
name|timeval
operator|.
name|tv_usec
operator|*
literal|1000
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* ST_MTIM_NSEC */
name|time
argument_list|(
operator|&
name|st
operator|->
name|st_mtime
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compare two files (or dirs) with parent comparison PARENT    and names NAME0 and NAME1.    (If PARENT is 0, then the first name is just NAME0, etc.)    This is self-contained; it opens the files and closes them.     Value is EXIT_SUCCESS if files are the same, EXIT_FAILURE if    different, EXIT_TROUBLE if there is a problem opening them.  */
end_comment

begin_function
specifier|static
name|int
name|compare_files
parameter_list|(
name|struct
name|comparison
specifier|const
modifier|*
name|parent
parameter_list|,
name|char
specifier|const
modifier|*
name|name0
parameter_list|,
name|char
specifier|const
modifier|*
name|name1
parameter_list|)
block|{
name|struct
name|comparison
name|cmp
decl_stmt|;
define|#
directive|define
name|DIR_P
parameter_list|(
name|f
parameter_list|)
value|(S_ISDIR (cmp.file[f].stat.st_mode) != 0)
specifier|register
name|int
name|f
decl_stmt|;
name|int
name|status
init|=
name|EXIT_SUCCESS
decl_stmt|;
name|bool
name|same_files
decl_stmt|;
name|char
modifier|*
name|free0
decl_stmt|,
modifier|*
name|free1
decl_stmt|;
comment|/* If this is directory comparison, perhaps we have a file      that exists only in one of the directories.      If so, just print a message to that effect.  */
if|if
condition|(
operator|!
operator|(
operator|(
name|name0
operator|&&
name|name1
operator|)
operator|||
operator|(
name|unidirectional_new_file
operator|&&
name|name1
operator|)
operator|||
name|new_file
operator|)
condition|)
block|{
name|char
specifier|const
modifier|*
name|name
init|=
name|name0
operator|==
literal|0
condition|?
name|name1
else|:
name|name0
decl_stmt|;
name|char
specifier|const
modifier|*
name|dir
init|=
name|parent
operator|->
name|file
index|[
name|name0
operator|==
literal|0
index|]
operator|.
name|name
decl_stmt|;
comment|/* See POSIX 1003.1-2001 for this format.  */
name|message
argument_list|(
literal|"Only in %s: %s\n"
argument_list|,
name|dir
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Return EXIT_FAILURE so that diff_dirs will return 	 EXIT_FAILURE ("some files differ").  */
return|return
name|EXIT_FAILURE
return|;
block|}
name|memset
argument_list|(
name|cmp
operator|.
name|file
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|cmp
operator|.
name|file
argument_list|)
expr_stmt|;
name|cmp
operator|.
name|parent
operator|=
name|parent
expr_stmt|;
comment|/* cmp.file[f].desc markers */
define|#
directive|define
name|NONEXISTENT
value|(-1)
comment|/* nonexistent file */
define|#
directive|define
name|UNOPENED
value|(-2)
comment|/* unopened file (e.g. directory) */
define|#
directive|define
name|ERRNO_ENCODE
parameter_list|(
name|errno
parameter_list|)
value|(-3 - (errno))
comment|/* encoded errno value */
define|#
directive|define
name|ERRNO_DECODE
parameter_list|(
name|desc
parameter_list|)
value|(-3 - (desc))
comment|/* inverse of ERRNO_ENCODE */
name|cmp
operator|.
name|file
index|[
literal|0
index|]
operator|.
name|desc
operator|=
name|name0
operator|==
literal|0
condition|?
name|NONEXISTENT
else|:
name|UNOPENED
expr_stmt|;
name|cmp
operator|.
name|file
index|[
literal|1
index|]
operator|.
name|desc
operator|=
name|name1
operator|==
literal|0
condition|?
name|NONEXISTENT
else|:
name|UNOPENED
expr_stmt|;
comment|/* Now record the full name of each file, including nonexistent ones.  */
if|if
condition|(
name|name0
operator|==
literal|0
condition|)
name|name0
operator|=
name|name1
expr_stmt|;
if|if
condition|(
name|name1
operator|==
literal|0
condition|)
name|name1
operator|=
name|name0
expr_stmt|;
if|if
condition|(
operator|!
name|parent
condition|)
block|{
name|free0
operator|=
literal|0
expr_stmt|;
name|free1
operator|=
literal|0
expr_stmt|;
name|cmp
operator|.
name|file
index|[
literal|0
index|]
operator|.
name|name
operator|=
name|name0
expr_stmt|;
name|cmp
operator|.
name|file
index|[
literal|1
index|]
operator|.
name|name
operator|=
name|name1
expr_stmt|;
block|}
else|else
block|{
name|cmp
operator|.
name|file
index|[
literal|0
index|]
operator|.
name|name
operator|=
name|free0
operator|=
name|dir_file_pathname
argument_list|(
name|parent
operator|->
name|file
index|[
literal|0
index|]
operator|.
name|name
argument_list|,
name|name0
argument_list|)
expr_stmt|;
name|cmp
operator|.
name|file
index|[
literal|1
index|]
operator|.
name|name
operator|=
name|free1
operator|=
name|dir_file_pathname
argument_list|(
name|parent
operator|->
name|file
index|[
literal|1
index|]
operator|.
name|name
argument_list|,
name|name1
argument_list|)
expr_stmt|;
block|}
comment|/* Stat the files.  */
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
literal|2
condition|;
name|f
operator|++
control|)
block|{
if|if
condition|(
name|cmp
operator|.
name|file
index|[
name|f
index|]
operator|.
name|desc
operator|!=
name|NONEXISTENT
condition|)
block|{
if|if
condition|(
name|f
operator|&&
name|file_name_cmp
argument_list|(
name|cmp
operator|.
name|file
index|[
name|f
index|]
operator|.
name|name
argument_list|,
name|cmp
operator|.
name|file
index|[
literal|0
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmp
operator|.
name|file
index|[
name|f
index|]
operator|.
name|desc
operator|=
name|cmp
operator|.
name|file
index|[
literal|0
index|]
operator|.
name|desc
expr_stmt|;
name|cmp
operator|.
name|file
index|[
name|f
index|]
operator|.
name|stat
operator|=
name|cmp
operator|.
name|file
index|[
literal|0
index|]
operator|.
name|stat
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cmp
operator|.
name|file
index|[
name|f
index|]
operator|.
name|name
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmp
operator|.
name|file
index|[
name|f
index|]
operator|.
name|desc
operator|=
name|STDIN_FILENO
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|&
name|cmp
operator|.
name|file
index|[
name|f
index|]
operator|.
name|stat
argument_list|)
operator|!=
literal|0
condition|)
name|cmp
operator|.
name|file
index|[
name|f
index|]
operator|.
name|desc
operator|=
name|ERRNO_ENCODE
argument_list|(
name|errno
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|S_ISREG
argument_list|(
name|cmp
operator|.
name|file
index|[
name|f
index|]
operator|.
name|stat
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|off_t
name|pos
init|=
name|lseek
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
name|cmp
operator|.
name|file
index|[
name|f
index|]
operator|.
name|desc
operator|=
name|ERRNO_ENCODE
argument_list|(
name|errno
argument_list|)
expr_stmt|;
else|else
name|cmp
operator|.
name|file
index|[
name|f
index|]
operator|.
name|stat
operator|.
name|st_size
operator|=
name|MAX
argument_list|(
literal|0
argument_list|,
name|cmp
operator|.
name|file
index|[
name|f
index|]
operator|.
name|stat
operator|.
name|st_size
operator|-
name|pos
argument_list|)
expr_stmt|;
block|}
comment|/* POSIX 1003.1-2001 requires current time for 		     stdin.  */
name|set_mtime_to_now
argument_list|(
operator|&
name|cmp
operator|.
name|file
index|[
name|f
index|]
operator|.
name|stat
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|stat
argument_list|(
name|cmp
operator|.
name|file
index|[
name|f
index|]
operator|.
name|name
argument_list|,
operator|&
name|cmp
operator|.
name|file
index|[
name|f
index|]
operator|.
name|stat
argument_list|)
operator|!=
literal|0
condition|)
name|cmp
operator|.
name|file
index|[
name|f
index|]
operator|.
name|desc
operator|=
name|ERRNO_ENCODE
argument_list|(
name|errno
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Mark files as nonexistent as needed for -N and -P, if they are      inaccessible empty regular files (the kind of files that 'patch'      creates to indicate nonexistent backups), or if they are      top-level files that do not exist but their counterparts do      exist.  */
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
literal|2
condition|;
name|f
operator|++
control|)
if|if
condition|(
operator|(
name|new_file
operator|||
operator|(
name|f
operator|==
literal|0
operator|&&
name|unidirectional_new_file
operator|)
operator|)
operator|&&
operator|(
name|cmp
operator|.
name|file
index|[
name|f
index|]
operator|.
name|desc
operator|==
name|UNOPENED
condition|?
operator|(
name|S_ISREG
argument_list|(
name|cmp
operator|.
name|file
index|[
name|f
index|]
operator|.
name|stat
operator|.
name|st_mode
argument_list|)
operator|&&
operator|!
operator|(
name|cmp
operator|.
name|file
index|[
name|f
index|]
operator|.
name|stat
operator|.
name|st_mode
operator|&
operator|(
name|S_IRWXU
operator||
name|S_IRWXG
operator||
name|S_IRWXO
operator|)
operator|)
operator|&&
name|cmp
operator|.
name|file
index|[
name|f
index|]
operator|.
name|stat
operator|.
name|st_size
operator|==
literal|0
operator|)
else|:
operator|(
name|cmp
operator|.
name|file
index|[
name|f
index|]
operator|.
name|desc
operator|==
name|ERRNO_ENCODE
argument_list|(
name|ENOENT
argument_list|)
operator|&&
operator|!
name|parent
operator|&&
name|cmp
operator|.
name|file
index|[
literal|1
operator|-
name|f
index|]
operator|.
name|desc
operator|==
name|UNOPENED
operator|)
operator|)
condition|)
name|cmp
operator|.
name|file
index|[
name|f
index|]
operator|.
name|desc
operator|=
name|NONEXISTENT
expr_stmt|;
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
literal|2
condition|;
name|f
operator|++
control|)
if|if
condition|(
name|cmp
operator|.
name|file
index|[
name|f
index|]
operator|.
name|desc
operator|==
name|NONEXISTENT
condition|)
block|{
name|memset
argument_list|(
operator|&
name|cmp
operator|.
name|file
index|[
name|f
index|]
operator|.
name|stat
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|cmp
operator|.
name|file
index|[
name|f
index|]
operator|.
name|stat
argument_list|)
expr_stmt|;
name|cmp
operator|.
name|file
index|[
name|f
index|]
operator|.
name|stat
operator|.
name|st_mode
operator|=
name|cmp
operator|.
name|file
index|[
literal|1
operator|-
name|f
index|]
operator|.
name|stat
operator|.
name|st_mode
expr_stmt|;
block|}
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
literal|2
condition|;
name|f
operator|++
control|)
block|{
name|int
name|e
init|=
name|ERRNO_DECODE
argument_list|(
name|cmp
operator|.
name|file
index|[
name|f
index|]
operator|.
name|desc
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|<=
name|e
condition|)
block|{
name|errno
operator|=
name|e
expr_stmt|;
name|perror_with_name
argument_list|(
name|cmp
operator|.
name|file
index|[
name|f
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|status
operator|=
name|EXIT_TROUBLE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|status
operator|==
name|EXIT_SUCCESS
operator|&&
operator|!
name|parent
operator|&&
name|DIR_P
argument_list|(
literal|0
argument_list|)
operator|!=
name|DIR_P
argument_list|(
literal|1
argument_list|)
condition|)
block|{
comment|/* If one is a directory, and it was specified in the command line, 	 use the file in that dir with the other file's basename.  */
name|int
name|fnm_arg
init|=
name|DIR_P
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|dir_arg
init|=
literal|1
operator|-
name|fnm_arg
decl_stmt|;
name|char
specifier|const
modifier|*
name|fnm
init|=
name|cmp
operator|.
name|file
index|[
name|fnm_arg
index|]
operator|.
name|name
decl_stmt|;
name|char
specifier|const
modifier|*
name|dir
init|=
name|cmp
operator|.
name|file
index|[
name|dir_arg
index|]
operator|.
name|name
decl_stmt|;
name|char
specifier|const
modifier|*
name|filename
init|=
name|cmp
operator|.
name|file
index|[
name|dir_arg
index|]
operator|.
name|name
operator|=
name|free0
operator|=
name|dir_file_pathname
argument_list|(
name|dir
argument_list|,
name|base_name
argument_list|(
name|fnm
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|fnm
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"cannot compare `-' to a directory"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|cmp
operator|.
name|file
index|[
name|dir_arg
index|]
operator|.
name|stat
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|status
operator|=
name|EXIT_TROUBLE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|status
operator|!=
name|EXIT_SUCCESS
condition|)
block|{
comment|/* One of the files should exist but does not.  */
block|}
elseif|else
if|if
condition|(
name|cmp
operator|.
name|file
index|[
literal|0
index|]
operator|.
name|desc
operator|==
name|NONEXISTENT
operator|&&
name|cmp
operator|.
name|file
index|[
literal|1
index|]
operator|.
name|desc
operator|==
name|NONEXISTENT
condition|)
block|{
comment|/* Neither file "exists", so there's nothing to compare.  */
block|}
elseif|else
if|if
condition|(
operator|(
name|same_files
operator|=
operator|(
name|cmp
operator|.
name|file
index|[
literal|0
index|]
operator|.
name|desc
operator|!=
name|NONEXISTENT
operator|&&
name|cmp
operator|.
name|file
index|[
literal|1
index|]
operator|.
name|desc
operator|!=
name|NONEXISTENT
operator|&&
literal|0
operator|<
name|same_file
argument_list|(
operator|&
name|cmp
operator|.
name|file
index|[
literal|0
index|]
operator|.
name|stat
argument_list|,
operator|&
name|cmp
operator|.
name|file
index|[
literal|1
index|]
operator|.
name|stat
argument_list|)
operator|&&
name|same_file_attributes
argument_list|(
operator|&
name|cmp
operator|.
name|file
index|[
literal|0
index|]
operator|.
name|stat
argument_list|,
operator|&
name|cmp
operator|.
name|file
index|[
literal|1
index|]
operator|.
name|stat
argument_list|)
operator|)
operator|)
operator|&&
name|no_diff_means_no_output
condition|)
block|{
comment|/* The two named files are actually the same physical file. 	 We know they are identical without actually reading them.  */
block|}
elseif|else
if|if
condition|(
name|DIR_P
argument_list|(
literal|0
argument_list|)
operator|&
name|DIR_P
argument_list|(
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|output_style
operator|==
name|OUTPUT_IFDEF
condition|)
name|fatal
argument_list|(
literal|"-D option not supported with directories"
argument_list|)
expr_stmt|;
comment|/* If both are directories, compare the files in them.  */
if|if
condition|(
name|parent
operator|&&
operator|!
name|recursive
condition|)
block|{
comment|/* But don't compare dir contents one level down 	     unless -r was specified. 	     See POSIX 1003.1-2001 for this format.  */
name|message
argument_list|(
literal|"Common subdirectories: %s and %s\n"
argument_list|,
name|cmp
operator|.
name|file
index|[
literal|0
index|]
operator|.
name|name
argument_list|,
name|cmp
operator|.
name|file
index|[
literal|1
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|status
operator|=
name|diff_dirs
argument_list|(
operator|&
name|cmp
argument_list|,
name|compare_files
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|DIR_P
argument_list|(
literal|0
argument_list|)
operator||
name|DIR_P
argument_list|(
literal|1
argument_list|)
operator|)
operator|||
operator|(
name|parent
operator|&&
operator|(
operator|!
name|S_ISREG
argument_list|(
name|cmp
operator|.
name|file
index|[
literal|0
index|]
operator|.
name|stat
operator|.
name|st_mode
argument_list|)
operator|||
operator|!
name|S_ISREG
argument_list|(
name|cmp
operator|.
name|file
index|[
literal|1
index|]
operator|.
name|stat
operator|.
name|st_mode
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|cmp
operator|.
name|file
index|[
literal|0
index|]
operator|.
name|desc
operator|==
name|NONEXISTENT
operator|||
name|cmp
operator|.
name|file
index|[
literal|1
index|]
operator|.
name|desc
operator|==
name|NONEXISTENT
condition|)
block|{
comment|/* We have a subdirectory that exists only in one directory.  */
if|if
condition|(
operator|(
name|DIR_P
argument_list|(
literal|0
argument_list|)
operator||
name|DIR_P
argument_list|(
literal|1
argument_list|)
operator|)
operator|&&
name|recursive
operator|&&
operator|(
name|new_file
operator|||
operator|(
name|unidirectional_new_file
operator|&&
name|cmp
operator|.
name|file
index|[
literal|0
index|]
operator|.
name|desc
operator|==
name|NONEXISTENT
operator|)
operator|)
condition|)
name|status
operator|=
name|diff_dirs
argument_list|(
operator|&
name|cmp
argument_list|,
name|compare_files
argument_list|)
expr_stmt|;
else|else
block|{
name|char
specifier|const
modifier|*
name|dir
init|=
name|parent
operator|->
name|file
index|[
name|cmp
operator|.
name|file
index|[
literal|0
index|]
operator|.
name|desc
operator|==
name|NONEXISTENT
index|]
operator|.
name|name
decl_stmt|;
comment|/* See POSIX 1003.1-2001 for this format.  */
name|message
argument_list|(
literal|"Only in %s: %s\n"
argument_list|,
name|dir
argument_list|,
name|name0
argument_list|)
expr_stmt|;
name|status
operator|=
name|EXIT_FAILURE
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We have two files that are not to be compared.  */
comment|/* See POSIX 1003.1-2001 for this format.  */
name|message5
argument_list|(
literal|"File %s is a %s while file %s is a %s\n"
argument_list|,
name|file_label
index|[
literal|0
index|]
condition|?
name|file_label
index|[
literal|0
index|]
else|:
name|cmp
operator|.
name|file
index|[
literal|0
index|]
operator|.
name|name
argument_list|,
name|file_type
argument_list|(
operator|&
name|cmp
operator|.
name|file
index|[
literal|0
index|]
operator|.
name|stat
argument_list|)
argument_list|,
name|file_label
index|[
literal|1
index|]
condition|?
name|file_label
index|[
literal|1
index|]
else|:
name|cmp
operator|.
name|file
index|[
literal|1
index|]
operator|.
name|name
argument_list|,
name|file_type
argument_list|(
operator|&
name|cmp
operator|.
name|file
index|[
literal|1
index|]
operator|.
name|stat
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This is a difference.  */
name|status
operator|=
name|EXIT_FAILURE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|files_can_be_treated_as_binary
operator|&&
name|S_ISREG
argument_list|(
name|cmp
operator|.
name|file
index|[
literal|0
index|]
operator|.
name|stat
operator|.
name|st_mode
argument_list|)
operator|&&
name|S_ISREG
argument_list|(
name|cmp
operator|.
name|file
index|[
literal|1
index|]
operator|.
name|stat
operator|.
name|st_mode
argument_list|)
operator|&&
name|cmp
operator|.
name|file
index|[
literal|0
index|]
operator|.
name|stat
operator|.
name|st_size
operator|!=
name|cmp
operator|.
name|file
index|[
literal|1
index|]
operator|.
name|stat
operator|.
name|st_size
condition|)
block|{
name|message
argument_list|(
literal|"Files %s and %s differ\n"
argument_list|,
name|file_label
index|[
literal|0
index|]
condition|?
name|file_label
index|[
literal|0
index|]
else|:
name|cmp
operator|.
name|file
index|[
literal|0
index|]
operator|.
name|name
argument_list|,
name|file_label
index|[
literal|1
index|]
condition|?
name|file_label
index|[
literal|1
index|]
else|:
name|cmp
operator|.
name|file
index|[
literal|1
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|status
operator|=
name|EXIT_FAILURE
expr_stmt|;
block|}
else|else
block|{
comment|/* Both exist and neither is a directory.  */
comment|/* Open the files and record their descriptors.  */
if|if
condition|(
name|cmp
operator|.
name|file
index|[
literal|0
index|]
operator|.
name|desc
operator|==
name|UNOPENED
condition|)
if|if
condition|(
operator|(
name|cmp
operator|.
name|file
index|[
literal|0
index|]
operator|.
name|desc
operator|=
name|open
argument_list|(
name|cmp
operator|.
name|file
index|[
literal|0
index|]
operator|.
name|name
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror_with_name
argument_list|(
name|cmp
operator|.
name|file
index|[
literal|0
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|status
operator|=
name|EXIT_TROUBLE
expr_stmt|;
block|}
if|if
condition|(
name|cmp
operator|.
name|file
index|[
literal|1
index|]
operator|.
name|desc
operator|==
name|UNOPENED
condition|)
block|{
if|if
condition|(
name|same_files
condition|)
name|cmp
operator|.
name|file
index|[
literal|1
index|]
operator|.
name|desc
operator|=
name|cmp
operator|.
name|file
index|[
literal|0
index|]
operator|.
name|desc
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|cmp
operator|.
name|file
index|[
literal|1
index|]
operator|.
name|desc
operator|=
name|open
argument_list|(
name|cmp
operator|.
name|file
index|[
literal|1
index|]
operator|.
name|name
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror_with_name
argument_list|(
name|cmp
operator|.
name|file
index|[
literal|1
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|status
operator|=
name|EXIT_TROUBLE
expr_stmt|;
block|}
block|}
if|#
directive|if
name|HAVE_SETMODE_DOS
if|if
condition|(
name|binary
condition|)
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
literal|2
condition|;
name|f
operator|++
control|)
if|if
condition|(
literal|0
operator|<=
name|cmp
operator|.
name|file
index|[
name|f
index|]
operator|.
name|desc
condition|)
name|set_binary_mode
argument_list|(
name|cmp
operator|.
name|file
index|[
name|f
index|]
operator|.
name|desc
argument_list|,
name|true
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Compare the files, if no error was found.  */
if|if
condition|(
name|status
operator|==
name|EXIT_SUCCESS
condition|)
name|status
operator|=
name|diff_2_files
argument_list|(
operator|&
name|cmp
argument_list|)
expr_stmt|;
comment|/* Close the file descriptors.  */
if|if
condition|(
literal|0
operator|<=
name|cmp
operator|.
name|file
index|[
literal|0
index|]
operator|.
name|desc
operator|&&
name|close
argument_list|(
name|cmp
operator|.
name|file
index|[
literal|0
index|]
operator|.
name|desc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|perror_with_name
argument_list|(
name|cmp
operator|.
name|file
index|[
literal|0
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|status
operator|=
name|EXIT_TROUBLE
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|<=
name|cmp
operator|.
name|file
index|[
literal|1
index|]
operator|.
name|desc
operator|&&
name|cmp
operator|.
name|file
index|[
literal|0
index|]
operator|.
name|desc
operator|!=
name|cmp
operator|.
name|file
index|[
literal|1
index|]
operator|.
name|desc
operator|&&
name|close
argument_list|(
name|cmp
operator|.
name|file
index|[
literal|1
index|]
operator|.
name|desc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|perror_with_name
argument_list|(
name|cmp
operator|.
name|file
index|[
literal|1
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|status
operator|=
name|EXIT_TROUBLE
expr_stmt|;
block|}
block|}
comment|/* Now the comparison has been done, if no error prevented it,      and STATUS is the value this function will return.  */
if|if
condition|(
name|status
operator|==
name|EXIT_SUCCESS
condition|)
block|{
if|if
condition|(
name|report_identical_files
operator|&&
operator|!
name|DIR_P
argument_list|(
literal|0
argument_list|)
condition|)
name|message
argument_list|(
literal|"Files %s and %s are identical\n"
argument_list|,
name|file_label
index|[
literal|0
index|]
condition|?
name|file_label
index|[
literal|0
index|]
else|:
name|cmp
operator|.
name|file
index|[
literal|0
index|]
operator|.
name|name
argument_list|,
name|file_label
index|[
literal|1
index|]
condition|?
name|file_label
index|[
literal|1
index|]
else|:
name|cmp
operator|.
name|file
index|[
literal|1
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Flush stdout so that the user sees differences immediately. 	 This can hurt performance, unfortunately.  */
if|if
condition|(
name|fflush
argument_list|(
name|stdout
argument_list|)
operator|!=
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|_
argument_list|(
literal|"standard output"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|free0
condition|)
name|free
argument_list|(
name|free0
argument_list|)
expr_stmt|;
if|if
condition|(
name|free1
condition|)
name|free
argument_list|(
name|free1
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

end_unit

