begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1991,1992,1993,1996,1997,1998,1999,2000,2001,2002,2003,2004 	Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software Foundation,    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Match STRING against the filename pattern PATTERN, returning zero if    it matches, nonzero if not.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|EXT
argument_list|(
name|INT
name|opt
argument_list|,
specifier|const
name|CHAR
operator|*
name|pattern
argument_list|,
specifier|const
name|CHAR
operator|*
name|string
argument_list|,
specifier|const
name|CHAR
operator|*
name|string_end
argument_list|,
name|int
name|no_leading_period
argument_list|,
name|int
name|flags
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|CHAR
modifier|*
name|END
argument_list|(
specifier|const
name|CHAR
operator|*
name|patternp
argument_list|)
name|internal_function
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|internal_function
name|FCT
parameter_list|(
specifier|const
name|CHAR
modifier|*
name|pattern
parameter_list|,
specifier|const
name|CHAR
modifier|*
name|string
parameter_list|,
specifier|const
name|CHAR
modifier|*
name|string_end
parameter_list|,
name|int
name|no_leading_period
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
specifier|register
specifier|const
name|CHAR
modifier|*
name|p
init|=
name|pattern
decl_stmt|,
modifier|*
name|n
init|=
name|string
decl_stmt|;
specifier|register
name|UCHAR
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
if|#
directive|if
name|WIDE_CHAR_VERSION
specifier|const
name|char
modifier|*
name|collseq
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_COLLSEQWC
argument_list|)
decl_stmt|;
else|#
directive|else
specifier|const
name|UCHAR
modifier|*
name|collseq
init|=
operator|(
specifier|const
name|UCHAR
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_COLLSEQMB
argument_list|)
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
name|L
argument_list|(
literal|'\0'
argument_list|)
condition|)
block|{
name|int
name|new_no_leading_period
init|=
literal|0
decl_stmt|;
name|c
operator|=
name|FOLD
argument_list|(
name|c
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|L
argument_list|(
literal|'?'
argument_list|)
case|:
if|if
condition|(
name|__builtin_expect
argument_list|(
name|flags
operator|&
name|FNM_EXTMATCH
argument_list|,
literal|0
argument_list|)
operator|&&
operator|*
name|p
operator|==
literal|'('
condition|)
block|{
name|int
name|res
decl_stmt|;
name|res
operator|=
name|EXT
argument_list|(
name|c
argument_list|,
name|p
argument_list|,
name|n
argument_list|,
name|string_end
argument_list|,
name|no_leading_period
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
operator|-
literal|1
condition|)
return|return
name|res
return|;
block|}
if|if
condition|(
name|n
operator|==
name|string_end
condition|)
return|return
name|FNM_NOMATCH
return|;
elseif|else
if|if
condition|(
operator|*
name|n
operator|==
name|L
argument_list|(
literal|'/'
argument_list|)
operator|&&
operator|(
name|flags
operator|&
name|FNM_FILE_NAME
operator|)
condition|)
return|return
name|FNM_NOMATCH
return|;
elseif|else
if|if
condition|(
operator|*
name|n
operator|==
name|L
argument_list|(
literal|'.'
argument_list|)
operator|&&
name|no_leading_period
condition|)
return|return
name|FNM_NOMATCH
return|;
break|break;
case|case
name|L
argument_list|(
literal|'\\'
argument_list|)
case|:
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|FNM_NOESCAPE
operator|)
condition|)
block|{
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|L
argument_list|(
literal|'\0'
argument_list|)
condition|)
comment|/* Trailing \ loses.  */
return|return
name|FNM_NOMATCH
return|;
name|c
operator|=
name|FOLD
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
name|string_end
operator|||
name|FOLD
argument_list|(
operator|(
name|UCHAR
operator|)
operator|*
name|n
argument_list|)
operator|!=
name|c
condition|)
return|return
name|FNM_NOMATCH
return|;
break|break;
case|case
name|L
argument_list|(
literal|'*'
argument_list|)
case|:
if|if
condition|(
name|__builtin_expect
argument_list|(
name|flags
operator|&
name|FNM_EXTMATCH
argument_list|,
literal|0
argument_list|)
operator|&&
operator|*
name|p
operator|==
literal|'('
condition|)
block|{
name|int
name|res
decl_stmt|;
name|res
operator|=
name|EXT
argument_list|(
name|c
argument_list|,
name|p
argument_list|,
name|n
argument_list|,
name|string_end
argument_list|,
name|no_leading_period
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
operator|-
literal|1
condition|)
return|return
name|res
return|;
block|}
if|if
condition|(
name|n
operator|!=
name|string_end
operator|&&
operator|*
name|n
operator|==
name|L
argument_list|(
literal|'.'
argument_list|)
operator|&&
name|no_leading_period
condition|)
return|return
name|FNM_NOMATCH
return|;
for|for
control|(
name|c
operator|=
operator|*
name|p
operator|++
init|;
name|c
operator|==
name|L
argument_list|(
literal|'?'
argument_list|)
operator|||
name|c
operator|==
name|L
argument_list|(
literal|'*'
argument_list|)
condition|;
name|c
operator|=
operator|*
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
name|L
argument_list|(
literal|'('
argument_list|)
operator|&&
operator|(
name|flags
operator|&
name|FNM_EXTMATCH
operator|)
operator|!=
literal|0
condition|)
block|{
specifier|const
name|CHAR
modifier|*
name|endp
init|=
name|END
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|endp
operator|!=
name|p
condition|)
block|{
comment|/* This is a pattern.  Skip over it.  */
name|p
operator|=
name|endp
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|c
operator|==
name|L
argument_list|(
literal|'?'
argument_list|)
condition|)
block|{
comment|/* A ? needs to match one character.  */
if|if
condition|(
name|n
operator|==
name|string_end
condition|)
comment|/* There isn't another character; no match.  */
return|return
name|FNM_NOMATCH
return|;
elseif|else
if|if
condition|(
operator|*
name|n
operator|==
name|L
argument_list|(
literal|'/'
argument_list|)
operator|&&
name|__builtin_expect
argument_list|(
name|flags
operator|&
name|FNM_FILE_NAME
argument_list|,
literal|0
argument_list|)
condition|)
comment|/* A slash does not match a wildcard under 		       FNM_FILE_NAME.  */
return|return
name|FNM_NOMATCH
return|;
else|else
comment|/* One character of the string is consumed in matching 		       this ? wildcard, so *??? won't match if there are 		       less than three characters.  */
operator|++
name|n
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|==
name|L
argument_list|(
literal|'\0'
argument_list|)
condition|)
comment|/* The wildcard(s) is/are the last element of the pattern. 	       If the name is a file name and contains another slash 	       this means it cannot match, unless the FNM_LEADING_DIR 	       flag is set.  */
block|{
name|int
name|result
init|=
operator|(
name|flags
operator|&
name|FNM_FILE_NAME
operator|)
operator|==
literal|0
condition|?
literal|0
else|:
name|FNM_NOMATCH
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|FNM_FILE_NAME
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|FNM_LEADING_DIR
condition|)
name|result
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|MEMCHR
argument_list|(
name|n
argument_list|,
name|L
argument_list|(
literal|'/'
argument_list|)
argument_list|,
name|string_end
operator|-
name|n
argument_list|)
operator|==
name|NULL
condition|)
name|result
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
else|else
block|{
specifier|const
name|CHAR
modifier|*
name|endp
decl_stmt|;
name|endp
operator|=
name|MEMCHR
argument_list|(
name|n
argument_list|,
operator|(
name|flags
operator|&
name|FNM_FILE_NAME
operator|)
condition|?
name|L
argument_list|(
literal|'/'
argument_list|)
else|:
name|L
argument_list|(
literal|'\0'
argument_list|)
argument_list|,
name|string_end
operator|-
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|endp
operator|==
name|NULL
condition|)
name|endp
operator|=
name|string_end
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|L
argument_list|(
literal|'['
argument_list|)
operator|||
operator|(
name|__builtin_expect
argument_list|(
name|flags
operator|&
name|FNM_EXTMATCH
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|c
operator|==
name|L
argument_list|(
literal|'@'
argument_list|)
operator|||
name|c
operator|==
name|L
argument_list|(
literal|'+'
argument_list|)
operator|||
name|c
operator|==
name|L
argument_list|(
literal|'!'
argument_list|)
operator|)
operator|&&
operator|*
name|p
operator|==
name|L
argument_list|(
literal|'('
argument_list|)
operator|)
condition|)
block|{
name|int
name|flags2
init|=
operator|(
operator|(
name|flags
operator|&
name|FNM_FILE_NAME
operator|)
condition|?
name|flags
else|:
operator|(
name|flags
operator|&
operator|~
name|FNM_PERIOD
operator|)
operator|)
decl_stmt|;
name|int
name|no_leading_period2
init|=
name|no_leading_period
decl_stmt|;
for|for
control|(
operator|--
name|p
init|;
name|n
operator|<
name|endp
condition|;
operator|++
name|n
operator|,
name|no_leading_period2
operator|=
literal|0
control|)
if|if
condition|(
name|FCT
argument_list|(
name|p
argument_list|,
name|n
argument_list|,
name|string_end
argument_list|,
name|no_leading_period2
argument_list|,
name|flags2
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|L
argument_list|(
literal|'/'
argument_list|)
operator|&&
operator|(
name|flags
operator|&
name|FNM_FILE_NAME
operator|)
condition|)
block|{
while|while
condition|(
name|n
operator|<
name|string_end
operator|&&
operator|*
name|n
operator|!=
name|L
argument_list|(
literal|'/'
argument_list|)
condition|)
operator|++
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|<
name|string_end
operator|&&
operator|*
name|n
operator|==
name|L
argument_list|(
literal|'/'
argument_list|)
operator|&&
operator|(
name|FCT
argument_list|(
name|p
argument_list|,
name|n
operator|+
literal|1
argument_list|,
name|string_end
argument_list|,
name|flags
operator|&
name|FNM_PERIOD
argument_list|,
name|flags
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
name|int
name|flags2
init|=
operator|(
operator|(
name|flags
operator|&
name|FNM_FILE_NAME
operator|)
condition|?
name|flags
else|:
operator|(
name|flags
operator|&
operator|~
name|FNM_PERIOD
operator|)
operator|)
decl_stmt|;
name|int
name|no_leading_period2
init|=
name|no_leading_period
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|L
argument_list|(
literal|'\\'
argument_list|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|FNM_NOESCAPE
operator|)
condition|)
name|c
operator|=
operator|*
name|p
expr_stmt|;
name|c
operator|=
name|FOLD
argument_list|(
name|c
argument_list|)
expr_stmt|;
for|for
control|(
operator|--
name|p
init|;
name|n
operator|<
name|endp
condition|;
operator|++
name|n
operator|,
name|no_leading_period2
operator|=
literal|0
control|)
if|if
condition|(
name|FOLD
argument_list|(
operator|(
name|UCHAR
operator|)
operator|*
name|n
argument_list|)
operator|==
name|c
operator|&&
operator|(
name|FCT
argument_list|(
name|p
argument_list|,
name|n
argument_list|,
name|string_end
argument_list|,
name|no_leading_period2
argument_list|,
name|flags2
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
literal|0
return|;
block|}
block|}
comment|/* If we come here no match is possible with the wildcard.  */
return|return
name|FNM_NOMATCH
return|;
case|case
name|L
argument_list|(
literal|'['
argument_list|)
case|:
block|{
comment|/* Nonzero if the sense of the character class is inverted.  */
specifier|register
name|int
name|not
decl_stmt|;
name|CHAR
name|cold
decl_stmt|;
name|UCHAR
name|fn
decl_stmt|;
if|if
condition|(
name|posixly_correct
operator|==
literal|0
condition|)
name|posixly_correct
operator|=
name|getenv
argument_list|(
literal|"POSIXLY_CORRECT"
argument_list|)
operator|!=
name|NULL
condition|?
literal|1
else|:
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|string_end
condition|)
return|return
name|FNM_NOMATCH
return|;
if|if
condition|(
operator|*
name|n
operator|==
name|L
argument_list|(
literal|'.'
argument_list|)
operator|&&
name|no_leading_period
condition|)
return|return
name|FNM_NOMATCH
return|;
if|if
condition|(
operator|*
name|n
operator|==
name|L
argument_list|(
literal|'/'
argument_list|)
operator|&&
operator|(
name|flags
operator|&
name|FNM_FILE_NAME
operator|)
condition|)
comment|/* `/' cannot be matched.  */
return|return
name|FNM_NOMATCH
return|;
name|not
operator|=
operator|(
operator|*
name|p
operator|==
name|L
argument_list|(
literal|'!'
argument_list|)
operator|||
operator|(
name|posixly_correct
operator|<
literal|0
operator|&&
operator|*
name|p
operator|==
name|L
argument_list|(
literal|'^'
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|not
condition|)
operator|++
name|p
expr_stmt|;
name|fn
operator|=
name|FOLD
argument_list|(
operator|(
name|UCHAR
operator|)
operator|*
name|n
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|FNM_NOESCAPE
operator|)
operator|&&
name|c
operator|==
name|L
argument_list|(
literal|'\\'
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
name|L
argument_list|(
literal|'\0'
argument_list|)
condition|)
return|return
name|FNM_NOMATCH
return|;
name|c
operator|=
name|FOLD
argument_list|(
operator|(
name|UCHAR
operator|)
operator|*
name|p
argument_list|)
expr_stmt|;
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|fn
condition|)
goto|goto
name|matched
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|L
argument_list|(
literal|'['
argument_list|)
operator|&&
operator|*
name|p
operator|==
name|L
argument_list|(
literal|':'
argument_list|)
condition|)
block|{
comment|/* Leave room for the null.  */
name|CHAR
name|str
index|[
name|CHAR_CLASS_MAX_LENGTH
operator|+
literal|1
index|]
decl_stmt|;
name|size_t
name|c1
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
name|_LIBC
operator|||
name|WIDE_CHAR_SUPPORT
name|wctype_t
name|wt
decl_stmt|;
endif|#
directive|endif
specifier|const
name|CHAR
modifier|*
name|startp
init|=
name|p
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|c1
operator|==
name|CHAR_CLASS_MAX_LENGTH
condition|)
comment|/* The name is too long and therefore the pattern 			     is ill-formed.  */
return|return
name|FNM_NOMATCH
return|;
name|c
operator|=
operator|*
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|L
argument_list|(
literal|':'
argument_list|)
operator|&&
name|p
index|[
literal|1
index|]
operator|==
name|L
argument_list|(
literal|']'
argument_list|)
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|<
name|L
argument_list|(
literal|'a'
argument_list|)
operator|||
name|c
operator|>=
name|L
argument_list|(
literal|'z'
argument_list|)
condition|)
block|{
comment|/* This cannot possibly be a character class name. 			       Match it as a normal range.  */
name|p
operator|=
name|startp
expr_stmt|;
name|c
operator|=
name|L
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
goto|goto
name|normal_bracket
goto|;
block|}
name|str
index|[
name|c1
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
name|str
index|[
name|c1
index|]
operator|=
name|L
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|_LIBC
operator|||
name|WIDE_CHAR_SUPPORT
name|wt
operator|=
name|IS_CHAR_CLASS
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|wt
operator|==
literal|0
condition|)
comment|/* Invalid character class name.  */
return|return
name|FNM_NOMATCH
return|;
if|#
directive|if
name|defined
name|_LIBC
operator|&&
operator|!
name|WIDE_CHAR_VERSION
comment|/* The following code is glibc specific but does 		       there a good job in speeding up the code since 		       we can avoid the btowc() call.  */
if|if
condition|(
name|_ISCTYPE
argument_list|(
operator|(
name|UCHAR
operator|)
operator|*
name|n
argument_list|,
name|wt
argument_list|)
condition|)
goto|goto
name|matched
goto|;
else|#
directive|else
if|if
condition|(
name|ISWCTYPE
argument_list|(
name|BTOWC
argument_list|(
operator|(
name|UCHAR
operator|)
operator|*
name|n
argument_list|)
argument_list|,
name|wt
argument_list|)
condition|)
goto|goto
name|matched
goto|;
endif|#
directive|endif
else|#
directive|else
if|if
condition|(
operator|(
name|STREQ
argument_list|(
name|str
argument_list|,
name|L
argument_list|(
literal|"alnum"
argument_list|)
argument_list|)
operator|&&
name|ISALNUM
argument_list|(
operator|(
name|UCHAR
operator|)
operator|*
name|n
argument_list|)
operator|)
operator|||
operator|(
name|STREQ
argument_list|(
name|str
argument_list|,
name|L
argument_list|(
literal|"alpha"
argument_list|)
argument_list|)
operator|&&
name|ISALPHA
argument_list|(
operator|(
name|UCHAR
operator|)
operator|*
name|n
argument_list|)
operator|)
operator|||
operator|(
name|STREQ
argument_list|(
name|str
argument_list|,
name|L
argument_list|(
literal|"blank"
argument_list|)
argument_list|)
operator|&&
name|ISBLANK
argument_list|(
operator|(
name|UCHAR
operator|)
operator|*
name|n
argument_list|)
operator|)
operator|||
operator|(
name|STREQ
argument_list|(
name|str
argument_list|,
name|L
argument_list|(
literal|"cntrl"
argument_list|)
argument_list|)
operator|&&
name|ISCNTRL
argument_list|(
operator|(
name|UCHAR
operator|)
operator|*
name|n
argument_list|)
operator|)
operator|||
operator|(
name|STREQ
argument_list|(
name|str
argument_list|,
name|L
argument_list|(
literal|"digit"
argument_list|)
argument_list|)
operator|&&
name|ISDIGIT
argument_list|(
operator|(
name|UCHAR
operator|)
operator|*
name|n
argument_list|)
operator|)
operator|||
operator|(
name|STREQ
argument_list|(
name|str
argument_list|,
name|L
argument_list|(
literal|"graph"
argument_list|)
argument_list|)
operator|&&
name|ISGRAPH
argument_list|(
operator|(
name|UCHAR
operator|)
operator|*
name|n
argument_list|)
operator|)
operator|||
operator|(
name|STREQ
argument_list|(
name|str
argument_list|,
name|L
argument_list|(
literal|"lower"
argument_list|)
argument_list|)
operator|&&
name|ISLOWER
argument_list|(
operator|(
name|UCHAR
operator|)
operator|*
name|n
argument_list|)
operator|)
operator|||
operator|(
name|STREQ
argument_list|(
name|str
argument_list|,
name|L
argument_list|(
literal|"print"
argument_list|)
argument_list|)
operator|&&
name|ISPRINT
argument_list|(
operator|(
name|UCHAR
operator|)
operator|*
name|n
argument_list|)
operator|)
operator|||
operator|(
name|STREQ
argument_list|(
name|str
argument_list|,
name|L
argument_list|(
literal|"punct"
argument_list|)
argument_list|)
operator|&&
name|ISPUNCT
argument_list|(
operator|(
name|UCHAR
operator|)
operator|*
name|n
argument_list|)
operator|)
operator|||
operator|(
name|STREQ
argument_list|(
name|str
argument_list|,
name|L
argument_list|(
literal|"space"
argument_list|)
argument_list|)
operator|&&
name|ISSPACE
argument_list|(
operator|(
name|UCHAR
operator|)
operator|*
name|n
argument_list|)
operator|)
operator|||
operator|(
name|STREQ
argument_list|(
name|str
argument_list|,
name|L
argument_list|(
literal|"upper"
argument_list|)
argument_list|)
operator|&&
name|ISUPPER
argument_list|(
operator|(
name|UCHAR
operator|)
operator|*
name|n
argument_list|)
operator|)
operator|||
operator|(
name|STREQ
argument_list|(
name|str
argument_list|,
name|L
argument_list|(
literal|"xdigit"
argument_list|)
argument_list|)
operator|&&
name|ISXDIGIT
argument_list|(
operator|(
name|UCHAR
operator|)
operator|*
name|n
argument_list|)
operator|)
condition|)
goto|goto
name|matched
goto|;
endif|#
directive|endif
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|_LIBC
elseif|else
if|if
condition|(
name|c
operator|==
name|L
argument_list|(
literal|'['
argument_list|)
operator|&&
operator|*
name|p
operator|==
name|L
argument_list|(
literal|'='
argument_list|)
condition|)
block|{
name|UCHAR
name|str
index|[
literal|1
index|]
decl_stmt|;
name|uint32_t
name|nrules
init|=
name|_NL_CURRENT_WORD
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_NRULES
argument_list|)
decl_stmt|;
specifier|const
name|CHAR
modifier|*
name|startp
init|=
name|p
decl_stmt|;
name|c
operator|=
operator|*
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|L
argument_list|(
literal|'\0'
argument_list|)
condition|)
block|{
name|p
operator|=
name|startp
expr_stmt|;
name|c
operator|=
name|L
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
goto|goto
name|normal_bracket
goto|;
block|}
name|str
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|c
operator|=
operator|*
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|L
argument_list|(
literal|'='
argument_list|)
operator|||
name|p
index|[
literal|1
index|]
operator|!=
name|L
argument_list|(
literal|']'
argument_list|)
condition|)
block|{
name|p
operator|=
name|startp
expr_stmt|;
name|c
operator|=
name|L
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
goto|goto
name|normal_bracket
goto|;
block|}
name|p
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|nrules
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|UCHAR
operator|)
operator|*
name|n
operator|==
name|str
index|[
literal|0
index|]
condition|)
goto|goto
name|matched
goto|;
block|}
else|else
block|{
specifier|const
name|int32_t
modifier|*
name|table
decl_stmt|;
if|#
directive|if
name|WIDE_CHAR_VERSION
specifier|const
name|int32_t
modifier|*
name|weights
decl_stmt|;
specifier|const
name|int32_t
modifier|*
name|extra
decl_stmt|;
else|#
directive|else
specifier|const
name|unsigned
name|char
modifier|*
name|weights
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|extra
decl_stmt|;
endif|#
directive|endif
specifier|const
name|int32_t
modifier|*
name|indirect
decl_stmt|;
name|int32_t
name|idx
decl_stmt|;
specifier|const
name|UCHAR
modifier|*
name|cp
init|=
operator|(
specifier|const
name|UCHAR
operator|*
operator|)
name|str
decl_stmt|;
comment|/* This #include defines a local function!  */
if|#
directive|if
name|WIDE_CHAR_VERSION
include|#
directive|include
file|<locale/weightwc.h>
else|#
directive|else
include|#
directive|include
file|<locale/weight.h>
endif|#
directive|endif
if|#
directive|if
name|WIDE_CHAR_VERSION
name|table
operator|=
operator|(
specifier|const
name|int32_t
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_TABLEWC
argument_list|)
expr_stmt|;
name|weights
operator|=
operator|(
specifier|const
name|int32_t
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_WEIGHTWC
argument_list|)
expr_stmt|;
name|extra
operator|=
operator|(
specifier|const
name|int32_t
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_EXTRAWC
argument_list|)
expr_stmt|;
name|indirect
operator|=
operator|(
specifier|const
name|int32_t
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_INDIRECTWC
argument_list|)
expr_stmt|;
else|#
directive|else
name|table
operator|=
operator|(
specifier|const
name|int32_t
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_TABLEMB
argument_list|)
expr_stmt|;
name|weights
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_WEIGHTMB
argument_list|)
expr_stmt|;
name|extra
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_EXTRAMB
argument_list|)
expr_stmt|;
name|indirect
operator|=
operator|(
specifier|const
name|int32_t
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_INDIRECTMB
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|idx
operator|=
name|findidx
argument_list|(
operator|&
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|!=
literal|0
condition|)
block|{
comment|/* We found a table entry.  Now see whether the 			       character we are currently at has the same 			       equivalance class value.  */
name|int
name|len
init|=
name|weights
index|[
name|idx
index|]
decl_stmt|;
name|int32_t
name|idx2
decl_stmt|;
specifier|const
name|UCHAR
modifier|*
name|np
init|=
operator|(
specifier|const
name|UCHAR
operator|*
operator|)
name|n
decl_stmt|;
name|idx2
operator|=
name|findidx
argument_list|(
operator|&
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx2
operator|!=
literal|0
operator|&&
name|len
operator|==
name|weights
index|[
name|idx2
index|]
condition|)
block|{
name|int
name|cnt
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|cnt
operator|<
name|len
operator|&&
operator|(
name|weights
index|[
name|idx
operator|+
literal|1
operator|+
name|cnt
index|]
operator|==
name|weights
index|[
name|idx2
operator|+
literal|1
operator|+
name|cnt
index|]
operator|)
condition|)
operator|++
name|cnt
expr_stmt|;
if|if
condition|(
name|cnt
operator|==
name|len
condition|)
goto|goto
name|matched
goto|;
block|}
block|}
block|}
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|c
operator|==
name|L
argument_list|(
literal|'\0'
argument_list|)
condition|)
comment|/* [ (unterminated) loses.  */
return|return
name|FNM_NOMATCH
return|;
else|else
block|{
name|int
name|is_range
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
name|int
name|is_seqval
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|L
argument_list|(
literal|'['
argument_list|)
operator|&&
operator|*
name|p
operator|==
name|L
argument_list|(
literal|'.'
argument_list|)
condition|)
block|{
name|uint32_t
name|nrules
init|=
name|_NL_CURRENT_WORD
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_NRULES
argument_list|)
decl_stmt|;
specifier|const
name|CHAR
modifier|*
name|startp
init|=
name|p
decl_stmt|;
name|size_t
name|c1
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
operator|*
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|L
argument_list|(
literal|'.'
argument_list|)
operator|&&
name|p
index|[
literal|1
index|]
operator|==
name|L
argument_list|(
literal|']'
argument_list|)
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
return|return
name|FNM_NOMATCH
return|;
operator|++
name|c1
expr_stmt|;
block|}
comment|/* We have to handling the symbols differently in 			   ranges since then the collation sequence is 			   important.  */
name|is_range
operator|=
operator|*
name|p
operator|==
name|L
argument_list|(
literal|'-'
argument_list|)
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
name|L
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|nrules
operator|==
literal|0
condition|)
block|{
comment|/* There are no names defined in the collation 			       data.  Therefore we only accept the trivial 			       names consisting of the character itself.  */
if|if
condition|(
name|c1
operator|!=
literal|1
condition|)
return|return
name|FNM_NOMATCH
return|;
if|if
condition|(
operator|!
name|is_range
operator|&&
operator|*
name|n
operator|==
name|startp
index|[
literal|1
index|]
condition|)
goto|goto
name|matched
goto|;
name|cold
operator|=
name|startp
index|[
literal|1
index|]
expr_stmt|;
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
else|else
block|{
name|int32_t
name|table_size
decl_stmt|;
specifier|const
name|int32_t
modifier|*
name|symb_table
decl_stmt|;
ifdef|#
directive|ifdef
name|WIDE_CHAR_VERSION
name|char
name|str
index|[
name|c1
index|]
decl_stmt|;
name|unsigned
name|int
name|strcnt
decl_stmt|;
else|#
directive|else
define|#
directive|define
name|str
value|(startp + 1)
endif|#
directive|endif
specifier|const
name|unsigned
name|char
modifier|*
name|extra
decl_stmt|;
name|int32_t
name|idx
decl_stmt|;
name|int32_t
name|elem
decl_stmt|;
name|int32_t
name|second
decl_stmt|;
name|int32_t
name|hash
decl_stmt|;
ifdef|#
directive|ifdef
name|WIDE_CHAR_VERSION
comment|/* We have to convert the name to a single-byte 			       string.  This is possible since the names 			       consist of ASCII characters and the internal 			       representation is UCS4.  */
for|for
control|(
name|strcnt
operator|=
literal|0
init|;
name|strcnt
operator|<
name|c1
condition|;
operator|++
name|strcnt
control|)
name|str
index|[
name|strcnt
index|]
operator|=
name|startp
index|[
literal|1
operator|+
name|strcnt
index|]
expr_stmt|;
endif|#
directive|endif
name|table_size
operator|=
name|_NL_CURRENT_WORD
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_SYMB_HASH_SIZEMB
argument_list|)
expr_stmt|;
name|symb_table
operator|=
operator|(
specifier|const
name|int32_t
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_SYMB_TABLEMB
argument_list|)
expr_stmt|;
name|extra
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_SYMB_EXTRAMB
argument_list|)
expr_stmt|;
comment|/* Locate the character in the hashing table.  */
name|hash
operator|=
name|elem_hash
argument_list|(
name|str
argument_list|,
name|c1
argument_list|)
expr_stmt|;
name|idx
operator|=
literal|0
expr_stmt|;
name|elem
operator|=
name|hash
operator|%
name|table_size
expr_stmt|;
name|second
operator|=
name|hash
operator|%
operator|(
name|table_size
operator|-
literal|2
operator|)
expr_stmt|;
while|while
condition|(
name|symb_table
index|[
literal|2
operator|*
name|elem
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* First compare the hashing value.  */
if|if
condition|(
name|symb_table
index|[
literal|2
operator|*
name|elem
index|]
operator|==
name|hash
operator|&&
name|c1
operator|==
name|extra
index|[
name|symb_table
index|[
literal|2
operator|*
name|elem
operator|+
literal|1
index|]
index|]
operator|&&
name|memcmp
argument_list|(
name|str
argument_list|,
operator|&
name|extra
index|[
name|symb_table
index|[
literal|2
operator|*
name|elem
operator|+
literal|1
index|]
operator|+
literal|1
index|]
argument_list|,
name|c1
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Yep, this is the entry.  */
name|idx
operator|=
name|symb_table
index|[
literal|2
operator|*
name|elem
operator|+
literal|1
index|]
expr_stmt|;
name|idx
operator|+=
literal|1
operator|+
name|extra
index|[
name|idx
index|]
expr_stmt|;
break|break;
block|}
comment|/* Next entry.  */
name|elem
operator|+=
name|second
expr_stmt|;
block|}
if|if
condition|(
name|symb_table
index|[
literal|2
operator|*
name|elem
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* Compare the byte sequence but only if 				   this is not part of a range.  */
ifdef|#
directive|ifdef
name|WIDE_CHAR_VERSION
name|int32_t
modifier|*
name|wextra
decl_stmt|;
name|idx
operator|+=
literal|1
operator|+
name|extra
index|[
name|idx
index|]
expr_stmt|;
comment|/* Adjust for the alignment.  */
name|idx
operator|=
operator|(
name|idx
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
name|wextra
operator|=
operator|(
name|int32_t
operator|*
operator|)
operator|&
name|extra
index|[
name|idx
operator|+
literal|4
index|]
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|is_range
condition|)
block|{
ifdef|#
directive|ifdef
name|WIDE_CHAR_VERSION
for|for
control|(
name|c1
operator|=
literal|0
init|;
operator|(
name|int32_t
operator|)
name|c1
operator|<
name|wextra
index|[
name|idx
index|]
condition|;
operator|++
name|c1
control|)
if|if
condition|(
name|n
index|[
name|c1
index|]
operator|!=
name|wextra
index|[
literal|1
operator|+
name|c1
index|]
condition|)
break|break;
if|if
condition|(
operator|(
name|int32_t
operator|)
name|c1
operator|==
name|wextra
index|[
name|idx
index|]
condition|)
goto|goto
name|matched
goto|;
else|#
directive|else
for|for
control|(
name|c1
operator|=
literal|0
init|;
name|c1
operator|<
name|extra
index|[
name|idx
index|]
condition|;
operator|++
name|c1
control|)
if|if
condition|(
name|n
index|[
name|c1
index|]
operator|!=
name|extra
index|[
literal|1
operator|+
name|c1
index|]
condition|)
break|break;
if|if
condition|(
name|c1
operator|==
name|extra
index|[
name|idx
index|]
condition|)
goto|goto
name|matched
goto|;
endif|#
directive|endif
block|}
comment|/* Get the collation sequence value.  */
name|is_seqval
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|WIDE_CHAR_VERSION
name|cold
operator|=
name|wextra
index|[
literal|1
operator|+
name|wextra
index|[
name|idx
index|]
index|]
expr_stmt|;
else|#
directive|else
comment|/* Adjust for the alignment.  */
name|idx
operator|+=
literal|1
operator|+
name|extra
index|[
name|idx
index|]
expr_stmt|;
name|idx
operator|=
operator|(
name|idx
operator|+
literal|3
operator|)
operator|&
operator|~
literal|4
expr_stmt|;
name|cold
operator|=
operator|*
operator|(
operator|(
name|int32_t
operator|*
operator|)
operator|&
name|extra
index|[
name|idx
index|]
operator|)
expr_stmt|;
endif|#
directive|endif
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c1
operator|==
literal|1
condition|)
block|{
comment|/* No valid character.  Match it as a 				   single byte.  */
if|if
condition|(
operator|!
name|is_range
operator|&&
operator|*
name|n
operator|==
name|str
index|[
literal|0
index|]
condition|)
goto|goto
name|matched
goto|;
name|cold
operator|=
name|str
index|[
literal|0
index|]
expr_stmt|;
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
else|else
return|return
name|FNM_NOMATCH
return|;
block|}
block|}
else|else
undef|#
directive|undef
name|str
endif|#
directive|endif
block|{
name|c
operator|=
name|FOLD
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|normal_bracket
label|:
comment|/* We have to handling the symbols differently in 			   ranges since then the collation sequence is 			   important.  */
name|is_range
operator|=
operator|(
operator|*
name|p
operator|==
name|L
argument_list|(
literal|'-'
argument_list|)
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
name|L
argument_list|(
literal|'\0'
argument_list|)
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
name|L
argument_list|(
literal|']'
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_range
operator|&&
name|c
operator|==
name|fn
condition|)
goto|goto
name|matched
goto|;
name|cold
operator|=
name|c
expr_stmt|;
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|L
argument_list|(
literal|'-'
argument_list|)
operator|&&
operator|*
name|p
operator|!=
name|L
argument_list|(
literal|']'
argument_list|)
condition|)
block|{
if|#
directive|if
name|_LIBC
comment|/* We have to find the collation sequence 			   value for C.  Collation sequence is nothing 			   we can regularly access.  The sequence 			   value is defined by the order in which the 			   definitions of the collation values for the 			   various characters appear in the source 			   file.  A strange concept, nowhere 			   documented.  */
name|uint32_t
name|fcollseq
decl_stmt|;
name|uint32_t
name|lcollseq
decl_stmt|;
name|UCHAR
name|cend
init|=
operator|*
name|p
operator|++
decl_stmt|;
ifdef|#
directive|ifdef
name|WIDE_CHAR_VERSION
comment|/* Search in the `names' array for the characters.  */
name|fcollseq
operator|=
name|__collseq_table_lookup
argument_list|(
name|collseq
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcollseq
operator|==
operator|~
operator|(
operator|(
name|uint32_t
operator|)
literal|0
operator|)
condition|)
comment|/* XXX We don't know anything about the character 			     we are supposed to match.  This means we are 			     failing.  */
goto|goto
name|range_not_matched
goto|;
if|if
condition|(
name|is_seqval
condition|)
name|lcollseq
operator|=
name|cold
expr_stmt|;
else|else
name|lcollseq
operator|=
name|__collseq_table_lookup
argument_list|(
name|collseq
argument_list|,
name|cold
argument_list|)
expr_stmt|;
else|#
directive|else
name|fcollseq
operator|=
name|collseq
index|[
name|fn
index|]
expr_stmt|;
name|lcollseq
operator|=
name|is_seqval
condition|?
name|cold
else|:
name|collseq
index|[
operator|(
name|UCHAR
operator|)
name|cold
index|]
expr_stmt|;
endif|#
directive|endif
name|is_seqval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cend
operator|==
name|L
argument_list|(
literal|'['
argument_list|)
operator|&&
operator|*
name|p
operator|==
name|L
argument_list|(
literal|'.'
argument_list|)
condition|)
block|{
name|uint32_t
name|nrules
init|=
name|_NL_CURRENT_WORD
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_NRULES
argument_list|)
decl_stmt|;
specifier|const
name|CHAR
modifier|*
name|startp
init|=
name|p
decl_stmt|;
name|size_t
name|c1
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
operator|*
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|L
argument_list|(
literal|'.'
argument_list|)
operator|&&
name|p
index|[
literal|1
index|]
operator|==
name|L
argument_list|(
literal|']'
argument_list|)
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
return|return
name|FNM_NOMATCH
return|;
operator|++
name|c1
expr_stmt|;
block|}
if|if
condition|(
name|nrules
operator|==
literal|0
condition|)
block|{
comment|/* There are no names defined in the 				   collation data.  Therefore we only 				   accept the trivial names consisting 				   of the character itself.  */
if|if
condition|(
name|c1
operator|!=
literal|1
condition|)
return|return
name|FNM_NOMATCH
return|;
name|cend
operator|=
name|startp
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|int32_t
name|table_size
decl_stmt|;
specifier|const
name|int32_t
modifier|*
name|symb_table
decl_stmt|;
ifdef|#
directive|ifdef
name|WIDE_CHAR_VERSION
name|char
name|str
index|[
name|c1
index|]
decl_stmt|;
name|unsigned
name|int
name|strcnt
decl_stmt|;
else|#
directive|else
define|#
directive|define
name|str
value|(startp + 1)
endif|#
directive|endif
specifier|const
name|unsigned
name|char
modifier|*
name|extra
decl_stmt|;
name|int32_t
name|idx
decl_stmt|;
name|int32_t
name|elem
decl_stmt|;
name|int32_t
name|second
decl_stmt|;
name|int32_t
name|hash
decl_stmt|;
ifdef|#
directive|ifdef
name|WIDE_CHAR_VERSION
comment|/* We have to convert the name to a single-byte 				   string.  This is possible since the names 				   consist of ASCII characters and the internal 				   representation is UCS4.  */
for|for
control|(
name|strcnt
operator|=
literal|0
init|;
name|strcnt
operator|<
name|c1
condition|;
operator|++
name|strcnt
control|)
name|str
index|[
name|strcnt
index|]
operator|=
name|startp
index|[
literal|1
operator|+
name|strcnt
index|]
expr_stmt|;
endif|#
directive|endif
name|table_size
operator|=
name|_NL_CURRENT_WORD
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_SYMB_HASH_SIZEMB
argument_list|)
expr_stmt|;
name|symb_table
operator|=
operator|(
specifier|const
name|int32_t
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_SYMB_TABLEMB
argument_list|)
expr_stmt|;
name|extra
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|_NL_CURRENT
argument_list|(
name|LC_COLLATE
argument_list|,
name|_NL_COLLATE_SYMB_EXTRAMB
argument_list|)
expr_stmt|;
comment|/* Locate the character in the hashing                                    table.  */
name|hash
operator|=
name|elem_hash
argument_list|(
name|str
argument_list|,
name|c1
argument_list|)
expr_stmt|;
name|idx
operator|=
literal|0
expr_stmt|;
name|elem
operator|=
name|hash
operator|%
name|table_size
expr_stmt|;
name|second
operator|=
name|hash
operator|%
operator|(
name|table_size
operator|-
literal|2
operator|)
expr_stmt|;
while|while
condition|(
name|symb_table
index|[
literal|2
operator|*
name|elem
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* First compare the hashing value.  */
if|if
condition|(
name|symb_table
index|[
literal|2
operator|*
name|elem
index|]
operator|==
name|hash
operator|&&
operator|(
name|c1
operator|==
name|extra
index|[
name|symb_table
index|[
literal|2
operator|*
name|elem
operator|+
literal|1
index|]
index|]
operator|)
operator|&&
name|memcmp
argument_list|(
name|str
argument_list|,
operator|&
name|extra
index|[
name|symb_table
index|[
literal|2
operator|*
name|elem
operator|+
literal|1
index|]
operator|+
literal|1
index|]
argument_list|,
name|c1
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Yep, this is the entry.  */
name|idx
operator|=
name|symb_table
index|[
literal|2
operator|*
name|elem
operator|+
literal|1
index|]
expr_stmt|;
name|idx
operator|+=
literal|1
operator|+
name|extra
index|[
name|idx
index|]
expr_stmt|;
break|break;
block|}
comment|/* Next entry.  */
name|elem
operator|+=
name|second
expr_stmt|;
block|}
if|if
condition|(
name|symb_table
index|[
literal|2
operator|*
name|elem
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* Compare the byte sequence but only if 				       this is not part of a range.  */
ifdef|#
directive|ifdef
name|WIDE_CHAR_VERSION
name|int32_t
modifier|*
name|wextra
decl_stmt|;
name|idx
operator|+=
literal|1
operator|+
name|extra
index|[
name|idx
index|]
expr_stmt|;
comment|/* Adjust for the alignment.  */
name|idx
operator|=
operator|(
name|idx
operator|+
literal|3
operator|)
operator|&
operator|~
literal|4
expr_stmt|;
name|wextra
operator|=
operator|(
name|int32_t
operator|*
operator|)
operator|&
name|extra
index|[
name|idx
operator|+
literal|4
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* Get the collation sequence value.  */
name|is_seqval
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|WIDE_CHAR_VERSION
name|cend
operator|=
name|wextra
index|[
literal|1
operator|+
name|wextra
index|[
name|idx
index|]
index|]
expr_stmt|;
else|#
directive|else
comment|/* Adjust for the alignment.  */
name|idx
operator|+=
literal|1
operator|+
name|extra
index|[
name|idx
index|]
expr_stmt|;
name|idx
operator|=
operator|(
name|idx
operator|+
literal|3
operator|)
operator|&
operator|~
literal|4
expr_stmt|;
name|cend
operator|=
operator|*
operator|(
operator|(
name|int32_t
operator|*
operator|)
operator|&
name|extra
index|[
name|idx
index|]
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|symb_table
index|[
literal|2
operator|*
name|elem
index|]
operator|!=
literal|0
operator|&&
name|c1
operator|==
literal|1
condition|)
block|{
name|cend
operator|=
name|str
index|[
literal|0
index|]
expr_stmt|;
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
else|else
return|return
name|FNM_NOMATCH
return|;
block|}
undef|#
directive|undef
name|str
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|FNM_NOESCAPE
operator|)
operator|&&
name|cend
operator|==
name|L
argument_list|(
literal|'\\'
argument_list|)
condition|)
name|cend
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|cend
operator|==
name|L
argument_list|(
literal|'\0'
argument_list|)
condition|)
return|return
name|FNM_NOMATCH
return|;
name|cend
operator|=
name|FOLD
argument_list|(
name|cend
argument_list|)
expr_stmt|;
block|}
comment|/* XXX It is not entirely clear to me how to handle 			   characters which are not mentioned in the 			   collation specification.  */
if|if
condition|(
ifdef|#
directive|ifdef
name|WIDE_CHAR_VERSION
name|lcollseq
operator|==
literal|0xffffffff
operator|||
endif|#
directive|endif
name|lcollseq
operator|<=
name|fcollseq
condition|)
block|{
comment|/* We have to look at the upper bound.  */
name|uint32_t
name|hcollseq
decl_stmt|;
if|if
condition|(
name|is_seqval
condition|)
name|hcollseq
operator|=
name|cend
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|WIDE_CHAR_VERSION
name|hcollseq
operator|=
name|__collseq_table_lookup
argument_list|(
name|collseq
argument_list|,
name|cend
argument_list|)
expr_stmt|;
if|if
condition|(
name|hcollseq
operator|==
operator|~
operator|(
operator|(
name|uint32_t
operator|)
literal|0
operator|)
condition|)
block|{
comment|/* Hum, no information about the upper 				       bound.  The matching succeeds if the 				       lower bound is matched exactly.  */
if|if
condition|(
name|lcollseq
operator|!=
name|fcollseq
condition|)
goto|goto
name|range_not_matched
goto|;
goto|goto
name|matched
goto|;
block|}
else|#
directive|else
name|hcollseq
operator|=
name|collseq
index|[
name|cend
index|]
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|lcollseq
operator|<=
name|hcollseq
operator|&&
name|fcollseq
operator|<=
name|hcollseq
condition|)
goto|goto
name|matched
goto|;
block|}
ifdef|#
directive|ifdef
name|WIDE_CHAR_VERSION
name|range_not_matched
label|:
endif|#
directive|endif
else|#
directive|else
comment|/* We use a boring value comparison of the character 			   values.  This is better than comparing using 			   `strcoll' since the latter would have surprising 			   and sometimes fatal consequences.  */
name|UCHAR
name|cend
init|=
operator|*
name|p
operator|++
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|FNM_NOESCAPE
operator|)
operator|&&
name|cend
operator|==
name|L
argument_list|(
literal|'\\'
argument_list|)
condition|)
name|cend
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|cend
operator|==
name|L
argument_list|(
literal|'\0'
argument_list|)
condition|)
return|return
name|FNM_NOMATCH
return|;
comment|/* It is a range.  */
if|if
condition|(
name|cold
operator|<=
name|fn
operator|&&
name|fn
operator|<=
name|cend
condition|)
goto|goto
name|matched
goto|;
endif|#
directive|endif
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|==
name|L
argument_list|(
literal|']'
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|not
condition|)
return|return
name|FNM_NOMATCH
return|;
break|break;
name|matched
label|:
comment|/* Skip the rest of the [...] that already matched.  */
do|do
block|{
name|ignore_next
label|:
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|L
argument_list|(
literal|'\0'
argument_list|)
condition|)
comment|/* [... (unterminated) loses.  */
return|return
name|FNM_NOMATCH
return|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|FNM_NOESCAPE
operator|)
operator|&&
name|c
operator|==
name|L
argument_list|(
literal|'\\'
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
name|L
argument_list|(
literal|'\0'
argument_list|)
condition|)
return|return
name|FNM_NOMATCH
return|;
comment|/* XXX 1003.2d11 is unclear if this is right.  */
operator|++
name|p
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|L
argument_list|(
literal|'['
argument_list|)
operator|&&
operator|*
name|p
operator|==
name|L
argument_list|(
literal|':'
argument_list|)
condition|)
block|{
name|int
name|c1
init|=
literal|0
decl_stmt|;
specifier|const
name|CHAR
modifier|*
name|startp
init|=
name|p
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
operator|*
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|++
name|c1
operator|==
name|CHAR_CLASS_MAX_LENGTH
condition|)
return|return
name|FNM_NOMATCH
return|;
if|if
condition|(
operator|*
name|p
operator|==
name|L
argument_list|(
literal|':'
argument_list|)
operator|&&
name|p
index|[
literal|1
index|]
operator|==
name|L
argument_list|(
literal|']'
argument_list|)
condition|)
break|break;
if|if
condition|(
name|c
operator|<
name|L
argument_list|(
literal|'a'
argument_list|)
operator|||
name|c
operator|>=
name|L
argument_list|(
literal|'z'
argument_list|)
condition|)
block|{
name|p
operator|=
name|startp
expr_stmt|;
goto|goto
name|ignore_next
goto|;
block|}
block|}
name|p
operator|+=
literal|2
expr_stmt|;
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|L
argument_list|(
literal|'['
argument_list|)
operator|&&
operator|*
name|p
operator|==
name|L
argument_list|(
literal|'='
argument_list|)
condition|)
block|{
name|c
operator|=
operator|*
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|L
argument_list|(
literal|'\0'
argument_list|)
condition|)
return|return
name|FNM_NOMATCH
return|;
name|c
operator|=
operator|*
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|L
argument_list|(
literal|'='
argument_list|)
operator|||
name|p
index|[
literal|1
index|]
operator|!=
name|L
argument_list|(
literal|']'
argument_list|)
condition|)
return|return
name|FNM_NOMATCH
return|;
name|p
operator|+=
literal|2
expr_stmt|;
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|L
argument_list|(
literal|'['
argument_list|)
operator|&&
operator|*
name|p
operator|==
name|L
argument_list|(
literal|'.'
argument_list|)
condition|)
block|{
operator|++
name|p
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
operator|*
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
return|return
name|FNM_NOMATCH
return|;
if|if
condition|(
operator|*
name|p
operator|==
name|L
argument_list|(
literal|'.'
argument_list|)
operator|&&
name|p
index|[
literal|1
index|]
operator|==
name|L
argument_list|(
literal|']'
argument_list|)
condition|)
break|break;
block|}
name|p
operator|+=
literal|2
expr_stmt|;
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
name|c
operator|!=
name|L
argument_list|(
literal|']'
argument_list|)
condition|)
do|;
if|if
condition|(
name|not
condition|)
return|return
name|FNM_NOMATCH
return|;
block|}
break|break;
case|case
name|L
argument_list|(
literal|'+'
argument_list|)
case|:
case|case
name|L
argument_list|(
literal|'@'
argument_list|)
case|:
case|case
name|L
argument_list|(
literal|'!'
argument_list|)
case|:
if|if
condition|(
name|__builtin_expect
argument_list|(
name|flags
operator|&
name|FNM_EXTMATCH
argument_list|,
literal|0
argument_list|)
operator|&&
operator|*
name|p
operator|==
literal|'('
condition|)
block|{
name|int
name|res
decl_stmt|;
name|res
operator|=
name|EXT
argument_list|(
name|c
argument_list|,
name|p
argument_list|,
name|n
argument_list|,
name|string_end
argument_list|,
name|no_leading_period
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
operator|-
literal|1
condition|)
return|return
name|res
return|;
block|}
goto|goto
name|normal_match
goto|;
case|case
name|L
argument_list|(
literal|'/'
argument_list|)
case|:
if|if
condition|(
name|NO_LEADING_PERIOD
argument_list|(
name|flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|n
operator|==
name|string_end
operator|||
name|c
operator|!=
operator|(
name|UCHAR
operator|)
operator|*
name|n
condition|)
return|return
name|FNM_NOMATCH
return|;
name|new_no_leading_period
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
default|default:
name|normal_match
label|:
if|if
condition|(
name|n
operator|==
name|string_end
operator|||
name|c
operator|!=
name|FOLD
argument_list|(
operator|(
name|UCHAR
operator|)
operator|*
name|n
argument_list|)
condition|)
return|return
name|FNM_NOMATCH
return|;
block|}
name|no_leading_period
operator|=
name|new_no_leading_period
expr_stmt|;
operator|++
name|n
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
name|string_end
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|flags
operator|&
name|FNM_LEADING_DIR
operator|)
operator|&&
name|n
operator|!=
name|string_end
operator|&&
operator|*
name|n
operator|==
name|L
argument_list|(
literal|'/'
argument_list|)
condition|)
comment|/* The FNM_LEADING_DIR flag says that "foo*" matches "foobar/frobozz".  */
return|return
literal|0
return|;
return|return
name|FNM_NOMATCH
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|CHAR
modifier|*
name|internal_function
name|END
parameter_list|(
specifier|const
name|CHAR
modifier|*
name|pattern
parameter_list|)
block|{
specifier|const
name|CHAR
modifier|*
name|p
init|=
name|pattern
decl_stmt|;
while|while
condition|(
literal|1
condition|)
if|if
condition|(
operator|*
operator|++
name|p
operator|==
name|L
argument_list|(
literal|'\0'
argument_list|)
condition|)
comment|/* This is an invalid pattern.  */
return|return
name|pattern
return|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
name|L
argument_list|(
literal|'['
argument_list|)
condition|)
block|{
comment|/* Handle brackets special.  */
if|if
condition|(
name|posixly_correct
operator|==
literal|0
condition|)
name|posixly_correct
operator|=
name|getenv
argument_list|(
literal|"POSIXLY_CORRECT"
argument_list|)
operator|!=
name|NULL
condition|?
literal|1
else|:
operator|-
literal|1
expr_stmt|;
comment|/* Skip the not sign.  We have to recognize it because of a possibly 	   following ']'.  */
if|if
condition|(
operator|*
operator|++
name|p
operator|==
name|L
argument_list|(
literal|'!'
argument_list|)
operator|||
operator|(
name|posixly_correct
operator|<
literal|0
operator|&&
operator|*
name|p
operator|==
name|L
argument_list|(
literal|'^'
argument_list|)
operator|)
condition|)
operator|++
name|p
expr_stmt|;
comment|/* A leading ']' is recognized as such.  */
if|if
condition|(
operator|*
name|p
operator|==
name|L
argument_list|(
literal|']'
argument_list|)
condition|)
operator|++
name|p
expr_stmt|;
comment|/* Skip over all characters of the list.  */
while|while
condition|(
operator|*
name|p
operator|!=
name|L
argument_list|(
literal|']'
argument_list|)
condition|)
if|if
condition|(
operator|*
name|p
operator|++
operator|==
name|L
argument_list|(
literal|'\0'
argument_list|)
condition|)
comment|/* This is no valid pattern.  */
return|return
name|pattern
return|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|p
operator|==
name|L
argument_list|(
literal|'?'
argument_list|)
operator|||
operator|*
name|p
operator|==
name|L
argument_list|(
literal|'*'
argument_list|)
operator|||
operator|*
name|p
operator|==
name|L
argument_list|(
literal|'+'
argument_list|)
operator|||
operator|*
name|p
operator|==
name|L
argument_list|(
literal|'@'
argument_list|)
operator|||
operator|*
name|p
operator|==
name|L
argument_list|(
literal|'!'
argument_list|)
operator|)
operator|&&
name|p
index|[
literal|1
index|]
operator|==
name|L
argument_list|(
literal|'('
argument_list|)
condition|)
name|p
operator|=
name|END
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
name|L
argument_list|(
literal|')'
argument_list|)
condition|)
break|break;
return|return
name|p
operator|+
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|internal_function
name|EXT
parameter_list|(
name|INT
name|opt
parameter_list|,
specifier|const
name|CHAR
modifier|*
name|pattern
parameter_list|,
specifier|const
name|CHAR
modifier|*
name|string
parameter_list|,
specifier|const
name|CHAR
modifier|*
name|string_end
parameter_list|,
name|int
name|no_leading_period
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
specifier|const
name|CHAR
modifier|*
name|startp
decl_stmt|;
name|int
name|level
decl_stmt|;
struct|struct
name|patternlist
block|{
name|struct
name|patternlist
modifier|*
name|next
decl_stmt|;
name|CHAR
name|str
index|[
literal|1
index|]
decl_stmt|;
block|}
modifier|*
name|list
init|=
name|NULL
struct|;
name|struct
name|patternlist
modifier|*
modifier|*
name|lastp
init|=
operator|&
name|list
decl_stmt|;
name|size_t
name|pattern_len
init|=
name|STRLEN
argument_list|(
name|pattern
argument_list|)
decl_stmt|;
specifier|const
name|CHAR
modifier|*
name|p
decl_stmt|;
specifier|const
name|CHAR
modifier|*
name|rs
decl_stmt|;
enum|enum
block|{
name|ALLOCA_LIMIT
init|=
literal|8000
block|}
enum|;
comment|/* Parse the pattern.  Store the individual parts in the list.  */
name|level
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|startp
operator|=
name|p
operator|=
name|pattern
operator|+
literal|1
init|;
name|level
operator|>=
literal|0
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|*
name|p
operator|==
name|L
argument_list|(
literal|'\0'
argument_list|)
condition|)
comment|/* This is an invalid pattern.  */
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
name|L
argument_list|(
literal|'['
argument_list|)
condition|)
block|{
comment|/* Handle brackets special.  */
if|if
condition|(
name|posixly_correct
operator|==
literal|0
condition|)
name|posixly_correct
operator|=
name|getenv
argument_list|(
literal|"POSIXLY_CORRECT"
argument_list|)
operator|!=
name|NULL
condition|?
literal|1
else|:
operator|-
literal|1
expr_stmt|;
comment|/* Skip the not sign.  We have to recognize it because of a possibly 	   following ']'.  */
if|if
condition|(
operator|*
operator|++
name|p
operator|==
name|L
argument_list|(
literal|'!'
argument_list|)
operator|||
operator|(
name|posixly_correct
operator|<
literal|0
operator|&&
operator|*
name|p
operator|==
name|L
argument_list|(
literal|'^'
argument_list|)
operator|)
condition|)
operator|++
name|p
expr_stmt|;
comment|/* A leading ']' is recognized as such.  */
if|if
condition|(
operator|*
name|p
operator|==
name|L
argument_list|(
literal|']'
argument_list|)
condition|)
operator|++
name|p
expr_stmt|;
comment|/* Skip over all characters of the list.  */
while|while
condition|(
operator|*
name|p
operator|!=
name|L
argument_list|(
literal|']'
argument_list|)
condition|)
if|if
condition|(
operator|*
name|p
operator|++
operator|==
name|L
argument_list|(
literal|'\0'
argument_list|)
condition|)
comment|/* This is no valid pattern.  */
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|p
operator|==
name|L
argument_list|(
literal|'?'
argument_list|)
operator|||
operator|*
name|p
operator|==
name|L
argument_list|(
literal|'*'
argument_list|)
operator|||
operator|*
name|p
operator|==
name|L
argument_list|(
literal|'+'
argument_list|)
operator|||
operator|*
name|p
operator|==
name|L
argument_list|(
literal|'@'
argument_list|)
operator|||
operator|*
name|p
operator|==
name|L
argument_list|(
literal|'!'
argument_list|)
operator|)
operator|&&
name|p
index|[
literal|1
index|]
operator|==
name|L
argument_list|(
literal|'('
argument_list|)
condition|)
comment|/* Remember the nesting level.  */
operator|++
name|level
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
name|L
argument_list|(
literal|')'
argument_list|)
condition|)
block|{
if|if
condition|(
name|level
operator|--
operator|==
literal|0
condition|)
block|{
comment|/* This means we found the end of the pattern.  */
define|#
directive|define
name|NEW_PATTERN
define|\
value|struct patternlist *newp;					      \ 	    size_t plen;						      \ 	    size_t plensize;						      \ 	    size_t newpsize;						      \ 									      \ 	    plen = (opt == L('?') || opt == L('@')			      \ 		    ? pattern_len					      \ 		    : p - startp + 1);					      \ 	    plensize = plen * sizeof (CHAR);				      \ 	    newpsize = offsetof (struct patternlist, str) + plensize;	      \ 	    if ((size_t) -1 / sizeof (CHAR)< plen			      \ 		|| newpsize< offsetof (struct patternlist, str)	      \ 		|| ALLOCA_LIMIT<= newpsize)				      \ 	      return -1;						      \ 	    newp = (struct patternlist *) alloca (newpsize);		      \ 	    *((CHAR *) MEMPCPY (newp->str, startp, p - startp)) = L('\0');    \ 	    newp->next = NULL;						      \ 	    *lastp = newp;						      \ 	    lastp =&newp->next
name|NEW_PATTERN
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
name|L
argument_list|(
literal|'|'
argument_list|)
condition|)
block|{
if|if
condition|(
name|level
operator|==
literal|0
condition|)
block|{
name|NEW_PATTERN
expr_stmt|;
name|startp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|assert
argument_list|(
name|list
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
name|L
argument_list|(
literal|')'
argument_list|)
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|NEW_PATTERN
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
name|L
argument_list|(
literal|'*'
argument_list|)
case|:
if|if
condition|(
name|FCT
argument_list|(
name|p
argument_list|,
name|string
argument_list|,
name|string_end
argument_list|,
name|no_leading_period
argument_list|,
name|flags
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* FALLTHROUGH */
case|case
name|L
argument_list|(
literal|'+'
argument_list|)
case|:
do|do
block|{
for|for
control|(
name|rs
operator|=
name|string
init|;
name|rs
operator|<=
name|string_end
condition|;
operator|++
name|rs
control|)
comment|/* First match the prefix with the current pattern with the 	       current pattern.  */
if|if
condition|(
name|FCT
argument_list|(
name|list
operator|->
name|str
argument_list|,
name|string
argument_list|,
name|rs
argument_list|,
name|no_leading_period
argument_list|,
name|flags
operator|&
name|FNM_FILE_NAME
condition|?
name|flags
else|:
name|flags
operator|&
operator|~
name|FNM_PERIOD
argument_list|)
operator|==
literal|0
comment|/* This was successful.  Now match the rest with the rest 		   of the pattern.  */
operator|&&
operator|(
name|FCT
argument_list|(
name|p
argument_list|,
name|rs
argument_list|,
name|string_end
argument_list|,
name|rs
operator|==
name|string
condition|?
name|no_leading_period
else|:
name|rs
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|&&
name|NO_LEADING_PERIOD
argument_list|(
name|flags
argument_list|)
condition|?
literal|1
else|:
literal|0
argument_list|,
name|flags
operator|&
name|FNM_FILE_NAME
condition|?
name|flags
else|:
name|flags
operator|&
operator|~
name|FNM_PERIOD
argument_list|)
operator|==
literal|0
comment|/* This didn't work.  Try the whole pattern.  */
operator|||
operator|(
name|rs
operator|!=
name|string
operator|&&
name|FCT
argument_list|(
name|pattern
operator|-
literal|1
argument_list|,
name|rs
argument_list|,
name|string_end
argument_list|,
name|rs
operator|==
name|string
condition|?
name|no_leading_period
else|:
operator|(
name|rs
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|&&
name|NO_LEADING_PERIOD
argument_list|(
name|flags
argument_list|)
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|,
name|flags
operator|&
name|FNM_FILE_NAME
condition|?
name|flags
else|:
name|flags
operator|&
operator|~
name|FNM_PERIOD
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
comment|/* It worked.  Signal success.  */
return|return
literal|0
return|;
block|}
do|while
condition|(
operator|(
name|list
operator|=
name|list
operator|->
name|next
operator|)
operator|!=
name|NULL
condition|)
do|;
comment|/* None of the patterns lead to a match.  */
return|return
name|FNM_NOMATCH
return|;
case|case
name|L
argument_list|(
literal|'?'
argument_list|)
case|:
if|if
condition|(
name|FCT
argument_list|(
name|p
argument_list|,
name|string
argument_list|,
name|string_end
argument_list|,
name|no_leading_period
argument_list|,
name|flags
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* FALLTHROUGH */
case|case
name|L
argument_list|(
literal|'@'
argument_list|)
case|:
do|do
comment|/* I cannot believe it but `strcat' is actually acceptable 	   here.  Match the entire string with the prefix from the 	   pattern list and the rest of the pattern following the 	   pattern list.  */
if|if
condition|(
name|FCT
argument_list|(
name|STRCAT
argument_list|(
name|list
operator|->
name|str
argument_list|,
name|p
argument_list|)
argument_list|,
name|string
argument_list|,
name|string_end
argument_list|,
name|no_leading_period
argument_list|,
name|flags
operator|&
name|FNM_FILE_NAME
condition|?
name|flags
else|:
name|flags
operator|&
operator|~
name|FNM_PERIOD
argument_list|)
operator|==
literal|0
condition|)
comment|/* It worked.  Signal success.  */
return|return
literal|0
return|;
do|while
condition|(
operator|(
name|list
operator|=
name|list
operator|->
name|next
operator|)
operator|!=
name|NULL
condition|)
do|;
comment|/* None of the patterns lead to a match.  */
return|return
name|FNM_NOMATCH
return|;
case|case
name|L
argument_list|(
literal|'!'
argument_list|)
case|:
for|for
control|(
name|rs
operator|=
name|string
init|;
name|rs
operator|<=
name|string_end
condition|;
operator|++
name|rs
control|)
block|{
name|struct
name|patternlist
modifier|*
name|runp
decl_stmt|;
for|for
control|(
name|runp
operator|=
name|list
init|;
name|runp
operator|!=
name|NULL
condition|;
name|runp
operator|=
name|runp
operator|->
name|next
control|)
if|if
condition|(
name|FCT
argument_list|(
name|runp
operator|->
name|str
argument_list|,
name|string
argument_list|,
name|rs
argument_list|,
name|no_leading_period
argument_list|,
name|flags
operator|&
name|FNM_FILE_NAME
condition|?
name|flags
else|:
name|flags
operator|&
operator|~
name|FNM_PERIOD
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* If none of the patterns matched see whether the rest does.  */
if|if
condition|(
name|runp
operator|==
name|NULL
operator|&&
operator|(
name|FCT
argument_list|(
name|p
argument_list|,
name|rs
argument_list|,
name|string_end
argument_list|,
name|rs
operator|==
name|string
condition|?
name|no_leading_period
else|:
name|rs
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|&&
name|NO_LEADING_PERIOD
argument_list|(
name|flags
argument_list|)
condition|?
literal|1
else|:
literal|0
argument_list|,
name|flags
operator|&
name|FNM_FILE_NAME
condition|?
name|flags
else|:
name|flags
operator|&
operator|~
name|FNM_PERIOD
argument_list|)
operator|==
literal|0
operator|)
condition|)
comment|/* This is successful.  */
return|return
literal|0
return|;
block|}
comment|/* None of the patterns together with the rest of the pattern 	 lead to a match.  */
return|return
name|FNM_NOMATCH
return|;
default|default:
name|assert
argument_list|(
operator|!
literal|"Invalid extended matching operator"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|FOLD
end_undef

begin_undef
undef|#
directive|undef
name|CHAR
end_undef

begin_undef
undef|#
directive|undef
name|UCHAR
end_undef

begin_undef
undef|#
directive|undef
name|INT
end_undef

begin_undef
undef|#
directive|undef
name|FCT
end_undef

begin_undef
undef|#
directive|undef
name|EXT
end_undef

begin_undef
undef|#
directive|undef
name|END
end_undef

begin_undef
undef|#
directive|undef
name|MEMPCPY
end_undef

begin_undef
undef|#
directive|undef
name|MEMCHR
end_undef

begin_undef
undef|#
directive|undef
name|STRCOLL
end_undef

begin_undef
undef|#
directive|undef
name|STRLEN
end_undef

begin_undef
undef|#
directive|undef
name|STRCAT
end_undef

begin_undef
undef|#
directive|undef
name|L
end_undef

begin_undef
undef|#
directive|undef
name|BTOWC
end_undef

end_unit

