begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tempname.c - generate the name of a temporary file.     Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2001, 2002, 2003 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License along    with this program; if not, write to the Free Software Foundation,    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|__set_errno
end_ifndef

begin_define
define|#
directive|define
name|__set_errno
parameter_list|(
name|Val
parameter_list|)
value|errno = (Val)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|P_tmpdir
end_ifndef

begin_define
define|#
directive|define
name|P_tmpdir
value|"/tmp"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TMP_MAX
end_ifndef

begin_define
define|#
directive|define
name|TMP_MAX
value|238328
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|__GT_FILE
end_ifndef

begin_define
define|#
directive|define
name|__GT_FILE
value|0
end_define

begin_define
define|#
directive|define
name|__GT_BIGFILE
value|1
end_define

begin_define
define|#
directive|define
name|__GT_DIR
value|2
end_define

begin_define
define|#
directive|define
name|__GT_NOCREATE
value|3
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_if
if|#
directive|if
name|HAVE_FCNTL_H
operator|||
name|_LIBC
end_if

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_SYS_TIME_H
operator|||
name|_LIBC
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_STDINT_H
operator|||
name|_LIBC
end_if

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_INTTYPES_H
end_if

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_UNISTD_H
operator|||
name|_LIBC
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_if
if|#
directive|if
name|STAT_MACROS_BROKEN
end_if

begin_undef
undef|#
directive|undef
name|S_ISDIR
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|S_ISDIR
operator|&&
name|defined
name|S_IFDIR
end_if

begin_define
define|#
directive|define
name|S_ISDIR
parameter_list|(
name|mode
parameter_list|)
value|(((mode)& S_IFMT) == S_IFDIR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|S_IRUSR
operator|&&
name|S_IREAD
end_if

begin_define
define|#
directive|define
name|S_IRUSR
value|S_IREAD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|S_IRUSR
end_if

begin_define
define|#
directive|define
name|S_IRUSR
value|00400
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|S_IWUSR
operator|&&
name|S_IWRITE
end_if

begin_define
define|#
directive|define
name|S_IWUSR
value|S_IWRITE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|S_IWUSR
end_if

begin_define
define|#
directive|define
name|S_IWUSR
value|00200
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|S_IXUSR
operator|&&
name|S_IEXEC
end_if

begin_define
define|#
directive|define
name|S_IXUSR
value|S_IEXEC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|S_IXUSR
end_if

begin_define
define|#
directive|define
name|S_IXUSR
value|00100
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|_LIBC
end_if

begin_define
define|#
directive|define
name|struct_stat64
value|struct stat64
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|struct_stat64
value|struct stat
end_define

begin_define
define|#
directive|define
name|__getpid
value|getpid
end_define

begin_define
define|#
directive|define
name|__gettimeofday
value|gettimeofday
end_define

begin_define
define|#
directive|define
name|__mkdir
value|mkdir
end_define

begin_define
define|#
directive|define
name|__open
value|open
end_define

begin_define
define|#
directive|define
name|__open64
value|open
end_define

begin_define
define|#
directive|define
name|__lxstat64
parameter_list|(
name|version
parameter_list|,
name|path
parameter_list|,
name|buf
parameter_list|)
value|lstat (path, buf)
end_define

begin_define
define|#
directive|define
name|__xstat64
parameter_list|(
name|version
parameter_list|,
name|path
parameter_list|,
name|buf
parameter_list|)
value|stat (path, buf)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
operator|(
name|HAVE___SECURE_GETENV
operator|||
name|_LIBC
operator|)
end_if

begin_define
define|#
directive|define
name|__secure_getenv
value|getenv
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_include
include|#
directive|include
file|<hp-timing.h>
end_include

begin_if
if|#
directive|if
name|HP_TIMING_AVAIL
end_if

begin_define
define|#
directive|define
name|RANDOM_BITS
parameter_list|(
name|Var
parameter_list|)
define|\
value|if (__builtin_expect (value == UINT64_C (0), 0))			      \     {									      \
comment|/* If this is the first time this function is used initialize	      \ 	 the variable we accumulate the value in to some somewhat	      \ 	 random value.  If we'd not do this programs at startup time	      \ 	 might have a reduced set of possible names, at least on slow	      \ 	 machines.  */
value|\       struct timeval tv;						      \       __gettimeofday (&tv, NULL);					      \       value = ((uint64_t) tv.tv_usec<< 16) ^ tv.tv_sec;		      \     }									      \   HP_TIMING_NOW (Var)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Use the widest available unsigned type if uint64_t is not    available.  The algorithm below extracts a number less than 62**6    (approximately 2**35.725) from uint64_t, so ancient hosts where    uintmax_t is only 32 bits lose about 3.725 bits of randomness,    which is better than not having mkstemp at all.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
name|UINT64_MAX
operator|&&
operator|!
name|defined
name|uint64_t
end_if

begin_define
define|#
directive|define
name|uint64_t
value|uintmax_t
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return nonzero if DIR is an existent directory.  */
end_comment

begin_function
specifier|static
name|int
name|direxists
parameter_list|(
specifier|const
name|char
modifier|*
name|dir
parameter_list|)
block|{
name|struct_stat64
name|buf
decl_stmt|;
return|return
name|__xstat64
argument_list|(
name|_STAT_VER
argument_list|,
name|dir
argument_list|,
operator|&
name|buf
argument_list|)
operator|==
literal|0
operator|&&
name|S_ISDIR
argument_list|(
name|buf
operator|.
name|st_mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Path search algorithm, for tmpnam, tmpfile, etc.  If DIR is    non-null and exists, uses it; otherwise uses the first of $TMPDIR,    P_tmpdir, /tmp that exists.  Copies into TMPL a template suitable    for use with mk[s]temp.  Will fail (-1) if DIR is non-null and    doesn't exist, none of the searched dirs exists, or there's not    enough space in TMPL. */
end_comment

begin_function
name|int
name|__path_search
parameter_list|(
name|char
modifier|*
name|tmpl
parameter_list|,
name|size_t
name|tmpl_len
parameter_list|,
specifier|const
name|char
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|pfx
parameter_list|,
name|int
name|try_tmpdir
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|d
decl_stmt|;
name|size_t
name|dlen
decl_stmt|,
name|plen
decl_stmt|;
if|if
condition|(
operator|!
name|pfx
operator|||
operator|!
name|pfx
index|[
literal|0
index|]
condition|)
block|{
name|pfx
operator|=
literal|"file"
expr_stmt|;
name|plen
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|plen
operator|=
name|strlen
argument_list|(
name|pfx
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|>
literal|5
condition|)
name|plen
operator|=
literal|5
expr_stmt|;
block|}
if|if
condition|(
name|try_tmpdir
condition|)
block|{
name|d
operator|=
name|__secure_getenv
argument_list|(
literal|"TMPDIR"
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|!=
name|NULL
operator|&&
name|direxists
argument_list|(
name|d
argument_list|)
condition|)
name|dir
operator|=
name|d
expr_stmt|;
elseif|else
if|if
condition|(
name|dir
operator|!=
name|NULL
operator|&&
name|direxists
argument_list|(
name|dir
argument_list|)
condition|)
comment|/* nothing */
empty_stmt|;
else|else
name|dir
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|dir
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|direxists
argument_list|(
name|P_tmpdir
argument_list|)
condition|)
name|dir
operator|=
name|P_tmpdir
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|P_tmpdir
argument_list|,
literal|"/tmp"
argument_list|)
operator|!=
literal|0
operator|&&
name|direxists
argument_list|(
literal|"/tmp"
argument_list|)
condition|)
name|dir
operator|=
literal|"/tmp"
expr_stmt|;
else|else
block|{
name|__set_errno
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|dlen
operator|=
name|strlen
argument_list|(
name|dir
argument_list|)
expr_stmt|;
while|while
condition|(
name|dlen
operator|>
literal|1
operator|&&
name|dir
index|[
name|dlen
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
name|dlen
operator|--
expr_stmt|;
comment|/* remove trailing slashes */
comment|/* check we have room for "${dir}/${pfx}XXXXXX\0" */
if|if
condition|(
name|tmpl_len
operator|<
name|dlen
operator|+
literal|1
operator|+
name|plen
operator|+
literal|6
operator|+
literal|1
condition|)
block|{
name|__set_errno
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|sprintf
argument_list|(
name|tmpl
argument_list|,
literal|"%.*s/%.*sXXXXXX"
argument_list|,
operator|(
name|int
operator|)
name|dlen
argument_list|,
name|dir
argument_list|,
operator|(
name|int
operator|)
name|plen
argument_list|,
name|pfx
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* These are the characters used in temporary filenames.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|letters
index|[]
init|=
literal|"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Generate a temporary file name based on TMPL.  TMPL must match the    rules for mk[s]temp (i.e. end in "XXXXXX").  The name constructed    does not exist at the time of the call to __gen_tempname.  TMPL is    overwritten with the result.     KIND may be one of:    __GT_NOCREATE:	simply verify that the name does not exist 			at the time of the call.    __GT_FILE:		create the file using open(O_CREAT|O_EXCL) 			and return a read-write fd.  The file is mode 0600.    __GT_BIGFILE:	same as __GT_FILE but use open64().    __GT_DIR:		create a directory, which will be mode 0700.     We use a clever algorithm to get hard-to-predict names. */
end_comment

begin_function
name|int
name|__gen_tempname
parameter_list|(
name|char
modifier|*
name|tmpl
parameter_list|,
name|int
name|kind
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|XXXXXX
decl_stmt|;
specifier|static
name|uint64_t
name|value
decl_stmt|;
name|uint64_t
name|random_time_bits
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|struct_stat64
name|st
decl_stmt|;
comment|/* A lower bound on the number of temporary files to attempt to      generate.  The maximum total number of temporary file names that      can exist for a given template is 62**6.  It should never be      necessary to try all these combinations.  Instead if a reasonable      number of names is tried (we define reasonable as 62**3) fail to      give the system administrator the chance to remove the problems.  */
name|unsigned
name|int
name|attempts_min
init|=
literal|62
operator|*
literal|62
operator|*
literal|62
decl_stmt|;
comment|/* The number of times to attempt to generate a temporary file.  To      conform to POSIX, this must be no smaller than TMP_MAX.  */
name|unsigned
name|int
name|attempts
init|=
name|attempts_min
operator|<
name|TMP_MAX
condition|?
name|TMP_MAX
else|:
name|attempts_min
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|6
operator|||
name|strcmp
argument_list|(
operator|&
name|tmpl
index|[
name|len
operator|-
literal|6
index|]
argument_list|,
literal|"XXXXXX"
argument_list|)
condition|)
block|{
name|__set_errno
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* This is where the Xs start.  */
name|XXXXXX
operator|=
operator|&
name|tmpl
index|[
name|len
operator|-
literal|6
index|]
expr_stmt|;
comment|/* Get some more or less random data.  */
ifdef|#
directive|ifdef
name|RANDOM_BITS
name|RANDOM_BITS
argument_list|(
name|random_time_bits
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|HAVE_GETTIMEOFDAY
operator|||
name|_LIBC
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|__gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|random_time_bits
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|tv
operator|.
name|tv_usec
operator|<<
literal|16
operator|)
operator|^
name|tv
operator|.
name|tv_sec
expr_stmt|;
block|}
else|#
directive|else
name|random_time_bits
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|value
operator|+=
name|random_time_bits
operator|^
name|__getpid
argument_list|()
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|attempts
condition|;
name|value
operator|+=
literal|7777
operator|,
operator|++
name|count
control|)
block|{
name|uint64_t
name|v
init|=
name|value
decl_stmt|;
comment|/* Fill in the random bits.  */
name|XXXXXX
index|[
literal|0
index|]
operator|=
name|letters
index|[
name|v
operator|%
literal|62
index|]
expr_stmt|;
name|v
operator|/=
literal|62
expr_stmt|;
name|XXXXXX
index|[
literal|1
index|]
operator|=
name|letters
index|[
name|v
operator|%
literal|62
index|]
expr_stmt|;
name|v
operator|/=
literal|62
expr_stmt|;
name|XXXXXX
index|[
literal|2
index|]
operator|=
name|letters
index|[
name|v
operator|%
literal|62
index|]
expr_stmt|;
name|v
operator|/=
literal|62
expr_stmt|;
name|XXXXXX
index|[
literal|3
index|]
operator|=
name|letters
index|[
name|v
operator|%
literal|62
index|]
expr_stmt|;
name|v
operator|/=
literal|62
expr_stmt|;
name|XXXXXX
index|[
literal|4
index|]
operator|=
name|letters
index|[
name|v
operator|%
literal|62
index|]
expr_stmt|;
name|v
operator|/=
literal|62
expr_stmt|;
name|XXXXXX
index|[
literal|5
index|]
operator|=
name|letters
index|[
name|v
operator|%
literal|62
index|]
expr_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|__GT_FILE
case|:
name|fd
operator|=
name|__open
argument_list|(
name|tmpl
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
argument_list|)
expr_stmt|;
break|break;
case|case
name|__GT_BIGFILE
case|:
name|fd
operator|=
name|__open64
argument_list|(
name|tmpl
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
argument_list|)
expr_stmt|;
break|break;
case|case
name|__GT_DIR
case|:
name|fd
operator|=
name|__mkdir
argument_list|(
name|tmpl
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
operator||
name|S_IXUSR
argument_list|)
expr_stmt|;
break|break;
case|case
name|__GT_NOCREATE
case|:
comment|/* This case is backward from the other three.  __gen_tempname 	     succeeds if __xstat fails because the name does not exist. 	     Note the continue to bypass the common logic at the bottom 	     of the loop.  */
if|if
condition|(
name|__lxstat64
argument_list|(
name|_STAT_VER
argument_list|,
name|tmpl
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
name|__set_errno
argument_list|(
name|save_errno
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
comment|/* Give up now. */
return|return
operator|-
literal|1
return|;
block|}
continue|continue;
default|default:
name|assert
argument_list|(
operator|!
literal|"invalid KIND in __gen_tempname"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
block|{
name|__set_errno
argument_list|(
name|save_errno
argument_list|)
expr_stmt|;
return|return
name|fd
return|;
block|}
elseif|else
if|if
condition|(
name|errno
operator|!=
name|EEXIST
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* We got out of the loop because we ran out of combinations to try.  */
name|__set_errno
argument_list|(
name|EEXIST
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

end_unit

