begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Support routines for GNU DIFF.    Copyright (C) 1988, 1989, 1992, 1993, 1994 Free Software Foundation, Inc.  This file is part of GNU DIFF.  GNU DIFF is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU DIFF is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU DIFF; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|"diff.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|PR_PROGRAM
end_ifndef

begin_define
define|#
directive|define
name|PR_PROGRAM
value|"/bin/pr"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Queue up one-line messages to be printed at the end,    when -l is specified.  Each message is recorded with a `struct msg'.  */
end_comment

begin_struct
struct|struct
name|msg
block|{
name|struct
name|msg
modifier|*
name|next
decl_stmt|;
name|char
specifier|const
modifier|*
name|format
decl_stmt|;
name|char
specifier|const
modifier|*
name|arg1
decl_stmt|;
name|char
specifier|const
modifier|*
name|arg2
decl_stmt|;
name|char
specifier|const
modifier|*
name|arg3
decl_stmt|;
name|char
specifier|const
modifier|*
name|arg4
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Head of the chain of queues messages.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|msg
modifier|*
name|msg_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tail of the chain of queues messages.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|msg
modifier|*
modifier|*
name|msg_chain_end
init|=
operator|&
name|msg_chain
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Use when a system call returns non-zero status.    TEXT should normally be the file name.  */
end_comment

begin_function
name|void
name|perror_with_name
parameter_list|(
name|text
parameter_list|)
name|char
specifier|const
modifier|*
name|text
decl_stmt|;
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|errno
operator|=
name|e
expr_stmt|;
name|perror
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Use when a system call returns non-zero status and that is fatal.  */
end_comment

begin_function
name|void
name|pfatal_with_name
parameter_list|(
name|text
parameter_list|)
name|char
specifier|const
modifier|*
name|text
decl_stmt|;
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|print_message_queue
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|errno
operator|=
name|e
expr_stmt|;
name|perror
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print an error message from the format-string FORMAT    with args ARG1 and ARG2.  */
end_comment

begin_function
name|void
name|error
parameter_list|(
name|format
parameter_list|,
name|arg
parameter_list|,
name|arg1
parameter_list|)
name|char
specifier|const
modifier|*
name|format
decl_stmt|,
decl|*
name|arg
decl_stmt|,
modifier|*
name|arg1
decl_stmt|;
end_function

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|arg
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Print an error message containing the string TEXT, then exit.  */
end_comment

begin_function
name|void
name|fatal
parameter_list|(
name|m
parameter_list|)
name|char
specifier|const
modifier|*
name|m
decl_stmt|;
block|{
name|print_message_queue
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"%s"
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like printf, except if -l in effect then save the message and print later.    This is used for things like "binary files differ" and "Only in ...".  */
end_comment

begin_function
name|void
name|message
parameter_list|(
name|format
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|char
specifier|const
modifier|*
name|format
decl_stmt|,
decl|*
name|arg1
decl_stmt|,
modifier|*
name|arg2
decl_stmt|;
end_function

begin_block
block|{
name|message5
argument_list|(
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|message5
parameter_list|(
name|format
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|,
name|arg4
parameter_list|)
name|char
specifier|const
modifier|*
name|format
decl_stmt|,
decl|*
name|arg1
decl_stmt|,
modifier|*
name|arg2
decl_stmt|,
modifier|*
name|arg3
decl_stmt|,
modifier|*
name|arg4
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|paginate_flag
condition|)
block|{
name|struct
name|msg
modifier|*
name|new
init|=
operator|(
expr|struct
name|msg
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|msg
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|format
operator|=
name|format
expr_stmt|;
name|new
operator|->
name|arg1
operator|=
name|concat
argument_list|(
name|arg1
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|new
operator|->
name|arg2
operator|=
name|concat
argument_list|(
name|arg2
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|new
operator|->
name|arg3
operator|=
name|arg3
condition|?
name|concat
argument_list|(
name|arg3
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
else|:
literal|0
expr_stmt|;
name|new
operator|->
name|arg4
operator|=
name|arg4
condition|?
name|concat
argument_list|(
name|arg4
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
else|:
literal|0
expr_stmt|;
name|new
operator|->
name|next
operator|=
literal|0
expr_stmt|;
operator|*
name|msg_chain_end
operator|=
name|new
expr_stmt|;
name|msg_chain_end
operator|=
operator|&
name|new
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sdiff_help_sdiff
condition|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
name|arg4
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Output all the messages that were saved up by calls to `message'.  */
end_comment

begin_function
name|void
name|print_message_queue
parameter_list|()
block|{
name|struct
name|msg
modifier|*
name|m
decl_stmt|;
for|for
control|(
name|m
operator|=
name|msg_chain
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
name|printf
argument_list|(
name|m
operator|->
name|format
argument_list|,
name|m
operator|->
name|arg1
argument_list|,
name|m
operator|->
name|arg2
argument_list|,
name|m
operator|->
name|arg3
argument_list|,
name|m
operator|->
name|arg4
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Call before outputting the results of comparing files NAME0 and NAME1    to set up OUTFILE, the stdio stream for the output to go to.     Usually, OUTFILE is just stdout.  But when -l was specified    we fork off a `pr' and make OUTFILE a pipe to it.    `pr' then outputs to our stdout.  */
end_comment

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|current_name0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|current_name1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|current_depth
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|setup_output
parameter_list|(
name|name0
parameter_list|,
name|name1
parameter_list|,
name|depth
parameter_list|)
name|char
specifier|const
modifier|*
name|name0
decl_stmt|,
decl|*
name|name1
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|depth
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|current_name0
operator|=
name|name0
expr_stmt|;
name|current_name1
operator|=
name|name1
expr_stmt|;
name|current_depth
operator|=
name|depth
expr_stmt|;
name|outfile
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_if
if|#
directive|if
name|HAVE_FORK
end_if

begin_decl_stmt
specifier|static
name|pid_t
name|pr_pid
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|begin_output
parameter_list|()
block|{
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|outfile
operator|!=
literal|0
condition|)
return|return;
comment|/* Construct the header of this piece of diff.  */
name|name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|current_name0
argument_list|)
operator|+
name|strlen
argument_list|(
name|current_name1
argument_list|)
operator|+
name|strlen
argument_list|(
name|switch_string
argument_list|)
operator|+
literal|7
argument_list|)
expr_stmt|;
comment|/* Posix.2 section 4.17.6.1.1 specifies this format.  But there is a      bug in the first printing (IEEE Std 1003.2-1992 p 251 l 3304):      it says that we must print only the last component of the pathnames.      This requirement is silly and does not match historical practice.  */
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"diff%s %s %s"
argument_list|,
name|switch_string
argument_list|,
name|current_name0
argument_list|,
name|current_name1
argument_list|)
expr_stmt|;
if|if
condition|(
name|paginate_flag
condition|)
block|{
comment|/* Make OUTFILE a pipe to a subsidiary `pr'.  */
if|#
directive|if
name|HAVE_FORK
name|int
name|pipes
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|pipes
argument_list|)
operator|!=
literal|0
condition|)
name|pfatal_with_name
argument_list|(
literal|"pipe"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|pr_pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pr_pid
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
literal|"vfork"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pr_pid
operator|==
literal|0
condition|)
block|{
name|close
argument_list|(
name|pipes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipes
index|[
literal|0
index|]
operator|!=
name|STDIN_FILENO
condition|)
block|{
if|if
condition|(
name|dup2
argument_list|(
name|pipes
index|[
literal|0
index|]
argument_list|,
name|STDIN_FILENO
argument_list|)
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
literal|"dup2"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pipes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|__FreeBSD__
name|execl
argument_list|(
name|PR_PROGRAM
argument_list|,
name|PR_PROGRAM
argument_list|,
literal|"-F"
argument_list|,
literal|"-h"
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|execl
argument_list|(
name|PR_PROGRAM
argument_list|,
name|PR_PROGRAM
argument_list|,
literal|"-f"
argument_list|,
literal|"-h"
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pfatal_with_name
argument_list|(
name|PR_PROGRAM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|close
argument_list|(
name|pipes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|outfile
operator|=
name|fdopen
argument_list|(
name|pipes
index|[
literal|1
index|]
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outfile
condition|)
name|pfatal_with_name
argument_list|(
literal|"fdopen"
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* ! HAVE_FORK */
name|char
modifier|*
name|command
init|=
name|xmalloc
argument_list|(
literal|4
operator|*
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|PR_PROGRAM
argument_list|)
operator|+
literal|10
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
specifier|const
modifier|*
name|a
init|=
name|name
decl_stmt|;
name|sprintf
argument_list|(
name|command
argument_list|,
literal|"%s -f -h "
argument_list|,
name|PR_PROGRAM
argument_list|)
expr_stmt|;
name|p
operator|=
name|command
operator|+
name|strlen
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|SYSTEM_QUOTE_ARG
argument_list|(
name|p
argument_list|,
name|a
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|outfile
operator|=
name|popen
argument_list|(
name|command
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outfile
condition|)
name|pfatal_with_name
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|command
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! HAVE_FORK */
block|}
else|else
block|{
comment|/* If -l was not specified, output the diff straight to `stdout'.  */
name|outfile
operator|=
name|stdout
expr_stmt|;
comment|/* If handling multiple files (because scanning a directory), 	 print which files the following output is about.  */
if|if
condition|(
name|current_depth
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* A special header is needed at the beginning of context output.  */
switch|switch
condition|(
name|output_style
condition|)
block|{
case|case
name|OUTPUT_CONTEXT
case|:
name|print_context_header
argument_list|(
name|files
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUTPUT_UNIFIED
case|:
name|print_context_header
argument_list|(
name|files
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Call after the end of output of diffs for one file.    Close OUTFILE and get rid of the `pr' subfork.  */
end_comment

begin_function
name|void
name|finish_output
parameter_list|()
block|{
if|if
condition|(
name|outfile
operator|!=
literal|0
operator|&&
name|outfile
operator|!=
name|stdout
condition|)
block|{
name|int
name|wstatus
decl_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|outfile
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"write error"
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|HAVE_FORK
name|wstatus
operator|=
name|pclose
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* HAVE_FORK */
if|if
condition|(
name|fclose
argument_list|(
name|outfile
argument_list|)
operator|!=
literal|0
condition|)
name|pfatal_with_name
argument_list|(
literal|"write error"
argument_list|)
expr_stmt|;
if|if
condition|(
name|waitpid
argument_list|(
name|pr_pid
argument_list|,
operator|&
name|wstatus
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
literal|"waitpid"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_FORK */
if|if
condition|(
name|wstatus
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"subsidiary pr failed"
argument_list|)
expr_stmt|;
block|}
name|outfile
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compare two lines (typically one from each input file)    according to the command line options.    For efficiency, this is invoked only when the lines do not match exactly    but an option like -i might cause us to ignore the difference.    Return nonzero if the lines differ.  */
end_comment

begin_function
name|int
name|line_cmp
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
name|char
specifier|const
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|unsigned
name|char
specifier|const
modifier|*
name|t1
init|=
operator|(
name|unsigned
name|char
specifier|const
operator|*
operator|)
name|s1
decl_stmt|;
specifier|register
name|unsigned
name|char
specifier|const
modifier|*
name|t2
init|=
operator|(
name|unsigned
name|char
specifier|const
operator|*
operator|)
name|s2
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
specifier|register
name|unsigned
name|char
name|c1
init|=
operator|*
name|t1
operator|++
decl_stmt|;
specifier|register
name|unsigned
name|char
name|c2
init|=
operator|*
name|t2
operator|++
decl_stmt|;
comment|/* Test for exact char equality first, since it's a common case.  */
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
block|{
comment|/* Ignore horizontal white space if -b or -w is specified.  */
if|if
condition|(
name|ignore_all_space_flag
condition|)
block|{
comment|/* For -w, just skip past any white space.  */
while|while
condition|(
name|ISSPACE
argument_list|(
name|c1
argument_list|)
operator|&&
name|c1
operator|!=
literal|'\n'
condition|)
name|c1
operator|=
operator|*
name|t1
operator|++
expr_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
name|c2
argument_list|)
operator|&&
name|c2
operator|!=
literal|'\n'
condition|)
name|c2
operator|=
operator|*
name|t2
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ignore_space_change_flag
condition|)
block|{
comment|/* For -b, advance past any sequence of white space in line 1 		 and consider it just one Space, or nothing at all 		 if it is at the end of the line.  */
if|if
condition|(
name|ISSPACE
argument_list|(
name|c1
argument_list|)
condition|)
block|{
while|while
condition|(
name|c1
operator|!=
literal|'\n'
condition|)
block|{
name|c1
operator|=
operator|*
name|t1
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ISSPACE
argument_list|(
name|c1
argument_list|)
condition|)
block|{
operator|--
name|t1
expr_stmt|;
name|c1
operator|=
literal|' '
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Likewise for line 2.  */
if|if
condition|(
name|ISSPACE
argument_list|(
name|c2
argument_list|)
condition|)
block|{
while|while
condition|(
name|c2
operator|!=
literal|'\n'
condition|)
block|{
name|c2
operator|=
operator|*
name|t2
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ISSPACE
argument_list|(
name|c2
argument_list|)
condition|)
block|{
operator|--
name|t2
expr_stmt|;
name|c2
operator|=
literal|' '
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
block|{
comment|/* If we went too far when doing the simple test 		     for equality, go back to the first non-white-space 		     character in both sides and try again.  */
if|if
condition|(
name|c2
operator|==
literal|' '
operator|&&
name|c1
operator|!=
literal|'\n'
operator|&&
operator|(
name|unsigned
name|char
specifier|const
operator|*
operator|)
name|s1
operator|+
literal|1
operator|<
name|t1
operator|&&
name|ISSPACE
argument_list|(
name|t1
index|[
operator|-
literal|2
index|]
argument_list|)
condition|)
block|{
operator|--
name|t1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c1
operator|==
literal|' '
operator|&&
name|c2
operator|!=
literal|'\n'
operator|&&
operator|(
name|unsigned
name|char
specifier|const
operator|*
operator|)
name|s2
operator|+
literal|1
operator|<
name|t2
operator|&&
name|ISSPACE
argument_list|(
name|t2
index|[
operator|-
literal|2
index|]
argument_list|)
condition|)
block|{
operator|--
name|t2
expr_stmt|;
continue|continue;
block|}
block|}
block|}
comment|/* Lowercase all letters if -i is specified.  */
if|if
condition|(
name|ignore_case_flag
condition|)
block|{
if|if
condition|(
name|ISUPPER
argument_list|(
name|c1
argument_list|)
condition|)
name|c1
operator|=
name|tolower
argument_list|(
name|c1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISUPPER
argument_list|(
name|c2
argument_list|)
condition|)
name|c2
operator|=
name|tolower
argument_list|(
name|c2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
break|break;
block|}
if|if
condition|(
name|c1
operator|==
literal|'\n'
condition|)
return|return
literal|0
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Find the consecutive changes at the start of the script START.    Return the last link before the first gap.  */
end_comment

begin_function
name|struct
name|change
modifier|*
name|find_change
parameter_list|(
name|start
parameter_list|)
name|struct
name|change
modifier|*
name|start
decl_stmt|;
block|{
return|return
name|start
return|;
block|}
end_function

begin_function
name|struct
name|change
modifier|*
name|find_reverse_change
parameter_list|(
name|start
parameter_list|)
name|struct
name|change
modifier|*
name|start
decl_stmt|;
block|{
return|return
name|start
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Divide SCRIPT into pieces by calling HUNKFUN and    print each piece with PRINTFUN.    Both functions take one arg, an edit script.     HUNKFUN is called with the tail of the script    and returns the last link that belongs together with the start    of the tail.     PRINTFUN takes a subscript which belongs together (with a null    link at the end) and prints it.  */
end_comment

begin_decl_stmt
name|void
name|print_script
argument_list|(
name|script
argument_list|,
name|hunkfun
argument_list|,
name|printfun
argument_list|)
decl|struct
name|change
modifier|*
name|script
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|change
modifier|*
argument_list|(
operator|*
name|hunkfun
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|change
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_macro
name|void
argument_list|(
argument|*printfun
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
expr|struct
name|change
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|change
modifier|*
name|next
init|=
name|script
decl_stmt|;
while|while
condition|(
name|next
condition|)
block|{
name|struct
name|change
modifier|*
name|this
decl_stmt|,
modifier|*
name|end
decl_stmt|;
comment|/* Find a set of changes that belong together.  */
name|this
operator|=
name|next
expr_stmt|;
name|end
operator|=
call|(
modifier|*
name|hunkfun
call|)
argument_list|(
name|next
argument_list|)
expr_stmt|;
comment|/* Disconnect them from the rest of the changes, 	 making them a hunk, and remember the rest for next iteration.  */
name|next
operator|=
name|end
operator|->
name|link
expr_stmt|;
name|end
operator|->
name|link
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|debug_script
argument_list|(
name|this
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Print this hunk.  */
call|(
modifier|*
name|printfun
call|)
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|/* Reconnect the script so it will all be freed properly.  */
name|end
operator|->
name|link
operator|=
name|next
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Print the text of a single line LINE,    flagging it with the characters in LINE_FLAG (which say whether    the line is inserted, deleted, changed, etc.).  */
end_comment

begin_function
name|void
name|print_1_line
parameter_list|(
name|line_flag
parameter_list|,
name|line
parameter_list|)
name|char
specifier|const
modifier|*
name|line_flag
decl_stmt|;
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|line
decl_stmt|;
block|{
name|char
specifier|const
modifier|*
name|text
init|=
name|line
index|[
literal|0
index|]
decl_stmt|,
modifier|*
name|limit
init|=
name|line
index|[
literal|1
index|]
decl_stmt|;
comment|/* Help the compiler.  */
name|FILE
modifier|*
name|out
init|=
name|outfile
decl_stmt|;
comment|/* Help the compiler some more.  */
name|char
specifier|const
modifier|*
name|flag_format
init|=
literal|0
decl_stmt|;
comment|/* If -T was specified, use a Tab between the line-flag and the text.      Otherwise use a Space (as Unix diff does).      Print neither space nor tab if line-flags are empty.  */
if|if
condition|(
name|line_flag
operator|&&
operator|*
name|line_flag
condition|)
block|{
name|flag_format
operator|=
name|tab_align_flag
condition|?
literal|"%s\t"
else|:
literal|"%s "
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
name|flag_format
argument_list|,
name|line_flag
argument_list|)
expr_stmt|;
block|}
name|output_1_line
argument_list|(
name|text
argument_list|,
name|limit
argument_list|,
name|flag_format
argument_list|,
name|line_flag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|line_flag
operator|||
name|line_flag
index|[
literal|0
index|]
operator|)
operator|&&
name|limit
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n\\ No newline at end of file\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a line from TEXT up to LIMIT.  Without -t, output verbatim.    With -t, expand white space characters to spaces, and if FLAG_FORMAT    is nonzero, output it with argument LINE_FLAG after every    internal carriage return, so that tab stops continue to line up.  */
end_comment

begin_function
name|void
name|output_1_line
parameter_list|(
name|text
parameter_list|,
name|limit
parameter_list|,
name|flag_format
parameter_list|,
name|line_flag
parameter_list|)
name|char
specifier|const
modifier|*
name|text
decl_stmt|,
decl|*
name|limit
decl_stmt|,
modifier|*
name|flag_format
decl_stmt|,
modifier|*
name|line_flag
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
operator|!
name|tab_expand_flag
condition|)
name|fwrite
argument_list|(
name|text
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|limit
operator|-
name|text
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
else|else
block|{
specifier|register
name|FILE
modifier|*
name|out
init|=
name|outfile
decl_stmt|;
specifier|register
name|unsigned
name|char
name|c
decl_stmt|;
specifier|register
name|char
specifier|const
modifier|*
name|t
init|=
name|text
decl_stmt|;
specifier|register
name|unsigned
name|column
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|t
operator|<
name|limit
condition|)
switch|switch
condition|(
operator|(
name|c
operator|=
operator|*
name|t
operator|++
operator|)
condition|)
block|{
case|case
literal|'\t'
case|:
block|{
name|unsigned
name|spaces
init|=
name|TAB_WIDTH
operator|-
name|column
operator|%
name|TAB_WIDTH
decl_stmt|;
name|column
operator|+=
name|spaces
expr_stmt|;
do|do
name|putc
argument_list|(
literal|' '
argument_list|,
name|out
argument_list|)
expr_stmt|;
do|while
condition|(
operator|--
name|spaces
condition|)
do|;
block|}
break|break;
case|case
literal|'\r'
case|:
name|putc
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_format
operator|&&
name|t
operator|<
name|limit
operator|&&
operator|*
name|t
operator|!=
literal|'\n'
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
name|flag_format
argument_list|,
name|line_flag
argument_list|)
expr_stmt|;
name|column
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
if|if
condition|(
name|column
operator|==
literal|0
condition|)
continue|continue;
name|column
operator|--
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|ISPRINT
argument_list|(
name|c
argument_list|)
condition|)
name|column
operator|++
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_block

begin_function
name|int
name|change_letter
parameter_list|(
name|inserts
parameter_list|,
name|deletes
parameter_list|)
name|int
name|inserts
decl_stmt|,
name|deletes
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|inserts
condition|)
return|return
literal|'d'
return|;
elseif|else
if|if
condition|(
operator|!
name|deletes
condition|)
return|return
literal|'a'
return|;
else|else
return|return
literal|'c'
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Translate an internal line number (an index into diff's table of lines)    into an actual line number in the input file.    The internal line number is LNUM.  FILE points to the data on the file.     Internal line numbers count from 0 starting after the prefix.    Actual line numbers count from 1 within the entire file.  */
end_comment

begin_function
name|int
name|translate_line_number
parameter_list|(
name|file
parameter_list|,
name|lnum
parameter_list|)
name|struct
name|file_data
specifier|const
modifier|*
name|file
decl_stmt|;
name|int
name|lnum
decl_stmt|;
block|{
return|return
name|lnum
operator|+
name|file
operator|->
name|prefix_lines
operator|+
literal|1
return|;
block|}
end_function

begin_function
name|void
name|translate_range
parameter_list|(
name|file
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|aptr
parameter_list|,
name|bptr
parameter_list|)
name|struct
name|file_data
specifier|const
modifier|*
name|file
decl_stmt|;
name|int
name|a
decl_stmt|,
name|b
decl_stmt|;
name|int
modifier|*
name|aptr
decl_stmt|,
decl|*
name|bptr
decl_stmt|;
end_function

begin_block
block|{
operator|*
name|aptr
operator|=
name|translate_line_number
argument_list|(
name|file
argument_list|,
name|a
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|*
name|bptr
operator|=
name|translate_line_number
argument_list|(
name|file
argument_list|,
name|b
operator|+
literal|1
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Print a pair of line numbers with SEPCHAR, translated for file FILE.    If the two numbers are identical, print just one number.     Args A and B are internal line numbers.    We print the translated (real) line numbers.  */
end_comment

begin_function
name|void
name|print_number_range
parameter_list|(
name|sepchar
parameter_list|,
name|file
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|)
name|int
name|sepchar
decl_stmt|;
name|struct
name|file_data
modifier|*
name|file
decl_stmt|;
name|int
name|a
decl_stmt|,
name|b
decl_stmt|;
block|{
name|int
name|trans_a
decl_stmt|,
name|trans_b
decl_stmt|;
name|translate_range
argument_list|(
name|file
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
operator|&
name|trans_a
argument_list|,
operator|&
name|trans_b
argument_list|)
expr_stmt|;
comment|/* Note: we can have B< A in the case of a range of no lines.      In this case, we should print the line number before the range,      which is B.  */
if|if
condition|(
name|trans_b
operator|>
name|trans_a
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%d%c%d"
argument_list|,
name|trans_a
argument_list|,
name|sepchar
argument_list|,
name|trans_b
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%d"
argument_list|,
name|trans_b
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look at a hunk of edit script and report the range of lines in each file    that it applies to.  HUNK is the start of the hunk, which is a chain    of `struct change'.  The first and last line numbers of file 0 are stored in    *FIRST0 and *LAST0, and likewise for file 1 in *FIRST1 and *LAST1.    Note that these are internal line numbers that count from 0.     If no lines from file 0 are deleted, then FIRST0 is LAST0+1.     Also set *DELETES nonzero if any lines of file 0 are deleted    and set *INSERTS nonzero if any lines of file 1 are inserted.    If only ignorable lines are inserted or deleted, both are    set to 0.  */
end_comment

begin_function
name|void
name|analyze_hunk
parameter_list|(
name|hunk
parameter_list|,
name|first0
parameter_list|,
name|last0
parameter_list|,
name|first1
parameter_list|,
name|last1
parameter_list|,
name|deletes
parameter_list|,
name|inserts
parameter_list|)
name|struct
name|change
modifier|*
name|hunk
decl_stmt|;
name|int
modifier|*
name|first0
decl_stmt|,
decl|*
name|last0
decl_stmt|,
modifier|*
name|first1
decl_stmt|,
modifier|*
name|last1
decl_stmt|;
end_function

begin_decl_stmt
name|int
modifier|*
name|deletes
decl_stmt|,
modifier|*
name|inserts
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|l0
decl_stmt|,
name|l1
decl_stmt|,
name|show_from
decl_stmt|,
name|show_to
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|trivial
init|=
name|ignore_blank_lines_flag
operator|||
name|ignore_regexp_list
decl_stmt|;
name|struct
name|change
modifier|*
name|next
decl_stmt|;
name|show_from
operator|=
name|show_to
operator|=
literal|0
expr_stmt|;
operator|*
name|first0
operator|=
name|hunk
operator|->
name|line0
expr_stmt|;
operator|*
name|first1
operator|=
name|hunk
operator|->
name|line1
expr_stmt|;
name|next
operator|=
name|hunk
expr_stmt|;
do|do
block|{
name|l0
operator|=
name|next
operator|->
name|line0
operator|+
name|next
operator|->
name|deleted
operator|-
literal|1
expr_stmt|;
name|l1
operator|=
name|next
operator|->
name|line1
operator|+
name|next
operator|->
name|inserted
operator|-
literal|1
expr_stmt|;
name|show_from
operator|+=
name|next
operator|->
name|deleted
expr_stmt|;
name|show_to
operator|+=
name|next
operator|->
name|inserted
expr_stmt|;
for|for
control|(
name|i
operator|=
name|next
operator|->
name|line0
init|;
name|i
operator|<=
name|l0
operator|&&
name|trivial
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|ignore_blank_lines_flag
operator|||
name|files
index|[
literal|0
index|]
operator|.
name|linbuf
index|[
name|i
index|]
index|[
literal|0
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|struct
name|regexp_list
modifier|*
name|r
decl_stmt|;
name|char
specifier|const
modifier|*
name|line
init|=
name|files
index|[
literal|0
index|]
operator|.
name|linbuf
index|[
name|i
index|]
decl_stmt|;
name|int
name|len
init|=
name|files
index|[
literal|0
index|]
operator|.
name|linbuf
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|line
decl_stmt|;
for|for
control|(
name|r
operator|=
name|ignore_regexp_list
init|;
name|r
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
if|if
condition|(
literal|0
operator|<=
name|re_search
argument_list|(
operator|&
name|r
operator|->
name|buf
argument_list|,
name|line
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
comment|/* Found a match.  Ignore this line.  */
comment|/* If we got all the way through the regexp list without 	       finding a match, then it's nontrivial.  */
if|if
condition|(
operator|!
name|r
condition|)
name|trivial
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|next
operator|->
name|line1
init|;
name|i
operator|<=
name|l1
operator|&&
name|trivial
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|ignore_blank_lines_flag
operator|||
name|files
index|[
literal|1
index|]
operator|.
name|linbuf
index|[
name|i
index|]
index|[
literal|0
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|struct
name|regexp_list
modifier|*
name|r
decl_stmt|;
name|char
specifier|const
modifier|*
name|line
init|=
name|files
index|[
literal|1
index|]
operator|.
name|linbuf
index|[
name|i
index|]
decl_stmt|;
name|int
name|len
init|=
name|files
index|[
literal|1
index|]
operator|.
name|linbuf
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|line
decl_stmt|;
for|for
control|(
name|r
operator|=
name|ignore_regexp_list
init|;
name|r
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
if|if
condition|(
literal|0
operator|<=
name|re_search
argument_list|(
operator|&
name|r
operator|->
name|buf
argument_list|,
name|line
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
comment|/* Found a match.  Ignore this line.  */
comment|/* If we got all the way through the regexp list without 	       finding a match, then it's nontrivial.  */
if|if
condition|(
operator|!
name|r
condition|)
name|trivial
operator|=
literal|0
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|next
operator|=
name|next
operator|->
name|link
operator|)
operator|!=
literal|0
condition|)
do|;
operator|*
name|last0
operator|=
name|l0
expr_stmt|;
operator|*
name|last1
operator|=
name|l1
expr_stmt|;
comment|/* If all inserted or deleted lines are ignorable,      tell the caller to ignore this hunk.  */
if|if
condition|(
name|trivial
condition|)
name|show_from
operator|=
name|show_to
operator|=
literal|0
expr_stmt|;
operator|*
name|deletes
operator|=
name|show_from
expr_stmt|;
operator|*
name|inserts
operator|=
name|show_to
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* malloc a block of memory, with fatal error message if we can't do it. */
end_comment

begin_function
name|VOID
modifier|*
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|size_t
name|size
decl_stmt|;
block|{
specifier|register
name|VOID
modifier|*
name|value
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|size
operator|=
literal|1
expr_stmt|;
name|value
operator|=
operator|(
name|VOID
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|value
condition|)
name|fatal
argument_list|(
literal|"memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* realloc a block of memory, with fatal error message if we can't do it. */
end_comment

begin_function
name|VOID
modifier|*
name|xrealloc
parameter_list|(
name|old
parameter_list|,
name|size
parameter_list|)
name|VOID
modifier|*
name|old
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
specifier|register
name|VOID
modifier|*
name|value
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|size
operator|=
literal|1
expr_stmt|;
name|value
operator|=
operator|(
name|VOID
operator|*
operator|)
name|realloc
argument_list|(
name|old
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|value
condition|)
name|fatal
argument_list|(
literal|"memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Concatenate three strings, returning a newly malloc'd string.  */
end_comment

begin_function
name|char
modifier|*
name|concat
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|s3
parameter_list|)
name|char
specifier|const
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|,
modifier|*
name|s3
decl_stmt|;
end_function

begin_block
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|s1
argument_list|)
operator|+
name|strlen
argument_list|(
name|s2
argument_list|)
operator|+
name|strlen
argument_list|(
name|s3
argument_list|)
decl_stmt|;
name|char
modifier|*
name|new
init|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|new
argument_list|,
literal|"%s%s%s"
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|,
name|s3
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_block

begin_comment
comment|/* Yield the newly malloc'd pathname    of the file in DIR whose filename is FILE.  */
end_comment

begin_function
name|char
modifier|*
name|dir_file_pathname
parameter_list|(
name|dir
parameter_list|,
name|file
parameter_list|)
name|char
specifier|const
modifier|*
name|dir
decl_stmt|,
decl|*
name|file
decl_stmt|;
end_function

begin_block
block|{
name|char
specifier|const
modifier|*
name|p
init|=
name|filename_lastdirchar
argument_list|(
name|dir
argument_list|)
decl_stmt|;
return|return
name|concat
argument_list|(
name|dir
argument_list|,
literal|"/"
operator|+
operator|(
name|p
operator|&&
operator|!
name|p
index|[
literal|1
index|]
operator|)
argument_list|,
name|file
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_function
name|void
name|debug_script
parameter_list|(
name|sp
parameter_list|)
name|struct
name|change
modifier|*
name|sp
decl_stmt|;
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|link
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%3d %3d delete %d insert %d\n"
argument_list|,
name|sp
operator|->
name|line0
argument_list|,
name|sp
operator|->
name|line1
argument_list|,
name|sp
operator|->
name|deleted
argument_list|,
name|sp
operator|->
name|inserted
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

