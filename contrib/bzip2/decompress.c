begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-------------------------------------------------------------*/
end_comment

begin_comment
comment|/*--- Decompression machinery                               ---*/
end_comment

begin_comment
comment|/*---                                          decompress.c ---*/
end_comment

begin_comment
comment|/*-------------------------------------------------------------*/
end_comment

begin_comment
comment|/*--   This file is a part of bzip2 and/or libbzip2, a program and   library for lossless, block-sorting data compression.    Copyright (C) 1996-2005 Julian R Seward.  All rights reserved.    Redistribution and use in source and binary forms, with or without   modification, are permitted provided that the following conditions   are met:    1. Redistributions of source code must retain the above copyright      notice, this list of conditions and the following disclaimer.    2. The origin of this software must not be misrepresented; you must       not claim that you wrote the original software.  If you use this       software in a product, an acknowledgment in the product       documentation would be appreciated but is not required.    3. Altered source versions must be plainly marked as such, and must      not be misrepresented as being the original software.    4. The name of the author may not be used to endorse or promote       products derived from this software without specific prior written       permission.    THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS   OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY   DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.    Julian Seward, Cambridge, UK.   jseward@bzip.org   bzip2/libbzip2 version 1.0 of 21 March 2000    This program is based on (at least) the work of:      Mike Burrows      David Wheeler      Peter Fenwick      Alistair Moffat      Radford Neal      Ian H. Witten      Robert Sedgewick      Jon L. Bentley    For more information on these sources, see the manual. --*/
end_comment

begin_include
include|#
directive|include
file|"bzlib_private.h"
end_include

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|makeMaps_d
parameter_list|(
name|DState
modifier|*
name|s
parameter_list|)
block|{
name|Int32
name|i
decl_stmt|;
name|s
operator|->
name|nInUse
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|s
operator|->
name|inUse
index|[
name|i
index|]
condition|)
block|{
name|s
operator|->
name|seqToUnseq
index|[
name|s
operator|->
name|nInUse
index|]
operator|=
name|i
expr_stmt|;
name|s
operator|->
name|nInUse
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_define
define|#
directive|define
name|RETURN
parameter_list|(
name|rrr
parameter_list|)
define|\
value|{ retVal = rrr; goto save_state_and_return; };
end_define

begin_define
define|#
directive|define
name|GET_BITS
parameter_list|(
name|lll
parameter_list|,
name|vvv
parameter_list|,
name|nnn
parameter_list|)
define|\
value|case lll: s->state = lll;                      \    while (True) {                                 \       if (s->bsLive>= nnn) {                     \          UInt32 v;                                \          v = (s->bsBuff>>                        \              (s->bsLive-nnn))& ((1<< nnn)-1);   \          s->bsLive -= nnn;                        \          vvv = v;                                 \          break;                                   \       }                                           \       if (s->strm->avail_in == 0) RETURN(BZ_OK);  \       s->bsBuff                                   \          = (s->bsBuff<< 8) |                     \            ((UInt32)                              \               (*((UChar*)(s->strm->next_in))));   \       s->bsLive += 8;                             \       s->strm->next_in++;                         \       s->strm->avail_in--;                        \       s->strm->total_in_lo32++;                   \       if (s->strm->total_in_lo32 == 0)            \          s->strm->total_in_hi32++;                \    }
end_define

begin_define
define|#
directive|define
name|GET_UCHAR
parameter_list|(
name|lll
parameter_list|,
name|uuu
parameter_list|)
define|\
value|GET_BITS(lll,uuu,8)
end_define

begin_define
define|#
directive|define
name|GET_BIT
parameter_list|(
name|lll
parameter_list|,
name|uuu
parameter_list|)
define|\
value|GET_BITS(lll,uuu,1)
end_define

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_define
define|#
directive|define
name|GET_MTF_VAL
parameter_list|(
name|label1
parameter_list|,
name|label2
parameter_list|,
name|lval
parameter_list|)
define|\
value|{                                                 \    if (groupPos == 0) {                           \       groupNo++;                                  \       if (groupNo>= nSelectors)                  \          RETURN(BZ_DATA_ERROR);                   \       groupPos = BZ_G_SIZE;                       \       gSel = s->selector[groupNo];                \       gMinlen = s->minLens[gSel];                 \       gLimit =&(s->limit[gSel][0]);              \       gPerm =&(s->perm[gSel][0]);                \       gBase =&(s->base[gSel][0]);                \    }                                              \    groupPos--;                                    \    zn = gMinlen;                                  \    GET_BITS(label1, zvec, zn);                    \    while (1) {                                    \       if (zn> 20
comment|/* the longest code */
value|)         \          RETURN(BZ_DATA_ERROR);                   \       if (zvec<= gLimit[zn]) break;              \       zn++;                                       \       GET_BIT(label2, zj);                        \       zvec = (zvec<< 1) | zj;                    \    };                                             \    if (zvec - gBase[zn]< 0                       \        || zvec - gBase[zn]>= BZ_MAX_ALPHA_SIZE)  \       RETURN(BZ_DATA_ERROR);                      \    lval = gPerm[zvec - gBase[zn]];                \ }
end_define

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_function
name|Int32
name|BZ2_decompress
parameter_list|(
name|DState
modifier|*
name|s
parameter_list|)
block|{
name|UChar
name|uc
decl_stmt|;
name|Int32
name|retVal
decl_stmt|;
name|Int32
name|minLen
decl_stmt|,
name|maxLen
decl_stmt|;
name|bz_stream
modifier|*
name|strm
init|=
name|s
operator|->
name|strm
decl_stmt|;
comment|/* stuff that needs to be saved/restored */
name|Int32
name|i
decl_stmt|;
name|Int32
name|j
decl_stmt|;
name|Int32
name|t
decl_stmt|;
name|Int32
name|alphaSize
decl_stmt|;
name|Int32
name|nGroups
decl_stmt|;
name|Int32
name|nSelectors
decl_stmt|;
name|Int32
name|EOB
decl_stmt|;
name|Int32
name|groupNo
decl_stmt|;
name|Int32
name|groupPos
decl_stmt|;
name|Int32
name|nextSym
decl_stmt|;
name|Int32
name|nblockMAX
decl_stmt|;
name|Int32
name|nblock
decl_stmt|;
name|Int32
name|es
decl_stmt|;
name|Int32
name|N
decl_stmt|;
name|Int32
name|curr
decl_stmt|;
name|Int32
name|zt
decl_stmt|;
name|Int32
name|zn
decl_stmt|;
name|Int32
name|zvec
decl_stmt|;
name|Int32
name|zj
decl_stmt|;
name|Int32
name|gSel
decl_stmt|;
name|Int32
name|gMinlen
decl_stmt|;
name|Int32
modifier|*
name|gLimit
decl_stmt|;
name|Int32
modifier|*
name|gBase
decl_stmt|;
name|Int32
modifier|*
name|gPerm
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|BZ_X_MAGIC_1
condition|)
block|{
comment|/*initialise the save area*/
name|s
operator|->
name|save_i
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|save_j
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|save_t
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|save_alphaSize
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|save_nGroups
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|save_nSelectors
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|save_EOB
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|save_groupNo
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|save_groupPos
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|save_nextSym
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|save_nblockMAX
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|save_nblock
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|save_es
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|save_N
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|save_curr
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|save_zt
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|save_zn
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|save_zvec
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|save_zj
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|save_gSel
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|save_gMinlen
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|save_gLimit
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|save_gBase
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|save_gPerm
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*restore from the save area*/
name|i
operator|=
name|s
operator|->
name|save_i
expr_stmt|;
name|j
operator|=
name|s
operator|->
name|save_j
expr_stmt|;
name|t
operator|=
name|s
operator|->
name|save_t
expr_stmt|;
name|alphaSize
operator|=
name|s
operator|->
name|save_alphaSize
expr_stmt|;
name|nGroups
operator|=
name|s
operator|->
name|save_nGroups
expr_stmt|;
name|nSelectors
operator|=
name|s
operator|->
name|save_nSelectors
expr_stmt|;
name|EOB
operator|=
name|s
operator|->
name|save_EOB
expr_stmt|;
name|groupNo
operator|=
name|s
operator|->
name|save_groupNo
expr_stmt|;
name|groupPos
operator|=
name|s
operator|->
name|save_groupPos
expr_stmt|;
name|nextSym
operator|=
name|s
operator|->
name|save_nextSym
expr_stmt|;
name|nblockMAX
operator|=
name|s
operator|->
name|save_nblockMAX
expr_stmt|;
name|nblock
operator|=
name|s
operator|->
name|save_nblock
expr_stmt|;
name|es
operator|=
name|s
operator|->
name|save_es
expr_stmt|;
name|N
operator|=
name|s
operator|->
name|save_N
expr_stmt|;
name|curr
operator|=
name|s
operator|->
name|save_curr
expr_stmt|;
name|zt
operator|=
name|s
operator|->
name|save_zt
expr_stmt|;
name|zn
operator|=
name|s
operator|->
name|save_zn
expr_stmt|;
name|zvec
operator|=
name|s
operator|->
name|save_zvec
expr_stmt|;
name|zj
operator|=
name|s
operator|->
name|save_zj
expr_stmt|;
name|gSel
operator|=
name|s
operator|->
name|save_gSel
expr_stmt|;
name|gMinlen
operator|=
name|s
operator|->
name|save_gMinlen
expr_stmt|;
name|gLimit
operator|=
name|s
operator|->
name|save_gLimit
expr_stmt|;
name|gBase
operator|=
name|s
operator|->
name|save_gBase
expr_stmt|;
name|gPerm
operator|=
name|s
operator|->
name|save_gPerm
expr_stmt|;
name|retVal
operator|=
name|BZ_OK
expr_stmt|;
switch|switch
condition|(
name|s
operator|->
name|state
condition|)
block|{
name|GET_UCHAR
argument_list|(
name|BZ_X_MAGIC_1
argument_list|,
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|!=
name|BZ_HDR_B
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR_MAGIC
argument_list|)
expr_stmt|;
name|GET_UCHAR
argument_list|(
name|BZ_X_MAGIC_2
argument_list|,
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|!=
name|BZ_HDR_Z
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR_MAGIC
argument_list|)
expr_stmt|;
name|GET_UCHAR
argument_list|(
argument|BZ_X_MAGIC_3
argument_list|,
argument|uc
argument_list|)
if|if
condition|(
name|uc
operator|!=
name|BZ_HDR_h
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR_MAGIC
argument_list|)
expr_stmt|;
name|GET_BITS
argument_list|(
argument|BZ_X_MAGIC_4
argument_list|,
argument|s->blockSize100k
argument_list|,
literal|8
argument_list|)
if|if
condition|(
name|s
operator|->
name|blockSize100k
operator|<
operator|(
name|BZ_HDR_0
operator|+
literal|1
operator|)
operator|||
name|s
operator|->
name|blockSize100k
operator|>
operator|(
name|BZ_HDR_0
operator|+
literal|9
operator|)
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR_MAGIC
argument_list|)
expr_stmt|;
name|s
operator|->
name|blockSize100k
operator|-=
name|BZ_HDR_0
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|smallDecompress
condition|)
block|{
name|s
operator|->
name|ll16
operator|=
name|BZALLOC
argument_list|(
name|s
operator|->
name|blockSize100k
operator|*
literal|100000
operator|*
sizeof|sizeof
argument_list|(
name|UInt16
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|ll4
operator|=
name|BZALLOC
argument_list|(
operator|(
operator|(
literal|1
operator|+
name|s
operator|->
name|blockSize100k
operator|*
literal|100000
operator|)
operator|>>
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|UChar
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|ll16
operator|==
name|NULL
operator|||
name|s
operator|->
name|ll4
operator|==
name|NULL
condition|)
name|RETURN
argument_list|(
name|BZ_MEM_ERROR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|->
name|tt
operator|=
name|BZALLOC
argument_list|(
name|s
operator|->
name|blockSize100k
operator|*
literal|100000
operator|*
sizeof|sizeof
argument_list|(
name|Int32
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|tt
operator|==
name|NULL
condition|)
name|RETURN
argument_list|(
name|BZ_MEM_ERROR
argument_list|)
expr_stmt|;
block|}
name|GET_UCHAR
argument_list|(
name|BZ_X_BLKHDR_1
argument_list|,
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|==
literal|0x17
condition|)
goto|goto
name|endhdr_2
goto|;
if|if
condition|(
name|uc
operator|!=
literal|0x31
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
name|GET_UCHAR
argument_list|(
name|BZ_X_BLKHDR_2
argument_list|,
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|!=
literal|0x41
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
name|GET_UCHAR
argument_list|(
name|BZ_X_BLKHDR_3
argument_list|,
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|!=
literal|0x59
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
name|GET_UCHAR
argument_list|(
name|BZ_X_BLKHDR_4
argument_list|,
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|!=
literal|0x26
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
name|GET_UCHAR
argument_list|(
name|BZ_X_BLKHDR_5
argument_list|,
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|!=
literal|0x53
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
name|GET_UCHAR
argument_list|(
name|BZ_X_BLKHDR_6
argument_list|,
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|!=
literal|0x59
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
name|s
operator|->
name|currBlockNo
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|verbosity
operator|>=
literal|2
condition|)
name|VPrintf1
argument_list|(
literal|"\n    [%d: huff+mtf "
argument_list|,
name|s
operator|->
name|currBlockNo
argument_list|)
expr_stmt|;
name|s
operator|->
name|storedBlockCRC
operator|=
literal|0
expr_stmt|;
name|GET_UCHAR
argument_list|(
name|BZ_X_BCRC_1
argument_list|,
name|uc
argument_list|)
expr_stmt|;
name|s
operator|->
name|storedBlockCRC
operator|=
operator|(
name|s
operator|->
name|storedBlockCRC
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|UInt32
operator|)
name|uc
operator|)
expr_stmt|;
name|GET_UCHAR
argument_list|(
name|BZ_X_BCRC_2
argument_list|,
name|uc
argument_list|)
expr_stmt|;
name|s
operator|->
name|storedBlockCRC
operator|=
operator|(
name|s
operator|->
name|storedBlockCRC
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|UInt32
operator|)
name|uc
operator|)
expr_stmt|;
name|GET_UCHAR
argument_list|(
name|BZ_X_BCRC_3
argument_list|,
name|uc
argument_list|)
expr_stmt|;
name|s
operator|->
name|storedBlockCRC
operator|=
operator|(
name|s
operator|->
name|storedBlockCRC
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|UInt32
operator|)
name|uc
operator|)
expr_stmt|;
name|GET_UCHAR
argument_list|(
name|BZ_X_BCRC_4
argument_list|,
name|uc
argument_list|)
expr_stmt|;
name|s
operator|->
name|storedBlockCRC
operator|=
operator|(
name|s
operator|->
name|storedBlockCRC
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|UInt32
operator|)
name|uc
operator|)
expr_stmt|;
name|GET_BITS
argument_list|(
name|BZ_X_RANDBIT
argument_list|,
name|s
operator|->
name|blockRandomised
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|s
operator|->
name|origPtr
operator|=
literal|0
expr_stmt|;
name|GET_UCHAR
argument_list|(
name|BZ_X_ORIGPTR_1
argument_list|,
name|uc
argument_list|)
expr_stmt|;
name|s
operator|->
name|origPtr
operator|=
operator|(
name|s
operator|->
name|origPtr
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|Int32
operator|)
name|uc
operator|)
expr_stmt|;
name|GET_UCHAR
argument_list|(
name|BZ_X_ORIGPTR_2
argument_list|,
name|uc
argument_list|)
expr_stmt|;
name|s
operator|->
name|origPtr
operator|=
operator|(
name|s
operator|->
name|origPtr
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|Int32
operator|)
name|uc
operator|)
expr_stmt|;
name|GET_UCHAR
argument_list|(
name|BZ_X_ORIGPTR_3
argument_list|,
name|uc
argument_list|)
expr_stmt|;
name|s
operator|->
name|origPtr
operator|=
operator|(
name|s
operator|->
name|origPtr
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|Int32
operator|)
name|uc
operator|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|origPtr
operator|<
literal|0
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|origPtr
operator|>
literal|10
operator|+
literal|100000
operator|*
name|s
operator|->
name|blockSize100k
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
comment|/*--- Receive the mapping table ---*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|GET_BIT
argument_list|(
name|BZ_X_MAPPING_1
argument_list|,
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|==
literal|1
condition|)
name|s
operator|->
name|inUse16
index|[
name|i
index|]
operator|=
name|True
expr_stmt|;
else|else
name|s
operator|->
name|inUse16
index|[
name|i
index|]
operator|=
name|False
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|s
operator|->
name|inUse
index|[
name|i
index|]
operator|=
name|False
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|s
operator|->
name|inUse16
index|[
name|i
index|]
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
block|{
name|GET_BIT
argument_list|(
name|BZ_X_MAPPING_2
argument_list|,
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|==
literal|1
condition|)
name|s
operator|->
name|inUse
index|[
name|i
operator|*
literal|16
operator|+
name|j
index|]
operator|=
name|True
expr_stmt|;
block|}
name|makeMaps_d
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|nInUse
operator|==
literal|0
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
name|alphaSize
operator|=
name|s
operator|->
name|nInUse
operator|+
literal|2
expr_stmt|;
comment|/*--- Now the selectors ---*/
name|GET_BITS
argument_list|(
name|BZ_X_SELECTOR_1
argument_list|,
name|nGroups
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|nGroups
operator|<
literal|2
operator|||
name|nGroups
operator|>
literal|6
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
name|GET_BITS
argument_list|(
name|BZ_X_SELECTOR_2
argument_list|,
name|nSelectors
argument_list|,
literal|15
argument_list|)
expr_stmt|;
if|if
condition|(
name|nSelectors
operator|<
literal|1
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nSelectors
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|True
condition|)
block|{
name|GET_BIT
argument_list|(
name|BZ_X_SELECTOR_3
argument_list|,
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|==
literal|0
condition|)
break|break;
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|nGroups
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|selectorMtf
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
block|}
comment|/*--- Undo the MTF values for the selectors. ---*/
block|{
name|UChar
name|pos
index|[
name|BZ_N_GROUPS
index|]
decl_stmt|,
name|tmp
decl_stmt|,
name|v
decl_stmt|;
for|for
control|(
name|v
operator|=
literal|0
init|;
name|v
operator|<
name|nGroups
condition|;
name|v
operator|++
control|)
name|pos
index|[
name|v
index|]
operator|=
name|v
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nSelectors
condition|;
name|i
operator|++
control|)
block|{
name|v
operator|=
name|s
operator|->
name|selectorMtf
index|[
name|i
index|]
expr_stmt|;
name|tmp
operator|=
name|pos
index|[
name|v
index|]
expr_stmt|;
while|while
condition|(
name|v
operator|>
literal|0
condition|)
block|{
name|pos
index|[
name|v
index|]
operator|=
name|pos
index|[
name|v
operator|-
literal|1
index|]
expr_stmt|;
name|v
operator|--
expr_stmt|;
block|}
name|pos
index|[
literal|0
index|]
operator|=
name|tmp
expr_stmt|;
name|s
operator|->
name|selector
index|[
name|i
index|]
operator|=
name|tmp
expr_stmt|;
block|}
block|}
comment|/*--- Now the coding tables ---*/
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|nGroups
condition|;
name|t
operator|++
control|)
block|{
name|GET_BITS
argument_list|(
name|BZ_X_CODING_1
argument_list|,
name|curr
argument_list|,
literal|5
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alphaSize
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
name|True
condition|)
block|{
if|if
condition|(
name|curr
operator|<
literal|1
operator|||
name|curr
operator|>
literal|20
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
name|GET_BIT
argument_list|(
name|BZ_X_CODING_2
argument_list|,
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|==
literal|0
condition|)
break|break;
name|GET_BIT
argument_list|(
name|BZ_X_CODING_3
argument_list|,
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|==
literal|0
condition|)
name|curr
operator|++
expr_stmt|;
else|else
name|curr
operator|--
expr_stmt|;
block|}
name|s
operator|->
name|len
index|[
name|t
index|]
index|[
name|i
index|]
operator|=
name|curr
expr_stmt|;
block|}
block|}
comment|/*--- Create the Huffman decoding tables ---*/
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|nGroups
condition|;
name|t
operator|++
control|)
block|{
name|minLen
operator|=
literal|32
expr_stmt|;
name|maxLen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alphaSize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|s
operator|->
name|len
index|[
name|t
index|]
index|[
name|i
index|]
operator|>
name|maxLen
condition|)
name|maxLen
operator|=
name|s
operator|->
name|len
index|[
name|t
index|]
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|len
index|[
name|t
index|]
index|[
name|i
index|]
operator|<
name|minLen
condition|)
name|minLen
operator|=
name|s
operator|->
name|len
index|[
name|t
index|]
index|[
name|i
index|]
expr_stmt|;
block|}
name|BZ2_hbCreateDecodeTables
argument_list|(
operator|&
operator|(
name|s
operator|->
name|limit
index|[
name|t
index|]
index|[
literal|0
index|]
operator|)
argument_list|,
operator|&
operator|(
name|s
operator|->
name|base
index|[
name|t
index|]
index|[
literal|0
index|]
operator|)
argument_list|,
operator|&
operator|(
name|s
operator|->
name|perm
index|[
name|t
index|]
index|[
literal|0
index|]
operator|)
argument_list|,
operator|&
operator|(
name|s
operator|->
name|len
index|[
name|t
index|]
index|[
literal|0
index|]
operator|)
argument_list|,
name|minLen
argument_list|,
name|maxLen
argument_list|,
name|alphaSize
argument_list|)
expr_stmt|;
name|s
operator|->
name|minLens
index|[
name|t
index|]
operator|=
name|minLen
expr_stmt|;
block|}
comment|/*--- Now the MTF values ---*/
name|EOB
operator|=
name|s
operator|->
name|nInUse
operator|+
literal|1
expr_stmt|;
name|nblockMAX
operator|=
literal|100000
operator|*
name|s
operator|->
name|blockSize100k
expr_stmt|;
name|groupNo
operator|=
operator|-
literal|1
expr_stmt|;
name|groupPos
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|255
condition|;
name|i
operator|++
control|)
name|s
operator|->
name|unzftab
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/*-- MTF init --*/
block|{
name|Int32
name|ii
decl_stmt|,
name|jj
decl_stmt|,
name|kk
decl_stmt|;
name|kk
operator|=
name|MTFA_SIZE
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|ii
operator|=
literal|256
operator|/
name|MTFL_SIZE
operator|-
literal|1
init|;
name|ii
operator|>=
literal|0
condition|;
name|ii
operator|--
control|)
block|{
for|for
control|(
name|jj
operator|=
name|MTFL_SIZE
operator|-
literal|1
init|;
name|jj
operator|>=
literal|0
condition|;
name|jj
operator|--
control|)
block|{
name|s
operator|->
name|mtfa
index|[
name|kk
index|]
operator|=
call|(
name|UChar
call|)
argument_list|(
name|ii
operator|*
name|MTFL_SIZE
operator|+
name|jj
argument_list|)
expr_stmt|;
name|kk
operator|--
expr_stmt|;
block|}
name|s
operator|->
name|mtfbase
index|[
name|ii
index|]
operator|=
name|kk
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|/*-- end MTF init --*/
name|nblock
operator|=
literal|0
expr_stmt|;
name|GET_MTF_VAL
argument_list|(
name|BZ_X_MTF_1
argument_list|,
name|BZ_X_MTF_2
argument_list|,
name|nextSym
argument_list|)
expr_stmt|;
while|while
condition|(
name|True
condition|)
block|{
if|if
condition|(
name|nextSym
operator|==
name|EOB
condition|)
break|break;
if|if
condition|(
name|nextSym
operator|==
name|BZ_RUNA
operator|||
name|nextSym
operator|==
name|BZ_RUNB
condition|)
block|{
name|es
operator|=
operator|-
literal|1
expr_stmt|;
name|N
operator|=
literal|1
expr_stmt|;
do|do
block|{
if|if
condition|(
name|nextSym
operator|==
name|BZ_RUNA
condition|)
name|es
operator|=
name|es
operator|+
operator|(
literal|0
operator|+
literal|1
operator|)
operator|*
name|N
expr_stmt|;
elseif|else
if|if
condition|(
name|nextSym
operator|==
name|BZ_RUNB
condition|)
name|es
operator|=
name|es
operator|+
operator|(
literal|1
operator|+
literal|1
operator|)
operator|*
name|N
expr_stmt|;
name|N
operator|=
name|N
operator|*
literal|2
expr_stmt|;
name|GET_MTF_VAL
argument_list|(
name|BZ_X_MTF_3
argument_list|,
name|BZ_X_MTF_4
argument_list|,
name|nextSym
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|nextSym
operator|==
name|BZ_RUNA
operator|||
name|nextSym
operator|==
name|BZ_RUNB
condition|)
do|;
name|es
operator|++
expr_stmt|;
name|uc
operator|=
name|s
operator|->
name|seqToUnseq
index|[
name|s
operator|->
name|mtfa
index|[
name|s
operator|->
name|mtfbase
index|[
literal|0
index|]
index|]
index|]
expr_stmt|;
name|s
operator|->
name|unzftab
index|[
name|uc
index|]
operator|+=
name|es
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|smallDecompress
condition|)
while|while
condition|(
name|es
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|nblock
operator|>=
name|nblockMAX
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
name|s
operator|->
name|ll16
index|[
name|nblock
index|]
operator|=
operator|(
name|UInt16
operator|)
name|uc
expr_stmt|;
name|nblock
operator|++
expr_stmt|;
name|es
operator|--
expr_stmt|;
block|}
else|else
while|while
condition|(
name|es
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|nblock
operator|>=
name|nblockMAX
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
name|s
operator|->
name|tt
index|[
name|nblock
index|]
operator|=
operator|(
name|UInt32
operator|)
name|uc
expr_stmt|;
name|nblock
operator|++
expr_stmt|;
name|es
operator|--
expr_stmt|;
block|}
empty_stmt|;
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|nblock
operator|>=
name|nblockMAX
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
comment|/*-- uc = MTF ( nextSym-1 ) --*/
block|{
name|Int32
name|ii
decl_stmt|,
name|jj
decl_stmt|,
name|kk
decl_stmt|,
name|pp
decl_stmt|,
name|lno
decl_stmt|,
name|off
decl_stmt|;
name|UInt32
name|nn
decl_stmt|;
name|nn
operator|=
call|(
name|UInt32
call|)
argument_list|(
name|nextSym
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nn
operator|<
name|MTFL_SIZE
condition|)
block|{
comment|/* avoid general-case expense */
name|pp
operator|=
name|s
operator|->
name|mtfbase
index|[
literal|0
index|]
expr_stmt|;
name|uc
operator|=
name|s
operator|->
name|mtfa
index|[
name|pp
operator|+
name|nn
index|]
expr_stmt|;
while|while
condition|(
name|nn
operator|>
literal|3
condition|)
block|{
name|Int32
name|z
init|=
name|pp
operator|+
name|nn
decl_stmt|;
name|s
operator|->
name|mtfa
index|[
operator|(
name|z
operator|)
index|]
operator|=
name|s
operator|->
name|mtfa
index|[
operator|(
name|z
operator|)
operator|-
literal|1
index|]
expr_stmt|;
name|s
operator|->
name|mtfa
index|[
operator|(
name|z
operator|)
operator|-
literal|1
index|]
operator|=
name|s
operator|->
name|mtfa
index|[
operator|(
name|z
operator|)
operator|-
literal|2
index|]
expr_stmt|;
name|s
operator|->
name|mtfa
index|[
operator|(
name|z
operator|)
operator|-
literal|2
index|]
operator|=
name|s
operator|->
name|mtfa
index|[
operator|(
name|z
operator|)
operator|-
literal|3
index|]
expr_stmt|;
name|s
operator|->
name|mtfa
index|[
operator|(
name|z
operator|)
operator|-
literal|3
index|]
operator|=
name|s
operator|->
name|mtfa
index|[
operator|(
name|z
operator|)
operator|-
literal|4
index|]
expr_stmt|;
name|nn
operator|-=
literal|4
expr_stmt|;
block|}
while|while
condition|(
name|nn
operator|>
literal|0
condition|)
block|{
name|s
operator|->
name|mtfa
index|[
operator|(
name|pp
operator|+
name|nn
operator|)
index|]
operator|=
name|s
operator|->
name|mtfa
index|[
operator|(
name|pp
operator|+
name|nn
operator|)
operator|-
literal|1
index|]
expr_stmt|;
name|nn
operator|--
expr_stmt|;
block|}
empty_stmt|;
name|s
operator|->
name|mtfa
index|[
name|pp
index|]
operator|=
name|uc
expr_stmt|;
block|}
else|else
block|{
comment|/* general case */
name|lno
operator|=
name|nn
operator|/
name|MTFL_SIZE
expr_stmt|;
name|off
operator|=
name|nn
operator|%
name|MTFL_SIZE
expr_stmt|;
name|pp
operator|=
name|s
operator|->
name|mtfbase
index|[
name|lno
index|]
operator|+
name|off
expr_stmt|;
name|uc
operator|=
name|s
operator|->
name|mtfa
index|[
name|pp
index|]
expr_stmt|;
while|while
condition|(
name|pp
operator|>
name|s
operator|->
name|mtfbase
index|[
name|lno
index|]
condition|)
block|{
name|s
operator|->
name|mtfa
index|[
name|pp
index|]
operator|=
name|s
operator|->
name|mtfa
index|[
name|pp
operator|-
literal|1
index|]
expr_stmt|;
name|pp
operator|--
expr_stmt|;
block|}
empty_stmt|;
name|s
operator|->
name|mtfbase
index|[
name|lno
index|]
operator|++
expr_stmt|;
while|while
condition|(
name|lno
operator|>
literal|0
condition|)
block|{
name|s
operator|->
name|mtfbase
index|[
name|lno
index|]
operator|--
expr_stmt|;
name|s
operator|->
name|mtfa
index|[
name|s
operator|->
name|mtfbase
index|[
name|lno
index|]
index|]
operator|=
name|s
operator|->
name|mtfa
index|[
name|s
operator|->
name|mtfbase
index|[
name|lno
operator|-
literal|1
index|]
operator|+
name|MTFL_SIZE
operator|-
literal|1
index|]
expr_stmt|;
name|lno
operator|--
expr_stmt|;
block|}
name|s
operator|->
name|mtfbase
index|[
literal|0
index|]
operator|--
expr_stmt|;
name|s
operator|->
name|mtfa
index|[
name|s
operator|->
name|mtfbase
index|[
literal|0
index|]
index|]
operator|=
name|uc
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|mtfbase
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|kk
operator|=
name|MTFA_SIZE
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|ii
operator|=
literal|256
operator|/
name|MTFL_SIZE
operator|-
literal|1
init|;
name|ii
operator|>=
literal|0
condition|;
name|ii
operator|--
control|)
block|{
for|for
control|(
name|jj
operator|=
name|MTFL_SIZE
operator|-
literal|1
init|;
name|jj
operator|>=
literal|0
condition|;
name|jj
operator|--
control|)
block|{
name|s
operator|->
name|mtfa
index|[
name|kk
index|]
operator|=
name|s
operator|->
name|mtfa
index|[
name|s
operator|->
name|mtfbase
index|[
name|ii
index|]
operator|+
name|jj
index|]
expr_stmt|;
name|kk
operator|--
expr_stmt|;
block|}
name|s
operator|->
name|mtfbase
index|[
name|ii
index|]
operator|=
name|kk
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/*-- end uc = MTF ( nextSym-1 ) --*/
name|s
operator|->
name|unzftab
index|[
name|s
operator|->
name|seqToUnseq
index|[
name|uc
index|]
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|smallDecompress
condition|)
name|s
operator|->
name|ll16
index|[
name|nblock
index|]
operator|=
call|(
name|UInt16
call|)
argument_list|(
name|s
operator|->
name|seqToUnseq
index|[
name|uc
index|]
argument_list|)
expr_stmt|;
else|else
name|s
operator|->
name|tt
index|[
name|nblock
index|]
operator|=
call|(
name|UInt32
call|)
argument_list|(
name|s
operator|->
name|seqToUnseq
index|[
name|uc
index|]
argument_list|)
expr_stmt|;
name|nblock
operator|++
expr_stmt|;
name|GET_MTF_VAL
argument_list|(
name|BZ_X_MTF_5
argument_list|,
name|BZ_X_MTF_6
argument_list|,
name|nextSym
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* Now we know what nblock is, we can do a better sanity          check on s->origPtr.       */
if|if
condition|(
name|s
operator|->
name|origPtr
operator|<
literal|0
operator|||
name|s
operator|->
name|origPtr
operator|>=
name|nblock
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
comment|/*-- Set up cftab to facilitate generation of T^(-1) --*/
name|s
operator|->
name|cftab
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|256
condition|;
name|i
operator|++
control|)
name|s
operator|->
name|cftab
index|[
name|i
index|]
operator|=
name|s
operator|->
name|unzftab
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|256
condition|;
name|i
operator|++
control|)
name|s
operator|->
name|cftab
index|[
name|i
index|]
operator|+=
name|s
operator|->
name|cftab
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|s
operator|->
name|cftab
index|[
name|i
index|]
operator|<
literal|0
operator|||
name|s
operator|->
name|cftab
index|[
name|i
index|]
operator|>
name|nblock
condition|)
block|{
comment|/* s->cftab[i] can legitimately be == nblock */
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
block|}
block|}
name|s
operator|->
name|state_out_len
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|state_out_ch
operator|=
literal|0
expr_stmt|;
name|BZ_INITIALISE_CRC
argument_list|(
name|s
operator|->
name|calculatedBlockCRC
argument_list|)
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|BZ_X_OUTPUT
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|verbosity
operator|>=
literal|2
condition|)
name|VPrintf0
argument_list|(
literal|"rt+rld"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|smallDecompress
condition|)
block|{
comment|/*-- Make a copy of cftab, used in generation of T --*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|256
condition|;
name|i
operator|++
control|)
name|s
operator|->
name|cftabCopy
index|[
name|i
index|]
operator|=
name|s
operator|->
name|cftab
index|[
name|i
index|]
expr_stmt|;
comment|/*-- compute the T vector --*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nblock
condition|;
name|i
operator|++
control|)
block|{
name|uc
operator|=
call|(
name|UChar
call|)
argument_list|(
name|s
operator|->
name|ll16
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|SET_LL
argument_list|(
name|i
argument_list|,
name|s
operator|->
name|cftabCopy
index|[
name|uc
index|]
argument_list|)
expr_stmt|;
name|s
operator|->
name|cftabCopy
index|[
name|uc
index|]
operator|++
expr_stmt|;
block|}
comment|/*-- Compute T^(-1) by pointer reversal on T --*/
name|i
operator|=
name|s
operator|->
name|origPtr
expr_stmt|;
name|j
operator|=
name|GET_LL
argument_list|(
name|i
argument_list|)
expr_stmt|;
do|do
block|{
name|Int32
name|tmp
init|=
name|GET_LL
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|SET_LL
argument_list|(
name|j
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|i
operator|=
name|j
expr_stmt|;
name|j
operator|=
name|tmp
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|!=
name|s
operator|->
name|origPtr
condition|)
do|;
name|s
operator|->
name|tPos
operator|=
name|s
operator|->
name|origPtr
expr_stmt|;
name|s
operator|->
name|nblock_used
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|blockRandomised
condition|)
block|{
name|BZ_RAND_INIT_MASK
expr_stmt|;
name|BZ_GET_SMALL
argument_list|(
name|s
operator|->
name|k0
argument_list|)
expr_stmt|;
name|s
operator|->
name|nblock_used
operator|++
expr_stmt|;
name|BZ_RAND_UPD_MASK
expr_stmt|;
name|s
operator|->
name|k0
operator|^=
name|BZ_RAND_MASK
expr_stmt|;
block|}
else|else
block|{
name|BZ_GET_SMALL
argument_list|(
name|s
operator|->
name|k0
argument_list|)
expr_stmt|;
name|s
operator|->
name|nblock_used
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*-- compute the T^(-1) vector --*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nblock
condition|;
name|i
operator|++
control|)
block|{
name|uc
operator|=
call|(
name|UChar
call|)
argument_list|(
name|s
operator|->
name|tt
index|[
name|i
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|s
operator|->
name|tt
index|[
name|s
operator|->
name|cftab
index|[
name|uc
index|]
index|]
operator||=
operator|(
name|i
operator|<<
literal|8
operator|)
expr_stmt|;
name|s
operator|->
name|cftab
index|[
name|uc
index|]
operator|++
expr_stmt|;
block|}
name|s
operator|->
name|tPos
operator|=
name|s
operator|->
name|tt
index|[
name|s
operator|->
name|origPtr
index|]
operator|>>
literal|8
expr_stmt|;
name|s
operator|->
name|nblock_used
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|blockRandomised
condition|)
block|{
name|BZ_RAND_INIT_MASK
expr_stmt|;
name|BZ_GET_FAST
argument_list|(
name|s
operator|->
name|k0
argument_list|)
expr_stmt|;
name|s
operator|->
name|nblock_used
operator|++
expr_stmt|;
name|BZ_RAND_UPD_MASK
expr_stmt|;
name|s
operator|->
name|k0
operator|^=
name|BZ_RAND_MASK
expr_stmt|;
block|}
else|else
block|{
name|BZ_GET_FAST
argument_list|(
name|s
operator|->
name|k0
argument_list|)
expr_stmt|;
name|s
operator|->
name|nblock_used
operator|++
expr_stmt|;
block|}
block|}
name|RETURN
argument_list|(
name|BZ_OK
argument_list|)
expr_stmt|;
name|endhdr_2
label|:
name|GET_UCHAR
argument_list|(
name|BZ_X_ENDHDR_2
argument_list|,
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|!=
literal|0x72
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
name|GET_UCHAR
argument_list|(
name|BZ_X_ENDHDR_3
argument_list|,
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|!=
literal|0x45
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
name|GET_UCHAR
argument_list|(
name|BZ_X_ENDHDR_4
argument_list|,
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|!=
literal|0x38
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
name|GET_UCHAR
argument_list|(
name|BZ_X_ENDHDR_5
argument_list|,
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|!=
literal|0x50
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
name|GET_UCHAR
argument_list|(
name|BZ_X_ENDHDR_6
argument_list|,
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|!=
literal|0x90
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
name|s
operator|->
name|storedCombinedCRC
operator|=
literal|0
expr_stmt|;
name|GET_UCHAR
argument_list|(
name|BZ_X_CCRC_1
argument_list|,
name|uc
argument_list|)
expr_stmt|;
name|s
operator|->
name|storedCombinedCRC
operator|=
operator|(
name|s
operator|->
name|storedCombinedCRC
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|UInt32
operator|)
name|uc
operator|)
expr_stmt|;
name|GET_UCHAR
argument_list|(
name|BZ_X_CCRC_2
argument_list|,
name|uc
argument_list|)
expr_stmt|;
name|s
operator|->
name|storedCombinedCRC
operator|=
operator|(
name|s
operator|->
name|storedCombinedCRC
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|UInt32
operator|)
name|uc
operator|)
expr_stmt|;
name|GET_UCHAR
argument_list|(
name|BZ_X_CCRC_3
argument_list|,
name|uc
argument_list|)
expr_stmt|;
name|s
operator|->
name|storedCombinedCRC
operator|=
operator|(
name|s
operator|->
name|storedCombinedCRC
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|UInt32
operator|)
name|uc
operator|)
expr_stmt|;
name|GET_UCHAR
argument_list|(
name|BZ_X_CCRC_4
argument_list|,
name|uc
argument_list|)
expr_stmt|;
name|s
operator|->
name|storedCombinedCRC
operator|=
operator|(
name|s
operator|->
name|storedCombinedCRC
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|UInt32
operator|)
name|uc
operator|)
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|BZ_X_IDLE
expr_stmt|;
name|RETURN
argument_list|(
name|BZ_STREAM_END
argument_list|)
expr_stmt|;
default|default:
name|AssertH
argument_list|(
name|False
argument_list|,
literal|4001
argument_list|)
expr_stmt|;
block|}
name|AssertH
argument_list|(
name|False
argument_list|,
literal|4002
argument_list|)
expr_stmt|;
name|save_state_and_return
label|:
name|s
operator|->
name|save_i
operator|=
name|i
expr_stmt|;
name|s
operator|->
name|save_j
operator|=
name|j
expr_stmt|;
name|s
operator|->
name|save_t
operator|=
name|t
expr_stmt|;
name|s
operator|->
name|save_alphaSize
operator|=
name|alphaSize
expr_stmt|;
name|s
operator|->
name|save_nGroups
operator|=
name|nGroups
expr_stmt|;
name|s
operator|->
name|save_nSelectors
operator|=
name|nSelectors
expr_stmt|;
name|s
operator|->
name|save_EOB
operator|=
name|EOB
expr_stmt|;
name|s
operator|->
name|save_groupNo
operator|=
name|groupNo
expr_stmt|;
name|s
operator|->
name|save_groupPos
operator|=
name|groupPos
expr_stmt|;
name|s
operator|->
name|save_nextSym
operator|=
name|nextSym
expr_stmt|;
name|s
operator|->
name|save_nblockMAX
operator|=
name|nblockMAX
expr_stmt|;
name|s
operator|->
name|save_nblock
operator|=
name|nblock
expr_stmt|;
name|s
operator|->
name|save_es
operator|=
name|es
expr_stmt|;
name|s
operator|->
name|save_N
operator|=
name|N
expr_stmt|;
name|s
operator|->
name|save_curr
operator|=
name|curr
expr_stmt|;
name|s
operator|->
name|save_zt
operator|=
name|zt
expr_stmt|;
name|s
operator|->
name|save_zn
operator|=
name|zn
expr_stmt|;
name|s
operator|->
name|save_zvec
operator|=
name|zvec
expr_stmt|;
name|s
operator|->
name|save_zj
operator|=
name|zj
expr_stmt|;
name|s
operator|->
name|save_gSel
operator|=
name|gSel
expr_stmt|;
name|s
operator|->
name|save_gMinlen
operator|=
name|gMinlen
expr_stmt|;
name|s
operator|->
name|save_gLimit
operator|=
name|gLimit
expr_stmt|;
name|s
operator|->
name|save_gBase
operator|=
name|gBase
expr_stmt|;
name|s
operator|->
name|save_gPerm
operator|=
name|gPerm
expr_stmt|;
return|return
name|retVal
return|;
block|}
end_function

begin_comment
comment|/*-------------------------------------------------------------*/
end_comment

begin_comment
comment|/*--- end                                      decompress.c ---*/
end_comment

begin_comment
comment|/*-------------------------------------------------------------*/
end_comment

end_unit

