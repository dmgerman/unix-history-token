begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-------------------------------------------------------------*/
end_comment

begin_comment
comment|/*--- Decompression machinery                               ---*/
end_comment

begin_comment
comment|/*---                                          decompress.c ---*/
end_comment

begin_comment
comment|/*-------------------------------------------------------------*/
end_comment

begin_comment
comment|/* ------------------------------------------------------------------    This file is part of bzip2/libbzip2, a program and library for    lossless, block-sorting data compression.     bzip2/libbzip2 version 1.0.4 of 20 December 2006    Copyright (C) 1996-2006 Julian Seward<jseward@bzip.org>     Please read the WARNING, DISCLAIMER and PATENTS sections in the     README file.     This program is released under the terms of the license contained    in the file LICENSE.    ------------------------------------------------------------------ */
end_comment

begin_include
include|#
directive|include
file|"bzlib_private.h"
end_include

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|makeMaps_d
parameter_list|(
name|DState
modifier|*
name|s
parameter_list|)
block|{
name|Int32
name|i
decl_stmt|;
name|s
operator|->
name|nInUse
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|s
operator|->
name|inUse
index|[
name|i
index|]
condition|)
block|{
name|s
operator|->
name|seqToUnseq
index|[
name|s
operator|->
name|nInUse
index|]
operator|=
name|i
expr_stmt|;
name|s
operator|->
name|nInUse
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_define
define|#
directive|define
name|RETURN
parameter_list|(
name|rrr
parameter_list|)
define|\
value|{ retVal = rrr; goto save_state_and_return; };
end_define

begin_define
define|#
directive|define
name|GET_BITS
parameter_list|(
name|lll
parameter_list|,
name|vvv
parameter_list|,
name|nnn
parameter_list|)
define|\
value|case lll: s->state = lll;                      \    while (True) {                                 \       if (s->bsLive>= nnn) {                     \          UInt32 v;                                \          v = (s->bsBuff>>                        \              (s->bsLive-nnn))& ((1<< nnn)-1);   \          s->bsLive -= nnn;                        \          vvv = v;                                 \          break;                                   \       }                                           \       if (s->strm->avail_in == 0) RETURN(BZ_OK);  \       s->bsBuff                                   \          = (s->bsBuff<< 8) |                     \            ((UInt32)                              \               (*((UChar*)(s->strm->next_in))));   \       s->bsLive += 8;                             \       s->strm->next_in++;                         \       s->strm->avail_in--;                        \       s->strm->total_in_lo32++;                   \       if (s->strm->total_in_lo32 == 0)            \          s->strm->total_in_hi32++;                \    }
end_define

begin_define
define|#
directive|define
name|GET_UCHAR
parameter_list|(
name|lll
parameter_list|,
name|uuu
parameter_list|)
define|\
value|GET_BITS(lll,uuu,8)
end_define

begin_define
define|#
directive|define
name|GET_BIT
parameter_list|(
name|lll
parameter_list|,
name|uuu
parameter_list|)
define|\
value|GET_BITS(lll,uuu,1)
end_define

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_define
define|#
directive|define
name|GET_MTF_VAL
parameter_list|(
name|label1
parameter_list|,
name|label2
parameter_list|,
name|lval
parameter_list|)
define|\
value|{                                                 \    if (groupPos == 0) {                           \       groupNo++;                                  \       if (groupNo>= nSelectors)                  \          RETURN(BZ_DATA_ERROR);                   \       groupPos = BZ_G_SIZE;                       \       gSel = s->selector[groupNo];                \       gMinlen = s->minLens[gSel];                 \       gLimit =&(s->limit[gSel][0]);              \       gPerm =&(s->perm[gSel][0]);                \       gBase =&(s->base[gSel][0]);                \    }                                              \    groupPos--;                                    \    zn = gMinlen;                                  \    GET_BITS(label1, zvec, zn);                    \    while (1) {                                    \       if (zn> 20
comment|/* the longest code */
value|)         \          RETURN(BZ_DATA_ERROR);                   \       if (zvec<= gLimit[zn]) break;              \       zn++;                                       \       GET_BIT(label2, zj);                        \       zvec = (zvec<< 1) | zj;                    \    };                                             \    if (zvec - gBase[zn]< 0                       \        || zvec - gBase[zn]>= BZ_MAX_ALPHA_SIZE)  \       RETURN(BZ_DATA_ERROR);                      \    lval = gPerm[zvec - gBase[zn]];                \ }
end_define

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_function
name|Int32
name|BZ2_decompress
parameter_list|(
name|DState
modifier|*
name|s
parameter_list|)
block|{
name|UChar
name|uc
decl_stmt|;
name|Int32
name|retVal
decl_stmt|;
name|Int32
name|minLen
decl_stmt|,
name|maxLen
decl_stmt|;
name|bz_stream
modifier|*
name|strm
init|=
name|s
operator|->
name|strm
decl_stmt|;
comment|/* stuff that needs to be saved/restored */
name|Int32
name|i
decl_stmt|;
name|Int32
name|j
decl_stmt|;
name|Int32
name|t
decl_stmt|;
name|Int32
name|alphaSize
decl_stmt|;
name|Int32
name|nGroups
decl_stmt|;
name|Int32
name|nSelectors
decl_stmt|;
name|Int32
name|EOB
decl_stmt|;
name|Int32
name|groupNo
decl_stmt|;
name|Int32
name|groupPos
decl_stmt|;
name|Int32
name|nextSym
decl_stmt|;
name|Int32
name|nblockMAX
decl_stmt|;
name|Int32
name|nblock
decl_stmt|;
name|Int32
name|es
decl_stmt|;
name|Int32
name|N
decl_stmt|;
name|Int32
name|curr
decl_stmt|;
name|Int32
name|zt
decl_stmt|;
name|Int32
name|zn
decl_stmt|;
name|Int32
name|zvec
decl_stmt|;
name|Int32
name|zj
decl_stmt|;
name|Int32
name|gSel
decl_stmt|;
name|Int32
name|gMinlen
decl_stmt|;
name|Int32
modifier|*
name|gLimit
decl_stmt|;
name|Int32
modifier|*
name|gBase
decl_stmt|;
name|Int32
modifier|*
name|gPerm
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|BZ_X_MAGIC_1
condition|)
block|{
comment|/*initialise the save area*/
name|s
operator|->
name|save_i
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|save_j
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|save_t
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|save_alphaSize
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|save_nGroups
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|save_nSelectors
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|save_EOB
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|save_groupNo
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|save_groupPos
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|save_nextSym
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|save_nblockMAX
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|save_nblock
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|save_es
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|save_N
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|save_curr
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|save_zt
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|save_zn
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|save_zvec
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|save_zj
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|save_gSel
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|save_gMinlen
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|save_gLimit
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|save_gBase
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|save_gPerm
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*restore from the save area*/
name|i
operator|=
name|s
operator|->
name|save_i
expr_stmt|;
name|j
operator|=
name|s
operator|->
name|save_j
expr_stmt|;
name|t
operator|=
name|s
operator|->
name|save_t
expr_stmt|;
name|alphaSize
operator|=
name|s
operator|->
name|save_alphaSize
expr_stmt|;
name|nGroups
operator|=
name|s
operator|->
name|save_nGroups
expr_stmt|;
name|nSelectors
operator|=
name|s
operator|->
name|save_nSelectors
expr_stmt|;
name|EOB
operator|=
name|s
operator|->
name|save_EOB
expr_stmt|;
name|groupNo
operator|=
name|s
operator|->
name|save_groupNo
expr_stmt|;
name|groupPos
operator|=
name|s
operator|->
name|save_groupPos
expr_stmt|;
name|nextSym
operator|=
name|s
operator|->
name|save_nextSym
expr_stmt|;
name|nblockMAX
operator|=
name|s
operator|->
name|save_nblockMAX
expr_stmt|;
name|nblock
operator|=
name|s
operator|->
name|save_nblock
expr_stmt|;
name|es
operator|=
name|s
operator|->
name|save_es
expr_stmt|;
name|N
operator|=
name|s
operator|->
name|save_N
expr_stmt|;
name|curr
operator|=
name|s
operator|->
name|save_curr
expr_stmt|;
name|zt
operator|=
name|s
operator|->
name|save_zt
expr_stmt|;
name|zn
operator|=
name|s
operator|->
name|save_zn
expr_stmt|;
name|zvec
operator|=
name|s
operator|->
name|save_zvec
expr_stmt|;
name|zj
operator|=
name|s
operator|->
name|save_zj
expr_stmt|;
name|gSel
operator|=
name|s
operator|->
name|save_gSel
expr_stmt|;
name|gMinlen
operator|=
name|s
operator|->
name|save_gMinlen
expr_stmt|;
name|gLimit
operator|=
name|s
operator|->
name|save_gLimit
expr_stmt|;
name|gBase
operator|=
name|s
operator|->
name|save_gBase
expr_stmt|;
name|gPerm
operator|=
name|s
operator|->
name|save_gPerm
expr_stmt|;
name|retVal
operator|=
name|BZ_OK
expr_stmt|;
switch|switch
condition|(
name|s
operator|->
name|state
condition|)
block|{
name|GET_UCHAR
argument_list|(
name|BZ_X_MAGIC_1
argument_list|,
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|!=
name|BZ_HDR_B
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR_MAGIC
argument_list|)
expr_stmt|;
name|GET_UCHAR
argument_list|(
name|BZ_X_MAGIC_2
argument_list|,
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|!=
name|BZ_HDR_Z
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR_MAGIC
argument_list|)
expr_stmt|;
name|GET_UCHAR
argument_list|(
argument|BZ_X_MAGIC_3
argument_list|,
argument|uc
argument_list|)
if|if
condition|(
name|uc
operator|!=
name|BZ_HDR_h
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR_MAGIC
argument_list|)
expr_stmt|;
name|GET_BITS
argument_list|(
argument|BZ_X_MAGIC_4
argument_list|,
argument|s->blockSize100k
argument_list|,
literal|8
argument_list|)
if|if
condition|(
name|s
operator|->
name|blockSize100k
operator|<
operator|(
name|BZ_HDR_0
operator|+
literal|1
operator|)
operator|||
name|s
operator|->
name|blockSize100k
operator|>
operator|(
name|BZ_HDR_0
operator|+
literal|9
operator|)
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR_MAGIC
argument_list|)
expr_stmt|;
name|s
operator|->
name|blockSize100k
operator|-=
name|BZ_HDR_0
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|smallDecompress
condition|)
block|{
name|s
operator|->
name|ll16
operator|=
name|BZALLOC
argument_list|(
name|s
operator|->
name|blockSize100k
operator|*
literal|100000
operator|*
sizeof|sizeof
argument_list|(
name|UInt16
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|ll4
operator|=
name|BZALLOC
argument_list|(
operator|(
operator|(
literal|1
operator|+
name|s
operator|->
name|blockSize100k
operator|*
literal|100000
operator|)
operator|>>
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|UChar
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|ll16
operator|==
name|NULL
operator|||
name|s
operator|->
name|ll4
operator|==
name|NULL
condition|)
name|RETURN
argument_list|(
name|BZ_MEM_ERROR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|->
name|tt
operator|=
name|BZALLOC
argument_list|(
name|s
operator|->
name|blockSize100k
operator|*
literal|100000
operator|*
sizeof|sizeof
argument_list|(
name|Int32
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|tt
operator|==
name|NULL
condition|)
name|RETURN
argument_list|(
name|BZ_MEM_ERROR
argument_list|)
expr_stmt|;
block|}
name|GET_UCHAR
argument_list|(
name|BZ_X_BLKHDR_1
argument_list|,
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|==
literal|0x17
condition|)
goto|goto
name|endhdr_2
goto|;
if|if
condition|(
name|uc
operator|!=
literal|0x31
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
name|GET_UCHAR
argument_list|(
name|BZ_X_BLKHDR_2
argument_list|,
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|!=
literal|0x41
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
name|GET_UCHAR
argument_list|(
name|BZ_X_BLKHDR_3
argument_list|,
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|!=
literal|0x59
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
name|GET_UCHAR
argument_list|(
name|BZ_X_BLKHDR_4
argument_list|,
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|!=
literal|0x26
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
name|GET_UCHAR
argument_list|(
name|BZ_X_BLKHDR_5
argument_list|,
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|!=
literal|0x53
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
name|GET_UCHAR
argument_list|(
name|BZ_X_BLKHDR_6
argument_list|,
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|!=
literal|0x59
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
name|s
operator|->
name|currBlockNo
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|verbosity
operator|>=
literal|2
condition|)
name|VPrintf1
argument_list|(
literal|"\n    [%d: huff+mtf "
argument_list|,
name|s
operator|->
name|currBlockNo
argument_list|)
expr_stmt|;
name|s
operator|->
name|storedBlockCRC
operator|=
literal|0
expr_stmt|;
name|GET_UCHAR
argument_list|(
name|BZ_X_BCRC_1
argument_list|,
name|uc
argument_list|)
expr_stmt|;
name|s
operator|->
name|storedBlockCRC
operator|=
operator|(
name|s
operator|->
name|storedBlockCRC
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|UInt32
operator|)
name|uc
operator|)
expr_stmt|;
name|GET_UCHAR
argument_list|(
name|BZ_X_BCRC_2
argument_list|,
name|uc
argument_list|)
expr_stmt|;
name|s
operator|->
name|storedBlockCRC
operator|=
operator|(
name|s
operator|->
name|storedBlockCRC
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|UInt32
operator|)
name|uc
operator|)
expr_stmt|;
name|GET_UCHAR
argument_list|(
name|BZ_X_BCRC_3
argument_list|,
name|uc
argument_list|)
expr_stmt|;
name|s
operator|->
name|storedBlockCRC
operator|=
operator|(
name|s
operator|->
name|storedBlockCRC
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|UInt32
operator|)
name|uc
operator|)
expr_stmt|;
name|GET_UCHAR
argument_list|(
name|BZ_X_BCRC_4
argument_list|,
name|uc
argument_list|)
expr_stmt|;
name|s
operator|->
name|storedBlockCRC
operator|=
operator|(
name|s
operator|->
name|storedBlockCRC
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|UInt32
operator|)
name|uc
operator|)
expr_stmt|;
name|GET_BITS
argument_list|(
name|BZ_X_RANDBIT
argument_list|,
name|s
operator|->
name|blockRandomised
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|s
operator|->
name|origPtr
operator|=
literal|0
expr_stmt|;
name|GET_UCHAR
argument_list|(
name|BZ_X_ORIGPTR_1
argument_list|,
name|uc
argument_list|)
expr_stmt|;
name|s
operator|->
name|origPtr
operator|=
operator|(
name|s
operator|->
name|origPtr
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|Int32
operator|)
name|uc
operator|)
expr_stmt|;
name|GET_UCHAR
argument_list|(
name|BZ_X_ORIGPTR_2
argument_list|,
name|uc
argument_list|)
expr_stmt|;
name|s
operator|->
name|origPtr
operator|=
operator|(
name|s
operator|->
name|origPtr
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|Int32
operator|)
name|uc
operator|)
expr_stmt|;
name|GET_UCHAR
argument_list|(
name|BZ_X_ORIGPTR_3
argument_list|,
name|uc
argument_list|)
expr_stmt|;
name|s
operator|->
name|origPtr
operator|=
operator|(
name|s
operator|->
name|origPtr
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|Int32
operator|)
name|uc
operator|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|origPtr
operator|<
literal|0
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|origPtr
operator|>
literal|10
operator|+
literal|100000
operator|*
name|s
operator|->
name|blockSize100k
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
comment|/*--- Receive the mapping table ---*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|GET_BIT
argument_list|(
name|BZ_X_MAPPING_1
argument_list|,
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|==
literal|1
condition|)
name|s
operator|->
name|inUse16
index|[
name|i
index|]
operator|=
name|True
expr_stmt|;
else|else
name|s
operator|->
name|inUse16
index|[
name|i
index|]
operator|=
name|False
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|s
operator|->
name|inUse
index|[
name|i
index|]
operator|=
name|False
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|s
operator|->
name|inUse16
index|[
name|i
index|]
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
block|{
name|GET_BIT
argument_list|(
name|BZ_X_MAPPING_2
argument_list|,
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|==
literal|1
condition|)
name|s
operator|->
name|inUse
index|[
name|i
operator|*
literal|16
operator|+
name|j
index|]
operator|=
name|True
expr_stmt|;
block|}
name|makeMaps_d
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|nInUse
operator|==
literal|0
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
name|alphaSize
operator|=
name|s
operator|->
name|nInUse
operator|+
literal|2
expr_stmt|;
comment|/*--- Now the selectors ---*/
name|GET_BITS
argument_list|(
name|BZ_X_SELECTOR_1
argument_list|,
name|nGroups
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|nGroups
operator|<
literal|2
operator|||
name|nGroups
operator|>
literal|6
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
name|GET_BITS
argument_list|(
name|BZ_X_SELECTOR_2
argument_list|,
name|nSelectors
argument_list|,
literal|15
argument_list|)
expr_stmt|;
if|if
condition|(
name|nSelectors
operator|<
literal|1
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nSelectors
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|True
condition|)
block|{
name|GET_BIT
argument_list|(
name|BZ_X_SELECTOR_3
argument_list|,
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|==
literal|0
condition|)
break|break;
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|nGroups
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|selectorMtf
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
block|}
comment|/*--- Undo the MTF values for the selectors. ---*/
block|{
name|UChar
name|pos
index|[
name|BZ_N_GROUPS
index|]
decl_stmt|,
name|tmp
decl_stmt|,
name|v
decl_stmt|;
for|for
control|(
name|v
operator|=
literal|0
init|;
name|v
operator|<
name|nGroups
condition|;
name|v
operator|++
control|)
name|pos
index|[
name|v
index|]
operator|=
name|v
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nSelectors
condition|;
name|i
operator|++
control|)
block|{
name|v
operator|=
name|s
operator|->
name|selectorMtf
index|[
name|i
index|]
expr_stmt|;
name|tmp
operator|=
name|pos
index|[
name|v
index|]
expr_stmt|;
while|while
condition|(
name|v
operator|>
literal|0
condition|)
block|{
name|pos
index|[
name|v
index|]
operator|=
name|pos
index|[
name|v
operator|-
literal|1
index|]
expr_stmt|;
name|v
operator|--
expr_stmt|;
block|}
name|pos
index|[
literal|0
index|]
operator|=
name|tmp
expr_stmt|;
name|s
operator|->
name|selector
index|[
name|i
index|]
operator|=
name|tmp
expr_stmt|;
block|}
block|}
comment|/*--- Now the coding tables ---*/
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|nGroups
condition|;
name|t
operator|++
control|)
block|{
name|GET_BITS
argument_list|(
name|BZ_X_CODING_1
argument_list|,
name|curr
argument_list|,
literal|5
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alphaSize
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
name|True
condition|)
block|{
if|if
condition|(
name|curr
operator|<
literal|1
operator|||
name|curr
operator|>
literal|20
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
name|GET_BIT
argument_list|(
name|BZ_X_CODING_2
argument_list|,
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|==
literal|0
condition|)
break|break;
name|GET_BIT
argument_list|(
name|BZ_X_CODING_3
argument_list|,
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|==
literal|0
condition|)
name|curr
operator|++
expr_stmt|;
else|else
name|curr
operator|--
expr_stmt|;
block|}
name|s
operator|->
name|len
index|[
name|t
index|]
index|[
name|i
index|]
operator|=
name|curr
expr_stmt|;
block|}
block|}
comment|/*--- Create the Huffman decoding tables ---*/
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|nGroups
condition|;
name|t
operator|++
control|)
block|{
name|minLen
operator|=
literal|32
expr_stmt|;
name|maxLen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alphaSize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|s
operator|->
name|len
index|[
name|t
index|]
index|[
name|i
index|]
operator|>
name|maxLen
condition|)
name|maxLen
operator|=
name|s
operator|->
name|len
index|[
name|t
index|]
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|len
index|[
name|t
index|]
index|[
name|i
index|]
operator|<
name|minLen
condition|)
name|minLen
operator|=
name|s
operator|->
name|len
index|[
name|t
index|]
index|[
name|i
index|]
expr_stmt|;
block|}
name|BZ2_hbCreateDecodeTables
argument_list|(
operator|&
operator|(
name|s
operator|->
name|limit
index|[
name|t
index|]
index|[
literal|0
index|]
operator|)
argument_list|,
operator|&
operator|(
name|s
operator|->
name|base
index|[
name|t
index|]
index|[
literal|0
index|]
operator|)
argument_list|,
operator|&
operator|(
name|s
operator|->
name|perm
index|[
name|t
index|]
index|[
literal|0
index|]
operator|)
argument_list|,
operator|&
operator|(
name|s
operator|->
name|len
index|[
name|t
index|]
index|[
literal|0
index|]
operator|)
argument_list|,
name|minLen
argument_list|,
name|maxLen
argument_list|,
name|alphaSize
argument_list|)
expr_stmt|;
name|s
operator|->
name|minLens
index|[
name|t
index|]
operator|=
name|minLen
expr_stmt|;
block|}
comment|/*--- Now the MTF values ---*/
name|EOB
operator|=
name|s
operator|->
name|nInUse
operator|+
literal|1
expr_stmt|;
name|nblockMAX
operator|=
literal|100000
operator|*
name|s
operator|->
name|blockSize100k
expr_stmt|;
name|groupNo
operator|=
operator|-
literal|1
expr_stmt|;
name|groupPos
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|255
condition|;
name|i
operator|++
control|)
name|s
operator|->
name|unzftab
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/*-- MTF init --*/
block|{
name|Int32
name|ii
decl_stmt|,
name|jj
decl_stmt|,
name|kk
decl_stmt|;
name|kk
operator|=
name|MTFA_SIZE
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|ii
operator|=
literal|256
operator|/
name|MTFL_SIZE
operator|-
literal|1
init|;
name|ii
operator|>=
literal|0
condition|;
name|ii
operator|--
control|)
block|{
for|for
control|(
name|jj
operator|=
name|MTFL_SIZE
operator|-
literal|1
init|;
name|jj
operator|>=
literal|0
condition|;
name|jj
operator|--
control|)
block|{
name|s
operator|->
name|mtfa
index|[
name|kk
index|]
operator|=
call|(
name|UChar
call|)
argument_list|(
name|ii
operator|*
name|MTFL_SIZE
operator|+
name|jj
argument_list|)
expr_stmt|;
name|kk
operator|--
expr_stmt|;
block|}
name|s
operator|->
name|mtfbase
index|[
name|ii
index|]
operator|=
name|kk
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|/*-- end MTF init --*/
name|nblock
operator|=
literal|0
expr_stmt|;
name|GET_MTF_VAL
argument_list|(
name|BZ_X_MTF_1
argument_list|,
name|BZ_X_MTF_2
argument_list|,
name|nextSym
argument_list|)
expr_stmt|;
while|while
condition|(
name|True
condition|)
block|{
if|if
condition|(
name|nextSym
operator|==
name|EOB
condition|)
break|break;
if|if
condition|(
name|nextSym
operator|==
name|BZ_RUNA
operator|||
name|nextSym
operator|==
name|BZ_RUNB
condition|)
block|{
name|es
operator|=
operator|-
literal|1
expr_stmt|;
name|N
operator|=
literal|1
expr_stmt|;
do|do
block|{
if|if
condition|(
name|nextSym
operator|==
name|BZ_RUNA
condition|)
name|es
operator|=
name|es
operator|+
operator|(
literal|0
operator|+
literal|1
operator|)
operator|*
name|N
expr_stmt|;
elseif|else
if|if
condition|(
name|nextSym
operator|==
name|BZ_RUNB
condition|)
name|es
operator|=
name|es
operator|+
operator|(
literal|1
operator|+
literal|1
operator|)
operator|*
name|N
expr_stmt|;
name|N
operator|=
name|N
operator|*
literal|2
expr_stmt|;
name|GET_MTF_VAL
argument_list|(
name|BZ_X_MTF_3
argument_list|,
name|BZ_X_MTF_4
argument_list|,
name|nextSym
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|nextSym
operator|==
name|BZ_RUNA
operator|||
name|nextSym
operator|==
name|BZ_RUNB
condition|)
do|;
name|es
operator|++
expr_stmt|;
name|uc
operator|=
name|s
operator|->
name|seqToUnseq
index|[
name|s
operator|->
name|mtfa
index|[
name|s
operator|->
name|mtfbase
index|[
literal|0
index|]
index|]
index|]
expr_stmt|;
name|s
operator|->
name|unzftab
index|[
name|uc
index|]
operator|+=
name|es
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|smallDecompress
condition|)
while|while
condition|(
name|es
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|nblock
operator|>=
name|nblockMAX
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
name|s
operator|->
name|ll16
index|[
name|nblock
index|]
operator|=
operator|(
name|UInt16
operator|)
name|uc
expr_stmt|;
name|nblock
operator|++
expr_stmt|;
name|es
operator|--
expr_stmt|;
block|}
else|else
while|while
condition|(
name|es
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|nblock
operator|>=
name|nblockMAX
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
name|s
operator|->
name|tt
index|[
name|nblock
index|]
operator|=
operator|(
name|UInt32
operator|)
name|uc
expr_stmt|;
name|nblock
operator|++
expr_stmt|;
name|es
operator|--
expr_stmt|;
block|}
empty_stmt|;
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|nblock
operator|>=
name|nblockMAX
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
comment|/*-- uc = MTF ( nextSym-1 ) --*/
block|{
name|Int32
name|ii
decl_stmt|,
name|jj
decl_stmt|,
name|kk
decl_stmt|,
name|pp
decl_stmt|,
name|lno
decl_stmt|,
name|off
decl_stmt|;
name|UInt32
name|nn
decl_stmt|;
name|nn
operator|=
call|(
name|UInt32
call|)
argument_list|(
name|nextSym
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nn
operator|<
name|MTFL_SIZE
condition|)
block|{
comment|/* avoid general-case expense */
name|pp
operator|=
name|s
operator|->
name|mtfbase
index|[
literal|0
index|]
expr_stmt|;
name|uc
operator|=
name|s
operator|->
name|mtfa
index|[
name|pp
operator|+
name|nn
index|]
expr_stmt|;
while|while
condition|(
name|nn
operator|>
literal|3
condition|)
block|{
name|Int32
name|z
init|=
name|pp
operator|+
name|nn
decl_stmt|;
name|s
operator|->
name|mtfa
index|[
operator|(
name|z
operator|)
index|]
operator|=
name|s
operator|->
name|mtfa
index|[
operator|(
name|z
operator|)
operator|-
literal|1
index|]
expr_stmt|;
name|s
operator|->
name|mtfa
index|[
operator|(
name|z
operator|)
operator|-
literal|1
index|]
operator|=
name|s
operator|->
name|mtfa
index|[
operator|(
name|z
operator|)
operator|-
literal|2
index|]
expr_stmt|;
name|s
operator|->
name|mtfa
index|[
operator|(
name|z
operator|)
operator|-
literal|2
index|]
operator|=
name|s
operator|->
name|mtfa
index|[
operator|(
name|z
operator|)
operator|-
literal|3
index|]
expr_stmt|;
name|s
operator|->
name|mtfa
index|[
operator|(
name|z
operator|)
operator|-
literal|3
index|]
operator|=
name|s
operator|->
name|mtfa
index|[
operator|(
name|z
operator|)
operator|-
literal|4
index|]
expr_stmt|;
name|nn
operator|-=
literal|4
expr_stmt|;
block|}
while|while
condition|(
name|nn
operator|>
literal|0
condition|)
block|{
name|s
operator|->
name|mtfa
index|[
operator|(
name|pp
operator|+
name|nn
operator|)
index|]
operator|=
name|s
operator|->
name|mtfa
index|[
operator|(
name|pp
operator|+
name|nn
operator|)
operator|-
literal|1
index|]
expr_stmt|;
name|nn
operator|--
expr_stmt|;
block|}
empty_stmt|;
name|s
operator|->
name|mtfa
index|[
name|pp
index|]
operator|=
name|uc
expr_stmt|;
block|}
else|else
block|{
comment|/* general case */
name|lno
operator|=
name|nn
operator|/
name|MTFL_SIZE
expr_stmt|;
name|off
operator|=
name|nn
operator|%
name|MTFL_SIZE
expr_stmt|;
name|pp
operator|=
name|s
operator|->
name|mtfbase
index|[
name|lno
index|]
operator|+
name|off
expr_stmt|;
name|uc
operator|=
name|s
operator|->
name|mtfa
index|[
name|pp
index|]
expr_stmt|;
while|while
condition|(
name|pp
operator|>
name|s
operator|->
name|mtfbase
index|[
name|lno
index|]
condition|)
block|{
name|s
operator|->
name|mtfa
index|[
name|pp
index|]
operator|=
name|s
operator|->
name|mtfa
index|[
name|pp
operator|-
literal|1
index|]
expr_stmt|;
name|pp
operator|--
expr_stmt|;
block|}
empty_stmt|;
name|s
operator|->
name|mtfbase
index|[
name|lno
index|]
operator|++
expr_stmt|;
while|while
condition|(
name|lno
operator|>
literal|0
condition|)
block|{
name|s
operator|->
name|mtfbase
index|[
name|lno
index|]
operator|--
expr_stmt|;
name|s
operator|->
name|mtfa
index|[
name|s
operator|->
name|mtfbase
index|[
name|lno
index|]
index|]
operator|=
name|s
operator|->
name|mtfa
index|[
name|s
operator|->
name|mtfbase
index|[
name|lno
operator|-
literal|1
index|]
operator|+
name|MTFL_SIZE
operator|-
literal|1
index|]
expr_stmt|;
name|lno
operator|--
expr_stmt|;
block|}
name|s
operator|->
name|mtfbase
index|[
literal|0
index|]
operator|--
expr_stmt|;
name|s
operator|->
name|mtfa
index|[
name|s
operator|->
name|mtfbase
index|[
literal|0
index|]
index|]
operator|=
name|uc
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|mtfbase
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|kk
operator|=
name|MTFA_SIZE
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|ii
operator|=
literal|256
operator|/
name|MTFL_SIZE
operator|-
literal|1
init|;
name|ii
operator|>=
literal|0
condition|;
name|ii
operator|--
control|)
block|{
for|for
control|(
name|jj
operator|=
name|MTFL_SIZE
operator|-
literal|1
init|;
name|jj
operator|>=
literal|0
condition|;
name|jj
operator|--
control|)
block|{
name|s
operator|->
name|mtfa
index|[
name|kk
index|]
operator|=
name|s
operator|->
name|mtfa
index|[
name|s
operator|->
name|mtfbase
index|[
name|ii
index|]
operator|+
name|jj
index|]
expr_stmt|;
name|kk
operator|--
expr_stmt|;
block|}
name|s
operator|->
name|mtfbase
index|[
name|ii
index|]
operator|=
name|kk
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/*-- end uc = MTF ( nextSym-1 ) --*/
name|s
operator|->
name|unzftab
index|[
name|s
operator|->
name|seqToUnseq
index|[
name|uc
index|]
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|smallDecompress
condition|)
name|s
operator|->
name|ll16
index|[
name|nblock
index|]
operator|=
call|(
name|UInt16
call|)
argument_list|(
name|s
operator|->
name|seqToUnseq
index|[
name|uc
index|]
argument_list|)
expr_stmt|;
else|else
name|s
operator|->
name|tt
index|[
name|nblock
index|]
operator|=
call|(
name|UInt32
call|)
argument_list|(
name|s
operator|->
name|seqToUnseq
index|[
name|uc
index|]
argument_list|)
expr_stmt|;
name|nblock
operator|++
expr_stmt|;
name|GET_MTF_VAL
argument_list|(
name|BZ_X_MTF_5
argument_list|,
name|BZ_X_MTF_6
argument_list|,
name|nextSym
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* Now we know what nblock is, we can do a better sanity          check on s->origPtr.       */
if|if
condition|(
name|s
operator|->
name|origPtr
operator|<
literal|0
operator|||
name|s
operator|->
name|origPtr
operator|>=
name|nblock
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
comment|/*-- Set up cftab to facilitate generation of T^(-1) --*/
name|s
operator|->
name|cftab
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|256
condition|;
name|i
operator|++
control|)
name|s
operator|->
name|cftab
index|[
name|i
index|]
operator|=
name|s
operator|->
name|unzftab
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|256
condition|;
name|i
operator|++
control|)
name|s
operator|->
name|cftab
index|[
name|i
index|]
operator|+=
name|s
operator|->
name|cftab
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|s
operator|->
name|cftab
index|[
name|i
index|]
operator|<
literal|0
operator|||
name|s
operator|->
name|cftab
index|[
name|i
index|]
operator|>
name|nblock
condition|)
block|{
comment|/* s->cftab[i] can legitimately be == nblock */
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
block|}
block|}
name|s
operator|->
name|state_out_len
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|state_out_ch
operator|=
literal|0
expr_stmt|;
name|BZ_INITIALISE_CRC
argument_list|(
name|s
operator|->
name|calculatedBlockCRC
argument_list|)
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|BZ_X_OUTPUT
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|verbosity
operator|>=
literal|2
condition|)
name|VPrintf0
argument_list|(
literal|"rt+rld"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|smallDecompress
condition|)
block|{
comment|/*-- Make a copy of cftab, used in generation of T --*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|256
condition|;
name|i
operator|++
control|)
name|s
operator|->
name|cftabCopy
index|[
name|i
index|]
operator|=
name|s
operator|->
name|cftab
index|[
name|i
index|]
expr_stmt|;
comment|/*-- compute the T vector --*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nblock
condition|;
name|i
operator|++
control|)
block|{
name|uc
operator|=
call|(
name|UChar
call|)
argument_list|(
name|s
operator|->
name|ll16
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|SET_LL
argument_list|(
name|i
argument_list|,
name|s
operator|->
name|cftabCopy
index|[
name|uc
index|]
argument_list|)
expr_stmt|;
name|s
operator|->
name|cftabCopy
index|[
name|uc
index|]
operator|++
expr_stmt|;
block|}
comment|/*-- Compute T^(-1) by pointer reversal on T --*/
name|i
operator|=
name|s
operator|->
name|origPtr
expr_stmt|;
name|j
operator|=
name|GET_LL
argument_list|(
name|i
argument_list|)
expr_stmt|;
do|do
block|{
name|Int32
name|tmp
init|=
name|GET_LL
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|SET_LL
argument_list|(
name|j
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|i
operator|=
name|j
expr_stmt|;
name|j
operator|=
name|tmp
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|!=
name|s
operator|->
name|origPtr
condition|)
do|;
name|s
operator|->
name|tPos
operator|=
name|s
operator|->
name|origPtr
expr_stmt|;
name|s
operator|->
name|nblock_used
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|blockRandomised
condition|)
block|{
name|BZ_RAND_INIT_MASK
expr_stmt|;
name|BZ_GET_SMALL
argument_list|(
name|s
operator|->
name|k0
argument_list|)
expr_stmt|;
name|s
operator|->
name|nblock_used
operator|++
expr_stmt|;
name|BZ_RAND_UPD_MASK
expr_stmt|;
name|s
operator|->
name|k0
operator|^=
name|BZ_RAND_MASK
expr_stmt|;
block|}
else|else
block|{
name|BZ_GET_SMALL
argument_list|(
name|s
operator|->
name|k0
argument_list|)
expr_stmt|;
name|s
operator|->
name|nblock_used
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*-- compute the T^(-1) vector --*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nblock
condition|;
name|i
operator|++
control|)
block|{
name|uc
operator|=
call|(
name|UChar
call|)
argument_list|(
name|s
operator|->
name|tt
index|[
name|i
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|s
operator|->
name|tt
index|[
name|s
operator|->
name|cftab
index|[
name|uc
index|]
index|]
operator||=
operator|(
name|i
operator|<<
literal|8
operator|)
expr_stmt|;
name|s
operator|->
name|cftab
index|[
name|uc
index|]
operator|++
expr_stmt|;
block|}
name|s
operator|->
name|tPos
operator|=
name|s
operator|->
name|tt
index|[
name|s
operator|->
name|origPtr
index|]
operator|>>
literal|8
expr_stmt|;
name|s
operator|->
name|nblock_used
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|blockRandomised
condition|)
block|{
name|BZ_RAND_INIT_MASK
expr_stmt|;
name|BZ_GET_FAST
argument_list|(
name|s
operator|->
name|k0
argument_list|)
expr_stmt|;
name|s
operator|->
name|nblock_used
operator|++
expr_stmt|;
name|BZ_RAND_UPD_MASK
expr_stmt|;
name|s
operator|->
name|k0
operator|^=
name|BZ_RAND_MASK
expr_stmt|;
block|}
else|else
block|{
name|BZ_GET_FAST
argument_list|(
name|s
operator|->
name|k0
argument_list|)
expr_stmt|;
name|s
operator|->
name|nblock_used
operator|++
expr_stmt|;
block|}
block|}
name|RETURN
argument_list|(
name|BZ_OK
argument_list|)
expr_stmt|;
name|endhdr_2
label|:
name|GET_UCHAR
argument_list|(
name|BZ_X_ENDHDR_2
argument_list|,
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|!=
literal|0x72
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
name|GET_UCHAR
argument_list|(
name|BZ_X_ENDHDR_3
argument_list|,
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|!=
literal|0x45
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
name|GET_UCHAR
argument_list|(
name|BZ_X_ENDHDR_4
argument_list|,
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|!=
literal|0x38
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
name|GET_UCHAR
argument_list|(
name|BZ_X_ENDHDR_5
argument_list|,
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|!=
literal|0x50
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
name|GET_UCHAR
argument_list|(
name|BZ_X_ENDHDR_6
argument_list|,
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|!=
literal|0x90
condition|)
name|RETURN
argument_list|(
name|BZ_DATA_ERROR
argument_list|)
expr_stmt|;
name|s
operator|->
name|storedCombinedCRC
operator|=
literal|0
expr_stmt|;
name|GET_UCHAR
argument_list|(
name|BZ_X_CCRC_1
argument_list|,
name|uc
argument_list|)
expr_stmt|;
name|s
operator|->
name|storedCombinedCRC
operator|=
operator|(
name|s
operator|->
name|storedCombinedCRC
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|UInt32
operator|)
name|uc
operator|)
expr_stmt|;
name|GET_UCHAR
argument_list|(
name|BZ_X_CCRC_2
argument_list|,
name|uc
argument_list|)
expr_stmt|;
name|s
operator|->
name|storedCombinedCRC
operator|=
operator|(
name|s
operator|->
name|storedCombinedCRC
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|UInt32
operator|)
name|uc
operator|)
expr_stmt|;
name|GET_UCHAR
argument_list|(
name|BZ_X_CCRC_3
argument_list|,
name|uc
argument_list|)
expr_stmt|;
name|s
operator|->
name|storedCombinedCRC
operator|=
operator|(
name|s
operator|->
name|storedCombinedCRC
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|UInt32
operator|)
name|uc
operator|)
expr_stmt|;
name|GET_UCHAR
argument_list|(
name|BZ_X_CCRC_4
argument_list|,
name|uc
argument_list|)
expr_stmt|;
name|s
operator|->
name|storedCombinedCRC
operator|=
operator|(
name|s
operator|->
name|storedCombinedCRC
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|UInt32
operator|)
name|uc
operator|)
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|BZ_X_IDLE
expr_stmt|;
name|RETURN
argument_list|(
name|BZ_STREAM_END
argument_list|)
expr_stmt|;
default|default:
name|AssertH
argument_list|(
name|False
argument_list|,
literal|4001
argument_list|)
expr_stmt|;
block|}
name|AssertH
argument_list|(
name|False
argument_list|,
literal|4002
argument_list|)
expr_stmt|;
name|save_state_and_return
label|:
name|s
operator|->
name|save_i
operator|=
name|i
expr_stmt|;
name|s
operator|->
name|save_j
operator|=
name|j
expr_stmt|;
name|s
operator|->
name|save_t
operator|=
name|t
expr_stmt|;
name|s
operator|->
name|save_alphaSize
operator|=
name|alphaSize
expr_stmt|;
name|s
operator|->
name|save_nGroups
operator|=
name|nGroups
expr_stmt|;
name|s
operator|->
name|save_nSelectors
operator|=
name|nSelectors
expr_stmt|;
name|s
operator|->
name|save_EOB
operator|=
name|EOB
expr_stmt|;
name|s
operator|->
name|save_groupNo
operator|=
name|groupNo
expr_stmt|;
name|s
operator|->
name|save_groupPos
operator|=
name|groupPos
expr_stmt|;
name|s
operator|->
name|save_nextSym
operator|=
name|nextSym
expr_stmt|;
name|s
operator|->
name|save_nblockMAX
operator|=
name|nblockMAX
expr_stmt|;
name|s
operator|->
name|save_nblock
operator|=
name|nblock
expr_stmt|;
name|s
operator|->
name|save_es
operator|=
name|es
expr_stmt|;
name|s
operator|->
name|save_N
operator|=
name|N
expr_stmt|;
name|s
operator|->
name|save_curr
operator|=
name|curr
expr_stmt|;
name|s
operator|->
name|save_zt
operator|=
name|zt
expr_stmt|;
name|s
operator|->
name|save_zn
operator|=
name|zn
expr_stmt|;
name|s
operator|->
name|save_zvec
operator|=
name|zvec
expr_stmt|;
name|s
operator|->
name|save_zj
operator|=
name|zj
expr_stmt|;
name|s
operator|->
name|save_gSel
operator|=
name|gSel
expr_stmt|;
name|s
operator|->
name|save_gMinlen
operator|=
name|gMinlen
expr_stmt|;
name|s
operator|->
name|save_gLimit
operator|=
name|gLimit
expr_stmt|;
name|s
operator|->
name|save_gBase
operator|=
name|gBase
expr_stmt|;
name|s
operator|->
name|save_gPerm
operator|=
name|gPerm
expr_stmt|;
return|return
name|retVal
return|;
block|}
end_function

begin_comment
comment|/*-------------------------------------------------------------*/
end_comment

begin_comment
comment|/*--- end                                      decompress.c ---*/
end_comment

begin_comment
comment|/*-------------------------------------------------------------*/
end_comment

end_unit

