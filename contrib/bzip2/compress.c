begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-------------------------------------------------------------*/
end_comment

begin_comment
comment|/*--- Compression machinery (not incl block sorting)        ---*/
end_comment

begin_comment
comment|/*---                                            compress.c ---*/
end_comment

begin_comment
comment|/*-------------------------------------------------------------*/
end_comment

begin_comment
comment|/*--   This file is a part of bzip2 and/or libbzip2, a program and   library for lossless, block-sorting data compression.    Copyright (C) 1996-2000 Julian R Seward.  All rights reserved.    Redistribution and use in source and binary forms, with or without   modification, are permitted provided that the following conditions   are met:    1. Redistributions of source code must retain the above copyright      notice, this list of conditions and the following disclaimer.    2. The origin of this software must not be misrepresented; you must       not claim that you wrote the original software.  If you use this       software in a product, an acknowledgment in the product       documentation would be appreciated but is not required.    3. Altered source versions must be plainly marked as such, and must      not be misrepresented as being the original software.    4. The name of the author may not be used to endorse or promote       products derived from this software without specific prior written       permission.    THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS   OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY   DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.    Julian Seward, Cambridge, UK.   jseward@acm.org   bzip2/libbzip2 version 1.0 of 21 March 2000    This program is based on (at least) the work of:      Mike Burrows      David Wheeler      Peter Fenwick      Alistair Moffat      Radford Neal      Ian H. Witten      Robert Sedgewick      Jon L. Bentley    For more information on these sources, see the manual. --*/
end_comment

begin_comment
comment|/*--    CHANGES    ~~~~~~~    0.9.0 -- original version.     0.9.0a/b -- no changes in this file.     0.9.0c       * changed setting of nGroups in sendMTFValues() so as to          do a bit better on small files --*/
end_comment

begin_include
include|#
directive|include
file|"bzlib_private.h"
end_include

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_comment
comment|/*--- Bit stream I/O                              ---*/
end_comment

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_function
name|void
name|BZ2_bsInitWrite
parameter_list|(
name|EState
modifier|*
name|s
parameter_list|)
block|{
name|s
operator|->
name|bsLive
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|bsBuff
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|bsFinishWrite
parameter_list|(
name|EState
modifier|*
name|s
parameter_list|)
block|{
while|while
condition|(
name|s
operator|->
name|bsLive
operator|>
literal|0
condition|)
block|{
name|s
operator|->
name|zbits
index|[
name|s
operator|->
name|numZ
index|]
operator|=
call|(
name|UChar
call|)
argument_list|(
name|s
operator|->
name|bsBuff
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|s
operator|->
name|numZ
operator|++
expr_stmt|;
name|s
operator|->
name|bsBuff
operator|<<=
literal|8
expr_stmt|;
name|s
operator|->
name|bsLive
operator|-=
literal|8
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_define
define|#
directive|define
name|bsNEEDW
parameter_list|(
name|nz
parameter_list|)
define|\
value|{                                             \    while (s->bsLive>= 8) {                   \       s->zbits[s->numZ]                       \          = (UChar)(s->bsBuff>> 24);          \       s->numZ++;                              \       s->bsBuff<<= 8;                        \       s->bsLive -= 8;                         \    }                                          \ }
end_define

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_function
specifier|static
name|__inline__
name|void
name|bsW
parameter_list|(
name|EState
modifier|*
name|s
parameter_list|,
name|Int32
name|n
parameter_list|,
name|UInt32
name|v
parameter_list|)
block|{
name|bsNEEDW
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|s
operator|->
name|bsBuff
operator||=
operator|(
name|v
operator|<<
operator|(
literal|32
operator|-
name|s
operator|->
name|bsLive
operator|-
name|n
operator|)
operator|)
expr_stmt|;
name|s
operator|->
name|bsLive
operator|+=
name|n
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|bsPutUInt32
parameter_list|(
name|EState
modifier|*
name|s
parameter_list|,
name|UInt32
name|u
parameter_list|)
block|{
name|bsW
argument_list|(
name|s
argument_list|,
literal|8
argument_list|,
operator|(
name|u
operator|>>
literal|24
operator|)
operator|&
literal|0xffL
argument_list|)
expr_stmt|;
name|bsW
argument_list|(
name|s
argument_list|,
literal|8
argument_list|,
operator|(
name|u
operator|>>
literal|16
operator|)
operator|&
literal|0xffL
argument_list|)
expr_stmt|;
name|bsW
argument_list|(
name|s
argument_list|,
literal|8
argument_list|,
operator|(
name|u
operator|>>
literal|8
operator|)
operator|&
literal|0xffL
argument_list|)
expr_stmt|;
name|bsW
argument_list|(
name|s
argument_list|,
literal|8
argument_list|,
name|u
operator|&
literal|0xffL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|bsPutUChar
parameter_list|(
name|EState
modifier|*
name|s
parameter_list|,
name|UChar
name|c
parameter_list|)
block|{
name|bsW
argument_list|(
name|s
argument_list|,
literal|8
argument_list|,
operator|(
name|UInt32
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_comment
comment|/*--- The back end proper                         ---*/
end_comment

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|makeMaps_e
parameter_list|(
name|EState
modifier|*
name|s
parameter_list|)
block|{
name|Int32
name|i
decl_stmt|;
name|s
operator|->
name|nInUse
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|s
operator|->
name|inUse
index|[
name|i
index|]
condition|)
block|{
name|s
operator|->
name|unseqToSeq
index|[
name|i
index|]
operator|=
name|s
operator|->
name|nInUse
expr_stmt|;
name|s
operator|->
name|nInUse
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|generateMTFValues
parameter_list|(
name|EState
modifier|*
name|s
parameter_list|)
block|{
name|UChar
name|yy
index|[
literal|256
index|]
decl_stmt|;
name|Int32
name|i
decl_stmt|,
name|j
decl_stmt|;
name|Int32
name|zPend
decl_stmt|;
name|Int32
name|wr
decl_stmt|;
name|Int32
name|EOB
decl_stmt|;
comment|/*        After sorting (eg, here),          s->arr1 [ 0 .. s->nblock-1 ] holds sorted order,          and          ((UChar*)s->arr2) [ 0 .. s->nblock-1 ]           holds the original block data.        The first thing to do is generate the MTF values,       and put them in          ((UInt16*)s->arr1) [ 0 .. s->nblock-1 ].       Because there are strictly fewer or equal MTF values       than block values, ptr values in this area are overwritten       with MTF values only when they are no longer needed.        The final compressed bitstream is generated into the       area starting at          (UChar*) (&((UChar*)s->arr2)[s->nblock])        These storage aliases are set up in bzCompressInit(),       except for the last one, which is arranged in        compressBlock().    */
name|UInt32
modifier|*
name|ptr
init|=
name|s
operator|->
name|ptr
decl_stmt|;
name|UChar
modifier|*
name|block
init|=
name|s
operator|->
name|block
decl_stmt|;
name|UInt16
modifier|*
name|mtfv
init|=
name|s
operator|->
name|mtfv
decl_stmt|;
name|makeMaps_e
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|EOB
operator|=
name|s
operator|->
name|nInUse
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|EOB
condition|;
name|i
operator|++
control|)
name|s
operator|->
name|mtfFreq
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|wr
operator|=
literal|0
expr_stmt|;
name|zPend
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|nInUse
condition|;
name|i
operator|++
control|)
name|yy
index|[
name|i
index|]
operator|=
operator|(
name|UChar
operator|)
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|nblock
condition|;
name|i
operator|++
control|)
block|{
name|UChar
name|ll_i
decl_stmt|;
name|AssertD
argument_list|(
name|wr
operator|<=
name|i
argument_list|,
literal|"generateMTFValues(1)"
argument_list|)
expr_stmt|;
name|j
operator|=
name|ptr
index|[
name|i
index|]
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|j
operator|<
literal|0
condition|)
name|j
operator|+=
name|s
operator|->
name|nblock
expr_stmt|;
name|ll_i
operator|=
name|s
operator|->
name|unseqToSeq
index|[
name|block
index|[
name|j
index|]
index|]
expr_stmt|;
name|AssertD
argument_list|(
name|ll_i
operator|<
name|s
operator|->
name|nInUse
argument_list|,
literal|"generateMTFValues(2a)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yy
index|[
literal|0
index|]
operator|==
name|ll_i
condition|)
block|{
name|zPend
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|zPend
operator|>
literal|0
condition|)
block|{
name|zPend
operator|--
expr_stmt|;
while|while
condition|(
name|True
condition|)
block|{
if|if
condition|(
name|zPend
operator|&
literal|1
condition|)
block|{
name|mtfv
index|[
name|wr
index|]
operator|=
name|BZ_RUNB
expr_stmt|;
name|wr
operator|++
expr_stmt|;
name|s
operator|->
name|mtfFreq
index|[
name|BZ_RUNB
index|]
operator|++
expr_stmt|;
block|}
else|else
block|{
name|mtfv
index|[
name|wr
index|]
operator|=
name|BZ_RUNA
expr_stmt|;
name|wr
operator|++
expr_stmt|;
name|s
operator|->
name|mtfFreq
index|[
name|BZ_RUNA
index|]
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|zPend
operator|<
literal|2
condition|)
break|break;
name|zPend
operator|=
operator|(
name|zPend
operator|-
literal|2
operator|)
operator|/
literal|2
expr_stmt|;
block|}
empty_stmt|;
name|zPend
operator|=
literal|0
expr_stmt|;
block|}
block|{
specifier|register
name|UChar
name|rtmp
decl_stmt|;
specifier|register
name|UChar
modifier|*
name|ryy_j
decl_stmt|;
specifier|register
name|UChar
name|rll_i
decl_stmt|;
name|rtmp
operator|=
name|yy
index|[
literal|1
index|]
expr_stmt|;
name|yy
index|[
literal|1
index|]
operator|=
name|yy
index|[
literal|0
index|]
expr_stmt|;
name|ryy_j
operator|=
operator|&
operator|(
name|yy
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|rll_i
operator|=
name|ll_i
expr_stmt|;
while|while
condition|(
name|rll_i
operator|!=
name|rtmp
condition|)
block|{
specifier|register
name|UChar
name|rtmp2
decl_stmt|;
name|ryy_j
operator|++
expr_stmt|;
name|rtmp2
operator|=
name|rtmp
expr_stmt|;
name|rtmp
operator|=
operator|*
name|ryy_j
expr_stmt|;
operator|*
name|ryy_j
operator|=
name|rtmp2
expr_stmt|;
block|}
empty_stmt|;
name|yy
index|[
literal|0
index|]
operator|=
name|rtmp
expr_stmt|;
name|j
operator|=
name|ryy_j
operator|-
operator|&
operator|(
name|yy
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|mtfv
index|[
name|wr
index|]
operator|=
name|j
operator|+
literal|1
expr_stmt|;
name|wr
operator|++
expr_stmt|;
name|s
operator|->
name|mtfFreq
index|[
name|j
operator|+
literal|1
index|]
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|zPend
operator|>
literal|0
condition|)
block|{
name|zPend
operator|--
expr_stmt|;
while|while
condition|(
name|True
condition|)
block|{
if|if
condition|(
name|zPend
operator|&
literal|1
condition|)
block|{
name|mtfv
index|[
name|wr
index|]
operator|=
name|BZ_RUNB
expr_stmt|;
name|wr
operator|++
expr_stmt|;
name|s
operator|->
name|mtfFreq
index|[
name|BZ_RUNB
index|]
operator|++
expr_stmt|;
block|}
else|else
block|{
name|mtfv
index|[
name|wr
index|]
operator|=
name|BZ_RUNA
expr_stmt|;
name|wr
operator|++
expr_stmt|;
name|s
operator|->
name|mtfFreq
index|[
name|BZ_RUNA
index|]
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|zPend
operator|<
literal|2
condition|)
break|break;
name|zPend
operator|=
operator|(
name|zPend
operator|-
literal|2
operator|)
operator|/
literal|2
expr_stmt|;
block|}
empty_stmt|;
name|zPend
operator|=
literal|0
expr_stmt|;
block|}
name|mtfv
index|[
name|wr
index|]
operator|=
name|EOB
expr_stmt|;
name|wr
operator|++
expr_stmt|;
name|s
operator|->
name|mtfFreq
index|[
name|EOB
index|]
operator|++
expr_stmt|;
name|s
operator|->
name|nMTF
operator|=
name|wr
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_define
define|#
directive|define
name|BZ_LESSER_ICOST
value|0
end_define

begin_define
define|#
directive|define
name|BZ_GREATER_ICOST
value|15
end_define

begin_function
specifier|static
name|void
name|sendMTFValues
parameter_list|(
name|EState
modifier|*
name|s
parameter_list|)
block|{
name|Int32
name|v
decl_stmt|,
name|t
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|gs
decl_stmt|,
name|ge
decl_stmt|,
name|totc
decl_stmt|,
name|bt
decl_stmt|,
name|bc
decl_stmt|,
name|iter
decl_stmt|;
name|Int32
name|nSelectors
decl_stmt|,
name|alphaSize
decl_stmt|,
name|minLen
decl_stmt|,
name|maxLen
decl_stmt|,
name|selCtr
decl_stmt|;
name|Int32
name|nGroups
decl_stmt|,
name|nBytes
decl_stmt|;
comment|/*--    UChar  len [BZ_N_GROUPS][BZ_MAX_ALPHA_SIZE];    is a global since the decoder also needs it.     Int32  code[BZ_N_GROUPS][BZ_MAX_ALPHA_SIZE];    Int32  rfreq[BZ_N_GROUPS][BZ_MAX_ALPHA_SIZE];    are also globals only used in this proc.    Made global to keep stack frame size small.    --*/
name|UInt16
name|cost
index|[
name|BZ_N_GROUPS
index|]
decl_stmt|;
name|Int32
name|fave
index|[
name|BZ_N_GROUPS
index|]
decl_stmt|;
name|UInt16
modifier|*
name|mtfv
init|=
name|s
operator|->
name|mtfv
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|verbosity
operator|>=
literal|3
condition|)
name|VPrintf3
argument_list|(
literal|"      %d in block, %d after MTF& 1-2 coding, "
literal|"%d+2 syms in use\n"
argument_list|,
name|s
operator|->
name|nblock
argument_list|,
name|s
operator|->
name|nMTF
argument_list|,
name|s
operator|->
name|nInUse
argument_list|)
expr_stmt|;
name|alphaSize
operator|=
name|s
operator|->
name|nInUse
operator|+
literal|2
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|BZ_N_GROUPS
condition|;
name|t
operator|++
control|)
for|for
control|(
name|v
operator|=
literal|0
init|;
name|v
operator|<
name|alphaSize
condition|;
name|v
operator|++
control|)
name|s
operator|->
name|len
index|[
name|t
index|]
index|[
name|v
index|]
operator|=
name|BZ_GREATER_ICOST
expr_stmt|;
comment|/*--- Decide how many coding tables to use ---*/
name|AssertH
argument_list|(
name|s
operator|->
name|nMTF
operator|>
literal|0
argument_list|,
literal|3001
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|nMTF
operator|<
literal|200
condition|)
name|nGroups
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|->
name|nMTF
operator|<
literal|600
condition|)
name|nGroups
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|->
name|nMTF
operator|<
literal|1200
condition|)
name|nGroups
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|->
name|nMTF
operator|<
literal|2400
condition|)
name|nGroups
operator|=
literal|5
expr_stmt|;
else|else
name|nGroups
operator|=
literal|6
expr_stmt|;
comment|/*--- Generate an initial set of coding tables ---*/
block|{
name|Int32
name|nPart
decl_stmt|,
name|remF
decl_stmt|,
name|tFreq
decl_stmt|,
name|aFreq
decl_stmt|;
name|nPart
operator|=
name|nGroups
expr_stmt|;
name|remF
operator|=
name|s
operator|->
name|nMTF
expr_stmt|;
name|gs
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|nPart
operator|>
literal|0
condition|)
block|{
name|tFreq
operator|=
name|remF
operator|/
name|nPart
expr_stmt|;
name|ge
operator|=
name|gs
operator|-
literal|1
expr_stmt|;
name|aFreq
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|aFreq
operator|<
name|tFreq
operator|&&
name|ge
operator|<
name|alphaSize
operator|-
literal|1
condition|)
block|{
name|ge
operator|++
expr_stmt|;
name|aFreq
operator|+=
name|s
operator|->
name|mtfFreq
index|[
name|ge
index|]
expr_stmt|;
block|}
if|if
condition|(
name|ge
operator|>
name|gs
operator|&&
name|nPart
operator|!=
name|nGroups
operator|&&
name|nPart
operator|!=
literal|1
operator|&&
operator|(
operator|(
name|nGroups
operator|-
name|nPart
operator|)
operator|%
literal|2
operator|==
literal|1
operator|)
condition|)
block|{
name|aFreq
operator|-=
name|s
operator|->
name|mtfFreq
index|[
name|ge
index|]
expr_stmt|;
name|ge
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|verbosity
operator|>=
literal|3
condition|)
name|VPrintf5
argument_list|(
literal|"      initial group %d, [%d .. %d], "
literal|"has %d syms (%4.1f%%)\n"
argument_list|,
name|nPart
argument_list|,
name|gs
argument_list|,
name|ge
argument_list|,
name|aFreq
argument_list|,
operator|(
literal|100.0
operator|*
operator|(
name|float
operator|)
name|aFreq
operator|)
operator|/
call|(
name|float
call|)
argument_list|(
name|s
operator|->
name|nMTF
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|v
operator|=
literal|0
init|;
name|v
operator|<
name|alphaSize
condition|;
name|v
operator|++
control|)
if|if
condition|(
name|v
operator|>=
name|gs
operator|&&
name|v
operator|<=
name|ge
condition|)
name|s
operator|->
name|len
index|[
name|nPart
operator|-
literal|1
index|]
index|[
name|v
index|]
operator|=
name|BZ_LESSER_ICOST
expr_stmt|;
else|else
name|s
operator|->
name|len
index|[
name|nPart
operator|-
literal|1
index|]
index|[
name|v
index|]
operator|=
name|BZ_GREATER_ICOST
expr_stmt|;
name|nPart
operator|--
expr_stmt|;
name|gs
operator|=
name|ge
operator|+
literal|1
expr_stmt|;
name|remF
operator|-=
name|aFreq
expr_stmt|;
block|}
block|}
comment|/*---        Iterate up to BZ_N_ITERS times to improve the tables.    ---*/
for|for
control|(
name|iter
operator|=
literal|0
init|;
name|iter
operator|<
name|BZ_N_ITERS
condition|;
name|iter
operator|++
control|)
block|{
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|nGroups
condition|;
name|t
operator|++
control|)
name|fave
index|[
name|t
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|nGroups
condition|;
name|t
operator|++
control|)
for|for
control|(
name|v
operator|=
literal|0
init|;
name|v
operator|<
name|alphaSize
condition|;
name|v
operator|++
control|)
name|s
operator|->
name|rfreq
index|[
name|t
index|]
index|[
name|v
index|]
operator|=
literal|0
expr_stmt|;
comment|/*---         Set up an auxiliary length table which is used to fast-track 	the common case (nGroups == 6).        ---*/
if|if
condition|(
name|nGroups
operator|==
literal|6
condition|)
block|{
for|for
control|(
name|v
operator|=
literal|0
init|;
name|v
operator|<
name|alphaSize
condition|;
name|v
operator|++
control|)
block|{
name|s
operator|->
name|len_pack
index|[
name|v
index|]
index|[
literal|0
index|]
operator|=
operator|(
name|s
operator|->
name|len
index|[
literal|1
index|]
index|[
name|v
index|]
operator|<<
literal|16
operator|)
operator||
name|s
operator|->
name|len
index|[
literal|0
index|]
index|[
name|v
index|]
expr_stmt|;
name|s
operator|->
name|len_pack
index|[
name|v
index|]
index|[
literal|1
index|]
operator|=
operator|(
name|s
operator|->
name|len
index|[
literal|3
index|]
index|[
name|v
index|]
operator|<<
literal|16
operator|)
operator||
name|s
operator|->
name|len
index|[
literal|2
index|]
index|[
name|v
index|]
expr_stmt|;
name|s
operator|->
name|len_pack
index|[
name|v
index|]
index|[
literal|2
index|]
operator|=
operator|(
name|s
operator|->
name|len
index|[
literal|5
index|]
index|[
name|v
index|]
operator|<<
literal|16
operator|)
operator||
name|s
operator|->
name|len
index|[
literal|4
index|]
index|[
name|v
index|]
expr_stmt|;
block|}
block|}
name|nSelectors
operator|=
literal|0
expr_stmt|;
name|totc
operator|=
literal|0
expr_stmt|;
name|gs
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|True
condition|)
block|{
comment|/*--- Set group start& end marks. --*/
if|if
condition|(
name|gs
operator|>=
name|s
operator|->
name|nMTF
condition|)
break|break;
name|ge
operator|=
name|gs
operator|+
name|BZ_G_SIZE
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ge
operator|>=
name|s
operator|->
name|nMTF
condition|)
name|ge
operator|=
name|s
operator|->
name|nMTF
operator|-
literal|1
expr_stmt|;
comment|/*--              Calculate the cost of this group as coded             by each of the coding tables.          --*/
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|nGroups
condition|;
name|t
operator|++
control|)
name|cost
index|[
name|t
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nGroups
operator|==
literal|6
operator|&&
literal|50
operator|==
name|ge
operator|-
name|gs
operator|+
literal|1
condition|)
block|{
comment|/*--- fast track the common case ---*/
specifier|register
name|UInt32
name|cost01
decl_stmt|,
name|cost23
decl_stmt|,
name|cost45
decl_stmt|;
specifier|register
name|UInt16
name|icv
decl_stmt|;
name|cost01
operator|=
name|cost23
operator|=
name|cost45
operator|=
literal|0
expr_stmt|;
define|#
directive|define
name|BZ_ITER
parameter_list|(
name|nn
parameter_list|)
define|\
value|icv = mtfv[gs+(nn)];           \                cost01 += s->len_pack[icv][0]; \                cost23 += s->len_pack[icv][1]; \                cost45 += s->len_pack[icv][2]; \              BZ_ITER(0);  BZ_ITER(1);  BZ_ITER(2);  BZ_ITER(3);  BZ_ITER(4);
name|BZ_ITER
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|7
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|9
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|11
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|12
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|13
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|14
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|15
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|16
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|17
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|18
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|19
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|21
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|22
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|23
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|24
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|25
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|26
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|27
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|28
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|29
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|30
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|31
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|32
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|33
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|34
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|35
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|36
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|37
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|38
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|39
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|40
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|41
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|42
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|43
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|44
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|45
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|46
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|47
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|48
argument_list|)
expr_stmt|;
name|BZ_ITER
argument_list|(
literal|49
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|BZ_ITER
name|cost
index|[
literal|0
index|]
operator|=
name|cost01
operator|&
literal|0xffff
expr_stmt|;
name|cost
index|[
literal|1
index|]
operator|=
name|cost01
operator|>>
literal|16
expr_stmt|;
name|cost
index|[
literal|2
index|]
operator|=
name|cost23
operator|&
literal|0xffff
expr_stmt|;
name|cost
index|[
literal|3
index|]
operator|=
name|cost23
operator|>>
literal|16
expr_stmt|;
name|cost
index|[
literal|4
index|]
operator|=
name|cost45
operator|&
literal|0xffff
expr_stmt|;
name|cost
index|[
literal|5
index|]
operator|=
name|cost45
operator|>>
literal|16
expr_stmt|;
block|}
else|else
block|{
comment|/*--- slow version which correctly handles all situations ---*/
for|for
control|(
name|i
operator|=
name|gs
init|;
name|i
operator|<=
name|ge
condition|;
name|i
operator|++
control|)
block|{
name|UInt16
name|icv
init|=
name|mtfv
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|nGroups
condition|;
name|t
operator|++
control|)
name|cost
index|[
name|t
index|]
operator|+=
name|s
operator|->
name|len
index|[
name|t
index|]
index|[
name|icv
index|]
expr_stmt|;
block|}
block|}
comment|/*--              Find the coding table which is best for this group,             and record its identity in the selector table.          --*/
name|bc
operator|=
literal|999999999
expr_stmt|;
name|bt
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|nGroups
condition|;
name|t
operator|++
control|)
if|if
condition|(
name|cost
index|[
name|t
index|]
operator|<
name|bc
condition|)
block|{
name|bc
operator|=
name|cost
index|[
name|t
index|]
expr_stmt|;
name|bt
operator|=
name|t
expr_stmt|;
block|}
empty_stmt|;
name|totc
operator|+=
name|bc
expr_stmt|;
name|fave
index|[
name|bt
index|]
operator|++
expr_stmt|;
name|s
operator|->
name|selector
index|[
name|nSelectors
index|]
operator|=
name|bt
expr_stmt|;
name|nSelectors
operator|++
expr_stmt|;
comment|/*--              Increment the symbol frequencies for the selected table.           --*/
if|if
condition|(
name|nGroups
operator|==
literal|6
operator|&&
literal|50
operator|==
name|ge
operator|-
name|gs
operator|+
literal|1
condition|)
block|{
comment|/*--- fast track the common case ---*/
define|#
directive|define
name|BZ_ITUR
parameter_list|(
name|nn
parameter_list|)
value|s->rfreq[bt][ mtfv[gs+(nn)] ]++
name|BZ_ITUR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|7
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|9
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|11
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|12
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|13
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|14
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|15
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|16
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|17
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|18
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|19
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|21
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|22
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|23
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|24
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|25
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|26
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|27
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|28
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|29
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|30
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|31
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|32
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|33
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|34
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|35
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|36
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|37
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|38
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|39
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|40
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|41
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|42
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|43
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|44
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|45
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|46
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|47
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|48
argument_list|)
expr_stmt|;
name|BZ_ITUR
argument_list|(
literal|49
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|BZ_ITUR
block|}
else|else
block|{
comment|/*--- slow version which correctly handles all situations ---*/
for|for
control|(
name|i
operator|=
name|gs
init|;
name|i
operator|<=
name|ge
condition|;
name|i
operator|++
control|)
name|s
operator|->
name|rfreq
index|[
name|bt
index|]
index|[
name|mtfv
index|[
name|i
index|]
index|]
operator|++
expr_stmt|;
block|}
name|gs
operator|=
name|ge
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|verbosity
operator|>=
literal|3
condition|)
block|{
name|VPrintf2
argument_list|(
literal|"      pass %d: size is %d, grp uses are "
argument_list|,
name|iter
operator|+
literal|1
argument_list|,
name|totc
operator|/
literal|8
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|nGroups
condition|;
name|t
operator|++
control|)
name|VPrintf1
argument_list|(
literal|"%d "
argument_list|,
name|fave
index|[
name|t
index|]
argument_list|)
expr_stmt|;
name|VPrintf0
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/*--         Recompute the tables based on the accumulated frequencies.       --*/
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|nGroups
condition|;
name|t
operator|++
control|)
name|BZ2_hbMakeCodeLengths
argument_list|(
operator|&
operator|(
name|s
operator|->
name|len
index|[
name|t
index|]
index|[
literal|0
index|]
operator|)
argument_list|,
operator|&
operator|(
name|s
operator|->
name|rfreq
index|[
name|t
index|]
index|[
literal|0
index|]
operator|)
argument_list|,
name|alphaSize
argument_list|,
literal|20
argument_list|)
expr_stmt|;
block|}
name|AssertH
argument_list|(
name|nGroups
operator|<
literal|8
argument_list|,
literal|3002
argument_list|)
expr_stmt|;
name|AssertH
argument_list|(
name|nSelectors
operator|<
literal|32768
operator|&&
name|nSelectors
operator|<=
operator|(
literal|2
operator|+
operator|(
literal|900000
operator|/
name|BZ_G_SIZE
operator|)
operator|)
argument_list|,
literal|3003
argument_list|)
expr_stmt|;
comment|/*--- Compute MTF values for the selectors. ---*/
block|{
name|UChar
name|pos
index|[
name|BZ_N_GROUPS
index|]
decl_stmt|,
name|ll_i
decl_stmt|,
name|tmp2
decl_stmt|,
name|tmp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nGroups
condition|;
name|i
operator|++
control|)
name|pos
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nSelectors
condition|;
name|i
operator|++
control|)
block|{
name|ll_i
operator|=
name|s
operator|->
name|selector
index|[
name|i
index|]
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|pos
index|[
name|j
index|]
expr_stmt|;
while|while
condition|(
name|ll_i
operator|!=
name|tmp
condition|)
block|{
name|j
operator|++
expr_stmt|;
name|tmp2
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|pos
index|[
name|j
index|]
expr_stmt|;
name|pos
index|[
name|j
index|]
operator|=
name|tmp2
expr_stmt|;
block|}
empty_stmt|;
name|pos
index|[
literal|0
index|]
operator|=
name|tmp
expr_stmt|;
name|s
operator|->
name|selectorMtf
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
block|}
block|}
empty_stmt|;
comment|/*--- Assign actual codes for the tables. --*/
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|nGroups
condition|;
name|t
operator|++
control|)
block|{
name|minLen
operator|=
literal|32
expr_stmt|;
name|maxLen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alphaSize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|s
operator|->
name|len
index|[
name|t
index|]
index|[
name|i
index|]
operator|>
name|maxLen
condition|)
name|maxLen
operator|=
name|s
operator|->
name|len
index|[
name|t
index|]
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|len
index|[
name|t
index|]
index|[
name|i
index|]
operator|<
name|minLen
condition|)
name|minLen
operator|=
name|s
operator|->
name|len
index|[
name|t
index|]
index|[
name|i
index|]
expr_stmt|;
block|}
name|AssertH
argument_list|(
operator|!
operator|(
name|maxLen
operator|>
literal|20
operator|)
argument_list|,
literal|3004
argument_list|)
expr_stmt|;
name|AssertH
argument_list|(
operator|!
operator|(
name|minLen
operator|<
literal|1
operator|)
argument_list|,
literal|3005
argument_list|)
expr_stmt|;
name|BZ2_hbAssignCodes
argument_list|(
operator|&
operator|(
name|s
operator|->
name|code
index|[
name|t
index|]
index|[
literal|0
index|]
operator|)
argument_list|,
operator|&
operator|(
name|s
operator|->
name|len
index|[
name|t
index|]
index|[
literal|0
index|]
operator|)
argument_list|,
name|minLen
argument_list|,
name|maxLen
argument_list|,
name|alphaSize
argument_list|)
expr_stmt|;
block|}
comment|/*--- Transmit the mapping table. ---*/
block|{
name|Bool
name|inUse16
index|[
literal|16
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|inUse16
index|[
name|i
index|]
operator|=
name|False
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|s
operator|->
name|inUse
index|[
name|i
operator|*
literal|16
operator|+
name|j
index|]
condition|)
name|inUse16
index|[
name|i
index|]
operator|=
name|True
expr_stmt|;
block|}
name|nBytes
operator|=
name|s
operator|->
name|numZ
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|inUse16
index|[
name|i
index|]
condition|)
name|bsW
argument_list|(
name|s
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|bsW
argument_list|(
name|s
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|inUse16
index|[
name|i
index|]
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|s
operator|->
name|inUse
index|[
name|i
operator|*
literal|16
operator|+
name|j
index|]
condition|)
name|bsW
argument_list|(
name|s
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|bsW
argument_list|(
name|s
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|verbosity
operator|>=
literal|3
condition|)
name|VPrintf1
argument_list|(
literal|"      bytes: mapping %d, "
argument_list|,
name|s
operator|->
name|numZ
operator|-
name|nBytes
argument_list|)
expr_stmt|;
block|}
comment|/*--- Now the selectors. ---*/
name|nBytes
operator|=
name|s
operator|->
name|numZ
expr_stmt|;
name|bsW
argument_list|(
name|s
argument_list|,
literal|3
argument_list|,
name|nGroups
argument_list|)
expr_stmt|;
name|bsW
argument_list|(
name|s
argument_list|,
literal|15
argument_list|,
name|nSelectors
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nSelectors
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|s
operator|->
name|selectorMtf
index|[
name|i
index|]
condition|;
name|j
operator|++
control|)
name|bsW
argument_list|(
name|s
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bsW
argument_list|(
name|s
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|verbosity
operator|>=
literal|3
condition|)
name|VPrintf1
argument_list|(
literal|"selectors %d, "
argument_list|,
name|s
operator|->
name|numZ
operator|-
name|nBytes
argument_list|)
expr_stmt|;
comment|/*--- Now the coding tables. ---*/
name|nBytes
operator|=
name|s
operator|->
name|numZ
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|nGroups
condition|;
name|t
operator|++
control|)
block|{
name|Int32
name|curr
init|=
name|s
operator|->
name|len
index|[
name|t
index|]
index|[
literal|0
index|]
decl_stmt|;
name|bsW
argument_list|(
name|s
argument_list|,
literal|5
argument_list|,
name|curr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alphaSize
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
name|curr
operator|<
name|s
operator|->
name|len
index|[
name|t
index|]
index|[
name|i
index|]
condition|)
block|{
name|bsW
argument_list|(
name|s
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|curr
operator|++
expr_stmt|;
comment|/* 10 */
block|}
empty_stmt|;
while|while
condition|(
name|curr
operator|>
name|s
operator|->
name|len
index|[
name|t
index|]
index|[
name|i
index|]
condition|)
block|{
name|bsW
argument_list|(
name|s
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|curr
operator|--
expr_stmt|;
comment|/* 11 */
block|}
empty_stmt|;
name|bsW
argument_list|(
name|s
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|s
operator|->
name|verbosity
operator|>=
literal|3
condition|)
name|VPrintf1
argument_list|(
literal|"code lengths %d, "
argument_list|,
name|s
operator|->
name|numZ
operator|-
name|nBytes
argument_list|)
expr_stmt|;
comment|/*--- And finally, the block data proper ---*/
name|nBytes
operator|=
name|s
operator|->
name|numZ
expr_stmt|;
name|selCtr
operator|=
literal|0
expr_stmt|;
name|gs
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|True
condition|)
block|{
if|if
condition|(
name|gs
operator|>=
name|s
operator|->
name|nMTF
condition|)
break|break;
name|ge
operator|=
name|gs
operator|+
name|BZ_G_SIZE
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ge
operator|>=
name|s
operator|->
name|nMTF
condition|)
name|ge
operator|=
name|s
operator|->
name|nMTF
operator|-
literal|1
expr_stmt|;
name|AssertH
argument_list|(
name|s
operator|->
name|selector
index|[
name|selCtr
index|]
operator|<
name|nGroups
argument_list|,
literal|3006
argument_list|)
expr_stmt|;
if|if
condition|(
name|nGroups
operator|==
literal|6
operator|&&
literal|50
operator|==
name|ge
operator|-
name|gs
operator|+
literal|1
condition|)
block|{
comment|/*--- fast track the common case ---*/
name|UInt16
name|mtfv_i
decl_stmt|;
name|UChar
modifier|*
name|s_len_sel_selCtr
init|=
operator|&
operator|(
name|s
operator|->
name|len
index|[
name|s
operator|->
name|selector
index|[
name|selCtr
index|]
index|]
index|[
literal|0
index|]
operator|)
decl_stmt|;
name|Int32
modifier|*
name|s_code_sel_selCtr
init|=
operator|&
operator|(
name|s
operator|->
name|code
index|[
name|s
operator|->
name|selector
index|[
name|selCtr
index|]
index|]
index|[
literal|0
index|]
operator|)
decl_stmt|;
define|#
directive|define
name|BZ_ITAH
parameter_list|(
name|nn
parameter_list|)
define|\
value|mtfv_i = mtfv[gs+(nn)];              \                bsW ( s,                             \                      s_len_sel_selCtr[mtfv_i],      \                      s_code_sel_selCtr[mtfv_i] )
name|BZ_ITAH
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|7
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|9
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|11
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|12
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|13
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|14
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|15
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|16
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|17
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|18
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|19
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|21
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|22
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|23
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|24
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|25
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|26
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|27
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|28
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|29
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|30
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|31
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|32
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|33
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|34
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|35
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|36
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|37
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|38
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|39
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|40
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|41
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|42
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|43
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|44
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|45
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|46
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|47
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|48
argument_list|)
expr_stmt|;
name|BZ_ITAH
argument_list|(
literal|49
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|BZ_ITAH
block|}
else|else
block|{
comment|/*--- slow version which correctly handles all situations ---*/
for|for
control|(
name|i
operator|=
name|gs
init|;
name|i
operator|<=
name|ge
condition|;
name|i
operator|++
control|)
block|{
name|bsW
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|len
index|[
name|s
operator|->
name|selector
index|[
name|selCtr
index|]
index|]
index|[
name|mtfv
index|[
name|i
index|]
index|]
argument_list|,
name|s
operator|->
name|code
index|[
name|s
operator|->
name|selector
index|[
name|selCtr
index|]
index|]
index|[
name|mtfv
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|gs
operator|=
name|ge
operator|+
literal|1
expr_stmt|;
name|selCtr
operator|++
expr_stmt|;
block|}
name|AssertH
argument_list|(
name|selCtr
operator|==
name|nSelectors
argument_list|,
literal|3007
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|verbosity
operator|>=
literal|3
condition|)
name|VPrintf1
argument_list|(
literal|"codes %d\n"
argument_list|,
name|s
operator|->
name|numZ
operator|-
name|nBytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_function
name|void
name|BZ2_compressBlock
parameter_list|(
name|EState
modifier|*
name|s
parameter_list|,
name|Bool
name|is_last_block
parameter_list|)
block|{
if|if
condition|(
name|s
operator|->
name|nblock
operator|>
literal|0
condition|)
block|{
name|BZ_FINALISE_CRC
argument_list|(
name|s
operator|->
name|blockCRC
argument_list|)
expr_stmt|;
name|s
operator|->
name|combinedCRC
operator|=
operator|(
name|s
operator|->
name|combinedCRC
operator|<<
literal|1
operator|)
operator||
operator|(
name|s
operator|->
name|combinedCRC
operator|>>
literal|31
operator|)
expr_stmt|;
name|s
operator|->
name|combinedCRC
operator|^=
name|s
operator|->
name|blockCRC
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|blockNo
operator|>
literal|1
condition|)
name|s
operator|->
name|numZ
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|verbosity
operator|>=
literal|2
condition|)
name|VPrintf4
argument_list|(
literal|"    block %d: crc = 0x%8x, "
literal|"combined CRC = 0x%8x, size = %d\n"
argument_list|,
name|s
operator|->
name|blockNo
argument_list|,
name|s
operator|->
name|blockCRC
argument_list|,
name|s
operator|->
name|combinedCRC
argument_list|,
name|s
operator|->
name|nblock
argument_list|)
expr_stmt|;
name|BZ2_blockSort
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|zbits
operator|=
operator|(
name|UChar
operator|*
operator|)
operator|(
operator|&
operator|(
operator|(
name|UChar
operator|*
operator|)
name|s
operator|->
name|arr2
operator|)
index|[
name|s
operator|->
name|nblock
index|]
operator|)
expr_stmt|;
comment|/*-- If this is the first block, create the stream header. --*/
if|if
condition|(
name|s
operator|->
name|blockNo
operator|==
literal|1
condition|)
block|{
name|BZ2_bsInitWrite
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|bsPutUChar
argument_list|(
name|s
argument_list|,
literal|'B'
argument_list|)
expr_stmt|;
name|bsPutUChar
argument_list|(
name|s
argument_list|,
literal|'Z'
argument_list|)
expr_stmt|;
name|bsPutUChar
argument_list|(
name|s
argument_list|,
literal|'h'
argument_list|)
expr_stmt|;
name|bsPutUChar
argument_list|(
name|s
argument_list|,
call|(
name|UChar
call|)
argument_list|(
literal|'0'
operator|+
name|s
operator|->
name|blockSize100k
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|nblock
operator|>
literal|0
condition|)
block|{
name|bsPutUChar
argument_list|(
name|s
argument_list|,
literal|0x31
argument_list|)
expr_stmt|;
name|bsPutUChar
argument_list|(
name|s
argument_list|,
literal|0x41
argument_list|)
expr_stmt|;
name|bsPutUChar
argument_list|(
name|s
argument_list|,
literal|0x59
argument_list|)
expr_stmt|;
name|bsPutUChar
argument_list|(
name|s
argument_list|,
literal|0x26
argument_list|)
expr_stmt|;
name|bsPutUChar
argument_list|(
name|s
argument_list|,
literal|0x53
argument_list|)
expr_stmt|;
name|bsPutUChar
argument_list|(
name|s
argument_list|,
literal|0x59
argument_list|)
expr_stmt|;
comment|/*-- Now the block's CRC, so it is in a known place. --*/
name|bsPutUInt32
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|blockCRC
argument_list|)
expr_stmt|;
comment|/*--           Now a single bit indicating (non-)randomisation.           As of version 0.9.5, we use a better sorting algorithm          which makes randomisation unnecessary.  So always set          the randomised bit to 'no'.  Of course, the decoder          still needs to be able to handle randomised blocks          so as to maintain backwards compatibility with          older versions of bzip2.       --*/
name|bsW
argument_list|(
name|s
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bsW
argument_list|(
name|s
argument_list|,
literal|24
argument_list|,
name|s
operator|->
name|origPtr
argument_list|)
expr_stmt|;
name|generateMTFValues
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sendMTFValues
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/*-- If this is the last block, add the stream trailer. --*/
if|if
condition|(
name|is_last_block
condition|)
block|{
name|bsPutUChar
argument_list|(
name|s
argument_list|,
literal|0x17
argument_list|)
expr_stmt|;
name|bsPutUChar
argument_list|(
name|s
argument_list|,
literal|0x72
argument_list|)
expr_stmt|;
name|bsPutUChar
argument_list|(
name|s
argument_list|,
literal|0x45
argument_list|)
expr_stmt|;
name|bsPutUChar
argument_list|(
name|s
argument_list|,
literal|0x38
argument_list|)
expr_stmt|;
name|bsPutUChar
argument_list|(
name|s
argument_list|,
literal|0x50
argument_list|)
expr_stmt|;
name|bsPutUChar
argument_list|(
name|s
argument_list|,
literal|0x90
argument_list|)
expr_stmt|;
name|bsPutUInt32
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|combinedCRC
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|verbosity
operator|>=
literal|2
condition|)
name|VPrintf1
argument_list|(
literal|"    final combined CRC = 0x%x\n   "
argument_list|,
name|s
operator|->
name|combinedCRC
argument_list|)
expr_stmt|;
name|bsFinishWrite
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-------------------------------------------------------------*/
end_comment

begin_comment
comment|/*--- end                                        compress.c ---*/
end_comment

begin_comment
comment|/*-------------------------------------------------------------*/
end_comment

end_unit

