begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-----------------------------------------------------------*/
end_comment

begin_comment
comment|/*--- Block recoverer program for bzip2                   ---*/
end_comment

begin_comment
comment|/*---                                      bzip2recover.c ---*/
end_comment

begin_comment
comment|/*-----------------------------------------------------------*/
end_comment

begin_comment
comment|/* ------------------------------------------------------------------    This file is part of bzip2/libbzip2, a program and library for    lossless, block-sorting data compression.     bzip2/libbzip2 version 1.0.5 of 10 December 2007    Copyright (C) 1996-2007 Julian Seward<jseward@bzip.org>     Please read the WARNING, DISCLAIMER and PATENTS sections in the     README file.     This program is released under the terms of the license contained    in the file LICENSE.    ------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* This program is a complete hack and should be rewritten properly. 	 It isn't very complicated. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* This program records bit locations in the file to be recovered.    That means that if 64-bit ints are not supported, we will not    be able to recover .bz2 files over 512MB (2^32 bits) long.    On GNU supported platforms, we take advantage of the 64-bit    int support to circumvent this problem.  Ditto MSVC.     This change occurred in version 1.0.2; all prior versions have    the 512MB limitation. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_typedef
typedef|typedef
name|unsigned
name|long
name|long
name|int
name|MaybeUInt64
typedef|;
end_typedef

begin_define
define|#
directive|define
name|MaybeUInt64_FMT
value|"%Lu"
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_typedef
typedef|typedef
name|unsigned
name|__int64
name|MaybeUInt64
typedef|;
end_typedef

begin_define
define|#
directive|define
name|MaybeUInt64_FMT
value|"%I64u"
end_define

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|unsigned
name|int
name|MaybeUInt64
typedef|;
end_typedef

begin_define
define|#
directive|define
name|MaybeUInt64_FMT
value|"%u"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|unsigned
name|int
name|UInt32
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|int
name|Int32
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|char
name|UChar
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|char
name|Char
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|char
name|Bool
typedef|;
end_typedef

begin_define
define|#
directive|define
name|True
value|((Bool)1)
end_define

begin_define
define|#
directive|define
name|False
value|((Bool)0)
end_define

begin_define
define|#
directive|define
name|BZ_MAX_FILENAME
value|2000
end_define

begin_decl_stmt
name|Char
name|inFileName
index|[
name|BZ_MAX_FILENAME
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Char
name|outFileName
index|[
name|BZ_MAX_FILENAME
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Char
name|progName
index|[
name|BZ_MAX_FILENAME
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|MaybeUInt64
name|bytesOut
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|MaybeUInt64
name|bytesIn
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_comment
comment|/*--- Header bytes                                ---*/
end_comment

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_define
define|#
directive|define
name|BZ_HDR_B
value|0x42
end_define

begin_comment
comment|/* 'B' */
end_comment

begin_define
define|#
directive|define
name|BZ_HDR_Z
value|0x5a
end_define

begin_comment
comment|/* 'Z' */
end_comment

begin_define
define|#
directive|define
name|BZ_HDR_h
value|0x68
end_define

begin_comment
comment|/* 'h' */
end_comment

begin_define
define|#
directive|define
name|BZ_HDR_0
value|0x30
end_define

begin_comment
comment|/* '0' */
end_comment

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_comment
comment|/*--- I/O errors                                  ---*/
end_comment

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|readError
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: I/O error reading `%s', possible reason follows.\n"
argument_list|,
name|progName
argument_list|,
name|inFileName
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|progName
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: warning: output file(s) may be incomplete.\n"
argument_list|,
name|progName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|writeError
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: I/O error reading `%s', possible reason follows.\n"
argument_list|,
name|progName
argument_list|,
name|inFileName
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|progName
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: warning: output file(s) may be incomplete.\n"
argument_list|,
name|progName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|mallocFail
parameter_list|(
name|Int32
name|n
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: malloc failed on request for %d bytes.\n"
argument_list|,
name|progName
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: warning: output file(s) may be incomplete.\n"
argument_list|,
name|progName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|tooManyBlocks
parameter_list|(
name|Int32
name|max_handled_blocks
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: `%s' appears to contain more than %d blocks\n"
argument_list|,
name|progName
argument_list|,
name|inFileName
argument_list|,
name|max_handled_blocks
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: and cannot be handled.  To fix, increase\n"
argument_list|,
name|progName
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: BZ_MAX_HANDLED_BLOCKS in bzip2recover.c, and recompile.\n"
argument_list|,
name|progName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_comment
comment|/*--- Bit stream I/O                              ---*/
end_comment

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|FILE
modifier|*
name|handle
decl_stmt|;
name|Int32
name|buffer
decl_stmt|;
name|Int32
name|buffLive
decl_stmt|;
name|Char
name|mode
decl_stmt|;
block|}
name|BitStream
typedef|;
end_typedef

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|BitStream
modifier|*
name|bsOpenReadStream
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|BitStream
modifier|*
name|bs
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BitStream
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|bs
operator|==
name|NULL
condition|)
name|mallocFail
argument_list|(
sizeof|sizeof
argument_list|(
name|BitStream
argument_list|)
argument_list|)
expr_stmt|;
name|bs
operator|->
name|handle
operator|=
name|stream
expr_stmt|;
name|bs
operator|->
name|buffer
operator|=
literal|0
expr_stmt|;
name|bs
operator|->
name|buffLive
operator|=
literal|0
expr_stmt|;
name|bs
operator|->
name|mode
operator|=
literal|'r'
expr_stmt|;
return|return
name|bs
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|BitStream
modifier|*
name|bsOpenWriteStream
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|BitStream
modifier|*
name|bs
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BitStream
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|bs
operator|==
name|NULL
condition|)
name|mallocFail
argument_list|(
sizeof|sizeof
argument_list|(
name|BitStream
argument_list|)
argument_list|)
expr_stmt|;
name|bs
operator|->
name|handle
operator|=
name|stream
expr_stmt|;
name|bs
operator|->
name|buffer
operator|=
literal|0
expr_stmt|;
name|bs
operator|->
name|buffLive
operator|=
literal|0
expr_stmt|;
name|bs
operator|->
name|mode
operator|=
literal|'w'
expr_stmt|;
return|return
name|bs
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|bsPutBit
parameter_list|(
name|BitStream
modifier|*
name|bs
parameter_list|,
name|Int32
name|bit
parameter_list|)
block|{
if|if
condition|(
name|bs
operator|->
name|buffLive
operator|==
literal|8
condition|)
block|{
name|Int32
name|retVal
init|=
name|putc
argument_list|(
operator|(
name|UChar
operator|)
name|bs
operator|->
name|buffer
argument_list|,
name|bs
operator|->
name|handle
argument_list|)
decl_stmt|;
if|if
condition|(
name|retVal
operator|==
name|EOF
condition|)
name|writeError
argument_list|()
expr_stmt|;
name|bytesOut
operator|++
expr_stmt|;
name|bs
operator|->
name|buffLive
operator|=
literal|1
expr_stmt|;
name|bs
operator|->
name|buffer
operator|=
name|bit
operator|&
literal|0x1
expr_stmt|;
block|}
else|else
block|{
name|bs
operator|->
name|buffer
operator|=
operator|(
operator|(
name|bs
operator|->
name|buffer
operator|<<
literal|1
operator|)
operator||
operator|(
name|bit
operator|&
literal|0x1
operator|)
operator|)
expr_stmt|;
name|bs
operator|->
name|buffLive
operator|++
expr_stmt|;
block|}
empty_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_comment
comment|/*--    Returns 0 or 1, or 2 to indicate EOF. --*/
end_comment

begin_function
specifier|static
name|Int32
name|bsGetBit
parameter_list|(
name|BitStream
modifier|*
name|bs
parameter_list|)
block|{
if|if
condition|(
name|bs
operator|->
name|buffLive
operator|>
literal|0
condition|)
block|{
name|bs
operator|->
name|buffLive
operator|--
expr_stmt|;
return|return
operator|(
operator|(
operator|(
name|bs
operator|->
name|buffer
operator|)
operator|>>
operator|(
name|bs
operator|->
name|buffLive
operator|)
operator|)
operator|&
literal|0x1
operator|)
return|;
block|}
else|else
block|{
name|Int32
name|retVal
init|=
name|getc
argument_list|(
name|bs
operator|->
name|handle
argument_list|)
decl_stmt|;
if|if
condition|(
name|retVal
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
name|readError
argument_list|()
expr_stmt|;
return|return
literal|2
return|;
block|}
name|bs
operator|->
name|buffLive
operator|=
literal|7
expr_stmt|;
name|bs
operator|->
name|buffer
operator|=
name|retVal
expr_stmt|;
return|return
operator|(
operator|(
operator|(
name|bs
operator|->
name|buffer
operator|)
operator|>>
literal|7
operator|)
operator|&
literal|0x1
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|bsClose
parameter_list|(
name|BitStream
modifier|*
name|bs
parameter_list|)
block|{
name|Int32
name|retVal
decl_stmt|;
if|if
condition|(
name|bs
operator|->
name|mode
operator|==
literal|'w'
condition|)
block|{
while|while
condition|(
name|bs
operator|->
name|buffLive
operator|<
literal|8
condition|)
block|{
name|bs
operator|->
name|buffLive
operator|++
expr_stmt|;
name|bs
operator|->
name|buffer
operator|<<=
literal|1
expr_stmt|;
block|}
empty_stmt|;
name|retVal
operator|=
name|putc
argument_list|(
call|(
name|UChar
call|)
argument_list|(
name|bs
operator|->
name|buffer
argument_list|)
argument_list|,
name|bs
operator|->
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|retVal
operator|==
name|EOF
condition|)
name|writeError
argument_list|()
expr_stmt|;
name|bytesOut
operator|++
expr_stmt|;
name|retVal
operator|=
name|fflush
argument_list|(
name|bs
operator|->
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|retVal
operator|==
name|EOF
condition|)
name|writeError
argument_list|()
expr_stmt|;
block|}
name|retVal
operator|=
name|fclose
argument_list|(
name|bs
operator|->
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|retVal
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|bs
operator|->
name|mode
operator|==
literal|'w'
condition|)
name|writeError
argument_list|()
expr_stmt|;
else|else
name|readError
argument_list|()
expr_stmt|;
block|}
name|free
argument_list|(
name|bs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|bsPutUChar
parameter_list|(
name|BitStream
modifier|*
name|bs
parameter_list|,
name|UChar
name|c
parameter_list|)
block|{
name|Int32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|7
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|bsPutBit
argument_list|(
name|bs
argument_list|,
operator|(
operator|(
operator|(
name|UInt32
operator|)
name|c
operator|)
operator|>>
name|i
operator|)
operator|&
literal|0x1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|bsPutUInt32
parameter_list|(
name|BitStream
modifier|*
name|bs
parameter_list|,
name|UInt32
name|c
parameter_list|)
block|{
name|Int32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|31
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|bsPutBit
argument_list|(
name|bs
argument_list|,
operator|(
name|c
operator|>>
name|i
operator|)
operator|&
literal|0x1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|Bool
name|endsInBz2
parameter_list|(
name|Char
modifier|*
name|name
parameter_list|)
block|{
name|Int32
name|n
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|<=
literal|4
condition|)
return|return
name|False
return|;
return|return
operator|(
name|name
index|[
name|n
operator|-
literal|4
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
name|n
operator|-
literal|3
index|]
operator|==
literal|'b'
operator|&&
name|name
index|[
name|n
operator|-
literal|2
index|]
operator|==
literal|'z'
operator|&&
name|name
index|[
name|n
operator|-
literal|1
index|]
operator|==
literal|'2'
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_comment
comment|/*---                                             ---*/
end_comment

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_comment
comment|/* This logic isn't really right when it comes to Cygwin. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_define
define|#
directive|define
name|BZ_SPLIT_SYM
value|'\\'
end_define

begin_comment
comment|/* path splitter on Windows platform */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BZ_SPLIT_SYM
value|'/'
end_define

begin_comment
comment|/* path splitter on Unix platform */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|BLOCK_HEADER_HI
value|0x00003141UL
end_define

begin_define
define|#
directive|define
name|BLOCK_HEADER_LO
value|0x59265359UL
end_define

begin_define
define|#
directive|define
name|BLOCK_ENDMARK_HI
value|0x00001772UL
end_define

begin_define
define|#
directive|define
name|BLOCK_ENDMARK_LO
value|0x45385090UL
end_define

begin_comment
comment|/* Increase if necessary.  However, a .bz2 file with> 50000 blocks    would have an uncompressed size of at least 40GB, so the chances    are low you'll need to up this. */
end_comment

begin_define
define|#
directive|define
name|BZ_MAX_HANDLED_BLOCKS
value|50000
end_define

begin_decl_stmt
name|MaybeUInt64
name|bStart
index|[
name|BZ_MAX_HANDLED_BLOCKS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|MaybeUInt64
name|bEnd
index|[
name|BZ_MAX_HANDLED_BLOCKS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|MaybeUInt64
name|rbStart
index|[
name|BZ_MAX_HANDLED_BLOCKS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|MaybeUInt64
name|rbEnd
index|[
name|BZ_MAX_HANDLED_BLOCKS
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|Int32
name|main
parameter_list|(
name|Int32
name|argc
parameter_list|,
name|Char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|FILE
modifier|*
name|inFile
decl_stmt|;
name|FILE
modifier|*
name|outFile
decl_stmt|;
name|BitStream
modifier|*
name|bsIn
decl_stmt|,
modifier|*
name|bsWr
decl_stmt|;
name|Int32
name|b
decl_stmt|,
name|wrBlock
decl_stmt|,
name|currBlock
decl_stmt|,
name|rbCtr
decl_stmt|;
name|MaybeUInt64
name|bitsRead
decl_stmt|;
name|UInt32
name|buffHi
decl_stmt|,
name|buffLo
decl_stmt|,
name|blockCRC
decl_stmt|;
name|Char
modifier|*
name|p
decl_stmt|;
name|strcpy
argument_list|(
name|progName
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|inFileName
index|[
literal|0
index|]
operator|=
name|outFileName
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bzip2recover 1.0.5: extracts blocks from damaged .bz2 files.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: usage is `%s damaged_file_name'.\n"
argument_list|,
name|progName
argument_list|,
name|progName
argument_list|)
expr_stmt|;
switch|switch
condition|(
sizeof|sizeof
argument_list|(
name|MaybeUInt64
argument_list|)
condition|)
block|{
case|case
literal|8
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\trestrictions on size of recovered file: None\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\trestrictions on size of recovered file: 512 MB\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tto circumvent, recompile with MaybeUInt64 as an\n"
literal|"\tunsigned 64-bit int.\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tsizeof(MaybeUInt64) is not 4 or 8 -- "
literal|"configuration error.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
operator|>=
name|BZ_MAX_FILENAME
operator|-
literal|20
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: supplied filename is suspiciously (>= %d chars) long.  Bye!\n"
argument_list|,
name|progName
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|inFileName
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|inFile
operator|=
name|fopen
argument_list|(
name|inFileName
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|inFile
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: can't read `%s'\n"
argument_list|,
name|progName
argument_list|,
name|inFileName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|bsIn
operator|=
name|bsOpenReadStream
argument_list|(
name|inFile
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: searching for block boundaries ...\n"
argument_list|,
name|progName
argument_list|)
expr_stmt|;
name|bitsRead
operator|=
literal|0
expr_stmt|;
name|buffHi
operator|=
name|buffLo
operator|=
literal|0
expr_stmt|;
name|currBlock
operator|=
literal|0
expr_stmt|;
name|bStart
index|[
name|currBlock
index|]
operator|=
literal|0
expr_stmt|;
name|rbCtr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|True
condition|)
block|{
name|b
operator|=
name|bsGetBit
argument_list|(
name|bsIn
argument_list|)
expr_stmt|;
name|bitsRead
operator|++
expr_stmt|;
if|if
condition|(
name|b
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|bitsRead
operator|>=
name|bStart
index|[
name|currBlock
index|]
operator|&&
operator|(
name|bitsRead
operator|-
name|bStart
index|[
name|currBlock
index|]
operator|)
operator|>=
literal|40
condition|)
block|{
name|bEnd
index|[
name|currBlock
index|]
operator|=
name|bitsRead
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|currBlock
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"   block %d runs from "
name|MaybeUInt64_FMT
literal|" to "
name|MaybeUInt64_FMT
literal|" (incomplete)\n"
argument_list|,
name|currBlock
argument_list|,
name|bStart
index|[
name|currBlock
index|]
argument_list|,
name|bEnd
index|[
name|currBlock
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|currBlock
operator|--
expr_stmt|;
break|break;
block|}
name|buffHi
operator|=
operator|(
name|buffHi
operator|<<
literal|1
operator|)
operator||
operator|(
name|buffLo
operator|>>
literal|31
operator|)
expr_stmt|;
name|buffLo
operator|=
operator|(
name|buffLo
operator|<<
literal|1
operator|)
operator||
operator|(
name|b
operator|&
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|buffHi
operator|&
literal|0x0000ffff
operator|)
operator|==
name|BLOCK_HEADER_HI
operator|&&
name|buffLo
operator|==
name|BLOCK_HEADER_LO
operator|)
operator|||
operator|(
operator|(
name|buffHi
operator|&
literal|0x0000ffff
operator|)
operator|==
name|BLOCK_ENDMARK_HI
operator|&&
name|buffLo
operator|==
name|BLOCK_ENDMARK_LO
operator|)
condition|)
block|{
if|if
condition|(
name|bitsRead
operator|>
literal|49
condition|)
block|{
name|bEnd
index|[
name|currBlock
index|]
operator|=
name|bitsRead
operator|-
literal|49
expr_stmt|;
block|}
else|else
block|{
name|bEnd
index|[
name|currBlock
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|currBlock
operator|>
literal|0
operator|&&
operator|(
name|bEnd
index|[
name|currBlock
index|]
operator|-
name|bStart
index|[
name|currBlock
index|]
operator|)
operator|>=
literal|130
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"   block %d runs from "
name|MaybeUInt64_FMT
literal|" to "
name|MaybeUInt64_FMT
literal|"\n"
argument_list|,
name|rbCtr
operator|+
literal|1
argument_list|,
name|bStart
index|[
name|currBlock
index|]
argument_list|,
name|bEnd
index|[
name|currBlock
index|]
argument_list|)
expr_stmt|;
name|rbStart
index|[
name|rbCtr
index|]
operator|=
name|bStart
index|[
name|currBlock
index|]
expr_stmt|;
name|rbEnd
index|[
name|rbCtr
index|]
operator|=
name|bEnd
index|[
name|currBlock
index|]
expr_stmt|;
name|rbCtr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|currBlock
operator|>=
name|BZ_MAX_HANDLED_BLOCKS
condition|)
name|tooManyBlocks
argument_list|(
name|BZ_MAX_HANDLED_BLOCKS
argument_list|)
expr_stmt|;
name|currBlock
operator|++
expr_stmt|;
name|bStart
index|[
name|currBlock
index|]
operator|=
name|bitsRead
expr_stmt|;
block|}
block|}
name|bsClose
argument_list|(
name|bsIn
argument_list|)
expr_stmt|;
comment|/*-- identified blocks run from 1 to rbCtr inclusive. --*/
if|if
condition|(
name|rbCtr
operator|<
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: sorry, I couldn't find any block boundaries.\n"
argument_list|,
name|progName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: splitting into blocks\n"
argument_list|,
name|progName
argument_list|)
expr_stmt|;
name|inFile
operator|=
name|fopen
argument_list|(
name|inFileName
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|inFile
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: can't open `%s'\n"
argument_list|,
name|progName
argument_list|,
name|inFileName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|bsIn
operator|=
name|bsOpenReadStream
argument_list|(
name|inFile
argument_list|)
expr_stmt|;
comment|/*-- placate gcc's dataflow analyser --*/
name|blockCRC
operator|=
literal|0
expr_stmt|;
name|bsWr
operator|=
literal|0
expr_stmt|;
name|bitsRead
operator|=
literal|0
expr_stmt|;
name|outFile
operator|=
name|NULL
expr_stmt|;
name|wrBlock
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|True
condition|)
block|{
name|b
operator|=
name|bsGetBit
argument_list|(
name|bsIn
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
literal|2
condition|)
break|break;
name|buffHi
operator|=
operator|(
name|buffHi
operator|<<
literal|1
operator|)
operator||
operator|(
name|buffLo
operator|>>
literal|31
operator|)
expr_stmt|;
name|buffLo
operator|=
operator|(
name|buffLo
operator|<<
literal|1
operator|)
operator||
operator|(
name|b
operator|&
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|bitsRead
operator|==
literal|47
operator|+
name|rbStart
index|[
name|wrBlock
index|]
condition|)
name|blockCRC
operator|=
operator|(
name|buffHi
operator|<<
literal|16
operator|)
operator||
operator|(
name|buffLo
operator|>>
literal|16
operator|)
expr_stmt|;
if|if
condition|(
name|outFile
operator|!=
name|NULL
operator|&&
name|bitsRead
operator|>=
name|rbStart
index|[
name|wrBlock
index|]
operator|&&
name|bitsRead
operator|<=
name|rbEnd
index|[
name|wrBlock
index|]
condition|)
block|{
name|bsPutBit
argument_list|(
name|bsWr
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
name|bitsRead
operator|++
expr_stmt|;
if|if
condition|(
name|bitsRead
operator|==
name|rbEnd
index|[
name|wrBlock
index|]
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|outFile
operator|!=
name|NULL
condition|)
block|{
name|bsPutUChar
argument_list|(
name|bsWr
argument_list|,
literal|0x17
argument_list|)
expr_stmt|;
name|bsPutUChar
argument_list|(
name|bsWr
argument_list|,
literal|0x72
argument_list|)
expr_stmt|;
name|bsPutUChar
argument_list|(
name|bsWr
argument_list|,
literal|0x45
argument_list|)
expr_stmt|;
name|bsPutUChar
argument_list|(
name|bsWr
argument_list|,
literal|0x38
argument_list|)
expr_stmt|;
name|bsPutUChar
argument_list|(
name|bsWr
argument_list|,
literal|0x50
argument_list|)
expr_stmt|;
name|bsPutUChar
argument_list|(
name|bsWr
argument_list|,
literal|0x90
argument_list|)
expr_stmt|;
name|bsPutUInt32
argument_list|(
name|bsWr
argument_list|,
name|blockCRC
argument_list|)
expr_stmt|;
name|bsClose
argument_list|(
name|bsWr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wrBlock
operator|>=
name|rbCtr
condition|)
break|break;
name|wrBlock
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitsRead
operator|==
name|rbStart
index|[
name|wrBlock
index|]
condition|)
block|{
comment|/* Create the output file name, correctly handling leading paths.              (31.10.2001 by Sergey E. Kusikov) */
name|Char
modifier|*
name|split
decl_stmt|;
name|Int32
name|ofs
decl_stmt|,
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|BZ_MAX_FILENAME
condition|;
name|k
operator|++
control|)
name|outFileName
index|[
name|k
index|]
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|outFileName
argument_list|,
name|inFileName
argument_list|)
expr_stmt|;
name|split
operator|=
name|strrchr
argument_list|(
name|outFileName
argument_list|,
name|BZ_SPLIT_SYM
argument_list|)
expr_stmt|;
if|if
condition|(
name|split
operator|==
name|NULL
condition|)
block|{
name|split
operator|=
name|outFileName
expr_stmt|;
block|}
else|else
block|{
operator|++
name|split
expr_stmt|;
block|}
comment|/* Now split points to the start of the basename. */
name|ofs
operator|=
name|split
operator|-
name|outFileName
expr_stmt|;
name|sprintf
argument_list|(
name|split
argument_list|,
literal|"rec%5d"
argument_list|,
name|wrBlock
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|split
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
operator|*
name|p
operator|=
literal|'0'
expr_stmt|;
name|strcat
argument_list|(
name|outFileName
argument_list|,
name|inFileName
operator|+
name|ofs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|endsInBz2
argument_list|(
name|outFileName
argument_list|)
condition|)
name|strcat
argument_list|(
name|outFileName
argument_list|,
literal|".bz2"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"   writing block %d to `%s' ...\n"
argument_list|,
name|wrBlock
operator|+
literal|1
argument_list|,
name|outFileName
argument_list|)
expr_stmt|;
name|outFile
operator|=
name|fopen
argument_list|(
name|outFileName
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|outFile
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: can't write `%s'\n"
argument_list|,
name|progName
argument_list|,
name|outFileName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|bsWr
operator|=
name|bsOpenWriteStream
argument_list|(
name|outFile
argument_list|)
expr_stmt|;
name|bsPutUChar
argument_list|(
name|bsWr
argument_list|,
name|BZ_HDR_B
argument_list|)
expr_stmt|;
name|bsPutUChar
argument_list|(
name|bsWr
argument_list|,
name|BZ_HDR_Z
argument_list|)
expr_stmt|;
name|bsPutUChar
argument_list|(
name|bsWr
argument_list|,
name|BZ_HDR_h
argument_list|)
expr_stmt|;
name|bsPutUChar
argument_list|(
name|bsWr
argument_list|,
name|BZ_HDR_0
operator|+
literal|9
argument_list|)
expr_stmt|;
name|bsPutUChar
argument_list|(
name|bsWr
argument_list|,
literal|0x31
argument_list|)
expr_stmt|;
name|bsPutUChar
argument_list|(
name|bsWr
argument_list|,
literal|0x41
argument_list|)
expr_stmt|;
name|bsPutUChar
argument_list|(
name|bsWr
argument_list|,
literal|0x59
argument_list|)
expr_stmt|;
name|bsPutUChar
argument_list|(
name|bsWr
argument_list|,
literal|0x26
argument_list|)
expr_stmt|;
name|bsPutUChar
argument_list|(
name|bsWr
argument_list|,
literal|0x53
argument_list|)
expr_stmt|;
name|bsPutUChar
argument_list|(
name|bsWr
argument_list|,
literal|0x59
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: finished\n"
argument_list|,
name|progName
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------*/
end_comment

begin_comment
comment|/*--- end                                  bzip2recover.c ---*/
end_comment

begin_comment
comment|/*-----------------------------------------------------------*/
end_comment

end_unit

