begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-------------------------------------------------------------*/
end_comment

begin_comment
comment|/*--- Huffman coding low-level stuff                        ---*/
end_comment

begin_comment
comment|/*---                                             huffman.c ---*/
end_comment

begin_comment
comment|/*-------------------------------------------------------------*/
end_comment

begin_comment
comment|/* ------------------------------------------------------------------    This file is part of bzip2/libbzip2, a program and library for    lossless, block-sorting data compression.     bzip2/libbzip2 version 1.0.4 of 20 December 2006    Copyright (C) 1996-2006 Julian Seward<jseward@bzip.org>     Please read the WARNING, DISCLAIMER and PATENTS sections in the     README file.     This program is released under the terms of the license contained    in the file LICENSE.    ------------------------------------------------------------------ */
end_comment

begin_include
include|#
directive|include
file|"bzlib_private.h"
end_include

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_define
define|#
directive|define
name|WEIGHTOF
parameter_list|(
name|zz0
parameter_list|)
value|((zz0)& 0xffffff00)
end_define

begin_define
define|#
directive|define
name|DEPTHOF
parameter_list|(
name|zz1
parameter_list|)
value|((zz1)& 0x000000ff)
end_define

begin_define
define|#
directive|define
name|MYMAX
parameter_list|(
name|zz2
parameter_list|,
name|zz3
parameter_list|)
value|((zz2)> (zz3) ? (zz2) : (zz3))
end_define

begin_define
define|#
directive|define
name|ADDWEIGHTS
parameter_list|(
name|zw1
parameter_list|,
name|zw2
parameter_list|)
define|\
value|(WEIGHTOF(zw1)+WEIGHTOF(zw2)) |                    \    (1 + MYMAX(DEPTHOF(zw1),DEPTHOF(zw2)))
end_define

begin_define
define|#
directive|define
name|UPHEAP
parameter_list|(
name|z
parameter_list|)
define|\
value|{                                                     \    Int32 zz, tmp;                                     \    zz = z; tmp = heap[zz];                            \    while (weight[tmp]< weight[heap[zz>> 1]]) {      \       heap[zz] = heap[zz>> 1];                       \       zz>>= 1;                                       \    }                                                  \    heap[zz] = tmp;                                    \ }
end_define

begin_define
define|#
directive|define
name|DOWNHEAP
parameter_list|(
name|z
parameter_list|)
define|\
value|{                                                     \    Int32 zz, yy, tmp;                                 \    zz = z; tmp = heap[zz];                            \    while (True) {                                     \       yy = zz<< 1;                                   \       if (yy> nHeap) break;                          \       if (yy< nHeap&&                               \           weight[heap[yy+1]]< weight[heap[yy]])      \          yy++;                                        \       if (weight[tmp]< weight[heap[yy]]) break;      \       heap[zz] = heap[yy];                            \       zz = yy;                                        \    }                                                  \    heap[zz] = tmp;                                    \ }
end_define

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_function
name|void
name|BZ2_hbMakeCodeLengths
parameter_list|(
name|UChar
modifier|*
name|len
parameter_list|,
name|Int32
modifier|*
name|freq
parameter_list|,
name|Int32
name|alphaSize
parameter_list|,
name|Int32
name|maxLen
parameter_list|)
block|{
comment|/*--       Nodes and heap entries run from 1.  Entry 0       for both the heap and nodes is a sentinel.    --*/
name|Int32
name|nNodes
decl_stmt|,
name|nHeap
decl_stmt|,
name|n1
decl_stmt|,
name|n2
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|Bool
name|tooLong
decl_stmt|;
name|Int32
name|heap
index|[
name|BZ_MAX_ALPHA_SIZE
operator|+
literal|2
index|]
decl_stmt|;
name|Int32
name|weight
index|[
name|BZ_MAX_ALPHA_SIZE
operator|*
literal|2
index|]
decl_stmt|;
name|Int32
name|parent
index|[
name|BZ_MAX_ALPHA_SIZE
operator|*
literal|2
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alphaSize
condition|;
name|i
operator|++
control|)
name|weight
index|[
name|i
operator|+
literal|1
index|]
operator|=
operator|(
name|freq
index|[
name|i
index|]
operator|==
literal|0
condition|?
literal|1
else|:
name|freq
index|[
name|i
index|]
operator|)
operator|<<
literal|8
expr_stmt|;
while|while
condition|(
name|True
condition|)
block|{
name|nNodes
operator|=
name|alphaSize
expr_stmt|;
name|nHeap
operator|=
literal|0
expr_stmt|;
name|heap
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|weight
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|parent
index|[
literal|0
index|]
operator|=
operator|-
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|alphaSize
condition|;
name|i
operator|++
control|)
block|{
name|parent
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|nHeap
operator|++
expr_stmt|;
name|heap
index|[
name|nHeap
index|]
operator|=
name|i
expr_stmt|;
name|UPHEAP
argument_list|(
name|nHeap
argument_list|)
expr_stmt|;
block|}
name|AssertH
argument_list|(
name|nHeap
operator|<
operator|(
name|BZ_MAX_ALPHA_SIZE
operator|+
literal|2
operator|)
argument_list|,
literal|2001
argument_list|)
expr_stmt|;
while|while
condition|(
name|nHeap
operator|>
literal|1
condition|)
block|{
name|n1
operator|=
name|heap
index|[
literal|1
index|]
expr_stmt|;
name|heap
index|[
literal|1
index|]
operator|=
name|heap
index|[
name|nHeap
index|]
expr_stmt|;
name|nHeap
operator|--
expr_stmt|;
name|DOWNHEAP
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|n2
operator|=
name|heap
index|[
literal|1
index|]
expr_stmt|;
name|heap
index|[
literal|1
index|]
operator|=
name|heap
index|[
name|nHeap
index|]
expr_stmt|;
name|nHeap
operator|--
expr_stmt|;
name|DOWNHEAP
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|nNodes
operator|++
expr_stmt|;
name|parent
index|[
name|n1
index|]
operator|=
name|parent
index|[
name|n2
index|]
operator|=
name|nNodes
expr_stmt|;
name|weight
index|[
name|nNodes
index|]
operator|=
name|ADDWEIGHTS
argument_list|(
name|weight
index|[
name|n1
index|]
argument_list|,
name|weight
index|[
name|n2
index|]
argument_list|)
expr_stmt|;
name|parent
index|[
name|nNodes
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|nHeap
operator|++
expr_stmt|;
name|heap
index|[
name|nHeap
index|]
operator|=
name|nNodes
expr_stmt|;
name|UPHEAP
argument_list|(
name|nHeap
argument_list|)
expr_stmt|;
block|}
name|AssertH
argument_list|(
name|nNodes
operator|<
operator|(
name|BZ_MAX_ALPHA_SIZE
operator|*
literal|2
operator|)
argument_list|,
literal|2002
argument_list|)
expr_stmt|;
name|tooLong
operator|=
name|False
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|alphaSize
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
literal|0
expr_stmt|;
name|k
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|parent
index|[
name|k
index|]
operator|>=
literal|0
condition|)
block|{
name|k
operator|=
name|parent
index|[
name|k
index|]
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
name|len
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|j
operator|>
name|maxLen
condition|)
name|tooLong
operator|=
name|True
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tooLong
condition|)
break|break;
comment|/* 17 Oct 04: keep-going condition for the following loop used          to be 'i< alphaSize', which missed the last element,          theoretically leading to the possibility of the compressor          looping.  However, this count-scaling step is only needed if          one of the generated Huffman code words is longer than          maxLen, which up to and including version 1.0.2 was 20 bits,          which is extremely unlikely.  In version 1.0.3 maxLen was          changed to 17 bits, which has minimal effect on compression          ratio, but does mean this scaling step is used from time to          time, enough to verify that it works.           This means that bzip2-1.0.3 and later will only produce          Huffman codes with a maximum length of 17 bits.  However, in          order to preserve backwards compatibility with bitstreams          produced by versions pre-1.0.3, the decompressor must still          handle lengths of up to 20. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|alphaSize
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
name|weight
index|[
name|i
index|]
operator|>>
literal|8
expr_stmt|;
name|j
operator|=
literal|1
operator|+
operator|(
name|j
operator|/
literal|2
operator|)
expr_stmt|;
name|weight
index|[
name|i
index|]
operator|=
name|j
operator|<<
literal|8
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_function
name|void
name|BZ2_hbAssignCodes
parameter_list|(
name|Int32
modifier|*
name|code
parameter_list|,
name|UChar
modifier|*
name|length
parameter_list|,
name|Int32
name|minLen
parameter_list|,
name|Int32
name|maxLen
parameter_list|,
name|Int32
name|alphaSize
parameter_list|)
block|{
name|Int32
name|n
decl_stmt|,
name|vec
decl_stmt|,
name|i
decl_stmt|;
name|vec
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
name|minLen
init|;
name|n
operator|<=
name|maxLen
condition|;
name|n
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alphaSize
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|length
index|[
name|i
index|]
operator|==
name|n
condition|)
block|{
name|code
index|[
name|i
index|]
operator|=
name|vec
expr_stmt|;
name|vec
operator|++
expr_stmt|;
block|}
empty_stmt|;
name|vec
operator|<<=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_function
name|void
name|BZ2_hbCreateDecodeTables
parameter_list|(
name|Int32
modifier|*
name|limit
parameter_list|,
name|Int32
modifier|*
name|base
parameter_list|,
name|Int32
modifier|*
name|perm
parameter_list|,
name|UChar
modifier|*
name|length
parameter_list|,
name|Int32
name|minLen
parameter_list|,
name|Int32
name|maxLen
parameter_list|,
name|Int32
name|alphaSize
parameter_list|)
block|{
name|Int32
name|pp
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|vec
decl_stmt|;
name|pp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|minLen
init|;
name|i
operator|<=
name|maxLen
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|alphaSize
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|length
index|[
name|j
index|]
operator|==
name|i
condition|)
block|{
name|perm
index|[
name|pp
index|]
operator|=
name|j
expr_stmt|;
name|pp
operator|++
expr_stmt|;
block|}
empty_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BZ_MAX_CODE_LEN
condition|;
name|i
operator|++
control|)
name|base
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alphaSize
condition|;
name|i
operator|++
control|)
name|base
index|[
name|length
index|[
name|i
index|]
operator|+
literal|1
index|]
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|BZ_MAX_CODE_LEN
condition|;
name|i
operator|++
control|)
name|base
index|[
name|i
index|]
operator|+=
name|base
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BZ_MAX_CODE_LEN
condition|;
name|i
operator|++
control|)
name|limit
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|vec
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|minLen
init|;
name|i
operator|<=
name|maxLen
condition|;
name|i
operator|++
control|)
block|{
name|vec
operator|+=
operator|(
name|base
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|base
index|[
name|i
index|]
operator|)
expr_stmt|;
name|limit
index|[
name|i
index|]
operator|=
name|vec
operator|-
literal|1
expr_stmt|;
name|vec
operator|<<=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|minLen
operator|+
literal|1
init|;
name|i
operator|<=
name|maxLen
condition|;
name|i
operator|++
control|)
name|base
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|limit
index|[
name|i
operator|-
literal|1
index|]
operator|+
literal|1
operator|)
operator|<<
literal|1
operator|)
operator|-
name|base
index|[
name|i
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-------------------------------------------------------------*/
end_comment

begin_comment
comment|/*--- end                                         huffman.c ---*/
end_comment

begin_comment
comment|/*-------------------------------------------------------------*/
end_comment

end_unit

