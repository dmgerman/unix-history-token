begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-------------------------------------------------------------*/
end_comment

begin_comment
comment|/*--- Huffman coding low-level stuff                        ---*/
end_comment

begin_comment
comment|/*---                                             huffman.c ---*/
end_comment

begin_comment
comment|/*-------------------------------------------------------------*/
end_comment

begin_comment
comment|/*--   This file is a part of bzip2 and/or libbzip2, a program and   library for lossless, block-sorting data compression.    Copyright (C) 1996-2000 Julian R Seward.  All rights reserved.    Redistribution and use in source and binary forms, with or without   modification, are permitted provided that the following conditions   are met:    1. Redistributions of source code must retain the above copyright      notice, this list of conditions and the following disclaimer.    2. The origin of this software must not be misrepresented; you must       not claim that you wrote the original software.  If you use this       software in a product, an acknowledgment in the product       documentation would be appreciated but is not required.    3. Altered source versions must be plainly marked as such, and must      not be misrepresented as being the original software.    4. The name of the author may not be used to endorse or promote       products derived from this software without specific prior written       permission.    THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS   OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY   DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.    Julian Seward, Cambridge, UK.   jseward@acm.org   bzip2/libbzip2 version 1.0 of 21 March 2000    This program is based on (at least) the work of:      Mike Burrows      David Wheeler      Peter Fenwick      Alistair Moffat      Radford Neal      Ian H. Witten      Robert Sedgewick      Jon L. Bentley    For more information on these sources, see the manual. --*/
end_comment

begin_include
include|#
directive|include
file|"bzlib_private.h"
end_include

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_define
define|#
directive|define
name|WEIGHTOF
parameter_list|(
name|zz0
parameter_list|)
value|((zz0)& 0xffffff00)
end_define

begin_define
define|#
directive|define
name|DEPTHOF
parameter_list|(
name|zz1
parameter_list|)
value|((zz1)& 0x000000ff)
end_define

begin_define
define|#
directive|define
name|MYMAX
parameter_list|(
name|zz2
parameter_list|,
name|zz3
parameter_list|)
value|((zz2)> (zz3) ? (zz2) : (zz3))
end_define

begin_define
define|#
directive|define
name|ADDWEIGHTS
parameter_list|(
name|zw1
parameter_list|,
name|zw2
parameter_list|)
define|\
value|(WEIGHTOF(zw1)+WEIGHTOF(zw2)) |                    \    (1 + MYMAX(DEPTHOF(zw1),DEPTHOF(zw2)))
end_define

begin_define
define|#
directive|define
name|UPHEAP
parameter_list|(
name|z
parameter_list|)
define|\
value|{                                                     \    Int32 zz, tmp;                                     \    zz = z; tmp = heap[zz];                            \    while (weight[tmp]< weight[heap[zz>> 1]]) {      \       heap[zz] = heap[zz>> 1];                       \       zz>>= 1;                                       \    }                                                  \    heap[zz] = tmp;                                    \ }
end_define

begin_define
define|#
directive|define
name|DOWNHEAP
parameter_list|(
name|z
parameter_list|)
define|\
value|{                                                     \    Int32 zz, yy, tmp;                                 \    zz = z; tmp = heap[zz];                            \    while (True) {                                     \       yy = zz<< 1;                                   \       if (yy> nHeap) break;                          \       if (yy< nHeap&&                               \           weight[heap[yy+1]]< weight[heap[yy]])      \          yy++;                                        \       if (weight[tmp]< weight[heap[yy]]) break;      \       heap[zz] = heap[yy];                            \       zz = yy;                                        \    }                                                  \    heap[zz] = tmp;                                    \ }
end_define

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_function
name|void
name|BZ2_hbMakeCodeLengths
parameter_list|(
name|UChar
modifier|*
name|len
parameter_list|,
name|Int32
modifier|*
name|freq
parameter_list|,
name|Int32
name|alphaSize
parameter_list|,
name|Int32
name|maxLen
parameter_list|)
block|{
comment|/*--       Nodes and heap entries run from 1.  Entry 0       for both the heap and nodes is a sentinel.    --*/
name|Int32
name|nNodes
decl_stmt|,
name|nHeap
decl_stmt|,
name|n1
decl_stmt|,
name|n2
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|Bool
name|tooLong
decl_stmt|;
name|Int32
name|heap
index|[
name|BZ_MAX_ALPHA_SIZE
operator|+
literal|2
index|]
decl_stmt|;
name|Int32
name|weight
index|[
name|BZ_MAX_ALPHA_SIZE
operator|*
literal|2
index|]
decl_stmt|;
name|Int32
name|parent
index|[
name|BZ_MAX_ALPHA_SIZE
operator|*
literal|2
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alphaSize
condition|;
name|i
operator|++
control|)
name|weight
index|[
name|i
operator|+
literal|1
index|]
operator|=
operator|(
name|freq
index|[
name|i
index|]
operator|==
literal|0
condition|?
literal|1
else|:
name|freq
index|[
name|i
index|]
operator|)
operator|<<
literal|8
expr_stmt|;
while|while
condition|(
name|True
condition|)
block|{
name|nNodes
operator|=
name|alphaSize
expr_stmt|;
name|nHeap
operator|=
literal|0
expr_stmt|;
name|heap
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|weight
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|parent
index|[
literal|0
index|]
operator|=
operator|-
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|alphaSize
condition|;
name|i
operator|++
control|)
block|{
name|parent
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|nHeap
operator|++
expr_stmt|;
name|heap
index|[
name|nHeap
index|]
operator|=
name|i
expr_stmt|;
name|UPHEAP
argument_list|(
name|nHeap
argument_list|)
expr_stmt|;
block|}
name|AssertH
argument_list|(
name|nHeap
operator|<
operator|(
name|BZ_MAX_ALPHA_SIZE
operator|+
literal|2
operator|)
argument_list|,
literal|2001
argument_list|)
expr_stmt|;
while|while
condition|(
name|nHeap
operator|>
literal|1
condition|)
block|{
name|n1
operator|=
name|heap
index|[
literal|1
index|]
expr_stmt|;
name|heap
index|[
literal|1
index|]
operator|=
name|heap
index|[
name|nHeap
index|]
expr_stmt|;
name|nHeap
operator|--
expr_stmt|;
name|DOWNHEAP
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|n2
operator|=
name|heap
index|[
literal|1
index|]
expr_stmt|;
name|heap
index|[
literal|1
index|]
operator|=
name|heap
index|[
name|nHeap
index|]
expr_stmt|;
name|nHeap
operator|--
expr_stmt|;
name|DOWNHEAP
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|nNodes
operator|++
expr_stmt|;
name|parent
index|[
name|n1
index|]
operator|=
name|parent
index|[
name|n2
index|]
operator|=
name|nNodes
expr_stmt|;
name|weight
index|[
name|nNodes
index|]
operator|=
name|ADDWEIGHTS
argument_list|(
name|weight
index|[
name|n1
index|]
argument_list|,
name|weight
index|[
name|n2
index|]
argument_list|)
expr_stmt|;
name|parent
index|[
name|nNodes
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|nHeap
operator|++
expr_stmt|;
name|heap
index|[
name|nHeap
index|]
operator|=
name|nNodes
expr_stmt|;
name|UPHEAP
argument_list|(
name|nHeap
argument_list|)
expr_stmt|;
block|}
name|AssertH
argument_list|(
name|nNodes
operator|<
operator|(
name|BZ_MAX_ALPHA_SIZE
operator|*
literal|2
operator|)
argument_list|,
literal|2002
argument_list|)
expr_stmt|;
name|tooLong
operator|=
name|False
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|alphaSize
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
literal|0
expr_stmt|;
name|k
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|parent
index|[
name|k
index|]
operator|>=
literal|0
condition|)
block|{
name|k
operator|=
name|parent
index|[
name|k
index|]
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
name|len
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|j
operator|>
name|maxLen
condition|)
name|tooLong
operator|=
name|True
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tooLong
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|alphaSize
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
name|weight
index|[
name|i
index|]
operator|>>
literal|8
expr_stmt|;
name|j
operator|=
literal|1
operator|+
operator|(
name|j
operator|/
literal|2
operator|)
expr_stmt|;
name|weight
index|[
name|i
index|]
operator|=
name|j
operator|<<
literal|8
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_function
name|void
name|BZ2_hbAssignCodes
parameter_list|(
name|Int32
modifier|*
name|code
parameter_list|,
name|UChar
modifier|*
name|length
parameter_list|,
name|Int32
name|minLen
parameter_list|,
name|Int32
name|maxLen
parameter_list|,
name|Int32
name|alphaSize
parameter_list|)
block|{
name|Int32
name|n
decl_stmt|,
name|vec
decl_stmt|,
name|i
decl_stmt|;
name|vec
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
name|minLen
init|;
name|n
operator|<=
name|maxLen
condition|;
name|n
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alphaSize
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|length
index|[
name|i
index|]
operator|==
name|n
condition|)
block|{
name|code
index|[
name|i
index|]
operator|=
name|vec
expr_stmt|;
name|vec
operator|++
expr_stmt|;
block|}
empty_stmt|;
name|vec
operator|<<=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_function
name|void
name|BZ2_hbCreateDecodeTables
parameter_list|(
name|Int32
modifier|*
name|limit
parameter_list|,
name|Int32
modifier|*
name|base
parameter_list|,
name|Int32
modifier|*
name|perm
parameter_list|,
name|UChar
modifier|*
name|length
parameter_list|,
name|Int32
name|minLen
parameter_list|,
name|Int32
name|maxLen
parameter_list|,
name|Int32
name|alphaSize
parameter_list|)
block|{
name|Int32
name|pp
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|vec
decl_stmt|;
name|pp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|minLen
init|;
name|i
operator|<=
name|maxLen
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|alphaSize
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|length
index|[
name|j
index|]
operator|==
name|i
condition|)
block|{
name|perm
index|[
name|pp
index|]
operator|=
name|j
expr_stmt|;
name|pp
operator|++
expr_stmt|;
block|}
empty_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BZ_MAX_CODE_LEN
condition|;
name|i
operator|++
control|)
name|base
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alphaSize
condition|;
name|i
operator|++
control|)
name|base
index|[
name|length
index|[
name|i
index|]
operator|+
literal|1
index|]
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|BZ_MAX_CODE_LEN
condition|;
name|i
operator|++
control|)
name|base
index|[
name|i
index|]
operator|+=
name|base
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BZ_MAX_CODE_LEN
condition|;
name|i
operator|++
control|)
name|limit
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|vec
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|minLen
init|;
name|i
operator|<=
name|maxLen
condition|;
name|i
operator|++
control|)
block|{
name|vec
operator|+=
operator|(
name|base
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|base
index|[
name|i
index|]
operator|)
expr_stmt|;
name|limit
index|[
name|i
index|]
operator|=
name|vec
operator|-
literal|1
expr_stmt|;
name|vec
operator|<<=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|minLen
operator|+
literal|1
init|;
name|i
operator|<=
name|maxLen
condition|;
name|i
operator|++
control|)
name|base
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|limit
index|[
name|i
operator|-
literal|1
index|]
operator|+
literal|1
operator|)
operator|<<
literal|1
operator|)
operator|-
name|base
index|[
name|i
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-------------------------------------------------------------*/
end_comment

begin_comment
comment|/*--- end                                         huffman.c ---*/
end_comment

begin_comment
comment|/*-------------------------------------------------------------*/
end_comment

end_unit

