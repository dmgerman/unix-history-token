begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-------------------------------------------------------------*/
end_comment

begin_comment
comment|/*--- Block sorting machinery                               ---*/
end_comment

begin_comment
comment|/*---                                           blocksort.c ---*/
end_comment

begin_comment
comment|/*-------------------------------------------------------------*/
end_comment

begin_comment
comment|/* ------------------------------------------------------------------    This file is part of bzip2/libbzip2, a program and library for    lossless, block-sorting data compression.     bzip2/libbzip2 version 1.0.4 of 20 December 2006    Copyright (C) 1996-2006 Julian Seward<jseward@bzip.org>     Please read the WARNING, DISCLAIMER and PATENTS sections in the     README file.     This program is released under the terms of the license contained    in the file LICENSE.    ------------------------------------------------------------------ */
end_comment

begin_include
include|#
directive|include
file|"bzlib_private.h"
end_include

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_comment
comment|/*--- Fallback O(N log(N)^2) sorting        ---*/
end_comment

begin_comment
comment|/*--- algorithm, for repetitive blocks      ---*/
end_comment

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|__inline__
name|void
name|fallbackSimpleSort
parameter_list|(
name|UInt32
modifier|*
name|fmap
parameter_list|,
name|UInt32
modifier|*
name|eclass
parameter_list|,
name|Int32
name|lo
parameter_list|,
name|Int32
name|hi
parameter_list|)
block|{
name|Int32
name|i
decl_stmt|,
name|j
decl_stmt|,
name|tmp
decl_stmt|;
name|UInt32
name|ec_tmp
decl_stmt|;
if|if
condition|(
name|lo
operator|==
name|hi
condition|)
return|return;
if|if
condition|(
name|hi
operator|-
name|lo
operator|>
literal|3
condition|)
block|{
for|for
control|(
name|i
operator|=
name|hi
operator|-
literal|4
init|;
name|i
operator|>=
name|lo
condition|;
name|i
operator|--
control|)
block|{
name|tmp
operator|=
name|fmap
index|[
name|i
index|]
expr_stmt|;
name|ec_tmp
operator|=
name|eclass
index|[
name|tmp
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|4
init|;
name|j
operator|<=
name|hi
operator|&&
name|ec_tmp
operator|>
name|eclass
index|[
name|fmap
index|[
name|j
index|]
index|]
condition|;
name|j
operator|+=
literal|4
control|)
name|fmap
index|[
name|j
operator|-
literal|4
index|]
operator|=
name|fmap
index|[
name|j
index|]
expr_stmt|;
name|fmap
index|[
name|j
operator|-
literal|4
index|]
operator|=
name|tmp
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
name|hi
operator|-
literal|1
init|;
name|i
operator|>=
name|lo
condition|;
name|i
operator|--
control|)
block|{
name|tmp
operator|=
name|fmap
index|[
name|i
index|]
expr_stmt|;
name|ec_tmp
operator|=
name|eclass
index|[
name|tmp
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<=
name|hi
operator|&&
name|ec_tmp
operator|>
name|eclass
index|[
name|fmap
index|[
name|j
index|]
index|]
condition|;
name|j
operator|++
control|)
name|fmap
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|fmap
index|[
name|j
index|]
expr_stmt|;
name|fmap
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|tmp
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_define
define|#
directive|define
name|fswap
parameter_list|(
name|zz1
parameter_list|,
name|zz2
parameter_list|)
define|\
value|{ Int32 zztmp = zz1; zz1 = zz2; zz2 = zztmp; }
end_define

begin_define
define|#
directive|define
name|fvswap
parameter_list|(
name|zzp1
parameter_list|,
name|zzp2
parameter_list|,
name|zzn
parameter_list|)
define|\
value|{                                     \    Int32 yyp1 = (zzp1);               \    Int32 yyp2 = (zzp2);               \    Int32 yyn  = (zzn);                \    while (yyn> 0) {                  \       fswap(fmap[yyp1], fmap[yyp2]);  \       yyp1++; yyp2++; yyn--;          \    }                                  \ }
end_define

begin_define
define|#
directive|define
name|fmin
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b)) ? (a) : (b)
end_define

begin_define
define|#
directive|define
name|fpush
parameter_list|(
name|lz
parameter_list|,
name|hz
parameter_list|)
value|{ stackLo[sp] = lz; \                        stackHi[sp] = hz; \                        sp++; }
end_define

begin_define
define|#
directive|define
name|fpop
parameter_list|(
name|lz
parameter_list|,
name|hz
parameter_list|)
value|{ sp--;              \                       lz = stackLo[sp];  \                       hz = stackHi[sp]; }
end_define

begin_define
define|#
directive|define
name|FALLBACK_QSORT_SMALL_THRESH
value|10
end_define

begin_define
define|#
directive|define
name|FALLBACK_QSORT_STACK_SIZE
value|100
end_define

begin_function
specifier|static
name|void
name|fallbackQSort3
parameter_list|(
name|UInt32
modifier|*
name|fmap
parameter_list|,
name|UInt32
modifier|*
name|eclass
parameter_list|,
name|Int32
name|loSt
parameter_list|,
name|Int32
name|hiSt
parameter_list|)
block|{
name|Int32
name|unLo
decl_stmt|,
name|unHi
decl_stmt|,
name|ltLo
decl_stmt|,
name|gtHi
decl_stmt|,
name|n
decl_stmt|,
name|m
decl_stmt|;
name|Int32
name|sp
decl_stmt|,
name|lo
decl_stmt|,
name|hi
decl_stmt|;
name|UInt32
name|med
decl_stmt|,
name|r
decl_stmt|,
name|r3
decl_stmt|;
name|Int32
name|stackLo
index|[
name|FALLBACK_QSORT_STACK_SIZE
index|]
decl_stmt|;
name|Int32
name|stackHi
index|[
name|FALLBACK_QSORT_STACK_SIZE
index|]
decl_stmt|;
name|r
operator|=
literal|0
expr_stmt|;
name|sp
operator|=
literal|0
expr_stmt|;
name|fpush
argument_list|(
name|loSt
argument_list|,
name|hiSt
argument_list|)
expr_stmt|;
while|while
condition|(
name|sp
operator|>
literal|0
condition|)
block|{
name|AssertH
argument_list|(
name|sp
operator|<
name|FALLBACK_QSORT_STACK_SIZE
operator|-
literal|1
argument_list|,
literal|1004
argument_list|)
expr_stmt|;
name|fpop
argument_list|(
name|lo
argument_list|,
name|hi
argument_list|)
expr_stmt|;
if|if
condition|(
name|hi
operator|-
name|lo
operator|<
name|FALLBACK_QSORT_SMALL_THRESH
condition|)
block|{
name|fallbackSimpleSort
argument_list|(
name|fmap
argument_list|,
name|eclass
argument_list|,
name|lo
argument_list|,
name|hi
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Random partitioning.  Median of 3 sometimes fails to          avoid bad cases.  Median of 9 seems to help but           looks rather expensive.  This too seems to work but          is cheaper.  Guidance for the magic constants           7621 and 32768 is taken from Sedgewick's algorithms          book, chapter 35.       */
name|r
operator|=
operator|(
operator|(
name|r
operator|*
literal|7621
operator|)
operator|+
literal|1
operator|)
operator|%
literal|32768
expr_stmt|;
name|r3
operator|=
name|r
operator|%
literal|3
expr_stmt|;
if|if
condition|(
name|r3
operator|==
literal|0
condition|)
name|med
operator|=
name|eclass
index|[
name|fmap
index|[
name|lo
index|]
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|r3
operator|==
literal|1
condition|)
name|med
operator|=
name|eclass
index|[
name|fmap
index|[
operator|(
name|lo
operator|+
name|hi
operator|)
operator|>>
literal|1
index|]
index|]
expr_stmt|;
else|else
name|med
operator|=
name|eclass
index|[
name|fmap
index|[
name|hi
index|]
index|]
expr_stmt|;
name|unLo
operator|=
name|ltLo
operator|=
name|lo
expr_stmt|;
name|unHi
operator|=
name|gtHi
operator|=
name|hi
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|unLo
operator|>
name|unHi
condition|)
break|break;
name|n
operator|=
operator|(
name|Int32
operator|)
name|eclass
index|[
name|fmap
index|[
name|unLo
index|]
index|]
operator|-
operator|(
name|Int32
operator|)
name|med
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|fswap
argument_list|(
name|fmap
index|[
name|unLo
index|]
argument_list|,
name|fmap
index|[
name|ltLo
index|]
argument_list|)
expr_stmt|;
name|ltLo
operator|++
expr_stmt|;
name|unLo
operator|++
expr_stmt|;
continue|continue;
block|}
empty_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
break|break;
name|unLo
operator|++
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|unLo
operator|>
name|unHi
condition|)
break|break;
name|n
operator|=
operator|(
name|Int32
operator|)
name|eclass
index|[
name|fmap
index|[
name|unHi
index|]
index|]
operator|-
operator|(
name|Int32
operator|)
name|med
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|fswap
argument_list|(
name|fmap
index|[
name|unHi
index|]
argument_list|,
name|fmap
index|[
name|gtHi
index|]
argument_list|)
expr_stmt|;
name|gtHi
operator|--
expr_stmt|;
name|unHi
operator|--
expr_stmt|;
continue|continue;
block|}
empty_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
break|break;
name|unHi
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|unLo
operator|>
name|unHi
condition|)
break|break;
name|fswap
argument_list|(
name|fmap
index|[
name|unLo
index|]
argument_list|,
name|fmap
index|[
name|unHi
index|]
argument_list|)
expr_stmt|;
name|unLo
operator|++
expr_stmt|;
name|unHi
operator|--
expr_stmt|;
block|}
name|AssertD
argument_list|(
name|unHi
operator|==
name|unLo
operator|-
literal|1
argument_list|,
literal|"fallbackQSort3(2)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|gtHi
operator|<
name|ltLo
condition|)
continue|continue;
name|n
operator|=
name|fmin
argument_list|(
name|ltLo
operator|-
name|lo
argument_list|,
name|unLo
operator|-
name|ltLo
argument_list|)
expr_stmt|;
name|fvswap
argument_list|(
name|lo
argument_list|,
name|unLo
operator|-
name|n
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|m
operator|=
name|fmin
argument_list|(
name|hi
operator|-
name|gtHi
argument_list|,
name|gtHi
operator|-
name|unHi
argument_list|)
expr_stmt|;
name|fvswap
argument_list|(
name|unLo
argument_list|,
name|hi
operator|-
name|m
operator|+
literal|1
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|n
operator|=
name|lo
operator|+
name|unLo
operator|-
name|ltLo
operator|-
literal|1
expr_stmt|;
name|m
operator|=
name|hi
operator|-
operator|(
name|gtHi
operator|-
name|unHi
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|-
name|lo
operator|>
name|hi
operator|-
name|m
condition|)
block|{
name|fpush
argument_list|(
name|lo
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|fpush
argument_list|(
name|m
argument_list|,
name|hi
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fpush
argument_list|(
name|m
argument_list|,
name|hi
argument_list|)
expr_stmt|;
name|fpush
argument_list|(
name|lo
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_undef
undef|#
directive|undef
name|fmin
end_undef

begin_undef
undef|#
directive|undef
name|fpush
end_undef

begin_undef
undef|#
directive|undef
name|fpop
end_undef

begin_undef
undef|#
directive|undef
name|fswap
end_undef

begin_undef
undef|#
directive|undef
name|fvswap
end_undef

begin_undef
undef|#
directive|undef
name|FALLBACK_QSORT_SMALL_THRESH
end_undef

begin_undef
undef|#
directive|undef
name|FALLBACK_QSORT_STACK_SIZE
end_undef

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_comment
comment|/* Pre:       nblock> 0       eclass exists for [0 .. nblock-1]       ((UChar*)eclass) [0 .. nblock-1] holds block       ptr exists for [0 .. nblock-1]     Post:       ((UChar*)eclass) [0 .. nblock-1] holds block       All other areas of eclass destroyed       fmap [0 .. nblock-1] holds sorted order       bhtab [ 0 .. 2+(nblock/32) ] destroyed */
end_comment

begin_define
define|#
directive|define
name|SET_BH
parameter_list|(
name|zz
parameter_list|)
value|bhtab[(zz)>> 5] |= (1<< ((zz)& 31))
end_define

begin_define
define|#
directive|define
name|CLEAR_BH
parameter_list|(
name|zz
parameter_list|)
value|bhtab[(zz)>> 5]&= ~(1<< ((zz)& 31))
end_define

begin_define
define|#
directive|define
name|ISSET_BH
parameter_list|(
name|zz
parameter_list|)
value|(bhtab[(zz)>> 5]& (1<< ((zz)& 31)))
end_define

begin_define
define|#
directive|define
name|WORD_BH
parameter_list|(
name|zz
parameter_list|)
value|bhtab[(zz)>> 5]
end_define

begin_define
define|#
directive|define
name|UNALIGNED_BH
parameter_list|(
name|zz
parameter_list|)
value|((zz)& 0x01f)
end_define

begin_function
specifier|static
name|void
name|fallbackSort
parameter_list|(
name|UInt32
modifier|*
name|fmap
parameter_list|,
name|UInt32
modifier|*
name|eclass
parameter_list|,
name|UInt32
modifier|*
name|bhtab
parameter_list|,
name|Int32
name|nblock
parameter_list|,
name|Int32
name|verb
parameter_list|)
block|{
name|Int32
name|ftab
index|[
literal|257
index|]
decl_stmt|;
name|Int32
name|ftabCopy
index|[
literal|256
index|]
decl_stmt|;
name|Int32
name|H
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|l
decl_stmt|,
name|r
decl_stmt|,
name|cc
decl_stmt|,
name|cc1
decl_stmt|;
name|Int32
name|nNotDone
decl_stmt|;
name|Int32
name|nBhtab
decl_stmt|;
name|UChar
modifier|*
name|eclass8
init|=
operator|(
name|UChar
operator|*
operator|)
name|eclass
decl_stmt|;
comment|/*--       Initial 1-char radix sort to generate       initial fmap and initial BH bits.    --*/
if|if
condition|(
name|verb
operator|>=
literal|4
condition|)
name|VPrintf0
argument_list|(
literal|"        bucket sorting ...\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|257
condition|;
name|i
operator|++
control|)
name|ftab
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nblock
condition|;
name|i
operator|++
control|)
name|ftab
index|[
name|eclass8
index|[
name|i
index|]
index|]
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|ftabCopy
index|[
name|i
index|]
operator|=
name|ftab
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|257
condition|;
name|i
operator|++
control|)
name|ftab
index|[
name|i
index|]
operator|+=
name|ftab
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nblock
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
name|eclass8
index|[
name|i
index|]
expr_stmt|;
name|k
operator|=
name|ftab
index|[
name|j
index|]
operator|-
literal|1
expr_stmt|;
name|ftab
index|[
name|j
index|]
operator|=
name|k
expr_stmt|;
name|fmap
index|[
name|k
index|]
operator|=
name|i
expr_stmt|;
block|}
name|nBhtab
operator|=
literal|2
operator|+
operator|(
name|nblock
operator|/
literal|32
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nBhtab
condition|;
name|i
operator|++
control|)
name|bhtab
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|SET_BH
argument_list|(
name|ftab
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/*--       Inductively refine the buckets.  Kind-of an       "exponential radix sort" (!), inspired by the       Manber-Myers suffix array construction algorithm.    --*/
comment|/*-- set sentinel bits for block-end detection --*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|SET_BH
argument_list|(
name|nblock
operator|+
literal|2
operator|*
name|i
argument_list|)
expr_stmt|;
name|CLEAR_BH
argument_list|(
name|nblock
operator|+
literal|2
operator|*
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*-- the log(N) loop --*/
name|H
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|verb
operator|>=
literal|4
condition|)
name|VPrintf1
argument_list|(
literal|"        depth %6d has "
argument_list|,
name|H
argument_list|)
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nblock
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ISSET_BH
argument_list|(
name|i
argument_list|)
condition|)
name|j
operator|=
name|i
expr_stmt|;
name|k
operator|=
name|fmap
index|[
name|i
index|]
operator|-
name|H
expr_stmt|;
if|if
condition|(
name|k
operator|<
literal|0
condition|)
name|k
operator|+=
name|nblock
expr_stmt|;
name|eclass
index|[
name|k
index|]
operator|=
name|j
expr_stmt|;
block|}
name|nNotDone
operator|=
literal|0
expr_stmt|;
name|r
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/*-- find the next non-singleton bucket --*/
name|k
operator|=
name|r
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|ISSET_BH
argument_list|(
name|k
argument_list|)
operator|&&
name|UNALIGNED_BH
argument_list|(
name|k
argument_list|)
condition|)
name|k
operator|++
expr_stmt|;
if|if
condition|(
name|ISSET_BH
argument_list|(
name|k
argument_list|)
condition|)
block|{
while|while
condition|(
name|WORD_BH
argument_list|(
name|k
argument_list|)
operator|==
literal|0xffffffff
condition|)
name|k
operator|+=
literal|32
expr_stmt|;
while|while
condition|(
name|ISSET_BH
argument_list|(
name|k
argument_list|)
condition|)
name|k
operator|++
expr_stmt|;
block|}
name|l
operator|=
name|k
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|l
operator|>=
name|nblock
condition|)
break|break;
while|while
condition|(
operator|!
name|ISSET_BH
argument_list|(
name|k
argument_list|)
operator|&&
name|UNALIGNED_BH
argument_list|(
name|k
argument_list|)
condition|)
name|k
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ISSET_BH
argument_list|(
name|k
argument_list|)
condition|)
block|{
while|while
condition|(
name|WORD_BH
argument_list|(
name|k
argument_list|)
operator|==
literal|0x00000000
condition|)
name|k
operator|+=
literal|32
expr_stmt|;
while|while
condition|(
operator|!
name|ISSET_BH
argument_list|(
name|k
argument_list|)
condition|)
name|k
operator|++
expr_stmt|;
block|}
name|r
operator|=
name|k
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|r
operator|>=
name|nblock
condition|)
break|break;
comment|/*-- now [l, r] bracket current bucket --*/
if|if
condition|(
name|r
operator|>
name|l
condition|)
block|{
name|nNotDone
operator|+=
operator|(
name|r
operator|-
name|l
operator|+
literal|1
operator|)
expr_stmt|;
name|fallbackQSort3
argument_list|(
name|fmap
argument_list|,
name|eclass
argument_list|,
name|l
argument_list|,
name|r
argument_list|)
expr_stmt|;
comment|/*-- scan bucket and generate header bits-- */
name|cc
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|l
init|;
name|i
operator|<=
name|r
condition|;
name|i
operator|++
control|)
block|{
name|cc1
operator|=
name|eclass
index|[
name|fmap
index|[
name|i
index|]
index|]
expr_stmt|;
if|if
condition|(
name|cc
operator|!=
name|cc1
condition|)
block|{
name|SET_BH
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|cc
operator|=
name|cc1
expr_stmt|;
block|}
empty_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|verb
operator|>=
literal|4
condition|)
name|VPrintf1
argument_list|(
literal|"%6d unresolved strings\n"
argument_list|,
name|nNotDone
argument_list|)
expr_stmt|;
name|H
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|H
operator|>
name|nblock
operator|||
name|nNotDone
operator|==
literal|0
condition|)
break|break;
block|}
comment|/*--        Reconstruct the original block in       eclass8 [0 .. nblock-1], since the       previous phase destroyed it.    --*/
if|if
condition|(
name|verb
operator|>=
literal|4
condition|)
name|VPrintf0
argument_list|(
literal|"        reconstructing block ...\n"
argument_list|)
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nblock
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
name|ftabCopy
index|[
name|j
index|]
operator|==
literal|0
condition|)
name|j
operator|++
expr_stmt|;
name|ftabCopy
index|[
name|j
index|]
operator|--
expr_stmt|;
name|eclass8
index|[
name|fmap
index|[
name|i
index|]
index|]
operator|=
operator|(
name|UChar
operator|)
name|j
expr_stmt|;
block|}
name|AssertH
argument_list|(
name|j
operator|<
literal|256
argument_list|,
literal|1005
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|SET_BH
end_undef

begin_undef
undef|#
directive|undef
name|CLEAR_BH
end_undef

begin_undef
undef|#
directive|undef
name|ISSET_BH
end_undef

begin_undef
undef|#
directive|undef
name|WORD_BH
end_undef

begin_undef
undef|#
directive|undef
name|UNALIGNED_BH
end_undef

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_comment
comment|/*--- The main, O(N^2 log(N)) sorting       ---*/
end_comment

begin_comment
comment|/*--- algorithm.  Faster for "normal"       ---*/
end_comment

begin_comment
comment|/*--- non-repetitive blocks.                ---*/
end_comment

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|__inline__
name|Bool
name|mainGtU
parameter_list|(
name|UInt32
name|i1
parameter_list|,
name|UInt32
name|i2
parameter_list|,
name|UChar
modifier|*
name|block
parameter_list|,
name|UInt16
modifier|*
name|quadrant
parameter_list|,
name|UInt32
name|nblock
parameter_list|,
name|Int32
modifier|*
name|budget
parameter_list|)
block|{
name|Int32
name|k
decl_stmt|;
name|UChar
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|UInt16
name|s1
decl_stmt|,
name|s2
decl_stmt|;
name|AssertD
argument_list|(
name|i1
operator|!=
name|i2
argument_list|,
literal|"mainGtU"
argument_list|)
expr_stmt|;
comment|/* 1 */
name|c1
operator|=
name|block
index|[
name|i1
index|]
expr_stmt|;
name|c2
operator|=
name|block
index|[
name|i2
index|]
expr_stmt|;
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
return|return
operator|(
name|c1
operator|>
name|c2
operator|)
return|;
name|i1
operator|++
expr_stmt|;
name|i2
operator|++
expr_stmt|;
comment|/* 2 */
name|c1
operator|=
name|block
index|[
name|i1
index|]
expr_stmt|;
name|c2
operator|=
name|block
index|[
name|i2
index|]
expr_stmt|;
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
return|return
operator|(
name|c1
operator|>
name|c2
operator|)
return|;
name|i1
operator|++
expr_stmt|;
name|i2
operator|++
expr_stmt|;
comment|/* 3 */
name|c1
operator|=
name|block
index|[
name|i1
index|]
expr_stmt|;
name|c2
operator|=
name|block
index|[
name|i2
index|]
expr_stmt|;
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
return|return
operator|(
name|c1
operator|>
name|c2
operator|)
return|;
name|i1
operator|++
expr_stmt|;
name|i2
operator|++
expr_stmt|;
comment|/* 4 */
name|c1
operator|=
name|block
index|[
name|i1
index|]
expr_stmt|;
name|c2
operator|=
name|block
index|[
name|i2
index|]
expr_stmt|;
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
return|return
operator|(
name|c1
operator|>
name|c2
operator|)
return|;
name|i1
operator|++
expr_stmt|;
name|i2
operator|++
expr_stmt|;
comment|/* 5 */
name|c1
operator|=
name|block
index|[
name|i1
index|]
expr_stmt|;
name|c2
operator|=
name|block
index|[
name|i2
index|]
expr_stmt|;
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
return|return
operator|(
name|c1
operator|>
name|c2
operator|)
return|;
name|i1
operator|++
expr_stmt|;
name|i2
operator|++
expr_stmt|;
comment|/* 6 */
name|c1
operator|=
name|block
index|[
name|i1
index|]
expr_stmt|;
name|c2
operator|=
name|block
index|[
name|i2
index|]
expr_stmt|;
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
return|return
operator|(
name|c1
operator|>
name|c2
operator|)
return|;
name|i1
operator|++
expr_stmt|;
name|i2
operator|++
expr_stmt|;
comment|/* 7 */
name|c1
operator|=
name|block
index|[
name|i1
index|]
expr_stmt|;
name|c2
operator|=
name|block
index|[
name|i2
index|]
expr_stmt|;
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
return|return
operator|(
name|c1
operator|>
name|c2
operator|)
return|;
name|i1
operator|++
expr_stmt|;
name|i2
operator|++
expr_stmt|;
comment|/* 8 */
name|c1
operator|=
name|block
index|[
name|i1
index|]
expr_stmt|;
name|c2
operator|=
name|block
index|[
name|i2
index|]
expr_stmt|;
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
return|return
operator|(
name|c1
operator|>
name|c2
operator|)
return|;
name|i1
operator|++
expr_stmt|;
name|i2
operator|++
expr_stmt|;
comment|/* 9 */
name|c1
operator|=
name|block
index|[
name|i1
index|]
expr_stmt|;
name|c2
operator|=
name|block
index|[
name|i2
index|]
expr_stmt|;
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
return|return
operator|(
name|c1
operator|>
name|c2
operator|)
return|;
name|i1
operator|++
expr_stmt|;
name|i2
operator|++
expr_stmt|;
comment|/* 10 */
name|c1
operator|=
name|block
index|[
name|i1
index|]
expr_stmt|;
name|c2
operator|=
name|block
index|[
name|i2
index|]
expr_stmt|;
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
return|return
operator|(
name|c1
operator|>
name|c2
operator|)
return|;
name|i1
operator|++
expr_stmt|;
name|i2
operator|++
expr_stmt|;
comment|/* 11 */
name|c1
operator|=
name|block
index|[
name|i1
index|]
expr_stmt|;
name|c2
operator|=
name|block
index|[
name|i2
index|]
expr_stmt|;
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
return|return
operator|(
name|c1
operator|>
name|c2
operator|)
return|;
name|i1
operator|++
expr_stmt|;
name|i2
operator|++
expr_stmt|;
comment|/* 12 */
name|c1
operator|=
name|block
index|[
name|i1
index|]
expr_stmt|;
name|c2
operator|=
name|block
index|[
name|i2
index|]
expr_stmt|;
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
return|return
operator|(
name|c1
operator|>
name|c2
operator|)
return|;
name|i1
operator|++
expr_stmt|;
name|i2
operator|++
expr_stmt|;
name|k
operator|=
name|nblock
operator|+
literal|8
expr_stmt|;
do|do
block|{
comment|/* 1 */
name|c1
operator|=
name|block
index|[
name|i1
index|]
expr_stmt|;
name|c2
operator|=
name|block
index|[
name|i2
index|]
expr_stmt|;
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
return|return
operator|(
name|c1
operator|>
name|c2
operator|)
return|;
name|s1
operator|=
name|quadrant
index|[
name|i1
index|]
expr_stmt|;
name|s2
operator|=
name|quadrant
index|[
name|i2
index|]
expr_stmt|;
if|if
condition|(
name|s1
operator|!=
name|s2
condition|)
return|return
operator|(
name|s1
operator|>
name|s2
operator|)
return|;
name|i1
operator|++
expr_stmt|;
name|i2
operator|++
expr_stmt|;
comment|/* 2 */
name|c1
operator|=
name|block
index|[
name|i1
index|]
expr_stmt|;
name|c2
operator|=
name|block
index|[
name|i2
index|]
expr_stmt|;
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
return|return
operator|(
name|c1
operator|>
name|c2
operator|)
return|;
name|s1
operator|=
name|quadrant
index|[
name|i1
index|]
expr_stmt|;
name|s2
operator|=
name|quadrant
index|[
name|i2
index|]
expr_stmt|;
if|if
condition|(
name|s1
operator|!=
name|s2
condition|)
return|return
operator|(
name|s1
operator|>
name|s2
operator|)
return|;
name|i1
operator|++
expr_stmt|;
name|i2
operator|++
expr_stmt|;
comment|/* 3 */
name|c1
operator|=
name|block
index|[
name|i1
index|]
expr_stmt|;
name|c2
operator|=
name|block
index|[
name|i2
index|]
expr_stmt|;
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
return|return
operator|(
name|c1
operator|>
name|c2
operator|)
return|;
name|s1
operator|=
name|quadrant
index|[
name|i1
index|]
expr_stmt|;
name|s2
operator|=
name|quadrant
index|[
name|i2
index|]
expr_stmt|;
if|if
condition|(
name|s1
operator|!=
name|s2
condition|)
return|return
operator|(
name|s1
operator|>
name|s2
operator|)
return|;
name|i1
operator|++
expr_stmt|;
name|i2
operator|++
expr_stmt|;
comment|/* 4 */
name|c1
operator|=
name|block
index|[
name|i1
index|]
expr_stmt|;
name|c2
operator|=
name|block
index|[
name|i2
index|]
expr_stmt|;
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
return|return
operator|(
name|c1
operator|>
name|c2
operator|)
return|;
name|s1
operator|=
name|quadrant
index|[
name|i1
index|]
expr_stmt|;
name|s2
operator|=
name|quadrant
index|[
name|i2
index|]
expr_stmt|;
if|if
condition|(
name|s1
operator|!=
name|s2
condition|)
return|return
operator|(
name|s1
operator|>
name|s2
operator|)
return|;
name|i1
operator|++
expr_stmt|;
name|i2
operator|++
expr_stmt|;
comment|/* 5 */
name|c1
operator|=
name|block
index|[
name|i1
index|]
expr_stmt|;
name|c2
operator|=
name|block
index|[
name|i2
index|]
expr_stmt|;
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
return|return
operator|(
name|c1
operator|>
name|c2
operator|)
return|;
name|s1
operator|=
name|quadrant
index|[
name|i1
index|]
expr_stmt|;
name|s2
operator|=
name|quadrant
index|[
name|i2
index|]
expr_stmt|;
if|if
condition|(
name|s1
operator|!=
name|s2
condition|)
return|return
operator|(
name|s1
operator|>
name|s2
operator|)
return|;
name|i1
operator|++
expr_stmt|;
name|i2
operator|++
expr_stmt|;
comment|/* 6 */
name|c1
operator|=
name|block
index|[
name|i1
index|]
expr_stmt|;
name|c2
operator|=
name|block
index|[
name|i2
index|]
expr_stmt|;
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
return|return
operator|(
name|c1
operator|>
name|c2
operator|)
return|;
name|s1
operator|=
name|quadrant
index|[
name|i1
index|]
expr_stmt|;
name|s2
operator|=
name|quadrant
index|[
name|i2
index|]
expr_stmt|;
if|if
condition|(
name|s1
operator|!=
name|s2
condition|)
return|return
operator|(
name|s1
operator|>
name|s2
operator|)
return|;
name|i1
operator|++
expr_stmt|;
name|i2
operator|++
expr_stmt|;
comment|/* 7 */
name|c1
operator|=
name|block
index|[
name|i1
index|]
expr_stmt|;
name|c2
operator|=
name|block
index|[
name|i2
index|]
expr_stmt|;
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
return|return
operator|(
name|c1
operator|>
name|c2
operator|)
return|;
name|s1
operator|=
name|quadrant
index|[
name|i1
index|]
expr_stmt|;
name|s2
operator|=
name|quadrant
index|[
name|i2
index|]
expr_stmt|;
if|if
condition|(
name|s1
operator|!=
name|s2
condition|)
return|return
operator|(
name|s1
operator|>
name|s2
operator|)
return|;
name|i1
operator|++
expr_stmt|;
name|i2
operator|++
expr_stmt|;
comment|/* 8 */
name|c1
operator|=
name|block
index|[
name|i1
index|]
expr_stmt|;
name|c2
operator|=
name|block
index|[
name|i2
index|]
expr_stmt|;
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
return|return
operator|(
name|c1
operator|>
name|c2
operator|)
return|;
name|s1
operator|=
name|quadrant
index|[
name|i1
index|]
expr_stmt|;
name|s2
operator|=
name|quadrant
index|[
name|i2
index|]
expr_stmt|;
if|if
condition|(
name|s1
operator|!=
name|s2
condition|)
return|return
operator|(
name|s1
operator|>
name|s2
operator|)
return|;
name|i1
operator|++
expr_stmt|;
name|i2
operator|++
expr_stmt|;
if|if
condition|(
name|i1
operator|>=
name|nblock
condition|)
name|i1
operator|-=
name|nblock
expr_stmt|;
if|if
condition|(
name|i2
operator|>=
name|nblock
condition|)
name|i2
operator|-=
name|nblock
expr_stmt|;
name|k
operator|-=
literal|8
expr_stmt|;
operator|(
operator|*
name|budget
operator|)
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|k
operator|>=
literal|0
condition|)
do|;
return|return
name|False
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_comment
comment|/*--    Knuth's increments seem to work better    than Incerpi-Sedgewick here.  Possibly    because the number of elems to sort is    usually small, typically<= 20. --*/
end_comment

begin_decl_stmt
specifier|static
name|Int32
name|incs
index|[
literal|14
index|]
init|=
block|{
literal|1
block|,
literal|4
block|,
literal|13
block|,
literal|40
block|,
literal|121
block|,
literal|364
block|,
literal|1093
block|,
literal|3280
block|,
literal|9841
block|,
literal|29524
block|,
literal|88573
block|,
literal|265720
block|,
literal|797161
block|,
literal|2391484
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|mainSimpleSort
parameter_list|(
name|UInt32
modifier|*
name|ptr
parameter_list|,
name|UChar
modifier|*
name|block
parameter_list|,
name|UInt16
modifier|*
name|quadrant
parameter_list|,
name|Int32
name|nblock
parameter_list|,
name|Int32
name|lo
parameter_list|,
name|Int32
name|hi
parameter_list|,
name|Int32
name|d
parameter_list|,
name|Int32
modifier|*
name|budget
parameter_list|)
block|{
name|Int32
name|i
decl_stmt|,
name|j
decl_stmt|,
name|h
decl_stmt|,
name|bigN
decl_stmt|,
name|hp
decl_stmt|;
name|UInt32
name|v
decl_stmt|;
name|bigN
operator|=
name|hi
operator|-
name|lo
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|bigN
operator|<
literal|2
condition|)
return|return;
name|hp
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|incs
index|[
name|hp
index|]
operator|<
name|bigN
condition|)
name|hp
operator|++
expr_stmt|;
name|hp
operator|--
expr_stmt|;
for|for
control|(
init|;
name|hp
operator|>=
literal|0
condition|;
name|hp
operator|--
control|)
block|{
name|h
operator|=
name|incs
index|[
name|hp
index|]
expr_stmt|;
name|i
operator|=
name|lo
operator|+
name|h
expr_stmt|;
while|while
condition|(
name|True
condition|)
block|{
comment|/*-- copy 1 --*/
if|if
condition|(
name|i
operator|>
name|hi
condition|)
break|break;
name|v
operator|=
name|ptr
index|[
name|i
index|]
expr_stmt|;
name|j
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|mainGtU
argument_list|(
name|ptr
index|[
name|j
operator|-
name|h
index|]
operator|+
name|d
argument_list|,
name|v
operator|+
name|d
argument_list|,
name|block
argument_list|,
name|quadrant
argument_list|,
name|nblock
argument_list|,
name|budget
argument_list|)
condition|)
block|{
name|ptr
index|[
name|j
index|]
operator|=
name|ptr
index|[
name|j
operator|-
name|h
index|]
expr_stmt|;
name|j
operator|=
name|j
operator|-
name|h
expr_stmt|;
if|if
condition|(
name|j
operator|<=
operator|(
name|lo
operator|+
name|h
operator|-
literal|1
operator|)
condition|)
break|break;
block|}
name|ptr
index|[
name|j
index|]
operator|=
name|v
expr_stmt|;
name|i
operator|++
expr_stmt|;
comment|/*-- copy 2 --*/
if|if
condition|(
name|i
operator|>
name|hi
condition|)
break|break;
name|v
operator|=
name|ptr
index|[
name|i
index|]
expr_stmt|;
name|j
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|mainGtU
argument_list|(
name|ptr
index|[
name|j
operator|-
name|h
index|]
operator|+
name|d
argument_list|,
name|v
operator|+
name|d
argument_list|,
name|block
argument_list|,
name|quadrant
argument_list|,
name|nblock
argument_list|,
name|budget
argument_list|)
condition|)
block|{
name|ptr
index|[
name|j
index|]
operator|=
name|ptr
index|[
name|j
operator|-
name|h
index|]
expr_stmt|;
name|j
operator|=
name|j
operator|-
name|h
expr_stmt|;
if|if
condition|(
name|j
operator|<=
operator|(
name|lo
operator|+
name|h
operator|-
literal|1
operator|)
condition|)
break|break;
block|}
name|ptr
index|[
name|j
index|]
operator|=
name|v
expr_stmt|;
name|i
operator|++
expr_stmt|;
comment|/*-- copy 3 --*/
if|if
condition|(
name|i
operator|>
name|hi
condition|)
break|break;
name|v
operator|=
name|ptr
index|[
name|i
index|]
expr_stmt|;
name|j
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|mainGtU
argument_list|(
name|ptr
index|[
name|j
operator|-
name|h
index|]
operator|+
name|d
argument_list|,
name|v
operator|+
name|d
argument_list|,
name|block
argument_list|,
name|quadrant
argument_list|,
name|nblock
argument_list|,
name|budget
argument_list|)
condition|)
block|{
name|ptr
index|[
name|j
index|]
operator|=
name|ptr
index|[
name|j
operator|-
name|h
index|]
expr_stmt|;
name|j
operator|=
name|j
operator|-
name|h
expr_stmt|;
if|if
condition|(
name|j
operator|<=
operator|(
name|lo
operator|+
name|h
operator|-
literal|1
operator|)
condition|)
break|break;
block|}
name|ptr
index|[
name|j
index|]
operator|=
name|v
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|budget
operator|<
literal|0
condition|)
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_comment
comment|/*--    The following is an implementation of    an elegant 3-way quicksort for strings,    described in a paper "Fast Algorithms for    Sorting and Searching Strings", by Robert    Sedgewick and Jon L. Bentley. --*/
end_comment

begin_define
define|#
directive|define
name|mswap
parameter_list|(
name|zz1
parameter_list|,
name|zz2
parameter_list|)
define|\
value|{ Int32 zztmp = zz1; zz1 = zz2; zz2 = zztmp; }
end_define

begin_define
define|#
directive|define
name|mvswap
parameter_list|(
name|zzp1
parameter_list|,
name|zzp2
parameter_list|,
name|zzn
parameter_list|)
define|\
value|{                                     \    Int32 yyp1 = (zzp1);               \    Int32 yyp2 = (zzp2);               \    Int32 yyn  = (zzn);                \    while (yyn> 0) {                  \       mswap(ptr[yyp1], ptr[yyp2]);    \       yyp1++; yyp2++; yyn--;          \    }                                  \ }
end_define

begin_function
specifier|static
name|__inline__
name|UChar
name|mmed3
parameter_list|(
name|UChar
name|a
parameter_list|,
name|UChar
name|b
parameter_list|,
name|UChar
name|c
parameter_list|)
block|{
name|UChar
name|t
decl_stmt|;
if|if
condition|(
name|a
operator|>
name|b
condition|)
block|{
name|t
operator|=
name|a
expr_stmt|;
name|a
operator|=
name|b
expr_stmt|;
name|b
operator|=
name|t
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|b
operator|>
name|c
condition|)
block|{
name|b
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|a
operator|>
name|b
condition|)
name|b
operator|=
name|a
expr_stmt|;
block|}
return|return
name|b
return|;
block|}
end_function

begin_define
define|#
directive|define
name|mmin
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b)) ? (a) : (b)
end_define

begin_define
define|#
directive|define
name|mpush
parameter_list|(
name|lz
parameter_list|,
name|hz
parameter_list|,
name|dz
parameter_list|)
value|{ stackLo[sp] = lz; \                           stackHi[sp] = hz; \                           stackD [sp] = dz; \                           sp++; }
end_define

begin_define
define|#
directive|define
name|mpop
parameter_list|(
name|lz
parameter_list|,
name|hz
parameter_list|,
name|dz
parameter_list|)
value|{ sp--;             \                          lz = stackLo[sp]; \                          hz = stackHi[sp]; \                          dz = stackD [sp]; }
end_define

begin_define
define|#
directive|define
name|mnextsize
parameter_list|(
name|az
parameter_list|)
value|(nextHi[az]-nextLo[az])
end_define

begin_define
define|#
directive|define
name|mnextswap
parameter_list|(
name|az
parameter_list|,
name|bz
parameter_list|)
define|\
value|{ Int32 tz;                                                  \      tz = nextLo[az]; nextLo[az] = nextLo[bz]; nextLo[bz] = tz; \      tz = nextHi[az]; nextHi[az] = nextHi[bz]; nextHi[bz] = tz; \      tz = nextD [az]; nextD [az] = nextD [bz]; nextD [bz] = tz; }
end_define

begin_define
define|#
directive|define
name|MAIN_QSORT_SMALL_THRESH
value|20
end_define

begin_define
define|#
directive|define
name|MAIN_QSORT_DEPTH_THRESH
value|(BZ_N_RADIX + BZ_N_QSORT)
end_define

begin_define
define|#
directive|define
name|MAIN_QSORT_STACK_SIZE
value|100
end_define

begin_function
specifier|static
name|void
name|mainQSort3
parameter_list|(
name|UInt32
modifier|*
name|ptr
parameter_list|,
name|UChar
modifier|*
name|block
parameter_list|,
name|UInt16
modifier|*
name|quadrant
parameter_list|,
name|Int32
name|nblock
parameter_list|,
name|Int32
name|loSt
parameter_list|,
name|Int32
name|hiSt
parameter_list|,
name|Int32
name|dSt
parameter_list|,
name|Int32
modifier|*
name|budget
parameter_list|)
block|{
name|Int32
name|unLo
decl_stmt|,
name|unHi
decl_stmt|,
name|ltLo
decl_stmt|,
name|gtHi
decl_stmt|,
name|n
decl_stmt|,
name|m
decl_stmt|,
name|med
decl_stmt|;
name|Int32
name|sp
decl_stmt|,
name|lo
decl_stmt|,
name|hi
decl_stmt|,
name|d
decl_stmt|;
name|Int32
name|stackLo
index|[
name|MAIN_QSORT_STACK_SIZE
index|]
decl_stmt|;
name|Int32
name|stackHi
index|[
name|MAIN_QSORT_STACK_SIZE
index|]
decl_stmt|;
name|Int32
name|stackD
index|[
name|MAIN_QSORT_STACK_SIZE
index|]
decl_stmt|;
name|Int32
name|nextLo
index|[
literal|3
index|]
decl_stmt|;
name|Int32
name|nextHi
index|[
literal|3
index|]
decl_stmt|;
name|Int32
name|nextD
index|[
literal|3
index|]
decl_stmt|;
name|sp
operator|=
literal|0
expr_stmt|;
name|mpush
argument_list|(
name|loSt
argument_list|,
name|hiSt
argument_list|,
name|dSt
argument_list|)
expr_stmt|;
while|while
condition|(
name|sp
operator|>
literal|0
condition|)
block|{
name|AssertH
argument_list|(
name|sp
operator|<
name|MAIN_QSORT_STACK_SIZE
operator|-
literal|2
argument_list|,
literal|1001
argument_list|)
expr_stmt|;
name|mpop
argument_list|(
name|lo
argument_list|,
name|hi
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|hi
operator|-
name|lo
operator|<
name|MAIN_QSORT_SMALL_THRESH
operator|||
name|d
operator|>
name|MAIN_QSORT_DEPTH_THRESH
condition|)
block|{
name|mainSimpleSort
argument_list|(
name|ptr
argument_list|,
name|block
argument_list|,
name|quadrant
argument_list|,
name|nblock
argument_list|,
name|lo
argument_list|,
name|hi
argument_list|,
name|d
argument_list|,
name|budget
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|budget
operator|<
literal|0
condition|)
return|return;
continue|continue;
block|}
name|med
operator|=
operator|(
name|Int32
operator|)
name|mmed3
argument_list|(
name|block
index|[
name|ptr
index|[
name|lo
index|]
operator|+
name|d
index|]
argument_list|,
name|block
index|[
name|ptr
index|[
name|hi
index|]
operator|+
name|d
index|]
argument_list|,
name|block
index|[
name|ptr
index|[
operator|(
name|lo
operator|+
name|hi
operator|)
operator|>>
literal|1
index|]
operator|+
name|d
index|]
argument_list|)
expr_stmt|;
name|unLo
operator|=
name|ltLo
operator|=
name|lo
expr_stmt|;
name|unHi
operator|=
name|gtHi
operator|=
name|hi
expr_stmt|;
while|while
condition|(
name|True
condition|)
block|{
while|while
condition|(
name|True
condition|)
block|{
if|if
condition|(
name|unLo
operator|>
name|unHi
condition|)
break|break;
name|n
operator|=
operator|(
operator|(
name|Int32
operator|)
name|block
index|[
name|ptr
index|[
name|unLo
index|]
operator|+
name|d
index|]
operator|)
operator|-
name|med
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|mswap
argument_list|(
name|ptr
index|[
name|unLo
index|]
argument_list|,
name|ptr
index|[
name|ltLo
index|]
argument_list|)
expr_stmt|;
name|ltLo
operator|++
expr_stmt|;
name|unLo
operator|++
expr_stmt|;
continue|continue;
block|}
empty_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
break|break;
name|unLo
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|True
condition|)
block|{
if|if
condition|(
name|unLo
operator|>
name|unHi
condition|)
break|break;
name|n
operator|=
operator|(
operator|(
name|Int32
operator|)
name|block
index|[
name|ptr
index|[
name|unHi
index|]
operator|+
name|d
index|]
operator|)
operator|-
name|med
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|mswap
argument_list|(
name|ptr
index|[
name|unHi
index|]
argument_list|,
name|ptr
index|[
name|gtHi
index|]
argument_list|)
expr_stmt|;
name|gtHi
operator|--
expr_stmt|;
name|unHi
operator|--
expr_stmt|;
continue|continue;
block|}
empty_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
break|break;
name|unHi
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|unLo
operator|>
name|unHi
condition|)
break|break;
name|mswap
argument_list|(
name|ptr
index|[
name|unLo
index|]
argument_list|,
name|ptr
index|[
name|unHi
index|]
argument_list|)
expr_stmt|;
name|unLo
operator|++
expr_stmt|;
name|unHi
operator|--
expr_stmt|;
block|}
name|AssertD
argument_list|(
name|unHi
operator|==
name|unLo
operator|-
literal|1
argument_list|,
literal|"mainQSort3(2)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|gtHi
operator|<
name|ltLo
condition|)
block|{
name|mpush
argument_list|(
name|lo
argument_list|,
name|hi
argument_list|,
name|d
operator|+
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|n
operator|=
name|mmin
argument_list|(
name|ltLo
operator|-
name|lo
argument_list|,
name|unLo
operator|-
name|ltLo
argument_list|)
expr_stmt|;
name|mvswap
argument_list|(
name|lo
argument_list|,
name|unLo
operator|-
name|n
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|m
operator|=
name|mmin
argument_list|(
name|hi
operator|-
name|gtHi
argument_list|,
name|gtHi
operator|-
name|unHi
argument_list|)
expr_stmt|;
name|mvswap
argument_list|(
name|unLo
argument_list|,
name|hi
operator|-
name|m
operator|+
literal|1
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|n
operator|=
name|lo
operator|+
name|unLo
operator|-
name|ltLo
operator|-
literal|1
expr_stmt|;
name|m
operator|=
name|hi
operator|-
operator|(
name|gtHi
operator|-
name|unHi
operator|)
operator|+
literal|1
expr_stmt|;
name|nextLo
index|[
literal|0
index|]
operator|=
name|lo
expr_stmt|;
name|nextHi
index|[
literal|0
index|]
operator|=
name|n
expr_stmt|;
name|nextD
index|[
literal|0
index|]
operator|=
name|d
expr_stmt|;
name|nextLo
index|[
literal|1
index|]
operator|=
name|m
expr_stmt|;
name|nextHi
index|[
literal|1
index|]
operator|=
name|hi
expr_stmt|;
name|nextD
index|[
literal|1
index|]
operator|=
name|d
expr_stmt|;
name|nextLo
index|[
literal|2
index|]
operator|=
name|n
operator|+
literal|1
expr_stmt|;
name|nextHi
index|[
literal|2
index|]
operator|=
name|m
operator|-
literal|1
expr_stmt|;
name|nextD
index|[
literal|2
index|]
operator|=
name|d
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|mnextsize
argument_list|(
literal|0
argument_list|)
operator|<
name|mnextsize
argument_list|(
literal|1
argument_list|)
condition|)
name|mnextswap
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mnextsize
argument_list|(
literal|1
argument_list|)
operator|<
name|mnextsize
argument_list|(
literal|2
argument_list|)
condition|)
name|mnextswap
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|mnextsize
argument_list|(
literal|0
argument_list|)
operator|<
name|mnextsize
argument_list|(
literal|1
argument_list|)
condition|)
name|mnextswap
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|AssertD
argument_list|(
name|mnextsize
argument_list|(
literal|0
argument_list|)
operator|>=
name|mnextsize
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"mainQSort3(8)"
argument_list|)
expr_stmt|;
name|AssertD
argument_list|(
name|mnextsize
argument_list|(
literal|1
argument_list|)
operator|>=
name|mnextsize
argument_list|(
literal|2
argument_list|)
argument_list|,
literal|"mainQSort3(9)"
argument_list|)
expr_stmt|;
name|mpush
argument_list|(
name|nextLo
index|[
literal|0
index|]
argument_list|,
name|nextHi
index|[
literal|0
index|]
argument_list|,
name|nextD
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|mpush
argument_list|(
name|nextLo
index|[
literal|1
index|]
argument_list|,
name|nextHi
index|[
literal|1
index|]
argument_list|,
name|nextD
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|mpush
argument_list|(
name|nextLo
index|[
literal|2
index|]
argument_list|,
name|nextHi
index|[
literal|2
index|]
argument_list|,
name|nextD
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_undef
undef|#
directive|undef
name|mswap
end_undef

begin_undef
undef|#
directive|undef
name|mvswap
end_undef

begin_undef
undef|#
directive|undef
name|mpush
end_undef

begin_undef
undef|#
directive|undef
name|mpop
end_undef

begin_undef
undef|#
directive|undef
name|mmin
end_undef

begin_undef
undef|#
directive|undef
name|mnextsize
end_undef

begin_undef
undef|#
directive|undef
name|mnextswap
end_undef

begin_undef
undef|#
directive|undef
name|MAIN_QSORT_SMALL_THRESH
end_undef

begin_undef
undef|#
directive|undef
name|MAIN_QSORT_DEPTH_THRESH
end_undef

begin_undef
undef|#
directive|undef
name|MAIN_QSORT_STACK_SIZE
end_undef

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_comment
comment|/* Pre:       nblock> N_OVERSHOOT       block32 exists for [0 .. nblock-1 +N_OVERSHOOT]       ((UChar*)block32) [0 .. nblock-1] holds block       ptr exists for [0 .. nblock-1]     Post:       ((UChar*)block32) [0 .. nblock-1] holds block       All other areas of block32 destroyed       ftab [0 .. 65536 ] destroyed       ptr [0 .. nblock-1] holds sorted order       if (*budget< 0), sorting was abandoned */
end_comment

begin_define
define|#
directive|define
name|BIGFREQ
parameter_list|(
name|b
parameter_list|)
value|(ftab[((b)+1)<< 8] - ftab[(b)<< 8])
end_define

begin_define
define|#
directive|define
name|SETMASK
value|(1<< 21)
end_define

begin_define
define|#
directive|define
name|CLEARMASK
value|(~(SETMASK))
end_define

begin_function
specifier|static
name|void
name|mainSort
parameter_list|(
name|UInt32
modifier|*
name|ptr
parameter_list|,
name|UChar
modifier|*
name|block
parameter_list|,
name|UInt16
modifier|*
name|quadrant
parameter_list|,
name|UInt32
modifier|*
name|ftab
parameter_list|,
name|Int32
name|nblock
parameter_list|,
name|Int32
name|verb
parameter_list|,
name|Int32
modifier|*
name|budget
parameter_list|)
block|{
name|Int32
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|ss
decl_stmt|,
name|sb
decl_stmt|;
name|Int32
name|runningOrder
index|[
literal|256
index|]
decl_stmt|;
name|Bool
name|bigDone
index|[
literal|256
index|]
decl_stmt|;
name|Int32
name|copyStart
index|[
literal|256
index|]
decl_stmt|;
name|Int32
name|copyEnd
index|[
literal|256
index|]
decl_stmt|;
name|UChar
name|c1
decl_stmt|;
name|Int32
name|numQSorted
decl_stmt|;
name|UInt16
name|s
decl_stmt|;
if|if
condition|(
name|verb
operator|>=
literal|4
condition|)
name|VPrintf0
argument_list|(
literal|"        main sort initialise ...\n"
argument_list|)
expr_stmt|;
comment|/*-- set up the 2-byte frequency table --*/
for|for
control|(
name|i
operator|=
literal|65536
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|ftab
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|j
operator|=
name|block
index|[
literal|0
index|]
operator|<<
literal|8
expr_stmt|;
name|i
operator|=
name|nblock
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>=
literal|3
condition|;
name|i
operator|-=
literal|4
control|)
block|{
name|quadrant
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|j
operator|=
operator|(
name|j
operator|>>
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|UInt16
operator|)
name|block
index|[
name|i
index|]
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|ftab
index|[
name|j
index|]
operator|++
expr_stmt|;
name|quadrant
index|[
name|i
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|j
operator|=
operator|(
name|j
operator|>>
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|UInt16
operator|)
name|block
index|[
name|i
operator|-
literal|1
index|]
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|ftab
index|[
name|j
index|]
operator|++
expr_stmt|;
name|quadrant
index|[
name|i
operator|-
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|j
operator|=
operator|(
name|j
operator|>>
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|UInt16
operator|)
name|block
index|[
name|i
operator|-
literal|2
index|]
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|ftab
index|[
name|j
index|]
operator|++
expr_stmt|;
name|quadrant
index|[
name|i
operator|-
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|j
operator|=
operator|(
name|j
operator|>>
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|UInt16
operator|)
name|block
index|[
name|i
operator|-
literal|3
index|]
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|ftab
index|[
name|j
index|]
operator|++
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|quadrant
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|j
operator|=
operator|(
name|j
operator|>>
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|UInt16
operator|)
name|block
index|[
name|i
index|]
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|ftab
index|[
name|j
index|]
operator|++
expr_stmt|;
block|}
comment|/*-- (emphasises close relationship of block& quadrant) --*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BZ_N_OVERSHOOT
condition|;
name|i
operator|++
control|)
block|{
name|block
index|[
name|nblock
operator|+
name|i
index|]
operator|=
name|block
index|[
name|i
index|]
expr_stmt|;
name|quadrant
index|[
name|nblock
operator|+
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|verb
operator|>=
literal|4
condition|)
name|VPrintf0
argument_list|(
literal|"        bucket sorting ...\n"
argument_list|)
expr_stmt|;
comment|/*-- Complete the initial radix sort --*/
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|65536
condition|;
name|i
operator|++
control|)
name|ftab
index|[
name|i
index|]
operator|+=
name|ftab
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|s
operator|=
name|block
index|[
literal|0
index|]
operator|<<
literal|8
expr_stmt|;
name|i
operator|=
name|nblock
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>=
literal|3
condition|;
name|i
operator|-=
literal|4
control|)
block|{
name|s
operator|=
operator|(
name|s
operator|>>
literal|8
operator|)
operator||
operator|(
name|block
index|[
name|i
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|j
operator|=
name|ftab
index|[
name|s
index|]
operator|-
literal|1
expr_stmt|;
name|ftab
index|[
name|s
index|]
operator|=
name|j
expr_stmt|;
name|ptr
index|[
name|j
index|]
operator|=
name|i
expr_stmt|;
name|s
operator|=
operator|(
name|s
operator|>>
literal|8
operator|)
operator||
operator|(
name|block
index|[
name|i
operator|-
literal|1
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|j
operator|=
name|ftab
index|[
name|s
index|]
operator|-
literal|1
expr_stmt|;
name|ftab
index|[
name|s
index|]
operator|=
name|j
expr_stmt|;
name|ptr
index|[
name|j
index|]
operator|=
name|i
operator|-
literal|1
expr_stmt|;
name|s
operator|=
operator|(
name|s
operator|>>
literal|8
operator|)
operator||
operator|(
name|block
index|[
name|i
operator|-
literal|2
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|j
operator|=
name|ftab
index|[
name|s
index|]
operator|-
literal|1
expr_stmt|;
name|ftab
index|[
name|s
index|]
operator|=
name|j
expr_stmt|;
name|ptr
index|[
name|j
index|]
operator|=
name|i
operator|-
literal|2
expr_stmt|;
name|s
operator|=
operator|(
name|s
operator|>>
literal|8
operator|)
operator||
operator|(
name|block
index|[
name|i
operator|-
literal|3
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|j
operator|=
name|ftab
index|[
name|s
index|]
operator|-
literal|1
expr_stmt|;
name|ftab
index|[
name|s
index|]
operator|=
name|j
expr_stmt|;
name|ptr
index|[
name|j
index|]
operator|=
name|i
operator|-
literal|3
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|s
operator|=
operator|(
name|s
operator|>>
literal|8
operator|)
operator||
operator|(
name|block
index|[
name|i
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|j
operator|=
name|ftab
index|[
name|s
index|]
operator|-
literal|1
expr_stmt|;
name|ftab
index|[
name|s
index|]
operator|=
name|j
expr_stmt|;
name|ptr
index|[
name|j
index|]
operator|=
name|i
expr_stmt|;
block|}
comment|/*--       Now ftab contains the first loc of every small bucket.       Calculate the running order, from smallest to largest       big bucket.    --*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|255
condition|;
name|i
operator|++
control|)
block|{
name|bigDone
index|[
name|i
index|]
operator|=
name|False
expr_stmt|;
name|runningOrder
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
block|{
name|Int32
name|vv
decl_stmt|;
name|Int32
name|h
init|=
literal|1
decl_stmt|;
do|do
name|h
operator|=
literal|3
operator|*
name|h
operator|+
literal|1
expr_stmt|;
do|while
condition|(
name|h
operator|<=
literal|256
condition|)
do|;
do|do
block|{
name|h
operator|=
name|h
operator|/
literal|3
expr_stmt|;
for|for
control|(
name|i
operator|=
name|h
init|;
name|i
operator|<=
literal|255
condition|;
name|i
operator|++
control|)
block|{
name|vv
operator|=
name|runningOrder
index|[
name|i
index|]
expr_stmt|;
name|j
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|BIGFREQ
argument_list|(
name|runningOrder
index|[
name|j
operator|-
name|h
index|]
argument_list|)
operator|>
name|BIGFREQ
argument_list|(
name|vv
argument_list|)
condition|)
block|{
name|runningOrder
index|[
name|j
index|]
operator|=
name|runningOrder
index|[
name|j
operator|-
name|h
index|]
expr_stmt|;
name|j
operator|=
name|j
operator|-
name|h
expr_stmt|;
if|if
condition|(
name|j
operator|<=
operator|(
name|h
operator|-
literal|1
operator|)
condition|)
goto|goto
name|zero
goto|;
block|}
name|zero
label|:
name|runningOrder
index|[
name|j
index|]
operator|=
name|vv
expr_stmt|;
block|}
block|}
do|while
condition|(
name|h
operator|!=
literal|1
condition|)
do|;
block|}
comment|/*--       The main sorting loop.    --*/
name|numQSorted
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|255
condition|;
name|i
operator|++
control|)
block|{
comment|/*--          Process big buckets, starting with the least full.          Basically this is a 3-step process in which we call          mainQSort3 to sort the small buckets [ss, j], but          also make a big effort to avoid the calls if we can.       --*/
name|ss
operator|=
name|runningOrder
index|[
name|i
index|]
expr_stmt|;
comment|/*--          Step 1:          Complete the big bucket [ss] by quicksorting          any unsorted small buckets [ss, j], for j != ss.            Hopefully previous pointer-scanning phases have already          completed many of the small buckets [ss, j], so          we don't have to sort them at all.       --*/
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
literal|255
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|!=
name|ss
condition|)
block|{
name|sb
operator|=
operator|(
name|ss
operator|<<
literal|8
operator|)
operator|+
name|j
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ftab
index|[
name|sb
index|]
operator|&
name|SETMASK
operator|)
condition|)
block|{
name|Int32
name|lo
init|=
name|ftab
index|[
name|sb
index|]
operator|&
name|CLEARMASK
decl_stmt|;
name|Int32
name|hi
init|=
operator|(
name|ftab
index|[
name|sb
operator|+
literal|1
index|]
operator|&
name|CLEARMASK
operator|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|hi
operator|>
name|lo
condition|)
block|{
if|if
condition|(
name|verb
operator|>=
literal|4
condition|)
name|VPrintf4
argument_list|(
literal|"        qsort [0x%x, 0x%x]   "
literal|"done %d   this %d\n"
argument_list|,
name|ss
argument_list|,
name|j
argument_list|,
name|numQSorted
argument_list|,
name|hi
operator|-
name|lo
operator|+
literal|1
argument_list|)
expr_stmt|;
name|mainQSort3
argument_list|(
name|ptr
argument_list|,
name|block
argument_list|,
name|quadrant
argument_list|,
name|nblock
argument_list|,
name|lo
argument_list|,
name|hi
argument_list|,
name|BZ_N_RADIX
argument_list|,
name|budget
argument_list|)
expr_stmt|;
name|numQSorted
operator|+=
operator|(
name|hi
operator|-
name|lo
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|budget
operator|<
literal|0
condition|)
return|return;
block|}
block|}
name|ftab
index|[
name|sb
index|]
operator||=
name|SETMASK
expr_stmt|;
block|}
block|}
name|AssertH
argument_list|(
operator|!
name|bigDone
index|[
name|ss
index|]
argument_list|,
literal|1006
argument_list|)
expr_stmt|;
comment|/*--          Step 2:          Now scan this big bucket [ss] so as to synthesise the          sorted order for small buckets [t, ss] for all t,          including, magically, the bucket [ss,ss] too.          This will avoid doing Real Work in subsequent Step 1's.       --*/
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
literal|255
condition|;
name|j
operator|++
control|)
block|{
name|copyStart
index|[
name|j
index|]
operator|=
name|ftab
index|[
operator|(
name|j
operator|<<
literal|8
operator|)
operator|+
name|ss
index|]
operator|&
name|CLEARMASK
expr_stmt|;
name|copyEnd
index|[
name|j
index|]
operator|=
operator|(
name|ftab
index|[
operator|(
name|j
operator|<<
literal|8
operator|)
operator|+
name|ss
operator|+
literal|1
index|]
operator|&
name|CLEARMASK
operator|)
operator|-
literal|1
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
name|ftab
index|[
name|ss
operator|<<
literal|8
index|]
operator|&
name|CLEARMASK
init|;
name|j
operator|<
name|copyStart
index|[
name|ss
index|]
condition|;
name|j
operator|++
control|)
block|{
name|k
operator|=
name|ptr
index|[
name|j
index|]
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|k
operator|<
literal|0
condition|)
name|k
operator|+=
name|nblock
expr_stmt|;
name|c1
operator|=
name|block
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|bigDone
index|[
name|c1
index|]
condition|)
name|ptr
index|[
name|copyStart
index|[
name|c1
index|]
operator|++
index|]
operator|=
name|k
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
operator|(
name|ftab
index|[
operator|(
name|ss
operator|+
literal|1
operator|)
operator|<<
literal|8
index|]
operator|&
name|CLEARMASK
operator|)
operator|-
literal|1
init|;
name|j
operator|>
name|copyEnd
index|[
name|ss
index|]
condition|;
name|j
operator|--
control|)
block|{
name|k
operator|=
name|ptr
index|[
name|j
index|]
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|k
operator|<
literal|0
condition|)
name|k
operator|+=
name|nblock
expr_stmt|;
name|c1
operator|=
name|block
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|bigDone
index|[
name|c1
index|]
condition|)
name|ptr
index|[
name|copyEnd
index|[
name|c1
index|]
operator|--
index|]
operator|=
name|k
expr_stmt|;
block|}
block|}
name|AssertH
argument_list|(
argument|(copyStart[ss]-
literal|1
argument|== copyEnd[ss])                 ||
comment|/* Extremely rare case missing in bzip2-1.0.0 and 1.0.1.                    Necessity for this case is demonstrated by compressing                     a sequence of approximately 48.5 million of character                     251; 1.0.0/1.0.1 will then die here. */
argument|(copyStart[ss] ==
literal|0
argument|&& copyEnd[ss] == nblock-
literal|1
argument|)
argument_list|,
literal|1007
argument_list|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
literal|255
condition|;
name|j
operator|++
control|)
name|ftab
index|[
operator|(
name|j
operator|<<
literal|8
operator|)
operator|+
name|ss
index|]
operator||=
name|SETMASK
expr_stmt|;
comment|/*--          Step 3:          The [ss] big bucket is now done.  Record this fact,          and update the quadrant descriptors.  Remember to          update quadrants in the overshoot area too, if          necessary.  The "if (i< 255)" test merely skips          this updating for the last bucket processed, since          updating for the last bucket is pointless.           The quadrant array provides a way to incrementally          cache sort orderings, as they appear, so as to           make subsequent comparisons in fullGtU() complete          faster.  For repetitive blocks this makes a big          difference (but not big enough to be able to avoid          the fallback sorting mechanism, exponential radix sort).           The precise meaning is: at all times:              for 0<= i< nblock and 0<= j<= nblock              if block[i] != block[j],                  then the relative values of quadrant[i] and                      quadrant[j] are meaningless.                 else {                   if quadrant[i]< quadrant[j]                      then the string starting at i lexicographically                      precedes the string starting at j                    else if quadrant[i]> quadrant[j]                      then the string starting at j lexicographically                      precedes the string starting at i                    else                      the relative ordering of the strings starting                      at i and j has not yet been determined.                }       --*/
name|bigDone
index|[
name|ss
index|]
operator|=
name|True
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|255
condition|)
block|{
name|Int32
name|bbStart
init|=
name|ftab
index|[
name|ss
operator|<<
literal|8
index|]
operator|&
name|CLEARMASK
decl_stmt|;
name|Int32
name|bbSize
init|=
operator|(
name|ftab
index|[
operator|(
name|ss
operator|+
literal|1
operator|)
operator|<<
literal|8
index|]
operator|&
name|CLEARMASK
operator|)
operator|-
name|bbStart
decl_stmt|;
name|Int32
name|shifts
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|bbSize
operator|>>
name|shifts
operator|)
operator|>
literal|65534
condition|)
name|shifts
operator|++
expr_stmt|;
for|for
control|(
name|j
operator|=
name|bbSize
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|Int32
name|a2update
init|=
name|ptr
index|[
name|bbStart
operator|+
name|j
index|]
decl_stmt|;
name|UInt16
name|qVal
init|=
call|(
name|UInt16
call|)
argument_list|(
name|j
operator|>>
name|shifts
argument_list|)
decl_stmt|;
name|quadrant
index|[
name|a2update
index|]
operator|=
name|qVal
expr_stmt|;
if|if
condition|(
name|a2update
operator|<
name|BZ_N_OVERSHOOT
condition|)
name|quadrant
index|[
name|a2update
operator|+
name|nblock
index|]
operator|=
name|qVal
expr_stmt|;
block|}
name|AssertH
argument_list|(
operator|(
operator|(
name|bbSize
operator|-
literal|1
operator|)
operator|>>
name|shifts
operator|)
operator|<=
literal|65535
argument_list|,
literal|1002
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|verb
operator|>=
literal|4
condition|)
name|VPrintf3
argument_list|(
literal|"        %d pointers, %d sorted, %d scanned\n"
argument_list|,
name|nblock
argument_list|,
name|numQSorted
argument_list|,
name|nblock
operator|-
name|numQSorted
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|BIGFREQ
end_undef

begin_undef
undef|#
directive|undef
name|SETMASK
end_undef

begin_undef
undef|#
directive|undef
name|CLEARMASK
end_undef

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_comment
comment|/* Pre:       nblock> 0       arr2 exists for [0 .. nblock-1 +N_OVERSHOOT]       ((UChar*)arr2)  [0 .. nblock-1] holds block       arr1 exists for [0 .. nblock-1]     Post:       ((UChar*)arr2) [0 .. nblock-1] holds block       All other areas of block destroyed       ftab [ 0 .. 65536 ] destroyed       arr1 [0 .. nblock-1] holds sorted order */
end_comment

begin_function
name|void
name|BZ2_blockSort
parameter_list|(
name|EState
modifier|*
name|s
parameter_list|)
block|{
name|UInt32
modifier|*
name|ptr
init|=
name|s
operator|->
name|ptr
decl_stmt|;
name|UChar
modifier|*
name|block
init|=
name|s
operator|->
name|block
decl_stmt|;
name|UInt32
modifier|*
name|ftab
init|=
name|s
operator|->
name|ftab
decl_stmt|;
name|Int32
name|nblock
init|=
name|s
operator|->
name|nblock
decl_stmt|;
name|Int32
name|verb
init|=
name|s
operator|->
name|verbosity
decl_stmt|;
name|Int32
name|wfact
init|=
name|s
operator|->
name|workFactor
decl_stmt|;
name|UInt16
modifier|*
name|quadrant
decl_stmt|;
name|Int32
name|budget
decl_stmt|;
name|Int32
name|budgetInit
decl_stmt|;
name|Int32
name|i
decl_stmt|;
if|if
condition|(
name|nblock
operator|<
literal|10000
condition|)
block|{
name|fallbackSort
argument_list|(
name|s
operator|->
name|arr1
argument_list|,
name|s
operator|->
name|arr2
argument_list|,
name|ftab
argument_list|,
name|nblock
argument_list|,
name|verb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Calculate the location for quadrant, remembering to get          the alignment right.  Assumes that&(block[0]) is at least          2-byte aligned -- this should be ok since block is really          the first section of arr2.       */
name|i
operator|=
name|nblock
operator|+
name|BZ_N_OVERSHOOT
expr_stmt|;
if|if
condition|(
name|i
operator|&
literal|1
condition|)
name|i
operator|++
expr_stmt|;
name|quadrant
operator|=
operator|(
name|UInt16
operator|*
operator|)
operator|(
operator|&
operator|(
name|block
index|[
name|i
index|]
operator|)
operator|)
expr_stmt|;
comment|/* (wfact-1) / 3 puts the default-factor-30          transition point at very roughly the same place as           with v0.1 and v0.9.0.            Not that it particularly matters any more, since the          resulting compressed stream is now the same regardless          of whether or not we use the main sort or fallback sort.       */
if|if
condition|(
name|wfact
operator|<
literal|1
condition|)
name|wfact
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|wfact
operator|>
literal|100
condition|)
name|wfact
operator|=
literal|100
expr_stmt|;
name|budgetInit
operator|=
name|nblock
operator|*
operator|(
operator|(
name|wfact
operator|-
literal|1
operator|)
operator|/
literal|3
operator|)
expr_stmt|;
name|budget
operator|=
name|budgetInit
expr_stmt|;
name|mainSort
argument_list|(
name|ptr
argument_list|,
name|block
argument_list|,
name|quadrant
argument_list|,
name|ftab
argument_list|,
name|nblock
argument_list|,
name|verb
argument_list|,
operator|&
name|budget
argument_list|)
expr_stmt|;
if|if
condition|(
name|verb
operator|>=
literal|3
condition|)
name|VPrintf3
argument_list|(
literal|"      %d work, %d block, ratio %5.2f\n"
argument_list|,
name|budgetInit
operator|-
name|budget
argument_list|,
name|nblock
argument_list|,
call|(
name|float
call|)
argument_list|(
name|budgetInit
operator|-
name|budget
argument_list|)
operator|/
call|(
name|float
call|)
argument_list|(
name|nblock
operator|==
literal|0
condition|?
literal|1
else|:
name|nblock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|budget
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|verb
operator|>=
literal|2
condition|)
name|VPrintf0
argument_list|(
literal|"    too repetitive; using fallback"
literal|" sorting algorithm\n"
argument_list|)
expr_stmt|;
name|fallbackSort
argument_list|(
name|s
operator|->
name|arr1
argument_list|,
name|s
operator|->
name|arr2
argument_list|,
name|ftab
argument_list|,
name|nblock
argument_list|,
name|verb
argument_list|)
expr_stmt|;
block|}
block|}
name|s
operator|->
name|origPtr
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|nblock
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ptr
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|s
operator|->
name|origPtr
operator|=
name|i
expr_stmt|;
break|break;
block|}
empty_stmt|;
name|AssertH
argument_list|(
name|s
operator|->
name|origPtr
operator|!=
operator|-
literal|1
argument_list|,
literal|1003
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-------------------------------------------------------------*/
end_comment

begin_comment
comment|/*--- end                                       blocksort.c ---*/
end_comment

begin_comment
comment|/*-------------------------------------------------------------*/
end_comment

end_unit

