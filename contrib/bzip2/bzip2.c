begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-----------------------------------------------------------*/
end_comment

begin_comment
comment|/*--- A block-sorting, lossless compressor        bzip2.c ---*/
end_comment

begin_comment
comment|/*-----------------------------------------------------------*/
end_comment

begin_comment
comment|/* ------------------------------------------------------------------    This file is part of bzip2/libbzip2, a program and library for    lossless, block-sorting data compression.     bzip2/libbzip2 version 1.0.4 of 20 December 2006    Copyright (C) 1996-2006 Julian Seward<jseward@bzip.org>     Please read the WARNING, DISCLAIMER and PATENTS sections in the     README file.     This program is released under the terms of the license contained    in the file LICENSE.    ------------------------------------------------------------------ */
end_comment

begin_comment
comment|/* Place a 1 beside your platform, and 0 elsewhere.    Generic 32-bit Unix.    Also works on 64-bit Unix boxes.    This is the default. */
end_comment

begin_define
define|#
directive|define
name|BZ_UNIX
value|1
end_define

begin_comment
comment|/*--   Win32, as seen by Jacob Navia's excellent   port of (Chris Fraser& David Hanson)'s excellent   lcc compiler.  Or with MS Visual C.   This is selected automatically if compiled by a compiler which   defines _WIN32, not including the Cygwin GCC. --*/
end_comment

begin_define
define|#
directive|define
name|BZ_LCCWIN32
value|0
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|BZ_LCCWIN32
end_undef

begin_define
define|#
directive|define
name|BZ_LCCWIN32
value|1
end_define

begin_undef
undef|#
directive|undef
name|BZ_UNIX
end_undef

begin_define
define|#
directive|define
name|BZ_UNIX
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_comment
comment|/*--   Some stuff for all platforms. --*/
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"bzlib.h"
end_include

begin_define
define|#
directive|define
name|ERROR_IF_EOF
parameter_list|(
name|i
parameter_list|)
value|{ if ((i) == EOF)  ioError(); }
end_define

begin_define
define|#
directive|define
name|ERROR_IF_NOT_ZERO
parameter_list|(
name|i
parameter_list|)
value|{ if ((i) != 0)    ioError(); }
end_define

begin_define
define|#
directive|define
name|ERROR_IF_MINUS_ONE
parameter_list|(
name|i
parameter_list|)
value|{ if ((i) == (-1)) ioError(); }
end_define

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_comment
comment|/*--    Platform-specific stuff. --*/
end_comment

begin_if
if|#
directive|if
name|BZ_UNIX
end_if

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<utime.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/times.h>
end_include

begin_define
define|#
directive|define
name|PATH_SEP
value|'/'
end_define

begin_define
define|#
directive|define
name|MY_LSTAT
value|lstat
end_define

begin_define
define|#
directive|define
name|MY_STAT
value|stat
end_define

begin_define
define|#
directive|define
name|MY_S_ISREG
value|S_ISREG
end_define

begin_define
define|#
directive|define
name|MY_S_ISDIR
value|S_ISDIR
end_define

begin_define
define|#
directive|define
name|APPEND_FILESPEC
parameter_list|(
name|root
parameter_list|,
name|name
parameter_list|)
define|\
value|root=snocString((root), (name))
end_define

begin_define
define|#
directive|define
name|APPEND_FLAG
parameter_list|(
name|root
parameter_list|,
name|name
parameter_list|)
define|\
value|root=snocString((root), (name))
end_define

begin_define
define|#
directive|define
name|SET_BINARY_MODE
parameter_list|(
name|fd
parameter_list|)
end_define

begin_comment
comment|/**/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|NORETURN
value|__attribute__ ((noreturn))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NORETURN
end_define

begin_comment
comment|/**/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__DJGPP__
end_ifdef

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_undef
undef|#
directive|undef
name|MY_LSTAT
end_undef

begin_undef
undef|#
directive|undef
name|MY_STAT
end_undef

begin_define
define|#
directive|define
name|MY_LSTAT
value|stat
end_define

begin_define
define|#
directive|define
name|MY_STAT
value|stat
end_define

begin_undef
undef|#
directive|undef
name|SET_BINARY_MODE
end_undef

begin_define
define|#
directive|define
name|SET_BINARY_MODE
parameter_list|(
name|fd
parameter_list|)
define|\
value|do {                                            \            int retVal = setmode ( fileno ( fd ),        \                                   O_BINARY );           \            ERROR_IF_MINUS_ONE ( retVal );               \         } while ( 0 )
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__CYGWIN__
end_ifdef

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_undef
undef|#
directive|undef
name|SET_BINARY_MODE
end_undef

begin_define
define|#
directive|define
name|SET_BINARY_MODE
parameter_list|(
name|fd
parameter_list|)
define|\
value|do {                                            \            int retVal = setmode ( fileno ( fd ),        \                                   O_BINARY );           \            ERROR_IF_MINUS_ONE ( retVal );               \         } while ( 0 )
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BZ_UNIX */
end_comment

begin_if
if|#
directive|if
name|BZ_LCCWIN32
end_if

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys\stat.h>
end_include

begin_define
define|#
directive|define
name|NORETURN
end_define

begin_comment
comment|/**/
end_comment

begin_define
define|#
directive|define
name|PATH_SEP
value|'\\'
end_define

begin_define
define|#
directive|define
name|MY_LSTAT
value|_stat
end_define

begin_define
define|#
directive|define
name|MY_STAT
value|_stat
end_define

begin_define
define|#
directive|define
name|MY_S_ISREG
parameter_list|(
name|x
parameter_list|)
value|((x)& _S_IFREG)
end_define

begin_define
define|#
directive|define
name|MY_S_ISDIR
parameter_list|(
name|x
parameter_list|)
value|((x)& _S_IFDIR)
end_define

begin_define
define|#
directive|define
name|APPEND_FLAG
parameter_list|(
name|root
parameter_list|,
name|name
parameter_list|)
define|\
value|root=snocString((root), (name))
end_define

begin_define
define|#
directive|define
name|APPEND_FILESPEC
parameter_list|(
name|root
parameter_list|,
name|name
parameter_list|)
define|\
value|root = snocString ((root), (name))
end_define

begin_define
define|#
directive|define
name|SET_BINARY_MODE
parameter_list|(
name|fd
parameter_list|)
define|\
value|do {                                            \          int retVal = setmode ( fileno ( fd ),        \                                 O_BINARY );           \          ERROR_IF_MINUS_ONE ( retVal );               \       } while ( 0 )
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BZ_LCCWIN32 */
end_comment

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_comment
comment|/*--   Some more stuff for all platforms :-) --*/
end_comment

begin_typedef
typedef|typedef
name|char
name|Char
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|char
name|Bool
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|char
name|UChar
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|int
name|Int32
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|int
name|UInt32
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|short
name|Int16
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|short
name|UInt16
typedef|;
end_typedef

begin_define
define|#
directive|define
name|True
value|((Bool)1)
end_define

begin_define
define|#
directive|define
name|False
value|((Bool)0)
end_define

begin_comment
comment|/*--   IntNative is your platform's `native' int size.   Only here to avoid probs with 64-bit platforms. --*/
end_comment

begin_typedef
typedef|typedef
name|int
name|IntNative
typedef|;
end_typedef

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_comment
comment|/*--- Misc (file handling) data decls             ---*/
end_comment

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_decl_stmt
name|Int32
name|verbosity
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Bool
name|keepInputFiles
decl_stmt|,
name|smallMode
decl_stmt|,
name|deleteOutputOnInterrupt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Bool
name|forceOverwrite
decl_stmt|,
name|testFailsExist
decl_stmt|,
name|unzFailsExist
decl_stmt|,
name|noisy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Int32
name|numFileNames
decl_stmt|,
name|numFilesProcessed
decl_stmt|,
name|blockSize100k
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Int32
name|exitValue
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*-- source modes; F==file, I==stdin, O==stdout --*/
end_comment

begin_define
define|#
directive|define
name|SM_I2O
value|1
end_define

begin_define
define|#
directive|define
name|SM_F2O
value|2
end_define

begin_define
define|#
directive|define
name|SM_F2F
value|3
end_define

begin_comment
comment|/*-- operation modes --*/
end_comment

begin_define
define|#
directive|define
name|OM_Z
value|1
end_define

begin_define
define|#
directive|define
name|OM_UNZ
value|2
end_define

begin_define
define|#
directive|define
name|OM_TEST
value|3
end_define

begin_decl_stmt
name|Int32
name|opMode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Int32
name|srcMode
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FILE_NAME_LEN
value|1034
end_define

begin_decl_stmt
name|Int32
name|longestFileName
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Char
name|inName
index|[
name|FILE_NAME_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Char
name|outName
index|[
name|FILE_NAME_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Char
name|tmpName
index|[
name|FILE_NAME_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Char
modifier|*
name|progName
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Char
name|progNameReally
index|[
name|FILE_NAME_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|outputHandleJustInCase
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Int32
name|workFactor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|panic
argument_list|(
specifier|const
name|Char
operator|*
argument_list|)
name|NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ioError
argument_list|(
name|void
argument_list|)
name|NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|outOfMemory
argument_list|(
name|void
argument_list|)
name|NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|configError
argument_list|(
name|void
argument_list|)
name|NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|crcError
argument_list|(
name|void
argument_list|)
name|NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cleanUpAndFail
argument_list|(
name|Int32
argument_list|)
name|NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compressedStreamEOF
argument_list|(
name|void
argument_list|)
name|NORETURN
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|copyFileName
parameter_list|(
name|Char
modifier|*
parameter_list|,
name|Char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|myMalloc
parameter_list|(
name|Int32
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|applySavedFileAttrToOutputFile
parameter_list|(
name|IntNative
name|fd
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_comment
comment|/*--- An implementation of 64-bit ints.  Sigh.    ---*/
end_comment

begin_comment
comment|/*--- Roll on widespread deployment of ANSI C9X ! ---*/
end_comment

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|UChar
name|b
index|[
literal|8
index|]
decl_stmt|;
block|}
name|UInt64
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|uInt64_from_UInt32s
parameter_list|(
name|UInt64
modifier|*
name|n
parameter_list|,
name|UInt32
name|lo32
parameter_list|,
name|UInt32
name|hi32
parameter_list|)
block|{
name|n
operator|->
name|b
index|[
literal|7
index|]
operator|=
call|(
name|UChar
call|)
argument_list|(
operator|(
name|hi32
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|n
operator|->
name|b
index|[
literal|6
index|]
operator|=
call|(
name|UChar
call|)
argument_list|(
operator|(
name|hi32
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|n
operator|->
name|b
index|[
literal|5
index|]
operator|=
call|(
name|UChar
call|)
argument_list|(
operator|(
name|hi32
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|n
operator|->
name|b
index|[
literal|4
index|]
operator|=
call|(
name|UChar
call|)
argument_list|(
name|hi32
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|n
operator|->
name|b
index|[
literal|3
index|]
operator|=
call|(
name|UChar
call|)
argument_list|(
operator|(
name|lo32
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|n
operator|->
name|b
index|[
literal|2
index|]
operator|=
call|(
name|UChar
call|)
argument_list|(
operator|(
name|lo32
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|n
operator|->
name|b
index|[
literal|1
index|]
operator|=
call|(
name|UChar
call|)
argument_list|(
operator|(
name|lo32
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|n
operator|->
name|b
index|[
literal|0
index|]
operator|=
call|(
name|UChar
call|)
argument_list|(
name|lo32
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|double
name|uInt64_to_double
parameter_list|(
name|UInt64
modifier|*
name|n
parameter_list|)
block|{
name|Int32
name|i
decl_stmt|;
name|double
name|base
init|=
literal|1.0
decl_stmt|;
name|double
name|sum
init|=
literal|0.0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|sum
operator|+=
name|base
operator|*
call|(
name|double
call|)
argument_list|(
name|n
operator|->
name|b
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|base
operator|*=
literal|256.0
expr_stmt|;
block|}
return|return
name|sum
return|;
block|}
end_function

begin_function
specifier|static
name|Bool
name|uInt64_isZero
parameter_list|(
name|UInt64
modifier|*
name|n
parameter_list|)
block|{
name|Int32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|n
operator|->
name|b
index|[
name|i
index|]
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Divide *n by 10, and return the remainder.  */
end_comment

begin_function
specifier|static
name|Int32
name|uInt64_qrm10
parameter_list|(
name|UInt64
modifier|*
name|n
parameter_list|)
block|{
name|UInt32
name|rem
decl_stmt|,
name|tmp
decl_stmt|;
name|Int32
name|i
decl_stmt|;
name|rem
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|7
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|tmp
operator|=
name|rem
operator|*
literal|256
operator|+
name|n
operator|->
name|b
index|[
name|i
index|]
expr_stmt|;
name|n
operator|->
name|b
index|[
name|i
index|]
operator|=
name|tmp
operator|/
literal|10
expr_stmt|;
name|rem
operator|=
name|tmp
operator|%
literal|10
expr_stmt|;
block|}
return|return
name|rem
return|;
block|}
end_function

begin_comment
comment|/* ... and the Whole Entire Point of all this UInt64 stuff is    so that we can supply the following function. */
end_comment

begin_function
specifier|static
name|void
name|uInt64_toAscii
parameter_list|(
name|char
modifier|*
name|outbuf
parameter_list|,
name|UInt64
modifier|*
name|n
parameter_list|)
block|{
name|Int32
name|i
decl_stmt|,
name|q
decl_stmt|;
name|UChar
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|Int32
name|nBuf
init|=
literal|0
decl_stmt|;
name|UInt64
name|n_copy
init|=
operator|*
name|n
decl_stmt|;
do|do
block|{
name|q
operator|=
name|uInt64_qrm10
argument_list|(
operator|&
name|n_copy
argument_list|)
expr_stmt|;
name|buf
index|[
name|nBuf
index|]
operator|=
name|q
operator|+
literal|'0'
expr_stmt|;
name|nBuf
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|uInt64_isZero
argument_list|(
operator|&
name|n_copy
argument_list|)
condition|)
do|;
name|outbuf
index|[
name|nBuf
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nBuf
condition|;
name|i
operator|++
control|)
name|outbuf
index|[
name|i
index|]
operator|=
name|buf
index|[
name|nBuf
operator|-
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_comment
comment|/*--- Processing of complete files and streams    ---*/
end_comment

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|Bool
name|myfeof
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|Int32
name|c
init|=
name|fgetc
argument_list|(
name|f
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
name|True
return|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
return|return
name|False
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|compressStream
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|FILE
modifier|*
name|zStream
parameter_list|)
block|{
name|BZFILE
modifier|*
name|bzf
init|=
name|NULL
decl_stmt|;
name|UChar
name|ibuf
index|[
literal|5000
index|]
decl_stmt|;
name|Int32
name|nIbuf
decl_stmt|;
name|UInt32
name|nbytes_in_lo32
decl_stmt|,
name|nbytes_in_hi32
decl_stmt|;
name|UInt32
name|nbytes_out_lo32
decl_stmt|,
name|nbytes_out_hi32
decl_stmt|;
name|Int32
name|bzerr
decl_stmt|,
name|bzerr_dummy
decl_stmt|,
name|ret
decl_stmt|;
name|SET_BINARY_MODE
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|SET_BINARY_MODE
argument_list|(
name|zStream
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stream
argument_list|)
condition|)
goto|goto
name|errhandler_io
goto|;
if|if
condition|(
name|ferror
argument_list|(
name|zStream
argument_list|)
condition|)
goto|goto
name|errhandler_io
goto|;
name|bzf
operator|=
name|BZ2_bzWriteOpen
argument_list|(
operator|&
name|bzerr
argument_list|,
name|zStream
argument_list|,
name|blockSize100k
argument_list|,
name|verbosity
argument_list|,
name|workFactor
argument_list|)
expr_stmt|;
if|if
condition|(
name|bzerr
operator|!=
name|BZ_OK
condition|)
goto|goto
name|errhandler
goto|;
if|if
condition|(
name|verbosity
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|True
condition|)
block|{
if|if
condition|(
name|myfeof
argument_list|(
name|stream
argument_list|)
condition|)
break|break;
name|nIbuf
operator|=
name|fread
argument_list|(
name|ibuf
argument_list|,
sizeof|sizeof
argument_list|(
name|UChar
argument_list|)
argument_list|,
literal|5000
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stream
argument_list|)
condition|)
goto|goto
name|errhandler_io
goto|;
if|if
condition|(
name|nIbuf
operator|>
literal|0
condition|)
name|BZ2_bzWrite
argument_list|(
operator|&
name|bzerr
argument_list|,
name|bzf
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ibuf
argument_list|,
name|nIbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bzerr
operator|!=
name|BZ_OK
condition|)
goto|goto
name|errhandler
goto|;
block|}
name|BZ2_bzWriteClose64
argument_list|(
operator|&
name|bzerr
argument_list|,
name|bzf
argument_list|,
literal|0
argument_list|,
operator|&
name|nbytes_in_lo32
argument_list|,
operator|&
name|nbytes_in_hi32
argument_list|,
operator|&
name|nbytes_out_lo32
argument_list|,
operator|&
name|nbytes_out_hi32
argument_list|)
expr_stmt|;
if|if
condition|(
name|bzerr
operator|!=
name|BZ_OK
condition|)
goto|goto
name|errhandler
goto|;
if|if
condition|(
name|ferror
argument_list|(
name|zStream
argument_list|)
condition|)
goto|goto
name|errhandler_io
goto|;
name|ret
operator|=
name|fflush
argument_list|(
name|zStream
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|EOF
condition|)
goto|goto
name|errhandler_io
goto|;
if|if
condition|(
name|zStream
operator|!=
name|stdout
condition|)
block|{
name|Int32
name|fd
init|=
name|fileno
argument_list|(
name|zStream
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
goto|goto
name|errhandler_io
goto|;
name|applySavedFileAttrToOutputFile
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|ret
operator|=
name|fclose
argument_list|(
name|zStream
argument_list|)
expr_stmt|;
name|outputHandleJustInCase
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|EOF
condition|)
goto|goto
name|errhandler_io
goto|;
block|}
name|outputHandleJustInCase
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stream
argument_list|)
condition|)
goto|goto
name|errhandler_io
goto|;
name|ret
operator|=
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|EOF
condition|)
goto|goto
name|errhandler_io
goto|;
if|if
condition|(
name|verbosity
operator|>=
literal|1
condition|)
block|{
if|if
condition|(
name|nbytes_in_lo32
operator|==
literal|0
operator|&&
name|nbytes_in_hi32
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" no data compressed.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Char
name|buf_nin
index|[
literal|32
index|]
decl_stmt|,
name|buf_nout
index|[
literal|32
index|]
decl_stmt|;
name|UInt64
name|nbytes_in
decl_stmt|,
name|nbytes_out
decl_stmt|;
name|double
name|nbytes_in_d
decl_stmt|,
name|nbytes_out_d
decl_stmt|;
name|uInt64_from_UInt32s
argument_list|(
operator|&
name|nbytes_in
argument_list|,
name|nbytes_in_lo32
argument_list|,
name|nbytes_in_hi32
argument_list|)
expr_stmt|;
name|uInt64_from_UInt32s
argument_list|(
operator|&
name|nbytes_out
argument_list|,
name|nbytes_out_lo32
argument_list|,
name|nbytes_out_hi32
argument_list|)
expr_stmt|;
name|nbytes_in_d
operator|=
name|uInt64_to_double
argument_list|(
operator|&
name|nbytes_in
argument_list|)
expr_stmt|;
name|nbytes_out_d
operator|=
name|uInt64_to_double
argument_list|(
operator|&
name|nbytes_out
argument_list|)
expr_stmt|;
name|uInt64_toAscii
argument_list|(
name|buf_nin
argument_list|,
operator|&
name|nbytes_in
argument_list|)
expr_stmt|;
name|uInt64_toAscii
argument_list|(
name|buf_nout
argument_list|,
operator|&
name|nbytes_out
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%6.3f:1, %6.3f bits/byte, "
literal|"%5.2f%% saved, %s in, %s out.\n"
argument_list|,
name|nbytes_in_d
operator|/
name|nbytes_out_d
argument_list|,
operator|(
literal|8.0
operator|*
name|nbytes_out_d
operator|)
operator|/
name|nbytes_in_d
argument_list|,
literal|100.0
operator|*
operator|(
literal|1.0
operator|-
name|nbytes_out_d
operator|/
name|nbytes_in_d
operator|)
argument_list|,
name|buf_nin
argument_list|,
name|buf_nout
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
name|errhandler
label|:
name|BZ2_bzWriteClose64
argument_list|(
operator|&
name|bzerr_dummy
argument_list|,
name|bzf
argument_list|,
literal|1
argument_list|,
operator|&
name|nbytes_in_lo32
argument_list|,
operator|&
name|nbytes_in_hi32
argument_list|,
operator|&
name|nbytes_out_lo32
argument_list|,
operator|&
name|nbytes_out_hi32
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bzerr
condition|)
block|{
case|case
name|BZ_CONFIG_ERROR
case|:
name|configError
argument_list|()
expr_stmt|;
break|break;
case|case
name|BZ_MEM_ERROR
case|:
name|outOfMemory
argument_list|()
expr_stmt|;
break|break;
case|case
name|BZ_IO_ERROR
case|:
name|errhandler_io
label|:
name|ioError
argument_list|()
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"compress:unexpected error"
argument_list|)
expr_stmt|;
block|}
name|panic
argument_list|(
literal|"compress:end"
argument_list|)
expr_stmt|;
comment|/*notreached*/
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|Bool
name|uncompressStream
parameter_list|(
name|FILE
modifier|*
name|zStream
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|BZFILE
modifier|*
name|bzf
init|=
name|NULL
decl_stmt|;
name|Int32
name|bzerr
decl_stmt|,
name|bzerr_dummy
decl_stmt|,
name|ret
decl_stmt|,
name|nread
decl_stmt|,
name|streamNo
decl_stmt|,
name|i
decl_stmt|;
name|UChar
name|obuf
index|[
literal|5000
index|]
decl_stmt|;
name|UChar
name|unused
index|[
name|BZ_MAX_UNUSED
index|]
decl_stmt|;
name|Int32
name|nUnused
decl_stmt|;
name|void
modifier|*
name|unusedTmpV
decl_stmt|;
name|UChar
modifier|*
name|unusedTmp
decl_stmt|;
name|nUnused
operator|=
literal|0
expr_stmt|;
name|streamNo
operator|=
literal|0
expr_stmt|;
name|SET_BINARY_MODE
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|SET_BINARY_MODE
argument_list|(
name|zStream
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stream
argument_list|)
condition|)
goto|goto
name|errhandler_io
goto|;
if|if
condition|(
name|ferror
argument_list|(
name|zStream
argument_list|)
condition|)
goto|goto
name|errhandler_io
goto|;
while|while
condition|(
name|True
condition|)
block|{
name|bzf
operator|=
name|BZ2_bzReadOpen
argument_list|(
operator|&
name|bzerr
argument_list|,
name|zStream
argument_list|,
name|verbosity
argument_list|,
operator|(
name|int
operator|)
name|smallMode
argument_list|,
name|unused
argument_list|,
name|nUnused
argument_list|)
expr_stmt|;
if|if
condition|(
name|bzf
operator|==
name|NULL
operator|||
name|bzerr
operator|!=
name|BZ_OK
condition|)
goto|goto
name|errhandler
goto|;
name|streamNo
operator|++
expr_stmt|;
while|while
condition|(
name|bzerr
operator|==
name|BZ_OK
condition|)
block|{
name|nread
operator|=
name|BZ2_bzRead
argument_list|(
operator|&
name|bzerr
argument_list|,
name|bzf
argument_list|,
name|obuf
argument_list|,
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
name|bzerr
operator|==
name|BZ_DATA_ERROR_MAGIC
condition|)
goto|goto
name|trycat
goto|;
if|if
condition|(
operator|(
name|bzerr
operator|==
name|BZ_OK
operator|||
name|bzerr
operator|==
name|BZ_STREAM_END
operator|)
operator|&&
name|nread
operator|>
literal|0
condition|)
name|fwrite
argument_list|(
name|obuf
argument_list|,
sizeof|sizeof
argument_list|(
name|UChar
argument_list|)
argument_list|,
name|nread
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stream
argument_list|)
condition|)
goto|goto
name|errhandler_io
goto|;
block|}
if|if
condition|(
name|bzerr
operator|!=
name|BZ_STREAM_END
condition|)
goto|goto
name|errhandler
goto|;
name|BZ2_bzReadGetUnused
argument_list|(
operator|&
name|bzerr
argument_list|,
name|bzf
argument_list|,
operator|&
name|unusedTmpV
argument_list|,
operator|&
name|nUnused
argument_list|)
expr_stmt|;
if|if
condition|(
name|bzerr
operator|!=
name|BZ_OK
condition|)
name|panic
argument_list|(
literal|"decompress:bzReadGetUnused"
argument_list|)
expr_stmt|;
name|unusedTmp
operator|=
operator|(
name|UChar
operator|*
operator|)
name|unusedTmpV
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nUnused
condition|;
name|i
operator|++
control|)
name|unused
index|[
name|i
index|]
operator|=
name|unusedTmp
index|[
name|i
index|]
expr_stmt|;
name|BZ2_bzReadClose
argument_list|(
operator|&
name|bzerr
argument_list|,
name|bzf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bzerr
operator|!=
name|BZ_OK
condition|)
name|panic
argument_list|(
literal|"decompress:bzReadGetUnused"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nUnused
operator|==
literal|0
operator|&&
name|myfeof
argument_list|(
name|zStream
argument_list|)
condition|)
break|break;
block|}
name|closeok
label|:
if|if
condition|(
name|ferror
argument_list|(
name|zStream
argument_list|)
condition|)
goto|goto
name|errhandler_io
goto|;
if|if
condition|(
name|stream
operator|!=
name|stdout
condition|)
block|{
name|Int32
name|fd
init|=
name|fileno
argument_list|(
name|stream
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
goto|goto
name|errhandler_io
goto|;
name|applySavedFileAttrToOutputFile
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|fclose
argument_list|(
name|zStream
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|EOF
condition|)
goto|goto
name|errhandler_io
goto|;
if|if
condition|(
name|ferror
argument_list|(
name|stream
argument_list|)
condition|)
goto|goto
name|errhandler_io
goto|;
name|ret
operator|=
name|fflush
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|errhandler_io
goto|;
if|if
condition|(
name|stream
operator|!=
name|stdout
condition|)
block|{
name|ret
operator|=
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|outputHandleJustInCase
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|EOF
condition|)
goto|goto
name|errhandler_io
goto|;
block|}
name|outputHandleJustInCase
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|verbosity
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n    "
argument_list|)
expr_stmt|;
return|return
name|True
return|;
name|trycat
label|:
if|if
condition|(
name|forceOverwrite
condition|)
block|{
name|rewind
argument_list|(
name|zStream
argument_list|)
expr_stmt|;
while|while
condition|(
name|True
condition|)
block|{
if|if
condition|(
name|myfeof
argument_list|(
name|zStream
argument_list|)
condition|)
break|break;
name|nread
operator|=
name|fread
argument_list|(
name|obuf
argument_list|,
sizeof|sizeof
argument_list|(
name|UChar
argument_list|)
argument_list|,
literal|5000
argument_list|,
name|zStream
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|zStream
argument_list|)
condition|)
goto|goto
name|errhandler_io
goto|;
if|if
condition|(
name|nread
operator|>
literal|0
condition|)
name|fwrite
argument_list|(
name|obuf
argument_list|,
sizeof|sizeof
argument_list|(
name|UChar
argument_list|)
argument_list|,
name|nread
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stream
argument_list|)
condition|)
goto|goto
name|errhandler_io
goto|;
block|}
goto|goto
name|closeok
goto|;
block|}
name|errhandler
label|:
name|BZ2_bzReadClose
argument_list|(
operator|&
name|bzerr_dummy
argument_list|,
name|bzf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bzerr
condition|)
block|{
case|case
name|BZ_CONFIG_ERROR
case|:
name|configError
argument_list|()
expr_stmt|;
break|break;
case|case
name|BZ_IO_ERROR
case|:
name|errhandler_io
label|:
name|ioError
argument_list|()
expr_stmt|;
break|break;
case|case
name|BZ_DATA_ERROR
case|:
name|crcError
argument_list|()
expr_stmt|;
case|case
name|BZ_MEM_ERROR
case|:
name|outOfMemory
argument_list|()
expr_stmt|;
case|case
name|BZ_UNEXPECTED_EOF
case|:
name|compressedStreamEOF
argument_list|()
expr_stmt|;
case|case
name|BZ_DATA_ERROR_MAGIC
case|:
if|if
condition|(
name|zStream
operator|!=
name|stdin
condition|)
name|fclose
argument_list|(
name|zStream
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream
operator|!=
name|stdout
condition|)
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|streamNo
operator|==
literal|1
condition|)
block|{
return|return
name|False
return|;
block|}
else|else
block|{
if|if
condition|(
name|noisy
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s: %s: trailing garbage after EOF ignored\n"
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|)
expr_stmt|;
return|return
name|True
return|;
block|}
default|default:
name|panic
argument_list|(
literal|"decompress:unexpected error"
argument_list|)
expr_stmt|;
block|}
name|panic
argument_list|(
literal|"decompress:end"
argument_list|)
expr_stmt|;
return|return
name|True
return|;
comment|/*notreached*/
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|Bool
name|testStream
parameter_list|(
name|FILE
modifier|*
name|zStream
parameter_list|)
block|{
name|BZFILE
modifier|*
name|bzf
init|=
name|NULL
decl_stmt|;
name|Int32
name|bzerr
decl_stmt|,
name|bzerr_dummy
decl_stmt|,
name|ret
decl_stmt|,
name|nread
decl_stmt|,
name|streamNo
decl_stmt|,
name|i
decl_stmt|;
name|UChar
name|obuf
index|[
literal|5000
index|]
decl_stmt|;
name|UChar
name|unused
index|[
name|BZ_MAX_UNUSED
index|]
decl_stmt|;
name|Int32
name|nUnused
decl_stmt|;
name|void
modifier|*
name|unusedTmpV
decl_stmt|;
name|UChar
modifier|*
name|unusedTmp
decl_stmt|;
name|nUnused
operator|=
literal|0
expr_stmt|;
name|streamNo
operator|=
literal|0
expr_stmt|;
name|SET_BINARY_MODE
argument_list|(
name|zStream
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|zStream
argument_list|)
condition|)
goto|goto
name|errhandler_io
goto|;
while|while
condition|(
name|True
condition|)
block|{
name|bzf
operator|=
name|BZ2_bzReadOpen
argument_list|(
operator|&
name|bzerr
argument_list|,
name|zStream
argument_list|,
name|verbosity
argument_list|,
operator|(
name|int
operator|)
name|smallMode
argument_list|,
name|unused
argument_list|,
name|nUnused
argument_list|)
expr_stmt|;
if|if
condition|(
name|bzf
operator|==
name|NULL
operator|||
name|bzerr
operator|!=
name|BZ_OK
condition|)
goto|goto
name|errhandler
goto|;
name|streamNo
operator|++
expr_stmt|;
while|while
condition|(
name|bzerr
operator|==
name|BZ_OK
condition|)
block|{
name|nread
operator|=
name|BZ2_bzRead
argument_list|(
operator|&
name|bzerr
argument_list|,
name|bzf
argument_list|,
name|obuf
argument_list|,
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
name|bzerr
operator|==
name|BZ_DATA_ERROR_MAGIC
condition|)
goto|goto
name|errhandler
goto|;
block|}
if|if
condition|(
name|bzerr
operator|!=
name|BZ_STREAM_END
condition|)
goto|goto
name|errhandler
goto|;
name|BZ2_bzReadGetUnused
argument_list|(
operator|&
name|bzerr
argument_list|,
name|bzf
argument_list|,
operator|&
name|unusedTmpV
argument_list|,
operator|&
name|nUnused
argument_list|)
expr_stmt|;
if|if
condition|(
name|bzerr
operator|!=
name|BZ_OK
condition|)
name|panic
argument_list|(
literal|"test:bzReadGetUnused"
argument_list|)
expr_stmt|;
name|unusedTmp
operator|=
operator|(
name|UChar
operator|*
operator|)
name|unusedTmpV
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nUnused
condition|;
name|i
operator|++
control|)
name|unused
index|[
name|i
index|]
operator|=
name|unusedTmp
index|[
name|i
index|]
expr_stmt|;
name|BZ2_bzReadClose
argument_list|(
operator|&
name|bzerr
argument_list|,
name|bzf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bzerr
operator|!=
name|BZ_OK
condition|)
name|panic
argument_list|(
literal|"test:bzReadGetUnused"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nUnused
operator|==
literal|0
operator|&&
name|myfeof
argument_list|(
name|zStream
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|zStream
argument_list|)
condition|)
goto|goto
name|errhandler_io
goto|;
name|ret
operator|=
name|fclose
argument_list|(
name|zStream
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|EOF
condition|)
goto|goto
name|errhandler_io
goto|;
if|if
condition|(
name|verbosity
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n    "
argument_list|)
expr_stmt|;
return|return
name|True
return|;
name|errhandler
label|:
name|BZ2_bzReadClose
argument_list|(
operator|&
name|bzerr_dummy
argument_list|,
name|bzf
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbosity
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: "
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bzerr
condition|)
block|{
case|case
name|BZ_CONFIG_ERROR
case|:
name|configError
argument_list|()
expr_stmt|;
break|break;
case|case
name|BZ_IO_ERROR
case|:
name|errhandler_io
label|:
name|ioError
argument_list|()
expr_stmt|;
break|break;
case|case
name|BZ_DATA_ERROR
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"data integrity (CRC) error in data\n"
argument_list|)
expr_stmt|;
return|return
name|False
return|;
case|case
name|BZ_MEM_ERROR
case|:
name|outOfMemory
argument_list|()
expr_stmt|;
case|case
name|BZ_UNEXPECTED_EOF
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"file ends unexpectedly\n"
argument_list|)
expr_stmt|;
return|return
name|False
return|;
case|case
name|BZ_DATA_ERROR_MAGIC
case|:
if|if
condition|(
name|zStream
operator|!=
name|stdin
condition|)
name|fclose
argument_list|(
name|zStream
argument_list|)
expr_stmt|;
if|if
condition|(
name|streamNo
operator|==
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bad magic number (file not created by bzip2)\n"
argument_list|)
expr_stmt|;
return|return
name|False
return|;
block|}
else|else
block|{
if|if
condition|(
name|noisy
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"trailing garbage after EOF ignored\n"
argument_list|)
expr_stmt|;
return|return
name|True
return|;
block|}
default|default:
name|panic
argument_list|(
literal|"test:unexpected error"
argument_list|)
expr_stmt|;
block|}
name|panic
argument_list|(
literal|"test:end"
argument_list|)
expr_stmt|;
return|return
name|True
return|;
comment|/*notreached*/
block|}
end_function

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_comment
comment|/*--- Error [non-] handling grunge                ---*/
end_comment

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|setExit
parameter_list|(
name|Int32
name|v
parameter_list|)
block|{
if|if
condition|(
name|v
operator|>
name|exitValue
condition|)
name|exitValue
operator|=
name|v
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|cadvise
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|noisy
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nIt is possible that the compressed file(s) have become corrupted.\n"
literal|"You can use the -tvv option to test integrity of such files.\n\n"
literal|"You can use the `bzip2recover' program to attempt to recover\n"
literal|"data from undamaged sections of corrupted files.\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|showFileNames
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|noisy
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tInput file = %s, output file = %s\n"
argument_list|,
name|inName
argument_list|,
name|outName
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|cleanUpAndFail
parameter_list|(
name|Int32
name|ec
parameter_list|)
block|{
name|IntNative
name|retVal
decl_stmt|;
name|struct
name|MY_STAT
name|statBuf
decl_stmt|;
if|if
condition|(
name|srcMode
operator|==
name|SM_F2F
operator|&&
name|opMode
operator|!=
name|OM_TEST
operator|&&
name|deleteOutputOnInterrupt
condition|)
block|{
comment|/* Check whether input file still exists.  Delete output file          only if input exists to avoid loss of data.  Joerg Prante, 5          January 2002.  (JRS 06-Jan-2002: other changes in 1.0.2 mean          this is less likely to happen.  But to be ultra-paranoid, we          do the check anyway.)  */
name|retVal
operator|=
name|MY_STAT
argument_list|(
name|inName
argument_list|,
operator|&
name|statBuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|retVal
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|noisy
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Deleting output file %s, if it exists.\n"
argument_list|,
name|progName
argument_list|,
name|outName
argument_list|)
expr_stmt|;
if|if
condition|(
name|outputHandleJustInCase
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|outputHandleJustInCase
argument_list|)
expr_stmt|;
name|retVal
operator|=
name|remove
argument_list|(
name|outName
argument_list|)
expr_stmt|;
if|if
condition|(
name|retVal
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: WARNING: deletion of output file "
literal|"(apparently) failed.\n"
argument_list|,
name|progName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: WARNING: deletion of output file suppressed\n"
argument_list|,
name|progName
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:    since input file no longer exists.  Output file\n"
argument_list|,
name|progName
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:    `%s' may be incomplete.\n"
argument_list|,
name|progName
argument_list|,
name|outName
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:    I suggest doing an integrity test (bzip2 -tv)"
literal|" of it.\n"
argument_list|,
name|progName
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|noisy
operator|&&
name|numFileNames
operator|>
literal|0
operator|&&
name|numFilesProcessed
operator|<
name|numFileNames
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: WARNING: some files have not been processed:\n"
literal|"%s:    %d specified on command line, %d not processed yet.\n\n"
argument_list|,
name|progName
argument_list|,
name|progName
argument_list|,
name|numFileNames
argument_list|,
name|numFileNames
operator|-
name|numFilesProcessed
argument_list|)
expr_stmt|;
block|}
name|setExit
argument_list|(
name|ec
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exitValue
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|panic
parameter_list|(
specifier|const
name|Char
modifier|*
name|s
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s: PANIC -- internal consistency error:\n"
literal|"\t%s\n"
literal|"\tThis is a BUG.  Please report it to me at:\n"
literal|"\tjseward@bzip.org\n"
argument_list|,
name|progName
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|showFileNames
argument_list|()
expr_stmt|;
name|cleanUpAndFail
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|crcError
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s: Data integrity error when decompressing.\n"
argument_list|,
name|progName
argument_list|)
expr_stmt|;
name|showFileNames
argument_list|()
expr_stmt|;
name|cadvise
argument_list|()
expr_stmt|;
name|cleanUpAndFail
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|compressedStreamEOF
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|noisy
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s: Compressed file ends unexpectedly;\n\t"
literal|"perhaps it is corrupted?  *Possible* reason follows.\n"
argument_list|,
name|progName
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|progName
argument_list|)
expr_stmt|;
name|showFileNames
argument_list|()
expr_stmt|;
name|cadvise
argument_list|()
expr_stmt|;
block|}
name|cleanUpAndFail
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|ioError
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s: I/O or other error, bailing out.  "
literal|"Possible reason follows.\n"
argument_list|,
name|progName
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|progName
argument_list|)
expr_stmt|;
name|showFileNames
argument_list|()
expr_stmt|;
name|cleanUpAndFail
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|mySignalCatcher
parameter_list|(
name|IntNative
name|n
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s: Control-C or similar caught, quitting.\n"
argument_list|,
name|progName
argument_list|)
expr_stmt|;
name|cleanUpAndFail
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|mySIGSEGVorSIGBUScatcher
parameter_list|(
name|IntNative
name|n
parameter_list|)
block|{
if|if
condition|(
name|opMode
operator|==
name|OM_Z
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s: Caught a SIGSEGV or SIGBUS whilst compressing.\n"
literal|"\n"
literal|"   Possible causes are (most likely first):\n"
literal|"   (1) This computer has unreliable memory or cache hardware\n"
literal|"       (a surprisingly common problem; try a different machine.)\n"
literal|"   (2) A bug in the compiler used to create this executable\n"
literal|"       (unlikely, if you didn't compile bzip2 yourself.)\n"
literal|"   (3) A real bug in bzip2 -- I hope this should never be the case.\n"
literal|"   The user's manual, Section 4.3, has more info on (1) and (2).\n"
literal|"   \n"
literal|"   If you suspect this is a bug in bzip2, or are unsure about (1)\n"
literal|"   or (2), feel free to report it to me at: jseward@bzip.org.\n"
literal|"   Section 4.3 of the user's manual describes the info a useful\n"
literal|"   bug report should have.  If the manual is available on your\n"
literal|"   system, please try and read it before mailing me.  If you don't\n"
literal|"   have the manual or can't be bothered to read it, mail me anyway.\n"
literal|"\n"
argument_list|,
name|progName
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s: Caught a SIGSEGV or SIGBUS whilst decompressing.\n"
literal|"\n"
literal|"   Possible causes are (most likely first):\n"
literal|"   (1) The compressed data is corrupted, and bzip2's usual checks\n"
literal|"       failed to detect this.  Try bzip2 -tvv my_file.bz2.\n"
literal|"   (2) This computer has unreliable memory or cache hardware\n"
literal|"       (a surprisingly common problem; try a different machine.)\n"
literal|"   (3) A bug in the compiler used to create this executable\n"
literal|"       (unlikely, if you didn't compile bzip2 yourself.)\n"
literal|"   (4) A real bug in bzip2 -- I hope this should never be the case.\n"
literal|"   The user's manual, Section 4.3, has more info on (2) and (3).\n"
literal|"   \n"
literal|"   If you suspect this is a bug in bzip2, or are unsure about (2)\n"
literal|"   or (3), feel free to report it to me at: jseward@bzip.org.\n"
literal|"   Section 4.3 of the user's manual describes the info a useful\n"
literal|"   bug report should have.  If the manual is available on your\n"
literal|"   system, please try and read it before mailing me.  If you don't\n"
literal|"   have the manual or can't be bothered to read it, mail me anyway.\n"
literal|"\n"
argument_list|,
name|progName
argument_list|)
expr_stmt|;
name|showFileNames
argument_list|()
expr_stmt|;
if|if
condition|(
name|opMode
operator|==
name|OM_Z
condition|)
name|cleanUpAndFail
argument_list|(
literal|3
argument_list|)
expr_stmt|;
else|else
block|{
name|cadvise
argument_list|()
expr_stmt|;
name|cleanUpAndFail
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|outOfMemory
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s: couldn't allocate enough memory\n"
argument_list|,
name|progName
argument_list|)
expr_stmt|;
name|showFileNames
argument_list|()
expr_stmt|;
name|cleanUpAndFail
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|configError
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bzip2: I'm not configured correctly for this platform!\n"
literal|"\tI require Int32, Int16 and Char to have sizes\n"
literal|"\tof 4, 2 and 1 bytes to run properly, and they don't.\n"
literal|"\tProbably you can fix this by defining them correctly,\n"
literal|"\tand recompiling.  Bye!\n"
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exitValue
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_comment
comment|/*--- The main driver machinery                   ---*/
end_comment

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_comment
comment|/* All rather crufty.  The main problem is that input files    are stat()d multiple times before use.  This should be    cleaned up.  */
end_comment

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|pad
parameter_list|(
name|Char
modifier|*
name|s
parameter_list|)
block|{
name|Int32
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|Int32
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
operator|>=
name|longestFileName
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|longestFileName
operator|-
operator|(
name|Int32
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|copyFileName
parameter_list|(
name|Char
modifier|*
name|to
parameter_list|,
name|Char
modifier|*
name|from
parameter_list|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|from
argument_list|)
operator|>
name|FILE_NAME_LEN
operator|-
literal|10
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bzip2: file name\n`%s'\n"
literal|"is suspiciously (more than %d chars) long.\n"
literal|"Try using a reasonable file name instead.  Sorry! :-)\n"
argument_list|,
name|from
argument_list|,
name|FILE_NAME_LEN
operator|-
literal|10
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exitValue
argument_list|)
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|FILE_NAME_LEN
operator|-
literal|10
argument_list|)
expr_stmt|;
name|to
index|[
name|FILE_NAME_LEN
operator|-
literal|10
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|Bool
name|fileExists
parameter_list|(
name|Char
modifier|*
name|name
parameter_list|)
block|{
name|FILE
modifier|*
name|tmp
init|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"rb"
argument_list|)
decl_stmt|;
name|Bool
name|exists
init|=
operator|(
name|tmp
operator|!=
name|NULL
operator|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|exists
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_comment
comment|/* Open an output file safely with O_EXCL and good permissions.    This avoids a race condition in versions< 1.0.2, in which    the file was first opened and then had its interim permissions    set safely.  We instead use open() to create the file with    the interim permissions required. (--- --- rw-).     For non-Unix platforms, if we are not worrying about    security issues, simple this simply behaves like fopen. */
end_comment

begin_function
specifier|static
name|FILE
modifier|*
name|fopen_output_safely
parameter_list|(
name|Char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|mode
parameter_list|)
block|{
if|#
directive|if
name|BZ_UNIX
name|FILE
modifier|*
name|fp
decl_stmt|;
name|IntNative
name|fh
decl_stmt|;
name|fh
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
name|S_IWUSR
operator||
name|S_IRUSR
argument_list|)
expr_stmt|;
if|if
condition|(
name|fh
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
name|fp
operator|=
name|fdopen
argument_list|(
name|fh
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|close
argument_list|(
name|fh
argument_list|)
expr_stmt|;
return|return
name|fp
return|;
else|#
directive|else
return|return
name|fopen
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_comment
comment|/*--   if in doubt, return True --*/
end_comment

begin_function
specifier|static
name|Bool
name|notAStandardFile
parameter_list|(
name|Char
modifier|*
name|name
parameter_list|)
block|{
name|IntNative
name|i
decl_stmt|;
name|struct
name|MY_STAT
name|statBuf
decl_stmt|;
name|i
operator|=
name|MY_LSTAT
argument_list|(
name|name
argument_list|,
operator|&
name|statBuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
return|return
name|True
return|;
if|if
condition|(
name|MY_S_ISREG
argument_list|(
name|statBuf
operator|.
name|st_mode
argument_list|)
condition|)
return|return
name|False
return|;
return|return
name|True
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_comment
comment|/*--   rac 11/21/98 see if file has hard links to it --*/
end_comment

begin_function
specifier|static
name|Int32
name|countHardLinks
parameter_list|(
name|Char
modifier|*
name|name
parameter_list|)
block|{
name|IntNative
name|i
decl_stmt|;
name|struct
name|MY_STAT
name|statBuf
decl_stmt|;
name|i
operator|=
name|MY_LSTAT
argument_list|(
name|name
argument_list|,
operator|&
name|statBuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|statBuf
operator|.
name|st_nlink
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_comment
comment|/* Copy modification date, access date, permissions and owner from the    source to destination file.  We have to copy this meta-info off    into fileMetaInfo before starting to compress / decompress it,    because doing it afterwards means we get the wrong access time.     To complicate matters, in compress() and decompress() below, the    sequence of tests preceding the call to saveInputFileMetaInfo()    involves calling fileExists(), which in turn establishes its result    by attempting to fopen() the file, and if successful, immediately    fclose()ing it again.  So we have to assume that the fopen() call    does not cause the access time field to be updated.     Reading of the man page for stat() (man 2 stat) on RedHat 7.2 seems    to imply that merely doing open() will not affect the access time.    Therefore we merely need to hope that the C library only does    open() as a result of fopen(), and not any kind of read()-ahead    cleverness.     It sounds pretty fragile to me.  Whether this carries across    robustly to arbitrary Unix-like platforms (or even works robustly    on this one, RedHat 7.2) is unknown to me.  Nevertheless ...   */
end_comment

begin_if
if|#
directive|if
name|BZ_UNIX
end_if

begin_decl_stmt
specifier|static
name|struct
name|MY_STAT
name|fileMetaInfo
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|saveInputFileMetaInfo
parameter_list|(
name|Char
modifier|*
name|srcName
parameter_list|)
block|{
if|#
directive|if
name|BZ_UNIX
name|IntNative
name|retVal
decl_stmt|;
comment|/* Note use of stat here, not lstat. */
name|retVal
operator|=
name|MY_STAT
argument_list|(
name|srcName
argument_list|,
operator|&
name|fileMetaInfo
argument_list|)
expr_stmt|;
name|ERROR_IF_NOT_ZERO
argument_list|(
name|retVal
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|applySavedTimeInfoToOutputFile
parameter_list|(
name|Char
modifier|*
name|dstName
parameter_list|)
block|{
if|#
directive|if
name|BZ_UNIX
name|IntNative
name|retVal
decl_stmt|;
name|struct
name|utimbuf
name|uTimBuf
decl_stmt|;
name|uTimBuf
operator|.
name|actime
operator|=
name|fileMetaInfo
operator|.
name|st_atime
expr_stmt|;
name|uTimBuf
operator|.
name|modtime
operator|=
name|fileMetaInfo
operator|.
name|st_mtime
expr_stmt|;
name|retVal
operator|=
name|utime
argument_list|(
name|dstName
argument_list|,
operator|&
name|uTimBuf
argument_list|)
expr_stmt|;
name|ERROR_IF_NOT_ZERO
argument_list|(
name|retVal
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|applySavedFileAttrToOutputFile
parameter_list|(
name|IntNative
name|fd
parameter_list|)
block|{
if|#
directive|if
name|BZ_UNIX
name|IntNative
name|retVal
decl_stmt|;
name|retVal
operator|=
name|fchmod
argument_list|(
name|fd
argument_list|,
name|fileMetaInfo
operator|.
name|st_mode
argument_list|)
expr_stmt|;
name|ERROR_IF_NOT_ZERO
argument_list|(
name|retVal
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fchown
argument_list|(
name|fd
argument_list|,
name|fileMetaInfo
operator|.
name|st_uid
argument_list|,
name|fileMetaInfo
operator|.
name|st_gid
argument_list|)
expr_stmt|;
comment|/* chown() will in many cases return with EPERM, which can       be safely ignored.    */
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|Bool
name|containsDubiousChars
parameter_list|(
name|Char
modifier|*
name|name
parameter_list|)
block|{
if|#
directive|if
name|BZ_UNIX
comment|/* On unix, files can contain any characters and the file expansion     * is performed by the shell.     */
return|return
name|False
return|;
else|#
directive|else
comment|/* ! BZ_UNIX */
comment|/* On non-unix (Win* platforms), wildcard characters are not allowed in      * filenames.     */
for|for
control|(
init|;
operator|*
name|name
operator|!=
literal|'\0'
condition|;
name|name
operator|++
control|)
if|if
condition|(
operator|*
name|name
operator|==
literal|'?'
operator|||
operator|*
name|name
operator|==
literal|'*'
condition|)
return|return
name|True
return|;
return|return
name|False
return|;
endif|#
directive|endif
comment|/* BZ_UNIX */
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_define
define|#
directive|define
name|BZ_N_SUFFIX_PAIRS
value|4
end_define

begin_decl_stmt
specifier|const
name|Char
modifier|*
name|zSuffix
index|[
name|BZ_N_SUFFIX_PAIRS
index|]
init|=
block|{
literal|".bz2"
block|,
literal|".bz"
block|,
literal|".tbz2"
block|,
literal|".tbz"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|Char
modifier|*
name|unzSuffix
index|[
name|BZ_N_SUFFIX_PAIRS
index|]
init|=
block|{
literal|""
block|,
literal|""
block|,
literal|".tar"
block|,
literal|".tar"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Bool
name|hasSuffix
parameter_list|(
name|Char
modifier|*
name|s
parameter_list|,
specifier|const
name|Char
modifier|*
name|suffix
parameter_list|)
block|{
name|Int32
name|ns
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|Int32
name|nx
init|=
name|strlen
argument_list|(
name|suffix
argument_list|)
decl_stmt|;
if|if
condition|(
name|ns
operator|<
name|nx
condition|)
return|return
name|False
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
operator|+
name|ns
operator|-
name|nx
argument_list|,
name|suffix
argument_list|)
operator|==
literal|0
condition|)
return|return
name|True
return|;
return|return
name|False
return|;
block|}
end_function

begin_function
specifier|static
name|Bool
name|mapSuffix
parameter_list|(
name|Char
modifier|*
name|name
parameter_list|,
specifier|const
name|Char
modifier|*
name|oldSuffix
parameter_list|,
specifier|const
name|Char
modifier|*
name|newSuffix
parameter_list|)
block|{
if|if
condition|(
operator|!
name|hasSuffix
argument_list|(
name|name
argument_list|,
name|oldSuffix
argument_list|)
condition|)
return|return
name|False
return|;
name|name
index|[
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
name|strlen
argument_list|(
name|oldSuffix
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
name|newSuffix
argument_list|)
expr_stmt|;
return|return
name|True
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|compress
parameter_list|(
name|Char
modifier|*
name|name
parameter_list|)
block|{
name|FILE
modifier|*
name|inStr
decl_stmt|;
name|FILE
modifier|*
name|outStr
decl_stmt|;
name|Int32
name|n
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|MY_STAT
name|statBuf
decl_stmt|;
name|deleteOutputOnInterrupt
operator|=
name|False
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|&&
name|srcMode
operator|!=
name|SM_I2O
condition|)
name|panic
argument_list|(
literal|"compress: bad modes\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|srcMode
condition|)
block|{
case|case
name|SM_I2O
case|:
name|copyFileName
argument_list|(
name|inName
argument_list|,
operator|(
name|Char
operator|*
operator|)
literal|"(stdin)"
argument_list|)
expr_stmt|;
name|copyFileName
argument_list|(
name|outName
argument_list|,
operator|(
name|Char
operator|*
operator|)
literal|"(stdout)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SM_F2F
case|:
name|copyFileName
argument_list|(
name|inName
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|copyFileName
argument_list|(
name|outName
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|outName
argument_list|,
literal|".bz2"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SM_F2O
case|:
name|copyFileName
argument_list|(
name|inName
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|copyFileName
argument_list|(
name|outName
argument_list|,
operator|(
name|Char
operator|*
operator|)
literal|"(stdout)"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|srcMode
operator|!=
name|SM_I2O
operator|&&
name|containsDubiousChars
argument_list|(
name|inName
argument_list|)
condition|)
block|{
if|if
condition|(
name|noisy
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: There are no files matching `%s'.\n"
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|srcMode
operator|!=
name|SM_I2O
operator|&&
operator|!
name|fileExists
argument_list|(
name|inName
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't open input file %s: %s.\n"
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BZ_N_SUFFIX_PAIRS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hasSuffix
argument_list|(
name|inName
argument_list|,
name|zSuffix
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|noisy
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Input file %s already has %s suffix.\n"
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|,
name|zSuffix
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|srcMode
operator|==
name|SM_F2F
operator|||
name|srcMode
operator|==
name|SM_F2O
condition|)
block|{
name|MY_STAT
argument_list|(
name|inName
argument_list|,
operator|&
name|statBuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|MY_S_ISDIR
argument_list|(
name|statBuf
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Input file %s is a directory.\n"
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|srcMode
operator|==
name|SM_F2F
operator|&&
operator|!
name|forceOverwrite
operator|&&
name|notAStandardFile
argument_list|(
name|inName
argument_list|)
condition|)
block|{
if|if
condition|(
name|noisy
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Input file %s is not a normal file.\n"
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|srcMode
operator|==
name|SM_F2F
operator|&&
name|fileExists
argument_list|(
name|outName
argument_list|)
condition|)
block|{
if|if
condition|(
name|forceOverwrite
condition|)
block|{
name|remove
argument_list|(
name|outName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Output file %s already exists.\n"
argument_list|,
name|progName
argument_list|,
name|outName
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|srcMode
operator|==
name|SM_F2F
operator|&&
operator|!
name|forceOverwrite
operator|&&
operator|(
name|n
operator|=
name|countHardLinks
argument_list|(
name|inName
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Input file %s has %d other link%s.\n"
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|,
name|n
argument_list|,
name|n
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|srcMode
operator|==
name|SM_F2F
condition|)
block|{
comment|/* Save the file's meta-info before we open it.  Doing it later          means we mess up the access times. */
name|saveInputFileMetaInfo
argument_list|(
name|inName
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|srcMode
condition|)
block|{
case|case
name|SM_I2O
case|:
name|inStr
operator|=
name|stdin
expr_stmt|;
name|outStr
operator|=
name|stdout
expr_stmt|;
if|if
condition|(
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: I won't write compressed data to a terminal.\n"
argument_list|,
name|progName
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: For help, type: `%s --help'.\n"
argument_list|,
name|progName
argument_list|,
name|progName
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
break|break;
case|case
name|SM_F2O
case|:
name|inStr
operator|=
name|fopen
argument_list|(
name|inName
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
name|outStr
operator|=
name|stdout
expr_stmt|;
if|if
condition|(
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: I won't write compressed data to a terminal.\n"
argument_list|,
name|progName
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: For help, type: `%s --help'.\n"
argument_list|,
name|progName
argument_list|,
name|progName
argument_list|)
expr_stmt|;
if|if
condition|(
name|inStr
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|inStr
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
if|if
condition|(
name|inStr
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't open input file %s: %s.\n"
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
break|break;
case|case
name|SM_F2F
case|:
name|inStr
operator|=
name|fopen
argument_list|(
name|inName
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
name|outStr
operator|=
name|fopen_output_safely
argument_list|(
name|outName
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|outStr
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't create output file %s: %s.\n"
argument_list|,
name|progName
argument_list|,
name|outName
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inStr
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|inStr
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|inStr
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't open input file %s: %s.\n"
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|outStr
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|outStr
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"compress: bad srcMode"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|verbosity
operator|>=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %s: "
argument_list|,
name|inName
argument_list|)
expr_stmt|;
name|pad
argument_list|(
name|inName
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
comment|/*--- Now the input and output handles are sane.  Do the Biz. ---*/
name|outputHandleJustInCase
operator|=
name|outStr
expr_stmt|;
name|deleteOutputOnInterrupt
operator|=
name|True
expr_stmt|;
name|compressStream
argument_list|(
name|inStr
argument_list|,
name|outStr
argument_list|)
expr_stmt|;
name|outputHandleJustInCase
operator|=
name|NULL
expr_stmt|;
comment|/*--- If there was an I/O error, we won't get here. ---*/
if|if
condition|(
name|srcMode
operator|==
name|SM_F2F
condition|)
block|{
name|applySavedTimeInfoToOutputFile
argument_list|(
name|outName
argument_list|)
expr_stmt|;
name|deleteOutputOnInterrupt
operator|=
name|False
expr_stmt|;
if|if
condition|(
operator|!
name|keepInputFiles
condition|)
block|{
name|IntNative
name|retVal
init|=
name|remove
argument_list|(
name|inName
argument_list|)
decl_stmt|;
name|ERROR_IF_NOT_ZERO
argument_list|(
name|retVal
argument_list|)
expr_stmt|;
block|}
block|}
name|deleteOutputOnInterrupt
operator|=
name|False
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|uncompress
parameter_list|(
name|Char
modifier|*
name|name
parameter_list|)
block|{
name|FILE
modifier|*
name|inStr
decl_stmt|;
name|FILE
modifier|*
name|outStr
decl_stmt|;
name|Int32
name|n
decl_stmt|,
name|i
decl_stmt|;
name|Bool
name|magicNumberOK
decl_stmt|;
name|Bool
name|cantGuess
decl_stmt|;
name|struct
name|MY_STAT
name|statBuf
decl_stmt|;
name|deleteOutputOnInterrupt
operator|=
name|False
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|&&
name|srcMode
operator|!=
name|SM_I2O
condition|)
name|panic
argument_list|(
literal|"uncompress: bad modes\n"
argument_list|)
expr_stmt|;
name|cantGuess
operator|=
name|False
expr_stmt|;
switch|switch
condition|(
name|srcMode
condition|)
block|{
case|case
name|SM_I2O
case|:
name|copyFileName
argument_list|(
name|inName
argument_list|,
operator|(
name|Char
operator|*
operator|)
literal|"(stdin)"
argument_list|)
expr_stmt|;
name|copyFileName
argument_list|(
name|outName
argument_list|,
operator|(
name|Char
operator|*
operator|)
literal|"(stdout)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SM_F2F
case|:
name|copyFileName
argument_list|(
name|inName
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|copyFileName
argument_list|(
name|outName
argument_list|,
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BZ_N_SUFFIX_PAIRS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|mapSuffix
argument_list|(
name|outName
argument_list|,
name|zSuffix
index|[
name|i
index|]
argument_list|,
name|unzSuffix
index|[
name|i
index|]
argument_list|)
condition|)
goto|goto
name|zzz
goto|;
name|cantGuess
operator|=
name|True
expr_stmt|;
name|strcat
argument_list|(
name|outName
argument_list|,
literal|".out"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SM_F2O
case|:
name|copyFileName
argument_list|(
name|inName
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|copyFileName
argument_list|(
name|outName
argument_list|,
operator|(
name|Char
operator|*
operator|)
literal|"(stdout)"
argument_list|)
expr_stmt|;
break|break;
block|}
name|zzz
label|:
if|if
condition|(
name|srcMode
operator|!=
name|SM_I2O
operator|&&
name|containsDubiousChars
argument_list|(
name|inName
argument_list|)
condition|)
block|{
if|if
condition|(
name|noisy
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: There are no files matching `%s'.\n"
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|srcMode
operator|!=
name|SM_I2O
operator|&&
operator|!
name|fileExists
argument_list|(
name|inName
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't open input file %s: %s.\n"
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|srcMode
operator|==
name|SM_F2F
operator|||
name|srcMode
operator|==
name|SM_F2O
condition|)
block|{
name|MY_STAT
argument_list|(
name|inName
argument_list|,
operator|&
name|statBuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|MY_S_ISDIR
argument_list|(
name|statBuf
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Input file %s is a directory.\n"
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|srcMode
operator|==
name|SM_F2F
operator|&&
operator|!
name|forceOverwrite
operator|&&
name|notAStandardFile
argument_list|(
name|inName
argument_list|)
condition|)
block|{
if|if
condition|(
name|noisy
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Input file %s is not a normal file.\n"
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
comment|/* srcMode == SM_F2F implied&& */
name|cantGuess
condition|)
block|{
if|if
condition|(
name|noisy
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't guess original name for %s -- using %s\n"
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|,
name|outName
argument_list|)
expr_stmt|;
comment|/* just a warning, no return */
block|}
if|if
condition|(
name|srcMode
operator|==
name|SM_F2F
operator|&&
name|fileExists
argument_list|(
name|outName
argument_list|)
condition|)
block|{
if|if
condition|(
name|forceOverwrite
condition|)
block|{
name|remove
argument_list|(
name|outName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Output file %s already exists.\n"
argument_list|,
name|progName
argument_list|,
name|outName
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|srcMode
operator|==
name|SM_F2F
operator|&&
operator|!
name|forceOverwrite
operator|&&
operator|(
name|n
operator|=
name|countHardLinks
argument_list|(
name|inName
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Input file %s has %d other link%s.\n"
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|,
name|n
argument_list|,
name|n
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|srcMode
operator|==
name|SM_F2F
condition|)
block|{
comment|/* Save the file's meta-info before we open it.  Doing it later          means we mess up the access times. */
name|saveInputFileMetaInfo
argument_list|(
name|inName
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|srcMode
condition|)
block|{
case|case
name|SM_I2O
case|:
name|inStr
operator|=
name|stdin
expr_stmt|;
name|outStr
operator|=
name|stdout
expr_stmt|;
if|if
condition|(
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: I won't read compressed data from a terminal.\n"
argument_list|,
name|progName
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: For help, type: `%s --help'.\n"
argument_list|,
name|progName
argument_list|,
name|progName
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
break|break;
case|case
name|SM_F2O
case|:
name|inStr
operator|=
name|fopen
argument_list|(
name|inName
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
name|outStr
operator|=
name|stdout
expr_stmt|;
if|if
condition|(
name|inStr
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't open input file %s:%s.\n"
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inStr
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|inStr
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
break|break;
case|case
name|SM_F2F
case|:
name|inStr
operator|=
name|fopen
argument_list|(
name|inName
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
name|outStr
operator|=
name|fopen_output_safely
argument_list|(
name|outName
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|outStr
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't create output file %s: %s.\n"
argument_list|,
name|progName
argument_list|,
name|outName
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inStr
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|inStr
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|inStr
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't open input file %s: %s.\n"
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|outStr
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|outStr
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"uncompress: bad srcMode"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|verbosity
operator|>=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %s: "
argument_list|,
name|inName
argument_list|)
expr_stmt|;
name|pad
argument_list|(
name|inName
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
comment|/*--- Now the input and output handles are sane.  Do the Biz. ---*/
name|outputHandleJustInCase
operator|=
name|outStr
expr_stmt|;
name|deleteOutputOnInterrupt
operator|=
name|True
expr_stmt|;
name|magicNumberOK
operator|=
name|uncompressStream
argument_list|(
name|inStr
argument_list|,
name|outStr
argument_list|)
expr_stmt|;
name|outputHandleJustInCase
operator|=
name|NULL
expr_stmt|;
comment|/*--- If there was an I/O error, we won't get here. ---*/
if|if
condition|(
name|magicNumberOK
condition|)
block|{
if|if
condition|(
name|srcMode
operator|==
name|SM_F2F
condition|)
block|{
name|applySavedTimeInfoToOutputFile
argument_list|(
name|outName
argument_list|)
expr_stmt|;
name|deleteOutputOnInterrupt
operator|=
name|False
expr_stmt|;
if|if
condition|(
operator|!
name|keepInputFiles
condition|)
block|{
name|IntNative
name|retVal
init|=
name|remove
argument_list|(
name|inName
argument_list|)
decl_stmt|;
name|ERROR_IF_NOT_ZERO
argument_list|(
name|retVal
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|unzFailsExist
operator|=
name|True
expr_stmt|;
name|deleteOutputOnInterrupt
operator|=
name|False
expr_stmt|;
if|if
condition|(
name|srcMode
operator|==
name|SM_F2F
condition|)
block|{
name|IntNative
name|retVal
init|=
name|remove
argument_list|(
name|outName
argument_list|)
decl_stmt|;
name|ERROR_IF_NOT_ZERO
argument_list|(
name|retVal
argument_list|)
expr_stmt|;
block|}
block|}
name|deleteOutputOnInterrupt
operator|=
name|False
expr_stmt|;
if|if
condition|(
name|magicNumberOK
condition|)
block|{
if|if
condition|(
name|verbosity
operator|>=
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"done\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setExit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbosity
operator|>=
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"not a bzip2 file.\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s is not a bzip2 file.\n"
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|testf
parameter_list|(
name|Char
modifier|*
name|name
parameter_list|)
block|{
name|FILE
modifier|*
name|inStr
decl_stmt|;
name|Bool
name|allOK
decl_stmt|;
name|struct
name|MY_STAT
name|statBuf
decl_stmt|;
name|deleteOutputOnInterrupt
operator|=
name|False
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|&&
name|srcMode
operator|!=
name|SM_I2O
condition|)
name|panic
argument_list|(
literal|"testf: bad modes\n"
argument_list|)
expr_stmt|;
name|copyFileName
argument_list|(
name|outName
argument_list|,
operator|(
name|Char
operator|*
operator|)
literal|"(none)"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|srcMode
condition|)
block|{
case|case
name|SM_I2O
case|:
name|copyFileName
argument_list|(
name|inName
argument_list|,
operator|(
name|Char
operator|*
operator|)
literal|"(stdin)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SM_F2F
case|:
name|copyFileName
argument_list|(
name|inName
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|SM_F2O
case|:
name|copyFileName
argument_list|(
name|inName
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|srcMode
operator|!=
name|SM_I2O
operator|&&
name|containsDubiousChars
argument_list|(
name|inName
argument_list|)
condition|)
block|{
if|if
condition|(
name|noisy
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: There are no files matching `%s'.\n"
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|srcMode
operator|!=
name|SM_I2O
operator|&&
operator|!
name|fileExists
argument_list|(
name|inName
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't open input %s: %s.\n"
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|srcMode
operator|!=
name|SM_I2O
condition|)
block|{
name|MY_STAT
argument_list|(
name|inName
argument_list|,
operator|&
name|statBuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|MY_S_ISDIR
argument_list|(
name|statBuf
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Input file %s is a directory.\n"
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
switch|switch
condition|(
name|srcMode
condition|)
block|{
case|case
name|SM_I2O
case|:
if|if
condition|(
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: I won't read compressed data from a terminal.\n"
argument_list|,
name|progName
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: For help, type: `%s --help'.\n"
argument_list|,
name|progName
argument_list|,
name|progName
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
name|inStr
operator|=
name|stdin
expr_stmt|;
break|break;
case|case
name|SM_F2O
case|:
case|case
name|SM_F2F
case|:
name|inStr
operator|=
name|fopen
argument_list|(
name|inName
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|inStr
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't open input file %s:%s.\n"
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"testf: bad srcMode"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|verbosity
operator|>=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %s: "
argument_list|,
name|inName
argument_list|)
expr_stmt|;
name|pad
argument_list|(
name|inName
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
comment|/*--- Now the input handle is sane.  Do the Biz. ---*/
name|outputHandleJustInCase
operator|=
name|NULL
expr_stmt|;
name|allOK
operator|=
name|testStream
argument_list|(
name|inStr
argument_list|)
expr_stmt|;
if|if
condition|(
name|allOK
operator|&&
name|verbosity
operator|>=
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ok\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|allOK
condition|)
name|testFailsExist
operator|=
name|True
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|license
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bzip2, a block-sorting file compressor.  "
literal|"Version %s.\n"
literal|"   \n"
literal|"   Copyright (C) 1996-2006 by Julian Seward.\n"
literal|"   \n"
literal|"   This program is free software; you can redistribute it and/or modify\n"
literal|"   it under the terms set out in the LICENSE file, which is included\n"
literal|"   in the bzip2-1.0.4 source distribution.\n"
literal|"   \n"
literal|"   This program is distributed in the hope that it will be useful,\n"
literal|"   but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
literal|"   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
literal|"   LICENSE file for more details.\n"
literal|"   \n"
argument_list|,
name|BZ2_bzlibVersion
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|Char
modifier|*
name|fullProgName
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bzip2, a block-sorting file compressor.  "
literal|"Version %s.\n"
literal|"\n   usage: %s [flags and input files in any order]\n"
literal|"\n"
literal|"   -h --help           print this message\n"
literal|"   -d --decompress     force decompression\n"
literal|"   -z --compress       force compression\n"
literal|"   -k --keep           keep (don't delete) input files\n"
literal|"   -f --force          overwrite existing output files\n"
literal|"   -t --test           test compressed file integrity\n"
literal|"   -c --stdout         output to standard out\n"
literal|"   -q --quiet          suppress noncritical error messages\n"
literal|"   -v --verbose        be verbose (a 2nd -v gives more)\n"
literal|"   -L --license        display software version& license\n"
literal|"   -V --version        display software version& license\n"
literal|"   -s --small          use less memory (at most 2500k)\n"
literal|"   -1 .. -9            set block size to 100k .. 900k\n"
literal|"   --fast              alias for -1\n"
literal|"   --best              alias for -9\n"
literal|"\n"
literal|"   If invoked as `bzip2', default action is to compress.\n"
literal|"              as `bunzip2',  default action is to decompress.\n"
literal|"              as `bzcat', default action is to decompress to stdout.\n"
literal|"\n"
literal|"   If no file names are given, bzip2 compresses or decompresses\n"
literal|"   from standard input to standard output.  You can combine\n"
literal|"   short flags, so `-v -4' means the same as -v4 or -4v,&c.\n"
if|#
directive|if
name|BZ_UNIX
literal|"\n"
endif|#
directive|endif
argument_list|,
name|BZ2_bzlibVersion
argument_list|()
argument_list|,
name|fullProgName
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|redundant
parameter_list|(
name|Char
modifier|*
name|flag
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s is redundant in versions 0.9.5 and above\n"
argument_list|,
name|progName
argument_list|,
name|flag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_comment
comment|/*--   All the garbage from here to main() is purely to   implement a linked list of command-line arguments,   into which main() copies argv[1 .. argc-1].    The purpose of this exercise is to facilitate    the expansion of wildcard characters * and ? in    filenames for OSs which don't know how to do it   themselves, like MSDOS, Windows 95 and NT.    The actual Dirty Work is done by the platform-   specific macro APPEND_FILESPEC. --*/
end_comment

begin_typedef
typedef|typedef
struct|struct
name|zzzz
block|{
name|Char
modifier|*
name|name
decl_stmt|;
name|struct
name|zzzz
modifier|*
name|link
decl_stmt|;
block|}
name|Cell
typedef|;
end_typedef

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
modifier|*
name|myMalloc
parameter_list|(
name|Int32
name|n
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|malloc
argument_list|(
operator|(
name|size_t
operator|)
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|outOfMemory
argument_list|()
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|Cell
modifier|*
name|mkCell
parameter_list|(
name|void
parameter_list|)
block|{
name|Cell
modifier|*
name|c
decl_stmt|;
name|c
operator|=
operator|(
name|Cell
operator|*
operator|)
name|myMalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Cell
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|link
operator|=
name|NULL
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|Cell
modifier|*
name|snocString
parameter_list|(
name|Cell
modifier|*
name|root
parameter_list|,
name|Char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|root
operator|==
name|NULL
condition|)
block|{
name|Cell
modifier|*
name|tmp
init|=
name|mkCell
argument_list|()
decl_stmt|;
name|tmp
operator|->
name|name
operator|=
operator|(
name|Char
operator|*
operator|)
name|myMalloc
argument_list|(
literal|5
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmp
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
else|else
block|{
name|Cell
modifier|*
name|tmp
init|=
name|root
decl_stmt|;
while|while
condition|(
name|tmp
operator|->
name|link
operator|!=
name|NULL
condition|)
name|tmp
operator|=
name|tmp
operator|->
name|link
expr_stmt|;
name|tmp
operator|->
name|link
operator|=
name|snocString
argument_list|(
name|tmp
operator|->
name|link
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|root
return|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|addFlagsFromEnvVar
parameter_list|(
name|Cell
modifier|*
modifier|*
name|argList
parameter_list|,
name|Char
modifier|*
name|varName
parameter_list|)
block|{
name|Int32
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|Char
modifier|*
name|envbase
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|envbase
operator|=
name|getenv
argument_list|(
name|varName
argument_list|)
expr_stmt|;
if|if
condition|(
name|envbase
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|envbase
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|True
condition|)
block|{
if|if
condition|(
name|p
index|[
name|i
index|]
operator|==
literal|0
condition|)
break|break;
name|p
operator|+=
name|i
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
call|(
name|Int32
call|)
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
name|p
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
operator|!
name|isspace
argument_list|(
call|(
name|Int32
call|)
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|k
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|k
operator|>
name|FILE_NAME_LEN
operator|-
literal|10
condition|)
name|k
operator|=
name|FILE_NAME_LEN
operator|-
literal|10
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|k
condition|;
name|j
operator|++
control|)
name|tmpName
index|[
name|j
index|]
operator|=
name|p
index|[
name|j
index|]
expr_stmt|;
name|tmpName
index|[
name|k
index|]
operator|=
literal|0
expr_stmt|;
name|APPEND_FLAG
argument_list|(
operator|*
name|argList
argument_list|,
name|tmpName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_define
define|#
directive|define
name|ISFLAG
parameter_list|(
name|s
parameter_list|)
value|(strcmp(aa->name, (s))==0)
end_define

begin_function
name|IntNative
name|main
parameter_list|(
name|IntNative
name|argc
parameter_list|,
name|Char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|Int32
name|i
decl_stmt|,
name|j
decl_stmt|;
name|Char
modifier|*
name|tmp
decl_stmt|;
name|Cell
modifier|*
name|argList
decl_stmt|;
name|Cell
modifier|*
name|aa
decl_stmt|;
name|Bool
name|decode
decl_stmt|;
comment|/*-- Be really really really paranoid :-) --*/
if|if
condition|(
sizeof|sizeof
argument_list|(
name|Int32
argument_list|)
operator|!=
literal|4
operator|||
sizeof|sizeof
argument_list|(
name|UInt32
argument_list|)
operator|!=
literal|4
operator|||
sizeof|sizeof
argument_list|(
name|Int16
argument_list|)
operator|!=
literal|2
operator|||
sizeof|sizeof
argument_list|(
name|UInt16
argument_list|)
operator|!=
literal|2
operator|||
sizeof|sizeof
argument_list|(
name|Char
argument_list|)
operator|!=
literal|1
operator|||
sizeof|sizeof
argument_list|(
name|UChar
argument_list|)
operator|!=
literal|1
condition|)
name|configError
argument_list|()
expr_stmt|;
comment|/*-- Initialise --*/
name|outputHandleJustInCase
operator|=
name|NULL
expr_stmt|;
name|smallMode
operator|=
name|False
expr_stmt|;
name|keepInputFiles
operator|=
name|False
expr_stmt|;
name|forceOverwrite
operator|=
name|False
expr_stmt|;
name|noisy
operator|=
name|True
expr_stmt|;
name|verbosity
operator|=
literal|0
expr_stmt|;
name|blockSize100k
operator|=
literal|9
expr_stmt|;
name|testFailsExist
operator|=
name|False
expr_stmt|;
name|unzFailsExist
operator|=
name|False
expr_stmt|;
name|numFileNames
operator|=
literal|0
expr_stmt|;
name|numFilesProcessed
operator|=
literal|0
expr_stmt|;
name|workFactor
operator|=
literal|30
expr_stmt|;
name|deleteOutputOnInterrupt
operator|=
name|False
expr_stmt|;
name|exitValue
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|j
operator|=
literal|0
expr_stmt|;
comment|/* avoid bogus warning from egcs-1.1.X */
comment|/*-- Set up signal handlers for mem access errors --*/
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|mySIGSEGVorSIGBUScatcher
argument_list|)
expr_stmt|;
if|#
directive|if
name|BZ_UNIX
ifndef|#
directive|ifndef
name|__DJGPP__
name|signal
argument_list|(
name|SIGBUS
argument_list|,
name|mySIGSEGVorSIGBUScatcher
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|copyFileName
argument_list|(
name|inName
argument_list|,
operator|(
name|Char
operator|*
operator|)
literal|"(none)"
argument_list|)
expr_stmt|;
name|copyFileName
argument_list|(
name|outName
argument_list|,
operator|(
name|Char
operator|*
operator|)
literal|"(none)"
argument_list|)
expr_stmt|;
name|copyFileName
argument_list|(
name|progNameReally
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|progName
operator|=
operator|&
name|progNameReally
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|tmp
operator|=
operator|&
name|progNameReally
index|[
literal|0
index|]
init|;
operator|*
name|tmp
operator|!=
literal|'\0'
condition|;
name|tmp
operator|++
control|)
if|if
condition|(
operator|*
name|tmp
operator|==
name|PATH_SEP
condition|)
name|progName
operator|=
name|tmp
operator|+
literal|1
expr_stmt|;
comment|/*-- Copy flags from env var BZIP2, and          expand filename wildcards in arg list.    --*/
name|argList
operator|=
name|NULL
expr_stmt|;
name|addFlagsFromEnvVar
argument_list|(
operator|&
name|argList
argument_list|,
operator|(
name|Char
operator|*
operator|)
literal|"BZIP2"
argument_list|)
expr_stmt|;
name|addFlagsFromEnvVar
argument_list|(
operator|&
name|argList
argument_list|,
operator|(
name|Char
operator|*
operator|)
literal|"BZIP"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|argc
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|APPEND_FILESPEC
argument_list|(
name|argList
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/*-- Find the length of the longest filename --*/
name|longestFileName
operator|=
literal|7
expr_stmt|;
name|numFileNames
operator|=
literal|0
expr_stmt|;
name|decode
operator|=
name|True
expr_stmt|;
for|for
control|(
name|aa
operator|=
name|argList
init|;
name|aa
operator|!=
name|NULL
condition|;
name|aa
operator|=
name|aa
operator|->
name|link
control|)
block|{
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--"
argument_list|)
condition|)
block|{
name|decode
operator|=
name|False
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|aa
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|decode
condition|)
continue|continue;
name|numFileNames
operator|++
expr_stmt|;
if|if
condition|(
name|longestFileName
operator|<
operator|(
name|Int32
operator|)
name|strlen
argument_list|(
name|aa
operator|->
name|name
argument_list|)
condition|)
name|longestFileName
operator|=
operator|(
name|Int32
operator|)
name|strlen
argument_list|(
name|aa
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
comment|/*-- Determine source modes; flag handling may change this too. --*/
if|if
condition|(
name|numFileNames
operator|==
literal|0
condition|)
name|srcMode
operator|=
name|SM_I2O
expr_stmt|;
else|else
name|srcMode
operator|=
name|SM_F2F
expr_stmt|;
comment|/*-- Determine what to do (compress/uncompress/test/cat). --*/
comment|/*-- Note that subsequent flag handling may change this. --*/
name|opMode
operator|=
name|OM_Z
expr_stmt|;
if|if
condition|(
operator|(
name|strstr
argument_list|(
name|progName
argument_list|,
literal|"unzip"
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|strstr
argument_list|(
name|progName
argument_list|,
literal|"UNZIP"
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|opMode
operator|=
name|OM_UNZ
expr_stmt|;
if|if
condition|(
operator|(
name|strstr
argument_list|(
name|progName
argument_list|,
literal|"z2cat"
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|strstr
argument_list|(
name|progName
argument_list|,
literal|"Z2CAT"
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|strstr
argument_list|(
name|progName
argument_list|,
literal|"zcat"
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|strstr
argument_list|(
name|progName
argument_list|,
literal|"ZCAT"
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|opMode
operator|=
name|OM_UNZ
expr_stmt|;
name|srcMode
operator|=
operator|(
name|numFileNames
operator|==
literal|0
operator|)
condition|?
name|SM_I2O
else|:
name|SM_F2O
expr_stmt|;
block|}
comment|/*-- Look at the flags. --*/
for|for
control|(
name|aa
operator|=
name|argList
init|;
name|aa
operator|!=
name|NULL
condition|;
name|aa
operator|=
name|aa
operator|->
name|link
control|)
block|{
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--"
argument_list|)
condition|)
break|break;
if|if
condition|(
name|aa
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|aa
operator|->
name|name
index|[
literal|1
index|]
operator|!=
literal|'-'
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|1
init|;
name|aa
operator|->
name|name
index|[
name|j
index|]
operator|!=
literal|'\0'
condition|;
name|j
operator|++
control|)
block|{
switch|switch
condition|(
name|aa
operator|->
name|name
index|[
name|j
index|]
condition|)
block|{
case|case
literal|'c'
case|:
name|srcMode
operator|=
name|SM_F2O
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|opMode
operator|=
name|OM_UNZ
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|opMode
operator|=
name|OM_Z
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|forceOverwrite
operator|=
name|True
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|opMode
operator|=
name|OM_TEST
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|keepInputFiles
operator|=
name|True
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|smallMode
operator|=
name|True
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|noisy
operator|=
name|False
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
name|blockSize100k
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
name|blockSize100k
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'3'
case|:
name|blockSize100k
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|'4'
case|:
name|blockSize100k
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'5'
case|:
name|blockSize100k
operator|=
literal|5
expr_stmt|;
break|break;
case|case
literal|'6'
case|:
name|blockSize100k
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|'7'
case|:
name|blockSize100k
operator|=
literal|7
expr_stmt|;
break|break;
case|case
literal|'8'
case|:
name|blockSize100k
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|'9'
case|:
name|blockSize100k
operator|=
literal|9
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
case|case
literal|'L'
case|:
name|license
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbosity
operator|++
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|usage
argument_list|(
name|progName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Bad flag `%s'\n"
argument_list|,
name|progName
argument_list|,
name|aa
operator|->
name|name
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|progName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/*-- And again ... --*/
for|for
control|(
name|aa
operator|=
name|argList
init|;
name|aa
operator|!=
name|NULL
condition|;
name|aa
operator|=
name|aa
operator|->
name|link
control|)
block|{
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--"
argument_list|)
condition|)
break|break;
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--stdout"
argument_list|)
condition|)
name|srcMode
operator|=
name|SM_F2O
expr_stmt|;
elseif|else
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--decompress"
argument_list|)
condition|)
name|opMode
operator|=
name|OM_UNZ
expr_stmt|;
elseif|else
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--compress"
argument_list|)
condition|)
name|opMode
operator|=
name|OM_Z
expr_stmt|;
elseif|else
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--force"
argument_list|)
condition|)
name|forceOverwrite
operator|=
name|True
expr_stmt|;
elseif|else
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--test"
argument_list|)
condition|)
name|opMode
operator|=
name|OM_TEST
expr_stmt|;
elseif|else
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--keep"
argument_list|)
condition|)
name|keepInputFiles
operator|=
name|True
expr_stmt|;
elseif|else
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--small"
argument_list|)
condition|)
name|smallMode
operator|=
name|True
expr_stmt|;
elseif|else
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--quiet"
argument_list|)
condition|)
name|noisy
operator|=
name|False
expr_stmt|;
elseif|else
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--version"
argument_list|)
condition|)
name|license
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--license"
argument_list|)
condition|)
name|license
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--exponential"
argument_list|)
condition|)
name|workFactor
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--repetitive-best"
argument_list|)
condition|)
name|redundant
argument_list|(
name|aa
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--repetitive-fast"
argument_list|)
condition|)
name|redundant
argument_list|(
name|aa
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--fast"
argument_list|)
condition|)
name|blockSize100k
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--best"
argument_list|)
condition|)
name|blockSize100k
operator|=
literal|9
expr_stmt|;
elseif|else
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--verbose"
argument_list|)
condition|)
name|verbosity
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--help"
argument_list|)
condition|)
block|{
name|usage
argument_list|(
name|progName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|aa
operator|->
name|name
argument_list|,
literal|"--"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Bad flag `%s'\n"
argument_list|,
name|progName
argument_list|,
name|aa
operator|->
name|name
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|progName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|verbosity
operator|>
literal|4
condition|)
name|verbosity
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|opMode
operator|==
name|OM_Z
operator|&&
name|smallMode
operator|&&
name|blockSize100k
operator|>
literal|2
condition|)
name|blockSize100k
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|opMode
operator|==
name|OM_TEST
operator|&&
name|srcMode
operator|==
name|SM_F2O
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: -c and -t cannot be used together.\n"
argument_list|,
name|progName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|srcMode
operator|==
name|SM_F2O
operator|&&
name|numFileNames
operator|==
literal|0
condition|)
name|srcMode
operator|=
name|SM_I2O
expr_stmt|;
if|if
condition|(
name|opMode
operator|!=
name|OM_Z
condition|)
name|blockSize100k
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|srcMode
operator|==
name|SM_F2F
condition|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|mySignalCatcher
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|mySignalCatcher
argument_list|)
expr_stmt|;
if|#
directive|if
name|BZ_UNIX
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|mySignalCatcher
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|opMode
operator|==
name|OM_Z
condition|)
block|{
if|if
condition|(
name|srcMode
operator|==
name|SM_I2O
condition|)
block|{
name|compress
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|decode
operator|=
name|True
expr_stmt|;
for|for
control|(
name|aa
operator|=
name|argList
init|;
name|aa
operator|!=
name|NULL
condition|;
name|aa
operator|=
name|aa
operator|->
name|link
control|)
block|{
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--"
argument_list|)
condition|)
block|{
name|decode
operator|=
name|False
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|aa
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|decode
condition|)
continue|continue;
name|numFilesProcessed
operator|++
expr_stmt|;
name|compress
argument_list|(
name|aa
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|opMode
operator|==
name|OM_UNZ
condition|)
block|{
name|unzFailsExist
operator|=
name|False
expr_stmt|;
if|if
condition|(
name|srcMode
operator|==
name|SM_I2O
condition|)
block|{
name|uncompress
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|decode
operator|=
name|True
expr_stmt|;
for|for
control|(
name|aa
operator|=
name|argList
init|;
name|aa
operator|!=
name|NULL
condition|;
name|aa
operator|=
name|aa
operator|->
name|link
control|)
block|{
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--"
argument_list|)
condition|)
block|{
name|decode
operator|=
name|False
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|aa
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|decode
condition|)
continue|continue;
name|numFilesProcessed
operator|++
expr_stmt|;
name|uncompress
argument_list|(
name|aa
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|unzFailsExist
condition|)
block|{
name|setExit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exitValue
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|testFailsExist
operator|=
name|False
expr_stmt|;
if|if
condition|(
name|srcMode
operator|==
name|SM_I2O
condition|)
block|{
name|testf
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|decode
operator|=
name|True
expr_stmt|;
for|for
control|(
name|aa
operator|=
name|argList
init|;
name|aa
operator|!=
name|NULL
condition|;
name|aa
operator|=
name|aa
operator|->
name|link
control|)
block|{
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--"
argument_list|)
condition|)
block|{
name|decode
operator|=
name|False
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|aa
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|decode
condition|)
continue|continue;
name|numFilesProcessed
operator|++
expr_stmt|;
name|testf
argument_list|(
name|aa
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|testFailsExist
operator|&&
name|noisy
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
literal|"You can use the `bzip2recover' program to attempt to recover\n"
literal|"data from undamaged sections of corrupted files.\n\n"
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exitValue
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Free the argument list memory to mollify leak detectors        (eg) Purify, Checker.  Serves no other useful purpose.    */
name|aa
operator|=
name|argList
expr_stmt|;
while|while
condition|(
name|aa
operator|!=
name|NULL
condition|)
block|{
name|Cell
modifier|*
name|aa2
init|=
name|aa
operator|->
name|link
decl_stmt|;
if|if
condition|(
name|aa
operator|->
name|name
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|aa
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|aa
argument_list|)
expr_stmt|;
name|aa
operator|=
name|aa2
expr_stmt|;
block|}
return|return
name|exitValue
return|;
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------*/
end_comment

begin_comment
comment|/*--- end                                         bzip2.c ---*/
end_comment

begin_comment
comment|/*-----------------------------------------------------------*/
end_comment

end_unit

