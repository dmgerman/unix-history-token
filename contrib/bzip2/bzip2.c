begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-----------------------------------------------------------*/
end_comment

begin_comment
comment|/*--- A block-sorting, lossless compressor        bzip2.c ---*/
end_comment

begin_comment
comment|/*-----------------------------------------------------------*/
end_comment

begin_comment
comment|/*--   This file is a part of bzip2 and/or libbzip2, a program and   library for lossless, block-sorting data compression.    Copyright (C) 1996-2000 Julian R Seward.  All rights reserved.    Redistribution and use in source and binary forms, with or without   modification, are permitted provided that the following conditions   are met:    1. Redistributions of source code must retain the above copyright      notice, this list of conditions and the following disclaimer.    2. The origin of this software must not be misrepresented; you must       not claim that you wrote the original software.  If you use this       software in a product, an acknowledgment in the product       documentation would be appreciated but is not required.    3. Altered source versions must be plainly marked as such, and must      not be misrepresented as being the original software.    4. The name of the author may not be used to endorse or promote       products derived from this software without specific prior written       permission.    THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS   OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY   DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.    Julian Seward, Cambridge, UK.   jseward@acm.org   bzip2/libbzip2 version 1.0 of 21 March 2000    This program is based on (at least) the work of:      Mike Burrows      David Wheeler      Peter Fenwick      Alistair Moffat      Radford Neal      Ian H. Witten      Robert Sedgewick      Jon L. Bentley    For more information on these sources, see the manual. --*/
end_comment

begin_comment
comment|/*----------------------------------------------------*/
end_comment

begin_comment
comment|/*--- IMPORTANT                                    ---*/
end_comment

begin_comment
comment|/*----------------------------------------------------*/
end_comment

begin_comment
comment|/*--    WARNING:       This program and library (attempts to) compress data by        performing several non-trivial transformations on it.         Unless you are 100% familiar with *all* the algorithms        contained herein, and with the consequences of modifying them,        you should NOT meddle with the compression or decompression        machinery.  Incorrect changes can and very likely *will*        lead to disasterous loss of data.     DISCLAIMER:       I TAKE NO RESPONSIBILITY FOR ANY LOSS OF DATA ARISING FROM THE       USE OF THIS PROGRAM, HOWSOEVER CAUSED.        Every compression of a file implies an assumption that the       compressed file can be decompressed to reproduce the original.       Great efforts in design, coding and testing have been made to       ensure that this program works correctly.  However, the       complexity of the algorithms, and, in particular, the presence       of various special cases in the code which occur with very low       but non-zero probability make it impossible to rule out the       possibility of bugs remaining in the program.  DO NOT COMPRESS       ANY DATA WITH THIS PROGRAM AND/OR LIBRARY UNLESS YOU ARE PREPARED        TO ACCEPT THE POSSIBILITY, HOWEVER SMALL, THAT THE DATA WILL        NOT BE RECOVERABLE.        That is not to say this program is inherently unreliable.       Indeed, I very much hope the opposite is true.  bzip2/libbzip2       has been carefully constructed and extensively tested.     PATENTS:       To the best of my knowledge, bzip2/libbzip2 does not use any        patented algorithms.  However, I do not have the resources        available to carry out a full patent search.  Therefore I cannot        give any guarantee of the above statement. --*/
end_comment

begin_comment
comment|/*----------------------------------------------------*/
end_comment

begin_comment
comment|/*--- and now for something much more pleasant :-) ---*/
end_comment

begin_comment
comment|/*----------------------------------------------------*/
end_comment

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_comment
comment|/*--   Place a 1 beside your platform, and 0 elsewhere. --*/
end_comment

begin_comment
comment|/*--   Generic 32-bit Unix.   Also works on 64-bit Unix boxes. --*/
end_comment

begin_define
define|#
directive|define
name|BZ_UNIX
value|1
end_define

begin_comment
comment|/*--   Win32, as seen by Jacob Navia's excellent   port of (Chris Fraser& David Hanson)'s excellent   lcc compiler. --*/
end_comment

begin_define
define|#
directive|define
name|BZ_LCCWIN32
value|0
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|BZ_LCCWIN32
end_undef

begin_define
define|#
directive|define
name|BZ_LCCWIN32
value|1
end_define

begin_undef
undef|#
directive|undef
name|BZ_UNIX
end_undef

begin_define
define|#
directive|define
name|BZ_UNIX
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_comment
comment|/*--   Some stuff for all platforms. --*/
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"bzlib.h"
end_include

begin_define
define|#
directive|define
name|ERROR_IF_EOF
parameter_list|(
name|i
parameter_list|)
value|{ if ((i) == EOF)  ioError(); }
end_define

begin_define
define|#
directive|define
name|ERROR_IF_NOT_ZERO
parameter_list|(
name|i
parameter_list|)
value|{ if ((i) != 0)    ioError(); }
end_define

begin_define
define|#
directive|define
name|ERROR_IF_MINUS_ONE
parameter_list|(
name|i
parameter_list|)
value|{ if ((i) == (-1)) ioError(); }
end_define

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_comment
comment|/*--    Platform-specific stuff. --*/
end_comment

begin_if
if|#
directive|if
name|BZ_UNIX
end_if

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<utime.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/times.h>
end_include

begin_define
define|#
directive|define
name|PATH_SEP
value|'/'
end_define

begin_define
define|#
directive|define
name|MY_LSTAT
value|lstat
end_define

begin_define
define|#
directive|define
name|MY_S_IFREG
value|S_ISREG
end_define

begin_define
define|#
directive|define
name|MY_STAT
value|stat
end_define

begin_define
define|#
directive|define
name|APPEND_FILESPEC
parameter_list|(
name|root
parameter_list|,
name|name
parameter_list|)
define|\
value|root=snocString((root), (name))
end_define

begin_define
define|#
directive|define
name|APPEND_FLAG
parameter_list|(
name|root
parameter_list|,
name|name
parameter_list|)
define|\
value|root=snocString((root), (name))
end_define

begin_define
define|#
directive|define
name|SET_BINARY_MODE
parameter_list|(
name|fd
parameter_list|)
end_define

begin_comment
comment|/**/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|NORETURN
value|__attribute__ ((noreturn))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NORETURN
end_define

begin_comment
comment|/**/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__DJGPP__
end_ifdef

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_undef
undef|#
directive|undef
name|MY_LSTAT
end_undef

begin_define
define|#
directive|define
name|MY_LSTAT
value|stat
end_define

begin_undef
undef|#
directive|undef
name|SET_BINARY_MODE
end_undef

begin_define
define|#
directive|define
name|SET_BINARY_MODE
parameter_list|(
name|fd
parameter_list|)
define|\
value|do {                                            \            int retVal = setmode ( fileno ( fd ),        \                                  O_BINARY );            \            ERROR_IF_MINUS_ONE ( retVal );               \         } while ( 0 )
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__CYGWIN__
end_ifdef

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_undef
undef|#
directive|undef
name|SET_BINARY_MODE
end_undef

begin_define
define|#
directive|define
name|SET_BINARY_MODE
parameter_list|(
name|fd
parameter_list|)
define|\
value|do {                                            \            int retVal = setmode ( fileno ( fd ),        \                                  O_BINARY );            \            ERROR_IF_MINUS_ONE ( retVal );               \         } while ( 0 )
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|BZ_LCCWIN32
end_if

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys\stat.h>
end_include

begin_define
define|#
directive|define
name|NORETURN
end_define

begin_comment
comment|/**/
end_comment

begin_define
define|#
directive|define
name|PATH_SEP
value|'\\'
end_define

begin_define
define|#
directive|define
name|MY_LSTAT
value|_stat
end_define

begin_define
define|#
directive|define
name|MY_STAT
value|_stat
end_define

begin_define
define|#
directive|define
name|MY_S_IFREG
parameter_list|(
name|x
parameter_list|)
value|((x)& _S_IFREG)
end_define

begin_define
define|#
directive|define
name|APPEND_FLAG
parameter_list|(
name|root
parameter_list|,
name|name
parameter_list|)
define|\
value|root=snocString((root), (name))
end_define

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*-- lcc-win32 seems to expand wildcards itself --*/
end_comment

begin_define
define|#
directive|define
name|APPEND_FILESPEC
parameter_list|(
name|root
parameter_list|,
name|spec
parameter_list|)
define|\
value|do {                                            \          if ((spec)[0] == '-') {                      \             root = snocString((root), (spec));        \          } else {                                     \             struct _finddata_t c_file;                \             long hFile;                               \             hFile = _findfirst((spec),&c_file);      \             if ( hFile == -1L ) {                     \                root = snocString ((root), (spec));    \             } else {                                  \                int anInt = 0;                         \                while ( anInt == 0 ) {                 \                   root = snocString((root),           \&c_file.name[0]);         \                   anInt = _findnext(hFile,&c_file);  \                }                                      \             }                                         \          }                                            \       } while ( 0 )
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|APPEND_FILESPEC
parameter_list|(
name|root
parameter_list|,
name|name
parameter_list|)
define|\
value|root = snocString ((root), (name))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SET_BINARY_MODE
parameter_list|(
name|fd
parameter_list|)
define|\
value|do {                                            \          int retVal = setmode ( fileno ( fd ),        \                                O_BINARY );            \          ERROR_IF_MINUS_ONE ( retVal );               \       } while ( 0 )
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_comment
comment|/*--   Some more stuff for all platforms :-) --*/
end_comment

begin_typedef
typedef|typedef
name|char
name|Char
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|char
name|Bool
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|char
name|UChar
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|int
name|Int32
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|int
name|UInt32
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|short
name|Int16
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|short
name|UInt16
typedef|;
end_typedef

begin_define
define|#
directive|define
name|True
value|((Bool)1)
end_define

begin_define
define|#
directive|define
name|False
value|((Bool)0)
end_define

begin_comment
comment|/*--   IntNative is your platform's `native' int size.   Only here to avoid probs with 64-bit platforms. --*/
end_comment

begin_typedef
typedef|typedef
name|int
name|IntNative
typedef|;
end_typedef

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_comment
comment|/*--- Misc (file handling) data decls             ---*/
end_comment

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_decl_stmt
name|Int32
name|verbosity
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Bool
name|keepInputFiles
decl_stmt|,
name|smallMode
decl_stmt|,
name|deleteOutputOnInterrupt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Bool
name|forceOverwrite
decl_stmt|,
name|testFailsExist
decl_stmt|,
name|unzFailsExist
decl_stmt|,
name|noisy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Int32
name|numFileNames
decl_stmt|,
name|numFilesProcessed
decl_stmt|,
name|blockSize100k
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Int32
name|exitValue
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*-- source modes; F==file, I==stdin, O==stdout --*/
end_comment

begin_define
define|#
directive|define
name|SM_I2O
value|1
end_define

begin_define
define|#
directive|define
name|SM_F2O
value|2
end_define

begin_define
define|#
directive|define
name|SM_F2F
value|3
end_define

begin_comment
comment|/*-- operation modes --*/
end_comment

begin_define
define|#
directive|define
name|OM_Z
value|1
end_define

begin_define
define|#
directive|define
name|OM_UNZ
value|2
end_define

begin_define
define|#
directive|define
name|OM_TEST
value|3
end_define

begin_decl_stmt
name|Int32
name|opMode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Int32
name|srcMode
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FILE_NAME_LEN
value|1034
end_define

begin_decl_stmt
name|Int32
name|longestFileName
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Char
name|inName
index|[
name|FILE_NAME_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Char
name|outName
index|[
name|FILE_NAME_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Char
name|tmpName
index|[
name|FILE_NAME_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Char
modifier|*
name|progName
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Char
name|progNameReally
index|[
name|FILE_NAME_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|outputHandleJustInCase
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Int32
name|workFactor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|panic
argument_list|(
name|Char
operator|*
argument_list|)
name|NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ioError
argument_list|(
name|void
argument_list|)
name|NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|outOfMemory
argument_list|(
name|void
argument_list|)
name|NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|configError
argument_list|(
name|void
argument_list|)
name|NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|crcError
argument_list|(
name|void
argument_list|)
name|NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cleanUpAndFail
argument_list|(
name|Int32
argument_list|)
name|NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compressedStreamEOF
argument_list|(
name|void
argument_list|)
name|NORETURN
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|copyFileName
parameter_list|(
name|Char
modifier|*
parameter_list|,
name|Char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|myMalloc
parameter_list|(
name|Int32
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_comment
comment|/*--- An implementation of 64-bit ints.  Sigh.    ---*/
end_comment

begin_comment
comment|/*--- Roll on widespread deployment of ANSI C9X ! ---*/
end_comment

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|UChar
name|b
index|[
literal|8
index|]
decl_stmt|;
block|}
name|UInt64
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|uInt64_from_UInt32s
parameter_list|(
name|UInt64
modifier|*
name|n
parameter_list|,
name|UInt32
name|lo32
parameter_list|,
name|UInt32
name|hi32
parameter_list|)
block|{
name|n
operator|->
name|b
index|[
literal|7
index|]
operator|=
call|(
name|UChar
call|)
argument_list|(
operator|(
name|hi32
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|n
operator|->
name|b
index|[
literal|6
index|]
operator|=
call|(
name|UChar
call|)
argument_list|(
operator|(
name|hi32
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|n
operator|->
name|b
index|[
literal|5
index|]
operator|=
call|(
name|UChar
call|)
argument_list|(
operator|(
name|hi32
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|n
operator|->
name|b
index|[
literal|4
index|]
operator|=
call|(
name|UChar
call|)
argument_list|(
name|hi32
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|n
operator|->
name|b
index|[
literal|3
index|]
operator|=
call|(
name|UChar
call|)
argument_list|(
operator|(
name|lo32
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|n
operator|->
name|b
index|[
literal|2
index|]
operator|=
call|(
name|UChar
call|)
argument_list|(
operator|(
name|lo32
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|n
operator|->
name|b
index|[
literal|1
index|]
operator|=
call|(
name|UChar
call|)
argument_list|(
operator|(
name|lo32
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|n
operator|->
name|b
index|[
literal|0
index|]
operator|=
call|(
name|UChar
call|)
argument_list|(
name|lo32
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|double
name|uInt64_to_double
parameter_list|(
name|UInt64
modifier|*
name|n
parameter_list|)
block|{
name|Int32
name|i
decl_stmt|;
name|double
name|base
init|=
literal|1.0
decl_stmt|;
name|double
name|sum
init|=
literal|0.0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|sum
operator|+=
name|base
operator|*
call|(
name|double
call|)
argument_list|(
name|n
operator|->
name|b
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|base
operator|*=
literal|256.0
expr_stmt|;
block|}
return|return
name|sum
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uInt64_add
parameter_list|(
name|UInt64
modifier|*
name|src
parameter_list|,
name|UInt64
modifier|*
name|dst
parameter_list|)
block|{
name|Int32
name|i
decl_stmt|;
name|Int32
name|carry
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|carry
operator|+=
operator|(
operator|(
operator|(
name|Int32
operator|)
name|src
operator|->
name|b
index|[
name|i
index|]
operator|)
operator|+
operator|(
operator|(
name|Int32
operator|)
name|dst
operator|->
name|b
index|[
name|i
index|]
operator|)
operator|)
expr_stmt|;
name|dst
operator|->
name|b
index|[
name|i
index|]
operator|=
call|(
name|UChar
call|)
argument_list|(
name|carry
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|carry
operator|>>=
literal|8
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|uInt64_sub
parameter_list|(
name|UInt64
modifier|*
name|src
parameter_list|,
name|UInt64
modifier|*
name|dst
parameter_list|)
block|{
name|Int32
name|t
decl_stmt|,
name|i
decl_stmt|;
name|Int32
name|borrow
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|t
operator|=
operator|(
operator|(
name|Int32
operator|)
name|dst
operator|->
name|b
index|[
name|i
index|]
operator|)
operator|-
operator|(
operator|(
name|Int32
operator|)
name|src
operator|->
name|b
index|[
name|i
index|]
operator|)
operator|-
name|borrow
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|0
condition|)
block|{
name|dst
operator|->
name|b
index|[
name|i
index|]
operator|=
call|(
name|UChar
call|)
argument_list|(
name|t
operator|+
literal|256
argument_list|)
expr_stmt|;
name|borrow
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|dst
operator|->
name|b
index|[
name|i
index|]
operator|=
operator|(
name|UChar
operator|)
name|t
expr_stmt|;
name|borrow
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|uInt64_mul
parameter_list|(
name|UInt64
modifier|*
name|a
parameter_list|,
name|UInt64
modifier|*
name|b
parameter_list|,
name|UInt64
modifier|*
name|r_hi
parameter_list|,
name|UInt64
modifier|*
name|r_lo
parameter_list|)
block|{
name|UChar
name|sum
index|[
literal|16
index|]
decl_stmt|;
name|Int32
name|ia
decl_stmt|,
name|ib
decl_stmt|,
name|carry
decl_stmt|;
for|for
control|(
name|ia
operator|=
literal|0
init|;
name|ia
operator|<
literal|16
condition|;
name|ia
operator|++
control|)
name|sum
index|[
name|ia
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ia
operator|=
literal|0
init|;
name|ia
operator|<
literal|8
condition|;
name|ia
operator|++
control|)
block|{
name|carry
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ib
operator|=
literal|0
init|;
name|ib
operator|<
literal|8
condition|;
name|ib
operator|++
control|)
block|{
name|carry
operator|+=
operator|(
operator|(
operator|(
name|Int32
operator|)
name|sum
index|[
name|ia
operator|+
name|ib
index|]
operator|)
operator|+
operator|(
operator|(
name|Int32
operator|)
name|a
operator|->
name|b
index|[
name|ia
index|]
operator|)
operator|*
operator|(
operator|(
name|Int32
operator|)
name|b
operator|->
name|b
index|[
name|ib
index|]
operator|)
operator|)
expr_stmt|;
name|sum
index|[
name|ia
operator|+
name|ib
index|]
operator|=
call|(
name|UChar
call|)
argument_list|(
name|carry
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|carry
operator|>>=
literal|8
expr_stmt|;
block|}
name|sum
index|[
name|ia
operator|+
literal|8
index|]
operator|=
call|(
name|UChar
call|)
argument_list|(
name|carry
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|carry
operator|>>=
literal|8
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"uInt64_mul"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ia
operator|=
literal|0
init|;
name|ia
operator|<
literal|8
condition|;
name|ia
operator|++
control|)
name|r_hi
operator|->
name|b
index|[
name|ia
index|]
operator|=
name|sum
index|[
name|ia
operator|+
literal|8
index|]
expr_stmt|;
for|for
control|(
name|ia
operator|=
literal|0
init|;
name|ia
operator|<
literal|8
condition|;
name|ia
operator|++
control|)
name|r_lo
operator|->
name|b
index|[
name|ia
index|]
operator|=
name|sum
index|[
name|ia
index|]
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|uInt64_shr1
parameter_list|(
name|UInt64
modifier|*
name|n
parameter_list|)
block|{
name|Int32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|n
operator|->
name|b
index|[
name|i
index|]
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|7
operator|&&
operator|(
name|n
operator|->
name|b
index|[
name|i
operator|+
literal|1
index|]
operator|&
literal|1
operator|)
condition|)
name|n
operator|->
name|b
index|[
name|i
index|]
operator||=
literal|0x80
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|uInt64_shl1
parameter_list|(
name|UInt64
modifier|*
name|n
parameter_list|)
block|{
name|Int32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|7
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|n
operator|->
name|b
index|[
name|i
index|]
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
operator|(
name|n
operator|->
name|b
index|[
name|i
operator|-
literal|1
index|]
operator|&
literal|0x80
operator|)
condition|)
name|n
operator|->
name|b
index|[
name|i
index|]
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|Bool
name|uInt64_isZero
parameter_list|(
name|UInt64
modifier|*
name|n
parameter_list|)
block|{
name|Int32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|n
operator|->
name|b
index|[
name|i
index|]
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|Int32
name|uInt64_qrm10
parameter_list|(
name|UInt64
modifier|*
name|n
parameter_list|)
block|{
comment|/* Divide *n by 10, and return the remainder.  Long division       is difficult, so we cheat and instead multiply by       0xCCCC CCCC CCCC CCCD, which is 0.8 (viz, 0.1<< 3).    */
name|Int32
name|i
decl_stmt|;
name|UInt64
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|,
name|n_orig
decl_stmt|,
name|zero_point_eight
decl_stmt|;
name|zero_point_eight
operator|.
name|b
index|[
literal|1
index|]
operator|=
name|zero_point_eight
operator|.
name|b
index|[
literal|2
index|]
operator|=
name|zero_point_eight
operator|.
name|b
index|[
literal|3
index|]
operator|=
name|zero_point_eight
operator|.
name|b
index|[
literal|4
index|]
operator|=
name|zero_point_eight
operator|.
name|b
index|[
literal|5
index|]
operator|=
name|zero_point_eight
operator|.
name|b
index|[
literal|6
index|]
operator|=
name|zero_point_eight
operator|.
name|b
index|[
literal|7
index|]
operator|=
literal|0xCC
expr_stmt|;
name|zero_point_eight
operator|.
name|b
index|[
literal|0
index|]
operator|=
literal|0xCD
expr_stmt|;
name|n_orig
operator|=
operator|*
name|n
expr_stmt|;
comment|/* divide n by 10,        by multiplying by 0.8 and then shifting right 3 times */
name|uInt64_mul
argument_list|(
name|n
argument_list|,
operator|&
name|zero_point_eight
argument_list|,
operator|&
name|tmp1
argument_list|,
operator|&
name|tmp2
argument_list|)
expr_stmt|;
name|uInt64_shr1
argument_list|(
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|uInt64_shr1
argument_list|(
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|uInt64_shr1
argument_list|(
operator|&
name|tmp1
argument_list|)
expr_stmt|;
operator|*
name|n
operator|=
name|tmp1
expr_stmt|;
comment|/* tmp1 = 8*n, tmp2 = 2*n */
name|uInt64_shl1
argument_list|(
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|uInt64_shl1
argument_list|(
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|uInt64_shl1
argument_list|(
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|tmp2
operator|=
operator|*
name|n
expr_stmt|;
name|uInt64_shl1
argument_list|(
operator|&
name|tmp2
argument_list|)
expr_stmt|;
comment|/* tmp1 = 10*n */
name|uInt64_add
argument_list|(
operator|&
name|tmp2
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
comment|/* n_orig = n_orig - 10*n */
name|uInt64_sub
argument_list|(
operator|&
name|tmp1
argument_list|,
operator|&
name|n_orig
argument_list|)
expr_stmt|;
comment|/* n_orig should now hold quotient, in range 0 .. 9 */
for|for
control|(
name|i
operator|=
literal|7
init|;
name|i
operator|>=
literal|1
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|n_orig
operator|.
name|b
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"uInt64_qrm10(1)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_orig
operator|.
name|b
index|[
literal|0
index|]
operator|>
literal|9
condition|)
name|panic
argument_list|(
literal|"uInt64_qrm10(2)"
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|n_orig
operator|.
name|b
index|[
literal|0
index|]
return|;
block|}
end_function

begin_comment
comment|/* ... and the Whole Entire Point of all this UInt64 stuff is    so that we can supply the following function. */
end_comment

begin_function
specifier|static
name|void
name|uInt64_toAscii
parameter_list|(
name|char
modifier|*
name|outbuf
parameter_list|,
name|UInt64
modifier|*
name|n
parameter_list|)
block|{
name|Int32
name|i
decl_stmt|,
name|q
decl_stmt|;
name|UChar
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|Int32
name|nBuf
init|=
literal|0
decl_stmt|;
name|UInt64
name|n_copy
init|=
operator|*
name|n
decl_stmt|;
do|do
block|{
name|q
operator|=
name|uInt64_qrm10
argument_list|(
operator|&
name|n_copy
argument_list|)
expr_stmt|;
name|buf
index|[
name|nBuf
index|]
operator|=
name|q
operator|+
literal|'0'
expr_stmt|;
name|nBuf
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|uInt64_isZero
argument_list|(
operator|&
name|n_copy
argument_list|)
condition|)
do|;
name|outbuf
index|[
name|nBuf
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nBuf
condition|;
name|i
operator|++
control|)
name|outbuf
index|[
name|i
index|]
operator|=
name|buf
index|[
name|nBuf
operator|-
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_comment
comment|/*--- Processing of complete files and streams    ---*/
end_comment

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|Bool
name|myfeof
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|Int32
name|c
init|=
name|fgetc
argument_list|(
name|f
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
name|True
return|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
return|return
name|False
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|compressStream
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|FILE
modifier|*
name|zStream
parameter_list|)
block|{
name|BZFILE
modifier|*
name|bzf
init|=
name|NULL
decl_stmt|;
name|UChar
name|ibuf
index|[
literal|5000
index|]
decl_stmt|;
name|Int32
name|nIbuf
decl_stmt|;
name|UInt32
name|nbytes_in_lo32
decl_stmt|,
name|nbytes_in_hi32
decl_stmt|;
name|UInt32
name|nbytes_out_lo32
decl_stmt|,
name|nbytes_out_hi32
decl_stmt|;
name|Int32
name|bzerr
decl_stmt|,
name|bzerr_dummy
decl_stmt|,
name|ret
decl_stmt|;
name|SET_BINARY_MODE
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|SET_BINARY_MODE
argument_list|(
name|zStream
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stream
argument_list|)
condition|)
goto|goto
name|errhandler_io
goto|;
if|if
condition|(
name|ferror
argument_list|(
name|zStream
argument_list|)
condition|)
goto|goto
name|errhandler_io
goto|;
name|bzf
operator|=
name|BZ2_bzWriteOpen
argument_list|(
operator|&
name|bzerr
argument_list|,
name|zStream
argument_list|,
name|blockSize100k
argument_list|,
name|verbosity
argument_list|,
name|workFactor
argument_list|)
expr_stmt|;
if|if
condition|(
name|bzerr
operator|!=
name|BZ_OK
condition|)
goto|goto
name|errhandler
goto|;
if|if
condition|(
name|verbosity
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|True
condition|)
block|{
if|if
condition|(
name|myfeof
argument_list|(
name|stream
argument_list|)
condition|)
break|break;
name|nIbuf
operator|=
name|fread
argument_list|(
name|ibuf
argument_list|,
sizeof|sizeof
argument_list|(
name|UChar
argument_list|)
argument_list|,
literal|5000
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stream
argument_list|)
condition|)
goto|goto
name|errhandler_io
goto|;
if|if
condition|(
name|nIbuf
operator|>
literal|0
condition|)
name|BZ2_bzWrite
argument_list|(
operator|&
name|bzerr
argument_list|,
name|bzf
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ibuf
argument_list|,
name|nIbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bzerr
operator|!=
name|BZ_OK
condition|)
goto|goto
name|errhandler
goto|;
block|}
name|BZ2_bzWriteClose64
argument_list|(
operator|&
name|bzerr
argument_list|,
name|bzf
argument_list|,
literal|0
argument_list|,
operator|&
name|nbytes_in_lo32
argument_list|,
operator|&
name|nbytes_in_hi32
argument_list|,
operator|&
name|nbytes_out_lo32
argument_list|,
operator|&
name|nbytes_out_hi32
argument_list|)
expr_stmt|;
if|if
condition|(
name|bzerr
operator|!=
name|BZ_OK
condition|)
goto|goto
name|errhandler
goto|;
if|if
condition|(
name|ferror
argument_list|(
name|zStream
argument_list|)
condition|)
goto|goto
name|errhandler_io
goto|;
name|ret
operator|=
name|fflush
argument_list|(
name|zStream
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|EOF
condition|)
goto|goto
name|errhandler_io
goto|;
if|if
condition|(
name|zStream
operator|!=
name|stdout
condition|)
block|{
name|ret
operator|=
name|fclose
argument_list|(
name|zStream
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|EOF
condition|)
goto|goto
name|errhandler_io
goto|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|stream
argument_list|)
condition|)
goto|goto
name|errhandler_io
goto|;
name|ret
operator|=
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|EOF
condition|)
goto|goto
name|errhandler_io
goto|;
if|if
condition|(
name|nbytes_in_lo32
operator|==
literal|0
operator|&&
name|nbytes_in_hi32
operator|==
literal|0
condition|)
name|nbytes_in_lo32
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|verbosity
operator|>=
literal|1
condition|)
block|{
name|Char
name|buf_nin
index|[
literal|32
index|]
decl_stmt|,
name|buf_nout
index|[
literal|32
index|]
decl_stmt|;
name|UInt64
name|nbytes_in
decl_stmt|,
name|nbytes_out
decl_stmt|;
name|double
name|nbytes_in_d
decl_stmt|,
name|nbytes_out_d
decl_stmt|;
name|uInt64_from_UInt32s
argument_list|(
operator|&
name|nbytes_in
argument_list|,
name|nbytes_in_lo32
argument_list|,
name|nbytes_in_hi32
argument_list|)
expr_stmt|;
name|uInt64_from_UInt32s
argument_list|(
operator|&
name|nbytes_out
argument_list|,
name|nbytes_out_lo32
argument_list|,
name|nbytes_out_hi32
argument_list|)
expr_stmt|;
name|nbytes_in_d
operator|=
name|uInt64_to_double
argument_list|(
operator|&
name|nbytes_in
argument_list|)
expr_stmt|;
name|nbytes_out_d
operator|=
name|uInt64_to_double
argument_list|(
operator|&
name|nbytes_out
argument_list|)
expr_stmt|;
name|uInt64_toAscii
argument_list|(
name|buf_nin
argument_list|,
operator|&
name|nbytes_in
argument_list|)
expr_stmt|;
name|uInt64_toAscii
argument_list|(
name|buf_nout
argument_list|,
operator|&
name|nbytes_out
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%6.3f:1, %6.3f bits/byte, "
literal|"%5.2f%% saved, %s in, %s out.\n"
argument_list|,
name|nbytes_in_d
operator|/
name|nbytes_out_d
argument_list|,
operator|(
literal|8.0
operator|*
name|nbytes_out_d
operator|)
operator|/
name|nbytes_in_d
argument_list|,
literal|100.0
operator|*
operator|(
literal|1.0
operator|-
name|nbytes_out_d
operator|/
name|nbytes_in_d
operator|)
argument_list|,
name|buf_nin
argument_list|,
name|buf_nout
argument_list|)
expr_stmt|;
block|}
return|return;
name|errhandler
label|:
name|BZ2_bzWriteClose64
argument_list|(
operator|&
name|bzerr_dummy
argument_list|,
name|bzf
argument_list|,
literal|1
argument_list|,
operator|&
name|nbytes_in_lo32
argument_list|,
operator|&
name|nbytes_in_hi32
argument_list|,
operator|&
name|nbytes_out_lo32
argument_list|,
operator|&
name|nbytes_out_hi32
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bzerr
condition|)
block|{
case|case
name|BZ_CONFIG_ERROR
case|:
name|configError
argument_list|()
expr_stmt|;
break|break;
case|case
name|BZ_MEM_ERROR
case|:
name|outOfMemory
argument_list|()
expr_stmt|;
break|break;
case|case
name|BZ_IO_ERROR
case|:
name|errhandler_io
label|:
name|ioError
argument_list|()
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"compress:unexpected error"
argument_list|)
expr_stmt|;
block|}
name|panic
argument_list|(
literal|"compress:end"
argument_list|)
expr_stmt|;
comment|/*notreached*/
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|Bool
name|uncompressStream
parameter_list|(
name|FILE
modifier|*
name|zStream
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|BZFILE
modifier|*
name|bzf
init|=
name|NULL
decl_stmt|;
name|Int32
name|bzerr
decl_stmt|,
name|bzerr_dummy
decl_stmt|,
name|ret
decl_stmt|,
name|nread
decl_stmt|,
name|streamNo
decl_stmt|,
name|i
decl_stmt|;
name|UChar
name|obuf
index|[
literal|5000
index|]
decl_stmt|;
name|UChar
name|unused
index|[
name|BZ_MAX_UNUSED
index|]
decl_stmt|;
name|Int32
name|nUnused
decl_stmt|;
name|UChar
modifier|*
name|unusedTmp
decl_stmt|;
name|nUnused
operator|=
literal|0
expr_stmt|;
name|streamNo
operator|=
literal|0
expr_stmt|;
name|SET_BINARY_MODE
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|SET_BINARY_MODE
argument_list|(
name|zStream
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stream
argument_list|)
condition|)
goto|goto
name|errhandler_io
goto|;
if|if
condition|(
name|ferror
argument_list|(
name|zStream
argument_list|)
condition|)
goto|goto
name|errhandler_io
goto|;
while|while
condition|(
name|True
condition|)
block|{
name|bzf
operator|=
name|BZ2_bzReadOpen
argument_list|(
operator|&
name|bzerr
argument_list|,
name|zStream
argument_list|,
name|verbosity
argument_list|,
operator|(
name|int
operator|)
name|smallMode
argument_list|,
name|unused
argument_list|,
name|nUnused
argument_list|)
expr_stmt|;
if|if
condition|(
name|bzf
operator|==
name|NULL
operator|||
name|bzerr
operator|!=
name|BZ_OK
condition|)
goto|goto
name|errhandler
goto|;
name|streamNo
operator|++
expr_stmt|;
while|while
condition|(
name|bzerr
operator|==
name|BZ_OK
condition|)
block|{
name|nread
operator|=
name|BZ2_bzRead
argument_list|(
operator|&
name|bzerr
argument_list|,
name|bzf
argument_list|,
name|obuf
argument_list|,
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
name|bzerr
operator|==
name|BZ_DATA_ERROR_MAGIC
condition|)
goto|goto
name|errhandler
goto|;
if|if
condition|(
operator|(
name|bzerr
operator|==
name|BZ_OK
operator|||
name|bzerr
operator|==
name|BZ_STREAM_END
operator|)
operator|&&
name|nread
operator|>
literal|0
condition|)
name|fwrite
argument_list|(
name|obuf
argument_list|,
sizeof|sizeof
argument_list|(
name|UChar
argument_list|)
argument_list|,
name|nread
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stream
argument_list|)
condition|)
goto|goto
name|errhandler_io
goto|;
block|}
if|if
condition|(
name|bzerr
operator|!=
name|BZ_STREAM_END
condition|)
goto|goto
name|errhandler
goto|;
name|BZ2_bzReadGetUnused
argument_list|(
operator|&
name|bzerr
argument_list|,
name|bzf
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|(
operator|&
name|unusedTmp
operator|)
argument_list|,
operator|&
name|nUnused
argument_list|)
expr_stmt|;
if|if
condition|(
name|bzerr
operator|!=
name|BZ_OK
condition|)
name|panic
argument_list|(
literal|"decompress:bzReadGetUnused"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nUnused
condition|;
name|i
operator|++
control|)
name|unused
index|[
name|i
index|]
operator|=
name|unusedTmp
index|[
name|i
index|]
expr_stmt|;
name|BZ2_bzReadClose
argument_list|(
operator|&
name|bzerr
argument_list|,
name|bzf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bzerr
operator|!=
name|BZ_OK
condition|)
name|panic
argument_list|(
literal|"decompress:bzReadGetUnused"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nUnused
operator|==
literal|0
operator|&&
name|myfeof
argument_list|(
name|zStream
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|zStream
argument_list|)
condition|)
goto|goto
name|errhandler_io
goto|;
name|ret
operator|=
name|fclose
argument_list|(
name|zStream
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|EOF
condition|)
goto|goto
name|errhandler_io
goto|;
if|if
condition|(
name|ferror
argument_list|(
name|stream
argument_list|)
condition|)
goto|goto
name|errhandler_io
goto|;
name|ret
operator|=
name|fflush
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|errhandler_io
goto|;
if|if
condition|(
name|stream
operator|!=
name|stdout
condition|)
block|{
name|ret
operator|=
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|EOF
condition|)
goto|goto
name|errhandler_io
goto|;
block|}
if|if
condition|(
name|verbosity
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n    "
argument_list|)
expr_stmt|;
return|return
name|True
return|;
name|errhandler
label|:
name|BZ2_bzReadClose
argument_list|(
operator|&
name|bzerr_dummy
argument_list|,
name|bzf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bzerr
condition|)
block|{
case|case
name|BZ_CONFIG_ERROR
case|:
name|configError
argument_list|()
expr_stmt|;
break|break;
case|case
name|BZ_IO_ERROR
case|:
name|errhandler_io
label|:
name|ioError
argument_list|()
expr_stmt|;
break|break;
case|case
name|BZ_DATA_ERROR
case|:
name|crcError
argument_list|()
expr_stmt|;
case|case
name|BZ_MEM_ERROR
case|:
name|outOfMemory
argument_list|()
expr_stmt|;
case|case
name|BZ_UNEXPECTED_EOF
case|:
name|compressedStreamEOF
argument_list|()
expr_stmt|;
case|case
name|BZ_DATA_ERROR_MAGIC
case|:
if|if
condition|(
name|zStream
operator|!=
name|stdin
condition|)
name|fclose
argument_list|(
name|zStream
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream
operator|!=
name|stdout
condition|)
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|streamNo
operator|==
literal|1
condition|)
block|{
return|return
name|False
return|;
block|}
else|else
block|{
if|if
condition|(
name|noisy
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s: %s: trailing garbage after EOF ignored\n"
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|)
expr_stmt|;
return|return
name|True
return|;
block|}
default|default:
name|panic
argument_list|(
literal|"decompress:unexpected error"
argument_list|)
expr_stmt|;
block|}
name|panic
argument_list|(
literal|"decompress:end"
argument_list|)
expr_stmt|;
return|return
name|True
return|;
comment|/*notreached*/
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|Bool
name|testStream
parameter_list|(
name|FILE
modifier|*
name|zStream
parameter_list|)
block|{
name|BZFILE
modifier|*
name|bzf
init|=
name|NULL
decl_stmt|;
name|Int32
name|bzerr
decl_stmt|,
name|bzerr_dummy
decl_stmt|,
name|ret
decl_stmt|,
name|nread
decl_stmt|,
name|streamNo
decl_stmt|,
name|i
decl_stmt|;
name|UChar
name|obuf
index|[
literal|5000
index|]
decl_stmt|;
name|UChar
name|unused
index|[
name|BZ_MAX_UNUSED
index|]
decl_stmt|;
name|Int32
name|nUnused
decl_stmt|;
name|UChar
modifier|*
name|unusedTmp
decl_stmt|;
name|nUnused
operator|=
literal|0
expr_stmt|;
name|streamNo
operator|=
literal|0
expr_stmt|;
name|SET_BINARY_MODE
argument_list|(
name|zStream
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|zStream
argument_list|)
condition|)
goto|goto
name|errhandler_io
goto|;
while|while
condition|(
name|True
condition|)
block|{
name|bzf
operator|=
name|BZ2_bzReadOpen
argument_list|(
operator|&
name|bzerr
argument_list|,
name|zStream
argument_list|,
name|verbosity
argument_list|,
operator|(
name|int
operator|)
name|smallMode
argument_list|,
name|unused
argument_list|,
name|nUnused
argument_list|)
expr_stmt|;
if|if
condition|(
name|bzf
operator|==
name|NULL
operator|||
name|bzerr
operator|!=
name|BZ_OK
condition|)
goto|goto
name|errhandler
goto|;
name|streamNo
operator|++
expr_stmt|;
while|while
condition|(
name|bzerr
operator|==
name|BZ_OK
condition|)
block|{
name|nread
operator|=
name|BZ2_bzRead
argument_list|(
operator|&
name|bzerr
argument_list|,
name|bzf
argument_list|,
name|obuf
argument_list|,
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
name|bzerr
operator|==
name|BZ_DATA_ERROR_MAGIC
condition|)
goto|goto
name|errhandler
goto|;
block|}
if|if
condition|(
name|bzerr
operator|!=
name|BZ_STREAM_END
condition|)
goto|goto
name|errhandler
goto|;
name|BZ2_bzReadGetUnused
argument_list|(
operator|&
name|bzerr
argument_list|,
name|bzf
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|(
operator|&
name|unusedTmp
operator|)
argument_list|,
operator|&
name|nUnused
argument_list|)
expr_stmt|;
if|if
condition|(
name|bzerr
operator|!=
name|BZ_OK
condition|)
name|panic
argument_list|(
literal|"test:bzReadGetUnused"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nUnused
condition|;
name|i
operator|++
control|)
name|unused
index|[
name|i
index|]
operator|=
name|unusedTmp
index|[
name|i
index|]
expr_stmt|;
name|BZ2_bzReadClose
argument_list|(
operator|&
name|bzerr
argument_list|,
name|bzf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bzerr
operator|!=
name|BZ_OK
condition|)
name|panic
argument_list|(
literal|"test:bzReadGetUnused"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nUnused
operator|==
literal|0
operator|&&
name|myfeof
argument_list|(
name|zStream
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|zStream
argument_list|)
condition|)
goto|goto
name|errhandler_io
goto|;
name|ret
operator|=
name|fclose
argument_list|(
name|zStream
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|EOF
condition|)
goto|goto
name|errhandler_io
goto|;
if|if
condition|(
name|verbosity
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n    "
argument_list|)
expr_stmt|;
return|return
name|True
return|;
name|errhandler
label|:
name|BZ2_bzReadClose
argument_list|(
operator|&
name|bzerr_dummy
argument_list|,
name|bzf
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbosity
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: "
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bzerr
condition|)
block|{
case|case
name|BZ_CONFIG_ERROR
case|:
name|configError
argument_list|()
expr_stmt|;
break|break;
case|case
name|BZ_IO_ERROR
case|:
name|errhandler_io
label|:
name|ioError
argument_list|()
expr_stmt|;
break|break;
case|case
name|BZ_DATA_ERROR
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"data integrity (CRC) error in data\n"
argument_list|)
expr_stmt|;
return|return
name|False
return|;
case|case
name|BZ_MEM_ERROR
case|:
name|outOfMemory
argument_list|()
expr_stmt|;
case|case
name|BZ_UNEXPECTED_EOF
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"file ends unexpectedly\n"
argument_list|)
expr_stmt|;
return|return
name|False
return|;
case|case
name|BZ_DATA_ERROR_MAGIC
case|:
if|if
condition|(
name|zStream
operator|!=
name|stdin
condition|)
name|fclose
argument_list|(
name|zStream
argument_list|)
expr_stmt|;
if|if
condition|(
name|streamNo
operator|==
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bad magic number (file not created by bzip2)\n"
argument_list|)
expr_stmt|;
return|return
name|False
return|;
block|}
else|else
block|{
if|if
condition|(
name|noisy
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"trailing garbage after EOF ignored\n"
argument_list|)
expr_stmt|;
return|return
name|True
return|;
block|}
default|default:
name|panic
argument_list|(
literal|"test:unexpected error"
argument_list|)
expr_stmt|;
block|}
name|panic
argument_list|(
literal|"test:end"
argument_list|)
expr_stmt|;
return|return
name|True
return|;
comment|/*notreached*/
block|}
end_function

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_comment
comment|/*--- Error [non-] handling grunge                ---*/
end_comment

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|setExit
parameter_list|(
name|Int32
name|v
parameter_list|)
block|{
if|if
condition|(
name|v
operator|>
name|exitValue
condition|)
name|exitValue
operator|=
name|v
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|cadvise
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|noisy
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nIt is possible that the compressed file(s) have become corrupted.\n"
literal|"You can use the -tvv option to test integrity of such files.\n\n"
literal|"You can use the `bzip2recover' program to *attempt* to recover\n"
literal|"data from undamaged sections of corrupted files.\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|showFileNames
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|noisy
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tInput file = %s, output file = %s\n"
argument_list|,
name|inName
argument_list|,
name|outName
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|cleanUpAndFail
parameter_list|(
name|Int32
name|ec
parameter_list|)
block|{
name|IntNative
name|retVal
decl_stmt|;
if|if
condition|(
name|srcMode
operator|==
name|SM_F2F
operator|&&
name|opMode
operator|!=
name|OM_TEST
operator|&&
name|deleteOutputOnInterrupt
condition|)
block|{
if|if
condition|(
name|noisy
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Deleting output file %s, if it exists.\n"
argument_list|,
name|progName
argument_list|,
name|outName
argument_list|)
expr_stmt|;
if|if
condition|(
name|outputHandleJustInCase
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|outputHandleJustInCase
argument_list|)
expr_stmt|;
name|retVal
operator|=
name|remove
argument_list|(
name|outName
argument_list|)
expr_stmt|;
if|if
condition|(
name|retVal
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: WARNING: deletion of output file (apparently) failed.\n"
argument_list|,
name|progName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|noisy
operator|&&
name|numFileNames
operator|>
literal|0
operator|&&
name|numFilesProcessed
operator|<
name|numFileNames
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: WARNING: some files have not been processed:\n"
literal|"\t%d specified on command line, %d not processed yet.\n\n"
argument_list|,
name|progName
argument_list|,
name|numFileNames
argument_list|,
name|numFileNames
operator|-
name|numFilesProcessed
argument_list|)
expr_stmt|;
block|}
name|setExit
argument_list|(
name|ec
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exitValue
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|panic
parameter_list|(
name|Char
modifier|*
name|s
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s: PANIC -- internal consistency error:\n"
literal|"\t%s\n"
literal|"\tThis is a BUG.  Please report it to me at:\n"
literal|"\tjseward@acm.org\n"
argument_list|,
name|progName
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|showFileNames
argument_list|()
expr_stmt|;
name|cleanUpAndFail
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|crcError
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s: Data integrity error when decompressing.\n"
argument_list|,
name|progName
argument_list|)
expr_stmt|;
name|showFileNames
argument_list|()
expr_stmt|;
name|cadvise
argument_list|()
expr_stmt|;
name|cleanUpAndFail
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|compressedStreamEOF
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s: Compressed file ends unexpectedly;\n\t"
literal|"perhaps it is corrupted?  *Possible* reason follows.\n"
argument_list|,
name|progName
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|progName
argument_list|)
expr_stmt|;
name|showFileNames
argument_list|()
expr_stmt|;
name|cadvise
argument_list|()
expr_stmt|;
name|cleanUpAndFail
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|ioError
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s: I/O or other error, bailing out.  "
literal|"Possible reason follows.\n"
argument_list|,
name|progName
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|progName
argument_list|)
expr_stmt|;
name|showFileNames
argument_list|()
expr_stmt|;
name|cleanUpAndFail
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|mySignalCatcher
parameter_list|(
name|IntNative
name|n
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s: Control-C or similar caught, quitting.\n"
argument_list|,
name|progName
argument_list|)
expr_stmt|;
name|cleanUpAndFail
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|mySIGSEGVorSIGBUScatcher
parameter_list|(
name|IntNative
name|n
parameter_list|)
block|{
if|if
condition|(
name|opMode
operator|==
name|OM_Z
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s: Caught a SIGSEGV or SIGBUS whilst compressing.\n"
literal|"\n"
literal|"   Possible causes are (most likely first):\n"
literal|"   (1) This computer has unreliable memory or cache hardware\n"
literal|"       (a surprisingly common problem; try a different machine.)\n"
literal|"   (2) A bug in the compiler used to create this executable\n"
literal|"       (unlikely, if you didn't compile bzip2 yourself.)\n"
literal|"   (3) A real bug in bzip2 -- I hope this should never be the case.\n"
literal|"   The user's manual, Section 4.3, has more info on (1) and (2).\n"
literal|"   \n"
literal|"   If you suspect this is a bug in bzip2, or are unsure about (1)\n"
literal|"   or (2), feel free to report it to me at: jseward@acm.org.\n"
literal|"   Section 4.3 of the user's manual describes the info a useful\n"
literal|"   bug report should have.  If the manual is available on your\n"
literal|"   system, please try and read it before mailing me.  If you don't\n"
literal|"   have the manual or can't be bothered to read it, mail me anyway.\n"
literal|"\n"
argument_list|,
name|progName
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s: Caught a SIGSEGV or SIGBUS whilst decompressing.\n"
literal|"\n"
literal|"   Possible causes are (most likely first):\n"
literal|"   (1) The compressed data is corrupted, and bzip2's usual checks\n"
literal|"       failed to detect this.  Try bzip2 -tvv my_file.bz2.\n"
literal|"   (2) This computer has unreliable memory or cache hardware\n"
literal|"       (a surprisingly common problem; try a different machine.)\n"
literal|"   (3) A bug in the compiler used to create this executable\n"
literal|"       (unlikely, if you didn't compile bzip2 yourself.)\n"
literal|"   (4) A real bug in bzip2 -- I hope this should never be the case.\n"
literal|"   The user's manual, Section 4.3, has more info on (2) and (3).\n"
literal|"   \n"
literal|"   If you suspect this is a bug in bzip2, or are unsure about (2)\n"
literal|"   or (3), feel free to report it to me at: jseward@acm.org.\n"
literal|"   Section 4.3 of the user's manual describes the info a useful\n"
literal|"   bug report should have.  If the manual is available on your\n"
literal|"   system, please try and read it before mailing me.  If you don't\n"
literal|"   have the manual or can't be bothered to read it, mail me anyway.\n"
literal|"\n"
argument_list|,
name|progName
argument_list|)
expr_stmt|;
name|showFileNames
argument_list|()
expr_stmt|;
if|if
condition|(
name|opMode
operator|==
name|OM_Z
condition|)
name|cleanUpAndFail
argument_list|(
literal|3
argument_list|)
expr_stmt|;
else|else
block|{
name|cadvise
argument_list|()
expr_stmt|;
name|cleanUpAndFail
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|outOfMemory
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s: couldn't allocate enough memory\n"
argument_list|,
name|progName
argument_list|)
expr_stmt|;
name|showFileNames
argument_list|()
expr_stmt|;
name|cleanUpAndFail
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|configError
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bzip2: I'm not configured correctly for this platform!\n"
literal|"\tI require Int32, Int16 and Char to have sizes\n"
literal|"\tof 4, 2 and 1 bytes to run properly, and they don't.\n"
literal|"\tProbably you can fix this by defining them correctly,\n"
literal|"\tand recompiling.  Bye!\n"
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exitValue
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_comment
comment|/*--- The main driver machinery                   ---*/
end_comment

begin_comment
comment|/*---------------------------------------------------*/
end_comment

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|pad
parameter_list|(
name|Char
modifier|*
name|s
parameter_list|)
block|{
name|Int32
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|Int32
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
operator|>=
name|longestFileName
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|longestFileName
operator|-
operator|(
name|Int32
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|copyFileName
parameter_list|(
name|Char
modifier|*
name|to
parameter_list|,
name|Char
modifier|*
name|from
parameter_list|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|from
argument_list|)
operator|>
name|FILE_NAME_LEN
operator|-
literal|10
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bzip2: file name\n`%s'\n"
literal|"is suspiciously (more than %d chars) long.\n"
literal|"Try using a reasonable file name instead.  Sorry! :-)\n"
argument_list|,
name|from
argument_list|,
name|FILE_NAME_LEN
operator|-
literal|10
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exitValue
argument_list|)
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|FILE_NAME_LEN
operator|-
literal|10
argument_list|)
expr_stmt|;
name|to
index|[
name|FILE_NAME_LEN
operator|-
literal|10
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|Bool
name|fileExists
parameter_list|(
name|Char
modifier|*
name|name
parameter_list|)
block|{
name|FILE
modifier|*
name|tmp
init|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"rb"
argument_list|)
decl_stmt|;
name|Bool
name|exists
init|=
operator|(
name|tmp
operator|!=
name|NULL
operator|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|exists
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_comment
comment|/*--   if in doubt, return True --*/
end_comment

begin_function
specifier|static
name|Bool
name|notAStandardFile
parameter_list|(
name|Char
modifier|*
name|name
parameter_list|)
block|{
name|IntNative
name|i
decl_stmt|;
name|struct
name|MY_STAT
name|statBuf
decl_stmt|;
name|i
operator|=
name|MY_LSTAT
argument_list|(
name|name
argument_list|,
operator|&
name|statBuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
return|return
name|True
return|;
if|if
condition|(
name|MY_S_IFREG
argument_list|(
name|statBuf
operator|.
name|st_mode
argument_list|)
condition|)
return|return
name|False
return|;
return|return
name|True
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_comment
comment|/*--   rac 11/21/98 see if file has hard links to it --*/
end_comment

begin_function
specifier|static
name|Int32
name|countHardLinks
parameter_list|(
name|Char
modifier|*
name|name
parameter_list|)
block|{
name|IntNative
name|i
decl_stmt|;
name|struct
name|MY_STAT
name|statBuf
decl_stmt|;
name|i
operator|=
name|MY_LSTAT
argument_list|(
name|name
argument_list|,
operator|&
name|statBuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|statBuf
operator|.
name|st_nlink
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|copyDatePermissionsAndOwner
parameter_list|(
name|Char
modifier|*
name|srcName
parameter_list|,
name|Char
modifier|*
name|dstName
parameter_list|)
block|{
if|#
directive|if
name|BZ_UNIX
name|IntNative
name|retVal
decl_stmt|;
name|struct
name|MY_STAT
name|statBuf
decl_stmt|;
name|struct
name|utimbuf
name|uTimBuf
decl_stmt|;
name|retVal
operator|=
name|MY_LSTAT
argument_list|(
name|srcName
argument_list|,
operator|&
name|statBuf
argument_list|)
expr_stmt|;
name|ERROR_IF_NOT_ZERO
argument_list|(
name|retVal
argument_list|)
expr_stmt|;
name|uTimBuf
operator|.
name|actime
operator|=
name|statBuf
operator|.
name|st_atime
expr_stmt|;
name|uTimBuf
operator|.
name|modtime
operator|=
name|statBuf
operator|.
name|st_mtime
expr_stmt|;
name|retVal
operator|=
name|chmod
argument_list|(
name|dstName
argument_list|,
name|statBuf
operator|.
name|st_mode
argument_list|)
expr_stmt|;
name|ERROR_IF_NOT_ZERO
argument_list|(
name|retVal
argument_list|)
expr_stmt|;
name|retVal
operator|=
name|utime
argument_list|(
name|dstName
argument_list|,
operator|&
name|uTimBuf
argument_list|)
expr_stmt|;
name|ERROR_IF_NOT_ZERO
argument_list|(
name|retVal
argument_list|)
expr_stmt|;
name|retVal
operator|=
name|chown
argument_list|(
name|dstName
argument_list|,
name|statBuf
operator|.
name|st_uid
argument_list|,
name|statBuf
operator|.
name|st_gid
argument_list|)
expr_stmt|;
comment|/* chown() will in many cases return with EPERM, which can       be safely ignored.    */
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|setInterimPermissions
parameter_list|(
name|Char
modifier|*
name|dstName
parameter_list|)
block|{
if|#
directive|if
name|BZ_UNIX
name|IntNative
name|retVal
decl_stmt|;
name|retVal
operator|=
name|chmod
argument_list|(
name|dstName
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
argument_list|)
expr_stmt|;
name|ERROR_IF_NOT_ZERO
argument_list|(
name|retVal
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|Bool
name|containsDubiousChars
parameter_list|(
name|Char
modifier|*
name|name
parameter_list|)
block|{
name|Bool
name|cdc
init|=
name|False
decl_stmt|;
for|for
control|(
init|;
operator|*
name|name
operator|!=
literal|'\0'
condition|;
name|name
operator|++
control|)
if|if
condition|(
operator|*
name|name
operator|==
literal|'?'
operator|||
operator|*
name|name
operator|==
literal|'*'
condition|)
name|cdc
operator|=
name|True
expr_stmt|;
return|return
name|cdc
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_define
define|#
directive|define
name|BZ_N_SUFFIX_PAIRS
value|4
end_define

begin_decl_stmt
name|Char
modifier|*
name|zSuffix
index|[
name|BZ_N_SUFFIX_PAIRS
index|]
init|=
block|{
literal|".bz2"
block|,
literal|".bz"
block|,
literal|".tbz2"
block|,
literal|".tbz"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Char
modifier|*
name|unzSuffix
index|[
name|BZ_N_SUFFIX_PAIRS
index|]
init|=
block|{
literal|""
block|,
literal|""
block|,
literal|".tar"
block|,
literal|".tar"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Bool
name|hasSuffix
parameter_list|(
name|Char
modifier|*
name|s
parameter_list|,
name|Char
modifier|*
name|suffix
parameter_list|)
block|{
name|Int32
name|ns
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|Int32
name|nx
init|=
name|strlen
argument_list|(
name|suffix
argument_list|)
decl_stmt|;
if|if
condition|(
name|ns
operator|<
name|nx
condition|)
return|return
name|False
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
operator|+
name|ns
operator|-
name|nx
argument_list|,
name|suffix
argument_list|)
operator|==
literal|0
condition|)
return|return
name|True
return|;
return|return
name|False
return|;
block|}
end_function

begin_function
specifier|static
name|Bool
name|mapSuffix
parameter_list|(
name|Char
modifier|*
name|name
parameter_list|,
name|Char
modifier|*
name|oldSuffix
parameter_list|,
name|Char
modifier|*
name|newSuffix
parameter_list|)
block|{
if|if
condition|(
operator|!
name|hasSuffix
argument_list|(
name|name
argument_list|,
name|oldSuffix
argument_list|)
condition|)
return|return
name|False
return|;
name|name
index|[
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
name|strlen
argument_list|(
name|oldSuffix
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
name|newSuffix
argument_list|)
expr_stmt|;
return|return
name|True
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|compress
parameter_list|(
name|Char
modifier|*
name|name
parameter_list|)
block|{
name|FILE
modifier|*
name|inStr
decl_stmt|;
name|FILE
modifier|*
name|outStr
decl_stmt|;
name|Int32
name|n
decl_stmt|,
name|i
decl_stmt|;
name|deleteOutputOnInterrupt
operator|=
name|False
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|&&
name|srcMode
operator|!=
name|SM_I2O
condition|)
name|panic
argument_list|(
literal|"compress: bad modes\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|srcMode
condition|)
block|{
case|case
name|SM_I2O
case|:
name|copyFileName
argument_list|(
name|inName
argument_list|,
literal|"(stdin)"
argument_list|)
expr_stmt|;
name|copyFileName
argument_list|(
name|outName
argument_list|,
literal|"(stdout)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SM_F2F
case|:
name|copyFileName
argument_list|(
name|inName
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|copyFileName
argument_list|(
name|outName
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|outName
argument_list|,
literal|".bz2"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SM_F2O
case|:
name|copyFileName
argument_list|(
name|inName
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|copyFileName
argument_list|(
name|outName
argument_list|,
literal|"(stdout)"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|srcMode
operator|!=
name|SM_I2O
operator|&&
name|containsDubiousChars
argument_list|(
name|inName
argument_list|)
condition|)
block|{
if|if
condition|(
name|noisy
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: There are no files matching `%s'.\n"
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|srcMode
operator|!=
name|SM_I2O
operator|&&
operator|!
name|fileExists
argument_list|(
name|inName
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't open input file %s: %s.\n"
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BZ_N_SUFFIX_PAIRS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hasSuffix
argument_list|(
name|inName
argument_list|,
name|zSuffix
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|noisy
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Input file %s already has %s suffix.\n"
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|,
name|zSuffix
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|srcMode
operator|==
name|SM_F2F
operator|&&
operator|!
name|forceOverwrite
operator|&&
name|notAStandardFile
argument_list|(
name|inName
argument_list|)
condition|)
block|{
if|if
condition|(
name|noisy
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Input file %s is not a normal file.\n"
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|srcMode
operator|==
name|SM_F2F
operator|&&
operator|!
name|forceOverwrite
operator|&&
name|fileExists
argument_list|(
name|outName
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Output file %s already exists.\n"
argument_list|,
name|progName
argument_list|,
name|outName
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|srcMode
operator|==
name|SM_F2F
operator|&&
operator|!
name|forceOverwrite
operator|&&
operator|(
name|n
operator|=
name|countHardLinks
argument_list|(
name|inName
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Input file %s has %d other link%s.\n"
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|,
name|n
argument_list|,
name|n
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|srcMode
condition|)
block|{
case|case
name|SM_I2O
case|:
name|inStr
operator|=
name|stdin
expr_stmt|;
name|outStr
operator|=
name|stdout
expr_stmt|;
if|if
condition|(
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: I won't write compressed data to a terminal.\n"
argument_list|,
name|progName
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: For help, type: `%s --help'.\n"
argument_list|,
name|progName
argument_list|,
name|progName
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
break|break;
case|case
name|SM_F2O
case|:
name|inStr
operator|=
name|fopen
argument_list|(
name|inName
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
name|outStr
operator|=
name|stdout
expr_stmt|;
if|if
condition|(
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: I won't write compressed data to a terminal.\n"
argument_list|,
name|progName
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: For help, type: `%s --help'.\n"
argument_list|,
name|progName
argument_list|,
name|progName
argument_list|)
expr_stmt|;
if|if
condition|(
name|inStr
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|inStr
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
if|if
condition|(
name|inStr
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't open input file %s: %s.\n"
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
break|break;
case|case
name|SM_F2F
case|:
name|inStr
operator|=
name|fopen
argument_list|(
name|inName
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
name|outStr
operator|=
name|fopen
argument_list|(
name|outName
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|outStr
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't create output file %s: %s.\n"
argument_list|,
name|progName
argument_list|,
name|outName
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inStr
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|inStr
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|inStr
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't open input file %s: %s.\n"
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|outStr
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|outStr
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
name|setInterimPermissions
argument_list|(
name|outName
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"compress: bad srcMode"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|verbosity
operator|>=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %s: "
argument_list|,
name|inName
argument_list|)
expr_stmt|;
name|pad
argument_list|(
name|inName
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
comment|/*--- Now the input and output handles are sane.  Do the Biz. ---*/
name|outputHandleJustInCase
operator|=
name|outStr
expr_stmt|;
name|deleteOutputOnInterrupt
operator|=
name|True
expr_stmt|;
name|compressStream
argument_list|(
name|inStr
argument_list|,
name|outStr
argument_list|)
expr_stmt|;
name|outputHandleJustInCase
operator|=
name|NULL
expr_stmt|;
comment|/*--- If there was an I/O error, we won't get here. ---*/
if|if
condition|(
name|srcMode
operator|==
name|SM_F2F
condition|)
block|{
name|copyDatePermissionsAndOwner
argument_list|(
name|inName
argument_list|,
name|outName
argument_list|)
expr_stmt|;
name|deleteOutputOnInterrupt
operator|=
name|False
expr_stmt|;
if|if
condition|(
operator|!
name|keepInputFiles
condition|)
block|{
name|IntNative
name|retVal
init|=
name|remove
argument_list|(
name|inName
argument_list|)
decl_stmt|;
name|ERROR_IF_NOT_ZERO
argument_list|(
name|retVal
argument_list|)
expr_stmt|;
block|}
block|}
name|deleteOutputOnInterrupt
operator|=
name|False
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|uncompress
parameter_list|(
name|Char
modifier|*
name|name
parameter_list|)
block|{
name|FILE
modifier|*
name|inStr
decl_stmt|;
name|FILE
modifier|*
name|outStr
decl_stmt|;
name|Int32
name|n
decl_stmt|,
name|i
decl_stmt|;
name|Bool
name|magicNumberOK
decl_stmt|;
name|Bool
name|cantGuess
decl_stmt|;
name|deleteOutputOnInterrupt
operator|=
name|False
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|&&
name|srcMode
operator|!=
name|SM_I2O
condition|)
name|panic
argument_list|(
literal|"uncompress: bad modes\n"
argument_list|)
expr_stmt|;
name|cantGuess
operator|=
name|False
expr_stmt|;
switch|switch
condition|(
name|srcMode
condition|)
block|{
case|case
name|SM_I2O
case|:
name|copyFileName
argument_list|(
name|inName
argument_list|,
literal|"(stdin)"
argument_list|)
expr_stmt|;
name|copyFileName
argument_list|(
name|outName
argument_list|,
literal|"(stdout)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SM_F2F
case|:
name|copyFileName
argument_list|(
name|inName
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|copyFileName
argument_list|(
name|outName
argument_list|,
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BZ_N_SUFFIX_PAIRS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|mapSuffix
argument_list|(
name|outName
argument_list|,
name|zSuffix
index|[
name|i
index|]
argument_list|,
name|unzSuffix
index|[
name|i
index|]
argument_list|)
condition|)
goto|goto
name|zzz
goto|;
name|cantGuess
operator|=
name|True
expr_stmt|;
name|strcat
argument_list|(
name|outName
argument_list|,
literal|".out"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SM_F2O
case|:
name|copyFileName
argument_list|(
name|inName
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|copyFileName
argument_list|(
name|outName
argument_list|,
literal|"(stdout)"
argument_list|)
expr_stmt|;
break|break;
block|}
name|zzz
label|:
if|if
condition|(
name|srcMode
operator|!=
name|SM_I2O
operator|&&
name|containsDubiousChars
argument_list|(
name|inName
argument_list|)
condition|)
block|{
if|if
condition|(
name|noisy
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: There are no files matching `%s'.\n"
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|srcMode
operator|!=
name|SM_I2O
operator|&&
operator|!
name|fileExists
argument_list|(
name|inName
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't open input file %s: %s.\n"
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|srcMode
operator|==
name|SM_F2F
operator|&&
operator|!
name|forceOverwrite
operator|&&
name|notAStandardFile
argument_list|(
name|inName
argument_list|)
condition|)
block|{
if|if
condition|(
name|noisy
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Input file %s is not a normal file.\n"
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
comment|/* srcMode == SM_F2F implied&& */
name|cantGuess
condition|)
block|{
if|if
condition|(
name|noisy
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't guess original name for %s -- using %s\n"
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|,
name|outName
argument_list|)
expr_stmt|;
comment|/* just a warning, no return */
block|}
if|if
condition|(
name|srcMode
operator|==
name|SM_F2F
operator|&&
operator|!
name|forceOverwrite
operator|&&
name|fileExists
argument_list|(
name|outName
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Output file %s already exists.\n"
argument_list|,
name|progName
argument_list|,
name|outName
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|srcMode
operator|==
name|SM_F2F
operator|&&
operator|!
name|forceOverwrite
operator|&&
operator|(
name|n
operator|=
name|countHardLinks
argument_list|(
name|inName
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Input file %s has %d other link%s.\n"
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|,
name|n
argument_list|,
name|n
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|srcMode
condition|)
block|{
case|case
name|SM_I2O
case|:
name|inStr
operator|=
name|stdin
expr_stmt|;
name|outStr
operator|=
name|stdout
expr_stmt|;
if|if
condition|(
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: I won't read compressed data from a terminal.\n"
argument_list|,
name|progName
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: For help, type: `%s --help'.\n"
argument_list|,
name|progName
argument_list|,
name|progName
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
break|break;
case|case
name|SM_F2O
case|:
name|inStr
operator|=
name|fopen
argument_list|(
name|inName
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
name|outStr
operator|=
name|stdout
expr_stmt|;
if|if
condition|(
name|inStr
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't open input file %s:%s.\n"
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inStr
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|inStr
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
break|break;
case|case
name|SM_F2F
case|:
name|inStr
operator|=
name|fopen
argument_list|(
name|inName
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
name|outStr
operator|=
name|fopen
argument_list|(
name|outName
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|outStr
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't create output file %s: %s.\n"
argument_list|,
name|progName
argument_list|,
name|outName
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inStr
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|inStr
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|inStr
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't open input file %s: %s.\n"
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|outStr
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|outStr
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
name|setInterimPermissions
argument_list|(
name|outName
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"uncompress: bad srcMode"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|verbosity
operator|>=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %s: "
argument_list|,
name|inName
argument_list|)
expr_stmt|;
name|pad
argument_list|(
name|inName
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
comment|/*--- Now the input and output handles are sane.  Do the Biz. ---*/
name|outputHandleJustInCase
operator|=
name|outStr
expr_stmt|;
name|deleteOutputOnInterrupt
operator|=
name|True
expr_stmt|;
name|magicNumberOK
operator|=
name|uncompressStream
argument_list|(
name|inStr
argument_list|,
name|outStr
argument_list|)
expr_stmt|;
name|outputHandleJustInCase
operator|=
name|NULL
expr_stmt|;
comment|/*--- If there was an I/O error, we won't get here. ---*/
if|if
condition|(
name|magicNumberOK
condition|)
block|{
if|if
condition|(
name|srcMode
operator|==
name|SM_F2F
condition|)
block|{
name|copyDatePermissionsAndOwner
argument_list|(
name|inName
argument_list|,
name|outName
argument_list|)
expr_stmt|;
name|deleteOutputOnInterrupt
operator|=
name|False
expr_stmt|;
if|if
condition|(
operator|!
name|keepInputFiles
condition|)
block|{
name|IntNative
name|retVal
init|=
name|remove
argument_list|(
name|inName
argument_list|)
decl_stmt|;
name|ERROR_IF_NOT_ZERO
argument_list|(
name|retVal
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|unzFailsExist
operator|=
name|True
expr_stmt|;
name|deleteOutputOnInterrupt
operator|=
name|False
expr_stmt|;
if|if
condition|(
name|srcMode
operator|==
name|SM_F2F
condition|)
block|{
name|IntNative
name|retVal
init|=
name|remove
argument_list|(
name|outName
argument_list|)
decl_stmt|;
name|ERROR_IF_NOT_ZERO
argument_list|(
name|retVal
argument_list|)
expr_stmt|;
block|}
block|}
name|deleteOutputOnInterrupt
operator|=
name|False
expr_stmt|;
if|if
condition|(
name|magicNumberOK
condition|)
block|{
if|if
condition|(
name|verbosity
operator|>=
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"done\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setExit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbosity
operator|>=
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"not a bzip2 file.\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s is not a bzip2 file.\n"
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|testf
parameter_list|(
name|Char
modifier|*
name|name
parameter_list|)
block|{
name|FILE
modifier|*
name|inStr
decl_stmt|;
name|Bool
name|allOK
decl_stmt|;
name|deleteOutputOnInterrupt
operator|=
name|False
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|&&
name|srcMode
operator|!=
name|SM_I2O
condition|)
name|panic
argument_list|(
literal|"testf: bad modes\n"
argument_list|)
expr_stmt|;
name|copyFileName
argument_list|(
name|outName
argument_list|,
literal|"(none)"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|srcMode
condition|)
block|{
case|case
name|SM_I2O
case|:
name|copyFileName
argument_list|(
name|inName
argument_list|,
literal|"(stdin)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SM_F2F
case|:
name|copyFileName
argument_list|(
name|inName
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|SM_F2O
case|:
name|copyFileName
argument_list|(
name|inName
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|srcMode
operator|!=
name|SM_I2O
operator|&&
name|containsDubiousChars
argument_list|(
name|inName
argument_list|)
condition|)
block|{
if|if
condition|(
name|noisy
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: There are no files matching `%s'.\n"
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|srcMode
operator|!=
name|SM_I2O
operator|&&
operator|!
name|fileExists
argument_list|(
name|inName
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't open input %s: %s.\n"
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|srcMode
condition|)
block|{
case|case
name|SM_I2O
case|:
if|if
condition|(
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: I won't read compressed data from a terminal.\n"
argument_list|,
name|progName
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: For help, type: `%s --help'.\n"
argument_list|,
name|progName
argument_list|,
name|progName
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
name|inStr
operator|=
name|stdin
expr_stmt|;
break|break;
case|case
name|SM_F2O
case|:
case|case
name|SM_F2F
case|:
name|inStr
operator|=
name|fopen
argument_list|(
name|inName
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|inStr
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't open input file %s:%s.\n"
argument_list|,
name|progName
argument_list|,
name|inName
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"testf: bad srcMode"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|verbosity
operator|>=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %s: "
argument_list|,
name|inName
argument_list|)
expr_stmt|;
name|pad
argument_list|(
name|inName
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
comment|/*--- Now the input handle is sane.  Do the Biz. ---*/
name|allOK
operator|=
name|testStream
argument_list|(
name|inStr
argument_list|)
expr_stmt|;
if|if
condition|(
name|allOK
operator|&&
name|verbosity
operator|>=
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ok\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|allOK
condition|)
name|testFailsExist
operator|=
name|True
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|license
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bzip2, a block-sorting file compressor.  "
literal|"Version %s.\n"
literal|"   \n"
literal|"   Copyright (C) 1996-2000 by Julian Seward.\n"
literal|"   \n"
literal|"   This program is free software; you can redistribute it and/or modify\n"
literal|"   it under the terms set out in the LICENSE file, which is included\n"
literal|"   in the bzip2-1.0 source distribution.\n"
literal|"   \n"
literal|"   This program is distributed in the hope that it will be useful,\n"
literal|"   but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
literal|"   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
literal|"   LICENSE file for more details.\n"
literal|"   \n"
argument_list|,
name|BZ2_bzlibVersion
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|Char
modifier|*
name|fullProgName
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bzip2, a block-sorting file compressor.  "
literal|"Version %s.\n"
literal|"\n   usage: %s [flags and input files in any order]\n"
literal|"\n"
literal|"   -h --help           print this message\n"
literal|"   -d --decompress     force decompression\n"
literal|"   -z --compress       force compression\n"
literal|"   -k --keep           keep (don't delete) input files\n"
literal|"   -f --force          overwrite existing output files\n"
literal|"   -t --test           test compressed file integrity\n"
literal|"   -c --stdout         output to standard out\n"
literal|"   -q --quiet          suppress noncritical error messages\n"
literal|"   -v --verbose        be verbose (a 2nd -v gives more)\n"
literal|"   -L --license        display software version& license\n"
literal|"   -V --version        display software version& license\n"
literal|"   -s --small          use less memory (at most 2500k)\n"
literal|"   -1 .. -9            set block size to 100k .. 900k\n"
literal|"\n"
literal|"   If invoked as `bzip2', default action is to compress.\n"
literal|"              as `bunzip2',  default action is to decompress.\n"
literal|"              as `bzcat', default action is to decompress to stdout.\n"
literal|"\n"
literal|"   If no file names are given, bzip2 compresses or decompresses\n"
literal|"   from standard input to standard output.  You can combine\n"
literal|"   short flags, so `-v -4' means the same as -v4 or -4v,&c.\n"
if|#
directive|if
name|BZ_UNIX
literal|"\n"
endif|#
directive|endif
argument_list|,
name|BZ2_bzlibVersion
argument_list|()
argument_list|,
name|fullProgName
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|redundant
parameter_list|(
name|Char
modifier|*
name|flag
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s is redundant in versions 0.9.5 and above\n"
argument_list|,
name|progName
argument_list|,
name|flag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_comment
comment|/*--   All the garbage from here to main() is purely to   implement a linked list of command-line arguments,   into which main() copies argv[1 .. argc-1].    The purpose of this exercise is to facilitate    the expansion of wildcard characters * and ? in    filenames for OSs which don't know how to do it   themselves, like MSDOS, Windows 95 and NT.    The actual Dirty Work is done by the platform-   specific macro APPEND_FILESPEC. --*/
end_comment

begin_typedef
typedef|typedef
struct|struct
name|zzzz
block|{
name|Char
modifier|*
name|name
decl_stmt|;
name|struct
name|zzzz
modifier|*
name|link
decl_stmt|;
block|}
name|Cell
typedef|;
end_typedef

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
modifier|*
name|myMalloc
parameter_list|(
name|Int32
name|n
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|malloc
argument_list|(
operator|(
name|size_t
operator|)
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|outOfMemory
argument_list|()
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|Cell
modifier|*
name|mkCell
parameter_list|(
name|void
parameter_list|)
block|{
name|Cell
modifier|*
name|c
decl_stmt|;
name|c
operator|=
operator|(
name|Cell
operator|*
operator|)
name|myMalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Cell
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|link
operator|=
name|NULL
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|Cell
modifier|*
name|snocString
parameter_list|(
name|Cell
modifier|*
name|root
parameter_list|,
name|Char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|root
operator|==
name|NULL
condition|)
block|{
name|Cell
modifier|*
name|tmp
init|=
name|mkCell
argument_list|()
decl_stmt|;
name|tmp
operator|->
name|name
operator|=
operator|(
name|Char
operator|*
operator|)
name|myMalloc
argument_list|(
literal|5
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmp
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
else|else
block|{
name|Cell
modifier|*
name|tmp
init|=
name|root
decl_stmt|;
while|while
condition|(
name|tmp
operator|->
name|link
operator|!=
name|NULL
condition|)
name|tmp
operator|=
name|tmp
operator|->
name|link
expr_stmt|;
name|tmp
operator|->
name|link
operator|=
name|snocString
argument_list|(
name|tmp
operator|->
name|link
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|root
return|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|addFlagsFromEnvVar
parameter_list|(
name|Cell
modifier|*
modifier|*
name|argList
parameter_list|,
name|Char
modifier|*
name|varName
parameter_list|)
block|{
name|Int32
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|Char
modifier|*
name|envbase
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|envbase
operator|=
name|getenv
argument_list|(
name|varName
argument_list|)
expr_stmt|;
if|if
condition|(
name|envbase
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|envbase
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|True
condition|)
block|{
if|if
condition|(
name|p
index|[
name|i
index|]
operator|==
literal|0
condition|)
break|break;
name|p
operator|+=
name|i
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
call|(
name|Int32
call|)
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
name|p
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
operator|!
name|isspace
argument_list|(
call|(
name|Int32
call|)
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|k
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|k
operator|>
name|FILE_NAME_LEN
operator|-
literal|10
condition|)
name|k
operator|=
name|FILE_NAME_LEN
operator|-
literal|10
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|k
condition|;
name|j
operator|++
control|)
name|tmpName
index|[
name|j
index|]
operator|=
name|p
index|[
name|j
index|]
expr_stmt|;
name|tmpName
index|[
name|k
index|]
operator|=
literal|0
expr_stmt|;
name|APPEND_FLAG
argument_list|(
operator|*
name|argList
argument_list|,
name|tmpName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------*/
end_comment

begin_define
define|#
directive|define
name|ISFLAG
parameter_list|(
name|s
parameter_list|)
value|(strcmp(aa->name, (s))==0)
end_define

begin_function
name|IntNative
name|main
parameter_list|(
name|IntNative
name|argc
parameter_list|,
name|Char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|Int32
name|i
decl_stmt|,
name|j
decl_stmt|;
name|Char
modifier|*
name|tmp
decl_stmt|;
name|Cell
modifier|*
name|argList
decl_stmt|;
name|Cell
modifier|*
name|aa
decl_stmt|;
name|Bool
name|decode
decl_stmt|;
comment|/*-- Be really really really paranoid :-) --*/
if|if
condition|(
sizeof|sizeof
argument_list|(
name|Int32
argument_list|)
operator|!=
literal|4
operator|||
sizeof|sizeof
argument_list|(
name|UInt32
argument_list|)
operator|!=
literal|4
operator|||
sizeof|sizeof
argument_list|(
name|Int16
argument_list|)
operator|!=
literal|2
operator|||
sizeof|sizeof
argument_list|(
name|UInt16
argument_list|)
operator|!=
literal|2
operator|||
sizeof|sizeof
argument_list|(
name|Char
argument_list|)
operator|!=
literal|1
operator|||
sizeof|sizeof
argument_list|(
name|UChar
argument_list|)
operator|!=
literal|1
condition|)
name|configError
argument_list|()
expr_stmt|;
comment|/*-- Initialise --*/
name|outputHandleJustInCase
operator|=
name|NULL
expr_stmt|;
name|smallMode
operator|=
name|False
expr_stmt|;
name|keepInputFiles
operator|=
name|False
expr_stmt|;
name|forceOverwrite
operator|=
name|False
expr_stmt|;
name|noisy
operator|=
name|True
expr_stmt|;
name|verbosity
operator|=
literal|0
expr_stmt|;
name|blockSize100k
operator|=
literal|9
expr_stmt|;
name|testFailsExist
operator|=
name|False
expr_stmt|;
name|unzFailsExist
operator|=
name|False
expr_stmt|;
name|numFileNames
operator|=
literal|0
expr_stmt|;
name|numFilesProcessed
operator|=
literal|0
expr_stmt|;
name|workFactor
operator|=
literal|30
expr_stmt|;
name|deleteOutputOnInterrupt
operator|=
name|False
expr_stmt|;
name|exitValue
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|j
operator|=
literal|0
expr_stmt|;
comment|/* avoid bogus warning from egcs-1.1.X */
comment|/*-- Set up signal handlers for mem access errors --*/
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|mySIGSEGVorSIGBUScatcher
argument_list|)
expr_stmt|;
if|#
directive|if
name|BZ_UNIX
ifndef|#
directive|ifndef
name|__DJGPP__
name|signal
argument_list|(
name|SIGBUS
argument_list|,
name|mySIGSEGVorSIGBUScatcher
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|copyFileName
argument_list|(
name|inName
argument_list|,
literal|"(none)"
argument_list|)
expr_stmt|;
name|copyFileName
argument_list|(
name|outName
argument_list|,
literal|"(none)"
argument_list|)
expr_stmt|;
name|copyFileName
argument_list|(
name|progNameReally
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|progName
operator|=
operator|&
name|progNameReally
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|tmp
operator|=
operator|&
name|progNameReally
index|[
literal|0
index|]
init|;
operator|*
name|tmp
operator|!=
literal|'\0'
condition|;
name|tmp
operator|++
control|)
if|if
condition|(
operator|*
name|tmp
operator|==
name|PATH_SEP
condition|)
name|progName
operator|=
name|tmp
operator|+
literal|1
expr_stmt|;
comment|/*-- Copy flags from env var BZIP2, and          expand filename wildcards in arg list.    --*/
name|argList
operator|=
name|NULL
expr_stmt|;
name|addFlagsFromEnvVar
argument_list|(
operator|&
name|argList
argument_list|,
literal|"BZIP2"
argument_list|)
expr_stmt|;
name|addFlagsFromEnvVar
argument_list|(
operator|&
name|argList
argument_list|,
literal|"BZIP"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|argc
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|APPEND_FILESPEC
argument_list|(
name|argList
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/*-- Find the length of the longest filename --*/
name|longestFileName
operator|=
literal|7
expr_stmt|;
name|numFileNames
operator|=
literal|0
expr_stmt|;
name|decode
operator|=
name|True
expr_stmt|;
for|for
control|(
name|aa
operator|=
name|argList
init|;
name|aa
operator|!=
name|NULL
condition|;
name|aa
operator|=
name|aa
operator|->
name|link
control|)
block|{
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--"
argument_list|)
condition|)
block|{
name|decode
operator|=
name|False
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|aa
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|decode
condition|)
continue|continue;
name|numFileNames
operator|++
expr_stmt|;
if|if
condition|(
name|longestFileName
operator|<
operator|(
name|Int32
operator|)
name|strlen
argument_list|(
name|aa
operator|->
name|name
argument_list|)
condition|)
name|longestFileName
operator|=
operator|(
name|Int32
operator|)
name|strlen
argument_list|(
name|aa
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
comment|/*-- Determine source modes; flag handling may change this too. --*/
if|if
condition|(
name|numFileNames
operator|==
literal|0
condition|)
name|srcMode
operator|=
name|SM_I2O
expr_stmt|;
else|else
name|srcMode
operator|=
name|SM_F2F
expr_stmt|;
comment|/*-- Determine what to do (compress/uncompress/test/cat). --*/
comment|/*-- Note that subsequent flag handling may change this. --*/
name|opMode
operator|=
name|OM_Z
expr_stmt|;
if|if
condition|(
operator|(
name|strstr
argument_list|(
name|progName
argument_list|,
literal|"unzip"
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|strstr
argument_list|(
name|progName
argument_list|,
literal|"UNZIP"
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|opMode
operator|=
name|OM_UNZ
expr_stmt|;
if|if
condition|(
operator|(
name|strstr
argument_list|(
name|progName
argument_list|,
literal|"z2cat"
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|strstr
argument_list|(
name|progName
argument_list|,
literal|"Z2CAT"
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|strstr
argument_list|(
name|progName
argument_list|,
literal|"zcat"
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|strstr
argument_list|(
name|progName
argument_list|,
literal|"ZCAT"
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|opMode
operator|=
name|OM_UNZ
expr_stmt|;
name|srcMode
operator|=
operator|(
name|numFileNames
operator|==
literal|0
operator|)
condition|?
name|SM_I2O
else|:
name|SM_F2O
expr_stmt|;
block|}
comment|/*-- Look at the flags. --*/
for|for
control|(
name|aa
operator|=
name|argList
init|;
name|aa
operator|!=
name|NULL
condition|;
name|aa
operator|=
name|aa
operator|->
name|link
control|)
block|{
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--"
argument_list|)
condition|)
break|break;
if|if
condition|(
name|aa
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|aa
operator|->
name|name
index|[
literal|1
index|]
operator|!=
literal|'-'
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|1
init|;
name|aa
operator|->
name|name
index|[
name|j
index|]
operator|!=
literal|'\0'
condition|;
name|j
operator|++
control|)
block|{
switch|switch
condition|(
name|aa
operator|->
name|name
index|[
name|j
index|]
condition|)
block|{
case|case
literal|'c'
case|:
name|srcMode
operator|=
name|SM_F2O
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|opMode
operator|=
name|OM_UNZ
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|opMode
operator|=
name|OM_Z
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|forceOverwrite
operator|=
name|True
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|opMode
operator|=
name|OM_TEST
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|keepInputFiles
operator|=
name|True
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|smallMode
operator|=
name|True
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|noisy
operator|=
name|False
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
name|blockSize100k
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
name|blockSize100k
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'3'
case|:
name|blockSize100k
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|'4'
case|:
name|blockSize100k
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'5'
case|:
name|blockSize100k
operator|=
literal|5
expr_stmt|;
break|break;
case|case
literal|'6'
case|:
name|blockSize100k
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|'7'
case|:
name|blockSize100k
operator|=
literal|7
expr_stmt|;
break|break;
case|case
literal|'8'
case|:
name|blockSize100k
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|'9'
case|:
name|blockSize100k
operator|=
literal|9
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
case|case
literal|'L'
case|:
name|license
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbosity
operator|++
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|usage
argument_list|(
name|progName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Bad flag `%s'\n"
argument_list|,
name|progName
argument_list|,
name|aa
operator|->
name|name
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|progName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/*-- And again ... --*/
for|for
control|(
name|aa
operator|=
name|argList
init|;
name|aa
operator|!=
name|NULL
condition|;
name|aa
operator|=
name|aa
operator|->
name|link
control|)
block|{
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--"
argument_list|)
condition|)
break|break;
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--stdout"
argument_list|)
condition|)
name|srcMode
operator|=
name|SM_F2O
expr_stmt|;
elseif|else
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--decompress"
argument_list|)
condition|)
name|opMode
operator|=
name|OM_UNZ
expr_stmt|;
elseif|else
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--compress"
argument_list|)
condition|)
name|opMode
operator|=
name|OM_Z
expr_stmt|;
elseif|else
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--force"
argument_list|)
condition|)
name|forceOverwrite
operator|=
name|True
expr_stmt|;
elseif|else
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--test"
argument_list|)
condition|)
name|opMode
operator|=
name|OM_TEST
expr_stmt|;
elseif|else
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--keep"
argument_list|)
condition|)
name|keepInputFiles
operator|=
name|True
expr_stmt|;
elseif|else
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--small"
argument_list|)
condition|)
name|smallMode
operator|=
name|True
expr_stmt|;
elseif|else
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--quiet"
argument_list|)
condition|)
name|noisy
operator|=
name|False
expr_stmt|;
elseif|else
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--version"
argument_list|)
condition|)
name|license
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--license"
argument_list|)
condition|)
name|license
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--exponential"
argument_list|)
condition|)
name|workFactor
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--repetitive-best"
argument_list|)
condition|)
name|redundant
argument_list|(
name|aa
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--repetitive-fast"
argument_list|)
condition|)
name|redundant
argument_list|(
name|aa
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--verbose"
argument_list|)
condition|)
name|verbosity
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--help"
argument_list|)
condition|)
block|{
name|usage
argument_list|(
name|progName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|aa
operator|->
name|name
argument_list|,
literal|"--"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Bad flag `%s'\n"
argument_list|,
name|progName
argument_list|,
name|aa
operator|->
name|name
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|progName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|verbosity
operator|>
literal|4
condition|)
name|verbosity
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|opMode
operator|==
name|OM_Z
operator|&&
name|smallMode
operator|&&
name|blockSize100k
operator|>
literal|2
condition|)
name|blockSize100k
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|opMode
operator|==
name|OM_TEST
operator|&&
name|srcMode
operator|==
name|SM_F2O
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: -c and -t cannot be used together.\n"
argument_list|,
name|progName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|srcMode
operator|==
name|SM_F2O
operator|&&
name|numFileNames
operator|==
literal|0
condition|)
name|srcMode
operator|=
name|SM_I2O
expr_stmt|;
if|if
condition|(
name|opMode
operator|!=
name|OM_Z
condition|)
name|blockSize100k
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|srcMode
operator|==
name|SM_F2F
condition|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|mySignalCatcher
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|mySignalCatcher
argument_list|)
expr_stmt|;
if|#
directive|if
name|BZ_UNIX
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|mySignalCatcher
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|opMode
operator|==
name|OM_Z
condition|)
block|{
if|if
condition|(
name|srcMode
operator|==
name|SM_I2O
condition|)
block|{
name|compress
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|decode
operator|=
name|True
expr_stmt|;
for|for
control|(
name|aa
operator|=
name|argList
init|;
name|aa
operator|!=
name|NULL
condition|;
name|aa
operator|=
name|aa
operator|->
name|link
control|)
block|{
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--"
argument_list|)
condition|)
block|{
name|decode
operator|=
name|False
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|aa
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|decode
condition|)
continue|continue;
name|numFilesProcessed
operator|++
expr_stmt|;
name|compress
argument_list|(
name|aa
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|opMode
operator|==
name|OM_UNZ
condition|)
block|{
name|unzFailsExist
operator|=
name|False
expr_stmt|;
if|if
condition|(
name|srcMode
operator|==
name|SM_I2O
condition|)
block|{
name|uncompress
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|decode
operator|=
name|True
expr_stmt|;
for|for
control|(
name|aa
operator|=
name|argList
init|;
name|aa
operator|!=
name|NULL
condition|;
name|aa
operator|=
name|aa
operator|->
name|link
control|)
block|{
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--"
argument_list|)
condition|)
block|{
name|decode
operator|=
name|False
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|aa
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|decode
condition|)
continue|continue;
name|numFilesProcessed
operator|++
expr_stmt|;
name|uncompress
argument_list|(
name|aa
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|unzFailsExist
condition|)
block|{
name|setExit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exitValue
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|testFailsExist
operator|=
name|False
expr_stmt|;
if|if
condition|(
name|srcMode
operator|==
name|SM_I2O
condition|)
block|{
name|testf
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|decode
operator|=
name|True
expr_stmt|;
for|for
control|(
name|aa
operator|=
name|argList
init|;
name|aa
operator|!=
name|NULL
condition|;
name|aa
operator|=
name|aa
operator|->
name|link
control|)
block|{
if|if
condition|(
name|ISFLAG
argument_list|(
literal|"--"
argument_list|)
condition|)
block|{
name|decode
operator|=
name|False
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|aa
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|decode
condition|)
continue|continue;
name|numFilesProcessed
operator|++
expr_stmt|;
name|testf
argument_list|(
name|aa
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|testFailsExist
operator|&&
name|noisy
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
literal|"You can use the `bzip2recover' program to attempt to recover\n"
literal|"data from undamaged sections of corrupted files.\n\n"
argument_list|)
expr_stmt|;
name|setExit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exitValue
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Free the argument list memory to mollify leak detectors        (eg) Purify, Checker.  Serves no other useful purpose.    */
name|aa
operator|=
name|argList
expr_stmt|;
while|while
condition|(
name|aa
operator|!=
name|NULL
condition|)
block|{
name|Cell
modifier|*
name|aa2
init|=
name|aa
operator|->
name|link
decl_stmt|;
if|if
condition|(
name|aa
operator|->
name|name
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|aa
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|aa
argument_list|)
expr_stmt|;
name|aa
operator|=
name|aa2
expr_stmt|;
block|}
return|return
name|exitValue
return|;
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------*/
end_comment

begin_comment
comment|/*--- end                                         bzip2.c ---*/
end_comment

begin_comment
comment|/*-----------------------------------------------------------*/
end_comment

end_unit

