begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* A test program written to test robustness to decompression of    corrupted data.  Usage is         unzcrash filename    and the program will read the specified file, compress it (in memory),    and then repeatedly decompress it, each time with a different bit of    the compressed data inverted, so as to test all possible one-bit errors.    This should not cause any invalid memory accesses.  If it does,     I want to know about it!     PS.  As you can see from the above description, the process is    incredibly slow.  A file of size eg 5KB will cause it to run for    many hours. */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------    This file is part of bzip2/libbzip2, a program and library for    lossless, block-sorting data compression.     bzip2/libbzip2 version 1.0.4 of 20 December 2006    Copyright (C) 1996-2006 Julian Seward<jseward@bzip.org>     Please read the WARNING, DISCLAIMER and PATENTS sections in the     README file.     This program is released under the terms of the license contained    in the file LICENSE.    ------------------------------------------------------------------ */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"bzlib.h"
end_include

begin_define
define|#
directive|define
name|M_BLOCK
value|1000000
end_define

begin_typedef
typedef|typedef
name|unsigned
name|char
name|uchar
typedef|;
end_typedef

begin_define
define|#
directive|define
name|M_BLOCK_OUT
value|(M_BLOCK + 1000000)
end_define

begin_decl_stmt
name|uchar
name|inbuf
index|[
name|M_BLOCK
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uchar
name|outbuf
index|[
name|M_BLOCK_OUT
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uchar
name|zbuf
index|[
name|M_BLOCK
operator|+
literal|600
operator|+
operator|(
name|M_BLOCK
operator|/
literal|100
operator|)
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nIn
decl_stmt|,
name|nOut
decl_stmt|,
name|nZ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|bzerrorstrings
index|[]
init|=
block|{
literal|"OK"
block|,
literal|"SEQUENCE_ERROR"
block|,
literal|"PARAM_ERROR"
block|,
literal|"MEM_ERROR"
block|,
literal|"DATA_ERROR"
block|,
literal|"DATA_ERROR_MAGIC"
block|,
literal|"IO_ERROR"
block|,
literal|"UNEXPECTED_EOF"
block|,
literal|"OUTBUFF_FULL"
block|,
literal|"???"
comment|/* for future */
block|,
literal|"???"
comment|/* for future */
block|,
literal|"???"
comment|/* for future */
block|,
literal|"???"
comment|/* for future */
block|,
literal|"???"
comment|/* for future */
block|,
literal|"???"
comment|/* for future */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|flip_bit
parameter_list|(
name|int
name|bit
parameter_list|)
block|{
name|int
name|byteno
init|=
name|bit
operator|/
literal|8
decl_stmt|;
name|int
name|bitno
init|=
name|bit
operator|%
literal|8
decl_stmt|;
name|uchar
name|mask
init|=
literal|1
operator|<<
name|bitno
decl_stmt|;
comment|//fprintf ( stderr, "(byte %d  bit %d  mask %d)",
comment|//          byteno, bitno, (int)mask );
name|zbuf
index|[
name|byteno
index|]
operator|^=
name|mask
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|r
decl_stmt|;
name|int
name|bit
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: unzcrash filename\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|f
operator|=
name|fopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unzcrash: can't open %s\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|nIn
operator|=
name|fread
argument_list|(
name|inbuf
argument_list|,
literal|1
argument_list|,
name|M_BLOCK
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d bytes read\n"
argument_list|,
name|nIn
argument_list|)
expr_stmt|;
name|nZ
operator|=
name|M_BLOCK
expr_stmt|;
name|r
operator|=
name|BZ2_bzBuffToBuffCompress
argument_list|(
name|zbuf
argument_list|,
operator|&
name|nZ
argument_list|,
name|inbuf
argument_list|,
name|nIn
argument_list|,
literal|9
argument_list|,
literal|0
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|r
operator|==
name|BZ_OK
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d after compression\n"
argument_list|,
name|nZ
argument_list|)
expr_stmt|;
for|for
control|(
name|bit
operator|=
literal|0
init|;
name|bit
operator|<
name|nZ
operator|*
literal|8
condition|;
name|bit
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bit %d  "
argument_list|,
name|bit
argument_list|)
expr_stmt|;
name|flip_bit
argument_list|(
name|bit
argument_list|)
expr_stmt|;
name|nOut
operator|=
name|M_BLOCK_OUT
expr_stmt|;
name|r
operator|=
name|BZ2_bzBuffToBuffDecompress
argument_list|(
name|outbuf
argument_list|,
operator|&
name|nOut
argument_list|,
name|zbuf
argument_list|,
name|nZ
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %d  %s "
argument_list|,
name|r
argument_list|,
name|bzerrorstrings
index|[
operator|-
name|r
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|BZ_OK
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nOut
operator|!=
name|nIn
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"nIn/nOut mismatch %d %d\n"
argument_list|,
name|nIn
argument_list|,
name|nOut
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nOut
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|inbuf
index|[
name|i
index|]
operator|!=
name|outbuf
index|[
name|i
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mismatch at %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|i
operator|==
name|nOut
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"really ok!\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|flip_bit
argument_list|(
name|bit
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|assert (nOut == nIn);    for (i = 0; i< nOut; i++) {      if (inbuf[i] != outbuf[i]) {         fprintf ( stderr, "difference at %d !\n", i );         return 1;      }    }
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"all ok\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

