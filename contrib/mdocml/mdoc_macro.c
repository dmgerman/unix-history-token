begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$Id: mdoc_macro.c,v 1.157 2014/12/13 13:14:39 schwarze Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2008-2012 Kristaps Dzonsons<kristaps@bsd.lv>  * Copyright (c) 2010, 2012, 2013, 2014 Ingo Schwarze<schwarze@openbsd.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|"mdoc.h"
end_include

begin_include
include|#
directive|include
file|"mandoc.h"
end_include

begin_include
include|#
directive|include
file|"libmdoc.h"
end_include

begin_include
include|#
directive|include
file|"libmandoc.h"
end_include

begin_enum
enum|enum
name|rew
block|{
comment|/* see rew_dohalt() */
name|REWIND_NONE
block|,
name|REWIND_THIS
block|,
name|REWIND_MORE
block|,
name|REWIND_FORCE
block|,
name|REWIND_LATER
block|,
name|REWIND_ERROR
block|}
enum|;
end_enum

begin_function_decl
specifier|static
name|void
name|blk_full
parameter_list|(
name|MACRO_PROT_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|blk_exp_close
parameter_list|(
name|MACRO_PROT_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|blk_part_exp
parameter_list|(
name|MACRO_PROT_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|blk_part_imp
parameter_list|(
name|MACRO_PROT_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctx_synopsis
parameter_list|(
name|MACRO_PROT_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|in_line_eoln
parameter_list|(
name|MACRO_PROT_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|in_line_argn
parameter_list|(
name|MACRO_PROT_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|in_line
parameter_list|(
name|MACRO_PROT_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|phrase_ta
parameter_list|(
name|MACRO_PROT_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dword
parameter_list|(
name|struct
name|mdoc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|enum
name|mdelim
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|append_delims
parameter_list|(
name|struct
name|mdoc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|mdoct
name|lookup
parameter_list|(
name|struct
name|mdoc
modifier|*
parameter_list|,
name|enum
name|mdoct
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|macro_or_word
parameter_list|(
name|MACRO_PROT_ARGS
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|make_pending
parameter_list|(
name|struct
name|mdoc_node
modifier|*
parameter_list|,
name|enum
name|mdoct
parameter_list|,
name|struct
name|mdoc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parse_rest
parameter_list|(
name|struct
name|mdoc
modifier|*
parameter_list|,
name|enum
name|mdoct
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|mdoct
name|rew_alt
parameter_list|(
name|enum
name|mdoct
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rew
name|rew_dohalt
parameter_list|(
name|enum
name|mdoct
parameter_list|,
name|enum
name|mdoc_type
parameter_list|,
specifier|const
name|struct
name|mdoc_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rew_elem
parameter_list|(
name|struct
name|mdoc
modifier|*
parameter_list|,
name|enum
name|mdoct
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rew_last
parameter_list|(
name|struct
name|mdoc
modifier|*
parameter_list|,
specifier|const
name|struct
name|mdoc_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rew_sub
parameter_list|(
name|enum
name|mdoc_type
parameter_list|,
name|struct
name|mdoc
modifier|*
parameter_list|,
name|enum
name|mdoct
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|const
name|struct
name|mdoc_macro
name|__mdoc_macros
index|[
name|MDOC_MAX
index|]
init|=
block|{
block|{
name|in_line_argn
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Ap */
block|{
name|in_line_eoln
block|,
name|MDOC_PROLOGUE
block|}
block|,
comment|/* Dd */
block|{
name|in_line_eoln
block|,
name|MDOC_PROLOGUE
block|}
block|,
comment|/* Dt */
block|{
name|in_line_eoln
block|,
name|MDOC_PROLOGUE
block|}
block|,
comment|/* Os */
block|{
name|blk_full
block|,
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Sh */
block|{
name|blk_full
block|,
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Ss */
block|{
name|in_line_eoln
block|,
literal|0
block|}
block|,
comment|/* Pp */
block|{
name|blk_part_imp
block|,
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* D1 */
block|{
name|blk_part_imp
block|,
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Dl */
block|{
name|blk_full
block|,
name|MDOC_EXPLICIT
block|}
block|,
comment|/* Bd */
block|{
name|blk_exp_close
block|,
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Ed */
block|{
name|blk_full
block|,
name|MDOC_EXPLICIT
block|}
block|,
comment|/* Bl */
block|{
name|blk_exp_close
block|,
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* El */
block|{
name|blk_full
block|,
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* It */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Ad */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* An */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Ar */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Cd */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Cm */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Dv */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Er */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Ev */
block|{
name|in_line_eoln
block|,
literal|0
block|}
block|,
comment|/* Ex */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Fa */
block|{
name|in_line_eoln
block|,
literal|0
block|}
block|,
comment|/* Fd */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Fl */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Fn */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Ft */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Ic */
block|{
name|in_line_argn
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* In */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Li */
block|{
name|blk_full
block|,
name|MDOC_JOIN
block|}
block|,
comment|/* Nd */
block|{
name|ctx_synopsis
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Nm */
block|{
name|blk_part_imp
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Op */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Ot */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Pa */
block|{
name|in_line_eoln
block|,
literal|0
block|}
block|,
comment|/* Rv */
block|{
name|in_line_argn
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* St */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Va */
block|{
name|ctx_synopsis
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Vt */
block|{
name|in_line_argn
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Xr */
block|{
name|in_line_eoln
block|,
name|MDOC_JOIN
block|}
block|,
comment|/* %A */
block|{
name|in_line_eoln
block|,
name|MDOC_JOIN
block|}
block|,
comment|/* %B */
block|{
name|in_line_eoln
block|,
name|MDOC_JOIN
block|}
block|,
comment|/* %D */
block|{
name|in_line_eoln
block|,
name|MDOC_JOIN
block|}
block|,
comment|/* %I */
block|{
name|in_line_eoln
block|,
name|MDOC_JOIN
block|}
block|,
comment|/* %J */
block|{
name|in_line_eoln
block|,
literal|0
block|}
block|,
comment|/* %N */
block|{
name|in_line_eoln
block|,
name|MDOC_JOIN
block|}
block|,
comment|/* %O */
block|{
name|in_line_eoln
block|,
literal|0
block|}
block|,
comment|/* %P */
block|{
name|in_line_eoln
block|,
name|MDOC_JOIN
block|}
block|,
comment|/* %R */
block|{
name|in_line_eoln
block|,
name|MDOC_JOIN
block|}
block|,
comment|/* %T */
block|{
name|in_line_eoln
block|,
literal|0
block|}
block|,
comment|/* %V */
block|{
name|blk_exp_close
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Ac */
block|{
name|blk_part_exp
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Ao */
block|{
name|blk_part_imp
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Aq */
block|{
name|in_line_argn
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* At */
block|{
name|blk_exp_close
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Bc */
block|{
name|blk_full
block|,
name|MDOC_EXPLICIT
block|}
block|,
comment|/* Bf */
block|{
name|blk_part_exp
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Bo */
block|{
name|blk_part_imp
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Bq */
block|{
name|in_line_argn
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Bsx */
block|{
name|in_line_argn
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Bx */
block|{
name|in_line_eoln
block|,
literal|0
block|}
block|,
comment|/* Db */
block|{
name|blk_exp_close
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Dc */
block|{
name|blk_part_exp
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Do */
block|{
name|blk_part_imp
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Dq */
block|{
name|blk_exp_close
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_EXPLICIT
block|}
block|,
comment|/* Ec */
block|{
name|blk_exp_close
block|,
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Ef */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Em */
block|{
name|blk_part_exp
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_EXPLICIT
block|}
block|,
comment|/* Eo */
block|{
name|in_line_argn
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Fx */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Ms */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* No */
block|{
name|in_line_argn
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_IGNDELIM
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Ns */
block|{
name|in_line_argn
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Nx */
block|{
name|in_line_argn
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Ox */
block|{
name|blk_exp_close
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Pc */
block|{
name|in_line_argn
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_IGNDELIM
block|}
block|,
comment|/* Pf */
block|{
name|blk_part_exp
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Po */
block|{
name|blk_part_imp
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Pq */
block|{
name|blk_exp_close
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Qc */
block|{
name|blk_part_imp
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Ql */
block|{
name|blk_part_exp
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Qo */
block|{
name|blk_part_imp
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Qq */
block|{
name|blk_exp_close
block|,
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Re */
block|{
name|blk_full
block|,
name|MDOC_EXPLICIT
block|}
block|,
comment|/* Rs */
block|{
name|blk_exp_close
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Sc */
block|{
name|blk_part_exp
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* So */
block|{
name|blk_part_imp
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Sq */
block|{
name|in_line_argn
block|,
literal|0
block|}
block|,
comment|/* Sm */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Sx */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Sy */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Tn */
block|{
name|in_line_argn
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Ux */
block|{
name|blk_exp_close
block|,
name|MDOC_EXPLICIT
operator||
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Xc */
block|{
name|blk_part_exp
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_EXPLICIT
block|}
block|,
comment|/* Xo */
block|{
name|blk_full
block|,
name|MDOC_EXPLICIT
operator||
name|MDOC_CALLABLE
block|}
block|,
comment|/* Fo */
block|{
name|blk_exp_close
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Fc */
block|{
name|blk_part_exp
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Oo */
block|{
name|blk_exp_close
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Oc */
block|{
name|blk_full
block|,
name|MDOC_EXPLICIT
block|}
block|,
comment|/* Bk */
block|{
name|blk_exp_close
block|,
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Ek */
block|{
name|in_line_eoln
block|,
literal|0
block|}
block|,
comment|/* Bt */
block|{
name|in_line_eoln
block|,
literal|0
block|}
block|,
comment|/* Hf */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Fr */
block|{
name|in_line_eoln
block|,
literal|0
block|}
block|,
comment|/* Ud */
block|{
name|in_line
block|,
literal|0
block|}
block|,
comment|/* Lb */
block|{
name|in_line_eoln
block|,
literal|0
block|}
block|,
comment|/* Lp */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Lk */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Mt */
block|{
name|blk_part_imp
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Brq */
block|{
name|blk_part_exp
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Bro */
block|{
name|blk_exp_close
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Brc */
block|{
name|in_line_eoln
block|,
name|MDOC_JOIN
block|}
block|,
comment|/* %C */
block|{
name|in_line_argn
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Es */
block|{
name|blk_part_imp
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* En */
block|{
name|in_line_argn
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Dx */
block|{
name|in_line_eoln
block|,
name|MDOC_JOIN
block|}
block|,
comment|/* %Q */
block|{
name|in_line_eoln
block|,
literal|0
block|}
block|,
comment|/* br */
block|{
name|in_line_eoln
block|,
literal|0
block|}
block|,
comment|/* sp */
block|{
name|in_line_eoln
block|,
literal|0
block|}
block|,
comment|/* %U */
block|{
name|phrase_ta
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Ta */
block|{
name|in_line_eoln
block|,
name|MDOC_PROLOGUE
block|}
block|,
comment|/* ll */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|mdoc_macro
modifier|*
specifier|const
name|mdoc_macros
init|=
name|__mdoc_macros
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This is called at the end of parsing.  It must traverse up the tree,  * closing out open [implicit] scopes.  Obviously, open explicit scopes  * are errors.  */
end_comment

begin_function
name|void
name|mdoc_macroend
parameter_list|(
name|struct
name|mdoc
modifier|*
name|mdoc
parameter_list|)
block|{
name|struct
name|mdoc_node
modifier|*
name|n
decl_stmt|;
comment|/* Scan for open explicit scopes. */
name|n
operator|=
name|mdoc
operator|->
name|last
operator|->
name|flags
operator|&
name|MDOC_VALID
condition|?
name|mdoc
operator|->
name|last
operator|->
name|parent
else|:
name|mdoc
operator|->
name|last
expr_stmt|;
for|for
control|(
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|parent
control|)
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|MDOC_BLOCK
operator|&&
name|mdoc_macros
index|[
name|n
operator|->
name|tok
index|]
operator|.
name|flags
operator|&
name|MDOC_EXPLICIT
condition|)
name|mandoc_msg
argument_list|(
name|MANDOCERR_BLK_NOEND
argument_list|,
name|mdoc
operator|->
name|parse
argument_list|,
name|n
operator|->
name|line
argument_list|,
name|n
operator|->
name|pos
argument_list|,
name|mdoc_macronames
index|[
name|n
operator|->
name|tok
index|]
argument_list|)
expr_stmt|;
comment|/* Rewind to the first. */
name|rew_last
argument_list|(
name|mdoc
argument_list|,
name|mdoc
operator|->
name|first
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Look up the macro at *p called by "from",  * or as a line macro if from == MDOC_MAX.  */
end_comment

begin_function
specifier|static
name|enum
name|mdoct
name|lookup
parameter_list|(
name|struct
name|mdoc
modifier|*
name|mdoc
parameter_list|,
name|enum
name|mdoct
name|from
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|ppos
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
name|enum
name|mdoct
name|res
decl_stmt|;
if|if
condition|(
name|from
operator|==
name|MDOC_MAX
operator|||
name|mdoc_macros
index|[
name|from
index|]
operator|.
name|flags
operator|&
name|MDOC_PARSED
condition|)
block|{
name|res
operator|=
name|mdoc_hash_find
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|MDOC_MAX
condition|)
block|{
if|if
condition|(
name|mdoc_macros
index|[
name|res
index|]
operator|.
name|flags
operator|&
name|MDOC_CALLABLE
condition|)
return|return
operator|(
name|res
operator|)
return|;
if|if
condition|(
name|res
operator|!=
name|MDOC_br
operator|&&
name|res
operator|!=
name|MDOC_sp
operator|&&
name|res
operator|!=
name|MDOC_ll
condition|)
name|mandoc_msg
argument_list|(
name|MANDOCERR_MACRO_CALL
argument_list|,
name|mdoc
operator|->
name|parse
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|MDOC_MAX
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rew_last
parameter_list|(
name|struct
name|mdoc
modifier|*
name|mdoc
parameter_list|,
specifier|const
name|struct
name|mdoc_node
modifier|*
name|to
parameter_list|)
block|{
name|struct
name|mdoc_node
modifier|*
name|n
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|assert
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|mdoc
operator|->
name|next
operator|=
name|MDOC_NEXT_SIBLING
expr_stmt|;
while|while
condition|(
name|mdoc
operator|->
name|last
operator|!=
name|to
condition|)
block|{
comment|/* 		 * Save the parent here, because we may delete the 		 * mdoc->last node in the post-validation phase and reset 		 * it to mdoc->last->parent, causing a step in the closing 		 * out to be lost. 		 */
name|np
operator|=
name|mdoc
operator|->
name|last
operator|->
name|parent
expr_stmt|;
name|mdoc_valid_post
argument_list|(
name|mdoc
argument_list|)
expr_stmt|;
name|n
operator|=
name|mdoc
operator|->
name|last
expr_stmt|;
name|mdoc
operator|->
name|last
operator|=
name|np
expr_stmt|;
name|assert
argument_list|(
name|mdoc
operator|->
name|last
argument_list|)
expr_stmt|;
name|mdoc
operator|->
name|last
operator|->
name|last
operator|=
name|n
expr_stmt|;
block|}
name|mdoc_valid_post
argument_list|(
name|mdoc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * For a block closing macro, return the corresponding opening one.  * Otherwise, return the macro itself.  */
end_comment

begin_function
specifier|static
name|enum
name|mdoct
name|rew_alt
parameter_list|(
name|enum
name|mdoct
name|tok
parameter_list|)
block|{
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|MDOC_Ac
case|:
return|return
operator|(
name|MDOC_Ao
operator|)
return|;
case|case
name|MDOC_Bc
case|:
return|return
operator|(
name|MDOC_Bo
operator|)
return|;
case|case
name|MDOC_Brc
case|:
return|return
operator|(
name|MDOC_Bro
operator|)
return|;
case|case
name|MDOC_Dc
case|:
return|return
operator|(
name|MDOC_Do
operator|)
return|;
case|case
name|MDOC_Ec
case|:
return|return
operator|(
name|MDOC_Eo
operator|)
return|;
case|case
name|MDOC_Ed
case|:
return|return
operator|(
name|MDOC_Bd
operator|)
return|;
case|case
name|MDOC_Ef
case|:
return|return
operator|(
name|MDOC_Bf
operator|)
return|;
case|case
name|MDOC_Ek
case|:
return|return
operator|(
name|MDOC_Bk
operator|)
return|;
case|case
name|MDOC_El
case|:
return|return
operator|(
name|MDOC_Bl
operator|)
return|;
case|case
name|MDOC_Fc
case|:
return|return
operator|(
name|MDOC_Fo
operator|)
return|;
case|case
name|MDOC_Oc
case|:
return|return
operator|(
name|MDOC_Oo
operator|)
return|;
case|case
name|MDOC_Pc
case|:
return|return
operator|(
name|MDOC_Po
operator|)
return|;
case|case
name|MDOC_Qc
case|:
return|return
operator|(
name|MDOC_Qo
operator|)
return|;
case|case
name|MDOC_Re
case|:
return|return
operator|(
name|MDOC_Rs
operator|)
return|;
case|case
name|MDOC_Sc
case|:
return|return
operator|(
name|MDOC_So
operator|)
return|;
case|case
name|MDOC_Xc
case|:
return|return
operator|(
name|MDOC_Xo
operator|)
return|;
default|default:
return|return
operator|(
name|tok
operator|)
return|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * Rewinding to tok, how do we have to handle *p?  * REWIND_NONE: *p would delimit tok, but no tok scope is open  *   inside *p, so there is no need to rewind anything at all.  * REWIND_THIS: *p matches tok, so rewind *p and nothing else.  * REWIND_MORE: *p is implicit, rewind it and keep searching for tok.  * REWIND_FORCE: *p is explicit, but tok is full, force rewinding *p.  * REWIND_LATER: *p is explicit and still open, postpone rewinding.  * REWIND_ERROR: No tok block is open at all.  */
end_comment

begin_function
specifier|static
name|enum
name|rew
name|rew_dohalt
parameter_list|(
name|enum
name|mdoct
name|tok
parameter_list|,
name|enum
name|mdoc_type
name|type
parameter_list|,
specifier|const
name|struct
name|mdoc_node
modifier|*
name|p
parameter_list|)
block|{
comment|/* 	 * No matching token, no delimiting block, no broken block. 	 * This can happen when full implicit macros are called for 	 * the first time but try to rewind their previous 	 * instance anyway. 	 */
if|if
condition|(
name|MDOC_ROOT
operator|==
name|p
operator|->
name|type
condition|)
return|return
operator|(
name|MDOC_BLOCK
operator|==
name|type
operator|&&
name|MDOC_EXPLICIT
operator|&
name|mdoc_macros
index|[
name|tok
index|]
operator|.
name|flags
condition|?
name|REWIND_ERROR
else|:
name|REWIND_NONE
operator|)
return|;
comment|/* 	 * When starting to rewind, skip plain text 	 * and nodes that have already been rewound. 	 */
if|if
condition|(
name|MDOC_TEXT
operator|==
name|p
operator|->
name|type
operator|||
name|MDOC_VALID
operator|&
name|p
operator|->
name|flags
condition|)
return|return
operator|(
name|REWIND_MORE
operator|)
return|;
comment|/* 	 * The easiest case:  Found a matching token. 	 * This applies to both blocks and elements. 	 */
name|tok
operator|=
name|rew_alt
argument_list|(
name|tok
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|p
operator|->
name|tok
condition|)
return|return
operator|(
name|p
operator|->
name|end
condition|?
name|REWIND_NONE
else|:
name|type
operator|==
name|p
operator|->
name|type
condition|?
name|REWIND_THIS
else|:
name|REWIND_MORE
operator|)
return|;
comment|/* 	 * While elements do require rewinding for themselves, 	 * they never affect rewinding of other nodes. 	 */
if|if
condition|(
name|MDOC_ELEM
operator|==
name|p
operator|->
name|type
condition|)
return|return
operator|(
name|REWIND_MORE
operator|)
return|;
comment|/* 	 * Blocks delimited by our target token get REWIND_MORE. 	 * Blocks delimiting our target token get REWIND_NONE. 	 */
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|MDOC_Bl
case|:
if|if
condition|(
name|MDOC_It
operator|==
name|p
operator|->
name|tok
condition|)
return|return
operator|(
name|REWIND_MORE
operator|)
return|;
break|break;
case|case
name|MDOC_It
case|:
if|if
condition|(
name|MDOC_BODY
operator|==
name|p
operator|->
name|type
operator|&&
name|MDOC_Bl
operator|==
name|p
operator|->
name|tok
condition|)
return|return
operator|(
name|REWIND_NONE
operator|)
return|;
break|break;
comment|/* 	 * XXX Badly nested block handling still fails badly 	 * when one block is breaking two blocks of the same type. 	 * This is an incomplete and extremely ugly workaround, 	 * required to let the OpenBSD tree build. 	 */
case|case
name|MDOC_Oo
case|:
if|if
condition|(
name|MDOC_Op
operator|==
name|p
operator|->
name|tok
condition|)
return|return
operator|(
name|REWIND_MORE
operator|)
return|;
break|break;
case|case
name|MDOC_Nm
case|:
return|return
operator|(
name|REWIND_NONE
operator|)
return|;
case|case
name|MDOC_Nd
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_Ss
case|:
if|if
condition|(
name|MDOC_BODY
operator|==
name|p
operator|->
name|type
operator|&&
name|MDOC_Sh
operator|==
name|p
operator|->
name|tok
condition|)
return|return
operator|(
name|REWIND_NONE
operator|)
return|;
comment|/* FALLTHROUGH */
case|case
name|MDOC_Sh
case|:
if|if
condition|(
name|MDOC_ROOT
operator|==
name|p
operator|->
name|parent
operator|->
name|type
condition|)
return|return
operator|(
name|REWIND_THIS
operator|)
return|;
if|if
condition|(
name|MDOC_Nd
operator|==
name|p
operator|->
name|tok
operator|||
name|MDOC_Ss
operator|==
name|p
operator|->
name|tok
operator|||
name|MDOC_Sh
operator|==
name|p
operator|->
name|tok
condition|)
return|return
operator|(
name|REWIND_MORE
operator|)
return|;
break|break;
default|default:
break|break;
block|}
comment|/* 	 * Default block rewinding rules. 	 * In particular, always skip block end markers, 	 * and let all blocks rewind Nm children. 	 * Do not warn again when closing a block, 	 * since closing the body already warned. 	 */
if|if
condition|(
name|ENDBODY_NOT
operator|!=
name|p
operator|->
name|end
operator|||
name|MDOC_Nm
operator|==
name|p
operator|->
name|tok
operator|||
name|MDOC_BLOCK
operator|==
name|type
operator|||
operator|(
name|MDOC_BLOCK
operator|==
name|p
operator|->
name|type
operator|&&
operator|!
operator|(
name|MDOC_EXPLICIT
operator|&
name|mdoc_macros
index|[
name|tok
index|]
operator|.
name|flags
operator|)
operator|)
condition|)
return|return
operator|(
name|REWIND_MORE
operator|)
return|;
comment|/* 	 * By default, closing out full blocks 	 * forces closing of broken explicit blocks, 	 * while closing out partial blocks 	 * allows delayed rewinding by default. 	 */
return|return
operator|(
operator|&
name|blk_full
operator|==
name|mdoc_macros
index|[
name|tok
index|]
operator|.
name|fp
condition|?
name|REWIND_FORCE
else|:
name|REWIND_LATER
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rew_elem
parameter_list|(
name|struct
name|mdoc
modifier|*
name|mdoc
parameter_list|,
name|enum
name|mdoct
name|tok
parameter_list|)
block|{
name|struct
name|mdoc_node
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|mdoc
operator|->
name|last
expr_stmt|;
if|if
condition|(
name|MDOC_ELEM
operator|!=
name|n
operator|->
name|type
condition|)
name|n
operator|=
name|n
operator|->
name|parent
expr_stmt|;
name|assert
argument_list|(
name|MDOC_ELEM
operator|==
name|n
operator|->
name|type
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tok
operator|==
name|n
operator|->
name|tok
argument_list|)
expr_stmt|;
name|rew_last
argument_list|(
name|mdoc
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We are trying to close a block identified by tok,  * but the child block *broken is still open.  * Thus, postpone closing the tok block  * until the rew_sub call closing *broken.  */
end_comment

begin_function
specifier|static
name|int
name|make_pending
parameter_list|(
name|struct
name|mdoc_node
modifier|*
name|broken
parameter_list|,
name|enum
name|mdoct
name|tok
parameter_list|,
name|struct
name|mdoc
modifier|*
name|mdoc
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|ppos
parameter_list|)
block|{
name|struct
name|mdoc_node
modifier|*
name|breaker
decl_stmt|;
comment|/* 	 * Iterate backwards, searching for the block matching tok, 	 * that is, the block breaking the *broken block. 	 */
for|for
control|(
name|breaker
operator|=
name|broken
operator|->
name|parent
init|;
name|breaker
condition|;
name|breaker
operator|=
name|breaker
operator|->
name|parent
control|)
block|{
comment|/* 		 * If the *broken block had already been broken before 		 * and we encounter its breaker, make the tok block 		 * pending on the inner breaker. 		 * Graphically, "[A breaker=[B broken=[C->B B] tok=A] C]" 		 * becomes "[A broken=[B [C->B B] tok=A] C]" 		 * and finally "[A [B->A [C->B B] A] C]". 		 */
if|if
condition|(
name|breaker
operator|==
name|broken
operator|->
name|pending
condition|)
block|{
name|broken
operator|=
name|breaker
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|REWIND_THIS
operator|!=
name|rew_dohalt
argument_list|(
name|tok
argument_list|,
name|MDOC_BLOCK
argument_list|,
name|breaker
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|MDOC_BODY
operator|==
name|broken
operator|->
name|type
condition|)
name|broken
operator|=
name|broken
operator|->
name|parent
expr_stmt|;
comment|/* 		 * Found the breaker. 		 * If another, outer breaker is already pending on 		 * the *broken block, we must not clobber the link 		 * to the outer breaker, but make it pending on the 		 * new, now inner breaker. 		 * Graphically, "[A breaker=[B broken=[C->A A] tok=B] C]" 		 * becomes "[A breaker=[B->A broken=[C A] tok=B] C]" 		 * and finally "[A [B->A [C->B A] B] C]". 		 */
if|if
condition|(
name|broken
operator|->
name|pending
condition|)
block|{
name|struct
name|mdoc_node
modifier|*
name|taker
decl_stmt|;
comment|/* 			 * If the breaker had also been broken before, 			 * it cannot take on the outer breaker itself, 			 * but must hand it on to its own breakers. 			 * Graphically, this is the following situation: 			 * "[A [B breaker=[C->B B] broken=[D->A A] tok=C] D]" 			 * "[A taker=[B->A breaker=[C->B B] [D->C A] C] D]" 			 */
name|taker
operator|=
name|breaker
expr_stmt|;
while|while
condition|(
name|taker
operator|->
name|pending
condition|)
name|taker
operator|=
name|taker
operator|->
name|pending
expr_stmt|;
name|taker
operator|->
name|pending
operator|=
name|broken
operator|->
name|pending
expr_stmt|;
block|}
name|broken
operator|->
name|pending
operator|=
name|breaker
expr_stmt|;
name|mandoc_vmsg
argument_list|(
name|MANDOCERR_BLK_NEST
argument_list|,
name|mdoc
operator|->
name|parse
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
literal|"%s breaks %s"
argument_list|,
name|mdoc_macronames
index|[
name|tok
index|]
argument_list|,
name|mdoc_macronames
index|[
name|broken
operator|->
name|tok
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Found no matching block for tok. 	 * Are you trying to close a block that is not open? 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rew_sub
parameter_list|(
name|enum
name|mdoc_type
name|t
parameter_list|,
name|struct
name|mdoc
modifier|*
name|mdoc
parameter_list|,
name|enum
name|mdoct
name|tok
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|ppos
parameter_list|)
block|{
name|struct
name|mdoc_node
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|mdoc
operator|->
name|last
expr_stmt|;
while|while
condition|(
name|n
condition|)
block|{
switch|switch
condition|(
name|rew_dohalt
argument_list|(
name|tok
argument_list|,
name|t
argument_list|,
name|n
argument_list|)
condition|)
block|{
case|case
name|REWIND_NONE
case|:
return|return;
case|case
name|REWIND_THIS
case|:
name|n
operator|->
name|lastline
operator|=
name|line
operator|-
operator|(
name|mdoc
operator|->
name|flags
operator|&
name|MDOC_NEWLINE
operator|&&
operator|!
operator|(
name|mdoc_macros
index|[
name|tok
index|]
operator|.
name|flags
operator|&
name|MDOC_EXPLICIT
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|REWIND_FORCE
case|:
name|mandoc_vmsg
argument_list|(
name|MANDOCERR_BLK_BROKEN
argument_list|,
name|mdoc
operator|->
name|parse
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
literal|"%s breaks %s"
argument_list|,
name|mdoc_macronames
index|[
name|tok
index|]
argument_list|,
name|mdoc_macronames
index|[
name|n
operator|->
name|tok
index|]
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|REWIND_MORE
case|:
name|n
operator|->
name|lastline
operator|=
name|line
operator|-
operator|(
name|mdoc
operator|->
name|flags
operator|&
name|MDOC_NEWLINE
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|n
operator|=
name|n
operator|->
name|parent
expr_stmt|;
continue|continue;
case|case
name|REWIND_LATER
case|:
if|if
condition|(
name|make_pending
argument_list|(
name|n
argument_list|,
name|tok
argument_list|,
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|)
operator|||
name|t
operator|!=
name|MDOC_BLOCK
condition|)
return|return;
comment|/* FALLTHROUGH */
case|case
name|REWIND_ERROR
case|:
name|mandoc_msg
argument_list|(
name|MANDOCERR_BLK_NOTOPEN
argument_list|,
name|mdoc
operator|->
name|parse
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|mdoc_macronames
index|[
name|tok
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
name|assert
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|rew_last
argument_list|(
name|mdoc
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* 	 * The current block extends an enclosing block. 	 * Now that the current block ends, close the enclosing block, too. 	 */
while|while
condition|(
operator|(
name|n
operator|=
name|n
operator|->
name|pending
operator|)
operator|!=
name|NULL
condition|)
block|{
name|rew_last
argument_list|(
name|mdoc
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|MDOC_HEAD
condition|)
name|mdoc_body_alloc
argument_list|(
name|mdoc
argument_list|,
name|n
operator|->
name|line
argument_list|,
name|n
operator|->
name|pos
argument_list|,
name|n
operator|->
name|tok
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Allocate a word and check whether it's punctuation or not.  * Punctuation consists of those tokens found in mdoc_isdelim().  */
end_comment

begin_function
specifier|static
name|void
name|dword
parameter_list|(
name|struct
name|mdoc
modifier|*
name|mdoc
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|col
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|enum
name|mdelim
name|d
parameter_list|,
name|int
name|may_append
parameter_list|)
block|{
if|if
condition|(
name|d
operator|==
name|DELIM_MAX
condition|)
name|d
operator|=
name|mdoc_isdelim
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|may_append
operator|&&
operator|!
operator|(
name|mdoc
operator|->
name|flags
operator|&
operator|(
name|MDOC_SYNOPSIS
operator||
name|MDOC_KEEP
operator||
name|MDOC_SMOFF
operator|)
operator|)
operator|&&
name|d
operator|==
name|DELIM_NONE
operator|&&
name|mdoc
operator|->
name|last
operator|->
name|type
operator|==
name|MDOC_TEXT
operator|&&
name|mdoc_isdelim
argument_list|(
name|mdoc
operator|->
name|last
operator|->
name|string
argument_list|)
operator|==
name|DELIM_NONE
condition|)
block|{
name|mdoc_word_append
argument_list|(
name|mdoc
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
name|mdoc_word_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|col
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* 	 * If the word consists of a bare delimiter, 	 * flag the new node accordingly, 	 * unless doing so was vetoed by the invoking macro. 	 * Always clear the veto, it is only valid for one word. 	 */
if|if
condition|(
name|d
operator|==
name|DELIM_OPEN
condition|)
name|mdoc
operator|->
name|last
operator|->
name|flags
operator||=
name|MDOC_DELIMO
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|==
name|DELIM_CLOSE
operator|&&
operator|!
operator|(
name|mdoc
operator|->
name|flags
operator|&
name|MDOC_NODELIMC
operator|)
operator|&&
name|mdoc
operator|->
name|last
operator|->
name|parent
operator|->
name|tok
operator|!=
name|MDOC_Fd
condition|)
name|mdoc
operator|->
name|last
operator|->
name|flags
operator||=
name|MDOC_DELIMC
expr_stmt|;
name|mdoc
operator|->
name|flags
operator|&=
operator|~
name|MDOC_NODELIMC
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|append_delims
parameter_list|(
name|struct
name|mdoc
modifier|*
name|mdoc
parameter_list|,
name|int
name|line
parameter_list|,
name|int
modifier|*
name|pos
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|la
decl_stmt|;
if|if
condition|(
name|buf
index|[
operator|*
name|pos
index|]
operator|==
literal|'\0'
condition|)
return|return;
for|for
control|(
init|;
condition|;
control|)
block|{
name|la
operator|=
operator|*
name|pos
expr_stmt|;
if|if
condition|(
name|mdoc_args
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|,
name|MDOC_MAX
argument_list|,
operator|&
name|p
argument_list|)
operator|==
name|ARGS_EOLN
condition|)
break|break;
name|dword
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|la
argument_list|,
name|p
argument_list|,
name|DELIM_MAX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * If we encounter end-of-sentence symbols, then trigger 		 * the double-space. 		 * 		 * XXX: it's easy to allow this to propagate outward to 		 * the last symbol, such that `. )' will cause the 		 * correct double-spacing.  However, (1) groff isn't 		 * smart enough to do this and (2) it would require 		 * knowing which symbols break this behaviour, for 		 * example, `.  ;' shouldn't propagate the double-space. 		 */
if|if
condition|(
name|mandoc_eos
argument_list|(
name|p
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
name|mdoc
operator|->
name|last
operator|->
name|flags
operator||=
name|MDOC_EOS
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Parse one word.  * If it is a macro, call it and return 1.  * Otherwise, allocate it and return 0.  */
end_comment

begin_function
specifier|static
name|int
name|macro_or_word
parameter_list|(
name|MACRO_PROT_ARGS
parameter_list|,
name|int
name|parsed
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|enum
name|mdoct
name|ntok
decl_stmt|;
name|p
operator|=
name|buf
operator|+
name|ppos
expr_stmt|;
name|ntok
operator|=
name|MDOC_MAX
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'"'
condition|)
name|p
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|parsed
operator|&&
operator|!
operator|(
name|mdoc
operator|->
name|flags
operator|&
name|MDOC_PHRASELIT
operator|)
condition|)
name|ntok
operator|=
name|lookup
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntok
operator|==
name|MDOC_MAX
condition|)
block|{
name|dword
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|p
argument_list|,
name|DELIM_MAX
argument_list|,
name|tok
operator|==
name|MDOC_MAX
operator|||
name|mdoc_macros
index|[
name|tok
index|]
operator|.
name|flags
operator|&
name|MDOC_JOIN
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|mdoc_macros
index|[
name|tok
index|]
operator|.
name|fp
operator|==
name|in_line_eoln
condition|)
name|rew_elem
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|)
expr_stmt|;
name|mdoc_macro
argument_list|(
name|mdoc
argument_list|,
name|ntok
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|MDOC_MAX
condition|)
name|append_delims
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Close out block partial/full explicit.  */
end_comment

begin_function
specifier|static
name|void
name|blk_exp_close
parameter_list|(
name|MACRO_PROT_ARGS
parameter_list|)
block|{
name|struct
name|mdoc_node
modifier|*
name|body
decl_stmt|;
comment|/* Our own body. */
name|struct
name|mdoc_node
modifier|*
name|endbody
decl_stmt|;
comment|/* Our own end marker. */
name|struct
name|mdoc_node
modifier|*
name|later
decl_stmt|;
comment|/* A sub-block starting later. */
name|struct
name|mdoc_node
modifier|*
name|n
decl_stmt|;
comment|/* For searching backwards. */
name|int
name|j
decl_stmt|,
name|lastarg
decl_stmt|,
name|maxargs
decl_stmt|,
name|flushed
decl_stmt|,
name|nl
decl_stmt|;
name|enum
name|margserr
name|ac
decl_stmt|;
name|enum
name|mdoct
name|atok
decl_stmt|,
name|ntok
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|nl
operator|=
name|MDOC_NEWLINE
operator|&
name|mdoc
operator|->
name|flags
expr_stmt|;
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|MDOC_Ec
case|:
name|maxargs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MDOC_Ek
case|:
name|mdoc
operator|->
name|flags
operator|&=
operator|~
name|MDOC_KEEP
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
name|maxargs
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* 	 * Search backwards for beginnings of blocks, 	 * both of our own and of pending sub-blocks. 	 */
name|atok
operator|=
name|rew_alt
argument_list|(
name|tok
argument_list|)
expr_stmt|;
name|body
operator|=
name|endbody
operator|=
name|later
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|n
operator|=
name|mdoc
operator|->
name|last
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|parent
control|)
block|{
if|if
condition|(
name|n
operator|->
name|flags
operator|&
name|MDOC_VALID
condition|)
continue|continue;
comment|/* Remember the start of our own body. */
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|MDOC_BODY
operator|&&
name|atok
operator|==
name|n
operator|->
name|tok
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|end
operator|==
name|ENDBODY_NOT
condition|)
name|body
operator|=
name|n
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|n
operator|->
name|type
operator|!=
name|MDOC_BLOCK
operator|||
name|n
operator|->
name|tok
operator|==
name|MDOC_Nm
condition|)
continue|continue;
if|if
condition|(
name|atok
operator|==
name|n
operator|->
name|tok
condition|)
block|{
name|assert
argument_list|(
name|body
argument_list|)
expr_stmt|;
comment|/* 			 * Found the start of our own block. 			 * When there is no pending sub block, 			 * just proceed to closing out. 			 */
if|if
condition|(
name|later
operator|==
name|NULL
condition|)
break|break;
comment|/* 			 * When there is a pending sub block, 			 * postpone closing out the current block 			 * until the rew_sub() closing out the sub-block. 			 */
name|make_pending
argument_list|(
name|later
argument_list|,
name|tok
argument_list|,
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|)
expr_stmt|;
comment|/* 			 * Mark the place where the formatting - but not 			 * the scope - of the current block ends. 			 */
name|mdoc_endbody_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|atok
argument_list|,
name|body
argument_list|,
name|ENDBODY_SPACE
argument_list|)
expr_stmt|;
comment|/* 			 * If a block closing macro taking arguments 			 * breaks another block, put the arguments 			 * into the end marker and remeber the 			 * end marker in order to close it out. 			 */
if|if
condition|(
name|maxargs
condition|)
block|{
name|endbody
operator|=
name|mdoc
operator|->
name|last
expr_stmt|;
name|mdoc
operator|->
name|next
operator|=
name|MDOC_NEXT_CHILD
expr_stmt|;
block|}
break|break;
block|}
comment|/* 		 * When finding an open sub block, remember the last 		 * open explicit block, or, in case there are only 		 * implicit ones, the first open implicit block. 		 */
if|if
condition|(
name|later
operator|&&
name|mdoc_macros
index|[
name|later
operator|->
name|tok
index|]
operator|.
name|flags
operator|&
name|MDOC_EXPLICIT
condition|)
continue|continue;
if|if
condition|(
name|n
operator|->
name|tok
operator|!=
name|MDOC_It
condition|)
name|later
operator|=
name|n
expr_stmt|;
block|}
name|rew_sub
argument_list|(
name|MDOC_BODY
argument_list|,
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mdoc_macros
index|[
name|tok
index|]
operator|.
name|flags
operator|&
name|MDOC_PARSED
operator|)
condition|)
block|{
if|if
condition|(
name|buf
index|[
operator|*
name|pos
index|]
operator|!=
literal|'\0'
condition|)
name|mandoc_vmsg
argument_list|(
name|MANDOCERR_ARG_SKIP
argument_list|,
name|mdoc
operator|->
name|parse
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
literal|"%s %s"
argument_list|,
name|mdoc_macronames
index|[
name|tok
index|]
argument_list|,
name|buf
operator|+
operator|*
name|pos
argument_list|)
expr_stmt|;
name|rew_sub
argument_list|(
name|MDOC_BLOCK
argument_list|,
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|maxargs
operator|&&
name|endbody
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Stray .Ec without previous .Eo: 			 * Break the output line, ignore any arguments. 			 */
name|mdoc_elem_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|MDOC_br
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rew_elem
argument_list|(
name|mdoc
argument_list|,
name|MDOC_br
argument_list|)
expr_stmt|;
block|}
else|else
name|mdoc_tail_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|atok
argument_list|)
expr_stmt|;
block|}
name|flushed
operator|=
name|n
operator|==
name|NULL
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
condition|;
name|j
operator|++
control|)
block|{
name|lastarg
operator|=
operator|*
name|pos
expr_stmt|;
if|if
condition|(
name|j
operator|==
name|maxargs
operator|&&
operator|!
name|flushed
condition|)
block|{
if|if
condition|(
name|endbody
operator|==
name|NULL
condition|)
name|rew_sub
argument_list|(
name|MDOC_BLOCK
argument_list|,
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|)
expr_stmt|;
else|else
name|rew_last
argument_list|(
name|mdoc
argument_list|,
name|endbody
argument_list|)
expr_stmt|;
name|flushed
operator|=
literal|1
expr_stmt|;
block|}
name|ac
operator|=
name|mdoc_args
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|,
name|tok
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
operator|==
name|ARGS_PUNCT
operator|||
name|ac
operator|==
name|ARGS_EOLN
condition|)
break|break;
name|ntok
operator|=
name|ac
operator|==
name|ARGS_QWORD
condition|?
name|MDOC_MAX
else|:
name|lookup
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|lastarg
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntok
operator|==
name|MDOC_MAX
condition|)
block|{
name|dword
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|lastarg
argument_list|,
name|p
argument_list|,
name|DELIM_MAX
argument_list|,
name|MDOC_JOIN
operator|&
name|mdoc_macros
index|[
name|tok
index|]
operator|.
name|flags
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|flushed
condition|)
block|{
if|if
condition|(
name|endbody
operator|==
name|NULL
condition|)
name|rew_sub
argument_list|(
name|MDOC_BLOCK
argument_list|,
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|)
expr_stmt|;
else|else
name|rew_last
argument_list|(
name|mdoc
argument_list|,
name|endbody
argument_list|)
expr_stmt|;
name|flushed
operator|=
literal|1
expr_stmt|;
block|}
name|mdoc
operator|->
name|flags
operator|&=
operator|~
name|MDOC_NEWLINE
expr_stmt|;
name|mdoc_macro
argument_list|(
name|mdoc
argument_list|,
name|ntok
argument_list|,
name|line
argument_list|,
name|lastarg
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|flushed
condition|)
block|{
if|if
condition|(
name|endbody
operator|==
name|NULL
condition|)
name|rew_sub
argument_list|(
name|MDOC_BLOCK
argument_list|,
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|)
expr_stmt|;
else|else
name|rew_last
argument_list|(
name|mdoc
argument_list|,
name|endbody
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nl
condition|)
name|append_delims
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|in_line
parameter_list|(
name|MACRO_PROT_ARGS
parameter_list|)
block|{
name|int
name|la
decl_stmt|,
name|scope
decl_stmt|,
name|cnt
decl_stmt|,
name|firstarg
decl_stmt|,
name|mayopen
decl_stmt|,
name|nc
decl_stmt|,
name|nl
decl_stmt|;
name|enum
name|mdoct
name|ntok
decl_stmt|;
name|enum
name|margserr
name|ac
decl_stmt|;
name|enum
name|mdelim
name|d
decl_stmt|;
name|struct
name|mdoc_arg
modifier|*
name|arg
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|nl
operator|=
name|MDOC_NEWLINE
operator|&
name|mdoc
operator|->
name|flags
expr_stmt|;
comment|/* 	 * Whether we allow ignored elements (those without content, 	 * usually because of reserved words) to squeak by. 	 */
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|MDOC_An
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_Ar
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_Fl
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_Mt
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_Nm
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_Pa
case|:
name|nc
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|nc
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|mdoc_argv
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|tok
argument_list|,
operator|&
name|arg
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|d
operator|=
name|DELIM_NONE
expr_stmt|;
name|firstarg
operator|=
literal|1
expr_stmt|;
name|mayopen
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|cnt
operator|=
name|scope
operator|=
literal|0
init|;
condition|;
control|)
block|{
name|la
operator|=
operator|*
name|pos
expr_stmt|;
name|ac
operator|=
name|mdoc_args
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|,
name|tok
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* 		 * At the end of a macro line, 		 * opening delimiters do not suppress spacing. 		 */
if|if
condition|(
name|ac
operator|==
name|ARGS_EOLN
condition|)
block|{
if|if
condition|(
name|d
operator|==
name|DELIM_OPEN
condition|)
name|mdoc
operator|->
name|last
operator|->
name|flags
operator|&=
operator|~
name|MDOC_DELIMO
expr_stmt|;
break|break;
block|}
comment|/* 		 * The rest of the macro line is only punctuation, 		 * to be handled by append_delims(). 		 * If there were no other arguments, 		 * do not allow the first one to suppress spacing, 		 * even if it turns out to be a closing one. 		 */
if|if
condition|(
name|ac
operator|==
name|ARGS_PUNCT
condition|)
block|{
if|if
condition|(
name|cnt
operator|==
literal|0
operator|&&
name|nc
operator|==
literal|0
condition|)
name|mdoc
operator|->
name|flags
operator||=
name|MDOC_NODELIMC
expr_stmt|;
break|break;
block|}
name|ntok
operator|=
operator|(
name|ac
operator|==
name|ARGS_QWORD
operator|||
operator|(
name|tok
operator|==
name|MDOC_Fn
operator|&&
operator|!
name|cnt
operator|)
operator|)
condition|?
name|MDOC_MAX
else|:
name|lookup
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|la
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* 		 * In this case, we've located a submacro and must 		 * execute it.  Close out scope, if open.  If no 		 * elements have been generated, either create one (nc) 		 * or raise a warning. 		 */
if|if
condition|(
name|ntok
operator|!=
name|MDOC_MAX
condition|)
block|{
if|if
condition|(
name|scope
condition|)
name|rew_elem
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|)
expr_stmt|;
if|if
condition|(
name|nc
operator|&&
operator|!
name|cnt
condition|)
block|{
name|mdoc_elem_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|rew_last
argument_list|(
name|mdoc
argument_list|,
name|mdoc
operator|->
name|last
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|nc
operator|&&
operator|!
name|cnt
condition|)
block|{
name|mdoc_argv_free
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|mandoc_msg
argument_list|(
name|MANDOCERR_MACRO_EMPTY
argument_list|,
name|mdoc
operator|->
name|parse
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|mdoc_macronames
index|[
name|tok
index|]
argument_list|)
expr_stmt|;
block|}
name|mdoc_macro
argument_list|(
name|mdoc
argument_list|,
name|ntok
argument_list|,
name|line
argument_list|,
name|la
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
condition|)
name|append_delims
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * Non-quote-enclosed punctuation.  Set up our scope, if 		 * a word; rewind the scope, if a delimiter; then append 		 * the word. 		 */
name|d
operator|=
name|ac
operator|==
name|ARGS_QWORD
condition|?
name|DELIM_NONE
else|:
name|mdoc_isdelim
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|DELIM_NONE
operator|!=
name|d
condition|)
block|{
comment|/* 			 * If we encounter closing punctuation, no word 			 * has been emitted, no scope is open, and we're 			 * allowed to have an empty element, then start 			 * a new scope. 			 */
if|if
condition|(
operator|(
name|d
operator|==
name|DELIM_CLOSE
operator|||
operator|(
name|d
operator|==
name|DELIM_MIDDLE
operator|&&
name|tok
operator|==
name|MDOC_Fl
operator|)
operator|)
operator|&&
operator|!
name|cnt
operator|&&
operator|!
name|scope
operator|&&
name|nc
operator|&&
name|mayopen
condition|)
block|{
name|mdoc_elem_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|scope
operator|=
literal|1
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|MDOC_Nm
condition|)
name|mayopen
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 			 * Close out our scope, if one is open, before 			 * any punctuation. 			 */
if|if
condition|(
name|scope
condition|)
name|rew_elem
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|)
expr_stmt|;
name|scope
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|MDOC_Fn
condition|)
name|mayopen
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mayopen
operator|&&
operator|!
name|scope
condition|)
block|{
name|mdoc_elem_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|scope
operator|=
literal|1
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
name|dword
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|la
argument_list|,
name|p
argument_list|,
name|d
argument_list|,
name|MDOC_JOIN
operator|&
name|mdoc_macros
index|[
name|tok
index|]
operator|.
name|flags
argument_list|)
expr_stmt|;
comment|/* 		 * If the first argument is a closing delimiter, 		 * do not suppress spacing before it. 		 */
if|if
condition|(
name|firstarg
operator|&&
name|d
operator|==
name|DELIM_CLOSE
operator|&&
operator|!
name|nc
condition|)
name|mdoc
operator|->
name|last
operator|->
name|flags
operator|&=
operator|~
name|MDOC_DELIMC
expr_stmt|;
name|firstarg
operator|=
literal|0
expr_stmt|;
comment|/* 		 * `Fl' macros have their scope re-opened with each new 		 * word so that the `-' can be added to each one without 		 * having to parse out spaces. 		 */
if|if
condition|(
name|scope
operator|&&
name|tok
operator|==
name|MDOC_Fl
condition|)
block|{
name|rew_elem
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|)
expr_stmt|;
name|scope
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|scope
condition|)
name|rew_elem
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|)
expr_stmt|;
comment|/* 	 * If no elements have been collected and we're allowed to have 	 * empties (nc), open a scope and close it out.  Otherwise, 	 * raise a warning. 	 */
if|if
condition|(
operator|!
name|cnt
condition|)
block|{
if|if
condition|(
name|nc
condition|)
block|{
name|mdoc_elem_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|rew_last
argument_list|(
name|mdoc
argument_list|,
name|mdoc
operator|->
name|last
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mdoc_argv_free
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|mandoc_msg
argument_list|(
name|MANDOCERR_MACRO_EMPTY
argument_list|,
name|mdoc
operator|->
name|parse
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|mdoc_macronames
index|[
name|tok
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nl
condition|)
name|append_delims
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|blk_full
parameter_list|(
name|MACRO_PROT_ARGS
parameter_list|)
block|{
name|int
name|la
decl_stmt|,
name|nl
decl_stmt|,
name|parsed
decl_stmt|;
name|struct
name|mdoc_arg
modifier|*
name|arg
decl_stmt|;
name|struct
name|mdoc_node
modifier|*
name|head
decl_stmt|;
comment|/* save of head macro */
name|struct
name|mdoc_node
modifier|*
name|body
decl_stmt|;
comment|/* save of body macro */
name|struct
name|mdoc_node
modifier|*
name|n
decl_stmt|;
name|enum
name|margserr
name|ac
decl_stmt|,
name|lac
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|nl
operator|=
name|MDOC_NEWLINE
operator|&
name|mdoc
operator|->
name|flags
expr_stmt|;
comment|/* Skip items outside lists. */
if|if
condition|(
name|tok
operator|==
name|MDOC_It
condition|)
block|{
for|for
control|(
name|n
operator|=
name|mdoc
operator|->
name|last
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|parent
control|)
if|if
condition|(
name|n
operator|->
name|tok
operator|==
name|MDOC_Bl
operator|&&
operator|!
operator|(
name|n
operator|->
name|flags
operator|&
name|MDOC_VALID
operator|)
condition|)
break|break;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|mandoc_vmsg
argument_list|(
name|MANDOCERR_IT_STRAY
argument_list|,
name|mdoc
operator|->
name|parse
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
literal|"It %s"
argument_list|,
name|buf
operator|+
operator|*
name|pos
argument_list|)
expr_stmt|;
name|mdoc_elem_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|MDOC_br
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rew_elem
argument_list|(
name|mdoc
argument_list|,
name|MDOC_br
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Close out prior implicit scope. */
if|if
condition|(
operator|!
operator|(
name|mdoc_macros
index|[
name|tok
index|]
operator|.
name|flags
operator|&
name|MDOC_EXPLICIT
operator|)
condition|)
block|{
name|rew_sub
argument_list|(
name|MDOC_BODY
argument_list|,
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|)
expr_stmt|;
name|rew_sub
argument_list|(
name|MDOC_BLOCK
argument_list|,
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * This routine accommodates implicitly- and explicitly-scoped 	 * macro openings.  Implicit ones first close out prior scope 	 * (seen above).  Delay opening the head until necessary to 	 * allow leading punctuation to print.  Special consideration 	 * for `It -column', which has phrase-part syntax instead of 	 * regular child nodes. 	 */
name|mdoc_argv
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|tok
argument_list|,
operator|&
name|arg
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|mdoc_block_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|head
operator|=
name|body
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Exception: Heads of `It' macros in `-diag' lists are not 	 * parsed, even though `It' macros in general are parsed. 	 */
name|parsed
operator|=
name|tok
operator|!=
name|MDOC_It
operator|||
name|mdoc
operator|->
name|last
operator|->
name|parent
operator|->
name|tok
operator|!=
name|MDOC_Bl
operator|||
name|mdoc
operator|->
name|last
operator|->
name|parent
operator|->
name|norm
operator|->
name|Bl
operator|.
name|type
operator|!=
name|LIST_diag
expr_stmt|;
comment|/* 	 * The `Nd' macro has all arguments in its body: it's a hybrid 	 * of block partial-explicit and full-implicit.  Stupid. 	 */
if|if
condition|(
name|tok
operator|==
name|MDOC_Nd
condition|)
block|{
name|head
operator|=
name|mdoc_head_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|)
expr_stmt|;
name|rew_sub
argument_list|(
name|MDOC_HEAD
argument_list|,
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|)
expr_stmt|;
name|body
operator|=
name|mdoc_body_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tok
operator|==
name|MDOC_Bk
condition|)
name|mdoc
operator|->
name|flags
operator||=
name|MDOC_KEEP
expr_stmt|;
name|ac
operator|=
name|ARGS_PEND
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|la
operator|=
operator|*
name|pos
expr_stmt|;
name|lac
operator|=
name|ac
expr_stmt|;
name|ac
operator|=
name|mdoc_args
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|,
name|tok
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
operator|==
name|ARGS_PUNCT
condition|)
break|break;
if|if
condition|(
name|ac
operator|==
name|ARGS_EOLN
condition|)
block|{
if|if
condition|(
name|lac
operator|!=
name|ARGS_PPHRASE
operator|&&
name|lac
operator|!=
name|ARGS_PHRASE
condition|)
break|break;
comment|/* 			 * This is necessary: if the last token on a 			 * line is a `Ta' or tab, then we'll get 			 * ARGS_EOLN, so we must be smart enough to 			 * reopen our scope if the last parse was a 			 * phrase or partial phrase. 			 */
name|rew_sub
argument_list|(
name|MDOC_BODY
argument_list|,
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|)
expr_stmt|;
name|body
operator|=
name|mdoc_body_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * Emit leading punctuation (i.e., punctuation before 		 * the MDOC_HEAD) for non-phrase types. 		 */
if|if
condition|(
name|head
operator|==
name|NULL
operator|&&
name|ac
operator|!=
name|ARGS_PEND
operator|&&
name|ac
operator|!=
name|ARGS_PHRASE
operator|&&
name|ac
operator|!=
name|ARGS_PPHRASE
operator|&&
name|ac
operator|!=
name|ARGS_QWORD
operator|&&
name|mdoc_isdelim
argument_list|(
name|p
argument_list|)
operator|==
name|DELIM_OPEN
condition|)
block|{
name|dword
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|la
argument_list|,
name|p
argument_list|,
name|DELIM_OPEN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Open a head if one hasn't been opened. */
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
name|head
operator|=
name|mdoc_head_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
operator|==
name|ARGS_PHRASE
operator|||
name|ac
operator|==
name|ARGS_PEND
operator|||
name|ac
operator|==
name|ARGS_PPHRASE
condition|)
block|{
comment|/* 			 * If we haven't opened a body yet, rewind the 			 * head; if we have, rewind that instead. 			 */
name|rew_sub
argument_list|(
name|body
condition|?
name|MDOC_BODY
else|:
name|MDOC_HEAD
argument_list|,
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|)
expr_stmt|;
name|body
operator|=
name|mdoc_body_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|)
expr_stmt|;
comment|/* 			 * Process phrases: set whether we're in a 			 * partial-phrase (this effects line handling) 			 * then call down into the phrase parser. 			 */
if|if
condition|(
name|ac
operator|==
name|ARGS_PPHRASE
condition|)
name|mdoc
operator|->
name|flags
operator||=
name|MDOC_PPHRASE
expr_stmt|;
if|if
condition|(
name|ac
operator|==
name|ARGS_PEND
operator|&&
name|lac
operator|==
name|ARGS_PPHRASE
condition|)
name|mdoc
operator|->
name|flags
operator||=
name|MDOC_PPHRASE
expr_stmt|;
name|parse_rest
argument_list|(
name|mdoc
argument_list|,
name|MDOC_MAX
argument_list|,
name|line
argument_list|,
operator|&
name|la
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|mdoc
operator|->
name|flags
operator|&=
operator|~
name|MDOC_PPHRASE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|macro_or_word
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|la
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|,
name|parsed
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
name|head
operator|=
name|mdoc_head_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
condition|)
name|append_delims
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|body
operator|!=
name|NULL
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * If there is an open (i.e., unvalidated) sub-block requiring 	 * explicit close-out, postpone switching the current block from 	 * head to body until the rew_sub() call closing out that 	 * sub-block. 	 */
for|for
control|(
name|n
operator|=
name|mdoc
operator|->
name|last
init|;
name|n
operator|&&
name|n
operator|!=
name|head
condition|;
name|n
operator|=
name|n
operator|->
name|parent
control|)
block|{
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|MDOC_BLOCK
operator|&&
name|mdoc_macros
index|[
name|n
operator|->
name|tok
index|]
operator|.
name|flags
operator|&
name|MDOC_EXPLICIT
operator|&&
operator|!
operator|(
name|n
operator|->
name|flags
operator|&
name|MDOC_VALID
operator|)
condition|)
block|{
name|n
operator|->
name|pending
operator|=
name|head
expr_stmt|;
return|return;
block|}
block|}
comment|/* Close out scopes to remain in a consistent state. */
name|rew_sub
argument_list|(
name|MDOC_HEAD
argument_list|,
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|)
expr_stmt|;
name|mdoc_body_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|mdoc
operator|->
name|flags
operator|&
name|MDOC_FREECOL
condition|)
block|{
name|rew_sub
argument_list|(
name|MDOC_BODY
argument_list|,
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|)
expr_stmt|;
name|rew_sub
argument_list|(
name|MDOC_BLOCK
argument_list|,
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|)
expr_stmt|;
name|mdoc
operator|->
name|flags
operator|&=
operator|~
name|MDOC_FREECOL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|blk_part_imp
parameter_list|(
name|MACRO_PROT_ARGS
parameter_list|)
block|{
name|int
name|la
decl_stmt|,
name|nl
decl_stmt|;
name|enum
name|margserr
name|ac
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|mdoc_node
modifier|*
name|blk
decl_stmt|;
comment|/* saved block context */
name|struct
name|mdoc_node
modifier|*
name|body
decl_stmt|;
comment|/* saved body context */
name|struct
name|mdoc_node
modifier|*
name|n
decl_stmt|;
name|nl
operator|=
name|MDOC_NEWLINE
operator|&
name|mdoc
operator|->
name|flags
expr_stmt|;
comment|/* 	 * A macro that spans to the end of the line.  This is generally 	 * (but not necessarily) called as the first macro.  The block 	 * has a head as the immediate child, which is always empty, 	 * followed by zero or more opening punctuation nodes, then the 	 * body (which may be empty, depending on the macro), then zero 	 * or more closing punctuation nodes. 	 */
name|blk
operator|=
name|mdoc_block_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mdoc_head_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|)
expr_stmt|;
name|rew_sub
argument_list|(
name|MDOC_HEAD
argument_list|,
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|)
expr_stmt|;
comment|/* 	 * Open the body scope "on-demand", that is, after we've 	 * processed all our the leading delimiters (open parenthesis, 	 * etc.). 	 */
for|for
control|(
name|body
operator|=
name|NULL
init|;
condition|;
control|)
block|{
name|la
operator|=
operator|*
name|pos
expr_stmt|;
name|ac
operator|=
name|mdoc_args
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|,
name|tok
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
operator|==
name|ARGS_EOLN
operator|||
name|ac
operator|==
name|ARGS_PUNCT
condition|)
break|break;
if|if
condition|(
name|body
operator|==
name|NULL
operator|&&
name|ac
operator|!=
name|ARGS_QWORD
operator|&&
name|mdoc_isdelim
argument_list|(
name|p
argument_list|)
operator|==
name|DELIM_OPEN
condition|)
block|{
name|dword
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|la
argument_list|,
name|p
argument_list|,
name|DELIM_OPEN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|body
operator|==
name|NULL
condition|)
name|body
operator|=
name|mdoc_body_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|)
expr_stmt|;
if|if
condition|(
name|macro_or_word
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|la
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|body
operator|==
name|NULL
condition|)
name|body
operator|=
name|mdoc_body_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|)
expr_stmt|;
comment|/* 	 * If there is an open sub-block requiring explicit close-out, 	 * postpone closing out the current block 	 * until the rew_sub() call closing out the sub-block. 	 */
for|for
control|(
name|n
operator|=
name|mdoc
operator|->
name|last
init|;
name|n
operator|&&
name|n
operator|!=
name|body
operator|&&
name|n
operator|!=
name|blk
operator|->
name|parent
condition|;
name|n
operator|=
name|n
operator|->
name|parent
control|)
block|{
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|MDOC_BLOCK
operator|&&
name|mdoc_macros
index|[
name|n
operator|->
name|tok
index|]
operator|.
name|flags
operator|&
name|MDOC_EXPLICIT
operator|&&
operator|!
operator|(
name|n
operator|->
name|flags
operator|&
name|MDOC_VALID
operator|)
condition|)
block|{
name|make_pending
argument_list|(
name|n
argument_list|,
name|tok
argument_list|,
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|)
expr_stmt|;
name|mdoc_endbody_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|,
name|body
argument_list|,
name|ENDBODY_NOSPACE
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|assert
argument_list|(
name|n
operator|==
name|body
argument_list|)
expr_stmt|;
name|rew_sub
argument_list|(
name|MDOC_BODY
argument_list|,
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
condition|)
name|append_delims
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|rew_sub
argument_list|(
name|MDOC_BLOCK
argument_list|,
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|)
expr_stmt|;
comment|/* Move trailing .Ns out of scope. */
for|for
control|(
name|n
operator|=
name|body
operator|->
name|child
init|;
name|n
operator|&&
name|n
operator|->
name|next
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
comment|/* Do nothing. */
empty_stmt|;
if|if
condition|(
name|n
operator|&&
name|n
operator|->
name|tok
operator|==
name|MDOC_Ns
condition|)
name|mdoc_node_relink
argument_list|(
name|mdoc
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|blk_part_exp
parameter_list|(
name|MACRO_PROT_ARGS
parameter_list|)
block|{
name|int
name|la
decl_stmt|,
name|nl
decl_stmt|;
name|enum
name|margserr
name|ac
decl_stmt|;
name|struct
name|mdoc_node
modifier|*
name|head
decl_stmt|;
comment|/* keep track of head */
name|struct
name|mdoc_node
modifier|*
name|body
decl_stmt|;
comment|/* keep track of body */
name|char
modifier|*
name|p
decl_stmt|;
name|nl
operator|=
name|MDOC_NEWLINE
operator|&
name|mdoc
operator|->
name|flags
expr_stmt|;
comment|/* 	 * The opening of an explicit macro having zero or more leading 	 * punctuation nodes; a head with optional single element (the 	 * case of `Eo'); and a body that may be empty. 	 */
name|mdoc_block_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|head
operator|=
name|body
operator|=
name|NULL
init|;
condition|;
control|)
block|{
name|la
operator|=
operator|*
name|pos
expr_stmt|;
name|ac
operator|=
name|mdoc_args
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|,
name|tok
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
operator|==
name|ARGS_PUNCT
operator|||
name|ac
operator|==
name|ARGS_EOLN
condition|)
break|break;
comment|/* Flush out leading punctuation. */
if|if
condition|(
name|head
operator|==
name|NULL
operator|&&
name|ac
operator|!=
name|ARGS_QWORD
operator|&&
name|mdoc_isdelim
argument_list|(
name|p
argument_list|)
operator|==
name|DELIM_OPEN
condition|)
block|{
name|assert
argument_list|(
name|NULL
operator|==
name|body
argument_list|)
expr_stmt|;
name|dword
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|la
argument_list|,
name|p
argument_list|,
name|DELIM_OPEN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|body
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|head
operator|=
name|mdoc_head_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * `Eo' gobbles any data into the head, but most other 		 * macros just immediately close out and begin the body. 		 */
if|if
condition|(
name|body
operator|==
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|head
argument_list|)
expr_stmt|;
comment|/* No check whether it's a macro! */
if|if
condition|(
name|tok
operator|==
name|MDOC_Eo
condition|)
name|dword
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|la
argument_list|,
name|p
argument_list|,
name|DELIM_MAX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rew_sub
argument_list|(
name|MDOC_HEAD
argument_list|,
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|)
expr_stmt|;
name|body
operator|=
name|mdoc_body_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|MDOC_Eo
condition|)
continue|continue;
block|}
name|assert
argument_list|(
name|head
operator|!=
name|NULL
operator|&&
name|body
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|macro_or_word
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|la
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
block|}
comment|/* Clean-up to leave in a consistent state. */
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
name|mdoc_head_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|)
expr_stmt|;
if|if
condition|(
name|body
operator|==
name|NULL
condition|)
block|{
name|rew_sub
argument_list|(
name|MDOC_HEAD
argument_list|,
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|)
expr_stmt|;
name|mdoc_body_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nl
condition|)
name|append_delims
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|in_line_argn
parameter_list|(
name|MACRO_PROT_ARGS
parameter_list|)
block|{
name|int
name|la
decl_stmt|,
name|flushed
decl_stmt|,
name|j
decl_stmt|,
name|maxargs
decl_stmt|,
name|nl
decl_stmt|;
name|enum
name|margserr
name|ac
decl_stmt|;
name|struct
name|mdoc_arg
modifier|*
name|arg
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|enum
name|mdoct
name|ntok
decl_stmt|;
name|nl
operator|=
name|mdoc
operator|->
name|flags
operator|&
name|MDOC_NEWLINE
expr_stmt|;
comment|/* 	 * A line macro that has a fixed number of arguments (maxargs). 	 * Only open the scope once the first non-leading-punctuation is 	 * found (unless MDOC_IGNDELIM is noted, like in `Pf'), then 	 * keep it open until the maximum number of arguments are 	 * exhausted. 	 */
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|MDOC_Ap
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_Ns
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_Ux
case|:
name|maxargs
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MDOC_Bx
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_Es
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_Xr
case|:
name|maxargs
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|maxargs
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|mdoc_argv
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|tok
argument_list|,
operator|&
name|arg
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|p
operator|=
name|NULL
expr_stmt|;
name|flushed
operator|=
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|la
operator|=
operator|*
name|pos
expr_stmt|;
name|ac
operator|=
name|mdoc_args
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|,
name|tok
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
operator|==
name|ARGS_PUNCT
operator|||
name|ac
operator|==
name|ARGS_EOLN
condition|)
block|{
if|if
condition|(
name|j
operator|<
literal|2
operator|&&
name|tok
operator|==
name|MDOC_Pf
condition|)
name|mandoc_vmsg
argument_list|(
name|MANDOCERR_PF_SKIP
argument_list|,
name|mdoc
operator|->
name|parse
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
literal|"Pf %s"
argument_list|,
name|p
operator|==
name|NULL
condition|?
literal|"at eol"
else|:
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|mdoc_macros
index|[
name|tok
index|]
operator|.
name|flags
operator|&
name|MDOC_IGNDELIM
operator|)
operator|&&
name|ac
operator|!=
name|ARGS_QWORD
operator|&&
name|j
operator|==
literal|0
operator|&&
name|mdoc_isdelim
argument_list|(
name|p
argument_list|)
operator|==
name|DELIM_OPEN
condition|)
block|{
name|dword
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|la
argument_list|,
name|p
argument_list|,
name|DELIM_OPEN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|j
operator|==
literal|0
condition|)
name|mdoc_elem_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|==
name|maxargs
operator|&&
operator|!
name|flushed
condition|)
block|{
name|rew_elem
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|)
expr_stmt|;
name|flushed
operator|=
literal|1
expr_stmt|;
block|}
name|ntok
operator|=
operator|(
name|ac
operator|==
name|ARGS_QWORD
operator|||
operator|(
name|tok
operator|==
name|MDOC_Pf
operator|&&
name|j
operator|==
literal|0
operator|)
operator|)
condition|?
name|MDOC_MAX
else|:
name|lookup
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|la
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntok
operator|!=
name|MDOC_MAX
condition|)
block|{
if|if
condition|(
operator|!
name|flushed
condition|)
name|rew_elem
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|)
expr_stmt|;
name|flushed
operator|=
literal|1
expr_stmt|;
name|mdoc_macro
argument_list|(
name|mdoc
argument_list|,
name|ntok
argument_list|,
name|line
argument_list|,
name|la
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|mdoc_macros
index|[
name|tok
index|]
operator|.
name|flags
operator|&
name|MDOC_IGNDELIM
operator|)
operator|&&
name|ac
operator|!=
name|ARGS_QWORD
operator|&&
operator|!
name|flushed
operator|&&
name|mdoc_isdelim
argument_list|(
name|p
argument_list|)
operator|!=
name|DELIM_NONE
condition|)
block|{
name|rew_elem
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|)
expr_stmt|;
name|flushed
operator|=
literal|1
expr_stmt|;
block|}
name|dword
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|la
argument_list|,
name|p
argument_list|,
name|DELIM_MAX
argument_list|,
name|MDOC_JOIN
operator|&
name|mdoc_macros
index|[
name|tok
index|]
operator|.
name|flags
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|==
literal|0
condition|)
block|{
name|mdoc_elem_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
operator|==
name|ARGS_PUNCT
operator|&&
name|tok
operator|==
name|MDOC_Pf
condition|)
name|append_delims
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|flushed
condition|)
name|rew_elem
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
condition|)
name|append_delims
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|in_line_eoln
parameter_list|(
name|MACRO_PROT_ARGS
parameter_list|)
block|{
name|struct
name|mdoc_arg
modifier|*
name|arg
decl_stmt|;
if|if
condition|(
name|tok
operator|==
name|MDOC_Pp
condition|)
name|rew_sub
argument_list|(
name|MDOC_BLOCK
argument_list|,
name|mdoc
argument_list|,
name|MDOC_Nm
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|)
expr_stmt|;
name|mdoc_argv
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|tok
argument_list|,
operator|&
name|arg
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|mdoc_elem_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_rest
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
condition|)
return|return;
name|rew_elem
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The simplest argument parser available: Parse the remaining  * words until the end of the phrase or line and return 0  * or until the next macro, call that macro, and return 1.  */
end_comment

begin_function
specifier|static
name|int
name|parse_rest
parameter_list|(
name|struct
name|mdoc
modifier|*
name|mdoc
parameter_list|,
name|enum
name|mdoct
name|tok
parameter_list|,
name|int
name|line
parameter_list|,
name|int
modifier|*
name|pos
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|la
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|la
operator|=
operator|*
name|pos
expr_stmt|;
if|if
condition|(
name|mdoc_args
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|,
name|tok
argument_list|,
name|NULL
argument_list|)
operator|==
name|ARGS_EOLN
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|macro_or_word
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|la
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ctx_synopsis
parameter_list|(
name|MACRO_PROT_ARGS
parameter_list|)
block|{
if|if
condition|(
operator|~
name|mdoc
operator|->
name|flags
operator|&
operator|(
name|MDOC_SYNOPSIS
operator||
name|MDOC_NEWLINE
operator|)
condition|)
name|in_line
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tok
operator|==
name|MDOC_Nm
condition|)
name|blk_full
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
name|tok
operator|==
name|MDOC_Vt
argument_list|)
expr_stmt|;
name|blk_part_imp
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Phrases occur within `Bl -column' entries, separated by `Ta' or tabs.  * They're unusual because they're basically free-form text until a  * macro is encountered.  */
end_comment

begin_function
specifier|static
name|void
name|phrase_ta
parameter_list|(
name|MACRO_PROT_ARGS
parameter_list|)
block|{
name|struct
name|mdoc_node
modifier|*
name|n
decl_stmt|;
comment|/* Make sure we are in a column list or ignore this macro. */
name|n
operator|=
name|mdoc
operator|->
name|last
expr_stmt|;
while|while
condition|(
name|n
operator|!=
name|NULL
operator|&&
name|n
operator|->
name|tok
operator|!=
name|MDOC_Bl
condition|)
name|n
operator|=
name|n
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
operator|||
name|n
operator|->
name|norm
operator|->
name|Bl
operator|.
name|type
operator|!=
name|LIST_column
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_TA_STRAY
argument_list|,
name|mdoc
operator|->
name|parse
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
literal|"Ta"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Advance to the next column. */
name|rew_sub
argument_list|(
name|MDOC_BODY
argument_list|,
name|mdoc
argument_list|,
name|MDOC_It
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|)
expr_stmt|;
name|mdoc_body_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|MDOC_It
argument_list|)
expr_stmt|;
name|parse_rest
argument_list|(
name|mdoc
argument_list|,
name|MDOC_MAX
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

