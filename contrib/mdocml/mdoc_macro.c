begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$Id: mdoc_macro.c,v 1.224 2017/05/30 16:22:03 schwarze Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2008-2012 Kristaps Dzonsons<kristaps@bsd.lv>  * Copyright (c) 2010, 2012-2017 Ingo Schwarze<schwarze@openbsd.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|"mandoc.h"
end_include

begin_include
include|#
directive|include
file|"roff.h"
end_include

begin_include
include|#
directive|include
file|"mdoc.h"
end_include

begin_include
include|#
directive|include
file|"libmandoc.h"
end_include

begin_include
include|#
directive|include
file|"roff_int.h"
end_include

begin_include
include|#
directive|include
file|"libmdoc.h"
end_include

begin_function_decl
specifier|static
name|void
name|blk_full
parameter_list|(
name|MACRO_PROT_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|blk_exp_close
parameter_list|(
name|MACRO_PROT_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|blk_part_exp
parameter_list|(
name|MACRO_PROT_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|blk_part_imp
parameter_list|(
name|MACRO_PROT_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctx_synopsis
parameter_list|(
name|MACRO_PROT_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|in_line_eoln
parameter_list|(
name|MACRO_PROT_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|in_line_argn
parameter_list|(
name|MACRO_PROT_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|in_line
parameter_list|(
name|MACRO_PROT_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|phrase_ta
parameter_list|(
name|MACRO_PROT_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|append_delims
parameter_list|(
name|struct
name|roff_man
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dword
parameter_list|(
name|struct
name|roff_man
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|enum
name|mdelim
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find_pending
parameter_list|(
name|struct
name|roff_man
modifier|*
parameter_list|,
name|enum
name|roff_tok
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|struct
name|roff_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lookup
parameter_list|(
name|struct
name|roff_man
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|macro_or_word
parameter_list|(
name|MACRO_PROT_ARGS
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|break_intermediate
parameter_list|(
name|struct
name|roff_node
modifier|*
parameter_list|,
name|struct
name|roff_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parse_rest
parameter_list|(
name|struct
name|roff_man
modifier|*
parameter_list|,
name|enum
name|roff_tok
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|roff_tok
name|rew_alt
parameter_list|(
name|enum
name|roff_tok
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rew_elem
parameter_list|(
name|struct
name|roff_man
modifier|*
parameter_list|,
name|enum
name|roff_tok
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rew_last
parameter_list|(
name|struct
name|roff_man
modifier|*
parameter_list|,
specifier|const
name|struct
name|roff_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rew_pending
parameter_list|(
name|struct
name|roff_man
modifier|*
parameter_list|,
specifier|const
name|struct
name|roff_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|const
name|struct
name|mdoc_macro
name|__mdoc_macros
index|[
name|MDOC_MAX
operator|-
name|MDOC_Dd
index|]
init|=
block|{
block|{
name|in_line_eoln
block|,
name|MDOC_PROLOGUE
block|}
block|,
comment|/* Dd */
block|{
name|in_line_eoln
block|,
name|MDOC_PROLOGUE
block|}
block|,
comment|/* Dt */
block|{
name|in_line_eoln
block|,
name|MDOC_PROLOGUE
block|}
block|,
comment|/* Os */
block|{
name|blk_full
block|,
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Sh */
block|{
name|blk_full
block|,
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Ss */
block|{
name|in_line_eoln
block|,
literal|0
block|}
block|,
comment|/* Pp */
block|{
name|blk_part_imp
block|,
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* D1 */
block|{
name|blk_part_imp
block|,
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Dl */
block|{
name|blk_full
block|,
name|MDOC_EXPLICIT
block|}
block|,
comment|/* Bd */
block|{
name|blk_exp_close
block|,
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Ed */
block|{
name|blk_full
block|,
name|MDOC_EXPLICIT
block|}
block|,
comment|/* Bl */
block|{
name|blk_exp_close
block|,
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* El */
block|{
name|blk_full
block|,
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* It */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Ad */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* An */
block|{
name|in_line_argn
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_IGNDELIM
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Ap */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Ar */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Cd */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Cm */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Dv */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Er */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Ev */
block|{
name|in_line_eoln
block|,
literal|0
block|}
block|,
comment|/* Ex */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Fa */
block|{
name|in_line_eoln
block|,
literal|0
block|}
block|,
comment|/* Fd */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Fl */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Fn */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Ft */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Ic */
block|{
name|in_line_argn
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* In */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Li */
block|{
name|blk_full
block|,
name|MDOC_JOIN
block|}
block|,
comment|/* Nd */
block|{
name|ctx_synopsis
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Nm */
block|{
name|blk_part_imp
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Op */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Ot */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Pa */
block|{
name|in_line_eoln
block|,
literal|0
block|}
block|,
comment|/* Rv */
block|{
name|in_line_argn
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* St */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Va */
block|{
name|ctx_synopsis
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Vt */
block|{
name|in_line_argn
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Xr */
block|{
name|in_line_eoln
block|,
name|MDOC_JOIN
block|}
block|,
comment|/* %A */
block|{
name|in_line_eoln
block|,
name|MDOC_JOIN
block|}
block|,
comment|/* %B */
block|{
name|in_line_eoln
block|,
name|MDOC_JOIN
block|}
block|,
comment|/* %D */
block|{
name|in_line_eoln
block|,
name|MDOC_JOIN
block|}
block|,
comment|/* %I */
block|{
name|in_line_eoln
block|,
name|MDOC_JOIN
block|}
block|,
comment|/* %J */
block|{
name|in_line_eoln
block|,
literal|0
block|}
block|,
comment|/* %N */
block|{
name|in_line_eoln
block|,
name|MDOC_JOIN
block|}
block|,
comment|/* %O */
block|{
name|in_line_eoln
block|,
literal|0
block|}
block|,
comment|/* %P */
block|{
name|in_line_eoln
block|,
name|MDOC_JOIN
block|}
block|,
comment|/* %R */
block|{
name|in_line_eoln
block|,
name|MDOC_JOIN
block|}
block|,
comment|/* %T */
block|{
name|in_line_eoln
block|,
literal|0
block|}
block|,
comment|/* %V */
block|{
name|blk_exp_close
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Ac */
block|{
name|blk_part_exp
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Ao */
block|{
name|blk_part_imp
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Aq */
block|{
name|in_line_argn
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* At */
block|{
name|blk_exp_close
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Bc */
block|{
name|blk_full
block|,
name|MDOC_EXPLICIT
block|}
block|,
comment|/* Bf */
block|{
name|blk_part_exp
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Bo */
block|{
name|blk_part_imp
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Bq */
block|{
name|in_line_argn
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Bsx */
block|{
name|in_line_argn
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Bx */
block|{
name|in_line_eoln
block|,
literal|0
block|}
block|,
comment|/* Db */
block|{
name|blk_exp_close
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Dc */
block|{
name|blk_part_exp
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Do */
block|{
name|blk_part_imp
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Dq */
block|{
name|blk_exp_close
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_EXPLICIT
block|}
block|,
comment|/* Ec */
block|{
name|blk_exp_close
block|,
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Ef */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Em */
block|{
name|blk_part_exp
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_EXPLICIT
block|}
block|,
comment|/* Eo */
block|{
name|in_line_argn
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Fx */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Ms */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* No */
block|{
name|in_line_argn
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_IGNDELIM
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Ns */
block|{
name|in_line_argn
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Nx */
block|{
name|in_line_argn
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Ox */
block|{
name|blk_exp_close
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Pc */
block|{
name|in_line_argn
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_IGNDELIM
block|}
block|,
comment|/* Pf */
block|{
name|blk_part_exp
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Po */
block|{
name|blk_part_imp
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Pq */
block|{
name|blk_exp_close
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Qc */
block|{
name|blk_part_imp
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Ql */
block|{
name|blk_part_exp
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Qo */
block|{
name|blk_part_imp
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Qq */
block|{
name|blk_exp_close
block|,
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Re */
block|{
name|blk_full
block|,
name|MDOC_EXPLICIT
block|}
block|,
comment|/* Rs */
block|{
name|blk_exp_close
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Sc */
block|{
name|blk_part_exp
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* So */
block|{
name|blk_part_imp
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Sq */
block|{
name|in_line_argn
block|,
literal|0
block|}
block|,
comment|/* Sm */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Sx */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Sy */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Tn */
block|{
name|in_line_argn
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Ux */
block|{
name|blk_exp_close
block|,
name|MDOC_EXPLICIT
operator||
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Xc */
block|{
name|blk_part_exp
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_EXPLICIT
block|}
block|,
comment|/* Xo */
block|{
name|blk_full
block|,
name|MDOC_EXPLICIT
operator||
name|MDOC_CALLABLE
block|}
block|,
comment|/* Fo */
block|{
name|blk_exp_close
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Fc */
block|{
name|blk_part_exp
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Oo */
block|{
name|blk_exp_close
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Oc */
block|{
name|blk_full
block|,
name|MDOC_EXPLICIT
block|}
block|,
comment|/* Bk */
block|{
name|blk_exp_close
block|,
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Ek */
block|{
name|in_line_eoln
block|,
literal|0
block|}
block|,
comment|/* Bt */
block|{
name|in_line_eoln
block|,
literal|0
block|}
block|,
comment|/* Hf */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Fr */
block|{
name|in_line_eoln
block|,
literal|0
block|}
block|,
comment|/* Ud */
block|{
name|in_line
block|,
literal|0
block|}
block|,
comment|/* Lb */
block|{
name|in_line_eoln
block|,
literal|0
block|}
block|,
comment|/* Lp */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Lk */
block|{
name|in_line
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Mt */
block|{
name|blk_part_imp
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Brq */
block|{
name|blk_part_exp
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Bro */
block|{
name|blk_exp_close
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_EXPLICIT
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Brc */
block|{
name|in_line_eoln
block|,
name|MDOC_JOIN
block|}
block|,
comment|/* %C */
block|{
name|in_line_argn
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Es */
block|{
name|blk_part_imp
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* En */
block|{
name|in_line_argn
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
block|}
block|,
comment|/* Dx */
block|{
name|in_line_eoln
block|,
name|MDOC_JOIN
block|}
block|,
comment|/* %Q */
block|{
name|in_line_eoln
block|,
literal|0
block|}
block|,
comment|/* %U */
block|{
name|phrase_ta
block|,
name|MDOC_CALLABLE
operator||
name|MDOC_PARSED
operator||
name|MDOC_JOIN
block|}
block|,
comment|/* Ta */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|mdoc_macro
modifier|*
specifier|const
name|mdoc_macros
init|=
name|__mdoc_macros
operator|-
name|MDOC_Dd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This is called at the end of parsing.  It must traverse up the tree,  * closing out open [implicit] scopes.  Obviously, open explicit scopes  * are errors.  */
end_comment

begin_function
name|void
name|mdoc_endparse
parameter_list|(
name|struct
name|roff_man
modifier|*
name|mdoc
parameter_list|)
block|{
name|struct
name|roff_node
modifier|*
name|n
decl_stmt|;
comment|/* Scan for open explicit scopes. */
name|n
operator|=
name|mdoc
operator|->
name|last
operator|->
name|flags
operator|&
name|NODE_VALID
condition|?
name|mdoc
operator|->
name|last
operator|->
name|parent
else|:
name|mdoc
operator|->
name|last
expr_stmt|;
for|for
control|(
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|parent
control|)
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_BLOCK
operator|&&
name|mdoc_macros
index|[
name|n
operator|->
name|tok
index|]
operator|.
name|flags
operator|&
name|MDOC_EXPLICIT
condition|)
name|mandoc_msg
argument_list|(
name|MANDOCERR_BLK_NOEND
argument_list|,
name|mdoc
operator|->
name|parse
argument_list|,
name|n
operator|->
name|line
argument_list|,
name|n
operator|->
name|pos
argument_list|,
name|roff_name
index|[
name|n
operator|->
name|tok
index|]
argument_list|)
expr_stmt|;
comment|/* Rewind to the first. */
name|rew_last
argument_list|(
name|mdoc
argument_list|,
name|mdoc
operator|->
name|first
argument_list|)
expr_stmt|;
name|mdoc_state_reset
argument_list|(
name|mdoc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Look up the macro at *p called by "from",  * or as a line macro if from == TOKEN_NONE.  */
end_comment

begin_function
specifier|static
name|int
name|lookup
parameter_list|(
name|struct
name|roff_man
modifier|*
name|mdoc
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|ppos
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
name|enum
name|roff_tok
name|res
decl_stmt|;
if|if
condition|(
name|mdoc
operator|->
name|flags
operator|&
name|MDOC_PHRASEQF
condition|)
block|{
name|mdoc
operator|->
name|flags
operator|&=
operator|~
name|MDOC_PHRASEQF
expr_stmt|;
return|return
name|TOKEN_NONE
return|;
block|}
if|if
condition|(
name|from
operator|==
name|TOKEN_NONE
operator|||
name|mdoc_macros
index|[
name|from
index|]
operator|.
name|flags
operator|&
name|MDOC_PARSED
condition|)
block|{
name|res
operator|=
name|roffhash_find
argument_list|(
name|mdoc
operator|->
name|mdocmac
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|TOKEN_NONE
condition|)
block|{
if|if
condition|(
name|mdoc_macros
index|[
name|res
index|]
operator|.
name|flags
operator|&
name|MDOC_CALLABLE
condition|)
return|return
name|res
return|;
name|mandoc_msg
argument_list|(
name|MANDOCERR_MACRO_CALL
argument_list|,
name|mdoc
operator|->
name|parse
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TOKEN_NONE
return|;
block|}
end_function

begin_comment
comment|/*  * Rewind up to and including a specific node.  */
end_comment

begin_function
specifier|static
name|void
name|rew_last
parameter_list|(
name|struct
name|roff_man
modifier|*
name|mdoc
parameter_list|,
specifier|const
name|struct
name|roff_node
modifier|*
name|to
parameter_list|)
block|{
if|if
condition|(
name|to
operator|->
name|flags
operator|&
name|NODE_VALID
condition|)
return|return;
while|while
condition|(
name|mdoc
operator|->
name|last
operator|!=
name|to
condition|)
block|{
name|mdoc_state
argument_list|(
name|mdoc
argument_list|,
name|mdoc
operator|->
name|last
argument_list|)
expr_stmt|;
name|mdoc
operator|->
name|last
operator|->
name|flags
operator||=
name|NODE_VALID
operator||
name|NODE_ENDED
expr_stmt|;
name|mdoc
operator|->
name|last
operator|=
name|mdoc
operator|->
name|last
operator|->
name|parent
expr_stmt|;
block|}
name|mdoc_state
argument_list|(
name|mdoc
argument_list|,
name|mdoc
operator|->
name|last
argument_list|)
expr_stmt|;
name|mdoc
operator|->
name|last
operator|->
name|flags
operator||=
name|NODE_VALID
operator||
name|NODE_ENDED
expr_stmt|;
name|mdoc
operator|->
name|next
operator|=
name|ROFF_NEXT_SIBLING
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Rewind up to a specific block, including all blocks that broke it.  */
end_comment

begin_function
specifier|static
name|void
name|rew_pending
parameter_list|(
name|struct
name|roff_man
modifier|*
name|mdoc
parameter_list|,
specifier|const
name|struct
name|roff_node
modifier|*
name|n
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|rew_last
argument_list|(
name|mdoc
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdoc
operator|->
name|last
operator|==
name|n
condition|)
block|{
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
case|case
name|ROFFT_HEAD
case|:
name|roff_body_alloc
argument_list|(
name|mdoc
argument_list|,
name|n
operator|->
name|line
argument_list|,
name|n
operator|->
name|pos
argument_list|,
name|n
operator|->
name|tok
argument_list|)
expr_stmt|;
break|break;
case|case
name|ROFFT_BLOCK
case|:
break|break;
default|default:
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|n
operator|->
name|flags
operator|&
name|NODE_BROKEN
operator|)
condition|)
return|return;
block|}
else|else
name|n
operator|=
name|mdoc
operator|->
name|last
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|n
operator|->
name|parent
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_BLOCK
operator|||
name|n
operator|->
name|type
operator|==
name|ROFFT_HEAD
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|flags
operator|&
name|NODE_ENDED
condition|)
break|break;
else|else
return|return;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * For a block closing macro, return the corresponding opening one.  * Otherwise, return the macro itself.  */
end_comment

begin_function
specifier|static
name|enum
name|roff_tok
name|rew_alt
parameter_list|(
name|enum
name|roff_tok
name|tok
parameter_list|)
block|{
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|MDOC_Ac
case|:
return|return
name|MDOC_Ao
return|;
case|case
name|MDOC_Bc
case|:
return|return
name|MDOC_Bo
return|;
case|case
name|MDOC_Brc
case|:
return|return
name|MDOC_Bro
return|;
case|case
name|MDOC_Dc
case|:
return|return
name|MDOC_Do
return|;
case|case
name|MDOC_Ec
case|:
return|return
name|MDOC_Eo
return|;
case|case
name|MDOC_Ed
case|:
return|return
name|MDOC_Bd
return|;
case|case
name|MDOC_Ef
case|:
return|return
name|MDOC_Bf
return|;
case|case
name|MDOC_Ek
case|:
return|return
name|MDOC_Bk
return|;
case|case
name|MDOC_El
case|:
return|return
name|MDOC_Bl
return|;
case|case
name|MDOC_Fc
case|:
return|return
name|MDOC_Fo
return|;
case|case
name|MDOC_Oc
case|:
return|return
name|MDOC_Oo
return|;
case|case
name|MDOC_Pc
case|:
return|return
name|MDOC_Po
return|;
case|case
name|MDOC_Qc
case|:
return|return
name|MDOC_Qo
return|;
case|case
name|MDOC_Re
case|:
return|return
name|MDOC_Rs
return|;
case|case
name|MDOC_Sc
case|:
return|return
name|MDOC_So
return|;
case|case
name|MDOC_Xc
case|:
return|return
name|MDOC_Xo
return|;
default|default:
return|return
name|tok
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|rew_elem
parameter_list|(
name|struct
name|roff_man
modifier|*
name|mdoc
parameter_list|,
name|enum
name|roff_tok
name|tok
parameter_list|)
block|{
name|struct
name|roff_node
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|mdoc
operator|->
name|last
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|type
operator|!=
name|ROFFT_ELEM
condition|)
name|n
operator|=
name|n
operator|->
name|parent
expr_stmt|;
name|assert
argument_list|(
name|n
operator|->
name|type
operator|==
name|ROFFT_ELEM
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tok
operator|==
name|n
operator|->
name|tok
argument_list|)
expr_stmt|;
name|rew_last
argument_list|(
name|mdoc
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|break_intermediate
parameter_list|(
name|struct
name|roff_node
modifier|*
name|n
parameter_list|,
name|struct
name|roff_node
modifier|*
name|breaker
parameter_list|)
block|{
if|if
condition|(
name|n
operator|!=
name|breaker
operator|&&
name|n
operator|->
name|type
operator|!=
name|ROFFT_BLOCK
operator|&&
name|n
operator|->
name|type
operator|!=
name|ROFFT_HEAD
operator|&&
operator|(
name|n
operator|->
name|type
operator|!=
name|ROFFT_BODY
operator|||
name|n
operator|->
name|end
operator|!=
name|ENDBODY_NOT
operator|)
condition|)
name|n
operator|=
name|n
operator|->
name|parent
expr_stmt|;
while|while
condition|(
name|n
operator|!=
name|breaker
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|n
operator|->
name|flags
operator|&
name|NODE_VALID
operator|)
condition|)
name|n
operator|->
name|flags
operator||=
name|NODE_BROKEN
expr_stmt|;
name|n
operator|=
name|n
operator|->
name|parent
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * If there is an open sub-block of the target requiring  * explicit close-out, postpone closing out the target until  * the rew_pending() call closing out the sub-block.  */
end_comment

begin_function
specifier|static
name|int
name|find_pending
parameter_list|(
name|struct
name|roff_man
modifier|*
name|mdoc
parameter_list|,
name|enum
name|roff_tok
name|tok
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|ppos
parameter_list|,
name|struct
name|roff_node
modifier|*
name|target
parameter_list|)
block|{
name|struct
name|roff_node
modifier|*
name|n
decl_stmt|;
name|int
name|irc
decl_stmt|;
if|if
condition|(
name|target
operator|->
name|flags
operator|&
name|NODE_VALID
condition|)
return|return
literal|0
return|;
name|irc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
name|mdoc
operator|->
name|last
init|;
name|n
operator|!=
name|NULL
operator|&&
name|n
operator|!=
name|target
condition|;
name|n
operator|=
name|n
operator|->
name|parent
control|)
block|{
if|if
condition|(
name|n
operator|->
name|flags
operator|&
name|NODE_ENDED
condition|)
continue|continue;
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_BLOCK
operator|&&
name|mdoc_macros
index|[
name|n
operator|->
name|tok
index|]
operator|.
name|flags
operator|&
name|MDOC_EXPLICIT
condition|)
block|{
name|irc
operator|=
literal|1
expr_stmt|;
name|break_intermediate
argument_list|(
name|mdoc
operator|->
name|last
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|type
operator|==
name|ROFFT_HEAD
condition|)
name|target
operator|->
name|flags
operator||=
name|NODE_ENDED
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|target
operator|->
name|flags
operator|&
name|NODE_ENDED
operator|)
condition|)
block|{
name|mandoc_vmsg
argument_list|(
name|MANDOCERR_BLK_NEST
argument_list|,
name|mdoc
operator|->
name|parse
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
literal|"%s breaks %s"
argument_list|,
name|roff_name
index|[
name|tok
index|]
argument_list|,
name|roff_name
index|[
name|n
operator|->
name|tok
index|]
argument_list|)
expr_stmt|;
name|mdoc_endbody_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|irc
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a word and check whether it's punctuation or not.  * Punctuation consists of those tokens found in mdoc_isdelim().  */
end_comment

begin_function
specifier|static
name|void
name|dword
parameter_list|(
name|struct
name|roff_man
modifier|*
name|mdoc
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|col
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|enum
name|mdelim
name|d
parameter_list|,
name|int
name|may_append
parameter_list|)
block|{
if|if
condition|(
name|d
operator|==
name|DELIM_MAX
condition|)
name|d
operator|=
name|mdoc_isdelim
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|may_append
operator|&&
operator|!
operator|(
name|mdoc
operator|->
name|flags
operator|&
operator|(
name|MDOC_SYNOPSIS
operator||
name|MDOC_KEEP
operator||
name|MDOC_SMOFF
operator|)
operator|)
operator|&&
name|d
operator|==
name|DELIM_NONE
operator|&&
name|mdoc
operator|->
name|last
operator|->
name|type
operator|==
name|ROFFT_TEXT
operator|&&
name|mdoc_isdelim
argument_list|(
name|mdoc
operator|->
name|last
operator|->
name|string
argument_list|)
operator|==
name|DELIM_NONE
condition|)
block|{
name|roff_word_append
argument_list|(
name|mdoc
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
name|roff_word_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|col
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* 	 * If the word consists of a bare delimiter, 	 * flag the new node accordingly, 	 * unless doing so was vetoed by the invoking macro. 	 * Always clear the veto, it is only valid for one word. 	 */
if|if
condition|(
name|d
operator|==
name|DELIM_OPEN
condition|)
name|mdoc
operator|->
name|last
operator|->
name|flags
operator||=
name|NODE_DELIMO
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|==
name|DELIM_CLOSE
operator|&&
operator|!
operator|(
name|mdoc
operator|->
name|flags
operator|&
name|MDOC_NODELIMC
operator|)
operator|&&
name|mdoc
operator|->
name|last
operator|->
name|parent
operator|->
name|tok
operator|!=
name|MDOC_Fd
condition|)
name|mdoc
operator|->
name|last
operator|->
name|flags
operator||=
name|NODE_DELIMC
expr_stmt|;
name|mdoc
operator|->
name|flags
operator|&=
operator|~
name|MDOC_NODELIMC
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|append_delims
parameter_list|(
name|struct
name|roff_man
modifier|*
name|mdoc
parameter_list|,
name|int
name|line
parameter_list|,
name|int
modifier|*
name|pos
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|la
decl_stmt|;
if|if
condition|(
name|buf
index|[
operator|*
name|pos
index|]
operator|==
literal|'\0'
condition|)
return|return;
for|for
control|(
init|;
condition|;
control|)
block|{
name|la
operator|=
operator|*
name|pos
expr_stmt|;
if|if
condition|(
name|mdoc_args
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|,
name|TOKEN_NONE
argument_list|,
operator|&
name|p
argument_list|)
operator|==
name|ARGS_EOLN
condition|)
break|break;
name|dword
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|la
argument_list|,
name|p
argument_list|,
name|DELIM_MAX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * If we encounter end-of-sentence symbols, then trigger 		 * the double-space. 		 * 		 * XXX: it's easy to allow this to propagate outward to 		 * the last symbol, such that `. )' will cause the 		 * correct double-spacing.  However, (1) groff isn't 		 * smart enough to do this and (2) it would require 		 * knowing which symbols break this behaviour, for 		 * example, `.  ;' shouldn't propagate the double-space. 		 */
if|if
condition|(
name|mandoc_eos
argument_list|(
name|p
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
name|mdoc
operator|->
name|last
operator|->
name|flags
operator||=
name|NODE_EOS
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Parse one word.  * If it is a macro, call it and return 1.  * Otherwise, allocate it and return 0.  */
end_comment

begin_function
specifier|static
name|int
name|macro_or_word
parameter_list|(
name|MACRO_PROT_ARGS
parameter_list|,
name|int
name|parsed
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|ntok
decl_stmt|;
name|p
operator|=
name|buf
operator|+
name|ppos
expr_stmt|;
name|ntok
operator|=
name|TOKEN_NONE
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'"'
condition|)
name|p
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|parsed
operator|&&
operator|!
operator|(
name|mdoc
operator|->
name|flags
operator|&
name|MDOC_PHRASELIT
operator|)
condition|)
name|ntok
operator|=
name|lookup
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntok
operator|==
name|TOKEN_NONE
condition|)
block|{
name|dword
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|p
argument_list|,
name|DELIM_MAX
argument_list|,
name|tok
operator|==
name|TOKEN_NONE
operator|||
name|mdoc_macros
index|[
name|tok
index|]
operator|.
name|flags
operator|&
name|MDOC_JOIN
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
name|tok
operator|!=
name|TOKEN_NONE
operator|&&
name|mdoc_macros
index|[
name|tok
index|]
operator|.
name|fp
operator|==
name|in_line_eoln
condition|)
name|rew_elem
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|)
expr_stmt|;
name|mdoc_macro
argument_list|(
name|mdoc
argument_list|,
name|ntok
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|TOKEN_NONE
condition|)
name|append_delims
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Close out block partial/full explicit.  */
end_comment

begin_function
specifier|static
name|void
name|blk_exp_close
parameter_list|(
name|MACRO_PROT_ARGS
parameter_list|)
block|{
name|struct
name|roff_node
modifier|*
name|body
decl_stmt|;
comment|/* Our own body. */
name|struct
name|roff_node
modifier|*
name|endbody
decl_stmt|;
comment|/* Our own end marker. */
name|struct
name|roff_node
modifier|*
name|itblk
decl_stmt|;
comment|/* An It block starting later. */
name|struct
name|roff_node
modifier|*
name|later
decl_stmt|;
comment|/* A sub-block starting later. */
name|struct
name|roff_node
modifier|*
name|n
decl_stmt|;
comment|/* Search back to our block. */
name|struct
name|roff_node
modifier|*
name|target
decl_stmt|;
comment|/* For find_pending(). */
name|int
name|j
decl_stmt|,
name|lastarg
decl_stmt|,
name|maxargs
decl_stmt|,
name|nl
decl_stmt|,
name|pending
decl_stmt|;
name|enum
name|margserr
name|ac
decl_stmt|;
name|enum
name|roff_tok
name|atok
decl_stmt|,
name|ntok
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|nl
operator|=
name|MDOC_NEWLINE
operator|&
name|mdoc
operator|->
name|flags
expr_stmt|;
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|MDOC_Ec
case|:
name|maxargs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MDOC_Ek
case|:
name|mdoc
operator|->
name|flags
operator|&=
operator|~
name|MDOC_KEEP
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
name|maxargs
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* Search backwards for the beginning of our own body. */
name|atok
operator|=
name|rew_alt
argument_list|(
name|tok
argument_list|)
expr_stmt|;
name|body
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|n
operator|=
name|mdoc
operator|->
name|last
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|parent
control|)
block|{
if|if
condition|(
name|n
operator|->
name|flags
operator|&
name|NODE_ENDED
operator|||
name|n
operator|->
name|tok
operator|!=
name|atok
operator|||
name|n
operator|->
name|type
operator|!=
name|ROFFT_BODY
operator|||
name|n
operator|->
name|end
operator|!=
name|ENDBODY_NOT
condition|)
continue|continue;
name|body
operator|=
name|n
expr_stmt|;
break|break;
block|}
comment|/* 	 * Search backwards for beginnings of blocks, 	 * both of our own and of pending sub-blocks. 	 */
name|endbody
operator|=
name|itblk
operator|=
name|later
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|n
operator|=
name|mdoc
operator|->
name|last
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|parent
control|)
block|{
if|if
condition|(
name|n
operator|->
name|flags
operator|&
name|NODE_ENDED
condition|)
continue|continue;
comment|/* 		 * Mismatching end macros can never break anything 		 * and we only care about the breaking of BLOCKs. 		 */
if|if
condition|(
name|body
operator|==
name|NULL
operator|||
name|n
operator|->
name|type
operator|!=
name|ROFFT_BLOCK
condition|)
continue|continue;
comment|/* 		 * SYNOPSIS name blocks can not be broken themselves, 		 * but they do get broken together with a broken child. 		 */
if|if
condition|(
name|n
operator|->
name|tok
operator|==
name|MDOC_Nm
condition|)
block|{
if|if
condition|(
name|later
operator|!=
name|NULL
condition|)
name|n
operator|->
name|flags
operator||=
name|NODE_BROKEN
operator||
name|NODE_ENDED
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|n
operator|->
name|tok
operator|==
name|MDOC_It
condition|)
block|{
name|itblk
operator|=
name|n
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|atok
operator|==
name|n
operator|->
name|tok
condition|)
block|{
comment|/* 			 * Found the start of our own block. 			 * When there is no pending sub block, 			 * just proceed to closing out. 			 */
if|if
condition|(
name|later
operator|==
name|NULL
operator|||
operator|(
name|tok
operator|==
name|MDOC_El
operator|&&
name|itblk
operator|==
name|NULL
operator|)
condition|)
break|break;
comment|/* 			 * When there is a pending sub block, postpone 			 * closing out the current block until the 			 * rew_pending() closing out the sub-block. 			 * Mark the place where the formatting - but not 			 * the scope - of the current block ends. 			 */
name|mandoc_vmsg
argument_list|(
name|MANDOCERR_BLK_NEST
argument_list|,
name|mdoc
operator|->
name|parse
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
literal|"%s breaks %s"
argument_list|,
name|roff_name
index|[
name|atok
index|]
argument_list|,
name|roff_name
index|[
name|later
operator|->
name|tok
index|]
argument_list|)
expr_stmt|;
name|endbody
operator|=
name|mdoc_endbody_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|atok
argument_list|,
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|MDOC_El
condition|)
name|itblk
operator|->
name|flags
operator||=
name|NODE_ENDED
operator||
name|NODE_BROKEN
expr_stmt|;
comment|/* 			 * If a block closing macro taking arguments 			 * breaks another block, put the arguments 			 * into the end marker. 			 */
if|if
condition|(
name|maxargs
condition|)
name|mdoc
operator|->
name|next
operator|=
name|ROFF_NEXT_CHILD
expr_stmt|;
break|break;
block|}
comment|/* 		 * Explicit blocks close out description lines, but 		 * even those can get broken together with a child. 		 */
if|if
condition|(
name|n
operator|->
name|tok
operator|==
name|MDOC_Nd
condition|)
block|{
if|if
condition|(
name|later
operator|!=
name|NULL
condition|)
name|n
operator|->
name|flags
operator||=
name|NODE_BROKEN
operator||
name|NODE_ENDED
expr_stmt|;
else|else
name|rew_last
argument_list|(
name|mdoc
argument_list|,
name|n
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Breaking an open sub block. */
name|break_intermediate
argument_list|(
name|mdoc
operator|->
name|last
argument_list|,
name|body
argument_list|)
expr_stmt|;
name|n
operator|->
name|flags
operator||=
name|NODE_BROKEN
expr_stmt|;
if|if
condition|(
name|later
operator|==
name|NULL
condition|)
name|later
operator|=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|body
operator|==
name|NULL
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_BLK_NOTOPEN
argument_list|,
name|mdoc
operator|->
name|parse
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|roff_name
index|[
name|tok
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxargs
operator|&&
name|endbody
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Stray .Ec without previous .Eo: 			 * Break the output line, keep the arguments. 			 */
name|roff_elem_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|ROFF_br
argument_list|)
expr_stmt|;
name|rew_elem
argument_list|(
name|mdoc
argument_list|,
name|ROFF_br
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|endbody
operator|==
name|NULL
condition|)
block|{
name|rew_last
argument_list|(
name|mdoc
argument_list|,
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxargs
condition|)
name|mdoc_tail_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|atok
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|mdoc_macros
index|[
name|tok
index|]
operator|.
name|flags
operator|&
name|MDOC_PARSED
operator|)
condition|)
block|{
if|if
condition|(
name|buf
index|[
operator|*
name|pos
index|]
operator|!=
literal|'\0'
condition|)
name|mandoc_vmsg
argument_list|(
name|MANDOCERR_ARG_SKIP
argument_list|,
name|mdoc
operator|->
name|parse
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
literal|"%s %s"
argument_list|,
name|roff_name
index|[
name|tok
index|]
argument_list|,
name|buf
operator|+
operator|*
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|endbody
operator|==
name|NULL
operator|&&
name|n
operator|!=
name|NULL
condition|)
name|rew_pending
argument_list|(
name|mdoc
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|endbody
operator|!=
name|NULL
condition|)
name|n
operator|=
name|endbody
expr_stmt|;
name|ntok
operator|=
name|TOKEN_NONE
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
condition|;
name|j
operator|++
control|)
block|{
name|lastarg
operator|=
operator|*
name|pos
expr_stmt|;
if|if
condition|(
name|j
operator|==
name|maxargs
operator|&&
name|n
operator|!=
name|NULL
condition|)
name|rew_last
argument_list|(
name|mdoc
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|ac
operator|=
name|mdoc_args
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|,
name|tok
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
operator|==
name|ARGS_PUNCT
operator|||
name|ac
operator|==
name|ARGS_EOLN
condition|)
break|break;
name|ntok
operator|=
name|lookup
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|lastarg
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntok
operator|==
name|TOKEN_NONE
condition|)
block|{
name|dword
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|lastarg
argument_list|,
name|p
argument_list|,
name|DELIM_MAX
argument_list|,
name|MDOC_JOIN
operator|&
name|mdoc_macros
index|[
name|tok
index|]
operator|.
name|flags
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
name|rew_last
argument_list|(
name|mdoc
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|mdoc
operator|->
name|flags
operator|&=
operator|~
name|MDOC_NEWLINE
expr_stmt|;
name|mdoc_macro
argument_list|(
name|mdoc
argument_list|,
name|ntok
argument_list|,
name|line
argument_list|,
name|lastarg
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
block|{
name|pending
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ntok
operator|!=
name|TOKEN_NONE
operator|&&
name|n
operator|->
name|flags
operator|&
name|NODE_BROKEN
condition|)
block|{
name|target
operator|=
name|n
expr_stmt|;
do|do
name|target
operator|=
name|target
operator|->
name|parent
expr_stmt|;
do|while
condition|(
operator|!
operator|(
name|target
operator|->
name|flags
operator|&
name|NODE_ENDED
operator|)
condition|)
do|;
name|pending
operator|=
name|find_pending
argument_list|(
name|mdoc
argument_list|,
name|ntok
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pending
condition|)
name|rew_pending
argument_list|(
name|mdoc
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nl
condition|)
name|append_delims
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|in_line
parameter_list|(
name|MACRO_PROT_ARGS
parameter_list|)
block|{
name|int
name|la
decl_stmt|,
name|scope
decl_stmt|,
name|cnt
decl_stmt|,
name|firstarg
decl_stmt|,
name|mayopen
decl_stmt|,
name|nc
decl_stmt|,
name|nl
decl_stmt|;
name|enum
name|roff_tok
name|ntok
decl_stmt|;
name|enum
name|margserr
name|ac
decl_stmt|;
name|enum
name|mdelim
name|d
decl_stmt|;
name|struct
name|mdoc_arg
modifier|*
name|arg
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|nl
operator|=
name|MDOC_NEWLINE
operator|&
name|mdoc
operator|->
name|flags
expr_stmt|;
comment|/* 	 * Whether we allow ignored elements (those without content, 	 * usually because of reserved words) to squeak by. 	 */
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|MDOC_An
case|:
case|case
name|MDOC_Ar
case|:
case|case
name|MDOC_Fl
case|:
case|case
name|MDOC_Mt
case|:
case|case
name|MDOC_Nm
case|:
case|case
name|MDOC_Pa
case|:
name|nc
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|nc
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|mdoc_argv
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|tok
argument_list|,
operator|&
name|arg
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|d
operator|=
name|DELIM_NONE
expr_stmt|;
name|firstarg
operator|=
literal|1
expr_stmt|;
name|mayopen
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|cnt
operator|=
name|scope
operator|=
literal|0
init|;
condition|;
control|)
block|{
name|la
operator|=
operator|*
name|pos
expr_stmt|;
name|ac
operator|=
name|mdoc_args
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|,
name|tok
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
comment|/* 		 * At the end of a macro line, 		 * opening delimiters do not suppress spacing. 		 */
if|if
condition|(
name|ac
operator|==
name|ARGS_EOLN
condition|)
block|{
if|if
condition|(
name|d
operator|==
name|DELIM_OPEN
condition|)
name|mdoc
operator|->
name|last
operator|->
name|flags
operator|&=
operator|~
name|NODE_DELIMO
expr_stmt|;
break|break;
block|}
comment|/* 		 * The rest of the macro line is only punctuation, 		 * to be handled by append_delims(). 		 * If there were no other arguments, 		 * do not allow the first one to suppress spacing, 		 * even if it turns out to be a closing one. 		 */
if|if
condition|(
name|ac
operator|==
name|ARGS_PUNCT
condition|)
block|{
if|if
condition|(
name|cnt
operator|==
literal|0
operator|&&
operator|(
name|nc
operator|==
literal|0
operator|||
name|tok
operator|==
name|MDOC_An
operator|)
condition|)
name|mdoc
operator|->
name|flags
operator||=
name|MDOC_NODELIMC
expr_stmt|;
break|break;
block|}
name|ntok
operator|=
operator|(
name|tok
operator|==
name|MDOC_Fn
operator|&&
operator|!
name|cnt
operator|)
condition|?
name|TOKEN_NONE
else|:
name|lookup
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|la
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* 		 * In this case, we've located a submacro and must 		 * execute it.  Close out scope, if open.  If no 		 * elements have been generated, either create one (nc) 		 * or raise a warning. 		 */
if|if
condition|(
name|ntok
operator|!=
name|TOKEN_NONE
condition|)
block|{
if|if
condition|(
name|scope
condition|)
name|rew_elem
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|)
expr_stmt|;
if|if
condition|(
name|nc
operator|&&
operator|!
name|cnt
condition|)
block|{
name|mdoc_elem_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|rew_last
argument_list|(
name|mdoc
argument_list|,
name|mdoc
operator|->
name|last
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|nc
operator|&&
operator|!
name|cnt
condition|)
block|{
name|mdoc_argv_free
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|mandoc_msg
argument_list|(
name|MANDOCERR_MACRO_EMPTY
argument_list|,
name|mdoc
operator|->
name|parse
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|roff_name
index|[
name|tok
index|]
argument_list|)
expr_stmt|;
block|}
name|mdoc_macro
argument_list|(
name|mdoc
argument_list|,
name|ntok
argument_list|,
name|line
argument_list|,
name|la
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
condition|)
name|append_delims
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * Handle punctuation.  Set up our scope, if a word; 		 * rewind the scope, if a delimiter; then append the word. 		 */
if|if
condition|(
operator|(
name|d
operator|=
name|mdoc_isdelim
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
name|DELIM_NONE
condition|)
block|{
comment|/* 			 * If we encounter closing punctuation, no word 			 * has been emitted, no scope is open, and we're 			 * allowed to have an empty element, then start 			 * a new scope. 			 */
if|if
condition|(
operator|(
name|d
operator|==
name|DELIM_CLOSE
operator|||
operator|(
name|d
operator|==
name|DELIM_MIDDLE
operator|&&
name|tok
operator|==
name|MDOC_Fl
operator|)
operator|)
operator|&&
operator|!
name|cnt
operator|&&
operator|!
name|scope
operator|&&
name|nc
operator|&&
name|mayopen
condition|)
block|{
name|mdoc_elem_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|scope
operator|=
literal|1
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|MDOC_Nm
condition|)
name|mayopen
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 			 * Close out our scope, if one is open, before 			 * any punctuation. 			 */
if|if
condition|(
name|scope
operator|&&
name|tok
operator|!=
name|MDOC_Lk
condition|)
block|{
name|rew_elem
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|)
expr_stmt|;
name|scope
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|MDOC_Fn
condition|)
name|mayopen
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mayopen
operator|&&
operator|!
name|scope
condition|)
block|{
name|mdoc_elem_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|scope
operator|=
literal|1
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
name|dword
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|la
argument_list|,
name|p
argument_list|,
name|d
argument_list|,
name|mdoc_macros
index|[
name|tok
index|]
operator|.
name|flags
operator|&
name|MDOC_JOIN
argument_list|)
expr_stmt|;
comment|/* 		 * If the first argument is a closing delimiter, 		 * do not suppress spacing before it. 		 */
if|if
condition|(
name|firstarg
operator|&&
name|d
operator|==
name|DELIM_CLOSE
operator|&&
operator|!
name|nc
condition|)
name|mdoc
operator|->
name|last
operator|->
name|flags
operator|&=
operator|~
name|NODE_DELIMC
expr_stmt|;
name|firstarg
operator|=
literal|0
expr_stmt|;
comment|/* 		 * `Fl' macros have their scope re-opened with each new 		 * word so that the `-' can be added to each one without 		 * having to parse out spaces. 		 */
if|if
condition|(
name|scope
operator|&&
name|tok
operator|==
name|MDOC_Fl
condition|)
block|{
name|rew_elem
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|)
expr_stmt|;
name|scope
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|scope
operator|&&
name|tok
operator|!=
name|MDOC_Lk
condition|)
block|{
name|rew_elem
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|)
expr_stmt|;
name|scope
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * If no elements have been collected and we're allowed to have 	 * empties (nc), open a scope and close it out.  Otherwise, 	 * raise a warning. 	 */
if|if
condition|(
operator|!
name|cnt
condition|)
block|{
if|if
condition|(
name|nc
condition|)
block|{
name|mdoc_elem_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|rew_last
argument_list|(
name|mdoc
argument_list|,
name|mdoc
operator|->
name|last
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mdoc_argv_free
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|mandoc_msg
argument_list|(
name|MANDOCERR_MACRO_EMPTY
argument_list|,
name|mdoc
operator|->
name|parse
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|roff_name
index|[
name|tok
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nl
condition|)
name|append_delims
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|scope
condition|)
name|rew_elem
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|blk_full
parameter_list|(
name|MACRO_PROT_ARGS
parameter_list|)
block|{
name|int
name|la
decl_stmt|,
name|nl
decl_stmt|,
name|parsed
decl_stmt|;
name|struct
name|mdoc_arg
modifier|*
name|arg
decl_stmt|;
name|struct
name|roff_node
modifier|*
name|blk
decl_stmt|;
comment|/* Our own or a broken block. */
name|struct
name|roff_node
modifier|*
name|head
decl_stmt|;
comment|/* Our own head. */
name|struct
name|roff_node
modifier|*
name|body
decl_stmt|;
comment|/* Our own body. */
name|struct
name|roff_node
modifier|*
name|n
decl_stmt|;
name|enum
name|margserr
name|ac
decl_stmt|,
name|lac
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|nl
operator|=
name|MDOC_NEWLINE
operator|&
name|mdoc
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|buf
index|[
operator|*
name|pos
index|]
operator|==
literal|'\0'
operator|&&
operator|(
name|tok
operator|==
name|MDOC_Sh
operator|||
name|tok
operator|==
name|MDOC_Ss
operator|)
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_MACRO_EMPTY
argument_list|,
name|mdoc
operator|->
name|parse
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|roff_name
index|[
name|tok
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|mdoc_macros
index|[
name|tok
index|]
operator|.
name|flags
operator|&
name|MDOC_EXPLICIT
operator|)
condition|)
block|{
comment|/* Here, tok is one of Sh Ss Nm Nd It. */
name|blk
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|n
operator|=
name|mdoc
operator|->
name|last
init|;
name|n
operator|!=
name|NULL
condition|;
name|n
operator|=
name|n
operator|->
name|parent
control|)
block|{
if|if
condition|(
name|n
operator|->
name|flags
operator|&
name|NODE_ENDED
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|n
operator|->
name|flags
operator|&
name|NODE_VALID
operator|)
condition|)
name|n
operator|->
name|flags
operator||=
name|NODE_BROKEN
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|n
operator|->
name|type
operator|!=
name|ROFFT_BLOCK
condition|)
continue|continue;
if|if
condition|(
name|tok
operator|==
name|MDOC_It
operator|&&
name|n
operator|->
name|tok
operator|==
name|MDOC_Bl
condition|)
block|{
if|if
condition|(
name|blk
operator|!=
name|NULL
condition|)
block|{
name|mandoc_vmsg
argument_list|(
name|MANDOCERR_BLK_BROKEN
argument_list|,
name|mdoc
operator|->
name|parse
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
literal|"It breaks %s"
argument_list|,
name|roff_name
index|[
name|blk
operator|->
name|tok
index|]
argument_list|)
expr_stmt|;
name|rew_pending
argument_list|(
name|mdoc
argument_list|,
name|blk
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|mdoc_macros
index|[
name|n
operator|->
name|tok
index|]
operator|.
name|flags
operator|&
name|MDOC_EXPLICIT
condition|)
block|{
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|MDOC_Sh
case|:
case|case
name|MDOC_Ss
case|:
name|mandoc_vmsg
argument_list|(
name|MANDOCERR_BLK_BROKEN
argument_list|,
name|mdoc
operator|->
name|parse
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
literal|"%s breaks %s"
argument_list|,
name|roff_name
index|[
name|tok
index|]
argument_list|,
name|roff_name
index|[
name|n
operator|->
name|tok
index|]
argument_list|)
expr_stmt|;
name|rew_pending
argument_list|(
name|mdoc
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|n
operator|=
name|mdoc
operator|->
name|last
expr_stmt|;
continue|continue;
case|case
name|MDOC_It
case|:
comment|/* Delay in case it's astray. */
name|blk
operator|=
name|n
expr_stmt|;
continue|continue;
default|default:
break|break;
block|}
break|break;
block|}
comment|/* Here, n is one of Sh Ss Nm Nd It. */
if|if
condition|(
name|tok
operator|!=
name|MDOC_Sh
operator|&&
operator|(
name|n
operator|->
name|tok
operator|==
name|MDOC_Sh
operator|||
operator|(
name|tok
operator|!=
name|MDOC_Ss
operator|&&
operator|(
name|n
operator|->
name|tok
operator|==
name|MDOC_Ss
operator|||
operator|(
name|tok
operator|!=
name|MDOC_It
operator|&&
name|n
operator|->
name|tok
operator|==
name|MDOC_It
operator|)
operator|)
operator|)
operator|)
condition|)
break|break;
comment|/* Item breaking an explicit block. */
if|if
condition|(
name|blk
operator|!=
name|NULL
condition|)
block|{
name|mandoc_vmsg
argument_list|(
name|MANDOCERR_BLK_BROKEN
argument_list|,
name|mdoc
operator|->
name|parse
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
literal|"It breaks %s"
argument_list|,
name|roff_name
index|[
name|blk
operator|->
name|tok
index|]
argument_list|)
expr_stmt|;
name|rew_pending
argument_list|(
name|mdoc
argument_list|,
name|blk
argument_list|)
expr_stmt|;
name|blk
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Close out prior implicit scopes. */
name|rew_pending
argument_list|(
name|mdoc
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
comment|/* Skip items outside lists. */
if|if
condition|(
name|tok
operator|==
name|MDOC_It
operator|&&
operator|(
name|n
operator|==
name|NULL
operator|||
name|n
operator|->
name|tok
operator|!=
name|MDOC_Bl
operator|)
condition|)
block|{
name|mandoc_vmsg
argument_list|(
name|MANDOCERR_IT_STRAY
argument_list|,
name|mdoc
operator|->
name|parse
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
literal|"It %s"
argument_list|,
name|buf
operator|+
operator|*
name|pos
argument_list|)
expr_stmt|;
name|roff_elem_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|ROFF_br
argument_list|)
expr_stmt|;
name|rew_elem
argument_list|(
name|mdoc
argument_list|,
name|ROFF_br
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * This routine accommodates implicitly- and explicitly-scoped 	 * macro openings.  Implicit ones first close out prior scope 	 * (seen above).  Delay opening the head until necessary to 	 * allow leading punctuation to print.  Special consideration 	 * for `It -column', which has phrase-part syntax instead of 	 * regular child nodes. 	 */
name|mdoc_argv
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|tok
argument_list|,
operator|&
name|arg
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|blk
operator|=
name|mdoc_block_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|head
operator|=
name|body
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Exception: Heads of `It' macros in `-diag' lists are not 	 * parsed, even though `It' macros in general are parsed. 	 */
name|parsed
operator|=
name|tok
operator|!=
name|MDOC_It
operator|||
name|mdoc
operator|->
name|last
operator|->
name|parent
operator|->
name|tok
operator|!=
name|MDOC_Bl
operator|||
name|mdoc
operator|->
name|last
operator|->
name|parent
operator|->
name|norm
operator|->
name|Bl
operator|.
name|type
operator|!=
name|LIST_diag
expr_stmt|;
comment|/* 	 * The `Nd' macro has all arguments in its body: it's a hybrid 	 * of block partial-explicit and full-implicit.  Stupid. 	 */
if|if
condition|(
name|tok
operator|==
name|MDOC_Nd
condition|)
block|{
name|head
operator|=
name|roff_head_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|)
expr_stmt|;
name|rew_last
argument_list|(
name|mdoc
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|body
operator|=
name|roff_body_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tok
operator|==
name|MDOC_Bk
condition|)
name|mdoc
operator|->
name|flags
operator||=
name|MDOC_KEEP
expr_stmt|;
name|ac
operator|=
name|ARGS_EOLN
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * If we are right after a tab character, 		 * do not parse the first word for macros. 		 */
if|if
condition|(
name|mdoc
operator|->
name|flags
operator|&
name|MDOC_PHRASEQN
condition|)
block|{
name|mdoc
operator|->
name|flags
operator|&=
operator|~
name|MDOC_PHRASEQN
expr_stmt|;
name|mdoc
operator|->
name|flags
operator||=
name|MDOC_PHRASEQF
expr_stmt|;
block|}
name|la
operator|=
operator|*
name|pos
expr_stmt|;
name|lac
operator|=
name|ac
expr_stmt|;
name|ac
operator|=
name|mdoc_args
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|,
name|tok
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
operator|==
name|ARGS_EOLN
condition|)
block|{
if|if
condition|(
name|lac
operator|!=
name|ARGS_PHRASE
operator|||
operator|!
operator|(
name|mdoc
operator|->
name|flags
operator|&
name|MDOC_PHRASEQF
operator|)
condition|)
break|break;
comment|/* 			 * This line ends in a tab; start the next 			 * column now, with a leading blank. 			 */
if|if
condition|(
name|body
operator|!=
name|NULL
condition|)
name|rew_last
argument_list|(
name|mdoc
argument_list|,
name|body
argument_list|)
expr_stmt|;
name|body
operator|=
name|roff_body_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|)
expr_stmt|;
name|roff_word_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
literal|"\\&"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tok
operator|==
name|MDOC_Bd
operator|||
name|tok
operator|==
name|MDOC_Bk
condition|)
block|{
name|mandoc_vmsg
argument_list|(
name|MANDOCERR_ARG_EXCESS
argument_list|,
name|mdoc
operator|->
name|parse
argument_list|,
name|line
argument_list|,
name|la
argument_list|,
literal|"%s ... %s"
argument_list|,
name|roff_name
index|[
name|tok
index|]
argument_list|,
name|buf
operator|+
name|la
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tok
operator|==
name|MDOC_Rs
condition|)
block|{
name|mandoc_vmsg
argument_list|(
name|MANDOCERR_ARG_SKIP
argument_list|,
name|mdoc
operator|->
name|parse
argument_list|,
name|line
argument_list|,
name|la
argument_list|,
literal|"Rs %s"
argument_list|,
name|buf
operator|+
name|la
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ac
operator|==
name|ARGS_PUNCT
condition|)
break|break;
comment|/* 		 * Emit leading punctuation (i.e., punctuation before 		 * the ROFFT_HEAD) for non-phrase types. 		 */
if|if
condition|(
name|head
operator|==
name|NULL
operator|&&
name|ac
operator|!=
name|ARGS_PHRASE
operator|&&
name|mdoc_isdelim
argument_list|(
name|p
argument_list|)
operator|==
name|DELIM_OPEN
condition|)
block|{
name|dword
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|la
argument_list|,
name|p
argument_list|,
name|DELIM_OPEN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Open a head if one hasn't been opened. */
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
name|head
operator|=
name|roff_head_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
operator|==
name|ARGS_PHRASE
condition|)
block|{
comment|/* 			 * If we haven't opened a body yet, rewind the 			 * head; if we have, rewind that instead. 			 */
name|rew_last
argument_list|(
name|mdoc
argument_list|,
name|body
operator|==
name|NULL
condition|?
name|head
else|:
name|body
argument_list|)
expr_stmt|;
name|body
operator|=
name|roff_body_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|)
expr_stmt|;
comment|/* Process to the tab or to the end of the line. */
name|mdoc
operator|->
name|flags
operator||=
name|MDOC_PHRASE
expr_stmt|;
name|parse_rest
argument_list|(
name|mdoc
argument_list|,
name|TOKEN_NONE
argument_list|,
name|line
argument_list|,
operator|&
name|la
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|mdoc
operator|->
name|flags
operator|&=
operator|~
name|MDOC_PHRASE
expr_stmt|;
comment|/* There may have been `Ta' macros. */
while|while
condition|(
name|body
operator|->
name|next
operator|!=
name|NULL
condition|)
name|body
operator|=
name|body
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|macro_or_word
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|la
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|,
name|parsed
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|blk
operator|->
name|flags
operator|&
name|NODE_VALID
condition|)
return|return;
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
name|head
operator|=
name|roff_head_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
operator|&&
name|tok
operator|!=
name|MDOC_Bd
operator|&&
name|tok
operator|!=
name|MDOC_Bl
operator|&&
name|tok
operator|!=
name|MDOC_Rs
condition|)
name|append_delims
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|body
operator|!=
name|NULL
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|find_pending
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|head
argument_list|)
condition|)
return|return;
comment|/* Close out scopes to remain in a consistent state. */
name|rew_last
argument_list|(
name|mdoc
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|body
operator|=
name|roff_body_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|mdoc
operator|->
name|flags
operator|&
name|MDOC_FREECOL
condition|)
block|{
name|rew_last
argument_list|(
name|mdoc
argument_list|,
name|body
argument_list|)
expr_stmt|;
name|rew_last
argument_list|(
name|mdoc
argument_list|,
name|blk
argument_list|)
expr_stmt|;
name|mdoc
operator|->
name|flags
operator|&=
operator|~
name|MDOC_FREECOL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|blk_part_imp
parameter_list|(
name|MACRO_PROT_ARGS
parameter_list|)
block|{
name|int
name|la
decl_stmt|,
name|nl
decl_stmt|;
name|enum
name|margserr
name|ac
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|roff_node
modifier|*
name|blk
decl_stmt|;
comment|/* saved block context */
name|struct
name|roff_node
modifier|*
name|body
decl_stmt|;
comment|/* saved body context */
name|struct
name|roff_node
modifier|*
name|n
decl_stmt|;
name|nl
operator|=
name|MDOC_NEWLINE
operator|&
name|mdoc
operator|->
name|flags
expr_stmt|;
comment|/* 	 * A macro that spans to the end of the line.  This is generally 	 * (but not necessarily) called as the first macro.  The block 	 * has a head as the immediate child, which is always empty, 	 * followed by zero or more opening punctuation nodes, then the 	 * body (which may be empty, depending on the macro), then zero 	 * or more closing punctuation nodes. 	 */
name|blk
operator|=
name|mdoc_block_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rew_last
argument_list|(
name|mdoc
argument_list|,
name|roff_head_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Open the body scope "on-demand", that is, after we've 	 * processed all our the leading delimiters (open parenthesis, 	 * etc.). 	 */
for|for
control|(
name|body
operator|=
name|NULL
init|;
condition|;
control|)
block|{
name|la
operator|=
operator|*
name|pos
expr_stmt|;
name|ac
operator|=
name|mdoc_args
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|,
name|tok
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
operator|==
name|ARGS_EOLN
operator|||
name|ac
operator|==
name|ARGS_PUNCT
condition|)
break|break;
if|if
condition|(
name|body
operator|==
name|NULL
operator|&&
name|mdoc_isdelim
argument_list|(
name|p
argument_list|)
operator|==
name|DELIM_OPEN
condition|)
block|{
name|dword
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|la
argument_list|,
name|p
argument_list|,
name|DELIM_OPEN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|body
operator|==
name|NULL
condition|)
name|body
operator|=
name|roff_body_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|)
expr_stmt|;
if|if
condition|(
name|macro_or_word
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|la
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|body
operator|==
name|NULL
condition|)
name|body
operator|=
name|roff_body_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_pending
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|body
argument_list|)
condition|)
return|return;
name|rew_last
argument_list|(
name|mdoc
argument_list|,
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
condition|)
name|append_delims
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|rew_pending
argument_list|(
name|mdoc
argument_list|,
name|blk
argument_list|)
expr_stmt|;
comment|/* Move trailing .Ns out of scope. */
for|for
control|(
name|n
operator|=
name|body
operator|->
name|child
init|;
name|n
operator|&&
name|n
operator|->
name|next
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
comment|/* Do nothing. */
empty_stmt|;
if|if
condition|(
name|n
operator|&&
name|n
operator|->
name|tok
operator|==
name|MDOC_Ns
condition|)
name|mdoc_node_relink
argument_list|(
name|mdoc
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|blk_part_exp
parameter_list|(
name|MACRO_PROT_ARGS
parameter_list|)
block|{
name|int
name|la
decl_stmt|,
name|nl
decl_stmt|;
name|enum
name|margserr
name|ac
decl_stmt|;
name|struct
name|roff_node
modifier|*
name|head
decl_stmt|;
comment|/* keep track of head */
name|char
modifier|*
name|p
decl_stmt|;
name|nl
operator|=
name|MDOC_NEWLINE
operator|&
name|mdoc
operator|->
name|flags
expr_stmt|;
comment|/* 	 * The opening of an explicit macro having zero or more leading 	 * punctuation nodes; a head with optional single element (the 	 * case of `Eo'); and a body that may be empty. 	 */
name|roff_block_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|)
expr_stmt|;
name|head
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|la
operator|=
operator|*
name|pos
expr_stmt|;
name|ac
operator|=
name|mdoc_args
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|,
name|tok
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
operator|==
name|ARGS_PUNCT
operator|||
name|ac
operator|==
name|ARGS_EOLN
condition|)
break|break;
comment|/* Flush out leading punctuation. */
if|if
condition|(
name|head
operator|==
name|NULL
operator|&&
name|mdoc_isdelim
argument_list|(
name|p
argument_list|)
operator|==
name|DELIM_OPEN
condition|)
block|{
name|dword
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|la
argument_list|,
name|p
argument_list|,
name|DELIM_OPEN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
block|{
name|head
operator|=
name|roff_head_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|MDOC_Eo
condition|)
comment|/* Not parsed. */
name|dword
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|la
argument_list|,
name|p
argument_list|,
name|DELIM_MAX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rew_last
argument_list|(
name|mdoc
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|roff_body_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|MDOC_Eo
condition|)
continue|continue;
block|}
if|if
condition|(
name|macro_or_word
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|la
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
block|}
comment|/* Clean-up to leave in a consistent state. */
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
block|{
name|rew_last
argument_list|(
name|mdoc
argument_list|,
name|roff_head_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|)
argument_list|)
expr_stmt|;
name|roff_body_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nl
condition|)
name|append_delims
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|in_line_argn
parameter_list|(
name|MACRO_PROT_ARGS
parameter_list|)
block|{
name|struct
name|mdoc_arg
modifier|*
name|arg
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|enum
name|margserr
name|ac
decl_stmt|;
name|enum
name|roff_tok
name|ntok
decl_stmt|;
name|int
name|state
decl_stmt|;
comment|/* arg#; -1: not yet open; -2: closed */
name|int
name|la
decl_stmt|,
name|maxargs
decl_stmt|,
name|nl
decl_stmt|;
name|nl
operator|=
name|mdoc
operator|->
name|flags
operator|&
name|MDOC_NEWLINE
expr_stmt|;
comment|/* 	 * A line macro that has a fixed number of arguments (maxargs). 	 * Only open the scope once the first non-leading-punctuation is 	 * found (unless MDOC_IGNDELIM is noted, like in `Pf'), then 	 * keep it open until the maximum number of arguments are 	 * exhausted. 	 */
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|MDOC_Ap
case|:
case|case
name|MDOC_Ns
case|:
case|case
name|MDOC_Ux
case|:
name|maxargs
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MDOC_Bx
case|:
case|case
name|MDOC_Es
case|:
case|case
name|MDOC_Xr
case|:
name|maxargs
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|maxargs
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|mdoc_argv
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|tok
argument_list|,
operator|&
name|arg
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|state
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|la
operator|=
operator|*
name|pos
expr_stmt|;
name|ac
operator|=
name|mdoc_args
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|,
name|tok
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
operator|==
name|ARGS_WORD
operator|&&
name|state
operator|==
operator|-
literal|1
operator|&&
operator|!
operator|(
name|mdoc_macros
index|[
name|tok
index|]
operator|.
name|flags
operator|&
name|MDOC_IGNDELIM
operator|)
operator|&&
name|mdoc_isdelim
argument_list|(
name|p
argument_list|)
operator|==
name|DELIM_OPEN
condition|)
block|{
name|dword
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|la
argument_list|,
name|p
argument_list|,
name|DELIM_OPEN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|state
operator|==
operator|-
literal|1
operator|&&
name|tok
operator|!=
name|MDOC_In
operator|&&
name|tok
operator|!=
name|MDOC_St
operator|&&
name|tok
operator|!=
name|MDOC_Xr
condition|)
block|{
name|mdoc_elem_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ac
operator|==
name|ARGS_PUNCT
operator|||
name|ac
operator|==
name|ARGS_EOLN
condition|)
block|{
if|if
condition|(
name|abs
argument_list|(
name|state
argument_list|)
operator|<
literal|2
operator|&&
name|tok
operator|==
name|MDOC_Pf
condition|)
name|mandoc_vmsg
argument_list|(
name|MANDOCERR_PF_SKIP
argument_list|,
name|mdoc
operator|->
name|parse
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
literal|"Pf %s"
argument_list|,
name|p
operator|==
name|NULL
condition|?
literal|"at eol"
else|:
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|state
operator|==
name|maxargs
condition|)
block|{
name|rew_elem
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|)
expr_stmt|;
name|state
operator|=
operator|-
literal|2
expr_stmt|;
block|}
name|ntok
operator|=
operator|(
name|tok
operator|==
name|MDOC_Pf
operator|&&
name|state
operator|==
literal|0
operator|)
condition|?
name|TOKEN_NONE
else|:
name|lookup
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|la
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntok
operator|!=
name|TOKEN_NONE
condition|)
block|{
if|if
condition|(
name|state
operator|>=
literal|0
condition|)
block|{
name|rew_elem
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|)
expr_stmt|;
name|state
operator|=
operator|-
literal|2
expr_stmt|;
block|}
name|mdoc_macro
argument_list|(
name|mdoc
argument_list|,
name|ntok
argument_list|,
name|line
argument_list|,
name|la
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|mdoc_macros
index|[
name|tok
index|]
operator|.
name|flags
operator|&
name|MDOC_IGNDELIM
operator|||
name|mdoc_isdelim
argument_list|(
name|p
argument_list|)
operator|==
name|DELIM_NONE
condition|)
block|{
if|if
condition|(
name|state
operator|==
operator|-
literal|1
condition|)
block|{
name|mdoc_elem_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|state
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|>=
literal|0
condition|)
name|state
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|>=
literal|0
condition|)
block|{
name|rew_elem
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|)
expr_stmt|;
name|state
operator|=
operator|-
literal|2
expr_stmt|;
block|}
name|dword
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|la
argument_list|,
name|p
argument_list|,
name|DELIM_MAX
argument_list|,
name|mdoc_macros
index|[
name|tok
index|]
operator|.
name|flags
operator|&
name|MDOC_JOIN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|==
operator|-
literal|1
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_MACRO_EMPTY
argument_list|,
name|mdoc
operator|->
name|parse
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|roff_name
index|[
name|tok
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|state
operator|==
literal|0
operator|&&
name|tok
operator|==
name|MDOC_Pf
condition|)
name|append_delims
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|>=
literal|0
condition|)
name|rew_elem
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
condition|)
name|append_delims
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|in_line_eoln
parameter_list|(
name|MACRO_PROT_ARGS
parameter_list|)
block|{
name|struct
name|roff_node
modifier|*
name|n
decl_stmt|;
name|struct
name|mdoc_arg
modifier|*
name|arg
decl_stmt|;
if|if
condition|(
operator|(
name|tok
operator|==
name|MDOC_Pp
operator|||
name|tok
operator|==
name|MDOC_Lp
operator|)
operator|&&
operator|!
operator|(
name|mdoc
operator|->
name|flags
operator|&
name|MDOC_SYNOPSIS
operator|)
condition|)
block|{
name|n
operator|=
name|mdoc
operator|->
name|last
expr_stmt|;
if|if
condition|(
name|mdoc
operator|->
name|next
operator|==
name|ROFF_NEXT_SIBLING
condition|)
name|n
operator|=
name|n
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|tok
operator|==
name|MDOC_Nm
condition|)
name|rew_last
argument_list|(
name|mdoc
argument_list|,
name|n
operator|->
name|parent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|buf
index|[
operator|*
name|pos
index|]
operator|==
literal|'\0'
operator|&&
operator|(
name|tok
operator|==
name|MDOC_Fd
operator|||
operator|*
name|roff_name
index|[
name|tok
index|]
operator|==
literal|'%'
operator|)
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_MACRO_EMPTY
argument_list|,
name|mdoc
operator|->
name|parse
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|roff_name
index|[
name|tok
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|mdoc_argv
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|tok
argument_list|,
operator|&
name|arg
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|mdoc_elem_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|tok
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_rest
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
condition|)
return|return;
name|rew_elem
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The simplest argument parser available: Parse the remaining  * words until the end of the phrase or line and return 0  * or until the next macro, call that macro, and return 1.  */
end_comment

begin_function
specifier|static
name|int
name|parse_rest
parameter_list|(
name|struct
name|roff_man
modifier|*
name|mdoc
parameter_list|,
name|enum
name|roff_tok
name|tok
parameter_list|,
name|int
name|line
parameter_list|,
name|int
modifier|*
name|pos
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|la
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|la
operator|=
operator|*
name|pos
expr_stmt|;
if|if
condition|(
name|mdoc_args
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|,
name|tok
argument_list|,
name|NULL
argument_list|)
operator|==
name|ARGS_EOLN
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|macro_or_word
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|la
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ctx_synopsis
parameter_list|(
name|MACRO_PROT_ARGS
parameter_list|)
block|{
if|if
condition|(
operator|~
name|mdoc
operator|->
name|flags
operator|&
operator|(
name|MDOC_SYNOPSIS
operator||
name|MDOC_NEWLINE
operator|)
condition|)
name|in_line
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tok
operator|==
name|MDOC_Nm
condition|)
name|blk_full
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
name|tok
operator|==
name|MDOC_Vt
argument_list|)
expr_stmt|;
name|blk_part_imp
argument_list|(
name|mdoc
argument_list|,
name|tok
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Phrases occur within `Bl -column' entries, separated by `Ta' or tabs.  * They're unusual because they're basically free-form text until a  * macro is encountered.  */
end_comment

begin_function
specifier|static
name|void
name|phrase_ta
parameter_list|(
name|MACRO_PROT_ARGS
parameter_list|)
block|{
name|struct
name|roff_node
modifier|*
name|body
decl_stmt|,
modifier|*
name|n
decl_stmt|;
comment|/* Make sure we are in a column list or ignore this macro. */
name|body
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|n
operator|=
name|mdoc
operator|->
name|last
init|;
name|n
operator|!=
name|NULL
condition|;
name|n
operator|=
name|n
operator|->
name|parent
control|)
block|{
if|if
condition|(
name|n
operator|->
name|flags
operator|&
name|NODE_ENDED
condition|)
continue|continue;
if|if
condition|(
name|n
operator|->
name|tok
operator|==
name|MDOC_It
operator|&&
name|n
operator|->
name|type
operator|==
name|ROFFT_BODY
condition|)
name|body
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|tok
operator|==
name|MDOC_Bl
operator|&&
name|n
operator|->
name|end
operator|==
name|ENDBODY_NOT
condition|)
break|break;
block|}
if|if
condition|(
name|n
operator|==
name|NULL
operator|||
name|n
operator|->
name|norm
operator|->
name|Bl
operator|.
name|type
operator|!=
name|LIST_column
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_TA_STRAY
argument_list|,
name|mdoc
operator|->
name|parse
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
literal|"Ta"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Advance to the next column. */
name|rew_last
argument_list|(
name|mdoc
argument_list|,
name|body
argument_list|)
expr_stmt|;
name|roff_body_alloc
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|ppos
argument_list|,
name|MDOC_It
argument_list|)
expr_stmt|;
name|parse_rest
argument_list|(
name|mdoc
argument_list|,
name|TOKEN_NONE
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

