begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$Id: eqn.c,v 1.44 2014/07/06 19:09:00 schwarze Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2011 Kristaps Dzonsons<kristaps@bsd.lv>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|"mandoc.h"
end_include

begin_include
include|#
directive|include
file|"mandoc_aux.h"
end_include

begin_include
include|#
directive|include
file|"libmandoc.h"
end_include

begin_include
include|#
directive|include
file|"libroff.h"
end_include

begin_define
define|#
directive|define
name|EQN_NEST_MAX
value|128
end_define

begin_comment
comment|/* maximum nesting of defines */
end_comment

begin_define
define|#
directive|define
name|EQN_MSG
parameter_list|(
name|t
parameter_list|,
name|x
parameter_list|)
value|mandoc_msg((t), (x)->parse, (x)->eqn.ln, (x)->eqn.pos, NULL)
end_define

begin_enum
enum|enum
name|eqn_rest
block|{
name|EQN_DESCOPE
block|,
name|EQN_ERR
block|,
name|EQN_OK
block|,
name|EQN_EOF
block|}
enum|;
end_enum

begin_enum
enum|enum
name|eqn_symt
block|{
name|EQNSYM_alpha
block|,
name|EQNSYM_beta
block|,
name|EQNSYM_chi
block|,
name|EQNSYM_delta
block|,
name|EQNSYM_epsilon
block|,
name|EQNSYM_eta
block|,
name|EQNSYM_gamma
block|,
name|EQNSYM_iota
block|,
name|EQNSYM_kappa
block|,
name|EQNSYM_lambda
block|,
name|EQNSYM_mu
block|,
name|EQNSYM_nu
block|,
name|EQNSYM_omega
block|,
name|EQNSYM_omicron
block|,
name|EQNSYM_phi
block|,
name|EQNSYM_pi
block|,
name|EQNSYM_ps
block|,
name|EQNSYM_rho
block|,
name|EQNSYM_sigma
block|,
name|EQNSYM_tau
block|,
name|EQNSYM_theta
block|,
name|EQNSYM_upsilon
block|,
name|EQNSYM_xi
block|,
name|EQNSYM_zeta
block|,
name|EQNSYM_DELTA
block|,
name|EQNSYM_GAMMA
block|,
name|EQNSYM_LAMBDA
block|,
name|EQNSYM_OMEGA
block|,
name|EQNSYM_PHI
block|,
name|EQNSYM_PI
block|,
name|EQNSYM_PSI
block|,
name|EQNSYM_SIGMA
block|,
name|EQNSYM_THETA
block|,
name|EQNSYM_UPSILON
block|,
name|EQNSYM_XI
block|,
name|EQNSYM_inter
block|,
name|EQNSYM_union
block|,
name|EQNSYM_prod
block|,
name|EQNSYM_int
block|,
name|EQNSYM_sum
block|,
name|EQNSYM_grad
block|,
name|EQNSYM_del
block|,
name|EQNSYM_times
block|,
name|EQNSYM_cdot
block|,
name|EQNSYM_nothing
block|,
name|EQNSYM_approx
block|,
name|EQNSYM_prime
block|,
name|EQNSYM_half
block|,
name|EQNSYM_partial
block|,
name|EQNSYM_inf
block|,
name|EQNSYM_muchgreat
block|,
name|EQNSYM_muchless
block|,
name|EQNSYM_larrow
block|,
name|EQNSYM_rarrow
block|,
name|EQNSYM_pm
block|,
name|EQNSYM_nequal
block|,
name|EQNSYM_equiv
block|,
name|EQNSYM_lessequal
block|,
name|EQNSYM_moreequal
block|,
name|EQNSYM__MAX
block|}
enum|;
end_enum

begin_enum
enum|enum
name|eqnpartt
block|{
name|EQN_DEFINE
init|=
literal|0
block|,
name|EQN_NDEFINE
block|,
name|EQN_TDEFINE
block|,
name|EQN_SET
block|,
name|EQN_UNDEF
block|,
name|EQN_GFONT
block|,
name|EQN_GSIZE
block|,
name|EQN_BACK
block|,
name|EQN_FWD
block|,
name|EQN_UP
block|,
name|EQN_DOWN
block|,
name|EQN__MAX
block|}
enum|;
end_enum

begin_struct
struct|struct
name|eqnstr
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|STRNEQ
parameter_list|(
name|p1
parameter_list|,
name|sz1
parameter_list|,
name|p2
parameter_list|,
name|sz2
parameter_list|)
define|\
value|((sz1) == (sz2)&& 0 == strncmp((p1), (p2), (sz1)))
end_define

begin_define
define|#
directive|define
name|EQNSTREQ
parameter_list|(
name|x
parameter_list|,
name|p
parameter_list|,
name|sz
parameter_list|)
define|\
value|STRNEQ((x)->name, (x)->sz, (p), (sz))
end_define

begin_struct
struct|struct
name|eqnpart
block|{
name|struct
name|eqnstr
name|str
decl_stmt|;
name|int
function_decl|(
modifier|*
name|fp
function_decl|)
parameter_list|(
name|struct
name|eqn_node
modifier|*
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|eqnsym
block|{
name|struct
name|eqnstr
name|str
decl_stmt|;
specifier|const
name|char
modifier|*
name|sym
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|enum
name|eqn_rest
name|eqn_box
parameter_list|(
name|struct
name|eqn_node
modifier|*
parameter_list|,
name|struct
name|eqn_box
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|eqn_box
modifier|*
name|eqn_box_alloc
parameter_list|(
name|struct
name|eqn_node
modifier|*
parameter_list|,
name|struct
name|eqn_box
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eqn_box_free
parameter_list|(
name|struct
name|eqn_box
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|eqn_def
modifier|*
name|eqn_def_find
parameter_list|(
name|struct
name|eqn_node
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|eqn_do_gfont
parameter_list|(
name|struct
name|eqn_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|eqn_do_gsize
parameter_list|(
name|struct
name|eqn_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|eqn_do_define
parameter_list|(
name|struct
name|eqn_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|eqn_do_ign1
parameter_list|(
name|struct
name|eqn_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|eqn_do_ign2
parameter_list|(
name|struct
name|eqn_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|eqn_do_tdefine
parameter_list|(
name|struct
name|eqn_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|eqn_do_undef
parameter_list|(
name|struct
name|eqn_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|eqn_rest
name|eqn_eqn
parameter_list|(
name|struct
name|eqn_node
modifier|*
parameter_list|,
name|struct
name|eqn_box
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|eqn_rest
name|eqn_list
parameter_list|(
name|struct
name|eqn_node
modifier|*
parameter_list|,
name|struct
name|eqn_box
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|eqn_rest
name|eqn_matrix
parameter_list|(
name|struct
name|eqn_node
modifier|*
parameter_list|,
name|struct
name|eqn_box
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|eqn_nexttok
parameter_list|(
name|struct
name|eqn_node
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|eqn_nextrawtok
parameter_list|(
name|struct
name|eqn_node
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|eqn_next
parameter_list|(
name|struct
name|eqn_node
modifier|*
parameter_list|,
name|char
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eqn_rewind
parameter_list|(
name|struct
name|eqn_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|eqnpart
name|eqnparts
index|[
name|EQN__MAX
index|]
init|=
block|{
block|{
block|{
literal|"define"
block|,
literal|6
block|}
block|,
name|eqn_do_define
block|}
block|,
comment|/* EQN_DEFINE */
block|{
block|{
literal|"ndefine"
block|,
literal|7
block|}
block|,
name|eqn_do_define
block|}
block|,
comment|/* EQN_NDEFINE */
block|{
block|{
literal|"tdefine"
block|,
literal|7
block|}
block|,
name|eqn_do_tdefine
block|}
block|,
comment|/* EQN_TDEFINE */
block|{
block|{
literal|"set"
block|,
literal|3
block|}
block|,
name|eqn_do_ign2
block|}
block|,
comment|/* EQN_SET */
block|{
block|{
literal|"undef"
block|,
literal|5
block|}
block|,
name|eqn_do_undef
block|}
block|,
comment|/* EQN_UNDEF */
block|{
block|{
literal|"gfont"
block|,
literal|5
block|}
block|,
name|eqn_do_gfont
block|}
block|,
comment|/* EQN_GFONT */
block|{
block|{
literal|"gsize"
block|,
literal|5
block|}
block|,
name|eqn_do_gsize
block|}
block|,
comment|/* EQN_GSIZE */
block|{
block|{
literal|"back"
block|,
literal|4
block|}
block|,
name|eqn_do_ign1
block|}
block|,
comment|/* EQN_BACK */
block|{
block|{
literal|"fwd"
block|,
literal|3
block|}
block|,
name|eqn_do_ign1
block|}
block|,
comment|/* EQN_FWD */
block|{
block|{
literal|"up"
block|,
literal|2
block|}
block|,
name|eqn_do_ign1
block|}
block|,
comment|/* EQN_UP */
block|{
block|{
literal|"down"
block|,
literal|4
block|}
block|,
name|eqn_do_ign1
block|}
block|,
comment|/* EQN_DOWN */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|eqnstr
name|eqnmarks
index|[
name|EQNMARK__MAX
index|]
init|=
block|{
block|{
literal|""
block|,
literal|0
block|}
block|,
comment|/* EQNMARK_NONE */
block|{
literal|"dot"
block|,
literal|3
block|}
block|,
comment|/* EQNMARK_DOT */
block|{
literal|"dotdot"
block|,
literal|6
block|}
block|,
comment|/* EQNMARK_DOTDOT */
block|{
literal|"hat"
block|,
literal|3
block|}
block|,
comment|/* EQNMARK_HAT */
block|{
literal|"tilde"
block|,
literal|5
block|}
block|,
comment|/* EQNMARK_TILDE */
block|{
literal|"vec"
block|,
literal|3
block|}
block|,
comment|/* EQNMARK_VEC */
block|{
literal|"dyad"
block|,
literal|4
block|}
block|,
comment|/* EQNMARK_DYAD */
block|{
literal|"bar"
block|,
literal|3
block|}
block|,
comment|/* EQNMARK_BAR */
block|{
literal|"under"
block|,
literal|5
block|}
block|,
comment|/* EQNMARK_UNDER */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|eqnstr
name|eqnfonts
index|[
name|EQNFONT__MAX
index|]
init|=
block|{
block|{
literal|""
block|,
literal|0
block|}
block|,
comment|/* EQNFONT_NONE */
block|{
literal|"roman"
block|,
literal|5
block|}
block|,
comment|/* EQNFONT_ROMAN */
block|{
literal|"bold"
block|,
literal|4
block|}
block|,
comment|/* EQNFONT_BOLD */
block|{
literal|"fat"
block|,
literal|3
block|}
block|,
comment|/* EQNFONT_FAT */
block|{
literal|"italic"
block|,
literal|6
block|}
block|,
comment|/* EQNFONT_ITALIC */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|eqnstr
name|eqnposs
index|[
name|EQNPOS__MAX
index|]
init|=
block|{
block|{
literal|""
block|,
literal|0
block|}
block|,
comment|/* EQNPOS_NONE */
block|{
literal|"over"
block|,
literal|4
block|}
block|,
comment|/* EQNPOS_OVER */
block|{
literal|"sup"
block|,
literal|3
block|}
block|,
comment|/* EQNPOS_SUP */
block|{
literal|"sub"
block|,
literal|3
block|}
block|,
comment|/* EQNPOS_SUB */
block|{
literal|"to"
block|,
literal|2
block|}
block|,
comment|/* EQNPOS_TO */
block|{
literal|"from"
block|,
literal|4
block|}
block|,
comment|/* EQNPOS_FROM */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|eqnstr
name|eqnpiles
index|[
name|EQNPILE__MAX
index|]
init|=
block|{
block|{
literal|""
block|,
literal|0
block|}
block|,
comment|/* EQNPILE_NONE */
block|{
literal|"pile"
block|,
literal|4
block|}
block|,
comment|/* EQNPILE_PILE */
block|{
literal|"cpile"
block|,
literal|5
block|}
block|,
comment|/* EQNPILE_CPILE */
block|{
literal|"rpile"
block|,
literal|5
block|}
block|,
comment|/* EQNPILE_RPILE */
block|{
literal|"lpile"
block|,
literal|5
block|}
block|,
comment|/* EQNPILE_LPILE */
block|{
literal|"col"
block|,
literal|3
block|}
block|,
comment|/* EQNPILE_COL */
block|{
literal|"ccol"
block|,
literal|4
block|}
block|,
comment|/* EQNPILE_CCOL */
block|{
literal|"rcol"
block|,
literal|4
block|}
block|,
comment|/* EQNPILE_RCOL */
block|{
literal|"lcol"
block|,
literal|4
block|}
block|,
comment|/* EQNPILE_LCOL */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|eqnsym
name|eqnsyms
index|[
name|EQNSYM__MAX
index|]
init|=
block|{
block|{
block|{
literal|"alpha"
block|,
literal|5
block|}
block|,
literal|"*a"
block|}
block|,
comment|/* EQNSYM_alpha */
block|{
block|{
literal|"beta"
block|,
literal|4
block|}
block|,
literal|"*b"
block|}
block|,
comment|/* EQNSYM_beta */
block|{
block|{
literal|"chi"
block|,
literal|3
block|}
block|,
literal|"*x"
block|}
block|,
comment|/* EQNSYM_chi */
block|{
block|{
literal|"delta"
block|,
literal|5
block|}
block|,
literal|"*d"
block|}
block|,
comment|/* EQNSYM_delta */
block|{
block|{
literal|"epsilon"
block|,
literal|7
block|}
block|,
literal|"*e"
block|}
block|,
comment|/* EQNSYM_epsilon */
block|{
block|{
literal|"eta"
block|,
literal|3
block|}
block|,
literal|"*y"
block|}
block|,
comment|/* EQNSYM_eta */
block|{
block|{
literal|"gamma"
block|,
literal|5
block|}
block|,
literal|"*g"
block|}
block|,
comment|/* EQNSYM_gamma */
block|{
block|{
literal|"iota"
block|,
literal|4
block|}
block|,
literal|"*i"
block|}
block|,
comment|/* EQNSYM_iota */
block|{
block|{
literal|"kappa"
block|,
literal|5
block|}
block|,
literal|"*k"
block|}
block|,
comment|/* EQNSYM_kappa */
block|{
block|{
literal|"lambda"
block|,
literal|6
block|}
block|,
literal|"*l"
block|}
block|,
comment|/* EQNSYM_lambda */
block|{
block|{
literal|"mu"
block|,
literal|2
block|}
block|,
literal|"*m"
block|}
block|,
comment|/* EQNSYM_mu */
block|{
block|{
literal|"nu"
block|,
literal|2
block|}
block|,
literal|"*n"
block|}
block|,
comment|/* EQNSYM_nu */
block|{
block|{
literal|"omega"
block|,
literal|5
block|}
block|,
literal|"*w"
block|}
block|,
comment|/* EQNSYM_omega */
block|{
block|{
literal|"omicron"
block|,
literal|7
block|}
block|,
literal|"*o"
block|}
block|,
comment|/* EQNSYM_omicron */
block|{
block|{
literal|"phi"
block|,
literal|3
block|}
block|,
literal|"*f"
block|}
block|,
comment|/* EQNSYM_phi */
block|{
block|{
literal|"pi"
block|,
literal|2
block|}
block|,
literal|"*p"
block|}
block|,
comment|/* EQNSYM_pi */
block|{
block|{
literal|"psi"
block|,
literal|2
block|}
block|,
literal|"*q"
block|}
block|,
comment|/* EQNSYM_psi */
block|{
block|{
literal|"rho"
block|,
literal|3
block|}
block|,
literal|"*r"
block|}
block|,
comment|/* EQNSYM_rho */
block|{
block|{
literal|"sigma"
block|,
literal|5
block|}
block|,
literal|"*s"
block|}
block|,
comment|/* EQNSYM_sigma */
block|{
block|{
literal|"tau"
block|,
literal|3
block|}
block|,
literal|"*t"
block|}
block|,
comment|/* EQNSYM_tau */
block|{
block|{
literal|"theta"
block|,
literal|5
block|}
block|,
literal|"*h"
block|}
block|,
comment|/* EQNSYM_theta */
block|{
block|{
literal|"upsilon"
block|,
literal|7
block|}
block|,
literal|"*u"
block|}
block|,
comment|/* EQNSYM_upsilon */
block|{
block|{
literal|"xi"
block|,
literal|2
block|}
block|,
literal|"*c"
block|}
block|,
comment|/* EQNSYM_xi */
block|{
block|{
literal|"zeta"
block|,
literal|4
block|}
block|,
literal|"*z"
block|}
block|,
comment|/* EQNSYM_zeta */
block|{
block|{
literal|"DELTA"
block|,
literal|5
block|}
block|,
literal|"*D"
block|}
block|,
comment|/* EQNSYM_DELTA */
block|{
block|{
literal|"GAMMA"
block|,
literal|5
block|}
block|,
literal|"*G"
block|}
block|,
comment|/* EQNSYM_GAMMA */
block|{
block|{
literal|"LAMBDA"
block|,
literal|6
block|}
block|,
literal|"*L"
block|}
block|,
comment|/* EQNSYM_LAMBDA */
block|{
block|{
literal|"OMEGA"
block|,
literal|5
block|}
block|,
literal|"*W"
block|}
block|,
comment|/* EQNSYM_OMEGA */
block|{
block|{
literal|"PHI"
block|,
literal|3
block|}
block|,
literal|"*F"
block|}
block|,
comment|/* EQNSYM_PHI */
block|{
block|{
literal|"PI"
block|,
literal|2
block|}
block|,
literal|"*P"
block|}
block|,
comment|/* EQNSYM_PI */
block|{
block|{
literal|"PSI"
block|,
literal|3
block|}
block|,
literal|"*Q"
block|}
block|,
comment|/* EQNSYM_PSI */
block|{
block|{
literal|"SIGMA"
block|,
literal|5
block|}
block|,
literal|"*S"
block|}
block|,
comment|/* EQNSYM_SIGMA */
block|{
block|{
literal|"THETA"
block|,
literal|5
block|}
block|,
literal|"*H"
block|}
block|,
comment|/* EQNSYM_THETA */
block|{
block|{
literal|"UPSILON"
block|,
literal|7
block|}
block|,
literal|"*U"
block|}
block|,
comment|/* EQNSYM_UPSILON */
block|{
block|{
literal|"XI"
block|,
literal|2
block|}
block|,
literal|"*C"
block|}
block|,
comment|/* EQNSYM_XI */
block|{
block|{
literal|"inter"
block|,
literal|5
block|}
block|,
literal|"ca"
block|}
block|,
comment|/* EQNSYM_inter */
block|{
block|{
literal|"union"
block|,
literal|5
block|}
block|,
literal|"cu"
block|}
block|,
comment|/* EQNSYM_union */
block|{
block|{
literal|"prod"
block|,
literal|4
block|}
block|,
literal|"product"
block|}
block|,
comment|/* EQNSYM_prod */
block|{
block|{
literal|"int"
block|,
literal|3
block|}
block|,
literal|"integral"
block|}
block|,
comment|/* EQNSYM_int */
block|{
block|{
literal|"sum"
block|,
literal|3
block|}
block|,
literal|"sum"
block|}
block|,
comment|/* EQNSYM_sum */
block|{
block|{
literal|"grad"
block|,
literal|4
block|}
block|,
literal|"gr"
block|}
block|,
comment|/* EQNSYM_grad */
block|{
block|{
literal|"del"
block|,
literal|3
block|}
block|,
literal|"gr"
block|}
block|,
comment|/* EQNSYM_del */
block|{
block|{
literal|"times"
block|,
literal|5
block|}
block|,
literal|"mu"
block|}
block|,
comment|/* EQNSYM_times */
block|{
block|{
literal|"cdot"
block|,
literal|4
block|}
block|,
literal|"pc"
block|}
block|,
comment|/* EQNSYM_cdot */
block|{
block|{
literal|"nothing"
block|,
literal|7
block|}
block|,
literal|"&"
block|}
block|,
comment|/* EQNSYM_nothing */
block|{
block|{
literal|"approx"
block|,
literal|6
block|}
block|,
literal|"~~"
block|}
block|,
comment|/* EQNSYM_approx */
block|{
block|{
literal|"prime"
block|,
literal|5
block|}
block|,
literal|"aq"
block|}
block|,
comment|/* EQNSYM_prime */
block|{
block|{
literal|"half"
block|,
literal|4
block|}
block|,
literal|"12"
block|}
block|,
comment|/* EQNSYM_half */
block|{
block|{
literal|"partial"
block|,
literal|7
block|}
block|,
literal|"pd"
block|}
block|,
comment|/* EQNSYM_partial */
block|{
block|{
literal|"inf"
block|,
literal|3
block|}
block|,
literal|"if"
block|}
block|,
comment|/* EQNSYM_inf */
block|{
block|{
literal|">>"
block|,
literal|2
block|}
block|,
literal|">>"
block|}
block|,
comment|/* EQNSYM_muchgreat */
block|{
block|{
literal|"<<"
block|,
literal|2
block|}
block|,
literal|"<<"
block|}
block|,
comment|/* EQNSYM_muchless */
block|{
block|{
literal|"<-"
block|,
literal|2
block|}
block|,
literal|"<-"
block|}
block|,
comment|/* EQNSYM_larrow */
block|{
block|{
literal|"->"
block|,
literal|2
block|}
block|,
literal|"->"
block|}
block|,
comment|/* EQNSYM_rarrow */
block|{
block|{
literal|"+-"
block|,
literal|2
block|}
block|,
literal|"+-"
block|}
block|,
comment|/* EQNSYM_pm */
block|{
block|{
literal|"!="
block|,
literal|2
block|}
block|,
literal|"!="
block|}
block|,
comment|/* EQNSYM_nequal */
block|{
block|{
literal|"=="
block|,
literal|2
block|}
block|,
literal|"=="
block|}
block|,
comment|/* EQNSYM_equiv */
block|{
block|{
literal|"<="
block|,
literal|2
block|}
block|,
literal|"<="
block|}
block|,
comment|/* EQNSYM_lessequal */
block|{
block|{
literal|">="
block|,
literal|2
block|}
block|,
literal|">="
block|}
block|,
comment|/* EQNSYM_moreequal */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|enum
name|rofferr
name|eqn_read
parameter_list|(
name|struct
name|eqn_node
modifier|*
modifier|*
name|epp
parameter_list|,
name|int
name|ln
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|int
name|pos
parameter_list|,
name|int
modifier|*
name|offs
parameter_list|)
block|{
name|size_t
name|sz
decl_stmt|;
name|struct
name|eqn_node
modifier|*
name|ep
decl_stmt|;
name|enum
name|rofferr
name|er
decl_stmt|;
name|ep
operator|=
operator|*
name|epp
expr_stmt|;
comment|/* 	 * If we're the terminating mark, unset our equation status and 	 * validate the full equation. 	 */
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|p
argument_list|,
literal|".EN"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|er
operator|=
name|eqn_end
argument_list|(
name|epp
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|3
expr_stmt|;
while|while
condition|(
literal|' '
operator|==
operator|*
name|p
operator|||
literal|'\t'
operator|==
operator|*
name|p
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
literal|'\0'
operator|==
operator|*
name|p
condition|)
return|return
operator|(
name|er
operator|)
return|;
name|mandoc_vmsg
argument_list|(
name|MANDOCERR_ARG_SKIP
argument_list|,
name|ep
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|pos
argument_list|,
literal|"EN %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|er
operator|)
return|;
block|}
comment|/* 	 * Build up the full string, replacing all newlines with regular 	 * whitespace. 	 */
name|sz
operator|=
name|strlen
argument_list|(
name|p
operator|+
name|pos
argument_list|)
operator|+
literal|1
expr_stmt|;
name|ep
operator|->
name|data
operator|=
name|mandoc_realloc
argument_list|(
name|ep
operator|->
name|data
argument_list|,
name|ep
operator|->
name|sz
operator|+
name|sz
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* First invocation: nil terminate the string. */
if|if
condition|(
literal|0
operator|==
name|ep
operator|->
name|sz
condition|)
operator|*
name|ep
operator|->
name|data
operator|=
literal|'\0'
expr_stmt|;
name|ep
operator|->
name|sz
operator|+=
name|sz
expr_stmt|;
name|strlcat
argument_list|(
name|ep
operator|->
name|data
argument_list|,
name|p
operator|+
name|pos
argument_list|,
name|ep
operator|->
name|sz
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|ep
operator|->
name|data
argument_list|,
literal|" "
argument_list|,
name|ep
operator|->
name|sz
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|ROFF_IGN
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|eqn_node
modifier|*
name|eqn_alloc
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|pos
parameter_list|,
name|int
name|line
parameter_list|,
name|struct
name|mparse
modifier|*
name|parse
parameter_list|)
block|{
name|struct
name|eqn_node
modifier|*
name|p
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
decl_stmt|;
name|p
operator|=
name|mandoc_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|eqn_node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|&&
literal|'\0'
operator|!=
operator|*
name|name
condition|)
block|{
name|sz
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|sz
argument_list|)
expr_stmt|;
do|do
block|{
name|sz
operator|--
expr_stmt|;
name|end
operator|=
name|name
operator|+
operator|(
name|int
operator|)
name|sz
expr_stmt|;
block|}
do|while
condition|(
literal|' '
operator|==
operator|*
name|end
operator|||
literal|'\t'
operator|==
operator|*
name|end
condition|)
do|;
name|p
operator|->
name|eqn
operator|.
name|name
operator|=
name|mandoc_strndup
argument_list|(
name|name
argument_list|,
name|sz
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|parse
operator|=
name|parse
expr_stmt|;
name|p
operator|->
name|eqn
operator|.
name|ln
operator|=
name|line
expr_stmt|;
name|p
operator|->
name|eqn
operator|.
name|pos
operator|=
name|pos
expr_stmt|;
name|p
operator|->
name|gsize
operator|=
name|EQN_DEFSIZE
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|enum
name|rofferr
name|eqn_end
parameter_list|(
name|struct
name|eqn_node
modifier|*
modifier|*
name|epp
parameter_list|)
block|{
name|struct
name|eqn_node
modifier|*
name|ep
decl_stmt|;
name|struct
name|eqn_box
modifier|*
name|root
decl_stmt|;
name|enum
name|eqn_rest
name|c
decl_stmt|;
name|ep
operator|=
operator|*
name|epp
expr_stmt|;
operator|*
name|epp
operator|=
name|NULL
expr_stmt|;
name|ep
operator|->
name|eqn
operator|.
name|root
operator|=
name|mandoc_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|eqn_box
argument_list|)
argument_list|)
expr_stmt|;
name|root
operator|=
name|ep
operator|->
name|eqn
operator|.
name|root
expr_stmt|;
name|root
operator|->
name|type
operator|=
name|EQN_ROOT
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|ep
operator|->
name|sz
condition|)
return|return
operator|(
name|ROFF_IGN
operator|)
return|;
if|if
condition|(
name|EQN_DESCOPE
operator|==
operator|(
name|c
operator|=
name|eqn_eqn
argument_list|(
name|ep
argument_list|,
name|root
argument_list|)
operator|)
condition|)
block|{
name|EQN_MSG
argument_list|(
name|MANDOCERR_EQNNSCOPE
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|c
operator|=
name|EQN_ERR
expr_stmt|;
block|}
return|return
operator|(
name|EQN_EOF
operator|==
name|c
condition|?
name|ROFF_EQN
else|:
name|ROFF_IGN
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|eqn_rest
name|eqn_eqn
parameter_list|(
name|struct
name|eqn_node
modifier|*
name|ep
parameter_list|,
name|struct
name|eqn_box
modifier|*
name|last
parameter_list|)
block|{
name|struct
name|eqn_box
modifier|*
name|bp
decl_stmt|;
name|enum
name|eqn_rest
name|c
decl_stmt|;
name|bp
operator|=
name|eqn_box_alloc
argument_list|(
name|ep
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|bp
operator|->
name|type
operator|=
name|EQN_SUBEXPR
expr_stmt|;
while|while
condition|(
name|EQN_OK
operator|==
operator|(
name|c
operator|=
name|eqn_box
argument_list|(
name|ep
argument_list|,
name|bp
argument_list|)
operator|)
condition|)
comment|/* Spin! */
empty_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|eqn_rest
name|eqn_matrix
parameter_list|(
name|struct
name|eqn_node
modifier|*
name|ep
parameter_list|,
name|struct
name|eqn_box
modifier|*
name|last
parameter_list|)
block|{
name|struct
name|eqn_box
modifier|*
name|bp
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
name|enum
name|eqn_rest
name|c
decl_stmt|;
name|bp
operator|=
name|eqn_box_alloc
argument_list|(
name|ep
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|bp
operator|->
name|type
operator|=
name|EQN_MATRIX
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|start
operator|=
name|eqn_nexttok
argument_list|(
name|ep
argument_list|,
operator|&
name|sz
argument_list|)
operator|)
condition|)
block|{
name|EQN_MSG
argument_list|(
name|MANDOCERR_EQNEOF
argument_list|,
name|ep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EQN_ERR
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|STRNEQ
argument_list|(
name|start
argument_list|,
name|sz
argument_list|,
literal|"{"
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|EQN_MSG
argument_list|(
name|MANDOCERR_EQNSYNT
argument_list|,
name|ep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EQN_ERR
operator|)
return|;
block|}
while|while
condition|(
name|EQN_OK
operator|==
operator|(
name|c
operator|=
name|eqn_box
argument_list|(
name|ep
argument_list|,
name|bp
argument_list|)
operator|)
condition|)
switch|switch
condition|(
name|bp
operator|->
name|last
operator|->
name|pile
condition|)
block|{
case|case
name|EQNPILE_LCOL
case|:
comment|/* FALLTHROUGH */
case|case
name|EQNPILE_CCOL
case|:
comment|/* FALLTHROUGH */
case|case
name|EQNPILE_RCOL
case|:
continue|continue;
default|default:
name|EQN_MSG
argument_list|(
name|MANDOCERR_EQNSYNT
argument_list|,
name|ep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EQN_ERR
operator|)
return|;
block|}
empty_stmt|;
if|if
condition|(
name|EQN_DESCOPE
operator|!=
name|c
condition|)
block|{
if|if
condition|(
name|EQN_EOF
operator|==
name|c
condition|)
name|EQN_MSG
argument_list|(
name|MANDOCERR_EQNEOF
argument_list|,
name|ep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EQN_ERR
operator|)
return|;
block|}
name|eqn_rewind
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|start
operator|=
name|eqn_nexttok
argument_list|(
name|ep
argument_list|,
operator|&
name|sz
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|STRNEQ
argument_list|(
name|start
argument_list|,
name|sz
argument_list|,
literal|"}"
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
name|EQN_OK
operator|)
return|;
name|EQN_MSG
argument_list|(
name|MANDOCERR_EQNBADSCOPE
argument_list|,
name|ep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EQN_ERR
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|eqn_rest
name|eqn_list
parameter_list|(
name|struct
name|eqn_node
modifier|*
name|ep
parameter_list|,
name|struct
name|eqn_box
modifier|*
name|last
parameter_list|)
block|{
name|struct
name|eqn_box
modifier|*
name|bp
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
name|enum
name|eqn_rest
name|c
decl_stmt|;
name|bp
operator|=
name|eqn_box_alloc
argument_list|(
name|ep
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|bp
operator|->
name|type
operator|=
name|EQN_LIST
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|start
operator|=
name|eqn_nexttok
argument_list|(
name|ep
argument_list|,
operator|&
name|sz
argument_list|)
operator|)
condition|)
block|{
name|EQN_MSG
argument_list|(
name|MANDOCERR_EQNEOF
argument_list|,
name|ep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EQN_ERR
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|STRNEQ
argument_list|(
name|start
argument_list|,
name|sz
argument_list|,
literal|"{"
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|EQN_MSG
argument_list|(
name|MANDOCERR_EQNSYNT
argument_list|,
name|ep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EQN_ERR
operator|)
return|;
block|}
while|while
condition|(
name|EQN_DESCOPE
operator|==
operator|(
name|c
operator|=
name|eqn_eqn
argument_list|(
name|ep
argument_list|,
name|bp
argument_list|)
operator|)
condition|)
block|{
name|eqn_rewind
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|start
operator|=
name|eqn_nexttok
argument_list|(
name|ep
argument_list|,
operator|&
name|sz
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|STRNEQ
argument_list|(
name|start
argument_list|,
name|sz
argument_list|,
literal|"above"
argument_list|,
literal|5
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|EQN_DESCOPE
operator|!=
name|c
condition|)
block|{
if|if
condition|(
name|EQN_ERR
operator|!=
name|c
condition|)
name|EQN_MSG
argument_list|(
name|MANDOCERR_EQNSCOPE
argument_list|,
name|ep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EQN_ERR
operator|)
return|;
block|}
name|eqn_rewind
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|start
operator|=
name|eqn_nexttok
argument_list|(
name|ep
argument_list|,
operator|&
name|sz
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|STRNEQ
argument_list|(
name|start
argument_list|,
name|sz
argument_list|,
literal|"}"
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
name|EQN_OK
operator|)
return|;
name|EQN_MSG
argument_list|(
name|MANDOCERR_EQNBADSCOPE
argument_list|,
name|ep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EQN_ERR
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|eqn_rest
name|eqn_box
parameter_list|(
name|struct
name|eqn_node
modifier|*
name|ep
parameter_list|,
name|struct
name|eqn_box
modifier|*
name|last
parameter_list|)
block|{
name|size_t
name|sz
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
name|char
modifier|*
name|left
decl_stmt|;
name|char
name|sym
index|[
literal|64
index|]
decl_stmt|;
name|enum
name|eqn_rest
name|c
decl_stmt|;
name|int
name|i
decl_stmt|,
name|size
decl_stmt|;
name|struct
name|eqn_box
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|start
operator|=
name|eqn_nexttok
argument_list|(
name|ep
argument_list|,
operator|&
name|sz
argument_list|)
operator|)
condition|)
return|return
operator|(
name|EQN_EOF
operator|)
return|;
if|if
condition|(
name|STRNEQ
argument_list|(
name|start
argument_list|,
name|sz
argument_list|,
literal|"}"
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
name|EQN_DESCOPE
operator|)
return|;
elseif|else
if|if
condition|(
name|STRNEQ
argument_list|(
name|start
argument_list|,
name|sz
argument_list|,
literal|"right"
argument_list|,
literal|5
argument_list|)
condition|)
return|return
operator|(
name|EQN_DESCOPE
operator|)
return|;
elseif|else
if|if
condition|(
name|STRNEQ
argument_list|(
name|start
argument_list|,
name|sz
argument_list|,
literal|"above"
argument_list|,
literal|5
argument_list|)
condition|)
return|return
operator|(
name|EQN_DESCOPE
operator|)
return|;
elseif|else
if|if
condition|(
name|STRNEQ
argument_list|(
name|start
argument_list|,
name|sz
argument_list|,
literal|"mark"
argument_list|,
literal|4
argument_list|)
condition|)
return|return
operator|(
name|EQN_OK
operator|)
return|;
elseif|else
if|if
condition|(
name|STRNEQ
argument_list|(
name|start
argument_list|,
name|sz
argument_list|,
literal|"lineup"
argument_list|,
literal|6
argument_list|)
condition|)
return|return
operator|(
name|EQN_OK
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|EQN__MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|EQNSTREQ
argument_list|(
operator|&
name|eqnparts
index|[
name|i
index|]
operator|.
name|str
argument_list|,
name|start
argument_list|,
name|sz
argument_list|)
condition|)
continue|continue;
return|return
operator|(
operator|(
operator|*
name|eqnparts
index|[
name|i
index|]
operator|.
name|fp
operator|)
operator|(
name|ep
operator|)
condition|?
name|EQN_OK
else|:
name|EQN_ERR
operator|)
return|;
block|}
if|if
condition|(
name|STRNEQ
argument_list|(
name|start
argument_list|,
name|sz
argument_list|,
literal|"{"
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|EQN_DESCOPE
operator|!=
operator|(
name|c
operator|=
name|eqn_eqn
argument_list|(
name|ep
argument_list|,
name|last
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|EQN_ERR
operator|!=
name|c
condition|)
name|EQN_MSG
argument_list|(
name|MANDOCERR_EQNSCOPE
argument_list|,
name|ep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EQN_ERR
operator|)
return|;
block|}
name|eqn_rewind
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|start
operator|=
name|eqn_nexttok
argument_list|(
name|ep
argument_list|,
operator|&
name|sz
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|STRNEQ
argument_list|(
name|start
argument_list|,
name|sz
argument_list|,
literal|"}"
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
name|EQN_OK
operator|)
return|;
name|EQN_MSG
argument_list|(
name|MANDOCERR_EQNBADSCOPE
argument_list|,
name|ep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EQN_ERR
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|EQNPILE__MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|EQNSTREQ
argument_list|(
operator|&
name|eqnpiles
index|[
name|i
index|]
argument_list|,
name|start
argument_list|,
name|sz
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|EQN_OK
operator|==
operator|(
name|c
operator|=
name|eqn_list
argument_list|(
name|ep
argument_list|,
name|last
argument_list|)
operator|)
condition|)
name|last
operator|->
name|last
operator|->
name|pile
operator|=
operator|(
expr|enum
name|eqn_pilet
operator|)
name|i
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
if|if
condition|(
name|STRNEQ
argument_list|(
name|start
argument_list|,
name|sz
argument_list|,
literal|"matrix"
argument_list|,
literal|6
argument_list|)
condition|)
return|return
operator|(
name|eqn_matrix
argument_list|(
name|ep
argument_list|,
name|last
argument_list|)
operator|)
return|;
if|if
condition|(
name|STRNEQ
argument_list|(
name|start
argument_list|,
name|sz
argument_list|,
literal|"left"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
if|if
condition|(
name|NULL
operator|==
operator|(
name|start
operator|=
name|eqn_nexttok
argument_list|(
name|ep
argument_list|,
operator|&
name|sz
argument_list|)
operator|)
condition|)
block|{
name|EQN_MSG
argument_list|(
name|MANDOCERR_EQNEOF
argument_list|,
name|ep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EQN_ERR
operator|)
return|;
block|}
name|left
operator|=
name|mandoc_strndup
argument_list|(
name|start
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|c
operator|=
name|eqn_eqn
argument_list|(
name|ep
argument_list|,
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|->
name|last
condition|)
name|last
operator|->
name|last
operator|->
name|left
operator|=
name|left
expr_stmt|;
else|else
name|free
argument_list|(
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|EQN_DESCOPE
operator|!=
name|c
condition|)
return|return
operator|(
name|c
operator|)
return|;
name|assert
argument_list|(
name|last
operator|->
name|last
argument_list|)
expr_stmt|;
name|eqn_rewind
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|start
operator|=
name|eqn_nexttok
argument_list|(
name|ep
argument_list|,
operator|&
name|sz
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|STRNEQ
argument_list|(
name|start
argument_list|,
name|sz
argument_list|,
literal|"right"
argument_list|,
literal|5
argument_list|)
condition|)
return|return
operator|(
name|EQN_DESCOPE
operator|)
return|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|start
operator|=
name|eqn_nexttok
argument_list|(
name|ep
argument_list|,
operator|&
name|sz
argument_list|)
operator|)
condition|)
block|{
name|EQN_MSG
argument_list|(
name|MANDOCERR_EQNEOF
argument_list|,
name|ep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EQN_ERR
operator|)
return|;
block|}
name|last
operator|->
name|last
operator|->
name|right
operator|=
name|mandoc_strndup
argument_list|(
name|start
argument_list|,
name|sz
argument_list|)
expr_stmt|;
return|return
operator|(
name|EQN_OK
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|EQNPOS__MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|EQNSTREQ
argument_list|(
operator|&
name|eqnposs
index|[
name|i
index|]
argument_list|,
name|start
argument_list|,
name|sz
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|NULL
operator|==
name|last
operator|->
name|last
condition|)
block|{
name|EQN_MSG
argument_list|(
name|MANDOCERR_EQNSYNT
argument_list|,
name|ep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EQN_ERR
operator|)
return|;
block|}
name|last
operator|->
name|last
operator|->
name|pos
operator|=
operator|(
expr|enum
name|eqn_post
operator|)
name|i
expr_stmt|;
if|if
condition|(
name|EQN_EOF
operator|==
operator|(
name|c
operator|=
name|eqn_box
argument_list|(
name|ep
argument_list|,
name|last
argument_list|)
operator|)
condition|)
block|{
name|EQN_MSG
argument_list|(
name|MANDOCERR_EQNEOF
argument_list|,
name|ep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EQN_ERR
operator|)
return|;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|EQNMARK__MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|EQNSTREQ
argument_list|(
operator|&
name|eqnmarks
index|[
name|i
index|]
argument_list|,
name|start
argument_list|,
name|sz
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|NULL
operator|==
name|last
operator|->
name|last
condition|)
block|{
name|EQN_MSG
argument_list|(
name|MANDOCERR_EQNSYNT
argument_list|,
name|ep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EQN_ERR
operator|)
return|;
block|}
name|last
operator|->
name|last
operator|->
name|mark
operator|=
operator|(
expr|enum
name|eqn_markt
operator|)
name|i
expr_stmt|;
if|if
condition|(
name|EQN_EOF
operator|==
operator|(
name|c
operator|=
name|eqn_box
argument_list|(
name|ep
argument_list|,
name|last
argument_list|)
operator|)
condition|)
block|{
name|EQN_MSG
argument_list|(
name|MANDOCERR_EQNEOF
argument_list|,
name|ep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EQN_ERR
operator|)
return|;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|EQNFONT__MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|EQNSTREQ
argument_list|(
operator|&
name|eqnfonts
index|[
name|i
index|]
argument_list|,
name|start
argument_list|,
name|sz
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|EQN_EOF
operator|==
operator|(
name|c
operator|=
name|eqn_box
argument_list|(
name|ep
argument_list|,
name|last
argument_list|)
operator|)
condition|)
block|{
name|EQN_MSG
argument_list|(
name|MANDOCERR_EQNEOF
argument_list|,
name|ep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EQN_ERR
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|EQN_OK
operator|==
name|c
condition|)
name|last
operator|->
name|last
operator|->
name|font
operator|=
operator|(
expr|enum
name|eqn_fontt
operator|)
name|i
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
if|if
condition|(
name|STRNEQ
argument_list|(
name|start
argument_list|,
name|sz
argument_list|,
literal|"size"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
if|if
condition|(
name|NULL
operator|==
operator|(
name|start
operator|=
name|eqn_nexttok
argument_list|(
name|ep
argument_list|,
operator|&
name|sz
argument_list|)
operator|)
condition|)
block|{
name|EQN_MSG
argument_list|(
name|MANDOCERR_EQNEOF
argument_list|,
name|ep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EQN_ERR
operator|)
return|;
block|}
name|size
operator|=
name|mandoc_strntoi
argument_list|(
name|start
argument_list|,
name|sz
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|EQN_EOF
operator|==
operator|(
name|c
operator|=
name|eqn_box
argument_list|(
name|ep
argument_list|,
name|last
argument_list|)
operator|)
condition|)
block|{
name|EQN_MSG
argument_list|(
name|MANDOCERR_EQNEOF
argument_list|,
name|ep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EQN_ERR
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|EQN_OK
operator|!=
name|c
condition|)
return|return
operator|(
name|c
operator|)
return|;
name|last
operator|->
name|last
operator|->
name|size
operator|=
name|size
expr_stmt|;
block|}
name|bp
operator|=
name|eqn_box_alloc
argument_list|(
name|ep
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|bp
operator|->
name|type
operator|=
name|EQN_TEXT
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|EQNSYM__MAX
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|EQNSTREQ
argument_list|(
operator|&
name|eqnsyms
index|[
name|i
index|]
operator|.
name|str
argument_list|,
name|start
argument_list|,
name|sz
argument_list|)
condition|)
block|{
name|sym
index|[
literal|63
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|sym
argument_list|,
literal|62
argument_list|,
literal|"\\[%s]"
argument_list|,
name|eqnsyms
index|[
name|i
index|]
operator|.
name|sym
argument_list|)
expr_stmt|;
name|bp
operator|->
name|text
operator|=
name|mandoc_strdup
argument_list|(
name|sym
argument_list|)
expr_stmt|;
return|return
operator|(
name|EQN_OK
operator|)
return|;
block|}
name|bp
operator|->
name|text
operator|=
name|mandoc_strndup
argument_list|(
name|start
argument_list|,
name|sz
argument_list|)
expr_stmt|;
return|return
operator|(
name|EQN_OK
operator|)
return|;
block|}
end_function

begin_function
name|void
name|eqn_free
parameter_list|(
name|struct
name|eqn_node
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|eqn_box_free
argument_list|(
name|p
operator|->
name|eqn
operator|.
name|root
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|p
operator|->
name|defsz
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|p
operator|->
name|defs
index|[
name|i
index|]
operator|.
name|key
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|defs
index|[
name|i
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|p
operator|->
name|eqn
operator|.
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|defs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|eqn_box
modifier|*
name|eqn_box_alloc
parameter_list|(
name|struct
name|eqn_node
modifier|*
name|ep
parameter_list|,
name|struct
name|eqn_box
modifier|*
name|parent
parameter_list|)
block|{
name|struct
name|eqn_box
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|mandoc_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|eqn_box
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
name|bp
operator|->
name|size
operator|=
name|ep
operator|->
name|gsize
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|parent
operator|->
name|first
condition|)
name|parent
operator|->
name|first
operator|=
name|bp
expr_stmt|;
else|else
name|parent
operator|->
name|last
operator|->
name|next
operator|=
name|bp
expr_stmt|;
name|parent
operator|->
name|last
operator|=
name|bp
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eqn_box_free
parameter_list|(
name|struct
name|eqn_box
modifier|*
name|bp
parameter_list|)
block|{
if|if
condition|(
name|bp
operator|->
name|first
condition|)
name|eqn_box_free
argument_list|(
name|bp
operator|->
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|next
condition|)
name|eqn_box_free
argument_list|(
name|bp
operator|->
name|next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bp
operator|->
name|text
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bp
operator|->
name|left
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bp
operator|->
name|right
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|eqn_nextrawtok
parameter_list|(
name|struct
name|eqn_node
modifier|*
name|ep
parameter_list|,
name|size_t
modifier|*
name|sz
parameter_list|)
block|{
return|return
operator|(
name|eqn_next
argument_list|(
name|ep
argument_list|,
literal|'"'
argument_list|,
name|sz
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|eqn_nexttok
parameter_list|(
name|struct
name|eqn_node
modifier|*
name|ep
parameter_list|,
name|size_t
modifier|*
name|sz
parameter_list|)
block|{
return|return
operator|(
name|eqn_next
argument_list|(
name|ep
argument_list|,
literal|'"'
argument_list|,
name|sz
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eqn_rewind
parameter_list|(
name|struct
name|eqn_node
modifier|*
name|ep
parameter_list|)
block|{
name|ep
operator|->
name|cur
operator|=
name|ep
operator|->
name|rew
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|eqn_next
parameter_list|(
name|struct
name|eqn_node
modifier|*
name|ep
parameter_list|,
name|char
name|quote
parameter_list|,
name|size_t
modifier|*
name|sz
parameter_list|,
name|int
name|repl
parameter_list|)
block|{
name|char
modifier|*
name|start
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|q
decl_stmt|,
name|diff
decl_stmt|,
name|lim
decl_stmt|;
name|size_t
name|ssz
decl_stmt|,
name|dummy
decl_stmt|;
name|struct
name|eqn_def
modifier|*
name|def
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
name|sz
condition|)
name|sz
operator|=
operator|&
name|dummy
expr_stmt|;
name|lim
operator|=
literal|0
expr_stmt|;
name|ep
operator|->
name|rew
operator|=
name|ep
operator|->
name|cur
expr_stmt|;
name|again
label|:
comment|/* Prevent self-definitions. */
if|if
condition|(
name|lim
operator|>=
name|EQN_NEST_MAX
condition|)
block|{
name|EQN_MSG
argument_list|(
name|MANDOCERR_ROFFLOOP
argument_list|,
name|ep
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ep
operator|->
name|cur
operator|=
name|ep
operator|->
name|rew
expr_stmt|;
name|start
operator|=
operator|&
name|ep
operator|->
name|data
index|[
operator|(
name|int
operator|)
name|ep
operator|->
name|cur
index|]
expr_stmt|;
name|q
operator|=
literal|0
expr_stmt|;
if|if
condition|(
literal|'\0'
operator|==
operator|*
name|start
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|quote
operator|==
operator|*
name|start
condition|)
block|{
name|ep
operator|->
name|cur
operator|++
expr_stmt|;
name|q
operator|=
literal|1
expr_stmt|;
block|}
name|start
operator|=
operator|&
name|ep
operator|->
name|data
index|[
operator|(
name|int
operator|)
name|ep
operator|->
name|cur
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|q
condition|)
block|{
if|if
condition|(
literal|'{'
operator|==
operator|*
name|start
operator|||
literal|'}'
operator|==
operator|*
name|start
condition|)
name|ssz
operator|=
literal|1
expr_stmt|;
else|else
name|ssz
operator|=
name|strcspn
argument_list|(
name|start
operator|+
literal|1
argument_list|,
literal|" ^~\"{}\t"
argument_list|)
operator|+
literal|1
expr_stmt|;
name|next
operator|=
name|start
operator|+
operator|(
name|int
operator|)
name|ssz
expr_stmt|;
if|if
condition|(
literal|'\0'
operator|==
operator|*
name|next
condition|)
name|next
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|next
operator|=
name|strchr
argument_list|(
name|start
argument_list|,
name|quote
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|next
condition|)
block|{
operator|*
name|sz
operator|=
call|(
name|size_t
call|)
argument_list|(
name|next
operator|-
name|start
argument_list|)
expr_stmt|;
name|ep
operator|->
name|cur
operator|+=
operator|*
name|sz
expr_stmt|;
if|if
condition|(
name|q
condition|)
name|ep
operator|->
name|cur
operator|++
expr_stmt|;
while|while
condition|(
literal|' '
operator|==
name|ep
operator|->
name|data
index|[
operator|(
name|int
operator|)
name|ep
operator|->
name|cur
index|]
operator|||
literal|'\t'
operator|==
name|ep
operator|->
name|data
index|[
operator|(
name|int
operator|)
name|ep
operator|->
name|cur
index|]
operator|||
literal|'^'
operator|==
name|ep
operator|->
name|data
index|[
operator|(
name|int
operator|)
name|ep
operator|->
name|cur
index|]
operator|||
literal|'~'
operator|==
name|ep
operator|->
name|data
index|[
operator|(
name|int
operator|)
name|ep
operator|->
name|cur
index|]
condition|)
name|ep
operator|->
name|cur
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|q
condition|)
name|EQN_MSG
argument_list|(
name|MANDOCERR_ARG_QUOTE
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|next
operator|=
name|strchr
argument_list|(
name|start
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
operator|*
name|sz
operator|=
call|(
name|size_t
call|)
argument_list|(
name|next
operator|-
name|start
argument_list|)
expr_stmt|;
name|ep
operator|->
name|cur
operator|+=
operator|*
name|sz
expr_stmt|;
block|}
comment|/* Quotes aren't expanded for values. */
if|if
condition|(
name|q
operator|||
operator|!
name|repl
condition|)
return|return
operator|(
name|start
operator|)
return|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|def
operator|=
name|eqn_def_find
argument_list|(
name|ep
argument_list|,
name|start
argument_list|,
operator|*
name|sz
argument_list|)
operator|)
condition|)
block|{
name|diff
operator|=
name|def
operator|->
name|valsz
operator|-
operator|*
name|sz
expr_stmt|;
if|if
condition|(
name|def
operator|->
name|valsz
operator|>
operator|*
name|sz
condition|)
block|{
name|ep
operator|->
name|sz
operator|+=
name|diff
expr_stmt|;
name|ep
operator|->
name|data
operator|=
name|mandoc_realloc
argument_list|(
name|ep
operator|->
name|data
argument_list|,
name|ep
operator|->
name|sz
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ep
operator|->
name|data
index|[
name|ep
operator|->
name|sz
index|]
operator|=
literal|'\0'
expr_stmt|;
name|start
operator|=
operator|&
name|ep
operator|->
name|data
index|[
operator|(
name|int
operator|)
name|ep
operator|->
name|rew
index|]
expr_stmt|;
block|}
name|diff
operator|=
name|def
operator|->
name|valsz
operator|-
operator|*
name|sz
expr_stmt|;
name|memmove
argument_list|(
name|start
operator|+
operator|*
name|sz
operator|+
name|diff
argument_list|,
name|start
operator|+
operator|*
name|sz
argument_list|,
operator|(
name|strlen
argument_list|(
name|start
argument_list|)
operator|-
operator|*
name|sz
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|start
argument_list|,
name|def
operator|->
name|val
argument_list|,
name|def
operator|->
name|valsz
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
return|return
operator|(
name|start
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|eqn_do_ign1
parameter_list|(
name|struct
name|eqn_node
modifier|*
name|ep
parameter_list|)
block|{
if|if
condition|(
name|NULL
operator|==
name|eqn_nextrawtok
argument_list|(
name|ep
argument_list|,
name|NULL
argument_list|)
condition|)
name|EQN_MSG
argument_list|(
name|MANDOCERR_EQNEOF
argument_list|,
name|ep
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|eqn_do_ign2
parameter_list|(
name|struct
name|eqn_node
modifier|*
name|ep
parameter_list|)
block|{
if|if
condition|(
name|NULL
operator|==
name|eqn_nextrawtok
argument_list|(
name|ep
argument_list|,
name|NULL
argument_list|)
condition|)
name|EQN_MSG
argument_list|(
name|MANDOCERR_EQNEOF
argument_list|,
name|ep
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|NULL
operator|==
name|eqn_nextrawtok
argument_list|(
name|ep
argument_list|,
name|NULL
argument_list|)
condition|)
name|EQN_MSG
argument_list|(
name|MANDOCERR_EQNEOF
argument_list|,
name|ep
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|eqn_do_tdefine
parameter_list|(
name|struct
name|eqn_node
modifier|*
name|ep
parameter_list|)
block|{
if|if
condition|(
name|NULL
operator|==
name|eqn_nextrawtok
argument_list|(
name|ep
argument_list|,
name|NULL
argument_list|)
condition|)
name|EQN_MSG
argument_list|(
name|MANDOCERR_EQNEOF
argument_list|,
name|ep
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|NULL
operator|==
name|eqn_next
argument_list|(
name|ep
argument_list|,
name|ep
operator|->
name|data
index|[
operator|(
name|int
operator|)
name|ep
operator|->
name|cur
index|]
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
name|EQN_MSG
argument_list|(
name|MANDOCERR_EQNEOF
argument_list|,
name|ep
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|eqn_do_define
parameter_list|(
name|struct
name|eqn_node
modifier|*
name|ep
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
name|struct
name|eqn_def
modifier|*
name|def
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|start
operator|=
name|eqn_nextrawtok
argument_list|(
name|ep
argument_list|,
operator|&
name|sz
argument_list|)
operator|)
condition|)
block|{
name|EQN_MSG
argument_list|(
name|MANDOCERR_EQNEOF
argument_list|,
name|ep
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Search for a key that already exists. 	 * Create a new key if none is found. 	 */
if|if
condition|(
name|NULL
operator|==
operator|(
name|def
operator|=
name|eqn_def_find
argument_list|(
name|ep
argument_list|,
name|start
argument_list|,
name|sz
argument_list|)
operator|)
condition|)
block|{
comment|/* Find holes in string array. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|ep
operator|->
name|defsz
condition|;
name|i
operator|++
control|)
if|if
condition|(
literal|0
operator|==
name|ep
operator|->
name|defs
index|[
name|i
index|]
operator|.
name|keysz
condition|)
break|break;
if|if
condition|(
name|i
operator|==
operator|(
name|int
operator|)
name|ep
operator|->
name|defsz
condition|)
block|{
name|ep
operator|->
name|defsz
operator|++
expr_stmt|;
name|ep
operator|->
name|defs
operator|=
name|mandoc_reallocarray
argument_list|(
name|ep
operator|->
name|defs
argument_list|,
name|ep
operator|->
name|defsz
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|eqn_def
argument_list|)
argument_list|)
expr_stmt|;
name|ep
operator|->
name|defs
index|[
name|i
index|]
operator|.
name|key
operator|=
name|ep
operator|->
name|defs
index|[
name|i
index|]
operator|.
name|val
operator|=
name|NULL
expr_stmt|;
block|}
name|ep
operator|->
name|defs
index|[
name|i
index|]
operator|.
name|keysz
operator|=
name|sz
expr_stmt|;
name|ep
operator|->
name|defs
index|[
name|i
index|]
operator|.
name|key
operator|=
name|mandoc_realloc
argument_list|(
name|ep
operator|->
name|defs
index|[
name|i
index|]
operator|.
name|key
argument_list|,
name|sz
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ep
operator|->
name|defs
index|[
name|i
index|]
operator|.
name|key
argument_list|,
name|start
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|ep
operator|->
name|defs
index|[
name|i
index|]
operator|.
name|key
index|[
operator|(
name|int
operator|)
name|sz
index|]
operator|=
literal|'\0'
expr_stmt|;
name|def
operator|=
operator|&
name|ep
operator|->
name|defs
index|[
name|i
index|]
expr_stmt|;
block|}
name|start
operator|=
name|eqn_next
argument_list|(
name|ep
argument_list|,
name|ep
operator|->
name|data
index|[
operator|(
name|int
operator|)
name|ep
operator|->
name|cur
index|]
argument_list|,
operator|&
name|sz
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|start
condition|)
block|{
name|EQN_MSG
argument_list|(
name|MANDOCERR_EQNEOF
argument_list|,
name|ep
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|def
operator|->
name|valsz
operator|=
name|sz
expr_stmt|;
name|def
operator|->
name|val
operator|=
name|mandoc_realloc
argument_list|(
name|def
operator|->
name|val
argument_list|,
name|sz
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|def
operator|->
name|val
argument_list|,
name|start
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|def
operator|->
name|val
index|[
operator|(
name|int
operator|)
name|sz
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|eqn_do_gfont
parameter_list|(
name|struct
name|eqn_node
modifier|*
name|ep
parameter_list|)
block|{
if|if
condition|(
name|NULL
operator|==
name|eqn_nextrawtok
argument_list|(
name|ep
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|EQN_MSG
argument_list|(
name|MANDOCERR_EQNEOF
argument_list|,
name|ep
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|eqn_do_gsize
parameter_list|(
name|struct
name|eqn_node
modifier|*
name|ep
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|start
operator|=
name|eqn_nextrawtok
argument_list|(
name|ep
argument_list|,
operator|&
name|sz
argument_list|)
operator|)
condition|)
block|{
name|EQN_MSG
argument_list|(
name|MANDOCERR_EQNEOF
argument_list|,
name|ep
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ep
operator|->
name|gsize
operator|=
name|mandoc_strntoi
argument_list|(
name|start
argument_list|,
name|sz
argument_list|,
literal|10
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|eqn_do_undef
parameter_list|(
name|struct
name|eqn_node
modifier|*
name|ep
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
name|struct
name|eqn_def
modifier|*
name|def
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|start
operator|=
name|eqn_nextrawtok
argument_list|(
name|ep
argument_list|,
operator|&
name|sz
argument_list|)
operator|)
condition|)
block|{
name|EQN_MSG
argument_list|(
name|MANDOCERR_EQNEOF
argument_list|,
name|ep
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|NULL
operator|!=
operator|(
name|def
operator|=
name|eqn_def_find
argument_list|(
name|ep
argument_list|,
name|start
argument_list|,
name|sz
argument_list|)
operator|)
condition|)
name|def
operator|->
name|keysz
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|eqn_def
modifier|*
name|eqn_def_find
parameter_list|(
name|struct
name|eqn_node
modifier|*
name|ep
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|size_t
name|sz
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|ep
operator|->
name|defsz
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|defs
index|[
name|i
index|]
operator|.
name|keysz
operator|&&
name|STRNEQ
argument_list|(
name|ep
operator|->
name|defs
index|[
name|i
index|]
operator|.
name|key
argument_list|,
name|ep
operator|->
name|defs
index|[
name|i
index|]
operator|.
name|keysz
argument_list|,
name|key
argument_list|,
name|sz
argument_list|)
condition|)
return|return
operator|(
operator|&
name|ep
operator|->
name|defs
index|[
name|i
index|]
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

end_unit

