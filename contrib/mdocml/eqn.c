begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$Id: eqn.c,v 1.62 2017/03/11 15:43:04 schwarze Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2011, 2014 Kristaps Dzonsons<kristaps@bsd.lv>  * Copyright (c) 2014, 2015 Ingo Schwarze<schwarze@openbsd.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|"mandoc.h"
end_include

begin_include
include|#
directive|include
file|"mandoc_aux.h"
end_include

begin_include
include|#
directive|include
file|"libmandoc.h"
end_include

begin_include
include|#
directive|include
file|"libroff.h"
end_include

begin_define
define|#
directive|define
name|EQN_NEST_MAX
value|128
end_define

begin_comment
comment|/* maximum nesting of defines */
end_comment

begin_define
define|#
directive|define
name|STRNEQ
parameter_list|(
name|p1
parameter_list|,
name|sz1
parameter_list|,
name|p2
parameter_list|,
name|sz2
parameter_list|)
define|\
value|((sz1) == (sz2)&& 0 == strncmp((p1), (p2), (sz1)))
end_define

begin_enum
enum|enum
name|eqn_tok
block|{
name|EQN_TOK_DYAD
init|=
literal|0
block|,
name|EQN_TOK_VEC
block|,
name|EQN_TOK_UNDER
block|,
name|EQN_TOK_BAR
block|,
name|EQN_TOK_TILDE
block|,
name|EQN_TOK_HAT
block|,
name|EQN_TOK_DOT
block|,
name|EQN_TOK_DOTDOT
block|,
name|EQN_TOK_FWD
block|,
name|EQN_TOK_BACK
block|,
name|EQN_TOK_DOWN
block|,
name|EQN_TOK_UP
block|,
name|EQN_TOK_FAT
block|,
name|EQN_TOK_ROMAN
block|,
name|EQN_TOK_ITALIC
block|,
name|EQN_TOK_BOLD
block|,
name|EQN_TOK_SIZE
block|,
name|EQN_TOK_SUB
block|,
name|EQN_TOK_SUP
block|,
name|EQN_TOK_SQRT
block|,
name|EQN_TOK_OVER
block|,
name|EQN_TOK_FROM
block|,
name|EQN_TOK_TO
block|,
name|EQN_TOK_BRACE_OPEN
block|,
name|EQN_TOK_BRACE_CLOSE
block|,
name|EQN_TOK_GSIZE
block|,
name|EQN_TOK_GFONT
block|,
name|EQN_TOK_MARK
block|,
name|EQN_TOK_LINEUP
block|,
name|EQN_TOK_LEFT
block|,
name|EQN_TOK_RIGHT
block|,
name|EQN_TOK_PILE
block|,
name|EQN_TOK_LPILE
block|,
name|EQN_TOK_RPILE
block|,
name|EQN_TOK_CPILE
block|,
name|EQN_TOK_MATRIX
block|,
name|EQN_TOK_CCOL
block|,
name|EQN_TOK_LCOL
block|,
name|EQN_TOK_RCOL
block|,
name|EQN_TOK_DELIM
block|,
name|EQN_TOK_DEFINE
block|,
name|EQN_TOK_TDEFINE
block|,
name|EQN_TOK_NDEFINE
block|,
name|EQN_TOK_UNDEF
block|,
name|EQN_TOK_EOF
block|,
name|EQN_TOK_ABOVE
block|,
name|EQN_TOK__MAX
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|eqn_toks
index|[
name|EQN_TOK__MAX
index|]
init|=
block|{
literal|"dyad"
block|,
comment|/* EQN_TOK_DYAD */
literal|"vec"
block|,
comment|/* EQN_TOK_VEC */
literal|"under"
block|,
comment|/* EQN_TOK_UNDER */
literal|"bar"
block|,
comment|/* EQN_TOK_BAR */
literal|"tilde"
block|,
comment|/* EQN_TOK_TILDE */
literal|"hat"
block|,
comment|/* EQN_TOK_HAT */
literal|"dot"
block|,
comment|/* EQN_TOK_DOT */
literal|"dotdot"
block|,
comment|/* EQN_TOK_DOTDOT */
literal|"fwd"
block|,
comment|/* EQN_TOK_FWD * */
literal|"back"
block|,
comment|/* EQN_TOK_BACK */
literal|"down"
block|,
comment|/* EQN_TOK_DOWN */
literal|"up"
block|,
comment|/* EQN_TOK_UP */
literal|"fat"
block|,
comment|/* EQN_TOK_FAT */
literal|"roman"
block|,
comment|/* EQN_TOK_ROMAN */
literal|"italic"
block|,
comment|/* EQN_TOK_ITALIC */
literal|"bold"
block|,
comment|/* EQN_TOK_BOLD */
literal|"size"
block|,
comment|/* EQN_TOK_SIZE */
literal|"sub"
block|,
comment|/* EQN_TOK_SUB */
literal|"sup"
block|,
comment|/* EQN_TOK_SUP */
literal|"sqrt"
block|,
comment|/* EQN_TOK_SQRT */
literal|"over"
block|,
comment|/* EQN_TOK_OVER */
literal|"from"
block|,
comment|/* EQN_TOK_FROM */
literal|"to"
block|,
comment|/* EQN_TOK_TO */
literal|"{"
block|,
comment|/* EQN_TOK_BRACE_OPEN */
literal|"}"
block|,
comment|/* EQN_TOK_BRACE_CLOSE */
literal|"gsize"
block|,
comment|/* EQN_TOK_GSIZE */
literal|"gfont"
block|,
comment|/* EQN_TOK_GFONT */
literal|"mark"
block|,
comment|/* EQN_TOK_MARK */
literal|"lineup"
block|,
comment|/* EQN_TOK_LINEUP */
literal|"left"
block|,
comment|/* EQN_TOK_LEFT */
literal|"right"
block|,
comment|/* EQN_TOK_RIGHT */
literal|"pile"
block|,
comment|/* EQN_TOK_PILE */
literal|"lpile"
block|,
comment|/* EQN_TOK_LPILE */
literal|"rpile"
block|,
comment|/* EQN_TOK_RPILE */
literal|"cpile"
block|,
comment|/* EQN_TOK_CPILE */
literal|"matrix"
block|,
comment|/* EQN_TOK_MATRIX */
literal|"ccol"
block|,
comment|/* EQN_TOK_CCOL */
literal|"lcol"
block|,
comment|/* EQN_TOK_LCOL */
literal|"rcol"
block|,
comment|/* EQN_TOK_RCOL */
literal|"delim"
block|,
comment|/* EQN_TOK_DELIM */
literal|"define"
block|,
comment|/* EQN_TOK_DEFINE */
literal|"tdefine"
block|,
comment|/* EQN_TOK_TDEFINE */
literal|"ndefine"
block|,
comment|/* EQN_TOK_NDEFINE */
literal|"undef"
block|,
comment|/* EQN_TOK_UNDEF */
name|NULL
block|,
comment|/* EQN_TOK_EOF */
literal|"above"
block|,
comment|/* EQN_TOK_ABOVE */
block|}
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|eqn_symt
block|{
name|EQNSYM_alpha
block|,
name|EQNSYM_beta
block|,
name|EQNSYM_chi
block|,
name|EQNSYM_delta
block|,
name|EQNSYM_epsilon
block|,
name|EQNSYM_eta
block|,
name|EQNSYM_gamma
block|,
name|EQNSYM_iota
block|,
name|EQNSYM_kappa
block|,
name|EQNSYM_lambda
block|,
name|EQNSYM_mu
block|,
name|EQNSYM_nu
block|,
name|EQNSYM_omega
block|,
name|EQNSYM_omicron
block|,
name|EQNSYM_phi
block|,
name|EQNSYM_pi
block|,
name|EQNSYM_ps
block|,
name|EQNSYM_rho
block|,
name|EQNSYM_sigma
block|,
name|EQNSYM_tau
block|,
name|EQNSYM_theta
block|,
name|EQNSYM_upsilon
block|,
name|EQNSYM_xi
block|,
name|EQNSYM_zeta
block|,
name|EQNSYM_DELTA
block|,
name|EQNSYM_GAMMA
block|,
name|EQNSYM_LAMBDA
block|,
name|EQNSYM_OMEGA
block|,
name|EQNSYM_PHI
block|,
name|EQNSYM_PI
block|,
name|EQNSYM_PSI
block|,
name|EQNSYM_SIGMA
block|,
name|EQNSYM_THETA
block|,
name|EQNSYM_UPSILON
block|,
name|EQNSYM_XI
block|,
name|EQNSYM_inter
block|,
name|EQNSYM_union
block|,
name|EQNSYM_prod
block|,
name|EQNSYM_int
block|,
name|EQNSYM_sum
block|,
name|EQNSYM_grad
block|,
name|EQNSYM_del
block|,
name|EQNSYM_times
block|,
name|EQNSYM_cdot
block|,
name|EQNSYM_nothing
block|,
name|EQNSYM_approx
block|,
name|EQNSYM_prime
block|,
name|EQNSYM_half
block|,
name|EQNSYM_partial
block|,
name|EQNSYM_inf
block|,
name|EQNSYM_muchgreat
block|,
name|EQNSYM_muchless
block|,
name|EQNSYM_larrow
block|,
name|EQNSYM_rarrow
block|,
name|EQNSYM_pm
block|,
name|EQNSYM_nequal
block|,
name|EQNSYM_equiv
block|,
name|EQNSYM_lessequal
block|,
name|EQNSYM_moreequal
block|,
name|EQNSYM_minus
block|,
name|EQNSYM__MAX
block|}
enum|;
end_enum

begin_struct
struct|struct
name|eqnsym
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
specifier|const
name|char
modifier|*
name|sym
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|eqnsym
name|eqnsyms
index|[
name|EQNSYM__MAX
index|]
init|=
block|{
block|{
literal|"alpha"
block|,
literal|"*a"
block|}
block|,
comment|/* EQNSYM_alpha */
block|{
literal|"beta"
block|,
literal|"*b"
block|}
block|,
comment|/* EQNSYM_beta */
block|{
literal|"chi"
block|,
literal|"*x"
block|}
block|,
comment|/* EQNSYM_chi */
block|{
literal|"delta"
block|,
literal|"*d"
block|}
block|,
comment|/* EQNSYM_delta */
block|{
literal|"epsilon"
block|,
literal|"*e"
block|}
block|,
comment|/* EQNSYM_epsilon */
block|{
literal|"eta"
block|,
literal|"*y"
block|}
block|,
comment|/* EQNSYM_eta */
block|{
literal|"gamma"
block|,
literal|"*g"
block|}
block|,
comment|/* EQNSYM_gamma */
block|{
literal|"iota"
block|,
literal|"*i"
block|}
block|,
comment|/* EQNSYM_iota */
block|{
literal|"kappa"
block|,
literal|"*k"
block|}
block|,
comment|/* EQNSYM_kappa */
block|{
literal|"lambda"
block|,
literal|"*l"
block|}
block|,
comment|/* EQNSYM_lambda */
block|{
literal|"mu"
block|,
literal|"*m"
block|}
block|,
comment|/* EQNSYM_mu */
block|{
literal|"nu"
block|,
literal|"*n"
block|}
block|,
comment|/* EQNSYM_nu */
block|{
literal|"omega"
block|,
literal|"*w"
block|}
block|,
comment|/* EQNSYM_omega */
block|{
literal|"omicron"
block|,
literal|"*o"
block|}
block|,
comment|/* EQNSYM_omicron */
block|{
literal|"phi"
block|,
literal|"*f"
block|}
block|,
comment|/* EQNSYM_phi */
block|{
literal|"pi"
block|,
literal|"*p"
block|}
block|,
comment|/* EQNSYM_pi */
block|{
literal|"psi"
block|,
literal|"*q"
block|}
block|,
comment|/* EQNSYM_psi */
block|{
literal|"rho"
block|,
literal|"*r"
block|}
block|,
comment|/* EQNSYM_rho */
block|{
literal|"sigma"
block|,
literal|"*s"
block|}
block|,
comment|/* EQNSYM_sigma */
block|{
literal|"tau"
block|,
literal|"*t"
block|}
block|,
comment|/* EQNSYM_tau */
block|{
literal|"theta"
block|,
literal|"*h"
block|}
block|,
comment|/* EQNSYM_theta */
block|{
literal|"upsilon"
block|,
literal|"*u"
block|}
block|,
comment|/* EQNSYM_upsilon */
block|{
literal|"xi"
block|,
literal|"*c"
block|}
block|,
comment|/* EQNSYM_xi */
block|{
literal|"zeta"
block|,
literal|"*z"
block|}
block|,
comment|/* EQNSYM_zeta */
block|{
literal|"DELTA"
block|,
literal|"*D"
block|}
block|,
comment|/* EQNSYM_DELTA */
block|{
literal|"GAMMA"
block|,
literal|"*G"
block|}
block|,
comment|/* EQNSYM_GAMMA */
block|{
literal|"LAMBDA"
block|,
literal|"*L"
block|}
block|,
comment|/* EQNSYM_LAMBDA */
block|{
literal|"OMEGA"
block|,
literal|"*W"
block|}
block|,
comment|/* EQNSYM_OMEGA */
block|{
literal|"PHI"
block|,
literal|"*F"
block|}
block|,
comment|/* EQNSYM_PHI */
block|{
literal|"PI"
block|,
literal|"*P"
block|}
block|,
comment|/* EQNSYM_PI */
block|{
literal|"PSI"
block|,
literal|"*Q"
block|}
block|,
comment|/* EQNSYM_PSI */
block|{
literal|"SIGMA"
block|,
literal|"*S"
block|}
block|,
comment|/* EQNSYM_SIGMA */
block|{
literal|"THETA"
block|,
literal|"*H"
block|}
block|,
comment|/* EQNSYM_THETA */
block|{
literal|"UPSILON"
block|,
literal|"*U"
block|}
block|,
comment|/* EQNSYM_UPSILON */
block|{
literal|"XI"
block|,
literal|"*C"
block|}
block|,
comment|/* EQNSYM_XI */
block|{
literal|"inter"
block|,
literal|"ca"
block|}
block|,
comment|/* EQNSYM_inter */
block|{
literal|"union"
block|,
literal|"cu"
block|}
block|,
comment|/* EQNSYM_union */
block|{
literal|"prod"
block|,
literal|"product"
block|}
block|,
comment|/* EQNSYM_prod */
block|{
literal|"int"
block|,
literal|"integral"
block|}
block|,
comment|/* EQNSYM_int */
block|{
literal|"sum"
block|,
literal|"sum"
block|}
block|,
comment|/* EQNSYM_sum */
block|{
literal|"grad"
block|,
literal|"gr"
block|}
block|,
comment|/* EQNSYM_grad */
block|{
literal|"del"
block|,
literal|"gr"
block|}
block|,
comment|/* EQNSYM_del */
block|{
literal|"times"
block|,
literal|"mu"
block|}
block|,
comment|/* EQNSYM_times */
block|{
literal|"cdot"
block|,
literal|"pc"
block|}
block|,
comment|/* EQNSYM_cdot */
block|{
literal|"nothing"
block|,
literal|"&"
block|}
block|,
comment|/* EQNSYM_nothing */
block|{
literal|"approx"
block|,
literal|"~~"
block|}
block|,
comment|/* EQNSYM_approx */
block|{
literal|"prime"
block|,
literal|"fm"
block|}
block|,
comment|/* EQNSYM_prime */
block|{
literal|"half"
block|,
literal|"12"
block|}
block|,
comment|/* EQNSYM_half */
block|{
literal|"partial"
block|,
literal|"pd"
block|}
block|,
comment|/* EQNSYM_partial */
block|{
literal|"inf"
block|,
literal|"if"
block|}
block|,
comment|/* EQNSYM_inf */
block|{
literal|">>"
block|,
literal|">>"
block|}
block|,
comment|/* EQNSYM_muchgreat */
block|{
literal|"<<"
block|,
literal|"<<"
block|}
block|,
comment|/* EQNSYM_muchless */
block|{
literal|"<-"
block|,
literal|"<-"
block|}
block|,
comment|/* EQNSYM_larrow */
block|{
literal|"->"
block|,
literal|"->"
block|}
block|,
comment|/* EQNSYM_rarrow */
block|{
literal|"+-"
block|,
literal|"+-"
block|}
block|,
comment|/* EQNSYM_pm */
block|{
literal|"!="
block|,
literal|"!="
block|}
block|,
comment|/* EQNSYM_nequal */
block|{
literal|"=="
block|,
literal|"=="
block|}
block|,
comment|/* EQNSYM_equiv */
block|{
literal|"<="
block|,
literal|"<="
block|}
block|,
comment|/* EQNSYM_lessequal */
block|{
literal|">="
block|,
literal|">="
block|}
block|,
comment|/* EQNSYM_moreequal */
block|{
literal|"-"
block|,
literal|"mi"
block|}
block|,
comment|/* EQNSYM_minus */
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|struct
name|eqn_box
modifier|*
name|eqn_box_alloc
parameter_list|(
name|struct
name|eqn_node
modifier|*
parameter_list|,
name|struct
name|eqn_box
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eqn_box_free
parameter_list|(
name|struct
name|eqn_box
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|eqn_box
modifier|*
name|eqn_box_makebinary
parameter_list|(
name|struct
name|eqn_node
modifier|*
parameter_list|,
name|enum
name|eqn_post
parameter_list|,
name|struct
name|eqn_box
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eqn_def
parameter_list|(
name|struct
name|eqn_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|eqn_def
modifier|*
name|eqn_def_find
parameter_list|(
name|struct
name|eqn_node
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eqn_delim
parameter_list|(
name|struct
name|eqn_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|eqn_next
parameter_list|(
name|struct
name|eqn_node
modifier|*
parameter_list|,
name|char
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|eqn_nextrawtok
parameter_list|(
name|struct
name|eqn_node
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|eqn_nexttok
parameter_list|(
name|struct
name|eqn_node
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rofferr
name|eqn_parse
parameter_list|(
name|struct
name|eqn_node
modifier|*
parameter_list|,
name|struct
name|eqn_box
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|eqn_tok
name|eqn_tok_parse
parameter_list|(
name|struct
name|eqn_node
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eqn_undef
parameter_list|(
name|struct
name|eqn_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|enum
name|rofferr
name|eqn_read
parameter_list|(
name|struct
name|eqn_node
modifier|*
modifier|*
name|epp
parameter_list|,
name|int
name|ln
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|int
name|pos
parameter_list|,
name|int
modifier|*
name|offs
parameter_list|)
block|{
name|size_t
name|sz
decl_stmt|;
name|struct
name|eqn_node
modifier|*
name|ep
decl_stmt|;
name|enum
name|rofferr
name|er
decl_stmt|;
name|ep
operator|=
operator|*
name|epp
expr_stmt|;
comment|/* 	 * If we're the terminating mark, unset our equation status and 	 * validate the full equation. 	 */
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|p
argument_list|,
literal|".EN"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|er
operator|=
name|eqn_end
argument_list|(
name|epp
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|3
expr_stmt|;
while|while
condition|(
literal|' '
operator|==
operator|*
name|p
operator|||
literal|'\t'
operator|==
operator|*
name|p
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
literal|'\0'
operator|==
operator|*
name|p
condition|)
return|return
name|er
return|;
name|mandoc_vmsg
argument_list|(
name|MANDOCERR_ARG_SKIP
argument_list|,
name|ep
operator|->
name|parse
argument_list|,
name|ln
argument_list|,
name|pos
argument_list|,
literal|"EN %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|er
return|;
block|}
comment|/* 	 * Build up the full string, replacing all newlines with regular 	 * whitespace. 	 */
name|sz
operator|=
name|strlen
argument_list|(
name|p
operator|+
name|pos
argument_list|)
operator|+
literal|1
expr_stmt|;
name|ep
operator|->
name|data
operator|=
name|mandoc_realloc
argument_list|(
name|ep
operator|->
name|data
argument_list|,
name|ep
operator|->
name|sz
operator|+
name|sz
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* First invocation: nil terminate the string. */
if|if
condition|(
literal|0
operator|==
name|ep
operator|->
name|sz
condition|)
operator|*
name|ep
operator|->
name|data
operator|=
literal|'\0'
expr_stmt|;
name|ep
operator|->
name|sz
operator|+=
name|sz
expr_stmt|;
name|strlcat
argument_list|(
name|ep
operator|->
name|data
argument_list|,
name|p
operator|+
name|pos
argument_list|,
name|ep
operator|->
name|sz
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|ep
operator|->
name|data
argument_list|,
literal|" "
argument_list|,
name|ep
operator|->
name|sz
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|ROFF_IGN
return|;
block|}
end_function

begin_function
name|struct
name|eqn_node
modifier|*
name|eqn_alloc
parameter_list|(
name|int
name|pos
parameter_list|,
name|int
name|line
parameter_list|,
name|struct
name|mparse
modifier|*
name|parse
parameter_list|)
block|{
name|struct
name|eqn_node
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|mandoc_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|eqn_node
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|parse
operator|=
name|parse
expr_stmt|;
name|p
operator|->
name|eqn
operator|.
name|ln
operator|=
name|line
expr_stmt|;
name|p
operator|->
name|eqn
operator|.
name|pos
operator|=
name|pos
expr_stmt|;
name|p
operator|->
name|gsize
operator|=
name|EQN_DEFSIZE
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/*  * Find the key "key" of the give size within our eqn-defined values.  */
end_comment

begin_function
specifier|static
name|struct
name|eqn_def
modifier|*
name|eqn_def_find
parameter_list|(
name|struct
name|eqn_node
modifier|*
name|ep
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|size_t
name|sz
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|ep
operator|->
name|defsz
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|defs
index|[
name|i
index|]
operator|.
name|keysz
operator|&&
name|STRNEQ
argument_list|(
name|ep
operator|->
name|defs
index|[
name|i
index|]
operator|.
name|key
argument_list|,
name|ep
operator|->
name|defs
index|[
name|i
index|]
operator|.
name|keysz
argument_list|,
name|key
argument_list|,
name|sz
argument_list|)
condition|)
return|return
operator|&
name|ep
operator|->
name|defs
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Get the next token from the input stream using the given quote  * character.  * Optionally make any replacements.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|eqn_next
parameter_list|(
name|struct
name|eqn_node
modifier|*
name|ep
parameter_list|,
name|char
name|quote
parameter_list|,
name|size_t
modifier|*
name|sz
parameter_list|,
name|int
name|repl
parameter_list|)
block|{
specifier|static
name|size_t
name|last_len
decl_stmt|;
specifier|static
name|int
name|lim
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|q
decl_stmt|,
name|diff
decl_stmt|;
name|size_t
name|ssz
decl_stmt|,
name|dummy
decl_stmt|;
name|struct
name|eqn_def
modifier|*
name|def
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
name|sz
condition|)
name|sz
operator|=
operator|&
name|dummy
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|cur
operator|>=
name|last_len
condition|)
name|lim
operator|=
literal|0
expr_stmt|;
name|ep
operator|->
name|rew
operator|=
name|ep
operator|->
name|cur
expr_stmt|;
name|again
label|:
comment|/* Prevent self-definitions. */
if|if
condition|(
name|lim
operator|>=
name|EQN_NEST_MAX
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_ROFFLOOP
argument_list|,
name|ep
operator|->
name|parse
argument_list|,
name|ep
operator|->
name|eqn
operator|.
name|ln
argument_list|,
name|ep
operator|->
name|eqn
operator|.
name|pos
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ep
operator|->
name|cur
operator|=
name|ep
operator|->
name|rew
expr_stmt|;
name|start
operator|=
operator|&
name|ep
operator|->
name|data
index|[
operator|(
name|int
operator|)
name|ep
operator|->
name|cur
index|]
expr_stmt|;
name|q
operator|=
literal|0
expr_stmt|;
if|if
condition|(
literal|'\0'
operator|==
operator|*
name|start
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|quote
operator|==
operator|*
name|start
condition|)
block|{
name|ep
operator|->
name|cur
operator|++
expr_stmt|;
name|q
operator|=
literal|1
expr_stmt|;
block|}
name|start
operator|=
operator|&
name|ep
operator|->
name|data
index|[
operator|(
name|int
operator|)
name|ep
operator|->
name|cur
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|q
condition|)
block|{
if|if
condition|(
literal|'{'
operator|==
operator|*
name|start
operator|||
literal|'}'
operator|==
operator|*
name|start
condition|)
name|ssz
operator|=
literal|1
expr_stmt|;
else|else
name|ssz
operator|=
name|strcspn
argument_list|(
name|start
operator|+
literal|1
argument_list|,
literal|" ^~\"{}\t"
argument_list|)
operator|+
literal|1
expr_stmt|;
name|next
operator|=
name|start
operator|+
operator|(
name|int
operator|)
name|ssz
expr_stmt|;
if|if
condition|(
literal|'\0'
operator|==
operator|*
name|next
condition|)
name|next
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|next
operator|=
name|strchr
argument_list|(
name|start
argument_list|,
name|quote
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|next
condition|)
block|{
operator|*
name|sz
operator|=
call|(
name|size_t
call|)
argument_list|(
name|next
operator|-
name|start
argument_list|)
expr_stmt|;
name|ep
operator|->
name|cur
operator|+=
operator|*
name|sz
expr_stmt|;
if|if
condition|(
name|q
condition|)
name|ep
operator|->
name|cur
operator|++
expr_stmt|;
while|while
condition|(
literal|' '
operator|==
name|ep
operator|->
name|data
index|[
operator|(
name|int
operator|)
name|ep
operator|->
name|cur
index|]
operator|||
literal|'\t'
operator|==
name|ep
operator|->
name|data
index|[
operator|(
name|int
operator|)
name|ep
operator|->
name|cur
index|]
operator|||
literal|'^'
operator|==
name|ep
operator|->
name|data
index|[
operator|(
name|int
operator|)
name|ep
operator|->
name|cur
index|]
operator|||
literal|'~'
operator|==
name|ep
operator|->
name|data
index|[
operator|(
name|int
operator|)
name|ep
operator|->
name|cur
index|]
condition|)
name|ep
operator|->
name|cur
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|q
condition|)
name|mandoc_msg
argument_list|(
name|MANDOCERR_ARG_QUOTE
argument_list|,
name|ep
operator|->
name|parse
argument_list|,
name|ep
operator|->
name|eqn
operator|.
name|ln
argument_list|,
name|ep
operator|->
name|eqn
operator|.
name|pos
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|next
operator|=
name|strchr
argument_list|(
name|start
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
operator|*
name|sz
operator|=
call|(
name|size_t
call|)
argument_list|(
name|next
operator|-
name|start
argument_list|)
expr_stmt|;
name|ep
operator|->
name|cur
operator|+=
operator|*
name|sz
expr_stmt|;
block|}
comment|/* Quotes aren't expanded for values. */
if|if
condition|(
name|q
operator|||
operator|!
name|repl
condition|)
return|return
name|start
return|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|def
operator|=
name|eqn_def_find
argument_list|(
name|ep
argument_list|,
name|start
argument_list|,
operator|*
name|sz
argument_list|)
operator|)
condition|)
block|{
name|diff
operator|=
name|def
operator|->
name|valsz
operator|-
operator|*
name|sz
expr_stmt|;
if|if
condition|(
name|def
operator|->
name|valsz
operator|>
operator|*
name|sz
condition|)
block|{
name|ep
operator|->
name|sz
operator|+=
name|diff
expr_stmt|;
name|ep
operator|->
name|data
operator|=
name|mandoc_realloc
argument_list|(
name|ep
operator|->
name|data
argument_list|,
name|ep
operator|->
name|sz
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ep
operator|->
name|data
index|[
name|ep
operator|->
name|sz
index|]
operator|=
literal|'\0'
expr_stmt|;
name|start
operator|=
operator|&
name|ep
operator|->
name|data
index|[
operator|(
name|int
operator|)
name|ep
operator|->
name|rew
index|]
expr_stmt|;
block|}
name|diff
operator|=
name|def
operator|->
name|valsz
operator|-
operator|*
name|sz
expr_stmt|;
name|memmove
argument_list|(
name|start
operator|+
operator|*
name|sz
operator|+
name|diff
argument_list|,
name|start
operator|+
operator|*
name|sz
argument_list|,
operator|(
name|strlen
argument_list|(
name|start
argument_list|)
operator|-
operator|*
name|sz
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|start
argument_list|,
name|def
operator|->
name|val
argument_list|,
name|def
operator|->
name|valsz
argument_list|)
expr_stmt|;
name|last_len
operator|=
name|start
operator|-
name|ep
operator|->
name|data
operator|+
name|def
operator|->
name|valsz
expr_stmt|;
name|lim
operator|++
expr_stmt|;
goto|goto
name|again
goto|;
block|}
return|return
name|start
return|;
block|}
end_function

begin_comment
comment|/*  * Get the next delimited token using the default current quote  * character.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|eqn_nexttok
parameter_list|(
name|struct
name|eqn_node
modifier|*
name|ep
parameter_list|,
name|size_t
modifier|*
name|sz
parameter_list|)
block|{
return|return
name|eqn_next
argument_list|(
name|ep
argument_list|,
literal|'"'
argument_list|,
name|sz
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get next token without replacement.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|eqn_nextrawtok
parameter_list|(
name|struct
name|eqn_node
modifier|*
name|ep
parameter_list|,
name|size_t
modifier|*
name|sz
parameter_list|)
block|{
return|return
name|eqn_next
argument_list|(
name|ep
argument_list|,
literal|'"'
argument_list|,
name|sz
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse a token from the stream of text.  * A token consists of one of the recognised eqn(7) strings.  * Strings are separated by delimiting marks.  * This returns EQN_TOK_EOF when there are no more tokens.  * If the token is an unrecognised string literal, then it returns  * EQN_TOK__MAX and sets the "p" pointer to an allocated, nil-terminated  * string.  * This must be later freed with free(3).  */
end_comment

begin_function
specifier|static
name|enum
name|eqn_tok
name|eqn_tok_parse
parameter_list|(
name|struct
name|eqn_node
modifier|*
name|ep
parameter_list|,
name|char
modifier|*
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|sz
decl_stmt|;
name|int
name|quoted
decl_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|p
condition|)
operator|*
name|p
operator|=
name|NULL
expr_stmt|;
name|quoted
operator|=
name|ep
operator|->
name|data
index|[
name|ep
operator|->
name|cur
index|]
operator|==
literal|'"'
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|start
operator|=
name|eqn_nexttok
argument_list|(
name|ep
argument_list|,
operator|&
name|sz
argument_list|)
operator|)
condition|)
return|return
name|EQN_TOK_EOF
return|;
if|if
condition|(
name|quoted
condition|)
block|{
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
name|mandoc_strndup
argument_list|(
name|start
argument_list|,
name|sz
argument_list|)
expr_stmt|;
return|return
name|EQN_TOK__MAX
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EQN_TOK__MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|NULL
operator|==
name|eqn_toks
index|[
name|i
index|]
condition|)
continue|continue;
if|if
condition|(
name|STRNEQ
argument_list|(
name|start
argument_list|,
name|sz
argument_list|,
name|eqn_toks
index|[
name|i
index|]
argument_list|,
name|strlen
argument_list|(
name|eqn_toks
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|EQN_TOK__MAX
operator|&&
name|NULL
operator|!=
name|p
condition|)
operator|*
name|p
operator|=
name|mandoc_strndup
argument_list|(
name|start
argument_list|,
name|sz
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eqn_box_free
parameter_list|(
name|struct
name|eqn_box
modifier|*
name|bp
parameter_list|)
block|{
if|if
condition|(
name|bp
operator|->
name|first
condition|)
name|eqn_box_free
argument_list|(
name|bp
operator|->
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|next
condition|)
name|eqn_box_free
argument_list|(
name|bp
operator|->
name|next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bp
operator|->
name|text
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bp
operator|->
name|left
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bp
operator|->
name|right
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bp
operator|->
name|top
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bp
operator|->
name|bottom
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a box as the last child of the parent node.  */
end_comment

begin_function
specifier|static
name|struct
name|eqn_box
modifier|*
name|eqn_box_alloc
parameter_list|(
name|struct
name|eqn_node
modifier|*
name|ep
parameter_list|,
name|struct
name|eqn_box
modifier|*
name|parent
parameter_list|)
block|{
name|struct
name|eqn_box
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|mandoc_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|eqn_box
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
name|bp
operator|->
name|parent
operator|->
name|args
operator|++
expr_stmt|;
name|bp
operator|->
name|expectargs
operator|=
name|UINT_MAX
expr_stmt|;
name|bp
operator|->
name|size
operator|=
name|ep
operator|->
name|gsize
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|parent
operator|->
name|first
condition|)
block|{
name|parent
operator|->
name|last
operator|->
name|next
operator|=
name|bp
expr_stmt|;
name|bp
operator|->
name|prev
operator|=
name|parent
operator|->
name|last
expr_stmt|;
block|}
else|else
name|parent
operator|->
name|first
operator|=
name|bp
expr_stmt|;
name|parent
operator|->
name|last
operator|=
name|bp
expr_stmt|;
return|return
name|bp
return|;
block|}
end_function

begin_comment
comment|/*  * Reparent the current last node (of the current parent) under a new  * EQN_SUBEXPR as the first element.  * Then return the new parent.  * The new EQN_SUBEXPR will have a two-child limit.  */
end_comment

begin_function
specifier|static
name|struct
name|eqn_box
modifier|*
name|eqn_box_makebinary
parameter_list|(
name|struct
name|eqn_node
modifier|*
name|ep
parameter_list|,
name|enum
name|eqn_post
name|pos
parameter_list|,
name|struct
name|eqn_box
modifier|*
name|parent
parameter_list|)
block|{
name|struct
name|eqn_box
modifier|*
name|b
decl_stmt|,
modifier|*
name|newb
decl_stmt|;
name|assert
argument_list|(
name|NULL
operator|!=
name|parent
operator|->
name|last
argument_list|)
expr_stmt|;
name|b
operator|=
name|parent
operator|->
name|last
expr_stmt|;
if|if
condition|(
name|parent
operator|->
name|last
operator|==
name|parent
operator|->
name|first
condition|)
name|parent
operator|->
name|first
operator|=
name|NULL
expr_stmt|;
name|parent
operator|->
name|args
operator|--
expr_stmt|;
name|parent
operator|->
name|last
operator|=
name|b
operator|->
name|prev
expr_stmt|;
name|b
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|newb
operator|=
name|eqn_box_alloc
argument_list|(
name|ep
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|newb
operator|->
name|pos
operator|=
name|pos
expr_stmt|;
name|newb
operator|->
name|type
operator|=
name|EQN_SUBEXPR
expr_stmt|;
name|newb
operator|->
name|expectargs
operator|=
literal|2
expr_stmt|;
name|newb
operator|->
name|args
operator|=
literal|1
expr_stmt|;
name|newb
operator|->
name|first
operator|=
name|newb
operator|->
name|last
operator|=
name|b
expr_stmt|;
name|newb
operator|->
name|first
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|parent
operator|=
name|newb
expr_stmt|;
return|return
name|newb
return|;
block|}
end_function

begin_comment
comment|/*  * Parse the "delim" control statement.  */
end_comment

begin_function
specifier|static
name|void
name|eqn_delim
parameter_list|(
name|struct
name|eqn_node
modifier|*
name|ep
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
if|if
condition|(
operator|(
name|start
operator|=
name|eqn_nextrawtok
argument_list|(
name|ep
argument_list|,
operator|&
name|sz
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|mandoc_msg
argument_list|(
name|MANDOCERR_REQ_EMPTY
argument_list|,
name|ep
operator|->
name|parse
argument_list|,
name|ep
operator|->
name|eqn
operator|.
name|ln
argument_list|,
name|ep
operator|->
name|eqn
operator|.
name|pos
argument_list|,
literal|"delim"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|start
argument_list|,
literal|"off"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|ep
operator|->
name|delim
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|start
argument_list|,
literal|"on"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ep
operator|->
name|odelim
operator|&&
name|ep
operator|->
name|cdelim
condition|)
name|ep
operator|->
name|delim
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|start
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|ep
operator|->
name|odelim
operator|=
name|start
index|[
literal|0
index|]
expr_stmt|;
name|ep
operator|->
name|cdelim
operator|=
name|start
index|[
literal|1
index|]
expr_stmt|;
name|ep
operator|->
name|delim
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Undefine a previously-defined string.  */
end_comment

begin_function
specifier|static
name|void
name|eqn_undef
parameter_list|(
name|struct
name|eqn_node
modifier|*
name|ep
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
name|struct
name|eqn_def
modifier|*
name|def
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
if|if
condition|(
operator|(
name|start
operator|=
name|eqn_nextrawtok
argument_list|(
name|ep
argument_list|,
operator|&
name|sz
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_REQ_EMPTY
argument_list|,
name|ep
operator|->
name|parse
argument_list|,
name|ep
operator|->
name|eqn
operator|.
name|ln
argument_list|,
name|ep
operator|->
name|eqn
operator|.
name|pos
argument_list|,
literal|"undef"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|def
operator|=
name|eqn_def_find
argument_list|(
name|ep
argument_list|,
name|start
argument_list|,
name|sz
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|free
argument_list|(
name|def
operator|->
name|key
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|def
operator|->
name|val
argument_list|)
expr_stmt|;
name|def
operator|->
name|key
operator|=
name|def
operator|->
name|val
operator|=
name|NULL
expr_stmt|;
name|def
operator|->
name|keysz
operator|=
name|def
operator|->
name|valsz
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|eqn_def
parameter_list|(
name|struct
name|eqn_node
modifier|*
name|ep
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
name|struct
name|eqn_def
modifier|*
name|def
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|start
operator|=
name|eqn_nextrawtok
argument_list|(
name|ep
argument_list|,
operator|&
name|sz
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_REQ_EMPTY
argument_list|,
name|ep
operator|->
name|parse
argument_list|,
name|ep
operator|->
name|eqn
operator|.
name|ln
argument_list|,
name|ep
operator|->
name|eqn
operator|.
name|pos
argument_list|,
literal|"define"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Search for a key that already exists. 	 * Create a new key if none is found. 	 */
if|if
condition|(
name|NULL
operator|==
operator|(
name|def
operator|=
name|eqn_def_find
argument_list|(
name|ep
argument_list|,
name|start
argument_list|,
name|sz
argument_list|)
operator|)
condition|)
block|{
comment|/* Find holes in string array. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|ep
operator|->
name|defsz
condition|;
name|i
operator|++
control|)
if|if
condition|(
literal|0
operator|==
name|ep
operator|->
name|defs
index|[
name|i
index|]
operator|.
name|keysz
condition|)
break|break;
if|if
condition|(
name|i
operator|==
operator|(
name|int
operator|)
name|ep
operator|->
name|defsz
condition|)
block|{
name|ep
operator|->
name|defsz
operator|++
expr_stmt|;
name|ep
operator|->
name|defs
operator|=
name|mandoc_reallocarray
argument_list|(
name|ep
operator|->
name|defs
argument_list|,
name|ep
operator|->
name|defsz
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|eqn_def
argument_list|)
argument_list|)
expr_stmt|;
name|ep
operator|->
name|defs
index|[
name|i
index|]
operator|.
name|key
operator|=
name|ep
operator|->
name|defs
index|[
name|i
index|]
operator|.
name|val
operator|=
name|NULL
expr_stmt|;
block|}
name|def
operator|=
name|ep
operator|->
name|defs
operator|+
name|i
expr_stmt|;
name|free
argument_list|(
name|def
operator|->
name|key
argument_list|)
expr_stmt|;
name|def
operator|->
name|key
operator|=
name|mandoc_strndup
argument_list|(
name|start
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|def
operator|->
name|keysz
operator|=
name|sz
expr_stmt|;
block|}
name|start
operator|=
name|eqn_next
argument_list|(
name|ep
argument_list|,
name|ep
operator|->
name|data
index|[
operator|(
name|int
operator|)
name|ep
operator|->
name|cur
index|]
argument_list|,
operator|&
name|sz
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|==
name|NULL
condition|)
block|{
name|mandoc_vmsg
argument_list|(
name|MANDOCERR_REQ_EMPTY
argument_list|,
name|ep
operator|->
name|parse
argument_list|,
name|ep
operator|->
name|eqn
operator|.
name|ln
argument_list|,
name|ep
operator|->
name|eqn
operator|.
name|pos
argument_list|,
literal|"define %s"
argument_list|,
name|def
operator|->
name|key
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|def
operator|->
name|key
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|def
operator|->
name|val
argument_list|)
expr_stmt|;
name|def
operator|->
name|key
operator|=
name|def
operator|->
name|val
operator|=
name|NULL
expr_stmt|;
name|def
operator|->
name|keysz
operator|=
name|def
operator|->
name|valsz
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|free
argument_list|(
name|def
operator|->
name|val
argument_list|)
expr_stmt|;
name|def
operator|->
name|val
operator|=
name|mandoc_strndup
argument_list|(
name|start
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|def
operator|->
name|valsz
operator|=
name|sz
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Recursively parse an eqn(7) expression.  */
end_comment

begin_function
specifier|static
name|enum
name|rofferr
name|eqn_parse
parameter_list|(
name|struct
name|eqn_node
modifier|*
name|ep
parameter_list|,
name|struct
name|eqn_box
modifier|*
name|parent
parameter_list|)
block|{
name|char
name|sym
index|[
literal|64
index|]
decl_stmt|;
name|struct
name|eqn_box
modifier|*
name|cur
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|sz
decl_stmt|;
name|enum
name|eqn_tok
name|tok
decl_stmt|,
name|subtok
decl_stmt|;
name|enum
name|eqn_post
name|pos
decl_stmt|;
name|int
name|size
decl_stmt|;
name|assert
argument_list|(
name|parent
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Empty equation. 	 * Do not add it to the high-level syntax tree. 	 */
if|if
condition|(
name|ep
operator|->
name|data
operator|==
name|NULL
condition|)
return|return
name|ROFF_IGN
return|;
name|next_tok
label|:
name|tok
operator|=
name|eqn_tok_parse
argument_list|(
name|ep
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
name|this_tok
label|:
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
operator|(
name|EQN_TOK_UNDEF
operator|)
case|:
name|eqn_undef
argument_list|(
name|ep
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|EQN_TOK_NDEFINE
operator|)
case|:
case|case
operator|(
name|EQN_TOK_DEFINE
operator|)
case|:
name|eqn_def
argument_list|(
name|ep
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|EQN_TOK_TDEFINE
operator|)
case|:
if|if
condition|(
name|eqn_nextrawtok
argument_list|(
name|ep
argument_list|,
name|NULL
argument_list|)
operator|==
name|NULL
operator|||
name|eqn_next
argument_list|(
name|ep
argument_list|,
name|ep
operator|->
name|data
index|[
operator|(
name|int
operator|)
name|ep
operator|->
name|cur
index|]
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL
condition|)
name|mandoc_msg
argument_list|(
name|MANDOCERR_REQ_EMPTY
argument_list|,
name|ep
operator|->
name|parse
argument_list|,
name|ep
operator|->
name|eqn
operator|.
name|ln
argument_list|,
name|ep
operator|->
name|eqn
operator|.
name|pos
argument_list|,
literal|"tdefine"
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|EQN_TOK_DELIM
operator|)
case|:
name|eqn_delim
argument_list|(
name|ep
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|EQN_TOK_GFONT
operator|)
case|:
if|if
condition|(
name|eqn_nextrawtok
argument_list|(
name|ep
argument_list|,
name|NULL
argument_list|)
operator|==
name|NULL
condition|)
name|mandoc_msg
argument_list|(
name|MANDOCERR_REQ_EMPTY
argument_list|,
name|ep
operator|->
name|parse
argument_list|,
name|ep
operator|->
name|eqn
operator|.
name|ln
argument_list|,
name|ep
operator|->
name|eqn
operator|.
name|pos
argument_list|,
name|eqn_toks
index|[
name|tok
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|EQN_TOK_MARK
operator|)
case|:
case|case
operator|(
name|EQN_TOK_LINEUP
operator|)
case|:
comment|/* Ignore these. */
break|break;
case|case
operator|(
name|EQN_TOK_DYAD
operator|)
case|:
case|case
operator|(
name|EQN_TOK_VEC
operator|)
case|:
case|case
operator|(
name|EQN_TOK_UNDER
operator|)
case|:
case|case
operator|(
name|EQN_TOK_BAR
operator|)
case|:
case|case
operator|(
name|EQN_TOK_TILDE
operator|)
case|:
case|case
operator|(
name|EQN_TOK_HAT
operator|)
case|:
case|case
operator|(
name|EQN_TOK_DOT
operator|)
case|:
case|case
operator|(
name|EQN_TOK_DOTDOT
operator|)
case|:
if|if
condition|(
name|parent
operator|->
name|last
operator|==
name|NULL
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_EQN_NOBOX
argument_list|,
name|ep
operator|->
name|parse
argument_list|,
name|ep
operator|->
name|eqn
operator|.
name|ln
argument_list|,
name|ep
operator|->
name|eqn
operator|.
name|pos
argument_list|,
name|eqn_toks
index|[
name|tok
index|]
argument_list|)
expr_stmt|;
name|cur
operator|=
name|eqn_box_alloc
argument_list|(
name|ep
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|cur
operator|->
name|type
operator|=
name|EQN_TEXT
expr_stmt|;
name|cur
operator|->
name|text
operator|=
name|mandoc_strdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
name|parent
operator|=
name|eqn_box_makebinary
argument_list|(
name|ep
argument_list|,
name|EQNPOS_NONE
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|parent
operator|->
name|type
operator|=
name|EQN_LISTONE
expr_stmt|;
name|parent
operator|->
name|expectargs
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
operator|(
name|EQN_TOK_DOTDOT
operator|)
case|:
name|strlcpy
argument_list|(
name|sym
argument_list|,
literal|"\\[ad]"
argument_list|,
sizeof|sizeof
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|EQN_TOK_VEC
operator|)
case|:
name|strlcpy
argument_list|(
name|sym
argument_list|,
literal|"\\[->]"
argument_list|,
sizeof|sizeof
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|EQN_TOK_DYAD
operator|)
case|:
name|strlcpy
argument_list|(
name|sym
argument_list|,
literal|"\\[<>]"
argument_list|,
sizeof|sizeof
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|EQN_TOK_TILDE
operator|)
case|:
name|strlcpy
argument_list|(
name|sym
argument_list|,
literal|"\\[a~]"
argument_list|,
sizeof|sizeof
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|EQN_TOK_UNDER
operator|)
case|:
name|strlcpy
argument_list|(
name|sym
argument_list|,
literal|"\\[ul]"
argument_list|,
sizeof|sizeof
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|EQN_TOK_BAR
operator|)
case|:
name|strlcpy
argument_list|(
name|sym
argument_list|,
literal|"\\[rl]"
argument_list|,
sizeof|sizeof
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|EQN_TOK_DOT
operator|)
case|:
name|strlcpy
argument_list|(
name|sym
argument_list|,
literal|"\\[a.]"
argument_list|,
sizeof|sizeof
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|EQN_TOK_HAT
operator|)
case|:
name|strlcpy
argument_list|(
name|sym
argument_list|,
literal|"\\[ha]"
argument_list|,
sizeof|sizeof
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
operator|(
name|EQN_TOK_DOTDOT
operator|)
case|:
case|case
operator|(
name|EQN_TOK_VEC
operator|)
case|:
case|case
operator|(
name|EQN_TOK_DYAD
operator|)
case|:
case|case
operator|(
name|EQN_TOK_TILDE
operator|)
case|:
case|case
operator|(
name|EQN_TOK_BAR
operator|)
case|:
case|case
operator|(
name|EQN_TOK_DOT
operator|)
case|:
case|case
operator|(
name|EQN_TOK_HAT
operator|)
case|:
name|parent
operator|->
name|top
operator|=
name|mandoc_strdup
argument_list|(
name|sym
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|EQN_TOK_UNDER
operator|)
case|:
name|parent
operator|->
name|bottom
operator|=
name|mandoc_strdup
argument_list|(
name|sym
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|parent
operator|=
name|parent
operator|->
name|parent
expr_stmt|;
break|break;
case|case
operator|(
name|EQN_TOK_FWD
operator|)
case|:
case|case
operator|(
name|EQN_TOK_BACK
operator|)
case|:
case|case
operator|(
name|EQN_TOK_DOWN
operator|)
case|:
case|case
operator|(
name|EQN_TOK_UP
operator|)
case|:
name|subtok
operator|=
name|eqn_tok_parse
argument_list|(
name|ep
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|subtok
operator|!=
name|EQN_TOK__MAX
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_REQ_EMPTY
argument_list|,
name|ep
operator|->
name|parse
argument_list|,
name|ep
operator|->
name|eqn
operator|.
name|ln
argument_list|,
name|ep
operator|->
name|eqn
operator|.
name|pos
argument_list|,
name|eqn_toks
index|[
name|tok
index|]
argument_list|)
expr_stmt|;
name|tok
operator|=
name|subtok
expr_stmt|;
goto|goto
name|this_tok
goto|;
block|}
break|break;
case|case
operator|(
name|EQN_TOK_FAT
operator|)
case|:
case|case
operator|(
name|EQN_TOK_ROMAN
operator|)
case|:
case|case
operator|(
name|EQN_TOK_ITALIC
operator|)
case|:
case|case
operator|(
name|EQN_TOK_BOLD
operator|)
case|:
while|while
condition|(
name|parent
operator|->
name|args
operator|==
name|parent
operator|->
name|expectargs
condition|)
name|parent
operator|=
name|parent
operator|->
name|parent
expr_stmt|;
comment|/* 		 * These values apply to the next word or sequence of 		 * words; thus, we mark that we'll have a child with 		 * exactly one of those. 		 */
name|parent
operator|=
name|eqn_box_alloc
argument_list|(
name|ep
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|parent
operator|->
name|type
operator|=
name|EQN_LISTONE
expr_stmt|;
name|parent
operator|->
name|expectargs
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
operator|(
name|EQN_TOK_FAT
operator|)
case|:
name|parent
operator|->
name|font
operator|=
name|EQNFONT_FAT
expr_stmt|;
break|break;
case|case
operator|(
name|EQN_TOK_ROMAN
operator|)
case|:
name|parent
operator|->
name|font
operator|=
name|EQNFONT_ROMAN
expr_stmt|;
break|break;
case|case
operator|(
name|EQN_TOK_ITALIC
operator|)
case|:
name|parent
operator|->
name|font
operator|=
name|EQNFONT_ITALIC
expr_stmt|;
break|break;
case|case
operator|(
name|EQN_TOK_BOLD
operator|)
case|:
name|parent
operator|->
name|font
operator|=
name|EQNFONT_BOLD
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
operator|(
name|EQN_TOK_SIZE
operator|)
case|:
case|case
operator|(
name|EQN_TOK_GSIZE
operator|)
case|:
comment|/* Accept two values: integral size and a single. */
if|if
condition|(
name|NULL
operator|==
operator|(
name|start
operator|=
name|eqn_nexttok
argument_list|(
name|ep
argument_list|,
operator|&
name|sz
argument_list|)
operator|)
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_REQ_EMPTY
argument_list|,
name|ep
operator|->
name|parse
argument_list|,
name|ep
operator|->
name|eqn
operator|.
name|ln
argument_list|,
name|ep
operator|->
name|eqn
operator|.
name|pos
argument_list|,
name|eqn_toks
index|[
name|tok
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|size
operator|=
name|mandoc_strntoi
argument_list|(
name|start
argument_list|,
name|sz
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|size
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_IT_NONUM
argument_list|,
name|ep
operator|->
name|parse
argument_list|,
name|ep
operator|->
name|eqn
operator|.
name|ln
argument_list|,
name|ep
operator|->
name|eqn
operator|.
name|pos
argument_list|,
name|eqn_toks
index|[
name|tok
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|EQN_TOK_GSIZE
operator|==
name|tok
condition|)
block|{
name|ep
operator|->
name|gsize
operator|=
name|size
expr_stmt|;
break|break;
block|}
name|parent
operator|=
name|eqn_box_alloc
argument_list|(
name|ep
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|parent
operator|->
name|type
operator|=
name|EQN_LISTONE
expr_stmt|;
name|parent
operator|->
name|expectargs
operator|=
literal|1
expr_stmt|;
name|parent
operator|->
name|size
operator|=
name|size
expr_stmt|;
break|break;
case|case
operator|(
name|EQN_TOK_FROM
operator|)
case|:
case|case
operator|(
name|EQN_TOK_TO
operator|)
case|:
case|case
operator|(
name|EQN_TOK_SUB
operator|)
case|:
case|case
operator|(
name|EQN_TOK_SUP
operator|)
case|:
comment|/* 		 * We have a left-right-associative expression. 		 * Repivot under a positional node, open a child scope 		 * and keep on reading. 		 */
if|if
condition|(
name|parent
operator|->
name|last
operator|==
name|NULL
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_EQN_NOBOX
argument_list|,
name|ep
operator|->
name|parse
argument_list|,
name|ep
operator|->
name|eqn
operator|.
name|ln
argument_list|,
name|ep
operator|->
name|eqn
operator|.
name|pos
argument_list|,
name|eqn_toks
index|[
name|tok
index|]
argument_list|)
expr_stmt|;
name|cur
operator|=
name|eqn_box_alloc
argument_list|(
name|ep
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|cur
operator|->
name|type
operator|=
name|EQN_TEXT
expr_stmt|;
name|cur
operator|->
name|text
operator|=
name|mandoc_strdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/* Handle the "subsup" and "fromto" positions. */
if|if
condition|(
name|EQN_TOK_SUP
operator|==
name|tok
operator|&&
name|parent
operator|->
name|pos
operator|==
name|EQNPOS_SUB
condition|)
block|{
name|parent
operator|->
name|expectargs
operator|=
literal|3
expr_stmt|;
name|parent
operator|->
name|pos
operator|=
name|EQNPOS_SUBSUP
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|EQN_TOK_TO
operator|==
name|tok
operator|&&
name|parent
operator|->
name|pos
operator|==
name|EQNPOS_FROM
condition|)
block|{
name|parent
operator|->
name|expectargs
operator|=
literal|3
expr_stmt|;
name|parent
operator|->
name|pos
operator|=
name|EQNPOS_FROMTO
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
operator|(
name|EQN_TOK_FROM
operator|)
case|:
name|pos
operator|=
name|EQNPOS_FROM
expr_stmt|;
break|break;
case|case
operator|(
name|EQN_TOK_TO
operator|)
case|:
name|pos
operator|=
name|EQNPOS_TO
expr_stmt|;
break|break;
case|case
operator|(
name|EQN_TOK_SUP
operator|)
case|:
name|pos
operator|=
name|EQNPOS_SUP
expr_stmt|;
break|break;
case|case
operator|(
name|EQN_TOK_SUB
operator|)
case|:
name|pos
operator|=
name|EQNPOS_SUB
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|parent
operator|=
name|eqn_box_makebinary
argument_list|(
name|ep
argument_list|,
name|pos
argument_list|,
name|parent
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|EQN_TOK_SQRT
operator|)
case|:
while|while
condition|(
name|parent
operator|->
name|args
operator|==
name|parent
operator|->
name|expectargs
condition|)
name|parent
operator|=
name|parent
operator|->
name|parent
expr_stmt|;
comment|/* 		 * Accept a left-right-associative set of arguments just 		 * like sub and sup and friends but without rebalancing 		 * under a pivot. 		 */
name|parent
operator|=
name|eqn_box_alloc
argument_list|(
name|ep
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|parent
operator|->
name|type
operator|=
name|EQN_SUBEXPR
expr_stmt|;
name|parent
operator|->
name|pos
operator|=
name|EQNPOS_SQRT
expr_stmt|;
name|parent
operator|->
name|expectargs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
operator|(
name|EQN_TOK_OVER
operator|)
case|:
comment|/* 		 * We have a right-left-associative fraction. 		 * Close out anything that's currently open, then 		 * rebalance and continue reading. 		 */
if|if
condition|(
name|parent
operator|->
name|last
operator|==
name|NULL
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_EQN_NOBOX
argument_list|,
name|ep
operator|->
name|parse
argument_list|,
name|ep
operator|->
name|eqn
operator|.
name|ln
argument_list|,
name|ep
operator|->
name|eqn
operator|.
name|pos
argument_list|,
name|eqn_toks
index|[
name|tok
index|]
argument_list|)
expr_stmt|;
name|cur
operator|=
name|eqn_box_alloc
argument_list|(
name|ep
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|cur
operator|->
name|type
operator|=
name|EQN_TEXT
expr_stmt|;
name|cur
operator|->
name|text
operator|=
name|mandoc_strdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|EQN_SUBEXPR
operator|==
name|parent
operator|->
name|type
condition|)
name|parent
operator|=
name|parent
operator|->
name|parent
expr_stmt|;
name|parent
operator|=
name|eqn_box_makebinary
argument_list|(
name|ep
argument_list|,
name|EQNPOS_OVER
argument_list|,
name|parent
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|EQN_TOK_RIGHT
operator|)
case|:
case|case
operator|(
name|EQN_TOK_BRACE_CLOSE
operator|)
case|:
comment|/* 		 * Close out the existing brace. 		 * FIXME: this is a shitty sentinel: we should really 		 * have a native EQN_BRACE type or whatnot. 		 */
for|for
control|(
name|cur
operator|=
name|parent
init|;
name|cur
operator|!=
name|NULL
condition|;
name|cur
operator|=
name|cur
operator|->
name|parent
control|)
if|if
condition|(
name|cur
operator|->
name|type
operator|==
name|EQN_LIST
operator|&&
operator|(
name|tok
operator|==
name|EQN_TOK_BRACE_CLOSE
operator|||
name|cur
operator|->
name|left
operator|!=
name|NULL
operator|)
condition|)
break|break;
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_BLK_NOTOPEN
argument_list|,
name|ep
operator|->
name|parse
argument_list|,
name|ep
operator|->
name|eqn
operator|.
name|ln
argument_list|,
name|ep
operator|->
name|eqn
operator|.
name|pos
argument_list|,
name|eqn_toks
index|[
name|tok
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|parent
operator|=
name|cur
expr_stmt|;
if|if
condition|(
name|EQN_TOK_RIGHT
operator|==
name|tok
condition|)
block|{
if|if
condition|(
name|NULL
operator|==
operator|(
name|start
operator|=
name|eqn_nexttok
argument_list|(
name|ep
argument_list|,
operator|&
name|sz
argument_list|)
operator|)
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_REQ_EMPTY
argument_list|,
name|ep
operator|->
name|parse
argument_list|,
name|ep
operator|->
name|eqn
operator|.
name|ln
argument_list|,
name|ep
operator|->
name|eqn
operator|.
name|pos
argument_list|,
name|eqn_toks
index|[
name|tok
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Handling depends on right/left. */
if|if
condition|(
name|STRNEQ
argument_list|(
name|start
argument_list|,
name|sz
argument_list|,
literal|"ceiling"
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|strlcpy
argument_list|(
name|sym
argument_list|,
literal|"\\[rc]"
argument_list|,
sizeof|sizeof
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|parent
operator|->
name|right
operator|=
name|mandoc_strdup
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STRNEQ
argument_list|(
name|start
argument_list|,
name|sz
argument_list|,
literal|"floor"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|strlcpy
argument_list|(
name|sym
argument_list|,
literal|"\\[rf]"
argument_list|,
sizeof|sizeof
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|parent
operator|->
name|right
operator|=
name|mandoc_strdup
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
else|else
name|parent
operator|->
name|right
operator|=
name|mandoc_strndup
argument_list|(
name|start
argument_list|,
name|sz
argument_list|)
expr_stmt|;
block|}
name|parent
operator|=
name|parent
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|EQN_TOK_BRACE_CLOSE
operator|&&
operator|(
name|parent
operator|->
name|type
operator|==
name|EQN_PILE
operator|||
name|parent
operator|->
name|type
operator|==
name|EQN_MATRIX
operator|)
condition|)
name|parent
operator|=
name|parent
operator|->
name|parent
expr_stmt|;
comment|/* Close out any "singleton" lists. */
while|while
condition|(
name|parent
operator|->
name|type
operator|==
name|EQN_LISTONE
operator|&&
name|parent
operator|->
name|args
operator|==
name|parent
operator|->
name|expectargs
condition|)
name|parent
operator|=
name|parent
operator|->
name|parent
expr_stmt|;
break|break;
case|case
operator|(
name|EQN_TOK_BRACE_OPEN
operator|)
case|:
case|case
operator|(
name|EQN_TOK_LEFT
operator|)
case|:
comment|/* 		 * If we already have something in the stack and we're 		 * in an expression, then rewind til we're not any more 		 * (just like with the text node). 		 */
while|while
condition|(
name|parent
operator|->
name|args
operator|==
name|parent
operator|->
name|expectargs
condition|)
name|parent
operator|=
name|parent
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|EQN_TOK_LEFT
operator|==
name|tok
operator|&&
operator|(
name|start
operator|=
name|eqn_nexttok
argument_list|(
name|ep
argument_list|,
operator|&
name|sz
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_REQ_EMPTY
argument_list|,
name|ep
operator|->
name|parse
argument_list|,
name|ep
operator|->
name|eqn
operator|.
name|ln
argument_list|,
name|ep
operator|->
name|eqn
operator|.
name|pos
argument_list|,
name|eqn_toks
index|[
name|tok
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|parent
operator|=
name|eqn_box_alloc
argument_list|(
name|ep
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|parent
operator|->
name|type
operator|=
name|EQN_LIST
expr_stmt|;
if|if
condition|(
name|EQN_TOK_LEFT
operator|==
name|tok
condition|)
block|{
if|if
condition|(
name|STRNEQ
argument_list|(
name|start
argument_list|,
name|sz
argument_list|,
literal|"ceiling"
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|strlcpy
argument_list|(
name|sym
argument_list|,
literal|"\\[lc]"
argument_list|,
sizeof|sizeof
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|parent
operator|->
name|left
operator|=
name|mandoc_strdup
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STRNEQ
argument_list|(
name|start
argument_list|,
name|sz
argument_list|,
literal|"floor"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|strlcpy
argument_list|(
name|sym
argument_list|,
literal|"\\[lf]"
argument_list|,
sizeof|sizeof
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|parent
operator|->
name|left
operator|=
name|mandoc_strdup
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
else|else
name|parent
operator|->
name|left
operator|=
name|mandoc_strndup
argument_list|(
name|start
argument_list|,
name|sz
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
operator|(
name|EQN_TOK_PILE
operator|)
case|:
case|case
operator|(
name|EQN_TOK_LPILE
operator|)
case|:
case|case
operator|(
name|EQN_TOK_RPILE
operator|)
case|:
case|case
operator|(
name|EQN_TOK_CPILE
operator|)
case|:
case|case
operator|(
name|EQN_TOK_CCOL
operator|)
case|:
case|case
operator|(
name|EQN_TOK_LCOL
operator|)
case|:
case|case
operator|(
name|EQN_TOK_RCOL
operator|)
case|:
while|while
condition|(
name|parent
operator|->
name|args
operator|==
name|parent
operator|->
name|expectargs
condition|)
name|parent
operator|=
name|parent
operator|->
name|parent
expr_stmt|;
name|parent
operator|=
name|eqn_box_alloc
argument_list|(
name|ep
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|parent
operator|->
name|type
operator|=
name|EQN_PILE
expr_stmt|;
name|parent
operator|->
name|expectargs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
operator|(
name|EQN_TOK_ABOVE
operator|)
case|:
for|for
control|(
name|cur
operator|=
name|parent
init|;
name|cur
operator|!=
name|NULL
condition|;
name|cur
operator|=
name|cur
operator|->
name|parent
control|)
if|if
condition|(
name|cur
operator|->
name|type
operator|==
name|EQN_PILE
condition|)
break|break;
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_IT_STRAY
argument_list|,
name|ep
operator|->
name|parse
argument_list|,
name|ep
operator|->
name|eqn
operator|.
name|ln
argument_list|,
name|ep
operator|->
name|eqn
operator|.
name|pos
argument_list|,
name|eqn_toks
index|[
name|tok
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|parent
operator|=
name|eqn_box_alloc
argument_list|(
name|ep
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|parent
operator|->
name|type
operator|=
name|EQN_LIST
expr_stmt|;
break|break;
case|case
operator|(
name|EQN_TOK_MATRIX
operator|)
case|:
while|while
condition|(
name|parent
operator|->
name|args
operator|==
name|parent
operator|->
name|expectargs
condition|)
name|parent
operator|=
name|parent
operator|->
name|parent
expr_stmt|;
name|parent
operator|=
name|eqn_box_alloc
argument_list|(
name|ep
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|parent
operator|->
name|type
operator|=
name|EQN_MATRIX
expr_stmt|;
name|parent
operator|->
name|expectargs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
operator|(
name|EQN_TOK_EOF
operator|)
case|:
comment|/* 		 * End of file! 		 * TODO: make sure we're not in an open subexpression. 		 */
return|return
name|ROFF_EQN
return|;
default|default:
name|assert
argument_list|(
name|tok
operator|==
name|EQN_TOK__MAX
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|NULL
operator|!=
name|p
argument_list|)
expr_stmt|;
comment|/* 		 * If we already have something in the stack and we're 		 * in an expression, then rewind til we're not any more. 		 */
while|while
condition|(
name|parent
operator|->
name|args
operator|==
name|parent
operator|->
name|expectargs
condition|)
name|parent
operator|=
name|parent
operator|->
name|parent
expr_stmt|;
name|cur
operator|=
name|eqn_box_alloc
argument_list|(
name|ep
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|cur
operator|->
name|type
operator|=
name|EQN_TEXT
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EQNSYM__MAX
condition|;
name|i
operator|++
control|)
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|eqnsyms
index|[
name|i
index|]
operator|.
name|str
argument_list|,
name|p
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|sym
argument_list|,
sizeof|sizeof
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|"\\[%s]"
argument_list|,
name|eqnsyms
index|[
name|i
index|]
operator|.
name|sym
argument_list|)
expr_stmt|;
name|cur
operator|->
name|text
operator|=
name|mandoc_strdup
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|EQNSYM__MAX
condition|)
name|cur
operator|->
name|text
operator|=
name|p
expr_stmt|;
comment|/* 		 * Post-process list status. 		 */
while|while
condition|(
name|parent
operator|->
name|type
operator|==
name|EQN_LISTONE
operator|&&
name|parent
operator|->
name|args
operator|==
name|parent
operator|->
name|expectargs
condition|)
name|parent
operator|=
name|parent
operator|->
name|parent
expr_stmt|;
break|break;
block|}
goto|goto
name|next_tok
goto|;
block|}
end_function

begin_function
name|enum
name|rofferr
name|eqn_end
parameter_list|(
name|struct
name|eqn_node
modifier|*
modifier|*
name|epp
parameter_list|)
block|{
name|struct
name|eqn_node
modifier|*
name|ep
decl_stmt|;
name|ep
operator|=
operator|*
name|epp
expr_stmt|;
operator|*
name|epp
operator|=
name|NULL
expr_stmt|;
name|ep
operator|->
name|eqn
operator|.
name|root
operator|=
name|mandoc_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|eqn_box
argument_list|)
argument_list|)
expr_stmt|;
name|ep
operator|->
name|eqn
operator|.
name|root
operator|->
name|expectargs
operator|=
name|UINT_MAX
expr_stmt|;
return|return
name|eqn_parse
argument_list|(
name|ep
argument_list|,
name|ep
operator|->
name|eqn
operator|.
name|root
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|eqn_free
parameter_list|(
name|struct
name|eqn_node
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|eqn_box_free
argument_list|(
name|p
operator|->
name|eqn
operator|.
name|root
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|p
operator|->
name|defsz
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|p
operator|->
name|defs
index|[
name|i
index|]
operator|.
name|key
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|defs
index|[
name|i
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|p
operator|->
name|data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|defs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

