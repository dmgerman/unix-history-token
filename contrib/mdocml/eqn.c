begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$Id: eqn.c,v 1.78 2017/07/15 16:26:17 schwarze Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2011, 2014 Kristaps Dzonsons<kristaps@bsd.lv>  * Copyright (c) 2014, 2015, 2017 Ingo Schwarze<schwarze@openbsd.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|"mandoc_aux.h"
end_include

begin_include
include|#
directive|include
file|"mandoc.h"
end_include

begin_include
include|#
directive|include
file|"roff.h"
end_include

begin_include
include|#
directive|include
file|"libmandoc.h"
end_include

begin_include
include|#
directive|include
file|"libroff.h"
end_include

begin_define
define|#
directive|define
name|EQN_NEST_MAX
value|128
end_define

begin_comment
comment|/* maximum nesting of defines */
end_comment

begin_define
define|#
directive|define
name|STRNEQ
parameter_list|(
name|p1
parameter_list|,
name|sz1
parameter_list|,
name|p2
parameter_list|,
name|sz2
parameter_list|)
define|\
value|((sz1) == (sz2)&& 0 == strncmp((p1), (p2), (sz1)))
end_define

begin_enum
enum|enum
name|eqn_tok
block|{
name|EQN_TOK_DYAD
init|=
literal|0
block|,
name|EQN_TOK_VEC
block|,
name|EQN_TOK_UNDER
block|,
name|EQN_TOK_BAR
block|,
name|EQN_TOK_TILDE
block|,
name|EQN_TOK_HAT
block|,
name|EQN_TOK_DOT
block|,
name|EQN_TOK_DOTDOT
block|,
name|EQN_TOK_FWD
block|,
name|EQN_TOK_BACK
block|,
name|EQN_TOK_DOWN
block|,
name|EQN_TOK_UP
block|,
name|EQN_TOK_FAT
block|,
name|EQN_TOK_ROMAN
block|,
name|EQN_TOK_ITALIC
block|,
name|EQN_TOK_BOLD
block|,
name|EQN_TOK_SIZE
block|,
name|EQN_TOK_SUB
block|,
name|EQN_TOK_SUP
block|,
name|EQN_TOK_SQRT
block|,
name|EQN_TOK_OVER
block|,
name|EQN_TOK_FROM
block|,
name|EQN_TOK_TO
block|,
name|EQN_TOK_BRACE_OPEN
block|,
name|EQN_TOK_BRACE_CLOSE
block|,
name|EQN_TOK_GSIZE
block|,
name|EQN_TOK_GFONT
block|,
name|EQN_TOK_MARK
block|,
name|EQN_TOK_LINEUP
block|,
name|EQN_TOK_LEFT
block|,
name|EQN_TOK_RIGHT
block|,
name|EQN_TOK_PILE
block|,
name|EQN_TOK_LPILE
block|,
name|EQN_TOK_RPILE
block|,
name|EQN_TOK_CPILE
block|,
name|EQN_TOK_MATRIX
block|,
name|EQN_TOK_CCOL
block|,
name|EQN_TOK_LCOL
block|,
name|EQN_TOK_RCOL
block|,
name|EQN_TOK_DELIM
block|,
name|EQN_TOK_DEFINE
block|,
name|EQN_TOK_TDEFINE
block|,
name|EQN_TOK_NDEFINE
block|,
name|EQN_TOK_UNDEF
block|,
name|EQN_TOK_ABOVE
block|,
name|EQN_TOK__MAX
block|,
name|EQN_TOK_FUNC
block|,
name|EQN_TOK_QUOTED
block|,
name|EQN_TOK_SYM
block|,
name|EQN_TOK_EOF
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|eqn_toks
index|[
name|EQN_TOK__MAX
index|]
init|=
block|{
literal|"dyad"
block|,
comment|/* EQN_TOK_DYAD */
literal|"vec"
block|,
comment|/* EQN_TOK_VEC */
literal|"under"
block|,
comment|/* EQN_TOK_UNDER */
literal|"bar"
block|,
comment|/* EQN_TOK_BAR */
literal|"tilde"
block|,
comment|/* EQN_TOK_TILDE */
literal|"hat"
block|,
comment|/* EQN_TOK_HAT */
literal|"dot"
block|,
comment|/* EQN_TOK_DOT */
literal|"dotdot"
block|,
comment|/* EQN_TOK_DOTDOT */
literal|"fwd"
block|,
comment|/* EQN_TOK_FWD * */
literal|"back"
block|,
comment|/* EQN_TOK_BACK */
literal|"down"
block|,
comment|/* EQN_TOK_DOWN */
literal|"up"
block|,
comment|/* EQN_TOK_UP */
literal|"fat"
block|,
comment|/* EQN_TOK_FAT */
literal|"roman"
block|,
comment|/* EQN_TOK_ROMAN */
literal|"italic"
block|,
comment|/* EQN_TOK_ITALIC */
literal|"bold"
block|,
comment|/* EQN_TOK_BOLD */
literal|"size"
block|,
comment|/* EQN_TOK_SIZE */
literal|"sub"
block|,
comment|/* EQN_TOK_SUB */
literal|"sup"
block|,
comment|/* EQN_TOK_SUP */
literal|"sqrt"
block|,
comment|/* EQN_TOK_SQRT */
literal|"over"
block|,
comment|/* EQN_TOK_OVER */
literal|"from"
block|,
comment|/* EQN_TOK_FROM */
literal|"to"
block|,
comment|/* EQN_TOK_TO */
literal|"{"
block|,
comment|/* EQN_TOK_BRACE_OPEN */
literal|"}"
block|,
comment|/* EQN_TOK_BRACE_CLOSE */
literal|"gsize"
block|,
comment|/* EQN_TOK_GSIZE */
literal|"gfont"
block|,
comment|/* EQN_TOK_GFONT */
literal|"mark"
block|,
comment|/* EQN_TOK_MARK */
literal|"lineup"
block|,
comment|/* EQN_TOK_LINEUP */
literal|"left"
block|,
comment|/* EQN_TOK_LEFT */
literal|"right"
block|,
comment|/* EQN_TOK_RIGHT */
literal|"pile"
block|,
comment|/* EQN_TOK_PILE */
literal|"lpile"
block|,
comment|/* EQN_TOK_LPILE */
literal|"rpile"
block|,
comment|/* EQN_TOK_RPILE */
literal|"cpile"
block|,
comment|/* EQN_TOK_CPILE */
literal|"matrix"
block|,
comment|/* EQN_TOK_MATRIX */
literal|"ccol"
block|,
comment|/* EQN_TOK_CCOL */
literal|"lcol"
block|,
comment|/* EQN_TOK_LCOL */
literal|"rcol"
block|,
comment|/* EQN_TOK_RCOL */
literal|"delim"
block|,
comment|/* EQN_TOK_DELIM */
literal|"define"
block|,
comment|/* EQN_TOK_DEFINE */
literal|"tdefine"
block|,
comment|/* EQN_TOK_TDEFINE */
literal|"ndefine"
block|,
comment|/* EQN_TOK_NDEFINE */
literal|"undef"
block|,
comment|/* EQN_TOK_UNDEF */
literal|"above"
block|,
comment|/* EQN_TOK_ABOVE */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|eqn_func
index|[]
init|=
block|{
literal|"acos"
block|,
literal|"acsc"
block|,
literal|"and"
block|,
literal|"arc"
block|,
literal|"asec"
block|,
literal|"asin"
block|,
literal|"atan"
block|,
literal|"cos"
block|,
literal|"cosh"
block|,
literal|"coth"
block|,
literal|"csc"
block|,
literal|"det"
block|,
literal|"exp"
block|,
literal|"for"
block|,
literal|"if"
block|,
literal|"lim"
block|,
literal|"ln"
block|,
literal|"log"
block|,
literal|"max"
block|,
literal|"min"
block|,
literal|"sec"
block|,
literal|"sin"
block|,
literal|"sinh"
block|,
literal|"tan"
block|,
literal|"tanh"
block|,
literal|"Im"
block|,
literal|"Re"
block|, }
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|eqn_symt
block|{
name|EQNSYM_alpha
init|=
literal|0
block|,
name|EQNSYM_beta
block|,
name|EQNSYM_chi
block|,
name|EQNSYM_delta
block|,
name|EQNSYM_epsilon
block|,
name|EQNSYM_eta
block|,
name|EQNSYM_gamma
block|,
name|EQNSYM_iota
block|,
name|EQNSYM_kappa
block|,
name|EQNSYM_lambda
block|,
name|EQNSYM_mu
block|,
name|EQNSYM_nu
block|,
name|EQNSYM_omega
block|,
name|EQNSYM_omicron
block|,
name|EQNSYM_phi
block|,
name|EQNSYM_pi
block|,
name|EQNSYM_ps
block|,
name|EQNSYM_rho
block|,
name|EQNSYM_sigma
block|,
name|EQNSYM_tau
block|,
name|EQNSYM_theta
block|,
name|EQNSYM_upsilon
block|,
name|EQNSYM_xi
block|,
name|EQNSYM_zeta
block|,
name|EQNSYM_DELTA
block|,
name|EQNSYM_GAMMA
block|,
name|EQNSYM_LAMBDA
block|,
name|EQNSYM_OMEGA
block|,
name|EQNSYM_PHI
block|,
name|EQNSYM_PI
block|,
name|EQNSYM_PSI
block|,
name|EQNSYM_SIGMA
block|,
name|EQNSYM_THETA
block|,
name|EQNSYM_UPSILON
block|,
name|EQNSYM_XI
block|,
name|EQNSYM_inter
block|,
name|EQNSYM_union
block|,
name|EQNSYM_prod
block|,
name|EQNSYM_int
block|,
name|EQNSYM_sum
block|,
name|EQNSYM_grad
block|,
name|EQNSYM_del
block|,
name|EQNSYM_times
block|,
name|EQNSYM_cdot
block|,
name|EQNSYM_nothing
block|,
name|EQNSYM_approx
block|,
name|EQNSYM_prime
block|,
name|EQNSYM_half
block|,
name|EQNSYM_partial
block|,
name|EQNSYM_inf
block|,
name|EQNSYM_muchgreat
block|,
name|EQNSYM_muchless
block|,
name|EQNSYM_larrow
block|,
name|EQNSYM_rarrow
block|,
name|EQNSYM_pm
block|,
name|EQNSYM_nequal
block|,
name|EQNSYM_equiv
block|,
name|EQNSYM_lessequal
block|,
name|EQNSYM_moreequal
block|,
name|EQNSYM_minus
block|,
name|EQNSYM__MAX
block|}
enum|;
end_enum

begin_struct
struct|struct
name|eqnsym
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
specifier|const
name|char
modifier|*
name|sym
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|eqnsym
name|eqnsyms
index|[
name|EQNSYM__MAX
index|]
init|=
block|{
block|{
literal|"alpha"
block|,
literal|"*a"
block|}
block|,
comment|/* EQNSYM_alpha */
block|{
literal|"beta"
block|,
literal|"*b"
block|}
block|,
comment|/* EQNSYM_beta */
block|{
literal|"chi"
block|,
literal|"*x"
block|}
block|,
comment|/* EQNSYM_chi */
block|{
literal|"delta"
block|,
literal|"*d"
block|}
block|,
comment|/* EQNSYM_delta */
block|{
literal|"epsilon"
block|,
literal|"*e"
block|}
block|,
comment|/* EQNSYM_epsilon */
block|{
literal|"eta"
block|,
literal|"*y"
block|}
block|,
comment|/* EQNSYM_eta */
block|{
literal|"gamma"
block|,
literal|"*g"
block|}
block|,
comment|/* EQNSYM_gamma */
block|{
literal|"iota"
block|,
literal|"*i"
block|}
block|,
comment|/* EQNSYM_iota */
block|{
literal|"kappa"
block|,
literal|"*k"
block|}
block|,
comment|/* EQNSYM_kappa */
block|{
literal|"lambda"
block|,
literal|"*l"
block|}
block|,
comment|/* EQNSYM_lambda */
block|{
literal|"mu"
block|,
literal|"*m"
block|}
block|,
comment|/* EQNSYM_mu */
block|{
literal|"nu"
block|,
literal|"*n"
block|}
block|,
comment|/* EQNSYM_nu */
block|{
literal|"omega"
block|,
literal|"*w"
block|}
block|,
comment|/* EQNSYM_omega */
block|{
literal|"omicron"
block|,
literal|"*o"
block|}
block|,
comment|/* EQNSYM_omicron */
block|{
literal|"phi"
block|,
literal|"*f"
block|}
block|,
comment|/* EQNSYM_phi */
block|{
literal|"pi"
block|,
literal|"*p"
block|}
block|,
comment|/* EQNSYM_pi */
block|{
literal|"psi"
block|,
literal|"*q"
block|}
block|,
comment|/* EQNSYM_psi */
block|{
literal|"rho"
block|,
literal|"*r"
block|}
block|,
comment|/* EQNSYM_rho */
block|{
literal|"sigma"
block|,
literal|"*s"
block|}
block|,
comment|/* EQNSYM_sigma */
block|{
literal|"tau"
block|,
literal|"*t"
block|}
block|,
comment|/* EQNSYM_tau */
block|{
literal|"theta"
block|,
literal|"*h"
block|}
block|,
comment|/* EQNSYM_theta */
block|{
literal|"upsilon"
block|,
literal|"*u"
block|}
block|,
comment|/* EQNSYM_upsilon */
block|{
literal|"xi"
block|,
literal|"*c"
block|}
block|,
comment|/* EQNSYM_xi */
block|{
literal|"zeta"
block|,
literal|"*z"
block|}
block|,
comment|/* EQNSYM_zeta */
block|{
literal|"DELTA"
block|,
literal|"*D"
block|}
block|,
comment|/* EQNSYM_DELTA */
block|{
literal|"GAMMA"
block|,
literal|"*G"
block|}
block|,
comment|/* EQNSYM_GAMMA */
block|{
literal|"LAMBDA"
block|,
literal|"*L"
block|}
block|,
comment|/* EQNSYM_LAMBDA */
block|{
literal|"OMEGA"
block|,
literal|"*W"
block|}
block|,
comment|/* EQNSYM_OMEGA */
block|{
literal|"PHI"
block|,
literal|"*F"
block|}
block|,
comment|/* EQNSYM_PHI */
block|{
literal|"PI"
block|,
literal|"*P"
block|}
block|,
comment|/* EQNSYM_PI */
block|{
literal|"PSI"
block|,
literal|"*Q"
block|}
block|,
comment|/* EQNSYM_PSI */
block|{
literal|"SIGMA"
block|,
literal|"*S"
block|}
block|,
comment|/* EQNSYM_SIGMA */
block|{
literal|"THETA"
block|,
literal|"*H"
block|}
block|,
comment|/* EQNSYM_THETA */
block|{
literal|"UPSILON"
block|,
literal|"*U"
block|}
block|,
comment|/* EQNSYM_UPSILON */
block|{
literal|"XI"
block|,
literal|"*C"
block|}
block|,
comment|/* EQNSYM_XI */
block|{
literal|"inter"
block|,
literal|"ca"
block|}
block|,
comment|/* EQNSYM_inter */
block|{
literal|"union"
block|,
literal|"cu"
block|}
block|,
comment|/* EQNSYM_union */
block|{
literal|"prod"
block|,
literal|"product"
block|}
block|,
comment|/* EQNSYM_prod */
block|{
literal|"int"
block|,
literal|"integral"
block|}
block|,
comment|/* EQNSYM_int */
block|{
literal|"sum"
block|,
literal|"sum"
block|}
block|,
comment|/* EQNSYM_sum */
block|{
literal|"grad"
block|,
literal|"gr"
block|}
block|,
comment|/* EQNSYM_grad */
block|{
literal|"del"
block|,
literal|"gr"
block|}
block|,
comment|/* EQNSYM_del */
block|{
literal|"times"
block|,
literal|"mu"
block|}
block|,
comment|/* EQNSYM_times */
block|{
literal|"cdot"
block|,
literal|"pc"
block|}
block|,
comment|/* EQNSYM_cdot */
block|{
literal|"nothing"
block|,
literal|"&"
block|}
block|,
comment|/* EQNSYM_nothing */
block|{
literal|"approx"
block|,
literal|"~~"
block|}
block|,
comment|/* EQNSYM_approx */
block|{
literal|"prime"
block|,
literal|"fm"
block|}
block|,
comment|/* EQNSYM_prime */
block|{
literal|"half"
block|,
literal|"12"
block|}
block|,
comment|/* EQNSYM_half */
block|{
literal|"partial"
block|,
literal|"pd"
block|}
block|,
comment|/* EQNSYM_partial */
block|{
literal|"inf"
block|,
literal|"if"
block|}
block|,
comment|/* EQNSYM_inf */
block|{
literal|">>"
block|,
literal|">>"
block|}
block|,
comment|/* EQNSYM_muchgreat */
block|{
literal|"<<"
block|,
literal|"<<"
block|}
block|,
comment|/* EQNSYM_muchless */
block|{
literal|"<-"
block|,
literal|"<-"
block|}
block|,
comment|/* EQNSYM_larrow */
block|{
literal|"->"
block|,
literal|"->"
block|}
block|,
comment|/* EQNSYM_rarrow */
block|{
literal|"+-"
block|,
literal|"+-"
block|}
block|,
comment|/* EQNSYM_pm */
block|{
literal|"!="
block|,
literal|"!="
block|}
block|,
comment|/* EQNSYM_nequal */
block|{
literal|"=="
block|,
literal|"=="
block|}
block|,
comment|/* EQNSYM_equiv */
block|{
literal|"<="
block|,
literal|"<="
block|}
block|,
comment|/* EQNSYM_lessequal */
block|{
literal|">="
block|,
literal|">="
block|}
block|,
comment|/* EQNSYM_moreequal */
block|{
literal|"-"
block|,
literal|"mi"
block|}
block|,
comment|/* EQNSYM_minus */
block|}
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|parse_mode
block|{
name|MODE_QUOTED
block|,
name|MODE_NOSUB
block|,
name|MODE_SUB
block|,
name|MODE_TOK
block|}
enum|;
end_enum

begin_function_decl
specifier|static
name|struct
name|eqn_box
modifier|*
name|eqn_box_alloc
parameter_list|(
name|struct
name|eqn_node
modifier|*
parameter_list|,
name|struct
name|eqn_box
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|eqn_box
modifier|*
name|eqn_box_makebinary
parameter_list|(
name|struct
name|eqn_node
modifier|*
parameter_list|,
name|struct
name|eqn_box
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eqn_def
parameter_list|(
name|struct
name|eqn_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|eqn_def
modifier|*
name|eqn_def_find
parameter_list|(
name|struct
name|eqn_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eqn_delim
parameter_list|(
name|struct
name|eqn_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|eqn_tok
name|eqn_next
parameter_list|(
name|struct
name|eqn_node
modifier|*
parameter_list|,
name|enum
name|parse_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eqn_undef
parameter_list|(
name|struct
name|eqn_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|struct
name|eqn_node
modifier|*
name|eqn_alloc
parameter_list|(
name|struct
name|mparse
modifier|*
name|parse
parameter_list|)
block|{
name|struct
name|eqn_node
modifier|*
name|ep
decl_stmt|;
name|ep
operator|=
name|mandoc_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ep
argument_list|)
argument_list|)
expr_stmt|;
name|ep
operator|->
name|parse
operator|=
name|parse
expr_stmt|;
name|ep
operator|->
name|gsize
operator|=
name|EQN_DEFSIZE
expr_stmt|;
return|return
name|ep
return|;
block|}
end_function

begin_function
name|void
name|eqn_reset
parameter_list|(
name|struct
name|eqn_node
modifier|*
name|ep
parameter_list|)
block|{
name|free
argument_list|(
name|ep
operator|->
name|data
argument_list|)
expr_stmt|;
name|ep
operator|->
name|data
operator|=
name|ep
operator|->
name|start
operator|=
name|ep
operator|->
name|end
operator|=
name|NULL
expr_stmt|;
name|ep
operator|->
name|sz
operator|=
name|ep
operator|->
name|toksz
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|eqn_read
parameter_list|(
name|struct
name|eqn_node
modifier|*
name|ep
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|ep
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|ep
operator|->
name|sz
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ep
operator|->
name|data
operator|=
name|mandoc_strdup
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ep
operator|->
name|sz
operator|=
name|mandoc_asprintf
argument_list|(
operator|&
name|cp
argument_list|,
literal|"%s %s"
argument_list|,
name|ep
operator|->
name|data
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ep
operator|->
name|data
argument_list|)
expr_stmt|;
name|ep
operator|->
name|data
operator|=
name|cp
expr_stmt|;
block|}
name|ep
operator|->
name|sz
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find the key "key" of the give size within our eqn-defined values.  */
end_comment

begin_function
specifier|static
name|struct
name|eqn_def
modifier|*
name|eqn_def_find
parameter_list|(
name|struct
name|eqn_node
modifier|*
name|ep
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|ep
operator|->
name|defsz
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ep
operator|->
name|defs
index|[
name|i
index|]
operator|.
name|keysz
operator|&&
name|STRNEQ
argument_list|(
name|ep
operator|->
name|defs
index|[
name|i
index|]
operator|.
name|key
argument_list|,
name|ep
operator|->
name|defs
index|[
name|i
index|]
operator|.
name|keysz
argument_list|,
name|ep
operator|->
name|start
argument_list|,
name|ep
operator|->
name|toksz
argument_list|)
condition|)
return|return
operator|&
name|ep
operator|->
name|defs
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Parse a token from the input text.  The modes are:  * MODE_QUOTED: Use *ep->start as the delimiter; the token ends  *   before its next occurence.  Do not interpret the token in any  *   way and return EQN_TOK_QUOTED.  All other modes behave like  *   MODE_QUOTED when *ep->start is '"'.  * MODE_NOSUB: If *ep->start is a curly brace, the token ends after it;  *   otherwise, it ends before the next whitespace or brace.  *   Do not interpret the token and return EQN_TOK__MAX.  * MODE_SUB: Like MODE_NOSUB, but try to interpret the token as an  *   alias created with define.  If it is an alias, replace it with  *   its string value and reparse.  * MODE_TOK: Like MODE_SUB, but also check the token against the list  *   of tokens, and if there is a match, return that token.  Otherwise,  *   if the token matches a symbol, return EQN_TOK_SYM; if it matches  *   a function name, EQN_TOK_FUNC, or else EQN_TOK__MAX.  Except for  *   a token match, *ep->start is set to an allocated string that the  *   caller is expected to free.  * All modes skip whitespace following the end of the token.  */
end_comment

begin_function
specifier|static
name|enum
name|eqn_tok
name|eqn_next
parameter_list|(
name|struct
name|eqn_node
modifier|*
name|ep
parameter_list|,
name|enum
name|parse_mode
name|mode
parameter_list|)
block|{
specifier|static
name|int
name|last_len
decl_stmt|,
name|lim
decl_stmt|;
name|struct
name|eqn_def
modifier|*
name|def
decl_stmt|;
name|size_t
name|start
decl_stmt|;
name|int
name|diff
decl_stmt|,
name|i
decl_stmt|,
name|quoted
decl_stmt|;
name|enum
name|eqn_tok
name|tok
decl_stmt|;
comment|/* 	 * Reset the recursion counter after advancing 	 * beyond the end of the previous substitution. 	 */
if|if
condition|(
name|ep
operator|->
name|end
operator|-
name|ep
operator|->
name|data
operator|>=
name|last_len
condition|)
name|lim
operator|=
literal|0
expr_stmt|;
name|ep
operator|->
name|start
operator|=
name|ep
operator|->
name|end
expr_stmt|;
name|quoted
operator|=
name|mode
operator|==
name|MODE_QUOTED
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
operator|*
name|ep
operator|->
name|start
condition|)
block|{
case|case
literal|'\0'
case|:
name|ep
operator|->
name|toksz
operator|=
literal|0
expr_stmt|;
return|return
name|EQN_TOK_EOF
return|;
case|case
literal|'"'
case|:
name|quoted
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|quoted
condition|)
block|{
name|ep
operator|->
name|end
operator|=
name|strchr
argument_list|(
name|ep
operator|->
name|start
operator|+
literal|1
argument_list|,
operator|*
name|ep
operator|->
name|start
argument_list|)
expr_stmt|;
name|ep
operator|->
name|start
operator|++
expr_stmt|;
comment|/* Skip opening quote. */
if|if
condition|(
name|ep
operator|->
name|end
operator|==
name|NULL
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_ARG_QUOTE
argument_list|,
name|ep
operator|->
name|parse
argument_list|,
name|ep
operator|->
name|node
operator|->
name|line
argument_list|,
name|ep
operator|->
name|node
operator|->
name|pos
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ep
operator|->
name|end
operator|=
name|strchr
argument_list|(
name|ep
operator|->
name|start
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ep
operator|->
name|end
operator|=
name|ep
operator|->
name|start
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|ep
operator|->
name|start
operator|!=
literal|'{'
operator|&&
operator|*
name|ep
operator|->
name|start
operator|!=
literal|'}'
condition|)
name|ep
operator|->
name|end
operator|+=
name|strcspn
argument_list|(
name|ep
operator|->
name|end
argument_list|,
literal|" ^~\"{}\t"
argument_list|)
expr_stmt|;
block|}
name|ep
operator|->
name|toksz
operator|=
name|ep
operator|->
name|end
operator|-
name|ep
operator|->
name|start
expr_stmt|;
if|if
condition|(
name|quoted
operator|&&
operator|*
name|ep
operator|->
name|end
operator|!=
literal|'\0'
condition|)
name|ep
operator|->
name|end
operator|++
expr_stmt|;
comment|/* Skip closing quote. */
while|while
condition|(
operator|*
name|ep
operator|->
name|end
operator|!=
literal|'\0'
operator|&&
name|strchr
argument_list|(
literal|" \t^~"
argument_list|,
operator|*
name|ep
operator|->
name|end
argument_list|)
operator|!=
name|NULL
condition|)
name|ep
operator|->
name|end
operator|++
expr_stmt|;
if|if
condition|(
name|quoted
condition|)
comment|/* Cannot return, may have to strndup. */
break|break;
if|if
condition|(
name|mode
operator|==
name|MODE_NOSUB
condition|)
return|return
name|EQN_TOK__MAX
return|;
if|if
condition|(
operator|(
name|def
operator|=
name|eqn_def_find
argument_list|(
name|ep
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|++
name|lim
operator|>
name|EQN_NEST_MAX
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_ROFFLOOP
argument_list|,
name|ep
operator|->
name|parse
argument_list|,
name|ep
operator|->
name|node
operator|->
name|line
argument_list|,
name|ep
operator|->
name|node
operator|->
name|pos
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|EQN_TOK_EOF
return|;
block|}
comment|/* Replace a defined name with its string value. */
if|if
condition|(
operator|(
name|diff
operator|=
name|def
operator|->
name|valsz
operator|-
name|ep
operator|->
name|toksz
operator|)
operator|>
literal|0
condition|)
block|{
name|start
operator|=
name|ep
operator|->
name|start
operator|-
name|ep
operator|->
name|data
expr_stmt|;
name|ep
operator|->
name|sz
operator|+=
name|diff
expr_stmt|;
name|ep
operator|->
name|data
operator|=
name|mandoc_realloc
argument_list|(
name|ep
operator|->
name|data
argument_list|,
name|ep
operator|->
name|sz
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ep
operator|->
name|start
operator|=
name|ep
operator|->
name|data
operator|+
name|start
expr_stmt|;
block|}
if|if
condition|(
name|diff
condition|)
name|memmove
argument_list|(
name|ep
operator|->
name|start
operator|+
name|def
operator|->
name|valsz
argument_list|,
name|ep
operator|->
name|start
operator|+
name|ep
operator|->
name|toksz
argument_list|,
name|strlen
argument_list|(
name|ep
operator|->
name|start
operator|+
name|ep
operator|->
name|toksz
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ep
operator|->
name|start
argument_list|,
name|def
operator|->
name|val
argument_list|,
name|def
operator|->
name|valsz
argument_list|)
expr_stmt|;
name|last_len
operator|=
name|ep
operator|->
name|start
operator|-
name|ep
operator|->
name|data
operator|+
name|def
operator|->
name|valsz
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|!=
name|MODE_TOK
condition|)
return|return
name|quoted
condition|?
name|EQN_TOK_QUOTED
else|:
name|EQN_TOK__MAX
return|;
if|if
condition|(
name|quoted
condition|)
block|{
name|ep
operator|->
name|start
operator|=
name|mandoc_strndup
argument_list|(
name|ep
operator|->
name|start
argument_list|,
name|ep
operator|->
name|toksz
argument_list|)
expr_stmt|;
return|return
name|EQN_TOK_QUOTED
return|;
block|}
for|for
control|(
name|tok
operator|=
literal|0
init|;
name|tok
operator|<
name|EQN_TOK__MAX
condition|;
name|tok
operator|++
control|)
if|if
condition|(
name|STRNEQ
argument_list|(
name|ep
operator|->
name|start
argument_list|,
name|ep
operator|->
name|toksz
argument_list|,
name|eqn_toks
index|[
name|tok
index|]
argument_list|,
name|strlen
argument_list|(
name|eqn_toks
index|[
name|tok
index|]
argument_list|)
argument_list|)
condition|)
return|return
name|tok
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EQNSYM__MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|STRNEQ
argument_list|(
name|ep
operator|->
name|start
argument_list|,
name|ep
operator|->
name|toksz
argument_list|,
name|eqnsyms
index|[
name|i
index|]
operator|.
name|str
argument_list|,
name|strlen
argument_list|(
name|eqnsyms
index|[
name|i
index|]
operator|.
name|str
argument_list|)
argument_list|)
condition|)
block|{
name|mandoc_asprintf
argument_list|(
operator|&
name|ep
operator|->
name|start
argument_list|,
literal|"\\[%s]"
argument_list|,
name|eqnsyms
index|[
name|i
index|]
operator|.
name|sym
argument_list|)
expr_stmt|;
return|return
name|EQN_TOK_SYM
return|;
block|}
block|}
name|ep
operator|->
name|start
operator|=
name|mandoc_strndup
argument_list|(
name|ep
operator|->
name|start
argument_list|,
name|ep
operator|->
name|toksz
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|eqn_func
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|eqn_func
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|STRNEQ
argument_list|(
name|ep
operator|->
name|start
argument_list|,
name|ep
operator|->
name|toksz
argument_list|,
name|eqn_func
index|[
name|i
index|]
argument_list|,
name|strlen
argument_list|(
name|eqn_func
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
return|return
name|EQN_TOK_FUNC
return|;
return|return
name|EQN_TOK__MAX
return|;
block|}
end_function

begin_function
name|void
name|eqn_box_free
parameter_list|(
name|struct
name|eqn_box
modifier|*
name|bp
parameter_list|)
block|{
if|if
condition|(
name|bp
operator|->
name|first
condition|)
name|eqn_box_free
argument_list|(
name|bp
operator|->
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|next
condition|)
name|eqn_box_free
argument_list|(
name|bp
operator|->
name|next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bp
operator|->
name|text
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bp
operator|->
name|left
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bp
operator|->
name|right
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bp
operator|->
name|top
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bp
operator|->
name|bottom
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a box as the last child of the parent node.  */
end_comment

begin_function
specifier|static
name|struct
name|eqn_box
modifier|*
name|eqn_box_alloc
parameter_list|(
name|struct
name|eqn_node
modifier|*
name|ep
parameter_list|,
name|struct
name|eqn_box
modifier|*
name|parent
parameter_list|)
block|{
name|struct
name|eqn_box
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|mandoc_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|eqn_box
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
name|bp
operator|->
name|parent
operator|->
name|args
operator|++
expr_stmt|;
name|bp
operator|->
name|expectargs
operator|=
name|UINT_MAX
expr_stmt|;
name|bp
operator|->
name|font
operator|=
name|bp
operator|->
name|parent
operator|->
name|font
expr_stmt|;
name|bp
operator|->
name|size
operator|=
name|ep
operator|->
name|gsize
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|parent
operator|->
name|first
condition|)
block|{
name|parent
operator|->
name|last
operator|->
name|next
operator|=
name|bp
expr_stmt|;
name|bp
operator|->
name|prev
operator|=
name|parent
operator|->
name|last
expr_stmt|;
block|}
else|else
name|parent
operator|->
name|first
operator|=
name|bp
expr_stmt|;
name|parent
operator|->
name|last
operator|=
name|bp
expr_stmt|;
return|return
name|bp
return|;
block|}
end_function

begin_comment
comment|/*  * Reparent the current last node (of the current parent) under a new  * EQN_SUBEXPR as the first element.  * Then return the new parent.  * The new EQN_SUBEXPR will have a two-child limit.  */
end_comment

begin_function
specifier|static
name|struct
name|eqn_box
modifier|*
name|eqn_box_makebinary
parameter_list|(
name|struct
name|eqn_node
modifier|*
name|ep
parameter_list|,
name|struct
name|eqn_box
modifier|*
name|parent
parameter_list|)
block|{
name|struct
name|eqn_box
modifier|*
name|b
decl_stmt|,
modifier|*
name|newb
decl_stmt|;
name|assert
argument_list|(
name|NULL
operator|!=
name|parent
operator|->
name|last
argument_list|)
expr_stmt|;
name|b
operator|=
name|parent
operator|->
name|last
expr_stmt|;
if|if
condition|(
name|parent
operator|->
name|last
operator|==
name|parent
operator|->
name|first
condition|)
name|parent
operator|->
name|first
operator|=
name|NULL
expr_stmt|;
name|parent
operator|->
name|args
operator|--
expr_stmt|;
name|parent
operator|->
name|last
operator|=
name|b
operator|->
name|prev
expr_stmt|;
name|b
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|newb
operator|=
name|eqn_box_alloc
argument_list|(
name|ep
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|newb
operator|->
name|type
operator|=
name|EQN_SUBEXPR
expr_stmt|;
name|newb
operator|->
name|expectargs
operator|=
literal|2
expr_stmt|;
name|newb
operator|->
name|args
operator|=
literal|1
expr_stmt|;
name|newb
operator|->
name|first
operator|=
name|newb
operator|->
name|last
operator|=
name|b
expr_stmt|;
name|newb
operator|->
name|first
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|parent
operator|=
name|newb
expr_stmt|;
return|return
name|newb
return|;
block|}
end_function

begin_comment
comment|/*  * Parse the "delim" control statement.  */
end_comment

begin_function
specifier|static
name|void
name|eqn_delim
parameter_list|(
name|struct
name|eqn_node
modifier|*
name|ep
parameter_list|)
block|{
if|if
condition|(
name|ep
operator|->
name|end
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|ep
operator|->
name|end
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_REQ_EMPTY
argument_list|,
name|ep
operator|->
name|parse
argument_list|,
name|ep
operator|->
name|node
operator|->
name|line
argument_list|,
name|ep
operator|->
name|node
operator|->
name|pos
argument_list|,
literal|"delim"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|end
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|ep
operator|->
name|end
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|ep
operator|->
name|end
argument_list|,
literal|"off"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ep
operator|->
name|delim
operator|=
literal|0
expr_stmt|;
name|ep
operator|->
name|end
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|ep
operator|->
name|end
argument_list|,
literal|"on"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ep
operator|->
name|odelim
operator|&&
name|ep
operator|->
name|cdelim
condition|)
name|ep
operator|->
name|delim
operator|=
literal|1
expr_stmt|;
name|ep
operator|->
name|end
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|ep
operator|->
name|odelim
operator|=
operator|*
name|ep
operator|->
name|end
operator|++
expr_stmt|;
name|ep
operator|->
name|cdelim
operator|=
operator|*
name|ep
operator|->
name|end
operator|++
expr_stmt|;
name|ep
operator|->
name|delim
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Undefine a previously-defined string.  */
end_comment

begin_function
specifier|static
name|void
name|eqn_undef
parameter_list|(
name|struct
name|eqn_node
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|eqn_def
modifier|*
name|def
decl_stmt|;
if|if
condition|(
name|eqn_next
argument_list|(
name|ep
argument_list|,
name|MODE_NOSUB
argument_list|)
operator|==
name|EQN_TOK_EOF
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_REQ_EMPTY
argument_list|,
name|ep
operator|->
name|parse
argument_list|,
name|ep
operator|->
name|node
operator|->
name|line
argument_list|,
name|ep
operator|->
name|node
operator|->
name|pos
argument_list|,
literal|"undef"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|def
operator|=
name|eqn_def_find
argument_list|(
name|ep
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|free
argument_list|(
name|def
operator|->
name|key
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|def
operator|->
name|val
argument_list|)
expr_stmt|;
name|def
operator|->
name|key
operator|=
name|def
operator|->
name|val
operator|=
name|NULL
expr_stmt|;
name|def
operator|->
name|keysz
operator|=
name|def
operator|->
name|valsz
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|eqn_def
parameter_list|(
name|struct
name|eqn_node
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|eqn_def
modifier|*
name|def
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|eqn_next
argument_list|(
name|ep
argument_list|,
name|MODE_NOSUB
argument_list|)
operator|==
name|EQN_TOK_EOF
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_REQ_EMPTY
argument_list|,
name|ep
operator|->
name|parse
argument_list|,
name|ep
operator|->
name|node
operator|->
name|line
argument_list|,
name|ep
operator|->
name|node
operator|->
name|pos
argument_list|,
literal|"define"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Search for a key that already exists. 	 * Create a new key if none is found. 	 */
if|if
condition|(
operator|(
name|def
operator|=
name|eqn_def_find
argument_list|(
name|ep
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* Find holes in string array. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|ep
operator|->
name|defsz
condition|;
name|i
operator|++
control|)
if|if
condition|(
literal|0
operator|==
name|ep
operator|->
name|defs
index|[
name|i
index|]
operator|.
name|keysz
condition|)
break|break;
if|if
condition|(
name|i
operator|==
operator|(
name|int
operator|)
name|ep
operator|->
name|defsz
condition|)
block|{
name|ep
operator|->
name|defsz
operator|++
expr_stmt|;
name|ep
operator|->
name|defs
operator|=
name|mandoc_reallocarray
argument_list|(
name|ep
operator|->
name|defs
argument_list|,
name|ep
operator|->
name|defsz
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|eqn_def
argument_list|)
argument_list|)
expr_stmt|;
name|ep
operator|->
name|defs
index|[
name|i
index|]
operator|.
name|key
operator|=
name|ep
operator|->
name|defs
index|[
name|i
index|]
operator|.
name|val
operator|=
name|NULL
expr_stmt|;
block|}
name|def
operator|=
name|ep
operator|->
name|defs
operator|+
name|i
expr_stmt|;
name|free
argument_list|(
name|def
operator|->
name|key
argument_list|)
expr_stmt|;
name|def
operator|->
name|key
operator|=
name|mandoc_strndup
argument_list|(
name|ep
operator|->
name|start
argument_list|,
name|ep
operator|->
name|toksz
argument_list|)
expr_stmt|;
name|def
operator|->
name|keysz
operator|=
name|ep
operator|->
name|toksz
expr_stmt|;
block|}
if|if
condition|(
name|eqn_next
argument_list|(
name|ep
argument_list|,
name|MODE_QUOTED
argument_list|)
operator|==
name|EQN_TOK_EOF
condition|)
block|{
name|mandoc_vmsg
argument_list|(
name|MANDOCERR_REQ_EMPTY
argument_list|,
name|ep
operator|->
name|parse
argument_list|,
name|ep
operator|->
name|node
operator|->
name|line
argument_list|,
name|ep
operator|->
name|node
operator|->
name|pos
argument_list|,
literal|"define %s"
argument_list|,
name|def
operator|->
name|key
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|def
operator|->
name|key
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|def
operator|->
name|val
argument_list|)
expr_stmt|;
name|def
operator|->
name|key
operator|=
name|def
operator|->
name|val
operator|=
name|NULL
expr_stmt|;
name|def
operator|->
name|keysz
operator|=
name|def
operator|->
name|valsz
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|free
argument_list|(
name|def
operator|->
name|val
argument_list|)
expr_stmt|;
name|def
operator|->
name|val
operator|=
name|mandoc_strndup
argument_list|(
name|ep
operator|->
name|start
argument_list|,
name|ep
operator|->
name|toksz
argument_list|)
expr_stmt|;
name|def
operator|->
name|valsz
operator|=
name|ep
operator|->
name|toksz
expr_stmt|;
block|}
end_function

begin_function
name|void
name|eqn_parse
parameter_list|(
name|struct
name|eqn_node
modifier|*
name|ep
parameter_list|)
block|{
name|struct
name|eqn_box
modifier|*
name|cur
decl_stmt|,
modifier|*
name|nbox
decl_stmt|,
modifier|*
name|parent
decl_stmt|,
modifier|*
name|split
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cpn
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|enum
name|eqn_tok
name|tok
decl_stmt|;
enum|enum
block|{
name|CCL_LET
block|,
name|CCL_DIG
block|,
name|CCL_PUN
block|}
name|ccl
enum|,
name|ccln
expr_stmt|;
name|int
name|size
decl_stmt|;
name|parent
operator|=
name|ep
operator|->
name|node
operator|->
name|eqn
expr_stmt|;
name|assert
argument_list|(
name|parent
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Empty equation. 	 * Do not add it to the high-level syntax tree. 	 */
if|if
condition|(
name|ep
operator|->
name|data
operator|==
name|NULL
condition|)
return|return;
name|ep
operator|->
name|start
operator|=
name|ep
operator|->
name|end
operator|=
name|ep
operator|->
name|data
operator|+
name|strspn
argument_list|(
name|ep
operator|->
name|data
argument_list|,
literal|" ^~"
argument_list|)
expr_stmt|;
name|next_tok
label|:
name|tok
operator|=
name|eqn_next
argument_list|(
name|ep
argument_list|,
name|MODE_TOK
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|EQN_TOK_UNDEF
case|:
name|eqn_undef
argument_list|(
name|ep
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQN_TOK_NDEFINE
case|:
case|case
name|EQN_TOK_DEFINE
case|:
name|eqn_def
argument_list|(
name|ep
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQN_TOK_TDEFINE
case|:
if|if
condition|(
name|eqn_next
argument_list|(
name|ep
argument_list|,
name|MODE_NOSUB
argument_list|)
operator|==
name|EQN_TOK_EOF
operator|||
name|eqn_next
argument_list|(
name|ep
argument_list|,
name|MODE_QUOTED
argument_list|)
operator|==
name|EQN_TOK_EOF
condition|)
name|mandoc_msg
argument_list|(
name|MANDOCERR_REQ_EMPTY
argument_list|,
name|ep
operator|->
name|parse
argument_list|,
name|ep
operator|->
name|node
operator|->
name|line
argument_list|,
name|ep
operator|->
name|node
operator|->
name|pos
argument_list|,
literal|"tdefine"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQN_TOK_DELIM
case|:
name|eqn_delim
argument_list|(
name|ep
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQN_TOK_GFONT
case|:
if|if
condition|(
name|eqn_next
argument_list|(
name|ep
argument_list|,
name|MODE_SUB
argument_list|)
operator|==
name|EQN_TOK_EOF
condition|)
name|mandoc_msg
argument_list|(
name|MANDOCERR_REQ_EMPTY
argument_list|,
name|ep
operator|->
name|parse
argument_list|,
name|ep
operator|->
name|node
operator|->
name|line
argument_list|,
name|ep
operator|->
name|node
operator|->
name|pos
argument_list|,
name|eqn_toks
index|[
name|tok
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQN_TOK_MARK
case|:
case|case
name|EQN_TOK_LINEUP
case|:
comment|/* Ignore these. */
break|break;
case|case
name|EQN_TOK_DYAD
case|:
case|case
name|EQN_TOK_VEC
case|:
case|case
name|EQN_TOK_UNDER
case|:
case|case
name|EQN_TOK_BAR
case|:
case|case
name|EQN_TOK_TILDE
case|:
case|case
name|EQN_TOK_HAT
case|:
case|case
name|EQN_TOK_DOT
case|:
case|case
name|EQN_TOK_DOTDOT
case|:
if|if
condition|(
name|parent
operator|->
name|last
operator|==
name|NULL
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_EQN_NOBOX
argument_list|,
name|ep
operator|->
name|parse
argument_list|,
name|ep
operator|->
name|node
operator|->
name|line
argument_list|,
name|ep
operator|->
name|node
operator|->
name|pos
argument_list|,
name|eqn_toks
index|[
name|tok
index|]
argument_list|)
expr_stmt|;
name|cur
operator|=
name|eqn_box_alloc
argument_list|(
name|ep
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|cur
operator|->
name|type
operator|=
name|EQN_TEXT
expr_stmt|;
name|cur
operator|->
name|text
operator|=
name|mandoc_strdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
name|parent
operator|=
name|eqn_box_makebinary
argument_list|(
name|ep
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|parent
operator|->
name|type
operator|=
name|EQN_LIST
expr_stmt|;
name|parent
operator|->
name|expectargs
operator|=
literal|1
expr_stmt|;
name|parent
operator|->
name|font
operator|=
name|EQNFONT_ROMAN
expr_stmt|;
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|EQN_TOK_DOTDOT
case|:
name|parent
operator|->
name|top
operator|=
name|mandoc_strdup
argument_list|(
literal|"\\[ad]"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQN_TOK_VEC
case|:
name|parent
operator|->
name|top
operator|=
name|mandoc_strdup
argument_list|(
literal|"\\[->]"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQN_TOK_DYAD
case|:
name|parent
operator|->
name|top
operator|=
name|mandoc_strdup
argument_list|(
literal|"\\[<>]"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQN_TOK_TILDE
case|:
name|parent
operator|->
name|top
operator|=
name|mandoc_strdup
argument_list|(
literal|"\\[a~]"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQN_TOK_UNDER
case|:
name|parent
operator|->
name|bottom
operator|=
name|mandoc_strdup
argument_list|(
literal|"\\[ul]"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQN_TOK_BAR
case|:
name|parent
operator|->
name|top
operator|=
name|mandoc_strdup
argument_list|(
literal|"\\[rn]"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQN_TOK_DOT
case|:
name|parent
operator|->
name|top
operator|=
name|mandoc_strdup
argument_list|(
literal|"\\[a.]"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQN_TOK_HAT
case|:
name|parent
operator|->
name|top
operator|=
name|mandoc_strdup
argument_list|(
literal|"\\[ha]"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|parent
operator|=
name|parent
operator|->
name|parent
expr_stmt|;
break|break;
case|case
name|EQN_TOK_FWD
case|:
case|case
name|EQN_TOK_BACK
case|:
case|case
name|EQN_TOK_DOWN
case|:
case|case
name|EQN_TOK_UP
case|:
if|if
condition|(
name|eqn_next
argument_list|(
name|ep
argument_list|,
name|MODE_SUB
argument_list|)
operator|==
name|EQN_TOK_EOF
condition|)
name|mandoc_msg
argument_list|(
name|MANDOCERR_REQ_EMPTY
argument_list|,
name|ep
operator|->
name|parse
argument_list|,
name|ep
operator|->
name|node
operator|->
name|line
argument_list|,
name|ep
operator|->
name|node
operator|->
name|pos
argument_list|,
name|eqn_toks
index|[
name|tok
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQN_TOK_FAT
case|:
case|case
name|EQN_TOK_ROMAN
case|:
case|case
name|EQN_TOK_ITALIC
case|:
case|case
name|EQN_TOK_BOLD
case|:
while|while
condition|(
name|parent
operator|->
name|args
operator|==
name|parent
operator|->
name|expectargs
condition|)
name|parent
operator|=
name|parent
operator|->
name|parent
expr_stmt|;
comment|/* 		 * These values apply to the next word or sequence of 		 * words; thus, we mark that we'll have a child with 		 * exactly one of those. 		 */
name|parent
operator|=
name|eqn_box_alloc
argument_list|(
name|ep
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|parent
operator|->
name|type
operator|=
name|EQN_LIST
expr_stmt|;
name|parent
operator|->
name|expectargs
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|EQN_TOK_FAT
case|:
name|parent
operator|->
name|font
operator|=
name|EQNFONT_FAT
expr_stmt|;
break|break;
case|case
name|EQN_TOK_ROMAN
case|:
name|parent
operator|->
name|font
operator|=
name|EQNFONT_ROMAN
expr_stmt|;
break|break;
case|case
name|EQN_TOK_ITALIC
case|:
name|parent
operator|->
name|font
operator|=
name|EQNFONT_ITALIC
expr_stmt|;
break|break;
case|case
name|EQN_TOK_BOLD
case|:
name|parent
operator|->
name|font
operator|=
name|EQNFONT_BOLD
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|EQN_TOK_SIZE
case|:
case|case
name|EQN_TOK_GSIZE
case|:
comment|/* Accept two values: integral size and a single. */
if|if
condition|(
name|eqn_next
argument_list|(
name|ep
argument_list|,
name|MODE_SUB
argument_list|)
operator|==
name|EQN_TOK_EOF
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_REQ_EMPTY
argument_list|,
name|ep
operator|->
name|parse
argument_list|,
name|ep
operator|->
name|node
operator|->
name|line
argument_list|,
name|ep
operator|->
name|node
operator|->
name|pos
argument_list|,
name|eqn_toks
index|[
name|tok
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|size
operator|=
name|mandoc_strntoi
argument_list|(
name|ep
operator|->
name|start
argument_list|,
name|ep
operator|->
name|toksz
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|size
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_IT_NONUM
argument_list|,
name|ep
operator|->
name|parse
argument_list|,
name|ep
operator|->
name|node
operator|->
name|line
argument_list|,
name|ep
operator|->
name|node
operator|->
name|pos
argument_list|,
name|eqn_toks
index|[
name|tok
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|EQN_TOK_GSIZE
operator|==
name|tok
condition|)
block|{
name|ep
operator|->
name|gsize
operator|=
name|size
expr_stmt|;
break|break;
block|}
while|while
condition|(
name|parent
operator|->
name|args
operator|==
name|parent
operator|->
name|expectargs
condition|)
name|parent
operator|=
name|parent
operator|->
name|parent
expr_stmt|;
name|parent
operator|=
name|eqn_box_alloc
argument_list|(
name|ep
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|parent
operator|->
name|type
operator|=
name|EQN_LIST
expr_stmt|;
name|parent
operator|->
name|expectargs
operator|=
literal|1
expr_stmt|;
name|parent
operator|->
name|size
operator|=
name|size
expr_stmt|;
break|break;
case|case
name|EQN_TOK_FROM
case|:
case|case
name|EQN_TOK_TO
case|:
case|case
name|EQN_TOK_SUB
case|:
case|case
name|EQN_TOK_SUP
case|:
comment|/* 		 * We have a left-right-associative expression. 		 * Repivot under a positional node, open a child scope 		 * and keep on reading. 		 */
if|if
condition|(
name|parent
operator|->
name|last
operator|==
name|NULL
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_EQN_NOBOX
argument_list|,
name|ep
operator|->
name|parse
argument_list|,
name|ep
operator|->
name|node
operator|->
name|line
argument_list|,
name|ep
operator|->
name|node
operator|->
name|pos
argument_list|,
name|eqn_toks
index|[
name|tok
index|]
argument_list|)
expr_stmt|;
name|cur
operator|=
name|eqn_box_alloc
argument_list|(
name|ep
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|cur
operator|->
name|type
operator|=
name|EQN_TEXT
expr_stmt|;
name|cur
operator|->
name|text
operator|=
name|mandoc_strdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|parent
operator|->
name|expectargs
operator|==
literal|1
operator|&&
name|parent
operator|->
name|args
operator|==
literal|1
condition|)
name|parent
operator|=
name|parent
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|EQN_TOK_FROM
operator|||
name|tok
operator|==
name|EQN_TOK_TO
condition|)
block|{
for|for
control|(
name|cur
operator|=
name|parent
init|;
name|cur
operator|!=
name|NULL
condition|;
name|cur
operator|=
name|cur
operator|->
name|parent
control|)
if|if
condition|(
name|cur
operator|->
name|pos
operator|==
name|EQNPOS_SUB
operator|||
name|cur
operator|->
name|pos
operator|==
name|EQNPOS_SUP
operator|||
name|cur
operator|->
name|pos
operator|==
name|EQNPOS_SUBSUP
operator|||
name|cur
operator|->
name|pos
operator|==
name|EQNPOS_SQRT
operator|||
name|cur
operator|->
name|pos
operator|==
name|EQNPOS_OVER
condition|)
break|break;
if|if
condition|(
name|cur
operator|!=
name|NULL
condition|)
name|parent
operator|=
name|cur
operator|->
name|parent
expr_stmt|;
block|}
if|if
condition|(
name|tok
operator|==
name|EQN_TOK_SUP
operator|&&
name|parent
operator|->
name|pos
operator|==
name|EQNPOS_SUB
condition|)
block|{
name|parent
operator|->
name|expectargs
operator|=
literal|3
expr_stmt|;
name|parent
operator|->
name|pos
operator|=
name|EQNPOS_SUBSUP
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tok
operator|==
name|EQN_TOK_TO
operator|&&
name|parent
operator|->
name|pos
operator|==
name|EQNPOS_FROM
condition|)
block|{
name|parent
operator|->
name|expectargs
operator|=
literal|3
expr_stmt|;
name|parent
operator|->
name|pos
operator|=
name|EQNPOS_FROMTO
expr_stmt|;
break|break;
block|}
name|parent
operator|=
name|eqn_box_makebinary
argument_list|(
name|ep
argument_list|,
name|parent
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|EQN_TOK_FROM
case|:
name|parent
operator|->
name|pos
operator|=
name|EQNPOS_FROM
expr_stmt|;
break|break;
case|case
name|EQN_TOK_TO
case|:
name|parent
operator|->
name|pos
operator|=
name|EQNPOS_TO
expr_stmt|;
break|break;
case|case
name|EQN_TOK_SUP
case|:
name|parent
operator|->
name|pos
operator|=
name|EQNPOS_SUP
expr_stmt|;
break|break;
case|case
name|EQN_TOK_SUB
case|:
name|parent
operator|->
name|pos
operator|=
name|EQNPOS_SUB
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|EQN_TOK_SQRT
case|:
while|while
condition|(
name|parent
operator|->
name|args
operator|==
name|parent
operator|->
name|expectargs
condition|)
name|parent
operator|=
name|parent
operator|->
name|parent
expr_stmt|;
comment|/* 		 * Accept a left-right-associative set of arguments just 		 * like sub and sup and friends but without rebalancing 		 * under a pivot. 		 */
name|parent
operator|=
name|eqn_box_alloc
argument_list|(
name|ep
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|parent
operator|->
name|type
operator|=
name|EQN_SUBEXPR
expr_stmt|;
name|parent
operator|->
name|pos
operator|=
name|EQNPOS_SQRT
expr_stmt|;
name|parent
operator|->
name|expectargs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|EQN_TOK_OVER
case|:
comment|/* 		 * We have a right-left-associative fraction. 		 * Close out anything that's currently open, then 		 * rebalance and continue reading. 		 */
if|if
condition|(
name|parent
operator|->
name|last
operator|==
name|NULL
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_EQN_NOBOX
argument_list|,
name|ep
operator|->
name|parse
argument_list|,
name|ep
operator|->
name|node
operator|->
name|line
argument_list|,
name|ep
operator|->
name|node
operator|->
name|pos
argument_list|,
name|eqn_toks
index|[
name|tok
index|]
argument_list|)
expr_stmt|;
name|cur
operator|=
name|eqn_box_alloc
argument_list|(
name|ep
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|cur
operator|->
name|type
operator|=
name|EQN_TEXT
expr_stmt|;
name|cur
operator|->
name|text
operator|=
name|mandoc_strdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|parent
operator|->
name|args
operator|==
name|parent
operator|->
name|expectargs
condition|)
name|parent
operator|=
name|parent
operator|->
name|parent
expr_stmt|;
while|while
condition|(
name|EQN_SUBEXPR
operator|==
name|parent
operator|->
name|type
condition|)
name|parent
operator|=
name|parent
operator|->
name|parent
expr_stmt|;
name|parent
operator|=
name|eqn_box_makebinary
argument_list|(
name|ep
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|parent
operator|->
name|pos
operator|=
name|EQNPOS_OVER
expr_stmt|;
break|break;
case|case
name|EQN_TOK_RIGHT
case|:
case|case
name|EQN_TOK_BRACE_CLOSE
case|:
comment|/* 		 * Close out the existing brace. 		 * FIXME: this is a shitty sentinel: we should really 		 * have a native EQN_BRACE type or whatnot. 		 */
for|for
control|(
name|cur
operator|=
name|parent
init|;
name|cur
operator|!=
name|NULL
condition|;
name|cur
operator|=
name|cur
operator|->
name|parent
control|)
if|if
condition|(
name|cur
operator|->
name|type
operator|==
name|EQN_LIST
operator|&&
name|cur
operator|->
name|expectargs
operator|>
literal|1
operator|&&
operator|(
name|tok
operator|==
name|EQN_TOK_BRACE_CLOSE
operator|||
name|cur
operator|->
name|left
operator|!=
name|NULL
operator|)
condition|)
break|break;
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_BLK_NOTOPEN
argument_list|,
name|ep
operator|->
name|parse
argument_list|,
name|ep
operator|->
name|node
operator|->
name|line
argument_list|,
name|ep
operator|->
name|node
operator|->
name|pos
argument_list|,
name|eqn_toks
index|[
name|tok
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|parent
operator|=
name|cur
expr_stmt|;
if|if
condition|(
name|EQN_TOK_RIGHT
operator|==
name|tok
condition|)
block|{
if|if
condition|(
name|eqn_next
argument_list|(
name|ep
argument_list|,
name|MODE_SUB
argument_list|)
operator|==
name|EQN_TOK_EOF
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_REQ_EMPTY
argument_list|,
name|ep
operator|->
name|parse
argument_list|,
name|ep
operator|->
name|node
operator|->
name|line
argument_list|,
name|ep
operator|->
name|node
operator|->
name|pos
argument_list|,
name|eqn_toks
index|[
name|tok
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Handling depends on right/left. */
if|if
condition|(
name|STRNEQ
argument_list|(
name|ep
operator|->
name|start
argument_list|,
name|ep
operator|->
name|toksz
argument_list|,
literal|"ceiling"
argument_list|,
literal|7
argument_list|)
condition|)
name|parent
operator|->
name|right
operator|=
name|mandoc_strdup
argument_list|(
literal|"\\[rc]"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|STRNEQ
argument_list|(
name|ep
operator|->
name|start
argument_list|,
name|ep
operator|->
name|toksz
argument_list|,
literal|"floor"
argument_list|,
literal|5
argument_list|)
condition|)
name|parent
operator|->
name|right
operator|=
name|mandoc_strdup
argument_list|(
literal|"\\[rf]"
argument_list|)
expr_stmt|;
else|else
name|parent
operator|->
name|right
operator|=
name|mandoc_strndup
argument_list|(
name|ep
operator|->
name|start
argument_list|,
name|ep
operator|->
name|toksz
argument_list|)
expr_stmt|;
block|}
name|parent
operator|=
name|parent
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|EQN_TOK_BRACE_CLOSE
operator|&&
operator|(
name|parent
operator|->
name|type
operator|==
name|EQN_PILE
operator|||
name|parent
operator|->
name|type
operator|==
name|EQN_MATRIX
operator|)
condition|)
name|parent
operator|=
name|parent
operator|->
name|parent
expr_stmt|;
comment|/* Close out any "singleton" lists. */
while|while
condition|(
name|parent
operator|->
name|type
operator|==
name|EQN_LIST
operator|&&
name|parent
operator|->
name|expectargs
operator|==
literal|1
operator|&&
name|parent
operator|->
name|args
operator|==
literal|1
condition|)
name|parent
operator|=
name|parent
operator|->
name|parent
expr_stmt|;
break|break;
case|case
name|EQN_TOK_BRACE_OPEN
case|:
case|case
name|EQN_TOK_LEFT
case|:
comment|/* 		 * If we already have something in the stack and we're 		 * in an expression, then rewind til we're not any more 		 * (just like with the text node). 		 */
while|while
condition|(
name|parent
operator|->
name|args
operator|==
name|parent
operator|->
name|expectargs
condition|)
name|parent
operator|=
name|parent
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|EQN_TOK_LEFT
operator|==
name|tok
operator|&&
name|eqn_next
argument_list|(
name|ep
argument_list|,
name|MODE_SUB
argument_list|)
operator|==
name|EQN_TOK_EOF
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_REQ_EMPTY
argument_list|,
name|ep
operator|->
name|parse
argument_list|,
name|ep
operator|->
name|node
operator|->
name|line
argument_list|,
name|ep
operator|->
name|node
operator|->
name|pos
argument_list|,
name|eqn_toks
index|[
name|tok
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|parent
operator|=
name|eqn_box_alloc
argument_list|(
name|ep
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|parent
operator|->
name|type
operator|=
name|EQN_LIST
expr_stmt|;
if|if
condition|(
name|EQN_TOK_LEFT
operator|==
name|tok
condition|)
block|{
if|if
condition|(
name|STRNEQ
argument_list|(
name|ep
operator|->
name|start
argument_list|,
name|ep
operator|->
name|toksz
argument_list|,
literal|"ceiling"
argument_list|,
literal|7
argument_list|)
condition|)
name|parent
operator|->
name|left
operator|=
name|mandoc_strdup
argument_list|(
literal|"\\[lc]"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|STRNEQ
argument_list|(
name|ep
operator|->
name|start
argument_list|,
name|ep
operator|->
name|toksz
argument_list|,
literal|"floor"
argument_list|,
literal|5
argument_list|)
condition|)
name|parent
operator|->
name|left
operator|=
name|mandoc_strdup
argument_list|(
literal|"\\[lf]"
argument_list|)
expr_stmt|;
else|else
name|parent
operator|->
name|left
operator|=
name|mandoc_strndup
argument_list|(
name|ep
operator|->
name|start
argument_list|,
name|ep
operator|->
name|toksz
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EQN_TOK_PILE
case|:
case|case
name|EQN_TOK_LPILE
case|:
case|case
name|EQN_TOK_RPILE
case|:
case|case
name|EQN_TOK_CPILE
case|:
case|case
name|EQN_TOK_CCOL
case|:
case|case
name|EQN_TOK_LCOL
case|:
case|case
name|EQN_TOK_RCOL
case|:
while|while
condition|(
name|parent
operator|->
name|args
operator|==
name|parent
operator|->
name|expectargs
condition|)
name|parent
operator|=
name|parent
operator|->
name|parent
expr_stmt|;
name|parent
operator|=
name|eqn_box_alloc
argument_list|(
name|ep
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|parent
operator|->
name|type
operator|=
name|EQN_PILE
expr_stmt|;
name|parent
operator|->
name|expectargs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|EQN_TOK_ABOVE
case|:
for|for
control|(
name|cur
operator|=
name|parent
init|;
name|cur
operator|!=
name|NULL
condition|;
name|cur
operator|=
name|cur
operator|->
name|parent
control|)
if|if
condition|(
name|cur
operator|->
name|type
operator|==
name|EQN_PILE
condition|)
break|break;
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_IT_STRAY
argument_list|,
name|ep
operator|->
name|parse
argument_list|,
name|ep
operator|->
name|node
operator|->
name|line
argument_list|,
name|ep
operator|->
name|node
operator|->
name|pos
argument_list|,
name|eqn_toks
index|[
name|tok
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|parent
operator|=
name|eqn_box_alloc
argument_list|(
name|ep
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|parent
operator|->
name|type
operator|=
name|EQN_LIST
expr_stmt|;
break|break;
case|case
name|EQN_TOK_MATRIX
case|:
while|while
condition|(
name|parent
operator|->
name|args
operator|==
name|parent
operator|->
name|expectargs
condition|)
name|parent
operator|=
name|parent
operator|->
name|parent
expr_stmt|;
name|parent
operator|=
name|eqn_box_alloc
argument_list|(
name|ep
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|parent
operator|->
name|type
operator|=
name|EQN_MATRIX
expr_stmt|;
name|parent
operator|->
name|expectargs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|EQN_TOK_EOF
case|:
return|return;
case|case
name|EQN_TOK__MAX
case|:
case|case
name|EQN_TOK_FUNC
case|:
case|case
name|EQN_TOK_QUOTED
case|:
case|case
name|EQN_TOK_SYM
case|:
name|p
operator|=
name|ep
operator|->
name|start
expr_stmt|;
name|assert
argument_list|(
name|p
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		 * If we already have something in the stack and we're 		 * in an expression, then rewind til we're not any more. 		 */
while|while
condition|(
name|parent
operator|->
name|args
operator|==
name|parent
operator|->
name|expectargs
condition|)
name|parent
operator|=
name|parent
operator|->
name|parent
expr_stmt|;
name|cur
operator|=
name|eqn_box_alloc
argument_list|(
name|ep
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|cur
operator|->
name|type
operator|=
name|EQN_TEXT
expr_stmt|;
name|cur
operator|->
name|text
operator|=
name|p
expr_stmt|;
switch|switch
condition|(
name|tok
condition|)
block|{
case|case
name|EQN_TOK_FUNC
case|:
name|cur
operator|->
name|font
operator|=
name|EQNFONT_ROMAN
expr_stmt|;
break|break;
case|case
name|EQN_TOK_QUOTED
case|:
if|if
condition|(
name|cur
operator|->
name|font
operator|==
name|EQNFONT_NONE
condition|)
name|cur
operator|->
name|font
operator|=
name|EQNFONT_ITALIC
expr_stmt|;
break|break;
case|case
name|EQN_TOK_SYM
case|:
break|break;
default|default:
if|if
condition|(
name|cur
operator|->
name|font
operator|!=
name|EQNFONT_NONE
operator|||
operator|*
name|p
operator|==
literal|'\0'
condition|)
break|break;
name|cpn
operator|=
name|p
operator|-
literal|1
expr_stmt|;
name|ccln
operator|=
name|CCL_LET
expr_stmt|;
name|split
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Advance to next character. */
name|cp
operator|=
name|cpn
operator|++
expr_stmt|;
name|ccl
operator|=
name|ccln
expr_stmt|;
name|ccln
operator|=
name|isalpha
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cpn
argument_list|)
condition|?
name|CCL_LET
else|:
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cpn
argument_list|)
operator|||
operator|(
operator|*
name|cpn
operator|==
literal|'.'
operator|&&
operator|(
name|ccl
operator|==
name|CCL_DIG
operator|||
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|cpn
index|[
literal|1
index|]
argument_list|)
operator|)
operator|)
condition|?
name|CCL_DIG
else|:
name|CCL_PUN
expr_stmt|;
comment|/* No boundary before first character. */
if|if
condition|(
name|cp
operator|<
name|p
condition|)
continue|continue;
name|cur
operator|->
name|font
operator|=
name|ccl
operator|==
name|CCL_LET
condition|?
name|EQNFONT_ITALIC
else|:
name|EQNFONT_ROMAN
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\\'
condition|)
name|mandoc_escape
argument_list|(
operator|&
name|cpn
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* No boundary after last character. */
if|if
condition|(
operator|*
name|cpn
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|ccln
operator|==
name|ccl
operator|&&
operator|*
name|cp
operator|!=
literal|','
operator|&&
operator|*
name|cpn
operator|!=
literal|','
condition|)
continue|continue;
comment|/* Boundary found, split the text. */
if|if
condition|(
name|parent
operator|->
name|args
operator|==
name|parent
operator|->
name|expectargs
condition|)
block|{
comment|/* Remove the text from the tree. */
if|if
condition|(
name|cur
operator|->
name|prev
operator|==
name|NULL
condition|)
name|parent
operator|->
name|first
operator|=
name|cur
operator|->
name|next
expr_stmt|;
else|else
name|cur
operator|->
name|prev
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|parent
operator|->
name|last
operator|=
name|cur
operator|->
name|prev
expr_stmt|;
name|parent
operator|->
name|args
operator|--
expr_stmt|;
comment|/* Set up a list instead. */
name|split
operator|=
name|eqn_box_alloc
argument_list|(
name|ep
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|split
operator|->
name|type
operator|=
name|EQN_LIST
expr_stmt|;
comment|/* Insert the word into the list. */
name|split
operator|->
name|first
operator|=
name|split
operator|->
name|last
operator|=
name|cur
expr_stmt|;
name|cur
operator|->
name|parent
operator|=
name|split
expr_stmt|;
name|cur
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|parent
operator|=
name|split
expr_stmt|;
block|}
comment|/* Append a new text box. */
name|nbox
operator|=
name|eqn_box_alloc
argument_list|(
name|ep
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|nbox
operator|->
name|type
operator|=
name|EQN_TEXT
expr_stmt|;
name|nbox
operator|->
name|text
operator|=
name|mandoc_strdup
argument_list|(
name|cpn
argument_list|)
expr_stmt|;
comment|/* Truncate the old box. */
name|p
operator|=
name|mandoc_strndup
argument_list|(
name|cur
operator|->
name|text
argument_list|,
name|cpn
operator|-
name|cur
operator|->
name|text
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cur
operator|->
name|text
argument_list|)
expr_stmt|;
name|cur
operator|->
name|text
operator|=
name|p
expr_stmt|;
comment|/* Setup to process the new box. */
name|cur
operator|=
name|nbox
expr_stmt|;
name|p
operator|=
name|nbox
operator|->
name|text
expr_stmt|;
name|cpn
operator|=
name|p
operator|-
literal|1
expr_stmt|;
name|ccln
operator|=
name|CCL_LET
expr_stmt|;
block|}
if|if
condition|(
name|split
operator|!=
name|NULL
condition|)
name|parent
operator|=
name|split
operator|->
name|parent
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
goto|goto
name|next_tok
goto|;
block|}
end_function

begin_function
name|void
name|eqn_free
parameter_list|(
name|struct
name|eqn_node
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|p
operator|->
name|defsz
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|p
operator|->
name|defs
index|[
name|i
index|]
operator|.
name|key
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|defs
index|[
name|i
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|p
operator|->
name|data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|defs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

