begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$Id: chars.c,v 1.58 2014/07/23 15:00:08 schwarze Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2009, 2010, 2011 Kristaps Dzonsons<kristaps@bsd.lv>  * Copyright (c) 2011 Ingo Schwarze<schwarze@openbsd.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"mandoc.h"
end_include

begin_include
include|#
directive|include
file|"mandoc_aux.h"
end_include

begin_include
include|#
directive|include
file|"libmandoc.h"
end_include

begin_define
define|#
directive|define
name|PRINT_HI
value|126
end_define

begin_define
define|#
directive|define
name|PRINT_LO
value|32
end_define

begin_struct
struct|struct
name|ln
block|{
name|struct
name|ln
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|ascii
decl_stmt|;
name|int
name|unicode
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|LINES_MAX
value|330
end_define

begin_define
define|#
directive|define
name|CHAR
parameter_list|(
name|in
parameter_list|,
name|ch
parameter_list|,
name|code
parameter_list|)
define|\
value|{ NULL, (in), (ch), (code) },
end_define

begin_define
define|#
directive|define
name|CHAR_TBL_START
value|static struct ln lines[LINES_MAX] = {
end_define

begin_define
define|#
directive|define
name|CHAR_TBL_END
value|};
end_define

begin_include
include|#
directive|include
file|"chars.in"
end_include

begin_struct
struct|struct
name|mchars
block|{
name|struct
name|ln
modifier|*
modifier|*
name|htab
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
specifier|const
name|struct
name|ln
modifier|*
name|find
parameter_list|(
specifier|const
name|struct
name|mchars
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|mchars_free
parameter_list|(
name|struct
name|mchars
modifier|*
name|arg
parameter_list|)
block|{
name|free
argument_list|(
name|arg
operator|->
name|htab
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|mchars
modifier|*
name|mchars_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|mchars
modifier|*
name|tab
decl_stmt|;
name|struct
name|ln
modifier|*
modifier|*
name|htab
decl_stmt|;
name|struct
name|ln
modifier|*
name|pp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|hash
decl_stmt|;
comment|/* 	 * Constructs a very basic chaining hashtable.  The hash routine 	 * is simply the integral value of the first character. 	 * Subsequent entries are chained in the order they're processed. 	 */
name|tab
operator|=
name|mandoc_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mchars
argument_list|)
argument_list|)
expr_stmt|;
name|htab
operator|=
name|mandoc_calloc
argument_list|(
name|PRINT_HI
operator|-
name|PRINT_LO
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ln
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LINES_MAX
condition|;
name|i
operator|++
control|)
block|{
name|hash
operator|=
operator|(
name|int
operator|)
name|lines
index|[
name|i
index|]
operator|.
name|code
index|[
literal|0
index|]
operator|-
name|PRINT_LO
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|pp
operator|=
name|htab
index|[
name|hash
index|]
operator|)
condition|)
block|{
name|htab
index|[
name|hash
index|]
operator|=
operator|&
name|lines
index|[
name|i
index|]
expr_stmt|;
continue|continue;
block|}
for|for
control|(
init|;
name|pp
operator|->
name|next
condition|;
name|pp
operator|=
name|pp
operator|->
name|next
control|)
comment|/* Scan ahead. */
empty_stmt|;
name|pp
operator|->
name|next
operator|=
operator|&
name|lines
index|[
name|i
index|]
expr_stmt|;
block|}
name|tab
operator|->
name|htab
operator|=
name|htab
expr_stmt|;
return|return
operator|(
name|tab
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mchars_spec2cp
parameter_list|(
specifier|const
name|struct
name|mchars
modifier|*
name|arg
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|sz
parameter_list|)
block|{
specifier|const
name|struct
name|ln
modifier|*
name|ln
decl_stmt|;
name|ln
operator|=
name|find
argument_list|(
name|arg
argument_list|,
name|p
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|ln
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|ln
operator|->
name|unicode
operator|)
return|;
block|}
end_function

begin_function
name|char
name|mchars_num2char
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|sz
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|mandoc_strntoi
argument_list|(
name|p
argument_list|,
name|sz
argument_list|,
literal|10
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|'\0'
operator|)
return|;
return|return
operator|(
name|i
operator|>
literal|0
operator|&&
name|i
operator|<
literal|256
operator|&&
name|isprint
argument_list|(
name|i
argument_list|)
condition|?
name|i
else|:
literal|'\0'
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mchars_num2uc
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|sz
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|mandoc_strntoi
argument_list|(
name|p
argument_list|,
name|sz
argument_list|,
literal|16
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|'\0'
operator|)
return|;
comment|/* 	 * Security warning: 	 * Never extend the range of accepted characters 	 * to overlap with the ASCII range, 0x00-0x7F 	 * without re-auditing the callers of this function. 	 * Some callers might relay on the fact that we never 	 * return ASCII characters for their escaping decisions. 	 * 	 * XXX Code is missing here to exclude bogus ranges. 	 */
return|return
operator|(
name|i
operator|>
literal|0x80
operator|&&
name|i
operator|<=
literal|0x10FFFF
condition|?
name|i
else|:
literal|'\0'
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|mchars_spec2str
parameter_list|(
specifier|const
name|struct
name|mchars
modifier|*
name|arg
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|sz
parameter_list|,
name|size_t
modifier|*
name|rsz
parameter_list|)
block|{
specifier|const
name|struct
name|ln
modifier|*
name|ln
decl_stmt|;
name|ln
operator|=
name|find
argument_list|(
name|arg
argument_list|,
name|p
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|ln
condition|)
block|{
operator|*
name|rsz
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|*
name|rsz
operator|=
name|strlen
argument_list|(
name|ln
operator|->
name|ascii
argument_list|)
expr_stmt|;
return|return
operator|(
name|ln
operator|->
name|ascii
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|struct
name|ln
modifier|*
name|find
parameter_list|(
specifier|const
name|struct
name|mchars
modifier|*
name|tab
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|sz
parameter_list|)
block|{
specifier|const
name|struct
name|ln
modifier|*
name|pp
decl_stmt|;
name|int
name|hash
decl_stmt|;
name|assert
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|sz
operator|||
name|p
index|[
literal|0
index|]
operator|<
name|PRINT_LO
operator|||
name|p
index|[
literal|0
index|]
operator|>
name|PRINT_HI
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|hash
operator|=
operator|(
name|int
operator|)
name|p
index|[
literal|0
index|]
operator|-
name|PRINT_LO
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|tab
operator|->
name|htab
index|[
name|hash
index|]
init|;
name|pp
condition|;
name|pp
operator|=
name|pp
operator|->
name|next
control|)
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|pp
operator|->
name|code
argument_list|,
name|p
argument_list|,
name|sz
argument_list|)
operator|&&
literal|'\0'
operator|==
name|pp
operator|->
name|code
index|[
operator|(
name|int
operator|)
name|sz
index|]
condition|)
return|return
operator|(
name|pp
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

end_unit

