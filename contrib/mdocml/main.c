begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$Id: main.c,v 1.301 2017/07/26 10:21:55 schwarze Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2008-2012 Kristaps Dzonsons<kristaps@bsd.lv>  * Copyright (c) 2010-2012, 2014-2017 Ingo Schwarze<schwarze@openbsd.org>  * Copyright (c) 2010 Joerg Sonnenberger<joerg@netbsd.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_comment
comment|/* MACHINE */
end_comment

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_if
if|#
directive|if
name|HAVE_ERR
end_if

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<glob.h>
end_include

begin_if
if|#
directive|if
name|HAVE_SANDBOX_INIT
end_if

begin_include
include|#
directive|include
file|<sandbox.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"mandoc_aux.h"
end_include

begin_include
include|#
directive|include
file|"mandoc.h"
end_include

begin_include
include|#
directive|include
file|"mandoc_xr.h"
end_include

begin_include
include|#
directive|include
file|"roff.h"
end_include

begin_include
include|#
directive|include
file|"mdoc.h"
end_include

begin_include
include|#
directive|include
file|"man.h"
end_include

begin_include
include|#
directive|include
file|"tag.h"
end_include

begin_include
include|#
directive|include
file|"main.h"
end_include

begin_include
include|#
directive|include
file|"manconf.h"
end_include

begin_include
include|#
directive|include
file|"mansearch.h"
end_include

begin_enum
enum|enum
name|outmode
block|{
name|OUTMODE_DEF
init|=
literal|0
block|,
name|OUTMODE_FLN
block|,
name|OUTMODE_LST
block|,
name|OUTMODE_ALL
block|,
name|OUTMODE_ONE
block|}
enum|;
end_enum

begin_enum
enum|enum
name|outt
block|{
name|OUTT_ASCII
init|=
literal|0
block|,
comment|/* -Tascii */
name|OUTT_LOCALE
block|,
comment|/* -Tlocale */
name|OUTT_UTF8
block|,
comment|/* -Tutf8 */
name|OUTT_TREE
block|,
comment|/* -Ttree */
name|OUTT_MAN
block|,
comment|/* -Tman */
name|OUTT_HTML
block|,
comment|/* -Thtml */
name|OUTT_MARKDOWN
block|,
comment|/* -Tmarkdown */
name|OUTT_LINT
block|,
comment|/* -Tlint */
name|OUTT_PS
block|,
comment|/* -Tps */
name|OUTT_PDF
comment|/* -Tpdf */
block|}
enum|;
end_enum

begin_struct
struct|struct
name|curparse
block|{
name|struct
name|mparse
modifier|*
name|mp
decl_stmt|;
name|struct
name|manoutput
modifier|*
name|outopts
decl_stmt|;
comment|/* output options */
name|void
modifier|*
name|outdata
decl_stmt|;
comment|/* data for output */
name|char
modifier|*
name|os_s
decl_stmt|;
comment|/* operating system for display */
name|int
name|wstop
decl_stmt|;
comment|/* stop after a file with a warning */
name|enum
name|mandocerr
name|mmin
decl_stmt|;
comment|/* ignore messages below this */
name|enum
name|mandoc_os
name|os_e
decl_stmt|;
comment|/* check base system conventions */
name|enum
name|outt
name|outtype
decl_stmt|;
comment|/* which output to use */
block|}
struct|;
end_struct

begin_function_decl
name|int
name|mandocdb
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_xr
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fs_lookup
parameter_list|(
specifier|const
name|struct
name|manpaths
modifier|*
parameter_list|,
name|size_t
name|ipath
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|manpage
modifier|*
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fs_search
parameter_list|(
specifier|const
name|struct
name|mansearch
modifier|*
parameter_list|,
specifier|const
name|struct
name|manpaths
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|struct
name|manpage
modifier|*
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|koptions
parameter_list|(
name|int
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|moptions
parameter_list|(
name|int
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mmsg
parameter_list|(
name|enum
name|mandocerr
parameter_list|,
name|enum
name|mandoclevel
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|outdata_alloc
parameter_list|(
name|struct
name|curparse
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse
parameter_list|(
name|struct
name|curparse
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|passthrough
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pid_t
name|spawn_pager
parameter_list|(
name|struct
name|tag_files
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|toptions
parameter_list|(
name|struct
name|curparse
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|enum
name|argmode
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(__noreturn__
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|int
name|woptions
parameter_list|(
name|struct
name|curparse
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|int
name|sec_prios
index|[]
init|=
block|{
literal|1
block|,
literal|4
block|,
literal|5
block|,
literal|8
block|,
literal|6
block|,
literal|3
block|,
literal|7
block|,
literal|2
block|,
literal|9
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|help_arg
index|[]
init|=
literal|"help"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|help_argv
index|[]
init|=
block|{
name|help_arg
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|mandoclevel
name|rc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|mmsg_stream
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|struct
name|manconf
name|conf
decl_stmt|;
name|struct
name|mansearch
name|search
decl_stmt|;
name|struct
name|curparse
name|curp
decl_stmt|;
name|struct
name|tag_files
modifier|*
name|tag_files
decl_stmt|;
name|struct
name|manpage
modifier|*
name|res
decl_stmt|,
modifier|*
name|resp
decl_stmt|;
specifier|const
name|char
modifier|*
name|progname
decl_stmt|,
modifier|*
name|sec
decl_stmt|,
modifier|*
name|thisarg
decl_stmt|;
name|char
modifier|*
name|conf_file
decl_stmt|,
modifier|*
name|defpaths
decl_stmt|,
modifier|*
name|auxpaths
decl_stmt|;
name|char
modifier|*
name|oarg
decl_stmt|;
name|unsigned
name|char
modifier|*
name|uc
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|sz
decl_stmt|;
name|int
name|prio
decl_stmt|,
name|best_prio
decl_stmt|;
name|enum
name|outmode
name|outmode
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|show_usage
decl_stmt|;
name|int
name|options
decl_stmt|;
name|int
name|use_pager
decl_stmt|;
name|int
name|status
decl_stmt|,
name|signum
decl_stmt|;
name|int
name|c
decl_stmt|;
name|pid_t
name|pager_pid
decl_stmt|,
name|tc_pgid
decl_stmt|,
name|man_pgid
decl_stmt|,
name|pid
decl_stmt|;
if|#
directive|if
name|HAVE_PROGNAME
name|progname
operator|=
name|getprogname
argument_list|()
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
name|progname
operator|=
name|mandoc_strdup
argument_list|(
literal|"mandoc"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|progname
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
else|else
operator|++
name|progname
expr_stmt|;
name|setprogname
argument_list|(
name|progname
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|strncmp
argument_list|(
name|progname
argument_list|,
literal|"mandocdb"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|progname
argument_list|,
name|BINM_MAKEWHATIS
argument_list|)
operator|==
literal|0
condition|)
return|return
name|mandocdb
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
return|;
if|#
directive|if
name|HAVE_PLEDGE
if|if
condition|(
name|pledge
argument_list|(
literal|"stdio rpath tmppath tty proc exec"
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
argument_list|,
literal|"pledge"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_SANDBOX_INIT
if|if
condition|(
name|sandbox_init
argument_list|(
name|kSBXProfileNoInternet
argument_list|,
name|SANDBOX_NAMED
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|errx
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
argument_list|,
literal|"sandbox_init"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Search options. */
name|memset
argument_list|(
operator|&
name|conf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|conf_file
operator|=
name|defpaths
operator|=
name|NULL
expr_stmt|;
name|auxpaths
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|search
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mansearch
argument_list|)
argument_list|)
expr_stmt|;
name|search
operator|.
name|outkey
operator|=
literal|"Nd"
expr_stmt|;
name|oarg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|progname
argument_list|,
name|BINM_MAN
argument_list|)
operator|==
literal|0
condition|)
name|search
operator|.
name|argmode
operator|=
name|ARG_NAME
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|progname
argument_list|,
name|BINM_APROPOS
argument_list|)
operator|==
literal|0
condition|)
name|search
operator|.
name|argmode
operator|=
name|ARG_EXPR
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|progname
argument_list|,
name|BINM_WHATIS
argument_list|)
operator|==
literal|0
condition|)
name|search
operator|.
name|argmode
operator|=
name|ARG_WORD
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|progname
argument_list|,
literal|"help"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|search
operator|.
name|argmode
operator|=
name|ARG_NAME
expr_stmt|;
else|else
name|search
operator|.
name|argmode
operator|=
name|ARG_FILE
expr_stmt|;
comment|/* Parser and formatter options. */
name|memset
argument_list|(
operator|&
name|curp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|curparse
argument_list|)
argument_list|)
expr_stmt|;
name|curp
operator|.
name|outtype
operator|=
name|OUTT_LOCALE
expr_stmt|;
name|curp
operator|.
name|mmin
operator|=
name|MANDOCERR_MAX
expr_stmt|;
name|curp
operator|.
name|outopts
operator|=
operator|&
name|conf
operator|.
name|output
expr_stmt|;
name|options
operator|=
name|MPARSE_SO
operator||
name|MPARSE_UTF8
operator||
name|MPARSE_LATIN1
expr_stmt|;
name|mmsg_stream
operator|=
name|stderr
expr_stmt|;
name|use_pager
operator|=
literal|1
expr_stmt|;
name|tag_files
operator|=
name|NULL
expr_stmt|;
name|show_usage
operator|=
literal|0
expr_stmt|;
name|outmode
operator|=
name|OUTMODE_DEF
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"aC:cfhI:iK:klM:m:O:S:s:T:VW:w"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'i'
operator|&&
name|search
operator|.
name|argmode
operator|==
name|ARG_EXPR
condition|)
block|{
name|optind
operator|--
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|outmode
operator|=
name|OUTMODE_ALL
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|conf_file
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|use_pager
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|search
operator|.
name|argmode
operator|=
name|ARG_WORD
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|conf
operator|.
name|output
operator|.
name|synopsisonly
operator|=
literal|1
expr_stmt|;
name|use_pager
operator|=
literal|0
expr_stmt|;
name|outmode
operator|=
name|OUTMODE_ALL
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|optarg
argument_list|,
literal|"os="
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"-I %s: Bad argument"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|MANDOCLEVEL_BADARG
return|;
block|}
if|if
condition|(
name|curp
operator|.
name|os_s
operator|!=
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"-I %s: Duplicate argument"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|MANDOCLEVEL_BADARG
return|;
block|}
name|curp
operator|.
name|os_s
operator|=
name|mandoc_strdup
argument_list|(
name|optarg
operator|+
literal|3
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
if|if
condition|(
operator|!
name|koptions
argument_list|(
operator|&
name|options
argument_list|,
name|optarg
argument_list|)
condition|)
return|return
operator|(
name|int
operator|)
name|MANDOCLEVEL_BADARG
return|;
break|break;
case|case
literal|'k'
case|:
name|search
operator|.
name|argmode
operator|=
name|ARG_EXPR
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|search
operator|.
name|argmode
operator|=
name|ARG_FILE
expr_stmt|;
name|outmode
operator|=
name|OUTMODE_ALL
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|defpaths
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|auxpaths
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|oarg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|search
operator|.
name|arch
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|search
operator|.
name|sec
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
if|if
condition|(
operator|!
name|toptions
argument_list|(
operator|&
name|curp
argument_list|,
name|optarg
argument_list|)
condition|)
return|return
operator|(
name|int
operator|)
name|MANDOCLEVEL_BADARG
return|;
break|break;
case|case
literal|'W'
case|:
if|if
condition|(
operator|!
name|woptions
argument_list|(
operator|&
name|curp
argument_list|,
name|optarg
argument_list|)
condition|)
return|return
operator|(
name|int
operator|)
name|MANDOCLEVEL_BADARG
return|;
break|break;
case|case
literal|'w'
case|:
name|outmode
operator|=
name|OUTMODE_FLN
expr_stmt|;
break|break;
default|default:
name|show_usage
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|show_usage
condition|)
name|usage
argument_list|(
name|search
operator|.
name|argmode
argument_list|)
expr_stmt|;
comment|/* Postprocess options. */
if|if
condition|(
name|outmode
operator|==
name|OUTMODE_DEF
condition|)
block|{
switch|switch
condition|(
name|search
operator|.
name|argmode
condition|)
block|{
case|case
name|ARG_FILE
case|:
name|outmode
operator|=
name|OUTMODE_ALL
expr_stmt|;
name|use_pager
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ARG_NAME
case|:
name|outmode
operator|=
name|OUTMODE_ONE
expr_stmt|;
break|break;
default|default:
name|outmode
operator|=
name|OUTMODE_LST
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|oarg
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|outmode
operator|==
name|OUTMODE_LST
condition|)
name|search
operator|.
name|outkey
operator|=
name|oarg
expr_stmt|;
else|else
block|{
while|while
condition|(
name|oarg
operator|!=
name|NULL
condition|)
block|{
name|thisarg
operator|=
name|oarg
expr_stmt|;
if|if
condition|(
name|manconf_output
argument_list|(
operator|&
name|conf
operator|.
name|output
argument_list|,
name|strsep
argument_list|(
operator|&
name|oarg
argument_list|,
literal|","
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|warnx
argument_list|(
literal|"-O %s: Bad argument"
argument_list|,
name|thisarg
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|MANDOCLEVEL_BADARG
return|;
block|}
block|}
block|}
if|if
condition|(
name|outmode
operator|==
name|OUTMODE_FLN
operator|||
name|outmode
operator|==
name|OUTMODE_LST
operator|||
operator|!
name|isatty
argument_list|(
name|STDOUT_FILENO
argument_list|)
condition|)
name|use_pager
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|HAVE_PLEDGE
if|if
condition|(
operator|!
name|use_pager
condition|)
if|if
condition|(
name|pledge
argument_list|(
literal|"stdio rpath"
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
argument_list|,
literal|"pledge"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Parse arguments. */
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
block|}
name|resp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Quirks for help(1) 	 * and for a man(1) section argument without -s. 	 */
if|if
condition|(
name|search
operator|.
name|argmode
operator|==
name|ARG_NAME
condition|)
block|{
if|if
condition|(
operator|*
name|progname
operator|==
literal|'h'
condition|)
block|{
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
name|argv
operator|=
name|help_argv
expr_stmt|;
name|argc
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|argc
operator|>
literal|1
operator|&&
operator|(
operator|(
name|uc
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|argv
index|[
literal|0
index|]
operator|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|isdigit
argument_list|(
name|uc
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|(
name|uc
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|isalpha
argument_list|(
name|uc
index|[
literal|1
index|]
argument_list|)
operator|&&
name|uc
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
operator|)
operator|)
operator|||
operator|(
name|uc
index|[
literal|0
index|]
operator|==
literal|'n'
operator|&&
name|uc
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
operator|)
condition|)
block|{
name|search
operator|.
name|sec
operator|=
operator|(
name|char
operator|*
operator|)
name|uc
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|search
operator|.
name|arch
operator|==
name|NULL
condition|)
name|search
operator|.
name|arch
operator|=
name|getenv
argument_list|(
literal|"MACHINE"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MACHINE
if|if
condition|(
name|search
operator|.
name|arch
operator|==
name|NULL
condition|)
name|search
operator|.
name|arch
operator|=
name|MACHINE
expr_stmt|;
endif|#
directive|endif
block|}
name|rc
operator|=
name|MANDOCLEVEL_OK
expr_stmt|;
comment|/* man(1), whatis(1), apropos(1) */
if|if
condition|(
name|search
operator|.
name|argmode
operator|!=
name|ARG_FILE
condition|)
block|{
if|if
condition|(
name|search
operator|.
name|argmode
operator|==
name|ARG_NAME
operator|&&
name|outmode
operator|==
name|OUTMODE_ONE
condition|)
name|search
operator|.
name|firstmatch
operator|=
literal|1
expr_stmt|;
comment|/* Access the mandoc database. */
name|manconf_parse
argument_list|(
operator|&
name|conf
argument_list|,
name|conf_file
argument_list|,
name|defpaths
argument_list|,
name|auxpaths
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mansearch
argument_list|(
operator|&
name|search
argument_list|,
operator|&
name|conf
operator|.
name|manpath
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|res
argument_list|,
operator|&
name|sz
argument_list|)
condition|)
name|usage
argument_list|(
name|search
operator|.
name|argmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|sz
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|search
operator|.
name|argmode
operator|==
name|ARG_NAME
condition|)
name|fs_search
argument_list|(
operator|&
name|search
argument_list|,
operator|&
name|conf
operator|.
name|manpath
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|res
argument_list|,
operator|&
name|sz
argument_list|)
expr_stmt|;
else|else
name|warnx
argument_list|(
literal|"nothing appropriate"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sz
operator|==
literal|0
condition|)
block|{
name|rc
operator|=
name|MANDOCLEVEL_BADARG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 		 * For standard man(1) and -a output mode, 		 * prepare for copying filename pointers 		 * into the program parameter array. 		 */
if|if
condition|(
name|outmode
operator|==
name|OUTMODE_ONE
condition|)
block|{
name|argc
operator|=
literal|1
expr_stmt|;
name|best_prio
operator|=
literal|20
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|outmode
operator|==
name|OUTMODE_ALL
condition|)
name|argc
operator|=
operator|(
name|int
operator|)
name|sz
expr_stmt|;
comment|/* Iterate all matching manuals. */
name|resp
operator|=
name|res
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|outmode
operator|==
name|OUTMODE_FLN
condition|)
name|puts
argument_list|(
name|res
index|[
name|i
index|]
operator|.
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|outmode
operator|==
name|OUTMODE_LST
condition|)
name|printf
argument_list|(
literal|"%s - %s\n"
argument_list|,
name|res
index|[
name|i
index|]
operator|.
name|names
argument_list|,
name|res
index|[
name|i
index|]
operator|.
name|output
operator|==
name|NULL
condition|?
literal|""
else|:
name|res
index|[
name|i
index|]
operator|.
name|output
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|outmode
operator|==
name|OUTMODE_ONE
condition|)
block|{
comment|/* Search for the best section. */
name|sec
operator|=
name|res
index|[
name|i
index|]
operator|.
name|file
expr_stmt|;
name|sec
operator|+=
name|strcspn
argument_list|(
name|sec
argument_list|,
literal|"123456789"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
name|prio
operator|=
name|sec_prios
index|[
name|sec
index|[
literal|0
index|]
operator|-
literal|'1'
index|]
expr_stmt|;
if|if
condition|(
name|sec
index|[
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|prio
operator|+=
literal|10
expr_stmt|;
if|if
condition|(
name|prio
operator|>=
name|best_prio
condition|)
continue|continue;
name|best_prio
operator|=
name|prio
expr_stmt|;
name|resp
operator|=
name|res
operator|+
name|i
expr_stmt|;
block|}
block|}
comment|/* 		 * For man(1), -a and -i output mode, fall through 		 * to the main mandoc(1) code iterating files 		 * and running the parsers on each of them. 		 */
if|if
condition|(
name|outmode
operator|==
name|OUTMODE_FLN
operator|||
name|outmode
operator|==
name|OUTMODE_LST
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* mandoc(1) */
if|#
directive|if
name|HAVE_PLEDGE
if|if
condition|(
name|use_pager
condition|)
block|{
if|if
condition|(
name|pledge
argument_list|(
literal|"stdio rpath tmppath tty proc exec"
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
argument_list|,
literal|"pledge"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pledge
argument_list|(
literal|"stdio rpath"
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
argument_list|,
literal|"pledge"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|search
operator|.
name|argmode
operator|==
name|ARG_FILE
condition|)
name|moptions
argument_list|(
operator|&
name|options
argument_list|,
name|auxpaths
argument_list|)
expr_stmt|;
name|mchars_alloc
argument_list|()
expr_stmt|;
name|curp
operator|.
name|mp
operator|=
name|mparse_alloc
argument_list|(
name|options
argument_list|,
name|curp
operator|.
name|mmin
argument_list|,
name|mmsg
argument_list|,
name|curp
operator|.
name|os_e
argument_list|,
name|curp
operator|.
name|os_s
argument_list|)
expr_stmt|;
comment|/* 	 * Conditionally start up the lookaside buffer before parsing. 	 */
if|if
condition|(
name|OUTT_MAN
operator|==
name|curp
operator|.
name|outtype
condition|)
name|mparse_keep
argument_list|(
name|curp
operator|.
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
if|if
condition|(
name|use_pager
condition|)
name|tag_files
operator|=
name|tag_init
argument_list|()
expr_stmt|;
name|parse
argument_list|(
operator|&
name|curp
argument_list|,
name|STDIN_FILENO
argument_list|,
literal|"<stdin>"
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
name|fd
operator|=
name|mparse_open
argument_list|(
name|curp
operator|.
name|mp
argument_list|,
name|resp
operator|!=
name|NULL
condition|?
name|resp
operator|->
name|file
else|:
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|use_pager
condition|)
block|{
name|tag_files
operator|=
name|tag_init
argument_list|()
expr_stmt|;
name|use_pager
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
name|parse
argument_list|(
operator|&
name|curp
argument_list|,
name|fd
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|resp
operator|->
name|form
operator|==
name|FORM_SRC
condition|)
block|{
comment|/* For .so only; ignore failure. */
operator|(
name|void
operator|)
name|chdir
argument_list|(
name|conf
operator|.
name|manpath
operator|.
name|paths
index|[
name|resp
operator|->
name|ipath
index|]
argument_list|)
expr_stmt|;
name|parse
argument_list|(
operator|&
name|curp
argument_list|,
name|fd
argument_list|,
name|resp
operator|->
name|file
argument_list|)
expr_stmt|;
block|}
else|else
name|passthrough
argument_list|(
name|resp
operator|->
name|file
argument_list|,
name|fd
argument_list|,
name|conf
operator|.
name|output
operator|.
name|synopsisonly
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
operator|&&
name|curp
operator|.
name|outtype
operator|<=
name|OUTT_UTF8
condition|)
block|{
if|if
condition|(
name|curp
operator|.
name|outdata
operator|==
name|NULL
condition|)
name|outdata_alloc
argument_list|(
operator|&
name|curp
argument_list|)
expr_stmt|;
name|terminal_sepline
argument_list|(
name|curp
operator|.
name|outdata
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|rc
operator|<
name|MANDOCLEVEL_ERROR
condition|)
name|rc
operator|=
name|MANDOCLEVEL_ERROR
expr_stmt|;
if|if
condition|(
name|MANDOCLEVEL_OK
operator|!=
name|rc
operator|&&
name|curp
operator|.
name|wstop
condition|)
break|break;
if|if
condition|(
name|resp
operator|!=
name|NULL
condition|)
name|resp
operator|++
expr_stmt|;
else|else
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|--
name|argc
condition|)
name|mparse_reset
argument_list|(
name|curp
operator|.
name|mp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|curp
operator|.
name|outdata
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|curp
operator|.
name|outtype
condition|)
block|{
case|case
name|OUTT_HTML
case|:
name|html_free
argument_list|(
name|curp
operator|.
name|outdata
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUTT_UTF8
case|:
case|case
name|OUTT_LOCALE
case|:
case|case
name|OUTT_ASCII
case|:
name|ascii_free
argument_list|(
name|curp
operator|.
name|outdata
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUTT_PDF
case|:
case|case
name|OUTT_PS
case|:
name|pspdf_free
argument_list|(
name|curp
operator|.
name|outdata
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|mandoc_xr_free
argument_list|()
expr_stmt|;
name|mparse_free
argument_list|(
name|curp
operator|.
name|mp
argument_list|)
expr_stmt|;
name|mchars_free
argument_list|()
expr_stmt|;
name|out
label|:
if|if
condition|(
name|search
operator|.
name|argmode
operator|!=
name|ARG_FILE
condition|)
block|{
name|manconf_free
argument_list|(
operator|&
name|conf
argument_list|)
expr_stmt|;
name|mansearch_free
argument_list|(
name|res
argument_list|,
name|sz
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|curp
operator|.
name|os_s
argument_list|)
expr_stmt|;
comment|/* 	 * When using a pager, finish writing both temporary files, 	 * fork it, wait for the user to close it, and clean up. 	 */
if|if
condition|(
name|tag_files
operator|!=
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|tag_write
argument_list|()
expr_stmt|;
name|man_pgid
operator|=
name|getpgid
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|tag_files
operator|->
name|tcpgid
operator|=
name|man_pgid
operator|==
name|getpid
argument_list|()
condition|?
name|getpgid
argument_list|(
name|getppid
argument_list|()
argument_list|)
else|:
name|man_pgid
expr_stmt|;
name|pager_pid
operator|=
literal|0
expr_stmt|;
name|signum
operator|=
name|SIGSTOP
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Stop here until moved to the foreground. */
name|tc_pgid
operator|=
name|tcgetpgrp
argument_list|(
name|tag_files
operator|->
name|ofd
argument_list|)
expr_stmt|;
if|if
condition|(
name|tc_pgid
operator|!=
name|man_pgid
condition|)
block|{
if|if
condition|(
name|tc_pgid
operator|==
name|pager_pid
condition|)
block|{
operator|(
name|void
operator|)
name|tcsetpgrp
argument_list|(
name|tag_files
operator|->
name|ofd
argument_list|,
name|man_pgid
argument_list|)
expr_stmt|;
if|if
condition|(
name|signum
operator|==
name|SIGTTIN
condition|)
continue|continue;
block|}
else|else
name|tag_files
operator|->
name|tcpgid
operator|=
name|tc_pgid
expr_stmt|;
name|kill
argument_list|(
literal|0
argument_list|,
name|signum
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Once in the foreground, activate the pager. */
if|if
condition|(
name|pager_pid
condition|)
block|{
operator|(
name|void
operator|)
name|tcsetpgrp
argument_list|(
name|tag_files
operator|->
name|ofd
argument_list|,
name|pager_pid
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|pager_pid
argument_list|,
name|SIGCONT
argument_list|)
expr_stmt|;
block|}
else|else
name|pager_pid
operator|=
name|spawn_pager
argument_list|(
name|tag_files
argument_list|)
expr_stmt|;
comment|/* Wait for the pager to stop or exit. */
while|while
condition|(
operator|(
name|pid
operator|=
name|waitpid
argument_list|(
name|pager_pid
argument_list|,
operator|&
name|status
argument_list|,
name|WUNTRACED
argument_list|)
operator|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"wait"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|MANDOCLEVEL_SYSERR
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|WIFSTOPPED
argument_list|(
name|status
argument_list|)
condition|)
break|break;
name|signum
operator|=
name|WSTOPSIG
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
name|tag_unlink
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|int
operator|)
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|enum
name|argmode
name|argmode
parameter_list|)
block|{
switch|switch
condition|(
name|argmode
condition|)
block|{
case|case
name|ARG_FILE
case|:
name|fputs
argument_list|(
literal|"usage: mandoc [-ac] [-I os=name] "
literal|"[-K encoding] [-mdoc | -man] [-O options]\n"
literal|"\t      [-T output] [-W level] [file ...]\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARG_NAME
case|:
name|fputs
argument_list|(
literal|"usage: man [-acfhklw] [-C file] [-M path] "
literal|"[-m path] [-S subsection]\n"
literal|"\t   [[-s] section] name ...\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARG_WORD
case|:
name|fputs
argument_list|(
literal|"usage: whatis [-afk] [-C file] "
literal|"[-M path] [-m path] [-O outkey] [-S arch]\n"
literal|"\t      [-s section] name ...\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARG_EXPR
case|:
name|fputs
argument_list|(
literal|"usage: apropos [-afk] [-C file] "
literal|"[-M path] [-m path] [-O outkey] [-S arch]\n"
literal|"\t       [-s section] expression ...\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
block|}
name|exit
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_BADARG
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fs_lookup
parameter_list|(
specifier|const
name|struct
name|manpaths
modifier|*
name|paths
parameter_list|,
name|size_t
name|ipath
parameter_list|,
specifier|const
name|char
modifier|*
name|sec
parameter_list|,
specifier|const
name|char
modifier|*
name|arch
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|manpage
modifier|*
modifier|*
name|res
parameter_list|,
name|size_t
modifier|*
name|ressz
parameter_list|)
block|{
name|glob_t
name|globinfo
decl_stmt|;
name|struct
name|manpage
modifier|*
name|page
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|globres
decl_stmt|;
name|enum
name|form
name|form
decl_stmt|;
name|form
operator|=
name|FORM_SRC
expr_stmt|;
name|mandoc_asprintf
argument_list|(
operator|&
name|file
argument_list|,
literal|"%s/man%s/%s.%s"
argument_list|,
name|paths
operator|->
name|paths
index|[
name|ipath
index|]
argument_list|,
name|sec
argument_list|,
name|name
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|file
argument_list|,
name|R_OK
argument_list|)
operator|!=
operator|-
literal|1
condition|)
goto|goto
name|found
goto|;
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|mandoc_asprintf
argument_list|(
operator|&
name|file
argument_list|,
literal|"%s/cat%s/%s.0"
argument_list|,
name|paths
operator|->
name|paths
index|[
name|ipath
index|]
argument_list|,
name|sec
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|file
argument_list|,
name|R_OK
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|form
operator|=
name|FORM_CAT
expr_stmt|;
goto|goto
name|found
goto|;
block|}
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|arch
operator|!=
name|NULL
condition|)
block|{
name|mandoc_asprintf
argument_list|(
operator|&
name|file
argument_list|,
literal|"%s/man%s/%s/%s.%s"
argument_list|,
name|paths
operator|->
name|paths
index|[
name|ipath
index|]
argument_list|,
name|sec
argument_list|,
name|arch
argument_list|,
name|name
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|file
argument_list|,
name|R_OK
argument_list|)
operator|!=
operator|-
literal|1
condition|)
goto|goto
name|found
goto|;
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
name|mandoc_asprintf
argument_list|(
operator|&
name|file
argument_list|,
literal|"%s/man%s/%s.[01-9]*"
argument_list|,
name|paths
operator|->
name|paths
index|[
name|ipath
index|]
argument_list|,
name|sec
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|globres
operator|=
name|glob
argument_list|(
name|file
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|globinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|globres
operator|!=
literal|0
operator|&&
name|globres
operator|!=
name|GLOB_NOMATCH
condition|)
name|warn
argument_list|(
literal|"%s: glob"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|globres
operator|==
literal|0
condition|)
name|file
operator|=
name|mandoc_strdup
argument_list|(
operator|*
name|globinfo
operator|.
name|gl_pathv
argument_list|)
expr_stmt|;
name|globfree
argument_list|(
operator|&
name|globinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|globres
operator|==
literal|0
condition|)
goto|goto
name|found
goto|;
if|if
condition|(
name|res
operator|!=
name|NULL
operator|||
name|ipath
operator|+
literal|1
operator|!=
name|paths
operator|->
name|sz
condition|)
return|return
literal|0
return|;
name|mandoc_asprintf
argument_list|(
operator|&
name|file
argument_list|,
literal|"%s.%s"
argument_list|,
name|name
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|globres
operator|=
name|access
argument_list|(
name|file
argument_list|,
name|R_OK
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
name|globres
operator|!=
operator|-
literal|1
return|;
name|found
label|:
name|warnx
argument_list|(
literal|"outdated mandoc.db lacks %s(%s) entry, run %s %s"
argument_list|,
name|name
argument_list|,
name|sec
argument_list|,
name|BINM_MAKEWHATIS
argument_list|,
name|paths
operator|->
name|paths
index|[
name|ipath
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
operator|*
name|res
operator|=
name|mandoc_reallocarray
argument_list|(
operator|*
name|res
argument_list|,
operator|++
operator|*
name|ressz
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|manpage
argument_list|)
argument_list|)
expr_stmt|;
name|page
operator|=
operator|*
name|res
operator|+
operator|(
operator|*
name|ressz
operator|-
literal|1
operator|)
expr_stmt|;
name|page
operator|->
name|file
operator|=
name|file
expr_stmt|;
name|page
operator|->
name|names
operator|=
name|NULL
expr_stmt|;
name|page
operator|->
name|output
operator|=
name|NULL
expr_stmt|;
name|page
operator|->
name|ipath
operator|=
name|ipath
expr_stmt|;
name|page
operator|->
name|bits
operator|=
name|NAME_FILE
operator|&
name|NAME_MASK
expr_stmt|;
name|page
operator|->
name|sec
operator|=
operator|(
operator|*
name|sec
operator|>=
literal|'1'
operator|&&
operator|*
name|sec
operator|<=
literal|'9'
operator|)
condition|?
operator|*
name|sec
operator|-
literal|'1'
operator|+
literal|1
else|:
literal|10
expr_stmt|;
name|page
operator|->
name|form
operator|=
name|form
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fs_search
parameter_list|(
specifier|const
name|struct
name|mansearch
modifier|*
name|cfg
parameter_list|,
specifier|const
name|struct
name|manpaths
modifier|*
name|paths
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|struct
name|manpage
modifier|*
modifier|*
name|res
parameter_list|,
name|size_t
modifier|*
name|ressz
parameter_list|)
block|{
specifier|const
name|char
modifier|*
specifier|const
name|sections
index|[]
init|=
block|{
literal|"1"
block|,
literal|"8"
block|,
literal|"6"
block|,
literal|"2"
block|,
literal|"3"
block|,
literal|"5"
block|,
literal|"7"
block|,
literal|"4"
block|,
literal|"9"
block|,
literal|"3p"
block|}
decl_stmt|;
specifier|const
name|size_t
name|nsec
init|=
sizeof|sizeof
argument_list|(
name|sections
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|sections
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|size_t
name|ipath
decl_stmt|,
name|isec
decl_stmt|,
name|lastsz
decl_stmt|;
name|assert
argument_list|(
name|cfg
operator|->
name|argmode
operator|==
name|ARG_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|NULL
condition|)
operator|*
name|res
operator|=
name|NULL
expr_stmt|;
operator|*
name|ressz
operator|=
name|lastsz
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|argc
condition|)
block|{
for|for
control|(
name|ipath
operator|=
literal|0
init|;
name|ipath
operator|<
name|paths
operator|->
name|sz
condition|;
name|ipath
operator|++
control|)
block|{
if|if
condition|(
name|cfg
operator|->
name|sec
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fs_lookup
argument_list|(
name|paths
argument_list|,
name|ipath
argument_list|,
name|cfg
operator|->
name|sec
argument_list|,
name|cfg
operator|->
name|arch
argument_list|,
operator|*
name|argv
argument_list|,
name|res
argument_list|,
name|ressz
argument_list|)
operator|&&
name|cfg
operator|->
name|firstmatch
condition|)
return|return
literal|1
return|;
block|}
else|else
for|for
control|(
name|isec
operator|=
literal|0
init|;
name|isec
operator|<
name|nsec
condition|;
name|isec
operator|++
control|)
if|if
condition|(
name|fs_lookup
argument_list|(
name|paths
argument_list|,
name|ipath
argument_list|,
name|sections
index|[
name|isec
index|]
argument_list|,
name|cfg
operator|->
name|arch
argument_list|,
operator|*
name|argv
argument_list|,
name|res
argument_list|,
name|ressz
argument_list|)
operator|&&
name|cfg
operator|->
name|firstmatch
condition|)
return|return
literal|1
return|;
block|}
if|if
condition|(
name|res
operator|!=
name|NULL
operator|&&
operator|*
name|ressz
operator|==
name|lastsz
condition|)
name|warnx
argument_list|(
literal|"No entry for %s in the manual."
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|lastsz
operator|=
operator|*
name|ressz
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|parse
parameter_list|(
name|struct
name|curparse
modifier|*
name|curp
parameter_list|,
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|)
block|{
name|enum
name|mandoclevel
name|rctmp
decl_stmt|;
name|struct
name|roff_man
modifier|*
name|man
decl_stmt|;
comment|/* Begin by parsing the file itself. */
name|assert
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|fd
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|rctmp
operator|=
name|mparse_readfd
argument_list|(
name|curp
operator|->
name|mp
argument_list|,
name|fd
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
name|STDIN_FILENO
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
name|rctmp
condition|)
name|rc
operator|=
name|rctmp
expr_stmt|;
comment|/* 	 * With -Wstop and warnings or errors of at least the requested 	 * level, do not produce output. 	 */
if|if
condition|(
name|rctmp
operator|!=
name|MANDOCLEVEL_OK
operator|&&
name|curp
operator|->
name|wstop
condition|)
return|return;
if|if
condition|(
name|curp
operator|->
name|outdata
operator|==
name|NULL
condition|)
name|outdata_alloc
argument_list|(
name|curp
argument_list|)
expr_stmt|;
name|mparse_result
argument_list|(
name|curp
operator|->
name|mp
argument_list|,
operator|&
name|man
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Execute the out device, if it exists. */
if|if
condition|(
name|man
operator|==
name|NULL
condition|)
return|return;
name|mandoc_xr_reset
argument_list|()
expr_stmt|;
if|if
condition|(
name|man
operator|->
name|macroset
operator|==
name|MACROSET_MDOC
condition|)
block|{
if|if
condition|(
name|curp
operator|->
name|outtype
operator|!=
name|OUTT_TREE
operator|||
operator|!
name|curp
operator|->
name|outopts
operator|->
name|noval
condition|)
name|mdoc_validate
argument_list|(
name|man
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|curp
operator|->
name|outtype
condition|)
block|{
case|case
name|OUTT_HTML
case|:
name|html_mdoc
argument_list|(
name|curp
operator|->
name|outdata
argument_list|,
name|man
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUTT_TREE
case|:
name|tree_mdoc
argument_list|(
name|curp
operator|->
name|outdata
argument_list|,
name|man
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUTT_MAN
case|:
name|man_mdoc
argument_list|(
name|curp
operator|->
name|outdata
argument_list|,
name|man
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUTT_PDF
case|:
case|case
name|OUTT_ASCII
case|:
case|case
name|OUTT_UTF8
case|:
case|case
name|OUTT_LOCALE
case|:
case|case
name|OUTT_PS
case|:
name|terminal_mdoc
argument_list|(
name|curp
operator|->
name|outdata
argument_list|,
name|man
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUTT_MARKDOWN
case|:
name|markdown_mdoc
argument_list|(
name|curp
operator|->
name|outdata
argument_list|,
name|man
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|man
operator|->
name|macroset
operator|==
name|MACROSET_MAN
condition|)
block|{
if|if
condition|(
name|curp
operator|->
name|outtype
operator|!=
name|OUTT_TREE
operator|||
operator|!
name|curp
operator|->
name|outopts
operator|->
name|noval
condition|)
name|man_validate
argument_list|(
name|man
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|curp
operator|->
name|outtype
condition|)
block|{
case|case
name|OUTT_HTML
case|:
name|html_man
argument_list|(
name|curp
operator|->
name|outdata
argument_list|,
name|man
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUTT_TREE
case|:
name|tree_man
argument_list|(
name|curp
operator|->
name|outdata
argument_list|,
name|man
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUTT_MAN
case|:
name|man_man
argument_list|(
name|curp
operator|->
name|outdata
argument_list|,
name|man
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUTT_PDF
case|:
case|case
name|OUTT_ASCII
case|:
case|case
name|OUTT_UTF8
case|:
case|case
name|OUTT_LOCALE
case|:
case|case
name|OUTT_PS
case|:
name|terminal_man
argument_list|(
name|curp
operator|->
name|outdata
argument_list|,
name|man
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|curp
operator|->
name|mmin
operator|<
name|MANDOCERR_STYLE
condition|)
name|check_xr
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|mparse_updaterc
argument_list|(
name|curp
operator|->
name|mp
argument_list|,
operator|&
name|rc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_xr
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|)
block|{
specifier|static
name|struct
name|manpaths
name|paths
decl_stmt|;
name|struct
name|mansearch
name|search
decl_stmt|;
name|struct
name|mandoc_xr
modifier|*
name|xr
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
if|if
condition|(
name|paths
operator|.
name|sz
operator|==
literal|0
condition|)
name|manpath_base
argument_list|(
operator|&
name|paths
argument_list|)
expr_stmt|;
for|for
control|(
name|xr
operator|=
name|mandoc_xr_get
argument_list|()
init|;
name|xr
operator|!=
name|NULL
condition|;
name|xr
operator|=
name|xr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|xr
operator|->
name|line
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|search
operator|.
name|arch
operator|=
name|NULL
expr_stmt|;
name|search
operator|.
name|sec
operator|=
name|xr
operator|->
name|sec
expr_stmt|;
name|search
operator|.
name|outkey
operator|=
name|NULL
expr_stmt|;
name|search
operator|.
name|argmode
operator|=
name|ARG_NAME
expr_stmt|;
name|search
operator|.
name|firstmatch
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mansearch
argument_list|(
operator|&
name|search
argument_list|,
operator|&
name|paths
argument_list|,
literal|1
argument_list|,
operator|&
name|xr
operator|->
name|name
argument_list|,
name|NULL
argument_list|,
operator|&
name|sz
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|fs_search
argument_list|(
operator|&
name|search
argument_list|,
operator|&
name|paths
argument_list|,
literal|1
argument_list|,
operator|&
name|xr
operator|->
name|name
argument_list|,
name|NULL
argument_list|,
operator|&
name|sz
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|xr
operator|->
name|count
operator|==
literal|1
condition|)
name|mandoc_asprintf
argument_list|(
operator|&
name|cp
argument_list|,
literal|"Xr %s %s"
argument_list|,
name|xr
operator|->
name|name
argument_list|,
name|xr
operator|->
name|sec
argument_list|)
expr_stmt|;
else|else
name|mandoc_asprintf
argument_list|(
operator|&
name|cp
argument_list|,
literal|"Xr %s %s (%d times)"
argument_list|,
name|xr
operator|->
name|name
argument_list|,
name|xr
operator|->
name|sec
argument_list|,
name|xr
operator|->
name|count
argument_list|)
expr_stmt|;
name|mmsg
argument_list|(
name|MANDOCERR_XR_BAD
argument_list|,
name|MANDOCLEVEL_STYLE
argument_list|,
name|file
argument_list|,
name|xr
operator|->
name|line
argument_list|,
name|xr
operator|->
name|pos
operator|+
literal|1
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|outdata_alloc
parameter_list|(
name|struct
name|curparse
modifier|*
name|curp
parameter_list|)
block|{
switch|switch
condition|(
name|curp
operator|->
name|outtype
condition|)
block|{
case|case
name|OUTT_HTML
case|:
name|curp
operator|->
name|outdata
operator|=
name|html_alloc
argument_list|(
name|curp
operator|->
name|outopts
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUTT_UTF8
case|:
name|curp
operator|->
name|outdata
operator|=
name|utf8_alloc
argument_list|(
name|curp
operator|->
name|outopts
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUTT_LOCALE
case|:
name|curp
operator|->
name|outdata
operator|=
name|locale_alloc
argument_list|(
name|curp
operator|->
name|outopts
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUTT_ASCII
case|:
name|curp
operator|->
name|outdata
operator|=
name|ascii_alloc
argument_list|(
name|curp
operator|->
name|outopts
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUTT_PDF
case|:
name|curp
operator|->
name|outdata
operator|=
name|pdf_alloc
argument_list|(
name|curp
operator|->
name|outopts
argument_list|)
expr_stmt|;
break|break;
case|case
name|OUTT_PS
case|:
name|curp
operator|->
name|outdata
operator|=
name|ps_alloc
argument_list|(
name|curp
operator|->
name|outopts
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|passthrough
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|synopsis_only
parameter_list|)
block|{
specifier|const
name|char
name|synb
index|[]
init|=
literal|"S\bSY\bYN\bNO\bOP\bPS\bSI\bIS\bS"
decl_stmt|;
specifier|const
name|char
name|synr
index|[]
init|=
literal|"SYNOPSIS"
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
specifier|const
name|char
modifier|*
name|syscall
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|size_t
name|linesz
decl_stmt|;
name|ssize_t
name|len
decl_stmt|,
name|written
decl_stmt|;
name|int
name|print
decl_stmt|;
name|line
operator|=
name|NULL
expr_stmt|;
name|linesz
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fflush
argument_list|(
name|stdout
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|syscall
operator|=
literal|"fflush"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|(
name|stream
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|syscall
operator|=
literal|"fdopen"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|print
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|len
operator|=
name|getline
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|linesz
argument_list|,
name|stream
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|cp
operator|=
name|line
expr_stmt|;
if|if
condition|(
name|synopsis_only
condition|)
block|{
if|if
condition|(
name|print
condition|)
block|{
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
goto|goto
name|done
goto|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
name|cp
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
name|synb
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|cp
argument_list|,
name|synr
argument_list|)
operator|==
literal|0
condition|)
name|print
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|-=
name|written
control|)
block|{
if|if
condition|(
operator|(
name|written
operator|=
name|write
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
continue|continue;
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|syscall
operator|=
literal|"write"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
if|if
condition|(
name|ferror
argument_list|(
name|stream
argument_list|)
condition|)
block|{
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|syscall
operator|=
literal|"getline"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|done
label|:
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return;
name|fail
label|:
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|warn
argument_list|(
literal|"%s: SYSERR: %s"
argument_list|,
name|file
argument_list|,
name|syscall
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
name|MANDOCLEVEL_SYSERR
condition|)
name|rc
operator|=
name|MANDOCLEVEL_SYSERR
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|koptions
parameter_list|(
name|int
modifier|*
name|options
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"utf-8"
argument_list|)
condition|)
block|{
operator|*
name|options
operator||=
name|MPARSE_UTF8
expr_stmt|;
operator|*
name|options
operator|&=
operator|~
name|MPARSE_LATIN1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"iso-8859-1"
argument_list|)
condition|)
block|{
operator|*
name|options
operator||=
name|MPARSE_LATIN1
expr_stmt|;
operator|*
name|options
operator|&=
operator|~
name|MPARSE_UTF8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"us-ascii"
argument_list|)
condition|)
block|{
operator|*
name|options
operator|&=
operator|~
operator|(
name|MPARSE_UTF8
operator||
name|MPARSE_LATIN1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"-K %s: Bad argument"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|moptions
parameter_list|(
name|int
modifier|*
name|options
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"doc"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|options
operator||=
name|MPARSE_MDOC
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"an"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|options
operator||=
name|MPARSE_MAN
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|toptions
parameter_list|(
name|struct
name|curparse
modifier|*
name|curp
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"ascii"
argument_list|)
condition|)
name|curp
operator|->
name|outtype
operator|=
name|OUTT_ASCII
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"lint"
argument_list|)
condition|)
block|{
name|curp
operator|->
name|outtype
operator|=
name|OUTT_LINT
expr_stmt|;
name|curp
operator|->
name|mmin
operator|=
name|MANDOCERR_BASE
expr_stmt|;
name|mmsg_stream
operator|=
name|stdout
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"tree"
argument_list|)
condition|)
name|curp
operator|->
name|outtype
operator|=
name|OUTT_TREE
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"man"
argument_list|)
condition|)
name|curp
operator|->
name|outtype
operator|=
name|OUTT_MAN
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"html"
argument_list|)
condition|)
name|curp
operator|->
name|outtype
operator|=
name|OUTT_HTML
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"markdown"
argument_list|)
condition|)
name|curp
operator|->
name|outtype
operator|=
name|OUTT_MARKDOWN
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"utf8"
argument_list|)
condition|)
name|curp
operator|->
name|outtype
operator|=
name|OUTT_UTF8
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"locale"
argument_list|)
condition|)
name|curp
operator|->
name|outtype
operator|=
name|OUTT_LOCALE
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"ps"
argument_list|)
condition|)
name|curp
operator|->
name|outtype
operator|=
name|OUTT_PS
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"pdf"
argument_list|)
condition|)
name|curp
operator|->
name|outtype
operator|=
name|OUTT_PDF
expr_stmt|;
else|else
block|{
name|warnx
argument_list|(
literal|"-T %s: Bad argument"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|woptions
parameter_list|(
name|struct
name|curparse
modifier|*
name|curp
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|char
modifier|*
name|v
decl_stmt|,
modifier|*
name|o
decl_stmt|;
specifier|const
name|char
modifier|*
name|toks
index|[
literal|11
index|]
decl_stmt|;
name|toks
index|[
literal|0
index|]
operator|=
literal|"stop"
expr_stmt|;
name|toks
index|[
literal|1
index|]
operator|=
literal|"all"
expr_stmt|;
name|toks
index|[
literal|2
index|]
operator|=
literal|"base"
expr_stmt|;
name|toks
index|[
literal|3
index|]
operator|=
literal|"style"
expr_stmt|;
name|toks
index|[
literal|4
index|]
operator|=
literal|"warning"
expr_stmt|;
name|toks
index|[
literal|5
index|]
operator|=
literal|"error"
expr_stmt|;
name|toks
index|[
literal|6
index|]
operator|=
literal|"unsupp"
expr_stmt|;
name|toks
index|[
literal|7
index|]
operator|=
literal|"fatal"
expr_stmt|;
name|toks
index|[
literal|8
index|]
operator|=
literal|"openbsd"
expr_stmt|;
name|toks
index|[
literal|9
index|]
operator|=
literal|"netbsd"
expr_stmt|;
name|toks
index|[
literal|10
index|]
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|*
name|arg
condition|)
block|{
name|o
operator|=
name|arg
expr_stmt|;
switch|switch
condition|(
name|getsubopt
argument_list|(
operator|&
name|arg
argument_list|,
operator|(
name|char
operator|*
specifier|const
operator|*
operator|)
name|toks
argument_list|,
operator|&
name|v
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|curp
operator|->
name|wstop
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|1
case|:
case|case
literal|2
case|:
name|curp
operator|->
name|mmin
operator|=
name|MANDOCERR_BASE
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|curp
operator|->
name|mmin
operator|=
name|MANDOCERR_STYLE
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|curp
operator|->
name|mmin
operator|=
name|MANDOCERR_WARNING
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|curp
operator|->
name|mmin
operator|=
name|MANDOCERR_ERROR
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|curp
operator|->
name|mmin
operator|=
name|MANDOCERR_UNSUPP
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|curp
operator|->
name|mmin
operator|=
name|MANDOCERR_MAX
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|curp
operator|->
name|mmin
operator|=
name|MANDOCERR_BASE
expr_stmt|;
name|curp
operator|->
name|os_e
operator|=
name|MANDOC_OS_OPENBSD
expr_stmt|;
break|break;
case|case
literal|9
case|:
name|curp
operator|->
name|mmin
operator|=
name|MANDOCERR_BASE
expr_stmt|;
name|curp
operator|->
name|os_e
operator|=
name|MANDOC_OS_NETBSD
expr_stmt|;
break|break;
default|default:
name|warnx
argument_list|(
literal|"-W %s: Bad argument"
argument_list|,
name|o
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mmsg
parameter_list|(
name|enum
name|mandocerr
name|t
parameter_list|,
name|enum
name|mandoclevel
name|lvl
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|col
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|mparse_msg
decl_stmt|;
name|fprintf
argument_list|(
name|mmsg_stream
argument_list|,
literal|"%s: %s:"
argument_list|,
name|getprogname
argument_list|()
argument_list|,
name|file
operator|==
name|NULL
condition|?
literal|"<stdin>"
else|:
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
condition|)
name|fprintf
argument_list|(
name|mmsg_stream
argument_list|,
literal|"%d:%d:"
argument_list|,
name|line
argument_list|,
name|col
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|mmsg_stream
argument_list|,
literal|" %s"
argument_list|,
name|mparse_strlevel
argument_list|(
name|lvl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mparse_msg
operator|=
name|mparse_strerror
argument_list|(
name|t
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|mmsg_stream
argument_list|,
literal|": %s"
argument_list|,
name|mparse_msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
condition|)
name|fprintf
argument_list|(
name|mmsg_stream
argument_list|,
literal|": %s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|mmsg_stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|pid_t
name|spawn_pager
parameter_list|(
name|struct
name|tag_files
modifier|*
name|tag_files
parameter_list|)
block|{
specifier|const
name|struct
name|timespec
name|timeout
init|=
block|{
literal|0
block|,
literal|100000000
block|}
decl_stmt|;
comment|/* 0.1s */
define|#
directive|define
name|MAX_PAGER_ARGS
value|16
name|char
modifier|*
name|argv
index|[
name|MAX_PAGER_ARGS
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|pager
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|size_t
name|cmdlen
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|pid_t
name|pager_pid
decl_stmt|;
name|pager
operator|=
name|getenv
argument_list|(
literal|"MANPAGER"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pager
operator|==
name|NULL
operator|||
operator|*
name|pager
operator|==
literal|'\0'
condition|)
name|pager
operator|=
name|getenv
argument_list|(
literal|"PAGER"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pager
operator|==
name|NULL
operator|||
operator|*
name|pager
operator|==
literal|'\0'
condition|)
name|pager
operator|=
literal|"more -s"
expr_stmt|;
name|cp
operator|=
name|mandoc_strdup
argument_list|(
name|pager
argument_list|)
expr_stmt|;
comment|/* 	 * Parse the pager command into words. 	 * Intentionally do not do anything fancy here. 	 */
name|argc
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|argc
operator|+
literal|4
operator|<
name|MAX_PAGER_ARGS
condition|)
block|{
name|argv
index|[
name|argc
operator|++
index|]
operator|=
name|cp
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
break|break;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|==
literal|' '
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
break|break;
block|}
comment|/* For less(1), use the tag file. */
if|if
condition|(
operator|(
name|cmdlen
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|)
operator|>=
literal|4
condition|)
block|{
name|cp
operator|=
name|argv
index|[
literal|0
index|]
operator|+
name|cmdlen
operator|-
literal|4
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"less"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|argv
index|[
name|argc
operator|++
index|]
operator|=
name|mandoc_strdup
argument_list|(
literal|"-T"
argument_list|)
expr_stmt|;
name|argv
index|[
name|argc
operator|++
index|]
operator|=
name|tag_files
operator|->
name|tfn
expr_stmt|;
block|}
block|}
name|argv
index|[
name|argc
operator|++
index|]
operator|=
name|tag_files
operator|->
name|ofn
expr_stmt|;
name|argv
index|[
name|argc
index|]
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|pager_pid
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|err
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
argument_list|,
literal|"fork"
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
break|break;
default|default:
operator|(
name|void
operator|)
name|setpgid
argument_list|(
name|pager_pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|tcsetpgrp
argument_list|(
name|tag_files
operator|->
name|ofd
argument_list|,
name|pager_pid
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_PLEDGE
if|if
condition|(
name|pledge
argument_list|(
literal|"stdio rpath tmppath tty proc"
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
argument_list|,
literal|"pledge"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tag_files
operator|->
name|pager_pid
operator|=
name|pager_pid
expr_stmt|;
return|return
name|pager_pid
return|;
block|}
comment|/* The child process becomes the pager. */
if|if
condition|(
name|dup2
argument_list|(
name|tag_files
operator|->
name|ofd
argument_list|,
name|STDOUT_FILENO
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
argument_list|,
literal|"pager stdout"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|tag_files
operator|->
name|ofd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|tag_files
operator|->
name|tfd
argument_list|)
expr_stmt|;
comment|/* Do not start the pager before controlling the terminal. */
while|while
condition|(
name|tcgetpgrp
argument_list|(
name|STDOUT_FILENO
argument_list|)
operator|!=
name|getpid
argument_list|()
condition|)
name|nanosleep
argument_list|(
operator|&
name|timeout
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|execvp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|err
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
argument_list|,
literal|"exec %s"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

