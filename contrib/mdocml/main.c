begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$Id: main.c,v 1.225 2015/03/10 13:50:03 schwarze Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2008-2012 Kristaps Dzonsons<kristaps@bsd.lv>  * Copyright (c) 2010-2012, 2014, 2015 Ingo Schwarze<schwarze@openbsd.org>  * Copyright (c) 2010 Joerg Sonnenberger<joerg@netbsd.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_comment
comment|/* MACHINE */
end_comment

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<glob.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"mandoc.h"
end_include

begin_include
include|#
directive|include
file|"mandoc_aux.h"
end_include

begin_include
include|#
directive|include
file|"main.h"
end_include

begin_include
include|#
directive|include
file|"mdoc.h"
end_include

begin_include
include|#
directive|include
file|"man.h"
end_include

begin_include
include|#
directive|include
file|"manpath.h"
end_include

begin_include
include|#
directive|include
file|"mansearch.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|||
operator|(
name|__GNUC__
operator|<
literal|2
operator|)
end_if

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_define
define|#
directive|define
name|__attribute__
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(__GNUC__) || (__GNUC__< 2) */
end_comment

begin_enum
enum|enum
name|outmode
block|{
name|OUTMODE_DEF
init|=
literal|0
block|,
name|OUTMODE_FLN
block|,
name|OUTMODE_LST
block|,
name|OUTMODE_ALL
block|,
name|OUTMODE_INT
block|,
name|OUTMODE_ONE
block|}
enum|;
end_enum

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|out_mdoc
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
specifier|const
name|struct
name|mdoc
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|out_man
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
specifier|const
name|struct
name|man
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|out_free
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_enum
enum|enum
name|outt
block|{
name|OUTT_ASCII
init|=
literal|0
block|,
comment|/* -Tascii */
name|OUTT_LOCALE
block|,
comment|/* -Tlocale */
name|OUTT_UTF8
block|,
comment|/* -Tutf8 */
name|OUTT_TREE
block|,
comment|/* -Ttree */
name|OUTT_MAN
block|,
comment|/* -Tman */
name|OUTT_HTML
block|,
comment|/* -Thtml */
name|OUTT_LINT
block|,
comment|/* -Tlint */
name|OUTT_PS
block|,
comment|/* -Tps */
name|OUTT_PDF
comment|/* -Tpdf */
block|}
enum|;
end_enum

begin_struct
struct|struct
name|curparse
block|{
name|struct
name|mparse
modifier|*
name|mp
decl_stmt|;
name|struct
name|mchars
modifier|*
name|mchars
decl_stmt|;
comment|/* character table */
name|enum
name|mandoclevel
name|wlevel
decl_stmt|;
comment|/* ignore messages below this */
name|int
name|wstop
decl_stmt|;
comment|/* stop after a file with a warning */
name|enum
name|outt
name|outtype
decl_stmt|;
comment|/* which output to use */
name|out_mdoc
name|outmdoc
decl_stmt|;
comment|/* mdoc output ptr */
name|out_man
name|outman
decl_stmt|;
comment|/* man output ptr */
name|out_free
name|outfree
decl_stmt|;
comment|/* free output ptr */
name|void
modifier|*
name|outdata
decl_stmt|;
comment|/* data for output */
name|char
name|outopts
index|[
name|BUFSIZ
index|]
decl_stmt|;
comment|/* buf of output opts */
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|fs_lookup
parameter_list|(
specifier|const
name|struct
name|manpaths
modifier|*
parameter_list|,
name|size_t
name|ipath
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|manpage
modifier|*
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fs_search
parameter_list|(
specifier|const
name|struct
name|mansearch
modifier|*
parameter_list|,
specifier|const
name|struct
name|manpaths
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|struct
name|manpage
modifier|*
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|koptions
parameter_list|(
name|int
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|HAVE_SQLITE3
end_if

begin_function_decl
name|int
name|mandocdb
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|moptions
parameter_list|(
name|int
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mmsg
parameter_list|(
name|enum
name|mandocerr
parameter_list|,
name|enum
name|mandoclevel
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse
parameter_list|(
name|struct
name|curparse
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|enum
name|mandoclevel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|mandoclevel
name|passthrough
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pid_t
name|spawn_pager
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|toptions
parameter_list|(
name|struct
name|curparse
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|enum
name|argmode
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(noreturn
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|int
name|woptions
parameter_list|(
name|struct
name|curparse
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|int
name|sec_prios
index|[]
init|=
block|{
literal|1
block|,
literal|4
block|,
literal|5
block|,
literal|8
block|,
literal|6
block|,
literal|3
block|,
literal|7
block|,
literal|2
block|,
literal|9
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|help_arg
index|[]
init|=
literal|"help"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|help_argv
index|[]
init|=
block|{
name|help_arg
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|struct
name|curparse
name|curp
decl_stmt|;
name|struct
name|mansearch
name|search
decl_stmt|;
name|struct
name|manpaths
name|paths
decl_stmt|;
name|char
modifier|*
name|auxpaths
decl_stmt|;
name|char
modifier|*
name|defos
decl_stmt|;
name|unsigned
name|char
modifier|*
name|uc
decl_stmt|;
name|struct
name|manpage
modifier|*
name|res
decl_stmt|,
modifier|*
name|resp
decl_stmt|;
name|char
modifier|*
name|conf_file
decl_stmt|,
modifier|*
name|defpaths
decl_stmt|;
name|size_t
name|isec
decl_stmt|,
name|i
decl_stmt|,
name|sz
decl_stmt|;
name|int
name|prio
decl_stmt|,
name|best_prio
decl_stmt|,
name|synopsis_only
decl_stmt|;
name|char
name|sec
decl_stmt|;
name|enum
name|mandoclevel
name|rc
decl_stmt|,
name|rctmp
decl_stmt|;
name|enum
name|outmode
name|outmode
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|show_usage
decl_stmt|;
name|int
name|options
decl_stmt|;
name|int
name|c
decl_stmt|;
name|pid_t
name|pager_pid
decl_stmt|;
comment|/* 0: don't use; 1: not yet spawned. */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
name|progname
operator|=
literal|"mandoc"
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|progname
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
else|else
operator|++
name|progname
expr_stmt|;
if|#
directive|if
name|HAVE_SQLITE3
if|if
condition|(
name|strcmp
argument_list|(
name|progname
argument_list|,
name|BINM_MAKEWHATIS
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|mandocdb
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
operator|)
return|;
endif|#
directive|endif
comment|/* Search options. */
name|memset
argument_list|(
operator|&
name|paths
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|manpaths
argument_list|)
argument_list|)
expr_stmt|;
name|conf_file
operator|=
name|defpaths
operator|=
name|NULL
expr_stmt|;
name|auxpaths
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|search
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mansearch
argument_list|)
argument_list|)
expr_stmt|;
name|search
operator|.
name|outkey
operator|=
literal|"Nd"
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|progname
argument_list|,
name|BINM_MAN
argument_list|)
operator|==
literal|0
condition|)
name|search
operator|.
name|argmode
operator|=
name|ARG_NAME
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|progname
argument_list|,
name|BINM_APROPOS
argument_list|)
operator|==
literal|0
condition|)
name|search
operator|.
name|argmode
operator|=
name|ARG_EXPR
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|progname
argument_list|,
name|BINM_WHATIS
argument_list|)
operator|==
literal|0
condition|)
name|search
operator|.
name|argmode
operator|=
name|ARG_WORD
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|progname
argument_list|,
literal|"help"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|search
operator|.
name|argmode
operator|=
name|ARG_NAME
expr_stmt|;
else|else
name|search
operator|.
name|argmode
operator|=
name|ARG_FILE
expr_stmt|;
comment|/* Parser and formatter options. */
name|memset
argument_list|(
operator|&
name|curp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|curparse
argument_list|)
argument_list|)
expr_stmt|;
name|curp
operator|.
name|outtype
operator|=
name|OUTT_LOCALE
expr_stmt|;
name|curp
operator|.
name|wlevel
operator|=
name|MANDOCLEVEL_BADARG
expr_stmt|;
name|options
operator|=
name|MPARSE_SO
operator||
name|MPARSE_UTF8
operator||
name|MPARSE_LATIN1
expr_stmt|;
name|defos
operator|=
name|NULL
expr_stmt|;
name|pager_pid
operator|=
literal|1
expr_stmt|;
name|show_usage
operator|=
literal|0
expr_stmt|;
name|synopsis_only
operator|=
literal|0
expr_stmt|;
name|outmode
operator|=
name|OUTMODE_DEF
expr_stmt|;
while|while
condition|(
operator|-
literal|1
operator|!=
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"aC:cfhI:iK:klM:m:O:S:s:T:VW:w"
argument_list|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|outmode
operator|=
name|OUTMODE_ALL
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|conf_file
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|pager_pid
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|search
operator|.
name|argmode
operator|=
name|ARG_WORD
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|curp
operator|.
name|outopts
argument_list|,
literal|"synopsis,"
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
name|synopsis_only
operator|=
literal|1
expr_stmt|;
name|pager_pid
operator|=
literal|0
expr_stmt|;
name|outmode
operator|=
name|OUTMODE_ALL
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|optarg
argument_list|,
literal|"os="
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: -I %s: Bad argument\n"
argument_list|,
name|progname
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_BADARG
operator|)
return|;
block|}
if|if
condition|(
name|defos
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: -I %s: Duplicate argument\n"
argument_list|,
name|progname
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_BADARG
operator|)
return|;
block|}
name|defos
operator|=
name|mandoc_strdup
argument_list|(
name|optarg
operator|+
literal|3
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|outmode
operator|=
name|OUTMODE_INT
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
if|if
condition|(
operator|!
name|koptions
argument_list|(
operator|&
name|options
argument_list|,
name|optarg
argument_list|)
condition|)
return|return
operator|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_BADARG
operator|)
return|;
break|break;
case|case
literal|'k'
case|:
name|search
operator|.
name|argmode
operator|=
name|ARG_EXPR
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|search
operator|.
name|argmode
operator|=
name|ARG_FILE
expr_stmt|;
name|outmode
operator|=
name|OUTMODE_ALL
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|defpaths
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|auxpaths
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|search
operator|.
name|outkey
operator|=
name|optarg
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|curp
operator|.
name|outopts
argument_list|,
name|optarg
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|curp
operator|.
name|outopts
argument_list|,
literal|","
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|search
operator|.
name|arch
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|search
operator|.
name|sec
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
if|if
condition|(
operator|!
name|toptions
argument_list|(
operator|&
name|curp
argument_list|,
name|optarg
argument_list|)
condition|)
return|return
operator|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_BADARG
operator|)
return|;
break|break;
case|case
literal|'W'
case|:
if|if
condition|(
operator|!
name|woptions
argument_list|(
operator|&
name|curp
argument_list|,
name|optarg
argument_list|)
condition|)
return|return
operator|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_BADARG
operator|)
return|;
break|break;
case|case
literal|'w'
case|:
name|outmode
operator|=
name|OUTMODE_FLN
expr_stmt|;
break|break;
default|default:
name|show_usage
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|show_usage
condition|)
name|usage
argument_list|(
name|search
operator|.
name|argmode
argument_list|)
expr_stmt|;
comment|/* Postprocess options. */
if|if
condition|(
name|outmode
operator|==
name|OUTMODE_DEF
condition|)
block|{
switch|switch
condition|(
name|search
operator|.
name|argmode
condition|)
block|{
case|case
name|ARG_FILE
case|:
name|outmode
operator|=
name|OUTMODE_ALL
expr_stmt|;
name|pager_pid
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ARG_NAME
case|:
name|outmode
operator|=
name|OUTMODE_ONE
expr_stmt|;
break|break;
default|default:
name|outmode
operator|=
name|OUTMODE_LST
expr_stmt|;
break|break;
block|}
block|}
comment|/* Parse arguments. */
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
block|}
name|resp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Quirks for help(1) 	 * and for a man(1) section argument without -s. 	 */
if|if
condition|(
name|search
operator|.
name|argmode
operator|==
name|ARG_NAME
condition|)
block|{
if|if
condition|(
operator|*
name|progname
operator|==
literal|'h'
condition|)
block|{
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
name|argv
operator|=
name|help_argv
expr_stmt|;
name|argc
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|argc
operator|>
literal|1
operator|&&
operator|(
operator|(
name|uc
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|argv
index|[
literal|0
index|]
operator|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|isdigit
argument_list|(
name|uc
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|(
name|uc
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|isalpha
argument_list|(
name|uc
index|[
literal|1
index|]
argument_list|)
operator|&&
name|uc
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
operator|)
operator|)
operator|||
operator|(
name|uc
index|[
literal|0
index|]
operator|==
literal|'n'
operator|&&
name|uc
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
operator|)
condition|)
block|{
name|search
operator|.
name|sec
operator|=
operator|(
name|char
operator|*
operator|)
name|uc
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|search
operator|.
name|arch
operator|==
name|NULL
condition|)
name|search
operator|.
name|arch
operator|=
name|getenv
argument_list|(
literal|"MACHINE"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MACHINE
if|if
condition|(
name|search
operator|.
name|arch
operator|==
name|NULL
condition|)
name|search
operator|.
name|arch
operator|=
name|MACHINE
expr_stmt|;
endif|#
directive|endif
block|}
name|rc
operator|=
name|MANDOCLEVEL_OK
expr_stmt|;
comment|/* man(1), whatis(1), apropos(1) */
if|if
condition|(
name|search
operator|.
name|argmode
operator|!=
name|ARG_FILE
condition|)
block|{
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
name|usage
argument_list|(
name|search
operator|.
name|argmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|search
operator|.
name|argmode
operator|==
name|ARG_NAME
operator|&&
name|outmode
operator|==
name|OUTMODE_ONE
condition|)
name|search
operator|.
name|firstmatch
operator|=
literal|1
expr_stmt|;
comment|/* Access the mandoc database. */
name|manpath_parse
argument_list|(
operator|&
name|paths
argument_list|,
name|conf_file
argument_list|,
name|defpaths
argument_list|,
name|auxpaths
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_SQLITE3
name|mansearch_setup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mansearch
argument_list|(
operator|&
name|search
argument_list|,
operator|&
name|paths
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|res
argument_list|,
operator|&
name|sz
argument_list|)
condition|)
name|usage
argument_list|(
name|search
operator|.
name|argmode
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|search
operator|.
name|argmode
operator|!=
name|ARG_NAME
condition|)
block|{
name|fputs
argument_list|(
literal|"mandoc: database support not compiled in\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_BADARG
operator|)
return|;
block|}
name|sz
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sz
operator|==
literal|0
operator|&&
name|search
operator|.
name|argmode
operator|==
name|ARG_NAME
condition|)
name|fs_search
argument_list|(
operator|&
name|search
argument_list|,
operator|&
name|paths
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|res
argument_list|,
operator|&
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|sz
operator|==
literal|0
condition|)
block|{
name|rc
operator|=
name|MANDOCLEVEL_BADARG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 		 * For standard man(1) and -a output mode, 		 * prepare for copying filename pointers 		 * into the program parameter array. 		 */
if|if
condition|(
name|outmode
operator|==
name|OUTMODE_ONE
condition|)
block|{
name|argc
operator|=
literal|1
expr_stmt|;
name|best_prio
operator|=
literal|10
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|outmode
operator|==
name|OUTMODE_ALL
condition|)
name|argc
operator|=
operator|(
name|int
operator|)
name|sz
expr_stmt|;
comment|/* Iterate all matching manuals. */
name|resp
operator|=
name|res
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|outmode
operator|==
name|OUTMODE_FLN
condition|)
name|puts
argument_list|(
name|res
index|[
name|i
index|]
operator|.
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|outmode
operator|==
name|OUTMODE_LST
condition|)
name|printf
argument_list|(
literal|"%s - %s\n"
argument_list|,
name|res
index|[
name|i
index|]
operator|.
name|names
argument_list|,
name|res
index|[
name|i
index|]
operator|.
name|output
operator|==
name|NULL
condition|?
literal|""
else|:
name|res
index|[
name|i
index|]
operator|.
name|output
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|outmode
operator|==
name|OUTMODE_ONE
condition|)
block|{
comment|/* Search for the best section. */
name|isec
operator|=
name|strcspn
argument_list|(
name|res
index|[
name|i
index|]
operator|.
name|file
argument_list|,
literal|"123456789"
argument_list|)
expr_stmt|;
name|sec
operator|=
name|res
index|[
name|i
index|]
operator|.
name|file
index|[
name|isec
index|]
expr_stmt|;
if|if
condition|(
literal|'\0'
operator|==
name|sec
condition|)
continue|continue;
name|prio
operator|=
name|sec_prios
index|[
name|sec
operator|-
literal|'1'
index|]
expr_stmt|;
if|if
condition|(
name|prio
operator|>=
name|best_prio
condition|)
continue|continue;
name|best_prio
operator|=
name|prio
expr_stmt|;
name|resp
operator|=
name|res
operator|+
name|i
expr_stmt|;
block|}
block|}
comment|/* 		 * For man(1), -a and -i output mode, fall through 		 * to the main mandoc(1) code iterating files 		 * and running the parsers on each of them. 		 */
if|if
condition|(
name|outmode
operator|==
name|OUTMODE_FLN
operator|||
name|outmode
operator|==
name|OUTMODE_LST
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* mandoc(1) */
if|if
condition|(
name|search
operator|.
name|argmode
operator|==
name|ARG_FILE
operator|&&
operator|!
name|moptions
argument_list|(
operator|&
name|options
argument_list|,
name|auxpaths
argument_list|)
condition|)
return|return
operator|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_BADARG
operator|)
return|;
name|curp
operator|.
name|mchars
operator|=
name|mchars_alloc
argument_list|()
expr_stmt|;
name|curp
operator|.
name|mp
operator|=
name|mparse_alloc
argument_list|(
name|options
argument_list|,
name|curp
operator|.
name|wlevel
argument_list|,
name|mmsg
argument_list|,
name|curp
operator|.
name|mchars
argument_list|,
name|defos
argument_list|)
expr_stmt|;
comment|/* 	 * Conditionally start up the lookaside buffer before parsing. 	 */
if|if
condition|(
name|OUTT_MAN
operator|==
name|curp
operator|.
name|outtype
condition|)
name|mparse_keep
argument_list|(
name|curp
operator|.
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
if|if
condition|(
name|pager_pid
operator|==
literal|1
operator|&&
name|isatty
argument_list|(
name|STDOUT_FILENO
argument_list|)
condition|)
name|pager_pid
operator|=
name|spawn_pager
argument_list|()
expr_stmt|;
name|parse
argument_list|(
operator|&
name|curp
argument_list|,
name|STDIN_FILENO
argument_list|,
literal|"<stdin>"
argument_list|,
operator|&
name|rc
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
name|rctmp
operator|=
name|mparse_open
argument_list|(
name|curp
operator|.
name|mp
argument_list|,
operator|&
name|fd
argument_list|,
name|resp
operator|!=
name|NULL
condition|?
name|resp
operator|->
name|file
else|:
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
name|rctmp
condition|)
name|rc
operator|=
name|rctmp
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|pager_pid
operator|==
literal|1
operator|&&
name|isatty
argument_list|(
name|STDOUT_FILENO
argument_list|)
condition|)
name|pager_pid
operator|=
name|spawn_pager
argument_list|()
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
name|parse
argument_list|(
operator|&
name|curp
argument_list|,
name|fd
argument_list|,
operator|*
name|argv
argument_list|,
operator|&
name|rc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|resp
operator|->
name|form
operator|&
name|FORM_SRC
condition|)
block|{
comment|/* For .so only; ignore failure. */
name|chdir
argument_list|(
name|paths
operator|.
name|paths
index|[
name|resp
operator|->
name|ipath
index|]
argument_list|)
expr_stmt|;
name|parse
argument_list|(
operator|&
name|curp
argument_list|,
name|fd
argument_list|,
name|resp
operator|->
name|file
argument_list|,
operator|&
name|rc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rctmp
operator|=
name|passthrough
argument_list|(
name|resp
operator|->
name|file
argument_list|,
name|fd
argument_list|,
name|synopsis_only
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
name|rctmp
condition|)
name|rc
operator|=
name|rctmp
expr_stmt|;
block|}
name|rctmp
operator|=
name|mparse_wait
argument_list|(
name|curp
operator|.
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
name|rctmp
condition|)
name|rc
operator|=
name|rctmp
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
operator|&&
name|curp
operator|.
name|outtype
operator|<=
name|OUTT_UTF8
condition|)
name|ascii_sepline
argument_list|(
name|curp
operator|.
name|outdata
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|MANDOCLEVEL_OK
operator|!=
name|rc
operator|&&
name|curp
operator|.
name|wstop
condition|)
break|break;
if|if
condition|(
name|resp
operator|!=
name|NULL
condition|)
name|resp
operator|++
expr_stmt|;
else|else
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|--
name|argc
condition|)
name|mparse_reset
argument_list|(
name|curp
operator|.
name|mp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|curp
operator|.
name|outfree
condition|)
call|(
modifier|*
name|curp
operator|.
name|outfree
call|)
argument_list|(
name|curp
operator|.
name|outdata
argument_list|)
expr_stmt|;
name|mparse_free
argument_list|(
name|curp
operator|.
name|mp
argument_list|)
expr_stmt|;
name|mchars_free
argument_list|(
name|curp
operator|.
name|mchars
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|search
operator|.
name|argmode
operator|!=
name|ARG_FILE
condition|)
block|{
name|manpath_free
argument_list|(
operator|&
name|paths
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_SQLITE3
name|mansearch_free
argument_list|(
name|res
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|mansearch_setup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|free
argument_list|(
name|defos
argument_list|)
expr_stmt|;
comment|/* 	 * If a pager is attached, flush the pipe leading to it 	 * and signal end of file such that the user can browse 	 * to the end.  Then wait for the user to close the pager. 	 */
if|if
condition|(
name|pager_pid
operator|!=
literal|0
operator|&&
name|pager_pid
operator|!=
literal|1
condition|)
block|{
name|fclose
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|waitpid
argument_list|(
name|pager_pid
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|int
operator|)
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|enum
name|argmode
name|argmode
parameter_list|)
block|{
switch|switch
condition|(
name|argmode
condition|)
block|{
case|case
name|ARG_FILE
case|:
name|fputs
argument_list|(
literal|"usage: mandoc [-acfhkl] [-Ios=name] "
literal|"[-Kencoding] [-mformat] [-Ooption]\n"
literal|"\t      [-Toutput] [-Wlevel] [file ...]\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARG_NAME
case|:
name|fputs
argument_list|(
literal|"usage: man [-acfhklw] [-C file] [-I os=name] "
literal|"[-K encoding] [-M path] [-m path]\n"
literal|"\t   [-O option=value] [-S subsection] [-s section] "
literal|"[-T output] [-W level]\n"
literal|"\t   [section] name ...\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARG_WORD
case|:
name|fputs
argument_list|(
literal|"usage: whatis [-acfhklw] [-C file] "
literal|"[-M path] [-m path] [-O outkey] [-S arch]\n"
literal|"\t      [-s section] name ...\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARG_EXPR
case|:
name|fputs
argument_list|(
literal|"usage: apropos [-acfhklw] [-C file] "
literal|"[-M path] [-m path] [-O outkey] [-S arch]\n"
literal|"\t       [-s section] expression ...\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
block|}
name|exit
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_BADARG
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fs_lookup
parameter_list|(
specifier|const
name|struct
name|manpaths
modifier|*
name|paths
parameter_list|,
name|size_t
name|ipath
parameter_list|,
specifier|const
name|char
modifier|*
name|sec
parameter_list|,
specifier|const
name|char
modifier|*
name|arch
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|manpage
modifier|*
modifier|*
name|res
parameter_list|,
name|size_t
modifier|*
name|ressz
parameter_list|)
block|{
name|glob_t
name|globinfo
decl_stmt|;
name|struct
name|manpage
modifier|*
name|page
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|form
decl_stmt|,
name|globres
decl_stmt|;
name|form
operator|=
name|FORM_SRC
expr_stmt|;
name|mandoc_asprintf
argument_list|(
operator|&
name|file
argument_list|,
literal|"%s/man%s/%s.%s"
argument_list|,
name|paths
operator|->
name|paths
index|[
name|ipath
index|]
argument_list|,
name|sec
argument_list|,
name|name
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|file
argument_list|,
name|R_OK
argument_list|)
operator|!=
operator|-
literal|1
condition|)
goto|goto
name|found
goto|;
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|mandoc_asprintf
argument_list|(
operator|&
name|file
argument_list|,
literal|"%s/cat%s/%s.0"
argument_list|,
name|paths
operator|->
name|paths
index|[
name|ipath
index|]
argument_list|,
name|sec
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|file
argument_list|,
name|R_OK
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|form
operator|=
name|FORM_CAT
expr_stmt|;
goto|goto
name|found
goto|;
block|}
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|arch
operator|!=
name|NULL
condition|)
block|{
name|mandoc_asprintf
argument_list|(
operator|&
name|file
argument_list|,
literal|"%s/man%s/%s/%s.%s"
argument_list|,
name|paths
operator|->
name|paths
index|[
name|ipath
index|]
argument_list|,
name|sec
argument_list|,
name|arch
argument_list|,
name|name
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|file
argument_list|,
name|R_OK
argument_list|)
operator|!=
operator|-
literal|1
condition|)
goto|goto
name|found
goto|;
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
name|mandoc_asprintf
argument_list|(
operator|&
name|file
argument_list|,
literal|"%s/man%s/%s.*"
argument_list|,
name|paths
operator|->
name|paths
index|[
name|ipath
index|]
argument_list|,
name|sec
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|globres
operator|=
name|glob
argument_list|(
name|file
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|globinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|globres
operator|!=
literal|0
operator|&&
name|globres
operator|!=
name|GLOB_NOMATCH
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: glob: %s\n"
argument_list|,
name|progname
argument_list|,
name|file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|globres
operator|==
literal|0
condition|)
name|file
operator|=
name|mandoc_strdup
argument_list|(
operator|*
name|globinfo
operator|.
name|gl_pathv
argument_list|)
expr_stmt|;
name|globfree
argument_list|(
operator|&
name|globinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|globres
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|found
label|:
if|#
directive|if
name|HAVE_SQLITE3
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: outdated mandoc.db lacks %s(%s) entry,\n"
literal|"     consider running  # makewhatis %s\n"
argument_list|,
name|progname
argument_list|,
name|name
argument_list|,
name|sec
argument_list|,
name|paths
operator|->
name|paths
index|[
name|ipath
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|res
operator|=
name|mandoc_reallocarray
argument_list|(
operator|*
name|res
argument_list|,
operator|++
operator|*
name|ressz
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|manpage
argument_list|)
argument_list|)
expr_stmt|;
name|page
operator|=
operator|*
name|res
operator|+
operator|(
operator|*
name|ressz
operator|-
literal|1
operator|)
expr_stmt|;
name|page
operator|->
name|file
operator|=
name|file
expr_stmt|;
name|page
operator|->
name|names
operator|=
name|NULL
expr_stmt|;
name|page
operator|->
name|output
operator|=
name|NULL
expr_stmt|;
name|page
operator|->
name|ipath
operator|=
name|ipath
expr_stmt|;
name|page
operator|->
name|bits
operator|=
name|NAME_FILE
operator|&
name|NAME_MASK
expr_stmt|;
name|page
operator|->
name|sec
operator|=
operator|(
operator|*
name|sec
operator|>=
literal|'1'
operator|&&
operator|*
name|sec
operator|<=
literal|'9'
operator|)
condition|?
operator|*
name|sec
operator|-
literal|'1'
operator|+
literal|1
else|:
literal|10
expr_stmt|;
name|page
operator|->
name|form
operator|=
name|form
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fs_search
parameter_list|(
specifier|const
name|struct
name|mansearch
modifier|*
name|cfg
parameter_list|,
specifier|const
name|struct
name|manpaths
modifier|*
name|paths
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|struct
name|manpage
modifier|*
modifier|*
name|res
parameter_list|,
name|size_t
modifier|*
name|ressz
parameter_list|)
block|{
specifier|const
name|char
modifier|*
specifier|const
name|sections
index|[]
init|=
block|{
literal|"1"
block|,
literal|"8"
block|,
literal|"6"
block|,
literal|"2"
block|,
literal|"3"
block|,
literal|"3p"
block|,
literal|"5"
block|,
literal|"7"
block|,
literal|"4"
block|,
literal|"9"
block|}
decl_stmt|;
specifier|const
name|size_t
name|nsec
init|=
sizeof|sizeof
argument_list|(
name|sections
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|sections
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|size_t
name|ipath
decl_stmt|,
name|isec
decl_stmt|,
name|lastsz
decl_stmt|;
name|assert
argument_list|(
name|cfg
operator|->
name|argmode
operator|==
name|ARG_NAME
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
name|NULL
expr_stmt|;
operator|*
name|ressz
operator|=
name|lastsz
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|argc
condition|)
block|{
for|for
control|(
name|ipath
operator|=
literal|0
init|;
name|ipath
operator|<
name|paths
operator|->
name|sz
condition|;
name|ipath
operator|++
control|)
block|{
if|if
condition|(
name|cfg
operator|->
name|sec
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fs_lookup
argument_list|(
name|paths
argument_list|,
name|ipath
argument_list|,
name|cfg
operator|->
name|sec
argument_list|,
name|cfg
operator|->
name|arch
argument_list|,
operator|*
name|argv
argument_list|,
name|res
argument_list|,
name|ressz
argument_list|)
operator|&&
name|cfg
operator|->
name|firstmatch
condition|)
return|return;
block|}
else|else
for|for
control|(
name|isec
operator|=
literal|0
init|;
name|isec
operator|<
name|nsec
condition|;
name|isec
operator|++
control|)
if|if
condition|(
name|fs_lookup
argument_list|(
name|paths
argument_list|,
name|ipath
argument_list|,
name|sections
index|[
name|isec
index|]
argument_list|,
name|cfg
operator|->
name|arch
argument_list|,
operator|*
name|argv
argument_list|,
name|res
argument_list|,
name|ressz
argument_list|)
operator|&&
name|cfg
operator|->
name|firstmatch
condition|)
return|return;
block|}
if|if
condition|(
operator|*
name|ressz
operator|==
name|lastsz
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: No entry for %s in the manual.\n"
argument_list|,
name|progname
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|lastsz
operator|=
operator|*
name|ressz
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|parse
parameter_list|(
name|struct
name|curparse
modifier|*
name|curp
parameter_list|,
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|enum
name|mandoclevel
modifier|*
name|level
parameter_list|)
block|{
name|enum
name|mandoclevel
name|rc
decl_stmt|;
name|struct
name|mdoc
modifier|*
name|mdoc
decl_stmt|;
name|struct
name|man
modifier|*
name|man
decl_stmt|;
comment|/* Begin by parsing the file itself. */
name|assert
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|fd
operator|>=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rc
operator|=
name|mparse_readfd
argument_list|(
name|curp
operator|->
name|mp
argument_list|,
name|fd
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* 	 * With -Wstop and warnings or errors of at least the requested 	 * level, do not produce output. 	 */
if|if
condition|(
name|MANDOCLEVEL_OK
operator|!=
name|rc
operator|&&
name|curp
operator|->
name|wstop
condition|)
goto|goto
name|cleanup
goto|;
comment|/* If unset, allocate output dev now (if applicable). */
if|if
condition|(
operator|!
operator|(
name|curp
operator|->
name|outman
operator|&&
name|curp
operator|->
name|outmdoc
operator|)
condition|)
block|{
switch|switch
condition|(
name|curp
operator|->
name|outtype
condition|)
block|{
case|case
name|OUTT_HTML
case|:
name|curp
operator|->
name|outdata
operator|=
name|html_alloc
argument_list|(
name|curp
operator|->
name|mchars
argument_list|,
name|curp
operator|->
name|outopts
argument_list|)
expr_stmt|;
name|curp
operator|->
name|outfree
operator|=
name|html_free
expr_stmt|;
break|break;
case|case
name|OUTT_UTF8
case|:
name|curp
operator|->
name|outdata
operator|=
name|utf8_alloc
argument_list|(
name|curp
operator|->
name|mchars
argument_list|,
name|curp
operator|->
name|outopts
argument_list|)
expr_stmt|;
name|curp
operator|->
name|outfree
operator|=
name|ascii_free
expr_stmt|;
break|break;
case|case
name|OUTT_LOCALE
case|:
name|curp
operator|->
name|outdata
operator|=
name|locale_alloc
argument_list|(
name|curp
operator|->
name|mchars
argument_list|,
name|curp
operator|->
name|outopts
argument_list|)
expr_stmt|;
name|curp
operator|->
name|outfree
operator|=
name|ascii_free
expr_stmt|;
break|break;
case|case
name|OUTT_ASCII
case|:
name|curp
operator|->
name|outdata
operator|=
name|ascii_alloc
argument_list|(
name|curp
operator|->
name|mchars
argument_list|,
name|curp
operator|->
name|outopts
argument_list|)
expr_stmt|;
name|curp
operator|->
name|outfree
operator|=
name|ascii_free
expr_stmt|;
break|break;
case|case
name|OUTT_PDF
case|:
name|curp
operator|->
name|outdata
operator|=
name|pdf_alloc
argument_list|(
name|curp
operator|->
name|mchars
argument_list|,
name|curp
operator|->
name|outopts
argument_list|)
expr_stmt|;
name|curp
operator|->
name|outfree
operator|=
name|pspdf_free
expr_stmt|;
break|break;
case|case
name|OUTT_PS
case|:
name|curp
operator|->
name|outdata
operator|=
name|ps_alloc
argument_list|(
name|curp
operator|->
name|mchars
argument_list|,
name|curp
operator|->
name|outopts
argument_list|)
expr_stmt|;
name|curp
operator|->
name|outfree
operator|=
name|pspdf_free
expr_stmt|;
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|curp
operator|->
name|outtype
condition|)
block|{
case|case
name|OUTT_HTML
case|:
name|curp
operator|->
name|outman
operator|=
name|html_man
expr_stmt|;
name|curp
operator|->
name|outmdoc
operator|=
name|html_mdoc
expr_stmt|;
break|break;
case|case
name|OUTT_TREE
case|:
name|curp
operator|->
name|outman
operator|=
name|tree_man
expr_stmt|;
name|curp
operator|->
name|outmdoc
operator|=
name|tree_mdoc
expr_stmt|;
break|break;
case|case
name|OUTT_MAN
case|:
name|curp
operator|->
name|outmdoc
operator|=
name|man_mdoc
expr_stmt|;
name|curp
operator|->
name|outman
operator|=
name|man_man
expr_stmt|;
break|break;
case|case
name|OUTT_PDF
case|:
comment|/* FALLTHROUGH */
case|case
name|OUTT_ASCII
case|:
comment|/* FALLTHROUGH */
case|case
name|OUTT_UTF8
case|:
comment|/* FALLTHROUGH */
case|case
name|OUTT_LOCALE
case|:
comment|/* FALLTHROUGH */
case|case
name|OUTT_PS
case|:
name|curp
operator|->
name|outman
operator|=
name|terminal_man
expr_stmt|;
name|curp
operator|->
name|outmdoc
operator|=
name|terminal_mdoc
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|mparse_result
argument_list|(
name|curp
operator|->
name|mp
argument_list|,
operator|&
name|mdoc
argument_list|,
operator|&
name|man
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Execute the out device, if it exists. */
if|if
condition|(
name|man
operator|&&
name|curp
operator|->
name|outman
condition|)
call|(
modifier|*
name|curp
operator|->
name|outman
call|)
argument_list|(
name|curp
operator|->
name|outdata
argument_list|,
name|man
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdoc
operator|&&
name|curp
operator|->
name|outmdoc
condition|)
call|(
modifier|*
name|curp
operator|->
name|outmdoc
call|)
argument_list|(
name|curp
operator|->
name|outdata
argument_list|,
name|mdoc
argument_list|)
expr_stmt|;
name|cleanup
label|:
if|if
condition|(
operator|*
name|level
operator|<
name|rc
condition|)
operator|*
name|level
operator|=
name|rc
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|enum
name|mandoclevel
name|passthrough
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|synopsis_only
parameter_list|)
block|{
specifier|const
name|char
name|synb
index|[]
init|=
literal|"S\bSY\bYN\bNO\bOP\bPS\bSI\bIS\bS"
decl_stmt|;
specifier|const
name|char
name|synr
index|[]
init|=
literal|"SYNOPSIS"
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
specifier|const
name|char
modifier|*
name|syscall
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|off
decl_stmt|;
name|ssize_t
name|nw
decl_stmt|;
name|int
name|print
decl_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stream
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|syscall
operator|=
literal|"fdopen"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|print
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|fgetln
argument_list|(
name|stream
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|synopsis_only
condition|)
block|{
if|if
condition|(
name|print
condition|)
block|{
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|line
argument_list|)
condition|)
goto|goto
name|done
goto|;
while|while
condition|(
name|len
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|line
argument_list|)
condition|)
block|{
name|line
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|synb
argument_list|)
operator|&&
operator|!
name|strncmp
argument_list|(
name|line
argument_list|,
name|synb
argument_list|,
name|len
operator|-
literal|1
argument_list|)
operator|)
operator|||
operator|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|synr
argument_list|)
operator|&&
operator|!
name|strncmp
argument_list|(
name|line
argument_list|,
name|synr
argument_list|,
name|len
operator|-
literal|1
argument_list|)
operator|)
condition|)
name|print
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
for|for
control|(
name|off
operator|=
literal|0
init|;
name|off
operator|<
name|len
condition|;
name|off
operator|+=
name|nw
control|)
if|if
condition|(
operator|(
name|nw
operator|=
name|write
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|line
operator|+
name|off
argument_list|,
name|len
operator|-
name|off
argument_list|)
operator|)
operator|==
operator|-
literal|1
operator|||
name|nw
operator|==
literal|0
condition|)
block|{
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|syscall
operator|=
literal|"write"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
if|if
condition|(
name|ferror
argument_list|(
name|stream
argument_list|)
condition|)
block|{
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|syscall
operator|=
literal|"fgetln"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|done
label|:
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return
operator|(
name|MANDOCLEVEL_OK
operator|)
return|;
name|fail
label|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: SYSERR: %s: %s"
argument_list|,
name|progname
argument_list|,
name|file
argument_list|,
name|syscall
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|MANDOCLEVEL_SYSERR
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|koptions
parameter_list|(
name|int
modifier|*
name|options
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"utf-8"
argument_list|)
condition|)
block|{
operator|*
name|options
operator||=
name|MPARSE_UTF8
expr_stmt|;
operator|*
name|options
operator|&=
operator|~
name|MPARSE_LATIN1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"iso-8859-1"
argument_list|)
condition|)
block|{
operator|*
name|options
operator||=
name|MPARSE_LATIN1
expr_stmt|;
operator|*
name|options
operator|&=
operator|~
name|MPARSE_UTF8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"us-ascii"
argument_list|)
condition|)
block|{
operator|*
name|options
operator|&=
operator|~
operator|(
name|MPARSE_UTF8
operator||
name|MPARSE_LATIN1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: -K %s: Bad argument\n"
argument_list|,
name|progname
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|moptions
parameter_list|(
name|int
modifier|*
name|options
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
comment|/* nothing to do */
empty_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"doc"
argument_list|)
condition|)
operator|*
name|options
operator||=
name|MPARSE_MDOC
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"andoc"
argument_list|)
condition|)
comment|/* nothing to do */
empty_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"an"
argument_list|)
condition|)
operator|*
name|options
operator||=
name|MPARSE_MAN
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: -m %s: Bad argument\n"
argument_list|,
name|progname
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|toptions
parameter_list|(
name|struct
name|curparse
modifier|*
name|curp
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"ascii"
argument_list|)
condition|)
name|curp
operator|->
name|outtype
operator|=
name|OUTT_ASCII
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"lint"
argument_list|)
condition|)
block|{
name|curp
operator|->
name|outtype
operator|=
name|OUTT_LINT
expr_stmt|;
name|curp
operator|->
name|wlevel
operator|=
name|MANDOCLEVEL_WARNING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"tree"
argument_list|)
condition|)
name|curp
operator|->
name|outtype
operator|=
name|OUTT_TREE
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"man"
argument_list|)
condition|)
name|curp
operator|->
name|outtype
operator|=
name|OUTT_MAN
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"html"
argument_list|)
condition|)
name|curp
operator|->
name|outtype
operator|=
name|OUTT_HTML
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"utf8"
argument_list|)
condition|)
name|curp
operator|->
name|outtype
operator|=
name|OUTT_UTF8
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"locale"
argument_list|)
condition|)
name|curp
operator|->
name|outtype
operator|=
name|OUTT_LOCALE
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"xhtml"
argument_list|)
condition|)
name|curp
operator|->
name|outtype
operator|=
name|OUTT_HTML
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"ps"
argument_list|)
condition|)
name|curp
operator|->
name|outtype
operator|=
name|OUTT_PS
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"pdf"
argument_list|)
condition|)
name|curp
operator|->
name|outtype
operator|=
name|OUTT_PDF
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: -T %s: Bad argument\n"
argument_list|,
name|progname
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|woptions
parameter_list|(
name|struct
name|curparse
modifier|*
name|curp
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|char
modifier|*
name|v
decl_stmt|,
modifier|*
name|o
decl_stmt|;
specifier|const
name|char
modifier|*
name|toks
index|[
literal|7
index|]
decl_stmt|;
name|toks
index|[
literal|0
index|]
operator|=
literal|"stop"
expr_stmt|;
name|toks
index|[
literal|1
index|]
operator|=
literal|"all"
expr_stmt|;
name|toks
index|[
literal|2
index|]
operator|=
literal|"warning"
expr_stmt|;
name|toks
index|[
literal|3
index|]
operator|=
literal|"error"
expr_stmt|;
name|toks
index|[
literal|4
index|]
operator|=
literal|"unsupp"
expr_stmt|;
name|toks
index|[
literal|5
index|]
operator|=
literal|"fatal"
expr_stmt|;
name|toks
index|[
literal|6
index|]
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|*
name|arg
condition|)
block|{
name|o
operator|=
name|arg
expr_stmt|;
switch|switch
condition|(
name|getsubopt
argument_list|(
operator|&
name|arg
argument_list|,
name|UNCONST
argument_list|(
name|toks
argument_list|)
argument_list|,
operator|&
name|v
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|curp
operator|->
name|wstop
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* FALLTHROUGH */
case|case
literal|2
case|:
name|curp
operator|->
name|wlevel
operator|=
name|MANDOCLEVEL_WARNING
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|curp
operator|->
name|wlevel
operator|=
name|MANDOCLEVEL_ERROR
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|curp
operator|->
name|wlevel
operator|=
name|MANDOCLEVEL_UNSUPP
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|curp
operator|->
name|wlevel
operator|=
name|MANDOCLEVEL_BADARG
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: -W %s: Bad argument\n"
argument_list|,
name|progname
argument_list|,
name|o
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mmsg
parameter_list|(
name|enum
name|mandocerr
name|t
parameter_list|,
name|enum
name|mandoclevel
name|lvl
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|col
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|mparse_msg
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s:"
argument_list|,
name|progname
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d:%d:"
argument_list|,
name|line
argument_list|,
name|col
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s"
argument_list|,
name|mparse_strlevel
argument_list|(
name|lvl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|mparse_msg
operator|=
name|mparse_strerror
argument_list|(
name|t
argument_list|)
operator|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": %s"
argument_list|,
name|mparse_msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": %s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|pid_t
name|spawn_pager
parameter_list|(
name|void
parameter_list|)
block|{
define|#
directive|define
name|MAX_PAGER_ARGS
value|16
name|char
modifier|*
name|argv
index|[
name|MAX_PAGER_ARGS
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|pager
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|fildes
index|[
literal|2
index|]
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|pid_t
name|pager_pid
decl_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|fildes
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: pipe: %s\n"
argument_list|,
name|progname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
switch|switch
condition|(
name|pager_pid
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: fork: %s\n"
argument_list|,
name|progname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
break|break;
default|default:
name|close
argument_list|(
name|fildes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup2
argument_list|(
name|fildes
index|[
literal|1
index|]
argument_list|,
name|STDOUT_FILENO
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: dup output: %s\n"
argument_list|,
name|progname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fildes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|pager_pid
operator|)
return|;
block|}
comment|/* The child process becomes the pager. */
name|close
argument_list|(
name|fildes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup2
argument_list|(
name|fildes
index|[
literal|0
index|]
argument_list|,
name|STDIN_FILENO
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: dup input: %s\n"
argument_list|,
name|progname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fildes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|pager
operator|=
name|getenv
argument_list|(
literal|"MANPAGER"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pager
operator|==
name|NULL
operator|||
operator|*
name|pager
operator|==
literal|'\0'
condition|)
name|pager
operator|=
name|getenv
argument_list|(
literal|"PAGER"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pager
operator|==
name|NULL
operator|||
operator|*
name|pager
operator|==
literal|'\0'
condition|)
name|pager
operator|=
literal|"/usr/bin/more -s"
expr_stmt|;
name|cp
operator|=
name|mandoc_strdup
argument_list|(
name|pager
argument_list|)
expr_stmt|;
comment|/* 	 * Parse the pager command into words. 	 * Intentionally do not do anything fancy here. 	 */
name|argc
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|argc
operator|+
literal|1
operator|<
name|MAX_PAGER_ARGS
condition|)
block|{
name|argv
index|[
name|argc
operator|++
index|]
operator|=
name|cp
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
break|break;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|==
literal|' '
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
break|break;
block|}
name|argv
index|[
name|argc
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Hand over to the pager. */
name|execvp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: exec: %s\n"
argument_list|,
name|progname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

