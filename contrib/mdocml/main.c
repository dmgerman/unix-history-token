begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$Id: main.c,v 1.205 2014/12/11 19:19:35 schwarze Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2008-2012 Kristaps Dzonsons<kristaps@bsd.lv>  * Copyright (c) 2010, 2011, 2012, 2014 Ingo Schwarze<schwarze@openbsd.org>  * Copyright (c) 2010 Joerg Sonnenberger<joerg@netbsd.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"mandoc.h"
end_include

begin_include
include|#
directive|include
file|"mandoc_aux.h"
end_include

begin_include
include|#
directive|include
file|"main.h"
end_include

begin_include
include|#
directive|include
file|"mdoc.h"
end_include

begin_include
include|#
directive|include
file|"man.h"
end_include

begin_include
include|#
directive|include
file|"manpath.h"
end_include

begin_include
include|#
directive|include
file|"mansearch.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|||
operator|(
name|__GNUC__
operator|<
literal|2
operator|)
end_if

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_define
define|#
directive|define
name|__attribute__
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(__GNUC__) || (__GNUC__< 2) */
end_comment

begin_enum
enum|enum
name|outmode
block|{
name|OUTMODE_DEF
init|=
literal|0
block|,
name|OUTMODE_FLN
block|,
name|OUTMODE_LST
block|,
name|OUTMODE_ALL
block|,
name|OUTMODE_INT
block|,
name|OUTMODE_ONE
block|}
enum|;
end_enum

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|out_mdoc
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
specifier|const
name|struct
name|mdoc
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|out_man
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
specifier|const
name|struct
name|man
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|out_free
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_enum
enum|enum
name|outt
block|{
name|OUTT_ASCII
init|=
literal|0
block|,
comment|/* -Tascii */
name|OUTT_LOCALE
block|,
comment|/* -Tlocale */
name|OUTT_UTF8
block|,
comment|/* -Tutf8 */
name|OUTT_TREE
block|,
comment|/* -Ttree */
name|OUTT_MAN
block|,
comment|/* -Tman */
name|OUTT_HTML
block|,
comment|/* -Thtml */
name|OUTT_LINT
block|,
comment|/* -Tlint */
name|OUTT_PS
block|,
comment|/* -Tps */
name|OUTT_PDF
comment|/* -Tpdf */
block|}
enum|;
end_enum

begin_struct
struct|struct
name|curparse
block|{
name|struct
name|mparse
modifier|*
name|mp
decl_stmt|;
name|struct
name|mchars
modifier|*
name|mchars
decl_stmt|;
comment|/* character table */
name|enum
name|mandoclevel
name|wlevel
decl_stmt|;
comment|/* ignore messages below this */
name|int
name|wstop
decl_stmt|;
comment|/* stop after a file with a warning */
name|enum
name|outt
name|outtype
decl_stmt|;
comment|/* which output to use */
name|out_mdoc
name|outmdoc
decl_stmt|;
comment|/* mdoc output ptr */
name|out_man
name|outman
decl_stmt|;
comment|/* man output ptr */
name|out_free
name|outfree
decl_stmt|;
comment|/* free output ptr */
name|void
modifier|*
name|outdata
decl_stmt|;
comment|/* data for output */
name|char
name|outopts
index|[
name|BUFSIZ
index|]
decl_stmt|;
comment|/* buf of output opts */
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|koptions
parameter_list|(
name|int
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|HAVE_SQLITE3
end_if

begin_function_decl
name|int
name|mandocdb
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|moptions
parameter_list|(
name|int
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mmsg
parameter_list|(
name|enum
name|mandocerr
parameter_list|,
name|enum
name|mandoclevel
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse
parameter_list|(
name|struct
name|curparse
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|enum
name|mandoclevel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|HAVE_SQLITE3
end_if

begin_function_decl
specifier|static
name|enum
name|mandoclevel
name|passthrough
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|spawn_pager
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|toptions
parameter_list|(
name|struct
name|curparse
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|enum
name|argmode
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(noreturn
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|void
name|version
parameter_list|(
name|void
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(noreturn
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|int
name|woptions
parameter_list|(
name|struct
name|curparse
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|int
name|sec_prios
index|[]
init|=
block|{
literal|1
block|,
literal|4
block|,
literal|5
block|,
literal|8
block|,
literal|6
block|,
literal|3
block|,
literal|7
block|,
literal|2
block|,
literal|9
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|help_arg
index|[]
init|=
literal|"help"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|help_argv
index|[]
init|=
block|{
name|help_arg
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|struct
name|curparse
name|curp
decl_stmt|;
name|struct
name|mansearch
name|search
decl_stmt|;
name|struct
name|manpaths
name|paths
decl_stmt|;
name|char
modifier|*
name|auxpaths
decl_stmt|;
name|char
modifier|*
name|defos
decl_stmt|;
if|#
directive|if
name|HAVE_SQLITE3
name|struct
name|manpage
modifier|*
name|res
decl_stmt|,
modifier|*
name|resp
decl_stmt|;
name|char
modifier|*
name|conf_file
decl_stmt|,
modifier|*
name|defpaths
decl_stmt|;
name|size_t
name|isec
decl_stmt|,
name|i
decl_stmt|,
name|sz
decl_stmt|;
name|int
name|prio
decl_stmt|,
name|best_prio
decl_stmt|,
name|synopsis_only
decl_stmt|;
name|char
name|sec
decl_stmt|;
endif|#
directive|endif
name|enum
name|mandoclevel
name|rc
decl_stmt|;
name|enum
name|outmode
name|outmode
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|show_usage
decl_stmt|;
name|int
name|use_pager
decl_stmt|;
name|int
name|options
decl_stmt|;
name|int
name|c
decl_stmt|;
name|progname
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|progname
operator|==
name|NULL
condition|)
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
else|else
operator|++
name|progname
expr_stmt|;
if|#
directive|if
name|HAVE_SQLITE3
if|if
condition|(
name|strcmp
argument_list|(
name|progname
argument_list|,
name|BINM_MAKEWHATIS
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|mandocdb
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
operator|)
return|;
endif|#
directive|endif
comment|/* Search options. */
name|memset
argument_list|(
operator|&
name|paths
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|manpaths
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_SQLITE3
name|conf_file
operator|=
name|defpaths
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|auxpaths
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|search
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mansearch
argument_list|)
argument_list|)
expr_stmt|;
name|search
operator|.
name|outkey
operator|=
literal|"Nd"
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|progname
argument_list|,
name|BINM_MAN
argument_list|)
operator|==
literal|0
condition|)
name|search
operator|.
name|argmode
operator|=
name|ARG_NAME
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|progname
argument_list|,
name|BINM_APROPOS
argument_list|)
operator|==
literal|0
condition|)
name|search
operator|.
name|argmode
operator|=
name|ARG_EXPR
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|progname
argument_list|,
name|BINM_WHATIS
argument_list|)
operator|==
literal|0
condition|)
name|search
operator|.
name|argmode
operator|=
name|ARG_WORD
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|progname
argument_list|,
literal|"help"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|search
operator|.
name|argmode
operator|=
name|ARG_NAME
expr_stmt|;
else|else
name|search
operator|.
name|argmode
operator|=
name|ARG_FILE
expr_stmt|;
comment|/* Parser and formatter options. */
name|memset
argument_list|(
operator|&
name|curp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|curparse
argument_list|)
argument_list|)
expr_stmt|;
name|curp
operator|.
name|outtype
operator|=
name|OUTT_LOCALE
expr_stmt|;
name|curp
operator|.
name|wlevel
operator|=
name|MANDOCLEVEL_FATAL
expr_stmt|;
name|options
operator|=
name|MPARSE_SO
operator||
name|MPARSE_UTF8
operator||
name|MPARSE_LATIN1
expr_stmt|;
name|defos
operator|=
name|NULL
expr_stmt|;
name|use_pager
operator|=
literal|1
expr_stmt|;
name|show_usage
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|HAVE_SQLITE3
name|synopsis_only
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|outmode
operator|=
name|OUTMODE_DEF
expr_stmt|;
while|while
condition|(
operator|-
literal|1
operator|!=
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"aC:cfhI:iK:klM:m:O:S:s:T:VW:w"
argument_list|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|outmode
operator|=
name|OUTMODE_ALL
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
if|#
directive|if
name|HAVE_SQLITE3
name|conf_file
operator|=
name|optarg
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'c'
case|:
name|use_pager
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|search
operator|.
name|argmode
operator|=
name|ARG_WORD
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|curp
operator|.
name|outopts
argument_list|,
literal|"synopsis,"
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_SQLITE3
name|synopsis_only
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|use_pager
operator|=
literal|0
expr_stmt|;
name|outmode
operator|=
name|OUTMODE_ALL
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|optarg
argument_list|,
literal|"os="
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: -I%s: Bad argument\n"
argument_list|,
name|progname
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_BADARG
operator|)
return|;
block|}
if|if
condition|(
name|defos
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: -I%s: Duplicate argument\n"
argument_list|,
name|progname
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_BADARG
operator|)
return|;
block|}
name|defos
operator|=
name|mandoc_strdup
argument_list|(
name|optarg
operator|+
literal|3
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|outmode
operator|=
name|OUTMODE_INT
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
if|if
condition|(
operator|!
name|koptions
argument_list|(
operator|&
name|options
argument_list|,
name|optarg
argument_list|)
condition|)
return|return
operator|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_BADARG
operator|)
return|;
break|break;
case|case
literal|'k'
case|:
name|search
operator|.
name|argmode
operator|=
name|ARG_EXPR
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|search
operator|.
name|argmode
operator|=
name|ARG_FILE
expr_stmt|;
name|outmode
operator|=
name|OUTMODE_ALL
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
if|#
directive|if
name|HAVE_SQLITE3
name|defpaths
operator|=
name|optarg
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'m'
case|:
name|auxpaths
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|search
operator|.
name|outkey
operator|=
name|optarg
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|curp
operator|.
name|outopts
argument_list|,
name|optarg
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|curp
operator|.
name|outopts
argument_list|,
literal|","
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|search
operator|.
name|arch
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|search
operator|.
name|sec
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
if|if
condition|(
operator|!
name|toptions
argument_list|(
operator|&
name|curp
argument_list|,
name|optarg
argument_list|)
condition|)
return|return
operator|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_BADARG
operator|)
return|;
break|break;
case|case
literal|'W'
case|:
if|if
condition|(
operator|!
name|woptions
argument_list|(
operator|&
name|curp
argument_list|,
name|optarg
argument_list|)
condition|)
return|return
operator|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_BADARG
operator|)
return|;
break|break;
case|case
literal|'w'
case|:
name|outmode
operator|=
name|OUTMODE_FLN
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|version
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
default|default:
name|show_usage
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|show_usage
condition|)
name|usage
argument_list|(
name|search
operator|.
name|argmode
argument_list|)
expr_stmt|;
comment|/* Postprocess options. */
if|if
condition|(
name|outmode
operator|==
name|OUTMODE_DEF
condition|)
block|{
switch|switch
condition|(
name|search
operator|.
name|argmode
condition|)
block|{
case|case
name|ARG_FILE
case|:
name|outmode
operator|=
name|OUTMODE_ALL
expr_stmt|;
name|use_pager
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ARG_NAME
case|:
name|outmode
operator|=
name|OUTMODE_ONE
expr_stmt|;
break|break;
default|default:
name|outmode
operator|=
name|OUTMODE_LST
expr_stmt|;
break|break;
block|}
block|}
comment|/* Parse arguments. */
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|#
directive|if
name|HAVE_SQLITE3
name|resp
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Quirks for help(1) 	 * and for a man(1) section argument without -s. 	 */
if|if
condition|(
name|search
operator|.
name|argmode
operator|==
name|ARG_NAME
condition|)
block|{
if|if
condition|(
operator|*
name|progname
operator|==
literal|'h'
condition|)
block|{
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
name|argv
operator|=
name|help_argv
expr_stmt|;
name|argc
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|argv
index|[
literal|0
index|]
operator|!=
name|NULL
operator|&&
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|(
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"3p"
argument_list|)
operator|)
condition|)
block|{
name|search
operator|.
name|sec
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
block|}
name|rc
operator|=
name|MANDOCLEVEL_OK
expr_stmt|;
comment|/* man(1), whatis(1), apropos(1) */
if|if
condition|(
name|search
operator|.
name|argmode
operator|!=
name|ARG_FILE
condition|)
block|{
if|#
directive|if
name|HAVE_SQLITE3
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
name|usage
argument_list|(
name|search
operator|.
name|argmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|search
operator|.
name|argmode
operator|==
name|ARG_NAME
operator|&&
name|outmode
operator|==
name|OUTMODE_ONE
condition|)
name|search
operator|.
name|firstmatch
operator|=
literal|1
expr_stmt|;
comment|/* Access the mandoc database. */
name|manpath_parse
argument_list|(
operator|&
name|paths
argument_list|,
name|conf_file
argument_list|,
name|defpaths
argument_list|,
name|auxpaths
argument_list|)
expr_stmt|;
name|mansearch_setup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mansearch
argument_list|(
operator|&
name|search
argument_list|,
operator|&
name|paths
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|res
argument_list|,
operator|&
name|sz
argument_list|)
condition|)
name|usage
argument_list|(
name|search
operator|.
name|argmode
argument_list|)
expr_stmt|;
name|resp
operator|=
name|res
expr_stmt|;
if|if
condition|(
name|sz
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|search
operator|.
name|argmode
operator|==
name|ARG_NAME
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: No entry for %s "
literal|"in the manual.\n"
argument_list|,
name|progname
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|rc
operator|=
name|MANDOCLEVEL_BADARG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 		 * For standard man(1) and -a output mode, 		 * prepare for copying filename pointers 		 * into the program parameter array. 		 */
if|if
condition|(
name|outmode
operator|==
name|OUTMODE_ONE
condition|)
block|{
name|argc
operator|=
literal|1
expr_stmt|;
name|best_prio
operator|=
literal|10
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|outmode
operator|==
name|OUTMODE_ALL
condition|)
name|argc
operator|=
operator|(
name|int
operator|)
name|sz
expr_stmt|;
comment|/* Iterate all matching manuals. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|outmode
operator|==
name|OUTMODE_FLN
condition|)
name|puts
argument_list|(
name|res
index|[
name|i
index|]
operator|.
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|outmode
operator|==
name|OUTMODE_LST
condition|)
name|printf
argument_list|(
literal|"%s - %s\n"
argument_list|,
name|res
index|[
name|i
index|]
operator|.
name|names
argument_list|,
name|res
index|[
name|i
index|]
operator|.
name|output
operator|==
name|NULL
condition|?
literal|""
else|:
name|res
index|[
name|i
index|]
operator|.
name|output
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|outmode
operator|==
name|OUTMODE_ONE
condition|)
block|{
comment|/* Search for the best section. */
name|isec
operator|=
name|strcspn
argument_list|(
name|res
index|[
name|i
index|]
operator|.
name|file
argument_list|,
literal|"123456789"
argument_list|)
expr_stmt|;
name|sec
operator|=
name|res
index|[
name|i
index|]
operator|.
name|file
index|[
name|isec
index|]
expr_stmt|;
if|if
condition|(
literal|'\0'
operator|==
name|sec
condition|)
continue|continue;
name|prio
operator|=
name|sec_prios
index|[
name|sec
operator|-
literal|'1'
index|]
expr_stmt|;
if|if
condition|(
name|prio
operator|>=
name|best_prio
condition|)
continue|continue;
name|best_prio
operator|=
name|prio
expr_stmt|;
name|resp
operator|=
name|res
operator|+
name|i
expr_stmt|;
block|}
block|}
comment|/* 		 * For man(1), -a and -i output mode, fall through 		 * to the main mandoc(1) code iterating files 		 * and running the parsers on each of them. 		 */
if|if
condition|(
name|outmode
operator|==
name|OUTMODE_FLN
operator|||
name|outmode
operator|==
name|OUTMODE_LST
condition|)
goto|goto
name|out
goto|;
else|#
directive|else
name|fputs
argument_list|(
literal|"mandoc: database support not compiled in\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_BADARG
operator|)
return|;
endif|#
directive|endif
block|}
comment|/* mandoc(1) */
if|if
condition|(
operator|!
name|moptions
argument_list|(
operator|&
name|options
argument_list|,
name|auxpaths
argument_list|)
condition|)
return|return
operator|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_BADARG
operator|)
return|;
if|if
condition|(
name|use_pager
operator|&&
name|isatty
argument_list|(
name|STDOUT_FILENO
argument_list|)
condition|)
name|spawn_pager
argument_list|()
expr_stmt|;
name|curp
operator|.
name|mchars
operator|=
name|mchars_alloc
argument_list|()
expr_stmt|;
name|curp
operator|.
name|mp
operator|=
name|mparse_alloc
argument_list|(
name|options
argument_list|,
name|curp
operator|.
name|wlevel
argument_list|,
name|mmsg
argument_list|,
name|curp
operator|.
name|mchars
argument_list|,
name|defos
argument_list|)
expr_stmt|;
comment|/* 	 * Conditionally start up the lookaside buffer before parsing. 	 */
if|if
condition|(
name|OUTT_MAN
operator|==
name|curp
operator|.
name|outtype
condition|)
name|mparse_keep
argument_list|(
name|curp
operator|.
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
name|parse
argument_list|(
operator|&
name|curp
argument_list|,
name|STDIN_FILENO
argument_list|,
literal|"<stdin>"
argument_list|,
operator|&
name|rc
argument_list|)
expr_stmt|;
while|while
condition|(
name|argc
condition|)
block|{
if|#
directive|if
name|HAVE_SQLITE3
if|if
condition|(
name|resp
operator|!=
name|NULL
condition|)
block|{
name|rc
operator|=
name|mparse_open
argument_list|(
name|curp
operator|.
name|mp
argument_list|,
operator|&
name|fd
argument_list|,
name|resp
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
comment|/* nothing */
empty_stmt|;
elseif|else
if|if
condition|(
name|resp
operator|->
name|form
operator|&
name|FORM_SRC
condition|)
block|{
comment|/* For .so only; ignore failure. */
name|chdir
argument_list|(
name|paths
operator|.
name|paths
index|[
name|resp
operator|->
name|ipath
index|]
argument_list|)
expr_stmt|;
name|parse
argument_list|(
operator|&
name|curp
argument_list|,
name|fd
argument_list|,
name|resp
operator|->
name|file
argument_list|,
operator|&
name|rc
argument_list|)
expr_stmt|;
block|}
else|else
name|rc
operator|=
name|passthrough
argument_list|(
name|resp
operator|->
name|file
argument_list|,
name|fd
argument_list|,
name|synopsis_only
argument_list|)
expr_stmt|;
name|resp
operator|++
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|rc
operator|=
name|mparse_open
argument_list|(
name|curp
operator|.
name|mp
argument_list|,
operator|&
name|fd
argument_list|,
operator|*
name|argv
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
name|parse
argument_list|(
operator|&
name|curp
argument_list|,
name|fd
argument_list|,
name|argv
index|[
operator|-
literal|1
index|]
argument_list|,
operator|&
name|rc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mparse_wait
argument_list|(
name|curp
operator|.
name|mp
argument_list|)
operator|!=
name|MANDOCLEVEL_OK
condition|)
name|rc
operator|=
name|MANDOCLEVEL_SYSERR
expr_stmt|;
if|if
condition|(
name|MANDOCLEVEL_OK
operator|!=
name|rc
operator|&&
name|curp
operator|.
name|wstop
condition|)
break|break;
name|argc
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|curp
operator|.
name|outfree
condition|)
call|(
modifier|*
name|curp
operator|.
name|outfree
call|)
argument_list|(
name|curp
operator|.
name|outdata
argument_list|)
expr_stmt|;
name|mparse_free
argument_list|(
name|curp
operator|.
name|mp
argument_list|)
expr_stmt|;
name|mchars_free
argument_list|(
name|curp
operator|.
name|mchars
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_SQLITE3
name|out
label|:
if|if
condition|(
name|search
operator|.
name|argmode
operator|!=
name|ARG_FILE
condition|)
block|{
name|manpath_free
argument_list|(
operator|&
name|paths
argument_list|)
expr_stmt|;
name|mansearch_free
argument_list|(
name|res
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|mansearch_setup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|free
argument_list|(
name|defos
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|version
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"mandoc %s\n"
argument_list|,
name|VERSION
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|enum
name|argmode
name|argmode
parameter_list|)
block|{
switch|switch
condition|(
name|argmode
condition|)
block|{
case|case
name|ARG_FILE
case|:
name|fputs
argument_list|(
literal|"usage: mandoc [-acfhklV] [-Ios=name] "
literal|"[-Kencoding] [-mformat] [-Ooption]\n"
literal|"\t      [-Toutput] [-Wlevel] [file ...]\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARG_NAME
case|:
name|fputs
argument_list|(
literal|"usage: man [-acfhklVw] [-C file] "
literal|"[-M path] [-m path] [-S arch] [-s section]\n"
literal|"\t   [section] name ...\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARG_WORD
case|:
name|fputs
argument_list|(
literal|"usage: whatis [-acfhklVw] [-C file] "
literal|"[-M path] [-m path] [-O outkey] [-S arch]\n"
literal|"\t      [-s section] name ...\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARG_EXPR
case|:
name|fputs
argument_list|(
literal|"usage: apropos [-acfhklVw] [-C file] "
literal|"[-M path] [-m path] [-O outkey] [-S arch]\n"
literal|"\t       [-s section] expression ...\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
block|}
name|exit
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_BADARG
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|parse
parameter_list|(
name|struct
name|curparse
modifier|*
name|curp
parameter_list|,
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|enum
name|mandoclevel
modifier|*
name|level
parameter_list|)
block|{
name|enum
name|mandoclevel
name|rc
decl_stmt|;
name|struct
name|mdoc
modifier|*
name|mdoc
decl_stmt|;
name|struct
name|man
modifier|*
name|man
decl_stmt|;
comment|/* Begin by parsing the file itself. */
name|assert
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|fd
operator|>=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rc
operator|=
name|mparse_readfd
argument_list|(
name|curp
operator|->
name|mp
argument_list|,
name|fd
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* Stop immediately if the parse has failed. */
if|if
condition|(
name|MANDOCLEVEL_FATAL
operator|<=
name|rc
condition|)
goto|goto
name|cleanup
goto|;
comment|/* 	 * With -Wstop and warnings or errors of at least the requested 	 * level, do not produce output. 	 */
if|if
condition|(
name|MANDOCLEVEL_OK
operator|!=
name|rc
operator|&&
name|curp
operator|->
name|wstop
condition|)
goto|goto
name|cleanup
goto|;
comment|/* If unset, allocate output dev now (if applicable). */
if|if
condition|(
operator|!
operator|(
name|curp
operator|->
name|outman
operator|&&
name|curp
operator|->
name|outmdoc
operator|)
condition|)
block|{
switch|switch
condition|(
name|curp
operator|->
name|outtype
condition|)
block|{
case|case
name|OUTT_HTML
case|:
name|curp
operator|->
name|outdata
operator|=
name|html_alloc
argument_list|(
name|curp
operator|->
name|mchars
argument_list|,
name|curp
operator|->
name|outopts
argument_list|)
expr_stmt|;
name|curp
operator|->
name|outfree
operator|=
name|html_free
expr_stmt|;
break|break;
case|case
name|OUTT_UTF8
case|:
name|curp
operator|->
name|outdata
operator|=
name|utf8_alloc
argument_list|(
name|curp
operator|->
name|mchars
argument_list|,
name|curp
operator|->
name|outopts
argument_list|)
expr_stmt|;
name|curp
operator|->
name|outfree
operator|=
name|ascii_free
expr_stmt|;
break|break;
case|case
name|OUTT_LOCALE
case|:
name|curp
operator|->
name|outdata
operator|=
name|locale_alloc
argument_list|(
name|curp
operator|->
name|mchars
argument_list|,
name|curp
operator|->
name|outopts
argument_list|)
expr_stmt|;
name|curp
operator|->
name|outfree
operator|=
name|ascii_free
expr_stmt|;
break|break;
case|case
name|OUTT_ASCII
case|:
name|curp
operator|->
name|outdata
operator|=
name|ascii_alloc
argument_list|(
name|curp
operator|->
name|mchars
argument_list|,
name|curp
operator|->
name|outopts
argument_list|)
expr_stmt|;
name|curp
operator|->
name|outfree
operator|=
name|ascii_free
expr_stmt|;
break|break;
case|case
name|OUTT_PDF
case|:
name|curp
operator|->
name|outdata
operator|=
name|pdf_alloc
argument_list|(
name|curp
operator|->
name|mchars
argument_list|,
name|curp
operator|->
name|outopts
argument_list|)
expr_stmt|;
name|curp
operator|->
name|outfree
operator|=
name|pspdf_free
expr_stmt|;
break|break;
case|case
name|OUTT_PS
case|:
name|curp
operator|->
name|outdata
operator|=
name|ps_alloc
argument_list|(
name|curp
operator|->
name|mchars
argument_list|,
name|curp
operator|->
name|outopts
argument_list|)
expr_stmt|;
name|curp
operator|->
name|outfree
operator|=
name|pspdf_free
expr_stmt|;
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|curp
operator|->
name|outtype
condition|)
block|{
case|case
name|OUTT_HTML
case|:
name|curp
operator|->
name|outman
operator|=
name|html_man
expr_stmt|;
name|curp
operator|->
name|outmdoc
operator|=
name|html_mdoc
expr_stmt|;
break|break;
case|case
name|OUTT_TREE
case|:
name|curp
operator|->
name|outman
operator|=
name|tree_man
expr_stmt|;
name|curp
operator|->
name|outmdoc
operator|=
name|tree_mdoc
expr_stmt|;
break|break;
case|case
name|OUTT_MAN
case|:
name|curp
operator|->
name|outmdoc
operator|=
name|man_mdoc
expr_stmt|;
name|curp
operator|->
name|outman
operator|=
name|man_man
expr_stmt|;
break|break;
case|case
name|OUTT_PDF
case|:
comment|/* FALLTHROUGH */
case|case
name|OUTT_ASCII
case|:
comment|/* FALLTHROUGH */
case|case
name|OUTT_UTF8
case|:
comment|/* FALLTHROUGH */
case|case
name|OUTT_LOCALE
case|:
comment|/* FALLTHROUGH */
case|case
name|OUTT_PS
case|:
name|curp
operator|->
name|outman
operator|=
name|terminal_man
expr_stmt|;
name|curp
operator|->
name|outmdoc
operator|=
name|terminal_mdoc
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|mparse_result
argument_list|(
name|curp
operator|->
name|mp
argument_list|,
operator|&
name|mdoc
argument_list|,
operator|&
name|man
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Execute the out device, if it exists. */
if|if
condition|(
name|man
operator|&&
name|curp
operator|->
name|outman
condition|)
call|(
modifier|*
name|curp
operator|->
name|outman
call|)
argument_list|(
name|curp
operator|->
name|outdata
argument_list|,
name|man
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdoc
operator|&&
name|curp
operator|->
name|outmdoc
condition|)
call|(
modifier|*
name|curp
operator|->
name|outmdoc
call|)
argument_list|(
name|curp
operator|->
name|outdata
argument_list|,
name|mdoc
argument_list|)
expr_stmt|;
name|cleanup
label|:
name|mparse_reset
argument_list|(
name|curp
operator|->
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|level
operator|<
name|rc
condition|)
operator|*
name|level
operator|=
name|rc
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|HAVE_SQLITE3
end_if

begin_function
specifier|static
name|enum
name|mandoclevel
name|passthrough
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|synopsis_only
parameter_list|)
block|{
specifier|const
name|char
name|synb
index|[]
init|=
literal|"S\bSY\bYN\bNO\bOP\bPS\bSI\bIS\bS"
decl_stmt|;
specifier|const
name|char
name|synr
index|[]
init|=
literal|"SYNOPSIS"
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
specifier|const
name|char
modifier|*
name|syscall
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|off
decl_stmt|;
name|ssize_t
name|nw
decl_stmt|;
name|int
name|print
decl_stmt|;
if|if
condition|(
operator|(
name|stream
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|syscall
operator|=
literal|"fdopen"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|print
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|fgetln
argument_list|(
name|stream
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|synopsis_only
condition|)
block|{
if|if
condition|(
name|print
condition|)
block|{
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|line
argument_list|)
condition|)
goto|goto
name|done
goto|;
while|while
condition|(
name|len
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|line
argument_list|)
condition|)
block|{
name|line
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|synb
argument_list|)
operator|&&
operator|!
name|strncmp
argument_list|(
name|line
argument_list|,
name|synb
argument_list|,
name|len
operator|-
literal|1
argument_list|)
operator|)
operator|||
operator|(
name|len
operator|==
sizeof|sizeof
argument_list|(
name|synr
argument_list|)
operator|&&
operator|!
name|strncmp
argument_list|(
name|line
argument_list|,
name|synr
argument_list|,
name|len
operator|-
literal|1
argument_list|)
operator|)
condition|)
name|print
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
for|for
control|(
name|off
operator|=
literal|0
init|;
name|off
operator|<
name|len
condition|;
name|off
operator|+=
name|nw
control|)
if|if
condition|(
operator|(
name|nw
operator|=
name|write
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|line
operator|+
name|off
argument_list|,
name|len
operator|-
name|off
argument_list|)
operator|)
operator|==
operator|-
literal|1
operator|||
name|nw
operator|==
literal|0
condition|)
block|{
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|syscall
operator|=
literal|"write"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
if|if
condition|(
name|ferror
argument_list|(
name|stream
argument_list|)
condition|)
block|{
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|syscall
operator|=
literal|"fgetln"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|done
label|:
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return
operator|(
name|MANDOCLEVEL_OK
operator|)
return|;
name|fail
label|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: SYSERR: %s: %s"
argument_list|,
name|progname
argument_list|,
name|file
argument_list|,
name|syscall
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|MANDOCLEVEL_SYSERR
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|koptions
parameter_list|(
name|int
modifier|*
name|options
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"utf-8"
argument_list|)
condition|)
block|{
operator|*
name|options
operator||=
name|MPARSE_UTF8
expr_stmt|;
operator|*
name|options
operator|&=
operator|~
name|MPARSE_LATIN1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"iso-8859-1"
argument_list|)
condition|)
block|{
operator|*
name|options
operator||=
name|MPARSE_LATIN1
expr_stmt|;
operator|*
name|options
operator|&=
operator|~
name|MPARSE_UTF8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"us-ascii"
argument_list|)
condition|)
block|{
operator|*
name|options
operator|&=
operator|~
operator|(
name|MPARSE_UTF8
operator||
name|MPARSE_LATIN1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: -K%s: Bad argument\n"
argument_list|,
name|progname
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|moptions
parameter_list|(
name|int
modifier|*
name|options
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
comment|/* nothing to do */
empty_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"doc"
argument_list|)
condition|)
operator|*
name|options
operator||=
name|MPARSE_MDOC
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"andoc"
argument_list|)
condition|)
comment|/* nothing to do */
empty_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"an"
argument_list|)
condition|)
operator|*
name|options
operator||=
name|MPARSE_MAN
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: -m%s: Bad argument\n"
argument_list|,
name|progname
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|toptions
parameter_list|(
name|struct
name|curparse
modifier|*
name|curp
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"ascii"
argument_list|)
condition|)
name|curp
operator|->
name|outtype
operator|=
name|OUTT_ASCII
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"lint"
argument_list|)
condition|)
block|{
name|curp
operator|->
name|outtype
operator|=
name|OUTT_LINT
expr_stmt|;
name|curp
operator|->
name|wlevel
operator|=
name|MANDOCLEVEL_WARNING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"tree"
argument_list|)
condition|)
name|curp
operator|->
name|outtype
operator|=
name|OUTT_TREE
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"man"
argument_list|)
condition|)
name|curp
operator|->
name|outtype
operator|=
name|OUTT_MAN
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"html"
argument_list|)
condition|)
name|curp
operator|->
name|outtype
operator|=
name|OUTT_HTML
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"utf8"
argument_list|)
condition|)
name|curp
operator|->
name|outtype
operator|=
name|OUTT_UTF8
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"locale"
argument_list|)
condition|)
name|curp
operator|->
name|outtype
operator|=
name|OUTT_LOCALE
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"xhtml"
argument_list|)
condition|)
name|curp
operator|->
name|outtype
operator|=
name|OUTT_HTML
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"ps"
argument_list|)
condition|)
name|curp
operator|->
name|outtype
operator|=
name|OUTT_PS
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"pdf"
argument_list|)
condition|)
name|curp
operator|->
name|outtype
operator|=
name|OUTT_PDF
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: -T%s: Bad argument\n"
argument_list|,
name|progname
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|woptions
parameter_list|(
name|struct
name|curparse
modifier|*
name|curp
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|char
modifier|*
name|v
decl_stmt|,
modifier|*
name|o
decl_stmt|;
specifier|const
name|char
modifier|*
name|toks
index|[
literal|6
index|]
decl_stmt|;
name|toks
index|[
literal|0
index|]
operator|=
literal|"stop"
expr_stmt|;
name|toks
index|[
literal|1
index|]
operator|=
literal|"all"
expr_stmt|;
name|toks
index|[
literal|2
index|]
operator|=
literal|"warning"
expr_stmt|;
name|toks
index|[
literal|3
index|]
operator|=
literal|"error"
expr_stmt|;
name|toks
index|[
literal|4
index|]
operator|=
literal|"fatal"
expr_stmt|;
name|toks
index|[
literal|5
index|]
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|*
name|arg
condition|)
block|{
name|o
operator|=
name|arg
expr_stmt|;
switch|switch
condition|(
name|getsubopt
argument_list|(
operator|&
name|arg
argument_list|,
name|UNCONST
argument_list|(
name|toks
argument_list|)
argument_list|,
operator|&
name|v
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|curp
operator|->
name|wstop
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* FALLTHROUGH */
case|case
literal|2
case|:
name|curp
operator|->
name|wlevel
operator|=
name|MANDOCLEVEL_WARNING
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|curp
operator|->
name|wlevel
operator|=
name|MANDOCLEVEL_ERROR
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|curp
operator|->
name|wlevel
operator|=
name|MANDOCLEVEL_FATAL
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: -W%s: Bad argument\n"
argument_list|,
name|progname
argument_list|,
name|o
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mmsg
parameter_list|(
name|enum
name|mandocerr
name|t
parameter_list|,
name|enum
name|mandoclevel
name|lvl
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|col
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|mparse_msg
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s:"
argument_list|,
name|progname
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d:%d:"
argument_list|,
name|line
argument_list|,
name|col
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s"
argument_list|,
name|mparse_strlevel
argument_list|(
name|lvl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|mparse_msg
operator|=
name|mparse_strerror
argument_list|(
name|t
argument_list|)
operator|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": %s"
argument_list|,
name|mparse_msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": %s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|spawn_pager
parameter_list|(
name|void
parameter_list|)
block|{
define|#
directive|define
name|MAX_PAGER_ARGS
value|16
name|char
modifier|*
name|argv
index|[
name|MAX_PAGER_ARGS
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|pager
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|fildes
index|[
literal|2
index|]
decl_stmt|;
name|int
name|argc
decl_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|fildes
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: pipe: %s\n"
argument_list|,
name|progname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: fork: %s\n"
argument_list|,
name|progname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
name|close
argument_list|(
name|fildes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup2
argument_list|(
name|fildes
index|[
literal|1
index|]
argument_list|,
name|STDOUT_FILENO
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: dup output: %s\n"
argument_list|,
name|progname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
argument_list|)
expr_stmt|;
block|}
return|return;
default|default:
break|break;
block|}
comment|/* The original process becomes the pager. */
name|close
argument_list|(
name|fildes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup2
argument_list|(
name|fildes
index|[
literal|0
index|]
argument_list|,
name|STDIN_FILENO
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: dup input: %s\n"
argument_list|,
name|progname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
argument_list|)
expr_stmt|;
block|}
name|pager
operator|=
name|getenv
argument_list|(
literal|"MANPAGER"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pager
operator|==
name|NULL
operator|||
operator|*
name|pager
operator|==
literal|'\0'
condition|)
name|pager
operator|=
name|getenv
argument_list|(
literal|"PAGER"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pager
operator|==
name|NULL
operator|||
operator|*
name|pager
operator|==
literal|'\0'
condition|)
name|pager
operator|=
literal|"/usr/bin/more -s"
expr_stmt|;
name|cp
operator|=
name|mandoc_strdup
argument_list|(
name|pager
argument_list|)
expr_stmt|;
comment|/* 	 * Parse the pager command into words. 	 * Intentionally do not do anything fancy here. 	 */
name|argc
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|argc
operator|+
literal|1
operator|<
name|MAX_PAGER_ARGS
condition|)
block|{
name|argv
index|[
name|argc
operator|++
index|]
operator|=
name|cp
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
break|break;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|==
literal|' '
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
break|break;
block|}
name|argv
index|[
name|argc
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Hand over to the pager. */
name|execvp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: exec: %s\n"
argument_list|,
name|progname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

