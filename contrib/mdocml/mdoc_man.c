begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$Id: mdoc_man.c,v 1.122 2017/06/14 22:51:25 schwarze Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2011-2017 Ingo Schwarze<schwarze@openbsd.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"mandoc_aux.h"
end_include

begin_include
include|#
directive|include
file|"mandoc.h"
end_include

begin_include
include|#
directive|include
file|"roff.h"
end_include

begin_include
include|#
directive|include
file|"mdoc.h"
end_include

begin_include
include|#
directive|include
file|"man.h"
end_include

begin_include
include|#
directive|include
file|"out.h"
end_include

begin_include
include|#
directive|include
file|"main.h"
end_include

begin_define
define|#
directive|define
name|DECL_ARGS
value|const struct roff_meta *meta, struct roff_node *n
end_define

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|int_fp
function_decl|)
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|void_fp
function_decl|)
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_typedef

begin_struct
struct|struct
name|manact
block|{
name|int_fp
name|cond
decl_stmt|;
comment|/* DON'T run actions */
name|int_fp
name|pre
decl_stmt|;
comment|/* pre-node action */
name|void_fp
name|post
decl_stmt|;
comment|/* post-node action */
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
comment|/* pre-node string constant */
specifier|const
name|char
modifier|*
name|suffix
decl_stmt|;
comment|/* post-node string constant */
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|cond_body
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cond_head
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|font_push
parameter_list|(
name|char
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|font_pop
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|man_strlen
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mid_it
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post__t
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_aq
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_bd
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_bf
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_bk
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_bl
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_dl
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_en
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_enc
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_eo
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_fa
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_fd
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_fl
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_fn
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_fo
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_font
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_in
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_it
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_lb
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_nm
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_percent
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_pf
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_sect
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|post_vt
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre__t
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_an
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_ap
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_aq
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_bd
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_bf
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_bk
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_bl
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pre_br
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_dl
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_en
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_enc
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_em
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_skip
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_eo
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_ex
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_fa
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_fd
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_fl
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_fn
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_fo
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pre_ft
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_Ft
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_in
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_it
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_lk
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_li
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_nm
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_no
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_ns
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pre_onearg
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_pp
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_rs
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_sm
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pre_sp
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_sect
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_sy
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pre_syn
parameter_list|(
specifier|const
name|struct
name|roff_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pre_ta
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_vt
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_xr
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_word
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_line
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_block
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_offs
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_width
parameter_list|(
specifier|const
name|struct
name|mdoc_bl
modifier|*
parameter_list|,
specifier|const
name|struct
name|roff_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_count
parameter_list|(
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_node
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|void_fp
name|roff_manacts
index|[
name|ROFF_MAX
index|]
init|=
block|{
name|pre_br
block|,
comment|/* br */
name|pre_onearg
block|,
comment|/* ce */
name|pre_ft
block|,
comment|/* ft */
name|pre_onearg
block|,
comment|/* ll */
name|pre_onearg
block|,
comment|/* mc */
name|pre_onearg
block|,
comment|/* po */
name|pre_onearg
block|,
comment|/* rj */
name|pre_sp
block|,
comment|/* sp */
name|pre_ta
block|,
comment|/* ta */
name|pre_onearg
block|,
comment|/* ti */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|manact
name|__manacts
index|[
name|MDOC_MAX
operator|-
name|MDOC_Dd
index|]
init|=
block|{
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Dd */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Dt */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Os */
block|{
name|NULL
block|,
name|pre_sect
block|,
name|post_sect
block|,
literal|".SH"
block|,
name|NULL
block|}
block|,
comment|/* Sh */
block|{
name|NULL
block|,
name|pre_sect
block|,
name|post_sect
block|,
literal|".SS"
block|,
name|NULL
block|}
block|,
comment|/* Ss */
block|{
name|NULL
block|,
name|pre_pp
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Pp */
block|{
name|cond_body
block|,
name|pre_dl
block|,
name|post_dl
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* D1 */
block|{
name|cond_body
block|,
name|pre_dl
block|,
name|post_dl
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Dl */
block|{
name|cond_body
block|,
name|pre_bd
block|,
name|post_bd
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Bd */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ed */
block|{
name|cond_body
block|,
name|pre_bl
block|,
name|post_bl
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Bl */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* El */
block|{
name|NULL
block|,
name|pre_it
block|,
name|post_it
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* It */
block|{
name|NULL
block|,
name|pre_em
block|,
name|post_font
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ad */
block|{
name|NULL
block|,
name|pre_an
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* An */
block|{
name|NULL
block|,
name|pre_ap
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ap */
block|{
name|NULL
block|,
name|pre_em
block|,
name|post_font
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ar */
block|{
name|NULL
block|,
name|pre_sy
block|,
name|post_font
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Cd */
block|{
name|NULL
block|,
name|pre_sy
block|,
name|post_font
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Cm */
block|{
name|NULL
block|,
name|pre_li
block|,
name|post_font
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Dv */
block|{
name|NULL
block|,
name|pre_li
block|,
name|post_font
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Er */
block|{
name|NULL
block|,
name|pre_li
block|,
name|post_font
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ev */
block|{
name|NULL
block|,
name|pre_ex
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ex */
block|{
name|NULL
block|,
name|pre_fa
block|,
name|post_fa
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Fa */
block|{
name|NULL
block|,
name|pre_fd
block|,
name|post_fd
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Fd */
block|{
name|NULL
block|,
name|pre_fl
block|,
name|post_fl
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Fl */
block|{
name|NULL
block|,
name|pre_fn
block|,
name|post_fn
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Fn */
block|{
name|NULL
block|,
name|pre_Ft
block|,
name|post_font
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ft */
block|{
name|NULL
block|,
name|pre_sy
block|,
name|post_font
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ic */
block|{
name|NULL
block|,
name|pre_in
block|,
name|post_in
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* In */
block|{
name|NULL
block|,
name|pre_li
block|,
name|post_font
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Li */
block|{
name|cond_head
block|,
name|pre_enc
block|,
name|NULL
block|,
literal|"\\- "
block|,
name|NULL
block|}
block|,
comment|/* Nd */
block|{
name|NULL
block|,
name|pre_nm
block|,
name|post_nm
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Nm */
block|{
name|cond_body
block|,
name|pre_enc
block|,
name|post_enc
block|,
literal|"["
block|,
literal|"]"
block|}
block|,
comment|/* Op */
block|{
name|NULL
block|,
name|pre_Ft
block|,
name|post_font
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ot */
block|{
name|NULL
block|,
name|pre_em
block|,
name|post_font
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Pa */
block|{
name|NULL
block|,
name|pre_ex
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Rv */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* St */
block|{
name|NULL
block|,
name|pre_em
block|,
name|post_font
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Va */
block|{
name|NULL
block|,
name|pre_vt
block|,
name|post_vt
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Vt */
block|{
name|NULL
block|,
name|pre_xr
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Xr */
block|{
name|NULL
block|,
name|NULL
block|,
name|post_percent
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* %A */
block|{
name|NULL
block|,
name|pre_em
block|,
name|post_percent
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* %B */
block|{
name|NULL
block|,
name|NULL
block|,
name|post_percent
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* %D */
block|{
name|NULL
block|,
name|pre_em
block|,
name|post_percent
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* %I */
block|{
name|NULL
block|,
name|pre_em
block|,
name|post_percent
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* %J */
block|{
name|NULL
block|,
name|NULL
block|,
name|post_percent
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* %N */
block|{
name|NULL
block|,
name|NULL
block|,
name|post_percent
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* %O */
block|{
name|NULL
block|,
name|NULL
block|,
name|post_percent
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* %P */
block|{
name|NULL
block|,
name|NULL
block|,
name|post_percent
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* %R */
block|{
name|NULL
block|,
name|pre__t
block|,
name|post__t
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* %T */
block|{
name|NULL
block|,
name|NULL
block|,
name|post_percent
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* %V */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ac */
block|{
name|cond_body
block|,
name|pre_aq
block|,
name|post_aq
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ao */
block|{
name|cond_body
block|,
name|pre_aq
block|,
name|post_aq
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Aq */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* At */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Bc */
block|{
name|NULL
block|,
name|pre_bf
block|,
name|post_bf
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Bf */
block|{
name|cond_body
block|,
name|pre_enc
block|,
name|post_enc
block|,
literal|"["
block|,
literal|"]"
block|}
block|,
comment|/* Bo */
block|{
name|cond_body
block|,
name|pre_enc
block|,
name|post_enc
block|,
literal|"["
block|,
literal|"]"
block|}
block|,
comment|/* Bq */
block|{
name|NULL
block|,
name|pre_bk
block|,
name|post_bk
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Bsx */
block|{
name|NULL
block|,
name|pre_bk
block|,
name|post_bk
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Bx */
block|{
name|NULL
block|,
name|pre_skip
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Db */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Dc */
block|{
name|cond_body
block|,
name|pre_enc
block|,
name|post_enc
block|,
literal|"\\(Lq"
block|,
literal|"\\(Rq"
block|}
block|,
comment|/* Do */
block|{
name|cond_body
block|,
name|pre_enc
block|,
name|post_enc
block|,
literal|"\\(Lq"
block|,
literal|"\\(Rq"
block|}
block|,
comment|/* Dq */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ec */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ef */
block|{
name|NULL
block|,
name|pre_em
block|,
name|post_font
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Em */
block|{
name|cond_body
block|,
name|pre_eo
block|,
name|post_eo
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Eo */
block|{
name|NULL
block|,
name|pre_bk
block|,
name|post_bk
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Fx */
block|{
name|NULL
block|,
name|pre_sy
block|,
name|post_font
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ms */
block|{
name|NULL
block|,
name|pre_no
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* No */
block|{
name|NULL
block|,
name|pre_ns
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ns */
block|{
name|NULL
block|,
name|pre_bk
block|,
name|post_bk
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Nx */
block|{
name|NULL
block|,
name|pre_bk
block|,
name|post_bk
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ox */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Pc */
block|{
name|NULL
block|,
name|NULL
block|,
name|post_pf
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Pf */
block|{
name|cond_body
block|,
name|pre_enc
block|,
name|post_enc
block|,
literal|"("
block|,
literal|")"
block|}
block|,
comment|/* Po */
block|{
name|cond_body
block|,
name|pre_enc
block|,
name|post_enc
block|,
literal|"("
block|,
literal|")"
block|}
block|,
comment|/* Pq */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Qc */
block|{
name|cond_body
block|,
name|pre_enc
block|,
name|post_enc
block|,
literal|"\\(oq"
block|,
literal|"\\(cq"
block|}
block|,
comment|/* Ql */
block|{
name|cond_body
block|,
name|pre_enc
block|,
name|post_enc
block|,
literal|"\""
block|,
literal|"\""
block|}
block|,
comment|/* Qo */
block|{
name|cond_body
block|,
name|pre_enc
block|,
name|post_enc
block|,
literal|"\""
block|,
literal|"\""
block|}
block|,
comment|/* Qq */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Re */
block|{
name|cond_body
block|,
name|pre_rs
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Rs */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Sc */
block|{
name|cond_body
block|,
name|pre_enc
block|,
name|post_enc
block|,
literal|"\\(oq"
block|,
literal|"\\(cq"
block|}
block|,
comment|/* So */
block|{
name|cond_body
block|,
name|pre_enc
block|,
name|post_enc
block|,
literal|"\\(oq"
block|,
literal|"\\(cq"
block|}
block|,
comment|/* Sq */
block|{
name|NULL
block|,
name|pre_sm
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Sm */
block|{
name|NULL
block|,
name|pre_em
block|,
name|post_font
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Sx */
block|{
name|NULL
block|,
name|pre_sy
block|,
name|post_font
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Sy */
block|{
name|NULL
block|,
name|pre_li
block|,
name|post_font
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Tn */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ux */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Xc */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Xo */
block|{
name|NULL
block|,
name|pre_fo
block|,
name|post_fo
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Fo */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Fc */
block|{
name|cond_body
block|,
name|pre_enc
block|,
name|post_enc
block|,
literal|"["
block|,
literal|"]"
block|}
block|,
comment|/* Oo */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Oc */
block|{
name|NULL
block|,
name|pre_bk
block|,
name|post_bk
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Bk */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ek */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Bt */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Hf */
block|{
name|NULL
block|,
name|pre_em
block|,
name|post_font
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Fr */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ud */
block|{
name|NULL
block|,
name|NULL
block|,
name|post_lb
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Lb */
block|{
name|NULL
block|,
name|pre_pp
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Lp */
block|{
name|NULL
block|,
name|pre_lk
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Lk */
block|{
name|NULL
block|,
name|pre_em
block|,
name|post_font
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Mt */
block|{
name|cond_body
block|,
name|pre_enc
block|,
name|post_enc
block|,
literal|"{"
block|,
literal|"}"
block|}
block|,
comment|/* Brq */
block|{
name|cond_body
block|,
name|pre_enc
block|,
name|post_enc
block|,
literal|"{"
block|,
literal|"}"
block|}
block|,
comment|/* Bro */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Brc */
block|{
name|NULL
block|,
name|NULL
block|,
name|post_percent
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* %C */
block|{
name|NULL
block|,
name|pre_skip
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Es */
block|{
name|cond_body
block|,
name|pre_en
block|,
name|post_en
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* En */
block|{
name|NULL
block|,
name|pre_bk
block|,
name|post_bk
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Dx */
block|{
name|NULL
block|,
name|NULL
block|,
name|post_percent
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* %Q */
block|{
name|NULL
block|,
name|NULL
block|,
name|post_percent
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* %U */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ta */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|manact
modifier|*
specifier|const
name|manacts
init|=
name|__manacts
operator|-
name|MDOC_Dd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|outflags
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MMAN_spc
value|(1<< 0)
end_define

begin_comment
comment|/* blank character before next word */
end_comment

begin_define
define|#
directive|define
name|MMAN_spc_force
value|(1<< 1)
end_define

begin_comment
comment|/* even before trailing punctuation */
end_comment

begin_define
define|#
directive|define
name|MMAN_nl
value|(1<< 2)
end_define

begin_comment
comment|/* break man(7) code line */
end_comment

begin_define
define|#
directive|define
name|MMAN_br
value|(1<< 3)
end_define

begin_comment
comment|/* break output line */
end_comment

begin_define
define|#
directive|define
name|MMAN_sp
value|(1<< 4)
end_define

begin_comment
comment|/* insert a blank output line */
end_comment

begin_define
define|#
directive|define
name|MMAN_PP
value|(1<< 5)
end_define

begin_comment
comment|/* reset indentation etc. */
end_comment

begin_define
define|#
directive|define
name|MMAN_Sm
value|(1<< 6)
end_define

begin_comment
comment|/* horizontal spacing mode */
end_comment

begin_define
define|#
directive|define
name|MMAN_Bk
value|(1<< 7)
end_define

begin_comment
comment|/* word keep mode */
end_comment

begin_define
define|#
directive|define
name|MMAN_Bk_susp
value|(1<< 8)
end_define

begin_comment
comment|/* suspend this (after a macro) */
end_comment

begin_define
define|#
directive|define
name|MMAN_An_split
value|(1<< 9)
end_define

begin_comment
comment|/* author mode is "split" */
end_comment

begin_define
define|#
directive|define
name|MMAN_An_nosplit
value|(1<< 10)
end_define

begin_comment
comment|/* author mode is "nosplit" */
end_comment

begin_define
define|#
directive|define
name|MMAN_PD
value|(1<< 11)
end_define

begin_comment
comment|/* inter-paragraph spacing disabled */
end_comment

begin_define
define|#
directive|define
name|MMAN_nbrword
value|(1<< 12)
end_define

begin_comment
comment|/* do not break the next word */
end_comment

begin_define
define|#
directive|define
name|BL_STACK_MAX
value|32
end_define

begin_decl_stmt
specifier|static
name|int
name|Bl_stack
index|[
name|BL_STACK_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* offsets [chars] */
end_comment

begin_decl_stmt
specifier|static
name|int
name|Bl_stack_post
index|[
name|BL_STACK_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* add final .RE */
end_comment

begin_decl_stmt
specifier|static
name|int
name|Bl_stack_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of nested Bl blocks */
end_comment

begin_decl_stmt
specifier|static
name|int
name|TPremain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* characters before tag is full */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|char
modifier|*
name|head
decl_stmt|;
name|char
modifier|*
name|tail
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|}
name|fontqueue
struct|;
end_struct

begin_function
specifier|static
name|int
name|man_strlen
parameter_list|(
specifier|const
name|char
modifier|*
name|cp
parameter_list|)
block|{
name|size_t
name|rsz
decl_stmt|;
name|int
name|skip
decl_stmt|,
name|sz
decl_stmt|;
name|sz
operator|=
literal|0
expr_stmt|;
name|skip
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|rsz
operator|=
name|strcspn
argument_list|(
name|cp
argument_list|,
literal|"\\"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsz
condition|)
block|{
name|cp
operator|+=
name|rsz
expr_stmt|;
if|if
condition|(
name|skip
condition|)
block|{
name|skip
operator|=
literal|0
expr_stmt|;
name|rsz
operator|--
expr_stmt|;
block|}
name|sz
operator|+=
name|rsz
expr_stmt|;
block|}
if|if
condition|(
literal|'\0'
operator|==
operator|*
name|cp
condition|)
break|break;
name|cp
operator|++
expr_stmt|;
switch|switch
condition|(
name|mandoc_escape
argument_list|(
operator|&
name|cp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
case|case
name|ESCAPE_ERROR
case|:
return|return
name|sz
return|;
case|case
name|ESCAPE_UNICODE
case|:
case|case
name|ESCAPE_NUMBERED
case|:
case|case
name|ESCAPE_SPECIAL
case|:
case|case
name|ESCAPE_OVERSTRIKE
case|:
if|if
condition|(
name|skip
condition|)
name|skip
operator|=
literal|0
expr_stmt|;
else|else
name|sz
operator|++
expr_stmt|;
break|break;
case|case
name|ESCAPE_SKIPCHAR
case|:
name|skip
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|sz
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|font_push
parameter_list|(
name|char
name|newfont
parameter_list|)
block|{
if|if
condition|(
name|fontqueue
operator|.
name|head
operator|+
name|fontqueue
operator|.
name|size
operator|<=
operator|++
name|fontqueue
operator|.
name|tail
condition|)
block|{
name|fontqueue
operator|.
name|size
operator|+=
literal|8
expr_stmt|;
name|fontqueue
operator|.
name|head
operator|=
name|mandoc_realloc
argument_list|(
name|fontqueue
operator|.
name|head
argument_list|,
name|fontqueue
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
operator|*
name|fontqueue
operator|.
name|tail
operator|=
name|newfont
expr_stmt|;
name|print_word
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\\f"
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
name|newfont
argument_list|)
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|font_pop
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|fontqueue
operator|.
name|tail
operator|>
name|fontqueue
operator|.
name|head
condition|)
name|fontqueue
operator|.
name|tail
operator|--
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
name|print_word
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\\f"
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
operator|*
name|fontqueue
operator|.
name|tail
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_word
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
operator|(
name|MMAN_PP
operator||
name|MMAN_sp
operator||
name|MMAN_br
operator||
name|MMAN_nl
operator|)
operator|&
name|outflags
condition|)
block|{
comment|/* 		 * If we need a newline, print it now and start afresh. 		 */
if|if
condition|(
name|MMAN_PP
operator|&
name|outflags
condition|)
block|{
if|if
condition|(
name|MMAN_sp
operator|&
name|outflags
condition|)
block|{
if|if
condition|(
name|MMAN_PD
operator|&
name|outflags
condition|)
block|{
name|printf
argument_list|(
literal|"\n.PD"
argument_list|)
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_PD
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|MMAN_PD
operator|&
name|outflags
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\n.PD 0"
argument_list|)
expr_stmt|;
name|outflags
operator||=
name|MMAN_PD
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n.PP\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MMAN_sp
operator|&
name|outflags
condition|)
name|printf
argument_list|(
literal|"\n.sp\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|MMAN_br
operator|&
name|outflags
condition|)
name|printf
argument_list|(
literal|"\n.br\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|MMAN_nl
operator|&
name|outflags
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|outflags
operator|&=
operator|~
operator|(
name|MMAN_PP
operator||
name|MMAN_sp
operator||
name|MMAN_br
operator||
name|MMAN_nl
operator||
name|MMAN_spc
operator|)
expr_stmt|;
if|if
condition|(
literal|1
operator|==
name|TPremain
condition|)
name|printf
argument_list|(
literal|".br\n"
argument_list|)
expr_stmt|;
name|TPremain
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MMAN_spc
operator|&
name|outflags
condition|)
block|{
comment|/* 		 * If we need a space, only print it if 		 * (1) it is forced by `No' or 		 * (2) what follows is not terminating punctuation or 		 * (3) what follows is longer than one character. 		 */
if|if
condition|(
name|MMAN_spc_force
operator|&
name|outflags
operator|||
literal|'\0'
operator|==
name|s
index|[
literal|0
index|]
operator|||
name|NULL
operator|==
name|strchr
argument_list|(
literal|".,:;)]?!"
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|)
operator|||
literal|'\0'
operator|!=
name|s
index|[
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|MMAN_Bk
operator|&
name|outflags
operator|&&
operator|!
operator|(
name|MMAN_Bk_susp
operator|&
name|outflags
operator|)
condition|)
name|putchar
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|TPremain
condition|)
name|TPremain
operator|--
expr_stmt|;
block|}
block|}
comment|/* 	 * Reassign needing space if we're not following opening 	 * punctuation. 	 */
if|if
condition|(
name|MMAN_Sm
operator|&
name|outflags
operator|&&
operator|(
literal|'\0'
operator|==
name|s
index|[
literal|0
index|]
operator|||
operator|(
operator|(
literal|'('
operator|!=
name|s
index|[
literal|0
index|]
operator|&&
literal|'['
operator|!=
name|s
index|[
literal|0
index|]
operator|)
operator|||
literal|'\0'
operator|!=
name|s
index|[
literal|1
index|]
operator|)
operator|)
condition|)
name|outflags
operator||=
name|MMAN_spc
expr_stmt|;
else|else
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
name|outflags
operator|&=
operator|~
operator|(
name|MMAN_spc_force
operator||
name|MMAN_Bk_susp
operator|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
name|ASCII_NBRSP
case|:
name|printf
argument_list|(
literal|"\\ "
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASCII_HYPH
case|:
name|putchar
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASCII_BREAK
case|:
name|printf
argument_list|(
literal|"\\:"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|' '
case|:
if|if
condition|(
name|MMAN_nbrword
operator|&
name|outflags
condition|)
block|{
name|printf
argument_list|(
literal|"\\ "
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
default|default:
name|putchar
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|TPremain
condition|)
name|TPremain
operator|--
expr_stmt|;
block|}
name|outflags
operator|&=
operator|~
name|MMAN_nbrword
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_line
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|newflags
parameter_list|)
block|{
name|outflags
operator||=
name|MMAN_nl
expr_stmt|;
name|print_word
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|outflags
operator||=
name|newflags
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_block
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|newflags
parameter_list|)
block|{
name|outflags
operator|&=
operator|~
name|MMAN_PP
expr_stmt|;
if|if
condition|(
name|MMAN_sp
operator|&
name|outflags
condition|)
block|{
name|outflags
operator|&=
operator|~
operator|(
name|MMAN_sp
operator||
name|MMAN_br
operator|)
expr_stmt|;
if|if
condition|(
name|MMAN_PD
operator|&
name|outflags
condition|)
block|{
name|print_line
argument_list|(
literal|".PD"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_PD
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|MMAN_PD
operator|&
name|outflags
operator|)
condition|)
name|print_line
argument_list|(
literal|".PD 0"
argument_list|,
name|MMAN_PD
argument_list|)
expr_stmt|;
name|outflags
operator||=
name|MMAN_nl
expr_stmt|;
name|print_word
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|outflags
operator||=
name|MMAN_Bk_susp
operator||
name|newflags
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_offs
parameter_list|(
specifier|const
name|char
modifier|*
name|v
parameter_list|,
name|int
name|keywords
parameter_list|)
block|{
name|char
name|buf
index|[
literal|24
index|]
decl_stmt|;
name|struct
name|roffsu
name|su
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
decl_stmt|;
name|int
name|sz
decl_stmt|;
name|print_line
argument_list|(
literal|".RS"
argument_list|,
name|MMAN_Bk_susp
argument_list|)
expr_stmt|;
comment|/* Convert v into a number (of characters). */
if|if
condition|(
name|NULL
operator|==
name|v
operator|||
literal|'\0'
operator|==
operator|*
name|v
operator|||
operator|(
name|keywords
operator|&&
operator|!
name|strcmp
argument_list|(
name|v
argument_list|,
literal|"left"
argument_list|)
operator|)
condition|)
name|sz
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|keywords
operator|&&
operator|!
name|strcmp
argument_list|(
name|v
argument_list|,
literal|"indent"
argument_list|)
condition|)
name|sz
operator|=
literal|6
expr_stmt|;
elseif|else
if|if
condition|(
name|keywords
operator|&&
operator|!
name|strcmp
argument_list|(
name|v
argument_list|,
literal|"indent-two"
argument_list|)
condition|)
name|sz
operator|=
literal|12
expr_stmt|;
else|else
block|{
name|end
operator|=
name|a2roffsu
argument_list|(
name|v
argument_list|,
operator|&
name|su
argument_list|,
name|SCALE_EN
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|==
name|NULL
operator|||
operator|*
name|end
operator|!=
literal|'\0'
condition|)
name|sz
operator|=
name|man_strlen
argument_list|(
name|v
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SCALE_EN
operator|==
name|su
operator|.
name|unit
condition|)
name|sz
operator|=
name|su
operator|.
name|scale
expr_stmt|;
else|else
block|{
comment|/* 			 * XXX 			 * If we are inside an enclosing list, 			 * there is no easy way to add the two 			 * indentations because they are provided 			 * in terms of different units. 			 */
name|print_word
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|outflags
operator||=
name|MMAN_nl
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * We are inside an enclosing list. 	 * Add the two indentations. 	 */
if|if
condition|(
name|Bl_stack_len
condition|)
name|sz
operator|+=
name|Bl_stack
index|[
name|Bl_stack_len
operator|-
literal|1
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%dn"
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|print_word
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|outflags
operator||=
name|MMAN_nl
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set up the indentation for a list item; used from pre_it().  */
end_comment

begin_function
specifier|static
name|void
name|print_width
parameter_list|(
specifier|const
name|struct
name|mdoc_bl
modifier|*
name|bl
parameter_list|,
specifier|const
name|struct
name|roff_node
modifier|*
name|child
parameter_list|)
block|{
name|char
name|buf
index|[
literal|24
index|]
decl_stmt|;
name|struct
name|roffsu
name|su
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
decl_stmt|;
name|int
name|numeric
decl_stmt|,
name|remain
decl_stmt|,
name|sz
decl_stmt|,
name|chsz
decl_stmt|;
name|numeric
operator|=
literal|1
expr_stmt|;
name|remain
operator|=
literal|0
expr_stmt|;
comment|/* Convert the width into a number (of characters). */
if|if
condition|(
name|bl
operator|->
name|width
operator|==
name|NULL
condition|)
name|sz
operator|=
operator|(
name|bl
operator|->
name|type
operator|==
name|LIST_hang
operator|)
condition|?
literal|6
else|:
literal|0
expr_stmt|;
else|else
block|{
name|end
operator|=
name|a2roffsu
argument_list|(
name|bl
operator|->
name|width
argument_list|,
operator|&
name|su
argument_list|,
name|SCALE_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|==
name|NULL
operator|||
operator|*
name|end
operator|!=
literal|'\0'
condition|)
name|sz
operator|=
name|man_strlen
argument_list|(
name|bl
operator|->
name|width
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SCALE_EN
operator|==
name|su
operator|.
name|unit
condition|)
name|sz
operator|=
name|su
operator|.
name|scale
expr_stmt|;
else|else
block|{
name|sz
operator|=
literal|0
expr_stmt|;
name|numeric
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* XXX Rough estimation, might have multiple parts. */
if|if
condition|(
name|bl
operator|->
name|type
operator|==
name|LIST_enum
condition|)
name|chsz
operator|=
operator|(
name|bl
operator|->
name|count
operator|>
literal|8
operator|)
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|child
operator|!=
name|NULL
operator|&&
name|child
operator|->
name|type
operator|==
name|ROFFT_TEXT
condition|)
name|chsz
operator|=
name|man_strlen
argument_list|(
name|child
operator|->
name|string
argument_list|)
expr_stmt|;
else|else
name|chsz
operator|=
literal|0
expr_stmt|;
comment|/* Maybe we are inside an enclosing list? */
name|mid_it
argument_list|()
expr_stmt|;
comment|/* 	 * Save our own indentation, 	 * such that child lists can use it. 	 */
name|Bl_stack
index|[
name|Bl_stack_len
operator|++
index|]
operator|=
name|sz
operator|+
literal|2
expr_stmt|;
comment|/* Set up the current list. */
if|if
condition|(
name|chsz
operator|>
name|sz
operator|&&
name|bl
operator|->
name|type
operator|!=
name|LIST_tag
condition|)
name|print_block
argument_list|(
literal|".HP"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|print_block
argument_list|(
literal|".TP"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|remain
operator|=
name|sz
operator|+
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|numeric
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%dn"
argument_list|,
name|sz
operator|+
literal|2
argument_list|)
expr_stmt|;
name|print_word
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
name|print_word
argument_list|(
name|bl
operator|->
name|width
argument_list|)
expr_stmt|;
name|TPremain
operator|=
name|remain
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_count
parameter_list|(
name|int
modifier|*
name|count
parameter_list|)
block|{
name|char
name|buf
index|[
literal|24
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%d.\\&"
argument_list|,
operator|++
operator|*
name|count
argument_list|)
expr_stmt|;
name|print_word
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|man_man
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|struct
name|roff_man
modifier|*
name|man
parameter_list|)
block|{
comment|/* 	 * Dump the keep buffer. 	 * We're guaranteed by now that this exists (is non-NULL). 	 * Flush stdout afterward, just in case. 	 */
name|fputs
argument_list|(
name|mparse_getkeep
argument_list|(
name|man_mparse
argument_list|(
name|man
argument_list|)
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|man_mdoc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|struct
name|roff_man
modifier|*
name|mdoc
parameter_list|)
block|{
name|struct
name|roff_node
modifier|*
name|n
decl_stmt|;
name|printf
argument_list|(
literal|".TH \"%s\" \"%s\" \"%s\" \"%s\" \"%s\"\n"
argument_list|,
name|mdoc
operator|->
name|meta
operator|.
name|title
argument_list|,
operator|(
name|mdoc
operator|->
name|meta
operator|.
name|msec
operator|==
name|NULL
condition|?
literal|""
else|:
name|mdoc
operator|->
name|meta
operator|.
name|msec
operator|)
argument_list|,
name|mdoc
operator|->
name|meta
operator|.
name|date
argument_list|,
name|mdoc
operator|->
name|meta
operator|.
name|os
argument_list|,
name|mdoc
operator|->
name|meta
operator|.
name|vol
argument_list|)
expr_stmt|;
comment|/* Disable hyphenation and if nroff, disable justification. */
name|printf
argument_list|(
literal|".nh\n.if n .ad l"
argument_list|)
expr_stmt|;
name|outflags
operator|=
name|MMAN_nl
operator||
name|MMAN_Sm
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|fontqueue
operator|.
name|size
condition|)
block|{
name|fontqueue
operator|.
name|size
operator|=
literal|8
expr_stmt|;
name|fontqueue
operator|.
name|head
operator|=
name|fontqueue
operator|.
name|tail
operator|=
name|mandoc_malloc
argument_list|(
literal|8
argument_list|)
expr_stmt|;
operator|*
name|fontqueue
operator|.
name|tail
operator|=
literal|'R'
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
name|mdoc
operator|->
name|first
operator|->
name|child
init|;
name|n
operator|!=
name|NULL
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
name|print_node
argument_list|(
operator|&
name|mdoc
operator|->
name|meta
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_node
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
specifier|const
name|struct
name|manact
modifier|*
name|act
decl_stmt|;
name|struct
name|roff_node
modifier|*
name|sub
decl_stmt|;
name|int
name|cond
decl_stmt|,
name|do_sub
decl_stmt|;
if|if
condition|(
name|n
operator|->
name|flags
operator|&
name|NODE_NOPRT
condition|)
return|return;
comment|/* 	 * Break the line if we were parsed subsequent the current node. 	 * This makes the page structure be more consistent. 	 */
if|if
condition|(
name|MMAN_spc
operator|&
name|outflags
operator|&&
name|NODE_LINE
operator|&
name|n
operator|->
name|flags
condition|)
name|outflags
operator||=
name|MMAN_nl
expr_stmt|;
name|act
operator|=
name|NULL
expr_stmt|;
name|cond
operator|=
literal|0
expr_stmt|;
name|do_sub
operator|=
literal|1
expr_stmt|;
name|n
operator|->
name|flags
operator|&=
operator|~
name|NODE_ENDED
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_TEXT
condition|)
block|{
comment|/* 		 * Make sure that we don't happen to start with a 		 * control character at the start of a line. 		 */
if|if
condition|(
name|MMAN_nl
operator|&
name|outflags
operator|&&
operator|(
literal|'.'
operator|==
operator|*
name|n
operator|->
name|string
operator|||
literal|'\''
operator|==
operator|*
name|n
operator|->
name|string
operator|)
condition|)
block|{
name|print_word
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\\&"
argument_list|)
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|->
name|flags
operator|&
name|NODE_DELIMC
condition|)
name|outflags
operator|&=
operator|~
operator|(
name|MMAN_spc
operator||
name|MMAN_spc_force
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|outflags
operator|&
name|MMAN_Sm
condition|)
name|outflags
operator||=
name|MMAN_spc_force
expr_stmt|;
name|print_word
argument_list|(
name|n
operator|->
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|flags
operator|&
name|NODE_DELIMO
condition|)
name|outflags
operator|&=
operator|~
operator|(
name|MMAN_spc
operator||
name|MMAN_spc_force
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|outflags
operator|&
name|MMAN_Sm
condition|)
name|outflags
operator||=
name|MMAN_spc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|->
name|tok
operator|<
name|ROFF_MAX
condition|)
block|{
call|(
modifier|*
name|roff_manacts
index|[
name|n
operator|->
name|tok
index|]
call|)
argument_list|(
name|meta
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|assert
argument_list|(
name|n
operator|->
name|tok
operator|>=
name|MDOC_Dd
operator|&&
name|n
operator|->
name|tok
operator|<
name|MDOC_MAX
argument_list|)
expr_stmt|;
comment|/* 		 * Conditionally run the pre-node action handler for a 		 * node. 		 */
name|act
operator|=
name|manacts
operator|+
name|n
operator|->
name|tok
expr_stmt|;
name|cond
operator|=
name|act
operator|->
name|cond
operator|==
name|NULL
operator|||
call|(
modifier|*
name|act
operator|->
name|cond
call|)
argument_list|(
name|meta
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
operator|&&
name|act
operator|->
name|pre
operator|!=
name|NULL
operator|&&
operator|(
name|n
operator|->
name|end
operator|==
name|ENDBODY_NOT
operator|||
name|n
operator|->
name|child
operator|!=
name|NULL
operator|)
condition|)
name|do_sub
operator|=
call|(
modifier|*
name|act
operator|->
name|pre
call|)
argument_list|(
name|meta
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Conditionally run all child nodes. 	 * Note that this iterates over children instead of using 	 * recursion.  This prevents unnecessary depth in the stack. 	 */
if|if
condition|(
name|do_sub
condition|)
for|for
control|(
name|sub
operator|=
name|n
operator|->
name|child
init|;
name|sub
condition|;
name|sub
operator|=
name|sub
operator|->
name|next
control|)
name|print_node
argument_list|(
name|meta
argument_list|,
name|sub
argument_list|)
expr_stmt|;
comment|/* 	 * Lastly, conditionally run the post-node handler. 	 */
if|if
condition|(
name|NODE_ENDED
operator|&
name|n
operator|->
name|flags
condition|)
return|return;
if|if
condition|(
name|cond
operator|&&
name|act
operator|->
name|post
condition|)
call|(
modifier|*
name|act
operator|->
name|post
call|)
argument_list|(
name|meta
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|ENDBODY_NOT
operator|!=
name|n
operator|->
name|end
condition|)
name|n
operator|->
name|body
operator|->
name|flags
operator||=
name|NODE_ENDED
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cond_head
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
return|return
name|n
operator|->
name|type
operator|==
name|ROFFT_HEAD
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cond_body
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
return|return
name|n
operator|->
name|type
operator|==
name|ROFFT_BODY
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_enc
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
name|prefix
operator|=
name|manacts
index|[
name|n
operator|->
name|tok
index|]
operator|.
name|prefix
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|prefix
condition|)
return|return
literal|1
return|;
name|print_word
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_enc
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|suffix
decl_stmt|;
name|suffix
operator|=
name|manacts
index|[
name|n
operator|->
name|tok
index|]
operator|.
name|suffix
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|suffix
condition|)
return|return;
name|outflags
operator|&=
operator|~
operator|(
name|MMAN_spc
operator||
name|MMAN_nl
operator|)
expr_stmt|;
name|print_word
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_ex
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|outflags
operator||=
name|MMAN_br
operator||
name|MMAN_nl
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_font
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|font_pop
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_percent
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|pre_em
operator|==
name|manacts
index|[
name|n
operator|->
name|tok
index|]
operator|.
name|pre
condition|)
name|font_pop
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|next
condition|)
block|{
name|print_word
argument_list|(
literal|","
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|prev
operator|&&
name|n
operator|->
name|prev
operator|->
name|tok
operator|==
name|n
operator|->
name|tok
operator|&&
name|n
operator|->
name|next
operator|->
name|tok
operator|==
name|n
operator|->
name|tok
condition|)
name|print_word
argument_list|(
literal|"and"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|print_word
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|outflags
operator||=
name|MMAN_nl
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|pre__t
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|n
operator|->
name|parent
operator|->
name|tok
operator|==
name|MDOC_Rs
operator|&&
name|n
operator|->
name|parent
operator|->
name|norm
operator|->
name|Rs
operator|.
name|quote_T
condition|)
block|{
name|print_word
argument_list|(
literal|"\\(lq"
argument_list|)
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
block|}
else|else
name|font_push
argument_list|(
literal|'I'
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|post__t
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|n
operator|->
name|parent
operator|->
name|tok
operator|==
name|MDOC_Rs
operator|&&
name|n
operator|->
name|parent
operator|->
name|norm
operator|->
name|Rs
operator|.
name|quote_T
condition|)
block|{
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
name|print_word
argument_list|(
literal|"\\(rq"
argument_list|)
expr_stmt|;
block|}
else|else
name|font_pop
argument_list|()
expr_stmt|;
name|post_percent
argument_list|(
name|meta
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print before a section header.  */
end_comment

begin_function
specifier|static
name|int
name|pre_sect
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_HEAD
condition|)
block|{
name|outflags
operator||=
name|MMAN_sp
expr_stmt|;
name|print_block
argument_list|(
name|manacts
index|[
name|n
operator|->
name|tok
index|]
operator|.
name|prefix
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|print_word
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\"'
argument_list|)
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Print subsequent a section header.  */
end_comment

begin_function
specifier|static
name|void
name|post_sect
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|n
operator|->
name|type
operator|!=
name|ROFFT_HEAD
condition|)
return|return;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
name|print_word
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\"'
argument_list|)
expr_stmt|;
name|outflags
operator||=
name|MMAN_nl
expr_stmt|;
if|if
condition|(
name|MDOC_Sh
operator|==
name|n
operator|->
name|tok
operator|&&
name|SEC_AUTHORS
operator|==
name|n
operator|->
name|sec
condition|)
name|outflags
operator|&=
operator|~
operator|(
name|MMAN_An_split
operator||
name|MMAN_An_nosplit
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* See mdoc_term.c, synopsis_pre() for comments. */
end_comment

begin_function
specifier|static
name|void
name|pre_syn
parameter_list|(
specifier|const
name|struct
name|roff_node
modifier|*
name|n
parameter_list|)
block|{
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|prev
operator|||
operator|!
operator|(
name|NODE_SYNPRETTY
operator|&
name|n
operator|->
name|flags
operator|)
condition|)
return|return;
if|if
condition|(
name|n
operator|->
name|prev
operator|->
name|tok
operator|==
name|n
operator|->
name|tok
operator|&&
name|MDOC_Ft
operator|!=
name|n
operator|->
name|tok
operator|&&
name|MDOC_Fo
operator|!=
name|n
operator|->
name|tok
operator|&&
name|MDOC_Fn
operator|!=
name|n
operator|->
name|tok
condition|)
block|{
name|outflags
operator||=
name|MMAN_br
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|n
operator|->
name|prev
operator|->
name|tok
condition|)
block|{
case|case
name|MDOC_Fd
case|:
case|case
name|MDOC_Fn
case|:
case|case
name|MDOC_Fo
case|:
case|case
name|MDOC_In
case|:
case|case
name|MDOC_Vt
case|:
name|outflags
operator||=
name|MMAN_sp
expr_stmt|;
break|break;
case|case
name|MDOC_Ft
case|:
if|if
condition|(
name|MDOC_Fn
operator|!=
name|n
operator|->
name|tok
operator|&&
name|MDOC_Fo
operator|!=
name|n
operator|->
name|tok
condition|)
block|{
name|outflags
operator||=
name|MMAN_sp
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
default|default:
name|outflags
operator||=
name|MMAN_br
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|pre_an
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
switch|switch
condition|(
name|n
operator|->
name|norm
operator|->
name|An
operator|.
name|auth
condition|)
block|{
case|case
name|AUTH_split
case|:
name|outflags
operator|&=
operator|~
name|MMAN_An_nosplit
expr_stmt|;
name|outflags
operator||=
name|MMAN_An_split
expr_stmt|;
return|return
literal|0
return|;
case|case
name|AUTH_nosplit
case|:
name|outflags
operator|&=
operator|~
name|MMAN_An_split
expr_stmt|;
name|outflags
operator||=
name|MMAN_An_nosplit
expr_stmt|;
return|return
literal|0
return|;
default|default:
if|if
condition|(
name|MMAN_An_split
operator|&
name|outflags
condition|)
name|outflags
operator||=
name|MMAN_br
expr_stmt|;
elseif|else
if|if
condition|(
name|SEC_AUTHORS
operator|==
name|n
operator|->
name|sec
operator|&&
operator|!
operator|(
name|MMAN_An_nosplit
operator|&
name|outflags
operator|)
condition|)
name|outflags
operator||=
name|MMAN_An_split
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|pre_ap
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
name|print_word
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_aq
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|print_word
argument_list|(
name|n
operator|->
name|child
operator|!=
name|NULL
operator|&&
name|n
operator|->
name|child
operator|->
name|next
operator|==
name|NULL
operator|&&
name|n
operator|->
name|child
operator|->
name|tok
operator|==
name|MDOC_Mt
condition|?
literal|"<"
else|:
literal|"\\(la"
argument_list|)
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_aq
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|outflags
operator|&=
operator|~
operator|(
name|MMAN_spc
operator||
name|MMAN_nl
operator|)
expr_stmt|;
name|print_word
argument_list|(
name|n
operator|->
name|child
operator|!=
name|NULL
operator|&&
name|n
operator|->
name|child
operator|->
name|next
operator|==
name|NULL
operator|&&
name|n
operator|->
name|child
operator|->
name|tok
operator|==
name|MDOC_Mt
condition|?
literal|">"
else|:
literal|"\\(ra"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_bd
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|outflags
operator|&=
operator|~
operator|(
name|MMAN_PP
operator||
name|MMAN_sp
operator||
name|MMAN_br
operator|)
expr_stmt|;
if|if
condition|(
name|DISP_unfilled
operator|==
name|n
operator|->
name|norm
operator|->
name|Bd
operator|.
name|type
operator|||
name|DISP_literal
operator|==
name|n
operator|->
name|norm
operator|->
name|Bd
operator|.
name|type
condition|)
name|print_line
argument_list|(
literal|".nf"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|n
operator|->
name|norm
operator|->
name|Bd
operator|.
name|comp
operator|&&
name|NULL
operator|!=
name|n
operator|->
name|parent
operator|->
name|prev
condition|)
name|outflags
operator||=
name|MMAN_sp
expr_stmt|;
name|print_offs
argument_list|(
name|n
operator|->
name|norm
operator|->
name|Bd
operator|.
name|offs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_bd
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
comment|/* Close out this display. */
name|print_line
argument_list|(
literal|".RE"
argument_list|,
name|MMAN_nl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DISP_unfilled
operator|==
name|n
operator|->
name|norm
operator|->
name|Bd
operator|.
name|type
operator|||
name|DISP_literal
operator|==
name|n
operator|->
name|norm
operator|->
name|Bd
operator|.
name|type
condition|)
name|print_line
argument_list|(
literal|".fi"
argument_list|,
name|MMAN_nl
argument_list|)
expr_stmt|;
comment|/* Maybe we are inside an enclosing list? */
if|if
condition|(
name|NULL
operator|!=
name|n
operator|->
name|parent
operator|->
name|next
condition|)
name|mid_it
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_bf
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
case|case
name|ROFFT_BLOCK
case|:
return|return
literal|1
return|;
case|case
name|ROFFT_BODY
case|:
break|break;
default|default:
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|n
operator|->
name|norm
operator|->
name|Bf
operator|.
name|font
condition|)
block|{
case|case
name|FONT_Em
case|:
name|font_push
argument_list|(
literal|'I'
argument_list|)
expr_stmt|;
break|break;
case|case
name|FONT_Sy
case|:
name|font_push
argument_list|(
literal|'B'
argument_list|)
expr_stmt|;
break|break;
default|default:
name|font_push
argument_list|(
literal|'R'
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_bf
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_BODY
condition|)
name|font_pop
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_bk
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
case|case
name|ROFFT_BLOCK
case|:
return|return
literal|1
return|;
case|case
name|ROFFT_BODY
case|:
case|case
name|ROFFT_ELEM
case|:
name|outflags
operator||=
name|MMAN_Bk
expr_stmt|;
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|post_bk
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
case|case
name|ROFFT_ELEM
case|:
while|while
condition|(
operator|(
name|n
operator|=
name|n
operator|->
name|parent
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|n
operator|->
name|tok
operator|==
name|MDOC_Bk
condition|)
return|return;
comment|/* FALLTHROUGH */
case|case
name|ROFFT_BODY
case|:
name|outflags
operator|&=
operator|~
name|MMAN_Bk
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|pre_bl
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|size_t
name|icol
decl_stmt|;
comment|/* 	 * print_offs() will increase the -offset to account for 	 * a possible enclosing .It, but any enclosed .It blocks 	 * just nest and do not add up their indentation. 	 */
if|if
condition|(
name|n
operator|->
name|norm
operator|->
name|Bl
operator|.
name|offs
condition|)
block|{
name|print_offs
argument_list|(
name|n
operator|->
name|norm
operator|->
name|Bl
operator|.
name|offs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Bl_stack
index|[
name|Bl_stack_len
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|n
operator|->
name|norm
operator|->
name|Bl
operator|.
name|type
condition|)
block|{
case|case
name|LIST_enum
case|:
name|n
operator|->
name|norm
operator|->
name|Bl
operator|.
name|count
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
case|case
name|LIST_column
case|:
break|break;
default|default:
return|return
literal|1
return|;
block|}
if|if
condition|(
name|n
operator|->
name|child
operator|!=
name|NULL
condition|)
block|{
name|print_line
argument_list|(
literal|".TS"
argument_list|,
name|MMAN_nl
argument_list|)
expr_stmt|;
for|for
control|(
name|icol
operator|=
literal|0
init|;
name|icol
operator|<
name|n
operator|->
name|norm
operator|->
name|Bl
operator|.
name|ncols
condition|;
name|icol
operator|++
control|)
name|print_word
argument_list|(
literal|"l"
argument_list|)
expr_stmt|;
name|print_word
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
block|}
name|outflags
operator||=
name|MMAN_nl
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_bl
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
switch|switch
condition|(
name|n
operator|->
name|norm
operator|->
name|Bl
operator|.
name|type
condition|)
block|{
case|case
name|LIST_column
case|:
if|if
condition|(
name|n
operator|->
name|child
operator|!=
name|NULL
condition|)
name|print_line
argument_list|(
literal|".TE"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIST_enum
case|:
name|n
operator|->
name|norm
operator|->
name|Bl
operator|.
name|count
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|n
operator|->
name|norm
operator|->
name|Bl
operator|.
name|offs
condition|)
block|{
name|print_line
argument_list|(
literal|".RE"
argument_list|,
name|MMAN_nl
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|Bl_stack_len
argument_list|)
expr_stmt|;
name|Bl_stack_len
operator|--
expr_stmt|;
name|assert
argument_list|(
literal|0
operator|==
name|Bl_stack
index|[
name|Bl_stack_len
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outflags
operator||=
name|MMAN_PP
operator||
name|MMAN_nl
expr_stmt|;
name|outflags
operator|&=
operator|~
operator|(
name|MMAN_sp
operator||
name|MMAN_br
operator|)
expr_stmt|;
block|}
comment|/* Maybe we are inside an enclosing list? */
if|if
condition|(
name|NULL
operator|!=
name|n
operator|->
name|parent
operator|->
name|next
condition|)
name|mid_it
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pre_br
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|outflags
operator||=
name|MMAN_br
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_dl
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|print_offs
argument_list|(
literal|"6n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_dl
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|print_line
argument_list|(
literal|".RE"
argument_list|,
name|MMAN_nl
argument_list|)
expr_stmt|;
comment|/* Maybe we are inside an enclosing list? */
if|if
condition|(
name|NULL
operator|!=
name|n
operator|->
name|parent
operator|->
name|next
condition|)
name|mid_it
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_em
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|font_push
argument_list|(
literal|'I'
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_en
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|norm
operator|->
name|Es
operator|||
name|NULL
operator|==
name|n
operator|->
name|norm
operator|->
name|Es
operator|->
name|child
condition|)
return|return
literal|1
return|;
name|print_word
argument_list|(
name|n
operator|->
name|norm
operator|->
name|Es
operator|->
name|child
operator|->
name|string
argument_list|)
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_en
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|norm
operator|->
name|Es
operator|||
name|NULL
operator|==
name|n
operator|->
name|norm
operator|->
name|Es
operator|->
name|child
operator|||
name|NULL
operator|==
name|n
operator|->
name|norm
operator|->
name|Es
operator|->
name|child
operator|->
name|next
condition|)
return|return;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
name|print_word
argument_list|(
name|n
operator|->
name|norm
operator|->
name|Es
operator|->
name|child
operator|->
name|next
operator|->
name|string
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_eo
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|n
operator|->
name|end
operator|==
name|ENDBODY_NOT
operator|&&
name|n
operator|->
name|parent
operator|->
name|head
operator|->
name|child
operator|==
name|NULL
operator|&&
name|n
operator|->
name|child
operator|!=
name|NULL
operator|&&
name|n
operator|->
name|child
operator|->
name|end
operator|!=
name|ENDBODY_NOT
condition|)
name|print_word
argument_list|(
literal|"\\&"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|->
name|end
operator|!=
name|ENDBODY_NOT
condition|?
name|n
operator|->
name|child
operator|!=
name|NULL
else|:
name|n
operator|->
name|parent
operator|->
name|head
operator|->
name|child
operator|!=
name|NULL
operator|&&
operator|(
name|n
operator|->
name|child
operator|!=
name|NULL
operator|||
operator|(
name|n
operator|->
name|parent
operator|->
name|tail
operator|!=
name|NULL
operator|&&
name|n
operator|->
name|parent
operator|->
name|tail
operator|->
name|child
operator|!=
name|NULL
operator|)
operator|)
condition|)
name|outflags
operator|&=
operator|~
operator|(
name|MMAN_spc
operator||
name|MMAN_nl
operator|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_eo
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|int
name|body
decl_stmt|,
name|tail
decl_stmt|;
if|if
condition|(
name|n
operator|->
name|end
operator|!=
name|ENDBODY_NOT
condition|)
block|{
name|outflags
operator||=
name|MMAN_spc
expr_stmt|;
return|return;
block|}
name|body
operator|=
name|n
operator|->
name|child
operator|!=
name|NULL
operator|||
name|n
operator|->
name|parent
operator|->
name|head
operator|->
name|child
operator|!=
name|NULL
expr_stmt|;
name|tail
operator|=
name|n
operator|->
name|parent
operator|->
name|tail
operator|!=
name|NULL
operator|&&
name|n
operator|->
name|parent
operator|->
name|tail
operator|->
name|child
operator|!=
name|NULL
expr_stmt|;
if|if
condition|(
name|body
operator|&&
name|tail
condition|)
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|body
operator|||
name|tail
operator|)
condition|)
name|print_word
argument_list|(
literal|"\\&"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|tail
condition|)
name|outflags
operator||=
name|MMAN_spc
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_fa
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|int
name|am_Fa
decl_stmt|;
name|am_Fa
operator|=
name|MDOC_Fa
operator|==
name|n
operator|->
name|tok
expr_stmt|;
if|if
condition|(
name|am_Fa
condition|)
name|n
operator|=
name|n
operator|->
name|child
expr_stmt|;
while|while
condition|(
name|NULL
operator|!=
name|n
condition|)
block|{
name|font_push
argument_list|(
literal|'I'
argument_list|)
expr_stmt|;
if|if
condition|(
name|am_Fa
operator|||
name|NODE_SYNPRETTY
operator|&
name|n
operator|->
name|flags
condition|)
name|outflags
operator||=
name|MMAN_nbrword
expr_stmt|;
name|print_node
argument_list|(
name|meta
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|font_pop
argument_list|()
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|n
operator|=
name|n
operator|->
name|next
operator|)
condition|)
name|print_word
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_fa
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|NULL
operator|!=
name|n
operator|->
name|next
operator|&&
name|MDOC_Fa
operator|==
name|n
operator|->
name|next
operator|->
name|tok
condition|)
name|print_word
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_fd
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|pre_syn
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|font_push
argument_list|(
literal|'B'
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_fd
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|font_pop
argument_list|()
expr_stmt|;
name|outflags
operator||=
name|MMAN_br
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_fl
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|font_push
argument_list|(
literal|'B'
argument_list|)
expr_stmt|;
name|print_word
argument_list|(
literal|"\\-"
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|child
operator|!=
name|NULL
condition|)
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_fl
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|font_pop
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|n
operator|->
name|child
operator|!=
name|NULL
operator|||
name|n
operator|->
name|next
operator|==
name|NULL
operator|||
name|n
operator|->
name|next
operator|->
name|type
operator|==
name|ROFFT_TEXT
operator|||
name|n
operator|->
name|next
operator|->
name|flags
operator|&
name|NODE_LINE
operator|)
condition|)
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_fn
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|pre_syn
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|n
operator|=
name|n
operator|->
name|child
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|n
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|NODE_SYNPRETTY
operator|&
name|n
operator|->
name|flags
condition|)
name|print_block
argument_list|(
literal|".HP 4n"
argument_list|,
name|MMAN_nl
argument_list|)
expr_stmt|;
name|font_push
argument_list|(
literal|'B'
argument_list|)
expr_stmt|;
name|print_node
argument_list|(
name|meta
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|font_pop
argument_list|()
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
name|print_word
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
name|n
operator|=
name|n
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|n
condition|)
name|pre_fa
argument_list|(
name|meta
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_fn
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|print_word
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NODE_SYNPRETTY
operator|&
name|n
operator|->
name|flags
condition|)
block|{
name|print_word
argument_list|(
literal|";"
argument_list|)
expr_stmt|;
name|outflags
operator||=
name|MMAN_PP
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|pre_fo
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
case|case
name|ROFFT_BLOCK
case|:
name|pre_syn
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
name|ROFFT_HEAD
case|:
if|if
condition|(
name|n
operator|->
name|child
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|NODE_SYNPRETTY
operator|&
name|n
operator|->
name|flags
condition|)
name|print_block
argument_list|(
literal|".HP 4n"
argument_list|,
name|MMAN_nl
argument_list|)
expr_stmt|;
name|font_push
argument_list|(
literal|'B'
argument_list|)
expr_stmt|;
break|break;
case|case
name|ROFFT_BODY
case|:
name|outflags
operator|&=
operator|~
operator|(
name|MMAN_spc
operator||
name|MMAN_nl
operator|)
expr_stmt|;
name|print_word
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_fo
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
case|case
name|ROFFT_HEAD
case|:
if|if
condition|(
name|n
operator|->
name|child
operator|!=
name|NULL
condition|)
name|font_pop
argument_list|()
expr_stmt|;
break|break;
case|case
name|ROFFT_BODY
case|:
name|post_fn
argument_list|(
name|meta
argument_list|,
name|n
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|pre_Ft
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|pre_syn
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|font_push
argument_list|(
literal|'I'
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pre_ft
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|print_line
argument_list|(
literal|".ft"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|print_word
argument_list|(
name|n
operator|->
name|child
operator|->
name|string
argument_list|)
expr_stmt|;
name|outflags
operator||=
name|MMAN_nl
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_in
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|NODE_SYNPRETTY
operator|&
name|n
operator|->
name|flags
condition|)
block|{
name|pre_syn
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|font_push
argument_list|(
literal|'B'
argument_list|)
expr_stmt|;
name|print_word
argument_list|(
literal|"#include<"
argument_list|)
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
block|}
else|else
block|{
name|print_word
argument_list|(
literal|"<"
argument_list|)
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
name|font_push
argument_list|(
literal|'I'
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_in
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|NODE_SYNPRETTY
operator|&
name|n
operator|->
name|flags
condition|)
block|{
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
name|print_word
argument_list|(
literal|">"
argument_list|)
expr_stmt|;
name|font_pop
argument_list|()
expr_stmt|;
name|outflags
operator||=
name|MMAN_br
expr_stmt|;
block|}
else|else
block|{
name|font_pop
argument_list|()
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
name|print_word
argument_list|(
literal|">"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|pre_it
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
specifier|const
name|struct
name|roff_node
modifier|*
name|bln
decl_stmt|;
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
case|case
name|ROFFT_HEAD
case|:
name|outflags
operator||=
name|MMAN_PP
operator||
name|MMAN_nl
expr_stmt|;
name|bln
operator|=
name|n
operator|->
name|parent
operator|->
name|parent
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|bln
operator|->
name|norm
operator|->
name|Bl
operator|.
name|comp
operator|||
operator|(
name|NULL
operator|==
name|n
operator|->
name|parent
operator|->
name|prev
operator|&&
name|NULL
operator|==
name|bln
operator|->
name|parent
operator|->
name|prev
operator|)
condition|)
name|outflags
operator||=
name|MMAN_sp
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_br
expr_stmt|;
switch|switch
condition|(
name|bln
operator|->
name|norm
operator|->
name|Bl
operator|.
name|type
condition|)
block|{
case|case
name|LIST_item
case|:
return|return
literal|0
return|;
case|case
name|LIST_inset
case|:
case|case
name|LIST_diag
case|:
case|case
name|LIST_ohang
case|:
if|if
condition|(
name|bln
operator|->
name|norm
operator|->
name|Bl
operator|.
name|type
operator|==
name|LIST_diag
condition|)
name|print_line
argument_list|(
literal|".B \""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|print_line
argument_list|(
literal|".R \""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
return|return
literal|1
return|;
case|case
name|LIST_bullet
case|:
case|case
name|LIST_dash
case|:
case|case
name|LIST_hyphen
case|:
name|print_width
argument_list|(
operator|&
name|bln
operator|->
name|norm
operator|->
name|Bl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TPremain
operator|=
literal|0
expr_stmt|;
name|outflags
operator||=
name|MMAN_nl
expr_stmt|;
name|font_push
argument_list|(
literal|'B'
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIST_bullet
operator|==
name|bln
operator|->
name|norm
operator|->
name|Bl
operator|.
name|type
condition|)
name|print_word
argument_list|(
literal|"\\(bu"
argument_list|)
expr_stmt|;
else|else
name|print_word
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
name|font_pop
argument_list|()
expr_stmt|;
name|outflags
operator||=
name|MMAN_nl
expr_stmt|;
return|return
literal|0
return|;
case|case
name|LIST_enum
case|:
name|print_width
argument_list|(
operator|&
name|bln
operator|->
name|norm
operator|->
name|Bl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TPremain
operator|=
literal|0
expr_stmt|;
name|outflags
operator||=
name|MMAN_nl
expr_stmt|;
name|print_count
argument_list|(
operator|&
name|bln
operator|->
name|norm
operator|->
name|Bl
operator|.
name|count
argument_list|)
expr_stmt|;
name|outflags
operator||=
name|MMAN_nl
expr_stmt|;
return|return
literal|0
return|;
case|case
name|LIST_hang
case|:
name|print_width
argument_list|(
operator|&
name|bln
operator|->
name|norm
operator|->
name|Bl
argument_list|,
name|n
operator|->
name|child
argument_list|)
expr_stmt|;
name|TPremain
operator|=
literal|0
expr_stmt|;
name|outflags
operator||=
name|MMAN_nl
expr_stmt|;
return|return
literal|1
return|;
case|case
name|LIST_tag
case|:
name|print_width
argument_list|(
operator|&
name|bln
operator|->
name|norm
operator|->
name|Bl
argument_list|,
name|n
operator|->
name|child
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
return|return
literal|1
return|;
default|default:
return|return
literal|1
return|;
block|}
default|default:
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * This function is called after closing out an indented block.  * If we are inside an enclosing list, restore its indentation.  */
end_comment

begin_function
specifier|static
name|void
name|mid_it
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|buf
index|[
literal|24
index|]
decl_stmt|;
comment|/* Nothing to do outside a list. */
if|if
condition|(
literal|0
operator|==
name|Bl_stack_len
operator|||
literal|0
operator|==
name|Bl_stack
index|[
name|Bl_stack_len
operator|-
literal|1
index|]
condition|)
return|return;
comment|/* The indentation has already been set up. */
if|if
condition|(
name|Bl_stack_post
index|[
name|Bl_stack_len
operator|-
literal|1
index|]
condition|)
return|return;
comment|/* Restore the indentation of the enclosing list. */
name|print_line
argument_list|(
literal|".RS"
argument_list|,
name|MMAN_Bk_susp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%dn"
argument_list|,
name|Bl_stack
index|[
name|Bl_stack_len
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|print_word
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* Remeber to close out this .RS block later. */
name|Bl_stack_post
index|[
name|Bl_stack_len
operator|-
literal|1
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_it
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
specifier|const
name|struct
name|roff_node
modifier|*
name|bln
decl_stmt|;
name|bln
operator|=
name|n
operator|->
name|parent
operator|->
name|parent
expr_stmt|;
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
case|case
name|ROFFT_HEAD
case|:
switch|switch
condition|(
name|bln
operator|->
name|norm
operator|->
name|Bl
operator|.
name|type
condition|)
block|{
case|case
name|LIST_diag
case|:
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
name|print_word
argument_list|(
literal|"\\ "
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIST_ohang
case|:
name|outflags
operator||=
name|MMAN_br
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|ROFFT_BODY
case|:
switch|switch
condition|(
name|bln
operator|->
name|norm
operator|->
name|Bl
operator|.
name|type
condition|)
block|{
case|case
name|LIST_bullet
case|:
case|case
name|LIST_dash
case|:
case|case
name|LIST_hyphen
case|:
case|case
name|LIST_enum
case|:
case|case
name|LIST_hang
case|:
case|case
name|LIST_tag
case|:
name|assert
argument_list|(
name|Bl_stack_len
argument_list|)
expr_stmt|;
name|Bl_stack
index|[
operator|--
name|Bl_stack_len
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Our indentation had to be restored 			 * after a child display or child list. 			 * Close out that indentation block now. 			 */
if|if
condition|(
name|Bl_stack_post
index|[
name|Bl_stack_len
index|]
condition|)
block|{
name|print_line
argument_list|(
literal|".RE"
argument_list|,
name|MMAN_nl
argument_list|)
expr_stmt|;
name|Bl_stack_post
index|[
name|Bl_stack_len
index|]
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|LIST_column
case|:
if|if
condition|(
name|NULL
operator|!=
name|n
operator|->
name|next
condition|)
block|{
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|post_lb
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|SEC_LIBRARY
operator|==
name|n
operator|->
name|sec
condition|)
name|outflags
operator||=
name|MMAN_br
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_lk
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
specifier|const
name|struct
name|roff_node
modifier|*
name|link
decl_stmt|,
modifier|*
name|descr
decl_stmt|,
modifier|*
name|punct
decl_stmt|;
name|int
name|display
decl_stmt|;
if|if
condition|(
operator|(
name|link
operator|=
name|n
operator|->
name|child
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Find beginning of trailing punctuation. */
name|punct
operator|=
name|n
operator|->
name|last
expr_stmt|;
while|while
condition|(
name|punct
operator|!=
name|link
operator|&&
name|punct
operator|->
name|flags
operator|&
name|NODE_DELIMC
condition|)
name|punct
operator|=
name|punct
operator|->
name|prev
expr_stmt|;
name|punct
operator|=
name|punct
operator|->
name|next
expr_stmt|;
comment|/* Link text. */
if|if
condition|(
operator|(
name|descr
operator|=
name|link
operator|->
name|next
operator|)
operator|!=
name|NULL
operator|&&
name|descr
operator|!=
name|punct
condition|)
block|{
name|font_push
argument_list|(
literal|'I'
argument_list|)
expr_stmt|;
while|while
condition|(
name|descr
operator|!=
name|punct
condition|)
block|{
name|print_word
argument_list|(
name|descr
operator|->
name|string
argument_list|)
expr_stmt|;
name|descr
operator|=
name|descr
operator|->
name|next
expr_stmt|;
block|}
name|font_pop
argument_list|()
expr_stmt|;
name|print_word
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
block|}
comment|/* Link target. */
name|display
operator|=
name|man_strlen
argument_list|(
name|link
operator|->
name|string
argument_list|)
operator|>=
literal|26
expr_stmt|;
if|if
condition|(
name|display
condition|)
block|{
name|print_line
argument_list|(
literal|".RS"
argument_list|,
name|MMAN_Bk_susp
argument_list|)
expr_stmt|;
name|print_word
argument_list|(
literal|"6n"
argument_list|)
expr_stmt|;
name|outflags
operator||=
name|MMAN_nl
expr_stmt|;
block|}
name|font_push
argument_list|(
literal|'B'
argument_list|)
expr_stmt|;
name|print_word
argument_list|(
name|link
operator|->
name|string
argument_list|)
expr_stmt|;
name|font_pop
argument_list|()
expr_stmt|;
comment|/* Trailing punctuation. */
while|while
condition|(
name|punct
operator|!=
name|NULL
condition|)
block|{
name|print_word
argument_list|(
name|punct
operator|->
name|string
argument_list|)
expr_stmt|;
name|punct
operator|=
name|punct
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|display
condition|)
name|print_line
argument_list|(
literal|".RE"
argument_list|,
name|MMAN_nl
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pre_onearg
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|outflags
operator||=
name|MMAN_nl
expr_stmt|;
name|print_word
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
name|print_word
argument_list|(
name|roff_name
index|[
name|n
operator|->
name|tok
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|child
operator|!=
name|NULL
condition|)
name|print_word
argument_list|(
name|n
operator|->
name|child
operator|->
name|string
argument_list|)
expr_stmt|;
name|outflags
operator||=
name|MMAN_nl
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|tok
operator|==
name|ROFF_ce
condition|)
for|for
control|(
name|n
operator|=
name|n
operator|->
name|child
operator|->
name|next
init|;
name|n
operator|!=
name|NULL
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
name|print_node
argument_list|(
name|meta
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_li
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|font_push
argument_list|(
literal|'R'
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_nm
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_BLOCK
condition|)
block|{
name|outflags
operator||=
name|MMAN_Bk
expr_stmt|;
name|pre_syn
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|->
name|type
operator|!=
name|ROFFT_ELEM
operator|&&
name|n
operator|->
name|type
operator|!=
name|ROFFT_HEAD
condition|)
return|return
literal|1
return|;
name|name
operator|=
name|n
operator|->
name|child
operator|==
name|NULL
condition|?
name|NULL
else|:
name|n
operator|->
name|child
operator|->
name|string
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|name
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_HEAD
condition|)
block|{
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|parent
operator|->
name|prev
condition|)
name|outflags
operator||=
name|MMAN_sp
expr_stmt|;
name|print_block
argument_list|(
literal|".HP"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %dn"
argument_list|,
name|man_strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outflags
operator||=
name|MMAN_nl
expr_stmt|;
block|}
name|font_push
argument_list|(
literal|'B'
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_nm
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
case|case
name|ROFFT_BLOCK
case|:
name|outflags
operator|&=
operator|~
name|MMAN_Bk
expr_stmt|;
break|break;
case|case
name|ROFFT_HEAD
case|:
case|case
name|ROFFT_ELEM
case|:
if|if
condition|(
name|n
operator|->
name|child
operator|!=
name|NULL
operator|&&
name|n
operator|->
name|child
operator|->
name|string
operator|!=
name|NULL
condition|)
name|font_pop
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|pre_no
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|outflags
operator||=
name|MMAN_spc_force
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_ns
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_pf
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|n
operator|->
name|next
operator|==
name|NULL
operator|||
name|n
operator|->
name|next
operator|->
name|flags
operator|&
name|NODE_LINE
operator|)
condition|)
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_pp
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|MDOC_It
operator|!=
name|n
operator|->
name|parent
operator|->
name|tok
condition|)
name|outflags
operator||=
name|MMAN_PP
expr_stmt|;
name|outflags
operator||=
name|MMAN_sp
operator||
name|MMAN_nl
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_br
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_rs
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|SEC_SEE_ALSO
operator|==
name|n
operator|->
name|sec
condition|)
block|{
name|outflags
operator||=
name|MMAN_PP
operator||
name|MMAN_sp
operator||
name|MMAN_nl
expr_stmt|;
name|outflags
operator|&=
operator|~
name|MMAN_br
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_skip
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_sm
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|child
condition|)
name|outflags
operator|^=
name|MMAN_Sm
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
literal|"on"
argument_list|,
name|n
operator|->
name|child
operator|->
name|string
argument_list|)
condition|)
name|outflags
operator||=
name|MMAN_Sm
expr_stmt|;
else|else
name|outflags
operator|&=
operator|~
name|MMAN_Sm
expr_stmt|;
if|if
condition|(
name|MMAN_Sm
operator|&
name|outflags
condition|)
name|outflags
operator||=
name|MMAN_spc
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pre_sp
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|outflags
operator|&
name|MMAN_PP
condition|)
block|{
name|outflags
operator|&=
operator|~
name|MMAN_PP
expr_stmt|;
name|print_line
argument_list|(
literal|".PP"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|print_line
argument_list|(
literal|".sp"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|child
operator|!=
name|NULL
condition|)
name|print_word
argument_list|(
name|n
operator|->
name|child
operator|->
name|string
argument_list|)
expr_stmt|;
block|}
name|outflags
operator||=
name|MMAN_nl
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_sy
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|font_push
argument_list|(
literal|'B'
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pre_ta
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|print_line
argument_list|(
literal|".ta"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|n
operator|->
name|child
init|;
name|n
operator|!=
name|NULL
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
name|print_word
argument_list|(
name|n
operator|->
name|string
argument_list|)
expr_stmt|;
name|outflags
operator||=
name|MMAN_nl
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_vt
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|NODE_SYNPRETTY
operator|&
name|n
operator|->
name|flags
condition|)
block|{
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
case|case
name|ROFFT_BLOCK
case|:
name|pre_syn
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|ROFFT_BODY
case|:
break|break;
default|default:
return|return
literal|0
return|;
block|}
block|}
name|font_push
argument_list|(
literal|'I'
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|post_vt
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|n
operator|->
name|flags
operator|&
name|NODE_SYNPRETTY
operator|&&
name|n
operator|->
name|type
operator|!=
name|ROFFT_BODY
condition|)
return|return;
name|font_pop
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pre_xr
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|n
operator|=
name|n
operator|->
name|child
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|n
condition|)
return|return
literal|0
return|;
name|print_node
argument_list|(
name|meta
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|n
operator|=
name|n
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|n
condition|)
return|return
literal|0
return|;
name|outflags
operator|&=
operator|~
name|MMAN_spc
expr_stmt|;
name|print_word
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
name|print_node
argument_list|(
name|meta
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|print_word
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

