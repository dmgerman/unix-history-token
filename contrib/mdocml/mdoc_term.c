begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$Id: mdoc_term.c,v 1.297 2014/11/28 16:54:23 schwarze Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2008, 2009, 2010, 2011 Kristaps Dzonsons<kristaps@bsd.lv>  * Copyright (c) 2010, 2012, 2013, 2014 Ingo Schwarze<schwarze@openbsd.org>  * Copyright (c) 2013 Franco Fichtner<franco@lastsummer.de>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"mandoc.h"
end_include

begin_include
include|#
directive|include
file|"mandoc_aux.h"
end_include

begin_include
include|#
directive|include
file|"out.h"
end_include

begin_include
include|#
directive|include
file|"term.h"
end_include

begin_include
include|#
directive|include
file|"mdoc.h"
end_include

begin_include
include|#
directive|include
file|"main.h"
end_include

begin_struct
struct|struct
name|termpair
block|{
name|struct
name|termpair
modifier|*
name|ppair
decl_stmt|;
name|int
name|count
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DECL_ARGS
value|struct termp *p, \ 		  struct termpair *pair, \ 		  const struct mdoc_meta *meta, \ 		  struct mdoc_node *n
end_define

begin_struct
struct|struct
name|termact
block|{
name|int
function_decl|(
modifier|*
name|pre
function_decl|)
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|post
function_decl|)
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|size_t
name|a2width
parameter_list|(
specifier|const
name|struct
name|termp
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|a2height
parameter_list|(
specifier|const
name|struct
name|termp
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_bvspace
parameter_list|(
name|struct
name|termp
modifier|*
parameter_list|,
specifier|const
name|struct
name|mdoc_node
modifier|*
parameter_list|,
specifier|const
name|struct
name|mdoc_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_mdoc_node
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_mdoc_nodelist
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_mdoc_head
parameter_list|(
name|struct
name|termp
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_mdoc_foot
parameter_list|(
name|struct
name|termp
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|synopsis_pre
parameter_list|(
name|struct
name|termp
modifier|*
parameter_list|,
specifier|const
name|struct
name|mdoc_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|termp____post
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|termp__t_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|termp_bd_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|termp_bk_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|termp_bl_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|termp_fd_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|termp_fo_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|termp_in_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|termp_it_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|termp_lb_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|termp_nm_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|termp_pf_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|termp_quote_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|termp_sh_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|termp_ss_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp__a_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp__t_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_an_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_ap_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_bd_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_bf_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_bk_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_bl_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_bold_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_bt_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_bx_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_cd_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_d1_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_ex_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_fa_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_fd_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_fl_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_fn_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_fo_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_ft_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_in_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_it_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_li_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_ll_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_lk_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_nd_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_nm_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_ns_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_quote_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_rs_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_rv_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_sh_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_skip_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_sm_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_sp_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_ss_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_under_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_ud_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_vt_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_xr_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_xx_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|termact
name|termacts
index|[
name|MDOC_MAX
index|]
init|=
block|{
block|{
name|termp_ap_pre
block|,
name|NULL
block|}
block|,
comment|/* Ap */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Dd */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Dt */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Os */
block|{
name|termp_sh_pre
block|,
name|termp_sh_post
block|}
block|,
comment|/* Sh */
block|{
name|termp_ss_pre
block|,
name|termp_ss_post
block|}
block|,
comment|/* Ss */
block|{
name|termp_sp_pre
block|,
name|NULL
block|}
block|,
comment|/* Pp */
block|{
name|termp_d1_pre
block|,
name|termp_bl_post
block|}
block|,
comment|/* D1 */
block|{
name|termp_d1_pre
block|,
name|termp_bl_post
block|}
block|,
comment|/* Dl */
block|{
name|termp_bd_pre
block|,
name|termp_bd_post
block|}
block|,
comment|/* Bd */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ed */
block|{
name|termp_bl_pre
block|,
name|termp_bl_post
block|}
block|,
comment|/* Bl */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* El */
block|{
name|termp_it_pre
block|,
name|termp_it_post
block|}
block|,
comment|/* It */
block|{
name|termp_under_pre
block|,
name|NULL
block|}
block|,
comment|/* Ad */
block|{
name|termp_an_pre
block|,
name|NULL
block|}
block|,
comment|/* An */
block|{
name|termp_under_pre
block|,
name|NULL
block|}
block|,
comment|/* Ar */
block|{
name|termp_cd_pre
block|,
name|NULL
block|}
block|,
comment|/* Cd */
block|{
name|termp_bold_pre
block|,
name|NULL
block|}
block|,
comment|/* Cm */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Dv */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Er */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ev */
block|{
name|termp_ex_pre
block|,
name|NULL
block|}
block|,
comment|/* Ex */
block|{
name|termp_fa_pre
block|,
name|NULL
block|}
block|,
comment|/* Fa */
block|{
name|termp_fd_pre
block|,
name|termp_fd_post
block|}
block|,
comment|/* Fd */
block|{
name|termp_fl_pre
block|,
name|NULL
block|}
block|,
comment|/* Fl */
block|{
name|termp_fn_pre
block|,
name|NULL
block|}
block|,
comment|/* Fn */
block|{
name|termp_ft_pre
block|,
name|NULL
block|}
block|,
comment|/* Ft */
block|{
name|termp_bold_pre
block|,
name|NULL
block|}
block|,
comment|/* Ic */
block|{
name|termp_in_pre
block|,
name|termp_in_post
block|}
block|,
comment|/* In */
block|{
name|termp_li_pre
block|,
name|NULL
block|}
block|,
comment|/* Li */
block|{
name|termp_nd_pre
block|,
name|NULL
block|}
block|,
comment|/* Nd */
block|{
name|termp_nm_pre
block|,
name|termp_nm_post
block|}
block|,
comment|/* Nm */
block|{
name|termp_quote_pre
block|,
name|termp_quote_post
block|}
block|,
comment|/* Op */
block|{
name|termp_ft_pre
block|,
name|NULL
block|}
block|,
comment|/* Ot */
block|{
name|termp_under_pre
block|,
name|NULL
block|}
block|,
comment|/* Pa */
block|{
name|termp_rv_pre
block|,
name|NULL
block|}
block|,
comment|/* Rv */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* St */
block|{
name|termp_under_pre
block|,
name|NULL
block|}
block|,
comment|/* Va */
block|{
name|termp_vt_pre
block|,
name|NULL
block|}
block|,
comment|/* Vt */
block|{
name|termp_xr_pre
block|,
name|NULL
block|}
block|,
comment|/* Xr */
block|{
name|termp__a_pre
block|,
name|termp____post
block|}
block|,
comment|/* %A */
block|{
name|termp_under_pre
block|,
name|termp____post
block|}
block|,
comment|/* %B */
block|{
name|NULL
block|,
name|termp____post
block|}
block|,
comment|/* %D */
block|{
name|termp_under_pre
block|,
name|termp____post
block|}
block|,
comment|/* %I */
block|{
name|termp_under_pre
block|,
name|termp____post
block|}
block|,
comment|/* %J */
block|{
name|NULL
block|,
name|termp____post
block|}
block|,
comment|/* %N */
block|{
name|NULL
block|,
name|termp____post
block|}
block|,
comment|/* %O */
block|{
name|NULL
block|,
name|termp____post
block|}
block|,
comment|/* %P */
block|{
name|NULL
block|,
name|termp____post
block|}
block|,
comment|/* %R */
block|{
name|termp__t_pre
block|,
name|termp__t_post
block|}
block|,
comment|/* %T */
block|{
name|NULL
block|,
name|termp____post
block|}
block|,
comment|/* %V */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ac */
block|{
name|termp_quote_pre
block|,
name|termp_quote_post
block|}
block|,
comment|/* Ao */
block|{
name|termp_quote_pre
block|,
name|termp_quote_post
block|}
block|,
comment|/* Aq */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* At */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Bc */
block|{
name|termp_bf_pre
block|,
name|NULL
block|}
block|,
comment|/* Bf */
block|{
name|termp_quote_pre
block|,
name|termp_quote_post
block|}
block|,
comment|/* Bo */
block|{
name|termp_quote_pre
block|,
name|termp_quote_post
block|}
block|,
comment|/* Bq */
block|{
name|termp_xx_pre
block|,
name|NULL
block|}
block|,
comment|/* Bsx */
block|{
name|termp_bx_pre
block|,
name|NULL
block|}
block|,
comment|/* Bx */
block|{
name|termp_skip_pre
block|,
name|NULL
block|}
block|,
comment|/* Db */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Dc */
block|{
name|termp_quote_pre
block|,
name|termp_quote_post
block|}
block|,
comment|/* Do */
block|{
name|termp_quote_pre
block|,
name|termp_quote_post
block|}
block|,
comment|/* Dq */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ec */
comment|/* FIXME: no space */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ef */
block|{
name|termp_under_pre
block|,
name|NULL
block|}
block|,
comment|/* Em */
block|{
name|termp_quote_pre
block|,
name|termp_quote_post
block|}
block|,
comment|/* Eo */
block|{
name|termp_xx_pre
block|,
name|NULL
block|}
block|,
comment|/* Fx */
block|{
name|termp_bold_pre
block|,
name|NULL
block|}
block|,
comment|/* Ms */
block|{
name|termp_li_pre
block|,
name|NULL
block|}
block|,
comment|/* No */
block|{
name|termp_ns_pre
block|,
name|NULL
block|}
block|,
comment|/* Ns */
block|{
name|termp_xx_pre
block|,
name|NULL
block|}
block|,
comment|/* Nx */
block|{
name|termp_xx_pre
block|,
name|NULL
block|}
block|,
comment|/* Ox */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Pc */
block|{
name|NULL
block|,
name|termp_pf_post
block|}
block|,
comment|/* Pf */
block|{
name|termp_quote_pre
block|,
name|termp_quote_post
block|}
block|,
comment|/* Po */
block|{
name|termp_quote_pre
block|,
name|termp_quote_post
block|}
block|,
comment|/* Pq */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Qc */
block|{
name|termp_quote_pre
block|,
name|termp_quote_post
block|}
block|,
comment|/* Ql */
block|{
name|termp_quote_pre
block|,
name|termp_quote_post
block|}
block|,
comment|/* Qo */
block|{
name|termp_quote_pre
block|,
name|termp_quote_post
block|}
block|,
comment|/* Qq */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Re */
block|{
name|termp_rs_pre
block|,
name|NULL
block|}
block|,
comment|/* Rs */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Sc */
block|{
name|termp_quote_pre
block|,
name|termp_quote_post
block|}
block|,
comment|/* So */
block|{
name|termp_quote_pre
block|,
name|termp_quote_post
block|}
block|,
comment|/* Sq */
block|{
name|termp_sm_pre
block|,
name|NULL
block|}
block|,
comment|/* Sm */
block|{
name|termp_under_pre
block|,
name|NULL
block|}
block|,
comment|/* Sx */
block|{
name|termp_bold_pre
block|,
name|NULL
block|}
block|,
comment|/* Sy */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Tn */
block|{
name|termp_xx_pre
block|,
name|NULL
block|}
block|,
comment|/* Ux */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Xc */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Xo */
block|{
name|termp_fo_pre
block|,
name|termp_fo_post
block|}
block|,
comment|/* Fo */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Fc */
block|{
name|termp_quote_pre
block|,
name|termp_quote_post
block|}
block|,
comment|/* Oo */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Oc */
block|{
name|termp_bk_pre
block|,
name|termp_bk_post
block|}
block|,
comment|/* Bk */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ek */
block|{
name|termp_bt_pre
block|,
name|NULL
block|}
block|,
comment|/* Bt */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Hf */
block|{
name|termp_under_pre
block|,
name|NULL
block|}
block|,
comment|/* Fr */
block|{
name|termp_ud_pre
block|,
name|NULL
block|}
block|,
comment|/* Ud */
block|{
name|NULL
block|,
name|termp_lb_post
block|}
block|,
comment|/* Lb */
block|{
name|termp_sp_pre
block|,
name|NULL
block|}
block|,
comment|/* Lp */
block|{
name|termp_lk_pre
block|,
name|NULL
block|}
block|,
comment|/* Lk */
block|{
name|termp_under_pre
block|,
name|NULL
block|}
block|,
comment|/* Mt */
block|{
name|termp_quote_pre
block|,
name|termp_quote_post
block|}
block|,
comment|/* Brq */
block|{
name|termp_quote_pre
block|,
name|termp_quote_post
block|}
block|,
comment|/* Bro */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Brc */
block|{
name|NULL
block|,
name|termp____post
block|}
block|,
comment|/* %C */
block|{
name|termp_skip_pre
block|,
name|NULL
block|}
block|,
comment|/* Es */
block|{
name|termp_quote_pre
block|,
name|termp_quote_post
block|}
block|,
comment|/* En */
block|{
name|termp_xx_pre
block|,
name|NULL
block|}
block|,
comment|/* Dx */
block|{
name|NULL
block|,
name|termp____post
block|}
block|,
comment|/* %Q */
block|{
name|termp_sp_pre
block|,
name|NULL
block|}
block|,
comment|/* br */
block|{
name|termp_sp_pre
block|,
name|NULL
block|}
block|,
comment|/* sp */
block|{
name|NULL
block|,
name|termp____post
block|}
block|,
comment|/* %U */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ta */
block|{
name|termp_ll_pre
block|,
name|NULL
block|}
block|,
comment|/* ll */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|terminal_mdoc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|struct
name|mdoc
modifier|*
name|mdoc
parameter_list|)
block|{
specifier|const
name|struct
name|mdoc_meta
modifier|*
name|meta
decl_stmt|;
name|struct
name|mdoc_node
modifier|*
name|n
decl_stmt|;
name|struct
name|termp
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|termp
operator|*
operator|)
name|arg
expr_stmt|;
name|p
operator|->
name|overstep
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|rmargin
operator|=
name|p
operator|->
name|maxrmargin
operator|=
name|p
operator|->
name|defrmargin
expr_stmt|;
name|p
operator|->
name|tabwidth
operator|=
name|term_len
argument_list|(
name|p
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|n
operator|=
name|mdoc_node
argument_list|(
name|mdoc
argument_list|)
operator|->
name|child
expr_stmt|;
name|meta
operator|=
name|mdoc_meta
argument_list|(
name|mdoc
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|synopsisonly
condition|)
block|{
while|while
condition|(
name|n
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|tok
operator|==
name|MDOC_Sh
operator|&&
name|n
operator|->
name|sec
operator|==
name|SEC_SYNOPSIS
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|child
operator|->
name|next
operator|->
name|child
operator|!=
name|NULL
condition|)
name|print_mdoc_nodelist
argument_list|(
name|p
argument_list|,
name|NULL
argument_list|,
name|meta
argument_list|,
name|n
operator|->
name|child
operator|->
name|next
operator|->
name|child
argument_list|)
expr_stmt|;
name|term_newln
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
name|n
operator|=
name|n
operator|->
name|next
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|p
operator|->
name|defindent
operator|==
literal|0
condition|)
name|p
operator|->
name|defindent
operator|=
literal|5
expr_stmt|;
name|term_begin
argument_list|(
name|p
argument_list|,
name|print_mdoc_head
argument_list|,
name|print_mdoc_foot
argument_list|,
name|meta
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|tok
operator|!=
name|MDOC_Sh
condition|)
name|term_vspace
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|print_mdoc_nodelist
argument_list|(
name|p
argument_list|,
name|NULL
argument_list|,
name|meta
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
name|term_end
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_mdoc_nodelist
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|print_mdoc_node
argument_list|(
name|p
argument_list|,
name|pair
argument_list|,
name|meta
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|next
condition|)
name|print_mdoc_nodelist
argument_list|(
name|p
argument_list|,
name|pair
argument_list|,
name|meta
argument_list|,
name|n
operator|->
name|next
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_mdoc_node
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|int
name|chld
decl_stmt|;
name|struct
name|termpair
name|npair
decl_stmt|;
name|size_t
name|offset
decl_stmt|,
name|rmargin
decl_stmt|;
name|chld
operator|=
literal|1
expr_stmt|;
name|offset
operator|=
name|p
operator|->
name|offset
expr_stmt|;
name|rmargin
operator|=
name|p
operator|->
name|rmargin
expr_stmt|;
name|n
operator|->
name|prev_font
operator|=
name|term_fontq
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|npair
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|termpair
argument_list|)
argument_list|)
expr_stmt|;
name|npair
operator|.
name|ppair
operator|=
name|pair
expr_stmt|;
comment|/* 	 * Keeps only work until the end of a line.  If a keep was 	 * invoked in a prior line, revert it to PREKEEP. 	 */
if|if
condition|(
name|TERMP_KEEP
operator|&
name|p
operator|->
name|flags
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|prev
condition|?
operator|(
name|n
operator|->
name|prev
operator|->
name|lastline
operator|!=
name|n
operator|->
name|line
operator|)
else|:
operator|(
name|n
operator|->
name|parent
operator|&&
name|n
operator|->
name|parent
operator|->
name|line
operator|!=
name|n
operator|->
name|line
operator|)
condition|)
block|{
name|p
operator|->
name|flags
operator|&=
operator|~
name|TERMP_KEEP
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_PREKEEP
expr_stmt|;
block|}
block|}
comment|/* 	 * After the keep flags have been set up, we may now 	 * produce output.  Note that some pre-handlers do so. 	 */
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
case|case
name|MDOC_TEXT
case|:
if|if
condition|(
literal|' '
operator|==
operator|*
name|n
operator|->
name|string
operator|&&
name|MDOC_LINE
operator|&
name|n
operator|->
name|flags
condition|)
name|term_newln
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|MDOC_DELIMC
operator|&
name|n
operator|->
name|flags
condition|)
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
name|n
operator|->
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|MDOC_DELIMO
operator|&
name|n
operator|->
name|flags
condition|)
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
break|break;
case|case
name|MDOC_EQN
case|:
if|if
condition|(
operator|!
operator|(
name|n
operator|->
name|flags
operator|&
name|MDOC_LINE
operator|)
condition|)
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_eqn
argument_list|(
name|p
argument_list|,
name|n
operator|->
name|eqn
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|next
operator|!=
name|NULL
operator|&&
operator|!
operator|(
name|n
operator|->
name|next
operator|->
name|flags
operator|&
name|MDOC_LINE
operator|)
condition|)
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
break|break;
case|case
name|MDOC_TBL
case|:
name|term_tbl
argument_list|(
name|p
argument_list|,
name|n
operator|->
name|span
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|termacts
index|[
name|n
operator|->
name|tok
index|]
operator|.
name|pre
operator|&&
operator|(
name|n
operator|->
name|end
operator|==
name|ENDBODY_NOT
operator|||
name|n
operator|->
name|nchild
operator|)
condition|)
name|chld
operator|=
operator|(
operator|*
name|termacts
index|[
name|n
operator|->
name|tok
index|]
operator|.
name|pre
operator|)
operator|(
name|p
operator|,
operator|&
name|npair
operator|,
name|meta
operator|,
name|n
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|chld
operator|&&
name|n
operator|->
name|child
condition|)
name|print_mdoc_nodelist
argument_list|(
name|p
argument_list|,
operator|&
name|npair
argument_list|,
name|meta
argument_list|,
name|n
operator|->
name|child
argument_list|)
expr_stmt|;
name|term_fontpopq
argument_list|(
name|p
argument_list|,
operator|(
name|ENDBODY_NOT
operator|==
name|n
operator|->
name|end
condition|?
name|n
else|:
name|n
operator|->
name|pending
operator|)
operator|->
name|prev_font
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
case|case
name|MDOC_TEXT
case|:
break|break;
case|case
name|MDOC_TBL
case|:
break|break;
case|case
name|MDOC_EQN
case|:
break|break;
default|default:
if|if
condition|(
operator|!
name|termacts
index|[
name|n
operator|->
name|tok
index|]
operator|.
name|post
operator|||
name|MDOC_ENDED
operator|&
name|n
operator|->
name|flags
condition|)
break|break;
call|(
name|void
call|)
argument_list|(
operator|*
name|termacts
index|[
name|n
operator|->
name|tok
index|]
operator|.
name|post
argument_list|)
argument_list|(
name|p
argument_list|,
operator|&
name|npair
argument_list|,
name|meta
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* 		 * Explicit end tokens not only call the post 		 * handler, but also tell the respective block 		 * that it must not call the post handler again. 		 */
if|if
condition|(
name|ENDBODY_NOT
operator|!=
name|n
operator|->
name|end
condition|)
name|n
operator|->
name|pending
operator|->
name|flags
operator||=
name|MDOC_ENDED
expr_stmt|;
comment|/* 		 * End of line terminating an implicit block 		 * while an explicit block is still open. 		 * Continue the explicit block without spacing. 		 */
if|if
condition|(
name|ENDBODY_NOSPACE
operator|==
name|n
operator|->
name|end
condition|)
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|MDOC_EOS
operator|&
name|n
operator|->
name|flags
condition|)
name|p
operator|->
name|flags
operator||=
name|TERMP_SENTENCE
expr_stmt|;
if|if
condition|(
name|MDOC_ll
operator|!=
name|n
operator|->
name|tok
condition|)
block|{
name|p
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|p
operator|->
name|rmargin
operator|=
name|rmargin
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_mdoc_foot
parameter_list|(
name|struct
name|termp
modifier|*
name|p
parameter_list|,
specifier|const
name|void
modifier|*
name|arg
parameter_list|)
block|{
specifier|const
name|struct
name|mdoc_meta
modifier|*
name|meta
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
name|meta
operator|=
operator|(
specifier|const
expr|struct
name|mdoc_meta
operator|*
operator|)
name|arg
expr_stmt|;
name|term_fontrepl
argument_list|(
name|p
argument_list|,
name|TERMFONT_NONE
argument_list|)
expr_stmt|;
comment|/* 	 * Output the footer in new-groff style, that is, three columns 	 * with the middle being the manual date and flanking columns 	 * being the operating system: 	 * 	 * SYSTEM                  DATE                    SYSTEM 	 */
name|term_vspace
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|sz
operator|=
name|term_strlen
argument_list|(
name|p
argument_list|,
name|meta
operator|->
name|date
argument_list|)
expr_stmt|;
name|p
operator|->
name|rmargin
operator|=
name|p
operator|->
name|maxrmargin
operator|>
name|sz
condition|?
operator|(
name|p
operator|->
name|maxrmargin
operator|+
name|term_len
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
operator|-
name|sz
operator|)
operator|/
literal|2
else|:
literal|0
expr_stmt|;
name|p
operator|->
name|trailspace
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
operator||
name|TERMP_NOBREAK
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
name|meta
operator|->
name|os
argument_list|)
expr_stmt|;
name|term_flushln
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|offset
operator|=
name|p
operator|->
name|rmargin
expr_stmt|;
name|sz
operator|=
name|term_strlen
argument_list|(
name|p
argument_list|,
name|meta
operator|->
name|os
argument_list|)
expr_stmt|;
name|p
operator|->
name|rmargin
operator|=
name|p
operator|->
name|maxrmargin
operator|>
name|sz
condition|?
name|p
operator|->
name|maxrmargin
operator|-
name|sz
else|:
literal|0
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
name|meta
operator|->
name|date
argument_list|)
expr_stmt|;
name|term_flushln
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|offset
operator|=
name|p
operator|->
name|rmargin
expr_stmt|;
name|p
operator|->
name|rmargin
operator|=
name|p
operator|->
name|maxrmargin
expr_stmt|;
name|p
operator|->
name|trailspace
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|flags
operator|&=
operator|~
name|TERMP_NOBREAK
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
name|meta
operator|->
name|os
argument_list|)
expr_stmt|;
name|term_flushln
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|rmargin
operator|=
name|p
operator|->
name|maxrmargin
expr_stmt|;
name|p
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_mdoc_head
parameter_list|(
name|struct
name|termp
modifier|*
name|p
parameter_list|,
specifier|const
name|void
modifier|*
name|arg
parameter_list|)
block|{
specifier|const
name|struct
name|mdoc_meta
modifier|*
name|meta
decl_stmt|;
name|char
modifier|*
name|volume
decl_stmt|,
modifier|*
name|title
decl_stmt|;
name|size_t
name|vollen
decl_stmt|,
name|titlen
decl_stmt|;
name|meta
operator|=
operator|(
specifier|const
expr|struct
name|mdoc_meta
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* 	 * The header is strange.  It has three components, which are 	 * really two with the first duplicated.  It goes like this: 	 * 	 * IDENTIFIER              TITLE                   IDENTIFIER 	 * 	 * The IDENTIFIER is NAME(SECTION), which is the command-name 	 * (if given, or "unknown" if not) followed by the manual page 	 * section.  These are given in `Dt'.  The TITLE is a free-form 	 * string depending on the manual volume.  If not specified, it 	 * switches on the manual section. 	 */
name|assert
argument_list|(
name|meta
operator|->
name|vol
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|meta
operator|->
name|arch
condition|)
name|volume
operator|=
name|mandoc_strdup
argument_list|(
name|meta
operator|->
name|vol
argument_list|)
expr_stmt|;
else|else
name|mandoc_asprintf
argument_list|(
operator|&
name|volume
argument_list|,
literal|"%s (%s)"
argument_list|,
name|meta
operator|->
name|vol
argument_list|,
name|meta
operator|->
name|arch
argument_list|)
expr_stmt|;
name|vollen
operator|=
name|term_strlen
argument_list|(
name|p
argument_list|,
name|volume
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|meta
operator|->
name|msec
condition|)
name|title
operator|=
name|mandoc_strdup
argument_list|(
name|meta
operator|->
name|title
argument_list|)
expr_stmt|;
else|else
name|mandoc_asprintf
argument_list|(
operator|&
name|title
argument_list|,
literal|"%s(%s)"
argument_list|,
name|meta
operator|->
name|title
argument_list|,
name|meta
operator|->
name|msec
argument_list|)
expr_stmt|;
name|titlen
operator|=
name|term_strlen
argument_list|(
name|p
argument_list|,
name|title
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOBREAK
operator||
name|TERMP_NOSPACE
expr_stmt|;
name|p
operator|->
name|trailspace
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|rmargin
operator|=
literal|2
operator|*
operator|(
name|titlen
operator|+
literal|1
operator|)
operator|+
name|vollen
operator|<
name|p
operator|->
name|maxrmargin
condition|?
operator|(
name|p
operator|->
name|maxrmargin
operator|-
name|vollen
operator|+
name|term_len
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
operator|)
operator|/
literal|2
else|:
name|vollen
operator|<
name|p
operator|->
name|maxrmargin
condition|?
name|p
operator|->
name|maxrmargin
operator|-
name|vollen
else|:
literal|0
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
name|title
argument_list|)
expr_stmt|;
name|term_flushln
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|p
operator|->
name|offset
operator|=
name|p
operator|->
name|rmargin
expr_stmt|;
name|p
operator|->
name|rmargin
operator|=
name|p
operator|->
name|offset
operator|+
name|vollen
operator|+
name|titlen
operator|<
name|p
operator|->
name|maxrmargin
condition|?
name|p
operator|->
name|maxrmargin
operator|-
name|titlen
else|:
name|p
operator|->
name|maxrmargin
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
name|volume
argument_list|)
expr_stmt|;
name|term_flushln
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator|&=
operator|~
name|TERMP_NOBREAK
expr_stmt|;
name|p
operator|->
name|trailspace
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|rmargin
operator|+
name|titlen
operator|<=
name|p
operator|->
name|maxrmargin
condition|)
block|{
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|p
operator|->
name|offset
operator|=
name|p
operator|->
name|rmargin
expr_stmt|;
name|p
operator|->
name|rmargin
operator|=
name|p
operator|->
name|maxrmargin
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
name|title
argument_list|)
expr_stmt|;
name|term_flushln
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|flags
operator|&=
operator|~
name|TERMP_NOSPACE
expr_stmt|;
name|p
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|rmargin
operator|=
name|p
operator|->
name|maxrmargin
expr_stmt|;
name|free
argument_list|(
name|title
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|volume
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|a2height
parameter_list|(
specifier|const
name|struct
name|termp
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|v
parameter_list|)
block|{
name|struct
name|roffsu
name|su
decl_stmt|;
name|assert
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|a2roffsu
argument_list|(
name|v
argument_list|,
operator|&
name|su
argument_list|,
name|SCALE_VS
argument_list|)
condition|)
name|SCALE_VS_INIT
argument_list|(
operator|&
name|su
argument_list|,
name|atoi
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|term_vspan
argument_list|(
name|p
argument_list|,
operator|&
name|su
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|a2width
parameter_list|(
specifier|const
name|struct
name|termp
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|v
parameter_list|)
block|{
name|struct
name|roffsu
name|su
decl_stmt|;
name|assert
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|a2roffsu
argument_list|(
name|v
argument_list|,
operator|&
name|su
argument_list|,
name|SCALE_MAX
argument_list|)
condition|)
block|{
name|SCALE_HS_INIT
argument_list|(
operator|&
name|su
argument_list|,
name|term_strlen
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|su
operator|.
name|scale
operator|/=
name|term_strlen
argument_list|(
name|p
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|term_hspan
argument_list|(
name|p
argument_list|,
operator|&
name|su
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine how much space to print out before block elements of `It'  * (and thus `Bl') and `Bd'.  And then go ahead and print that space,  * too.  */
end_comment

begin_function
specifier|static
name|void
name|print_bvspace
parameter_list|(
name|struct
name|termp
modifier|*
name|p
parameter_list|,
specifier|const
name|struct
name|mdoc_node
modifier|*
name|bl
parameter_list|,
specifier|const
name|struct
name|mdoc_node
modifier|*
name|n
parameter_list|)
block|{
specifier|const
name|struct
name|mdoc_node
modifier|*
name|nn
decl_stmt|;
name|assert
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|term_newln
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|MDOC_Bd
operator|==
name|bl
operator|->
name|tok
operator|&&
name|bl
operator|->
name|norm
operator|->
name|Bd
operator|.
name|comp
condition|)
return|return;
if|if
condition|(
name|MDOC_Bl
operator|==
name|bl
operator|->
name|tok
operator|&&
name|bl
operator|->
name|norm
operator|->
name|Bl
operator|.
name|comp
condition|)
return|return;
comment|/* Do not vspace directly after Ss/Sh. */
name|nn
operator|=
name|n
expr_stmt|;
while|while
condition|(
name|nn
operator|->
name|prev
operator|==
name|NULL
condition|)
block|{
do|do
block|{
name|nn
operator|=
name|nn
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|nn
operator|->
name|type
operator|==
name|MDOC_ROOT
condition|)
return|return;
block|}
do|while
condition|(
name|nn
operator|->
name|type
operator|!=
name|MDOC_BLOCK
condition|)
do|;
if|if
condition|(
name|nn
operator|->
name|tok
operator|==
name|MDOC_Sh
operator|||
name|nn
operator|->
name|tok
operator|==
name|MDOC_Ss
condition|)
return|return;
if|if
condition|(
name|nn
operator|->
name|tok
operator|==
name|MDOC_It
operator|&&
name|nn
operator|->
name|parent
operator|->
name|parent
operator|->
name|norm
operator|->
name|Bl
operator|.
name|type
operator|!=
name|LIST_item
condition|)
break|break;
block|}
comment|/* A `-column' does not assert vspace within the list. */
if|if
condition|(
name|MDOC_Bl
operator|==
name|bl
operator|->
name|tok
operator|&&
name|LIST_column
operator|==
name|bl
operator|->
name|norm
operator|->
name|Bl
operator|.
name|type
condition|)
if|if
condition|(
name|n
operator|->
name|prev
operator|&&
name|MDOC_It
operator|==
name|n
operator|->
name|prev
operator|->
name|tok
condition|)
return|return;
comment|/* A `-diag' without body does not vspace. */
if|if
condition|(
name|MDOC_Bl
operator|==
name|bl
operator|->
name|tok
operator|&&
name|LIST_diag
operator|==
name|bl
operator|->
name|norm
operator|->
name|Bl
operator|.
name|type
condition|)
if|if
condition|(
name|n
operator|->
name|prev
operator|&&
name|MDOC_It
operator|==
name|n
operator|->
name|prev
operator|->
name|tok
condition|)
block|{
name|assert
argument_list|(
name|n
operator|->
name|prev
operator|->
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|prev
operator|->
name|body
operator|->
name|child
condition|)
return|return;
block|}
name|term_vspace
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_ll_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|term_setwidth
argument_list|(
name|p
argument_list|,
name|n
operator|->
name|nchild
condition|?
name|n
operator|->
name|child
operator|->
name|string
else|:
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_it_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
specifier|const
name|struct
name|mdoc_node
modifier|*
name|bl
decl_stmt|,
modifier|*
name|nn
decl_stmt|;
name|char
name|buf
index|[
literal|24
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|size_t
name|width
decl_stmt|,
name|offset
decl_stmt|,
name|ncols
decl_stmt|,
name|dcol
decl_stmt|;
name|enum
name|mdoc_list
name|type
decl_stmt|;
if|if
condition|(
name|MDOC_BLOCK
operator|==
name|n
operator|->
name|type
condition|)
block|{
name|print_bvspace
argument_list|(
name|p
argument_list|,
name|n
operator|->
name|parent
operator|->
name|parent
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|bl
operator|=
name|n
operator|->
name|parent
operator|->
name|parent
operator|->
name|parent
expr_stmt|;
name|type
operator|=
name|bl
operator|->
name|norm
operator|->
name|Bl
operator|.
name|type
expr_stmt|;
comment|/* 	 * First calculate width and offset.  This is pretty easy unless 	 * we're a -column list, in which case all prior columns must 	 * be accounted for. 	 */
name|width
operator|=
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bl
operator|->
name|norm
operator|->
name|Bl
operator|.
name|offs
condition|)
name|offset
operator|=
name|a2width
argument_list|(
name|p
argument_list|,
name|bl
operator|->
name|norm
operator|->
name|Bl
operator|.
name|offs
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|LIST_column
case|:
if|if
condition|(
name|MDOC_HEAD
operator|==
name|n
operator|->
name|type
condition|)
break|break;
comment|/* 		 * Imitate groff's column handling: 		 * - For each earlier column, add its width. 		 * - For less than 5 columns, add four more blanks per 		 *   column. 		 * - For exactly 5 columns, add three more blank per 		 *   column. 		 * - For more than 5 columns, add only one column. 		 */
name|ncols
operator|=
name|bl
operator|->
name|norm
operator|->
name|Bl
operator|.
name|ncols
expr_stmt|;
name|dcol
operator|=
name|ncols
operator|<
literal|5
condition|?
name|term_len
argument_list|(
name|p
argument_list|,
literal|4
argument_list|)
else|:
name|ncols
operator|==
literal|5
condition|?
name|term_len
argument_list|(
name|p
argument_list|,
literal|3
argument_list|)
else|:
name|term_len
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * Calculate the offset by applying all prior MDOC_BODY, 		 * so we stop at the MDOC_HEAD (NULL == nn->prev). 		 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|nn
operator|=
name|n
operator|->
name|prev
init|;
name|nn
operator|->
name|prev
operator|&&
name|i
operator|<
operator|(
name|int
operator|)
name|ncols
condition|;
name|nn
operator|=
name|nn
operator|->
name|prev
operator|,
name|i
operator|++
control|)
name|offset
operator|+=
name|dcol
operator|+
name|a2width
argument_list|(
name|p
argument_list|,
name|bl
operator|->
name|norm
operator|->
name|Bl
operator|.
name|cols
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* 		 * When exceeding the declared number of columns, leave 		 * the remaining widths at 0.  This will later be 		 * adjusted to the default width of 10, or, for the last 		 * column, stretched to the right margin. 		 */
if|if
condition|(
name|i
operator|>=
operator|(
name|int
operator|)
name|ncols
condition|)
break|break;
comment|/* 		 * Use the declared column widths, extended as explained 		 * in the preceding paragraph. 		 */
name|width
operator|=
name|a2width
argument_list|(
name|p
argument_list|,
name|bl
operator|->
name|norm
operator|->
name|Bl
operator|.
name|cols
index|[
name|i
index|]
argument_list|)
operator|+
name|dcol
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|NULL
operator|==
name|bl
operator|->
name|norm
operator|->
name|Bl
operator|.
name|width
condition|)
break|break;
comment|/* 		 * Note: buffer the width by 2, which is groff's magic 		 * number for buffering single arguments.  See the above 		 * handling for column for how this changes. 		 */
name|assert
argument_list|(
name|bl
operator|->
name|norm
operator|->
name|Bl
operator|.
name|width
argument_list|)
expr_stmt|;
name|width
operator|=
name|a2width
argument_list|(
name|p
argument_list|,
name|bl
operator|->
name|norm
operator|->
name|Bl
operator|.
name|width
argument_list|)
operator|+
name|term_len
argument_list|(
name|p
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * List-type can override the width in the case of fixed-head 	 * values (bullet, dash/hyphen, enum).  Tags need a non-zero 	 * offset. 	 */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|LIST_bullet
case|:
comment|/* FALLTHROUGH */
case|case
name|LIST_dash
case|:
comment|/* FALLTHROUGH */
case|case
name|LIST_hyphen
case|:
comment|/* FALLTHROUGH */
case|case
name|LIST_enum
case|:
if|if
condition|(
name|width
operator|<
name|term_len
argument_list|(
name|p
argument_list|,
literal|2
argument_list|)
condition|)
name|width
operator|=
name|term_len
argument_list|(
name|p
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIST_hang
case|:
if|if
condition|(
literal|0
operator|==
name|width
condition|)
name|width
operator|=
name|term_len
argument_list|(
name|p
argument_list|,
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIST_column
case|:
comment|/* FALLTHROUGH */
case|case
name|LIST_tag
case|:
if|if
condition|(
literal|0
operator|==
name|width
condition|)
name|width
operator|=
name|term_len
argument_list|(
name|p
argument_list|,
literal|10
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* 	 * Whitespace control.  Inset bodies need an initial space, 	 * while diagonal bodies need two. 	 */
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|LIST_diag
case|:
if|if
condition|(
name|MDOC_BODY
operator|==
name|n
operator|->
name|type
condition|)
name|term_word
argument_list|(
name|p
argument_list|,
literal|"\\ \\ "
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIST_inset
case|:
if|if
condition|(
name|MDOC_BODY
operator|==
name|n
operator|->
name|type
operator|&&
name|n
operator|->
name|parent
operator|->
name|head
operator|->
name|nchild
condition|)
name|term_word
argument_list|(
name|p
argument_list|,
literal|"\\ "
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|LIST_diag
case|:
if|if
condition|(
name|MDOC_HEAD
operator|==
name|n
operator|->
name|type
condition|)
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_BOLD
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* 	 * Pad and break control.  This is the tricky part.  These flags 	 * are documented in term_flushln() in term.c.  Note that we're 	 * going to unset all of these flags in termp_it_post() when we 	 * exit. 	 */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|LIST_enum
case|:
comment|/* 		 * Weird special case. 		 * Very narrow enum lists actually hang. 		 */
if|if
condition|(
name|width
operator|==
name|term_len
argument_list|(
name|p
argument_list|,
literal|2
argument_list|)
condition|)
name|p
operator|->
name|flags
operator||=
name|TERMP_HANG
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|LIST_bullet
case|:
comment|/* FALLTHROUGH */
case|case
name|LIST_dash
case|:
comment|/* FALLTHROUGH */
case|case
name|LIST_hyphen
case|:
if|if
condition|(
name|MDOC_HEAD
operator|!=
name|n
operator|->
name|type
condition|)
break|break;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOBREAK
expr_stmt|;
name|p
operator|->
name|trailspace
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|LIST_hang
case|:
if|if
condition|(
name|MDOC_HEAD
operator|!=
name|n
operator|->
name|type
condition|)
break|break;
comment|/* 		 * This is ugly.  If `-hang' is specified and the body 		 * is a `Bl' or `Bd', then we want basically to nullify 		 * the "overstep" effect in term_flushln() and treat 		 * this as a `-ohang' list instead. 		 */
if|if
condition|(
name|NULL
operator|!=
name|n
operator|->
name|next
operator|&&
name|NULL
operator|!=
name|n
operator|->
name|next
operator|->
name|child
operator|&&
operator|(
name|MDOC_Bl
operator|==
name|n
operator|->
name|next
operator|->
name|child
operator|->
name|tok
operator|||
name|MDOC_Bd
operator|==
name|n
operator|->
name|next
operator|->
name|child
operator|->
name|tok
operator|)
condition|)
break|break;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOBREAK
operator||
name|TERMP_BRIND
operator||
name|TERMP_HANG
expr_stmt|;
name|p
operator|->
name|trailspace
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|LIST_tag
case|:
if|if
condition|(
name|MDOC_HEAD
operator|!=
name|n
operator|->
name|type
condition|)
break|break;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOBREAK
operator||
name|TERMP_BRIND
expr_stmt|;
name|p
operator|->
name|trailspace
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|next
operator|||
name|NULL
operator|==
name|n
operator|->
name|next
operator|->
name|child
condition|)
name|p
operator|->
name|flags
operator||=
name|TERMP_DANGLE
expr_stmt|;
break|break;
case|case
name|LIST_column
case|:
if|if
condition|(
name|MDOC_HEAD
operator|==
name|n
operator|->
name|type
condition|)
break|break;
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|next
condition|)
block|{
name|p
operator|->
name|flags
operator|&=
operator|~
name|TERMP_NOBREAK
expr_stmt|;
name|p
operator|->
name|trailspace
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|flags
operator||=
name|TERMP_NOBREAK
expr_stmt|;
name|p
operator|->
name|trailspace
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|LIST_diag
case|:
if|if
condition|(
name|MDOC_HEAD
operator|!=
name|n
operator|->
name|type
condition|)
break|break;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOBREAK
operator||
name|TERMP_BRIND
expr_stmt|;
name|p
operator|->
name|trailspace
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* 	 * Margin control.  Set-head-width lists have their right 	 * margins shortened.  The body for these lists has the offset 	 * necessarily lengthened.  Everybody gets the offset. 	 */
name|p
operator|->
name|offset
operator|+=
name|offset
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|LIST_hang
case|:
comment|/* 		 * Same stipulation as above, regarding `-hang'.  We 		 * don't want to recalculate rmargin and offsets when 		 * using `Bd' or `Bl' within `-hang' overstep lists. 		 */
if|if
condition|(
name|MDOC_HEAD
operator|==
name|n
operator|->
name|type
operator|&&
name|NULL
operator|!=
name|n
operator|->
name|next
operator|&&
name|NULL
operator|!=
name|n
operator|->
name|next
operator|->
name|child
operator|&&
operator|(
name|MDOC_Bl
operator|==
name|n
operator|->
name|next
operator|->
name|child
operator|->
name|tok
operator|||
name|MDOC_Bd
operator|==
name|n
operator|->
name|next
operator|->
name|child
operator|->
name|tok
operator|)
condition|)
break|break;
comment|/* FALLTHROUGH */
case|case
name|LIST_bullet
case|:
comment|/* FALLTHROUGH */
case|case
name|LIST_dash
case|:
comment|/* FALLTHROUGH */
case|case
name|LIST_enum
case|:
comment|/* FALLTHROUGH */
case|case
name|LIST_hyphen
case|:
comment|/* FALLTHROUGH */
case|case
name|LIST_tag
case|:
name|assert
argument_list|(
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
name|MDOC_HEAD
operator|==
name|n
operator|->
name|type
condition|)
name|p
operator|->
name|rmargin
operator|=
name|p
operator|->
name|offset
operator|+
name|width
expr_stmt|;
else|else
name|p
operator|->
name|offset
operator|+=
name|width
expr_stmt|;
break|break;
case|case
name|LIST_column
case|:
name|assert
argument_list|(
name|width
argument_list|)
expr_stmt|;
name|p
operator|->
name|rmargin
operator|=
name|p
operator|->
name|offset
operator|+
name|width
expr_stmt|;
comment|/* 		 * XXX - this behaviour is not documented: the 		 * right-most column is filled to the right margin. 		 */
if|if
condition|(
name|MDOC_HEAD
operator|==
name|n
operator|->
name|type
condition|)
break|break;
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|next
operator|&&
name|p
operator|->
name|rmargin
operator|<
name|p
operator|->
name|maxrmargin
condition|)
name|p
operator|->
name|rmargin
operator|=
name|p
operator|->
name|maxrmargin
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* 	 * The dash, hyphen, bullet and enum lists all have a special 	 * HEAD character (temporarily bold, in some cases). 	 */
if|if
condition|(
name|MDOC_HEAD
operator|==
name|n
operator|->
name|type
condition|)
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|LIST_bullet
case|:
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_BOLD
argument_list|)
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|"\\[bu]"
argument_list|)
expr_stmt|;
name|term_fontpop
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIST_dash
case|:
comment|/* FALLTHROUGH */
case|case
name|LIST_hyphen
case|:
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_BOLD
argument_list|)
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|"\\(hy"
argument_list|)
expr_stmt|;
name|term_fontpop
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIST_enum
case|:
operator|(
name|pair
operator|->
name|ppair
operator|->
name|ppair
operator|->
name|count
operator|)
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%d."
argument_list|,
name|pair
operator|->
name|ppair
operator|->
name|ppair
operator|->
name|count
argument_list|)
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* 	 * If we're not going to process our children, indicate so here. 	 */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|LIST_bullet
case|:
comment|/* FALLTHROUGH */
case|case
name|LIST_item
case|:
comment|/* FALLTHROUGH */
case|case
name|LIST_dash
case|:
comment|/* FALLTHROUGH */
case|case
name|LIST_hyphen
case|:
comment|/* FALLTHROUGH */
case|case
name|LIST_enum
case|:
if|if
condition|(
name|MDOC_HEAD
operator|==
name|n
operator|->
name|type
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|LIST_column
case|:
if|if
condition|(
name|MDOC_HEAD
operator|==
name|n
operator|->
name|type
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|termp_it_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|enum
name|mdoc_list
name|type
decl_stmt|;
if|if
condition|(
name|MDOC_BLOCK
operator|==
name|n
operator|->
name|type
condition|)
return|return;
name|type
operator|=
name|n
operator|->
name|parent
operator|->
name|parent
operator|->
name|parent
operator|->
name|norm
operator|->
name|Bl
operator|.
name|type
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|LIST_item
case|:
comment|/* FALLTHROUGH */
case|case
name|LIST_diag
case|:
comment|/* FALLTHROUGH */
case|case
name|LIST_inset
case|:
if|if
condition|(
name|MDOC_BODY
operator|==
name|n
operator|->
name|type
condition|)
name|term_newln
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIST_column
case|:
if|if
condition|(
name|MDOC_BODY
operator|==
name|n
operator|->
name|type
condition|)
name|term_flushln
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
default|default:
name|term_newln
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * Now that our output is flushed, we can reset our tags.  Since 	 * only `It' sets these flags, we're free to assume that nobody 	 * has munged them in the meanwhile. 	 */
name|p
operator|->
name|flags
operator|&=
operator|~
operator|(
name|TERMP_NOBREAK
operator||
name|TERMP_BRIND
operator||
name|TERMP_DANGLE
operator||
name|TERMP_HANG
operator|)
expr_stmt|;
name|p
operator|->
name|trailspace
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_nm_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|MDOC_BLOCK
operator|==
name|n
operator|->
name|type
condition|)
block|{
name|p
operator|->
name|flags
operator||=
name|TERMP_PREKEEP
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|MDOC_BODY
operator|==
name|n
operator|->
name|type
condition|)
block|{
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|child
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|cp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|prev
operator|->
name|child
operator|!=
name|NULL
condition|)
name|cp
operator|=
name|n
operator|->
name|prev
operator|->
name|child
operator|->
name|string
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|cp
operator|=
name|meta
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|p
operator|->
name|offset
operator|+=
name|term_len
argument_list|(
name|p
argument_list|,
literal|6
argument_list|)
expr_stmt|;
else|else
name|p
operator|->
name|offset
operator|+=
name|term_len
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
operator|+
name|term_strlen
argument_list|(
name|p
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|child
operator|&&
name|NULL
operator|==
name|meta
operator|->
name|name
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|MDOC_HEAD
operator|==
name|n
operator|->
name|type
condition|)
name|synopsis_pre
argument_list|(
name|p
argument_list|,
name|n
operator|->
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|MDOC_HEAD
operator|==
name|n
operator|->
name|type
operator|&&
name|NULL
operator|!=
name|n
operator|->
name|next
operator|&&
name|NULL
operator|!=
name|n
operator|->
name|next
operator|->
name|child
condition|)
block|{
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
operator||
name|TERMP_NOBREAK
operator||
name|TERMP_BRIND
expr_stmt|;
name|p
operator|->
name|trailspace
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|rmargin
operator|=
name|p
operator|->
name|offset
operator|+
name|term_len
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|child
condition|)
block|{
name|p
operator|->
name|rmargin
operator|+=
name|term_strlen
argument_list|(
name|p
argument_list|,
name|meta
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MDOC_TEXT
operator|==
name|n
operator|->
name|child
operator|->
name|type
condition|)
block|{
name|p
operator|->
name|rmargin
operator|+=
name|term_strlen
argument_list|(
name|p
argument_list|,
name|n
operator|->
name|child
operator|->
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|child
operator|->
name|next
condition|)
name|p
operator|->
name|flags
operator||=
name|TERMP_HANG
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|rmargin
operator|+=
name|term_len
argument_list|(
name|p
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_HANG
expr_stmt|;
block|}
block|}
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_BOLD
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|child
condition|)
name|term_word
argument_list|(
name|p
argument_list|,
name|meta
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|termp_nm_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|MDOC_BLOCK
operator|==
name|n
operator|->
name|type
condition|)
block|{
name|p
operator|->
name|flags
operator|&=
operator|~
operator|(
name|TERMP_KEEP
operator||
name|TERMP_PREKEEP
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MDOC_HEAD
operator|==
name|n
operator|->
name|type
operator|&&
name|NULL
operator|!=
name|n
operator|->
name|next
operator|&&
name|NULL
operator|!=
name|n
operator|->
name|next
operator|->
name|child
condition|)
block|{
name|term_flushln
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator|&=
operator|~
operator|(
name|TERMP_NOBREAK
operator||
name|TERMP_BRIND
operator||
name|TERMP_HANG
operator|)
expr_stmt|;
name|p
operator|->
name|trailspace
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MDOC_BODY
operator|==
name|n
operator|->
name|type
operator|&&
name|n
operator|->
name|child
condition|)
name|term_flushln
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_fl_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_BOLD
argument_list|)
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|"\\-"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|n
operator|->
name|nchild
operator|==
literal|0
operator|&&
operator|(
name|n
operator|->
name|next
operator|==
name|NULL
operator|||
name|n
operator|->
name|next
operator|->
name|type
operator|==
name|MDOC_TEXT
operator|||
name|n
operator|->
name|next
operator|->
name|flags
operator|&
name|MDOC_LINE
operator|)
operator|)
condition|)
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp__a_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|n
operator|->
name|prev
operator|&&
name|MDOC__A
operator|==
name|n
operator|->
name|prev
operator|->
name|tok
condition|)
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|next
operator|||
name|MDOC__A
operator|!=
name|n
operator|->
name|next
operator|->
name|tok
condition|)
name|term_word
argument_list|(
name|p
argument_list|,
literal|"and"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_an_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|n
operator|->
name|norm
operator|->
name|An
operator|.
name|auth
operator|==
name|AUTH_split
condition|)
block|{
name|p
operator|->
name|flags
operator|&=
operator|~
name|TERMP_NOSPLIT
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_SPLIT
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|->
name|norm
operator|->
name|An
operator|.
name|auth
operator|==
name|AUTH_nosplit
condition|)
block|{
name|p
operator|->
name|flags
operator|&=
operator|~
name|TERMP_SPLIT
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPLIT
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|->
name|child
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|flags
operator|&
name|TERMP_SPLIT
condition|)
name|term_newln
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|sec
operator|==
name|SEC_AUTHORS
operator|&&
operator|!
operator|(
name|p
operator|->
name|flags
operator|&
name|TERMP_NOSPLIT
operator|)
condition|)
name|p
operator|->
name|flags
operator||=
name|TERMP_SPLIT
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_ns_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|MDOC_LINE
operator|&
name|n
operator|->
name|flags
operator|)
condition|)
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_rs_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|SEC_SEE_ALSO
operator|!=
name|n
operator|->
name|sec
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|MDOC_BLOCK
operator|==
name|n
operator|->
name|type
operator|&&
name|n
operator|->
name|prev
condition|)
name|term_vspace
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_rv_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|int
name|nchild
decl_stmt|;
name|term_newln
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|nchild
operator|=
name|n
operator|->
name|nchild
expr_stmt|;
if|if
condition|(
name|nchild
operator|>
literal|0
condition|)
block|{
name|term_word
argument_list|(
name|p
argument_list|,
literal|"The"
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|n
operator|->
name|child
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
block|{
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_BOLD
argument_list|)
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
name|n
operator|->
name|string
argument_list|)
expr_stmt|;
name|term_fontpop
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|"()"
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|next
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|nchild
operator|>
literal|2
condition|)
block|{
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|->
name|next
operator|->
name|next
operator|==
name|NULL
condition|)
name|term_word
argument_list|(
name|p
argument_list|,
literal|"and"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nchild
operator|>
literal|1
condition|)
name|term_word
argument_list|(
name|p
argument_list|,
literal|"functions return"
argument_list|)
expr_stmt|;
else|else
name|term_word
argument_list|(
name|p
argument_list|,
literal|"function returns"
argument_list|)
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|"the value\\~0 if successful;"
argument_list|)
expr_stmt|;
block|}
else|else
name|term_word
argument_list|(
name|p
argument_list|,
literal|"Upon successful completion,"
literal|" the value\\~0 is returned;"
argument_list|)
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|"otherwise the value\\~\\-1 is returned"
literal|" and the global variable"
argument_list|)
expr_stmt|;
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_UNDER
argument_list|)
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|"errno"
argument_list|)
expr_stmt|;
name|term_fontpop
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|"is set to indicate the error."
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_SENTENCE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_ex_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|int
name|nchild
decl_stmt|;
name|term_newln
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|"The"
argument_list|)
expr_stmt|;
name|nchild
operator|=
name|n
operator|->
name|nchild
expr_stmt|;
for|for
control|(
name|n
operator|=
name|n
operator|->
name|child
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
block|{
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_BOLD
argument_list|)
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
name|n
operator|->
name|string
argument_list|)
expr_stmt|;
name|term_fontpop
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|nchild
operator|>
literal|2
operator|&&
name|n
operator|->
name|next
condition|)
block|{
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|->
name|next
operator|&&
name|NULL
operator|==
name|n
operator|->
name|next
operator|->
name|next
condition|)
name|term_word
argument_list|(
name|p
argument_list|,
literal|"and"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nchild
operator|>
literal|1
condition|)
name|term_word
argument_list|(
name|p
argument_list|,
literal|"utilities exit\\~0"
argument_list|)
expr_stmt|;
else|else
name|term_word
argument_list|(
name|p
argument_list|,
literal|"utility exits\\~0"
argument_list|)
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|"on success, and\\~>0 if an error occurs."
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_SENTENCE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_nd_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|MDOC_BODY
condition|)
name|term_word
argument_list|(
name|p
argument_list|,
literal|"\\(en"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_bl_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
return|return
operator|(
name|MDOC_HEAD
operator|!=
name|n
operator|->
name|type
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|termp_bl_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|MDOC_BLOCK
operator|==
name|n
operator|->
name|type
condition|)
name|term_newln
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_xr_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|NULL
operator|==
operator|(
name|n
operator|=
name|n
operator|->
name|child
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|assert
argument_list|(
name|MDOC_TEXT
operator|==
name|n
operator|->
name|type
argument_list|)
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
name|n
operator|->
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|n
operator|=
name|n
operator|->
name|next
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|assert
argument_list|(
name|MDOC_TEXT
operator|==
name|n
operator|->
name|type
argument_list|)
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
name|n
operator|->
name|string
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This decides how to assert whitespace before any of the SYNOPSIS set  * of macros (which, as in the case of Ft/Fo and Ft/Fn, may contain  * macro combos).  */
end_comment

begin_function
specifier|static
name|void
name|synopsis_pre
parameter_list|(
name|struct
name|termp
modifier|*
name|p
parameter_list|,
specifier|const
name|struct
name|mdoc_node
modifier|*
name|n
parameter_list|)
block|{
comment|/* 	 * Obviously, if we're not in a SYNOPSIS or no prior macros 	 * exist, do nothing. 	 */
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|prev
operator|||
operator|!
operator|(
name|MDOC_SYNPRETTY
operator|&
name|n
operator|->
name|flags
operator|)
condition|)
return|return;
comment|/* 	 * If we're the second in a pair of like elements, emit our 	 * newline and return.  UNLESS we're `Fo', `Fn', `Fn', in which 	 * case we soldier on. 	 */
if|if
condition|(
name|n
operator|->
name|prev
operator|->
name|tok
operator|==
name|n
operator|->
name|tok
operator|&&
name|MDOC_Ft
operator|!=
name|n
operator|->
name|tok
operator|&&
name|MDOC_Fo
operator|!=
name|n
operator|->
name|tok
operator|&&
name|MDOC_Fn
operator|!=
name|n
operator|->
name|tok
condition|)
block|{
name|term_newln
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If we're one of the SYNOPSIS set and non-like pair-wise after 	 * another (or Fn/Fo, which we've let slip through) then assert 	 * vertical space, else only newline and move on. 	 */
switch|switch
condition|(
name|n
operator|->
name|prev
operator|->
name|tok
condition|)
block|{
case|case
name|MDOC_Fd
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_Fn
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_Fo
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_In
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_Vt
case|:
name|term_vspace
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDOC_Ft
case|:
if|if
condition|(
name|MDOC_Fn
operator|!=
name|n
operator|->
name|tok
operator|&&
name|MDOC_Fo
operator|!=
name|n
operator|->
name|tok
condition|)
block|{
name|term_vspace
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
default|default:
name|term_newln
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|termp_vt_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|MDOC_ELEM
operator|==
name|n
operator|->
name|type
condition|)
block|{
name|synopsis_pre
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
name|termp_under_pre
argument_list|(
name|p
argument_list|,
name|pair
argument_list|,
name|meta
argument_list|,
name|n
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|MDOC_BLOCK
operator|==
name|n
operator|->
name|type
condition|)
block|{
name|synopsis_pre
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|MDOC_HEAD
operator|==
name|n
operator|->
name|type
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|termp_under_pre
argument_list|(
name|p
argument_list|,
name|pair
argument_list|,
name|meta
argument_list|,
name|n
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_bold_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_BOLD
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_fd_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|synopsis_pre
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
name|termp_bold_pre
argument_list|(
name|p
argument_list|,
name|pair
argument_list|,
name|meta
argument_list|,
name|n
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|termp_fd_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|term_newln
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_sh_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
case|case
name|MDOC_BLOCK
case|:
comment|/* 		 * Vertical space before sections, except 		 * when the previous section was empty. 		 */
if|if
condition|(
name|n
operator|->
name|prev
operator|==
name|NULL
operator|||
name|MDOC_Sh
operator|!=
name|n
operator|->
name|prev
operator|->
name|tok
operator|||
operator|(
name|n
operator|->
name|prev
operator|->
name|body
operator|!=
name|NULL
operator|&&
name|n
operator|->
name|prev
operator|->
name|body
operator|->
name|child
operator|!=
name|NULL
operator|)
condition|)
name|term_vspace
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDOC_HEAD
case|:
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_BOLD
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDOC_BODY
case|:
name|p
operator|->
name|offset
operator|=
name|term_len
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|defindent
argument_list|)
expr_stmt|;
if|if
condition|(
name|SEC_AUTHORS
operator|==
name|n
operator|->
name|sec
condition|)
name|p
operator|->
name|flags
operator|&=
operator|~
operator|(
name|TERMP_SPLIT
operator||
name|TERMP_NOSPLIT
operator|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|termp_sh_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
case|case
name|MDOC_HEAD
case|:
name|term_newln
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDOC_BODY
case|:
name|term_newln
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|termp_bt_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|term_word
argument_list|(
name|p
argument_list|,
literal|"is currently in beta test."
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_SENTENCE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|termp_lb_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|SEC_LIBRARY
operator|==
name|n
operator|->
name|sec
operator|&&
name|MDOC_LINE
operator|&
name|n
operator|->
name|flags
condition|)
name|term_newln
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_ud_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|term_word
argument_list|(
name|p
argument_list|,
literal|"currently under development."
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_SENTENCE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_d1_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|MDOC_BLOCK
operator|!=
name|n
operator|->
name|type
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|term_newln
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|offset
operator|+=
name|term_len
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|defindent
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_ft_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
comment|/* NB: MDOC_LINE does not effect this! */
name|synopsis_pre
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_UNDER
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_fn_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|size_t
name|rmargin
init|=
literal|0
decl_stmt|;
name|int
name|pretty
decl_stmt|;
name|pretty
operator|=
name|MDOC_SYNPRETTY
operator|&
name|n
operator|->
name|flags
expr_stmt|;
name|synopsis_pre
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|n
operator|=
name|n
operator|->
name|child
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|pretty
condition|)
block|{
name|rmargin
operator|=
name|p
operator|->
name|rmargin
expr_stmt|;
name|p
operator|->
name|rmargin
operator|=
name|p
operator|->
name|offset
operator|+
name|term_len
argument_list|(
name|p
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOBREAK
operator||
name|TERMP_BRIND
operator||
name|TERMP_HANG
expr_stmt|;
block|}
name|assert
argument_list|(
name|MDOC_TEXT
operator|==
name|n
operator|->
name|type
argument_list|)
expr_stmt|;
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_BOLD
argument_list|)
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
name|n
operator|->
name|string
argument_list|)
expr_stmt|;
name|term_fontpop
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|pretty
condition|)
block|{
name|term_flushln
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator|&=
operator|~
operator|(
name|TERMP_NOBREAK
operator||
name|TERMP_BRIND
operator||
name|TERMP_HANG
operator|)
expr_stmt|;
name|p
operator|->
name|offset
operator|=
name|p
operator|->
name|rmargin
expr_stmt|;
name|p
operator|->
name|rmargin
operator|=
name|rmargin
expr_stmt|;
block|}
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
for|for
control|(
name|n
operator|=
name|n
operator|->
name|next
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
block|{
name|assert
argument_list|(
name|MDOC_TEXT
operator|==
name|n
operator|->
name|type
argument_list|)
expr_stmt|;
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_UNDER
argument_list|)
expr_stmt|;
if|if
condition|(
name|pretty
condition|)
name|p
operator|->
name|flags
operator||=
name|TERMP_NBRWORD
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
name|n
operator|->
name|string
argument_list|)
expr_stmt|;
name|term_fontpop
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|next
condition|)
block|{
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
block|}
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pretty
condition|)
block|{
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
name|term_flushln
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_fa_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
specifier|const
name|struct
name|mdoc_node
modifier|*
name|nn
decl_stmt|;
if|if
condition|(
name|n
operator|->
name|parent
operator|->
name|tok
operator|!=
name|MDOC_Fo
condition|)
block|{
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_UNDER
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
for|for
control|(
name|nn
operator|=
name|n
operator|->
name|child
init|;
name|nn
condition|;
name|nn
operator|=
name|nn
operator|->
name|next
control|)
block|{
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_UNDER
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NBRWORD
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
name|nn
operator|->
name|string
argument_list|)
expr_stmt|;
name|term_fontpop
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|nn
operator|->
name|next
operator|||
operator|(
name|n
operator|->
name|next
operator|&&
name|n
operator|->
name|next
operator|->
name|tok
operator|==
name|MDOC_Fa
operator|)
condition|)
block|{
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_bd_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|size_t
name|tabwidth
decl_stmt|,
name|lm
decl_stmt|,
name|len
decl_stmt|,
name|rm
decl_stmt|,
name|rmax
decl_stmt|;
name|struct
name|mdoc_node
modifier|*
name|nn
decl_stmt|;
if|if
condition|(
name|MDOC_BLOCK
operator|==
name|n
operator|->
name|type
condition|)
block|{
name|print_bvspace
argument_list|(
name|p
argument_list|,
name|n
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|MDOC_HEAD
operator|==
name|n
operator|->
name|type
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Handle the -offset argument. */
if|if
condition|(
name|n
operator|->
name|norm
operator|->
name|Bd
operator|.
name|offs
operator|==
name|NULL
operator|||
operator|!
name|strcmp
argument_list|(
name|n
operator|->
name|norm
operator|->
name|Bd
operator|.
name|offs
argument_list|,
literal|"left"
argument_list|)
condition|)
comment|/* nothing */
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|n
operator|->
name|norm
operator|->
name|Bd
operator|.
name|offs
argument_list|,
literal|"indent"
argument_list|)
condition|)
name|p
operator|->
name|offset
operator|+=
name|term_len
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|defindent
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|n
operator|->
name|norm
operator|->
name|Bd
operator|.
name|offs
argument_list|,
literal|"indent-two"
argument_list|)
condition|)
name|p
operator|->
name|offset
operator|+=
name|term_len
argument_list|(
name|p
argument_list|,
operator|(
name|p
operator|->
name|defindent
operator|+
literal|1
operator|)
operator|*
literal|2
argument_list|)
expr_stmt|;
else|else
name|p
operator|->
name|offset
operator|+=
name|a2width
argument_list|(
name|p
argument_list|,
name|n
operator|->
name|norm
operator|->
name|Bd
operator|.
name|offs
argument_list|)
expr_stmt|;
comment|/* 	 * If -ragged or -filled are specified, the block does nothing 	 * but change the indentation.  If -unfilled or -literal are 	 * specified, text is printed exactly as entered in the display: 	 * for macro lines, a newline is appended to the line.  Blank 	 * lines are allowed. 	 */
if|if
condition|(
name|DISP_literal
operator|!=
name|n
operator|->
name|norm
operator|->
name|Bd
operator|.
name|type
operator|&&
name|DISP_unfilled
operator|!=
name|n
operator|->
name|norm
operator|->
name|Bd
operator|.
name|type
operator|&&
name|DISP_centered
operator|!=
name|n
operator|->
name|norm
operator|->
name|Bd
operator|.
name|type
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|tabwidth
operator|=
name|p
operator|->
name|tabwidth
expr_stmt|;
if|if
condition|(
name|DISP_literal
operator|==
name|n
operator|->
name|norm
operator|->
name|Bd
operator|.
name|type
condition|)
name|p
operator|->
name|tabwidth
operator|=
name|term_len
argument_list|(
name|p
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|lm
operator|=
name|p
operator|->
name|offset
expr_stmt|;
name|rm
operator|=
name|p
operator|->
name|rmargin
expr_stmt|;
name|rmax
operator|=
name|p
operator|->
name|maxrmargin
expr_stmt|;
name|p
operator|->
name|rmargin
operator|=
name|p
operator|->
name|maxrmargin
operator|=
name|TERM_MAXMARGIN
expr_stmt|;
for|for
control|(
name|nn
operator|=
name|n
operator|->
name|child
init|;
name|nn
condition|;
name|nn
operator|=
name|nn
operator|->
name|next
control|)
block|{
if|if
condition|(
name|DISP_centered
operator|==
name|n
operator|->
name|norm
operator|->
name|Bd
operator|.
name|type
condition|)
block|{
if|if
condition|(
name|MDOC_TEXT
operator|==
name|nn
operator|->
name|type
condition|)
block|{
name|len
operator|=
name|term_strlen
argument_list|(
name|p
argument_list|,
name|nn
operator|->
name|string
argument_list|)
expr_stmt|;
name|p
operator|->
name|offset
operator|=
name|len
operator|>=
name|rm
condition|?
literal|0
else|:
name|lm
operator|+
name|len
operator|>=
name|rm
condition|?
name|rm
operator|-
name|len
else|:
operator|(
name|lm
operator|+
name|rm
operator|-
name|len
operator|)
operator|/
literal|2
expr_stmt|;
block|}
else|else
name|p
operator|->
name|offset
operator|=
name|lm
expr_stmt|;
block|}
name|print_mdoc_node
argument_list|(
name|p
argument_list|,
name|pair
argument_list|,
name|meta
argument_list|,
name|nn
argument_list|)
expr_stmt|;
comment|/* 		 * If the printed node flushes its own line, then we 		 * needn't do it here as well.  This is hacky, but the 		 * notion of selective eoln whitespace is pretty dumb 		 * anyway, so don't sweat it. 		 */
switch|switch
condition|(
name|nn
operator|->
name|tok
condition|)
block|{
case|case
name|MDOC_Sm
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_br
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_sp
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_Bl
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_D1
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_Dl
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_Lp
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_Pp
case|:
continue|continue;
default|default:
break|break;
block|}
if|if
condition|(
name|nn
operator|->
name|next
operator|&&
name|nn
operator|->
name|next
operator|->
name|line
operator|==
name|nn
operator|->
name|line
condition|)
continue|continue;
name|term_flushln
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
block|}
name|p
operator|->
name|tabwidth
operator|=
name|tabwidth
expr_stmt|;
name|p
operator|->
name|rmargin
operator|=
name|rm
expr_stmt|;
name|p
operator|->
name|maxrmargin
operator|=
name|rmax
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|termp_bd_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|size_t
name|rm
decl_stmt|,
name|rmax
decl_stmt|;
if|if
condition|(
name|MDOC_BODY
operator|!=
name|n
operator|->
name|type
condition|)
return|return;
name|rm
operator|=
name|p
operator|->
name|rmargin
expr_stmt|;
name|rmax
operator|=
name|p
operator|->
name|maxrmargin
expr_stmt|;
if|if
condition|(
name|DISP_literal
operator|==
name|n
operator|->
name|norm
operator|->
name|Bd
operator|.
name|type
operator|||
name|DISP_unfilled
operator|==
name|n
operator|->
name|norm
operator|->
name|Bd
operator|.
name|type
condition|)
name|p
operator|->
name|rmargin
operator|=
name|p
operator|->
name|maxrmargin
operator|=
name|TERM_MAXMARGIN
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_newln
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|rmargin
operator|=
name|rm
expr_stmt|;
name|p
operator|->
name|maxrmargin
operator|=
name|rmax
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_bx_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|NULL
operator|!=
operator|(
name|n
operator|=
name|n
operator|->
name|child
operator|)
condition|)
block|{
name|term_word
argument_list|(
name|p
argument_list|,
name|n
operator|->
name|string
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|"BSD"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|term_word
argument_list|(
name|p
argument_list|,
literal|"BSD"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|NULL
operator|!=
operator|(
name|n
operator|=
name|n
operator|->
name|next
operator|)
condition|)
block|{
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
name|n
operator|->
name|string
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_xx_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|pp
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|pp
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|n
operator|->
name|tok
condition|)
block|{
case|case
name|MDOC_Bsx
case|:
name|pp
operator|=
literal|"BSD/OS"
expr_stmt|;
break|break;
case|case
name|MDOC_Dx
case|:
name|pp
operator|=
literal|"DragonFly"
expr_stmt|;
break|break;
case|case
name|MDOC_Fx
case|:
name|pp
operator|=
literal|"FreeBSD"
expr_stmt|;
break|break;
case|case
name|MDOC_Nx
case|:
name|pp
operator|=
literal|"NetBSD"
expr_stmt|;
break|break;
case|case
name|MDOC_Ox
case|:
name|pp
operator|=
literal|"OpenBSD"
expr_stmt|;
break|break;
case|case
name|MDOC_Ux
case|:
name|pp
operator|=
literal|"UNIX"
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|term_word
argument_list|(
name|p
argument_list|,
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|child
condition|)
block|{
name|flags
operator|=
name|p
operator|->
name|flags
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_KEEP
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
name|n
operator|->
name|child
operator|->
name|string
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|termp_pf_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_ss_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
case|case
name|MDOC_BLOCK
case|:
name|term_newln
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|prev
condition|)
name|term_vspace
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDOC_HEAD
case|:
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_BOLD
argument_list|)
expr_stmt|;
name|p
operator|->
name|offset
operator|=
name|term_len
argument_list|(
name|p
argument_list|,
operator|(
name|p
operator|->
name|defindent
operator|+
literal|1
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDOC_BODY
case|:
name|p
operator|->
name|offset
operator|=
name|term_len
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|defindent
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|termp_ss_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|MDOC_HEAD
operator|||
name|n
operator|->
name|type
operator|==
name|MDOC_BODY
condition|)
name|term_newln
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_cd_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|synopsis_pre
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_BOLD
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_in_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|synopsis_pre
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|MDOC_SYNPRETTY
operator|&
name|n
operator|->
name|flags
operator|&&
name|MDOC_LINE
operator|&
name|n
operator|->
name|flags
condition|)
block|{
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_BOLD
argument_list|)
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|"#include"
argument_list|)
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|term_word
argument_list|(
name|p
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_UNDER
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|termp_in_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|MDOC_SYNPRETTY
operator|&
name|n
operator|->
name|flags
condition|)
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_BOLD
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
if|if
condition|(
name|MDOC_SYNPRETTY
operator|&
name|n
operator|->
name|flags
condition|)
name|term_fontpop
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_sp_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|len
decl_stmt|;
switch|switch
condition|(
name|n
operator|->
name|tok
condition|)
block|{
case|case
name|MDOC_sp
case|:
name|len
operator|=
name|n
operator|->
name|child
condition|?
name|a2height
argument_list|(
name|p
argument_list|,
name|n
operator|->
name|child
operator|->
name|string
argument_list|)
else|:
literal|1
expr_stmt|;
break|break;
case|case
name|MDOC_br
case|:
name|len
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|len
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
literal|0
operator|==
name|len
condition|)
name|term_newln
argument_list|(
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|term_vspace
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_skip_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_quote_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|MDOC_BODY
operator|!=
name|n
operator|->
name|type
operator|&&
name|MDOC_ELEM
operator|!=
name|n
operator|->
name|type
condition|)
return|return
operator|(
literal|1
operator|)
return|;
switch|switch
condition|(
name|n
operator|->
name|tok
condition|)
block|{
case|case
name|MDOC_Ao
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_Aq
case|:
name|term_word
argument_list|(
name|p
argument_list|,
name|n
operator|->
name|parent
operator|->
name|prev
operator|!=
name|NULL
operator|&&
name|n
operator|->
name|parent
operator|->
name|prev
operator|->
name|tok
operator|==
name|MDOC_An
condition|?
literal|"<"
else|:
literal|"\\(la"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDOC_Bro
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_Brq
case|:
name|term_word
argument_list|(
name|p
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDOC_Oo
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_Op
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_Bo
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_Bq
case|:
name|term_word
argument_list|(
name|p
argument_list|,
literal|"["
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDOC_Do
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_Dq
case|:
name|term_word
argument_list|(
name|p
argument_list|,
literal|"\\(lq"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDOC_En
case|:
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|norm
operator|->
name|Es
operator|||
name|NULL
operator|==
name|n
operator|->
name|norm
operator|->
name|Es
operator|->
name|child
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|term_word
argument_list|(
name|p
argument_list|,
name|n
operator|->
name|norm
operator|->
name|Es
operator|->
name|child
operator|->
name|string
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDOC_Eo
case|:
break|break;
case|case
name|MDOC_Po
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_Pq
case|:
name|term_word
argument_list|(
name|p
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDOC__T
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_Qo
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_Qq
case|:
name|term_word
argument_list|(
name|p
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDOC_Ql
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_So
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_Sq
case|:
name|term_word
argument_list|(
name|p
argument_list|,
literal|"\\(oq"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|termp_quote_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|n
operator|->
name|type
operator|!=
name|MDOC_BODY
operator|&&
name|n
operator|->
name|type
operator|!=
name|MDOC_ELEM
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|n
operator|->
name|tok
operator|==
name|MDOC_En
operator|||
operator|(
name|n
operator|->
name|tok
operator|==
name|MDOC_Eo
operator|&&
name|n
operator|->
name|end
operator|==
name|ENDBODY_SPACE
operator|)
operator|)
condition|)
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
switch|switch
condition|(
name|n
operator|->
name|tok
condition|)
block|{
case|case
name|MDOC_Ao
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_Aq
case|:
name|term_word
argument_list|(
name|p
argument_list|,
name|n
operator|->
name|parent
operator|->
name|prev
operator|!=
name|NULL
operator|&&
name|n
operator|->
name|parent
operator|->
name|prev
operator|->
name|tok
operator|==
name|MDOC_An
condition|?
literal|">"
else|:
literal|"\\(ra"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDOC_Bro
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_Brq
case|:
name|term_word
argument_list|(
name|p
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDOC_Oo
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_Op
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_Bo
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_Bq
case|:
name|term_word
argument_list|(
name|p
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDOC_Do
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_Dq
case|:
name|term_word
argument_list|(
name|p
argument_list|,
literal|"\\(rq"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDOC_En
case|:
if|if
condition|(
name|NULL
operator|!=
name|n
operator|->
name|norm
operator|->
name|Es
operator|&&
name|NULL
operator|!=
name|n
operator|->
name|norm
operator|->
name|Es
operator|->
name|child
operator|&&
name|NULL
operator|!=
name|n
operator|->
name|norm
operator|->
name|Es
operator|->
name|child
operator|->
name|next
condition|)
block|{
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
name|n
operator|->
name|norm
operator|->
name|Es
operator|->
name|child
operator|->
name|next
operator|->
name|string
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MDOC_Eo
case|:
break|break;
case|case
name|MDOC_Po
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_Pq
case|:
name|term_word
argument_list|(
name|p
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDOC__T
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_Qo
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_Qq
case|:
name|term_word
argument_list|(
name|p
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDOC_Ql
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_So
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_Sq
case|:
name|term_word
argument_list|(
name|p
argument_list|,
literal|"\\(cq"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|termp_fo_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|size_t
name|rmargin
init|=
literal|0
decl_stmt|;
name|int
name|pretty
decl_stmt|;
name|pretty
operator|=
name|MDOC_SYNPRETTY
operator|&
name|n
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|MDOC_BLOCK
operator|==
name|n
operator|->
name|type
condition|)
block|{
name|synopsis_pre
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|MDOC_BODY
operator|==
name|n
operator|->
name|type
condition|)
block|{
if|if
condition|(
name|pretty
condition|)
block|{
name|rmargin
operator|=
name|p
operator|->
name|rmargin
expr_stmt|;
name|p
operator|->
name|rmargin
operator|=
name|p
operator|->
name|offset
operator|+
name|term_len
argument_list|(
name|p
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOBREAK
operator||
name|TERMP_BRIND
operator||
name|TERMP_HANG
expr_stmt|;
block|}
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
if|if
condition|(
name|pretty
condition|)
block|{
name|term_flushln
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator|&=
operator|~
operator|(
name|TERMP_NOBREAK
operator||
name|TERMP_BRIND
operator||
name|TERMP_HANG
operator|)
expr_stmt|;
name|p
operator|->
name|offset
operator|=
name|p
operator|->
name|rmargin
expr_stmt|;
name|p
operator|->
name|rmargin
operator|=
name|rmargin
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|child
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* XXX: we drop non-initial arguments as per groff. */
name|assert
argument_list|(
name|n
operator|->
name|child
operator|->
name|string
argument_list|)
expr_stmt|;
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_BOLD
argument_list|)
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
name|n
operator|->
name|child
operator|->
name|string
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|termp_fo_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|MDOC_BODY
operator|!=
name|n
operator|->
name|type
condition|)
return|return;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
name|MDOC_SYNPRETTY
operator|&
name|n
operator|->
name|flags
condition|)
block|{
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
name|term_flushln
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|termp_bf_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|MDOC_HEAD
operator|==
name|n
operator|->
name|type
condition|)
return|return
operator|(
literal|0
operator|)
return|;
elseif|else
if|if
condition|(
name|MDOC_BODY
operator|!=
name|n
operator|->
name|type
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|FONT_Em
operator|==
name|n
operator|->
name|norm
operator|->
name|Bf
operator|.
name|font
condition|)
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_UNDER
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|FONT_Sy
operator|==
name|n
operator|->
name|norm
operator|->
name|Bf
operator|.
name|font
condition|)
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_BOLD
argument_list|)
expr_stmt|;
else|else
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_NONE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_sm_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|child
condition|)
name|p
operator|->
name|flags
operator|^=
name|TERMP_NONOSPACE
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
literal|"on"
argument_list|,
name|n
operator|->
name|child
operator|->
name|string
argument_list|)
condition|)
name|p
operator|->
name|flags
operator|&=
operator|~
name|TERMP_NONOSPACE
expr_stmt|;
else|else
name|p
operator|->
name|flags
operator||=
name|TERMP_NONOSPACE
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|col
operator|&&
operator|!
operator|(
name|TERMP_NONOSPACE
operator|&
name|p
operator|->
name|flags
operator|)
condition|)
name|p
operator|->
name|flags
operator|&=
operator|~
name|TERMP_NOSPACE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_ap_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|termp____post
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
comment|/* 	 * Handle lists of authors.  In general, print each followed by 	 * a comma.  Don't print the comma if there are only two 	 * authors. 	 */
if|if
condition|(
name|MDOC__A
operator|==
name|n
operator|->
name|tok
operator|&&
name|n
operator|->
name|next
operator|&&
name|MDOC__A
operator|==
name|n
operator|->
name|next
operator|->
name|tok
condition|)
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|next
operator|->
name|next
operator|||
name|MDOC__A
operator|!=
name|n
operator|->
name|next
operator|->
name|next
operator|->
name|tok
condition|)
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|prev
operator|||
name|MDOC__A
operator|!=
name|n
operator|->
name|prev
operator|->
name|tok
condition|)
return|return;
comment|/* TODO: %U. */
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|parent
operator|||
name|MDOC_Rs
operator|!=
name|n
operator|->
name|parent
operator|->
name|tok
condition|)
return|return;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|next
condition|)
block|{
name|term_word
argument_list|(
name|p
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_SENTENCE
expr_stmt|;
block|}
else|else
name|term_word
argument_list|(
name|p
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_li_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_NONE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_lk_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
specifier|const
name|struct
name|mdoc_node
modifier|*
name|link
decl_stmt|,
modifier|*
name|descr
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|link
operator|=
name|n
operator|->
name|child
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|descr
operator|=
name|link
operator|->
name|next
operator|)
condition|)
block|{
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_UNDER
argument_list|)
expr_stmt|;
while|while
condition|(
name|NULL
operator|!=
name|descr
condition|)
block|{
name|term_word
argument_list|(
name|p
argument_list|,
name|descr
operator|->
name|string
argument_list|)
expr_stmt|;
name|descr
operator|=
name|descr
operator|->
name|next
expr_stmt|;
block|}
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|term_fontpop
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_BOLD
argument_list|)
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
name|link
operator|->
name|string
argument_list|)
expr_stmt|;
name|term_fontpop
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_bk_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
case|case
name|MDOC_BLOCK
case|:
break|break;
case|case
name|MDOC_HEAD
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|MDOC_BODY
case|:
if|if
condition|(
name|n
operator|->
name|parent
operator|->
name|args
operator|||
literal|0
operator|==
name|n
operator|->
name|prev
operator|->
name|nchild
condition|)
name|p
operator|->
name|flags
operator||=
name|TERMP_PREKEEP
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|termp_bk_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|MDOC_BODY
operator|==
name|n
operator|->
name|type
condition|)
name|p
operator|->
name|flags
operator|&=
operator|~
operator|(
name|TERMP_KEEP
operator||
name|TERMP_PREKEEP
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|termp__t_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
comment|/* 	 * If we're in an `Rs' and there's a journal present, then quote 	 * us instead of underlining us (for disambiguation). 	 */
if|if
condition|(
name|n
operator|->
name|parent
operator|&&
name|MDOC_Rs
operator|==
name|n
operator|->
name|parent
operator|->
name|tok
operator|&&
name|n
operator|->
name|parent
operator|->
name|norm
operator|->
name|Rs
operator|.
name|quote_T
condition|)
name|termp_quote_post
argument_list|(
name|p
argument_list|,
name|pair
argument_list|,
name|meta
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|termp____post
argument_list|(
name|p
argument_list|,
name|pair
argument_list|,
name|meta
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp__t_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
comment|/* 	 * If we're in an `Rs' and there's a journal present, then quote 	 * us instead of underlining us (for disambiguation). 	 */
if|if
condition|(
name|n
operator|->
name|parent
operator|&&
name|MDOC_Rs
operator|==
name|n
operator|->
name|parent
operator|->
name|tok
operator|&&
name|n
operator|->
name|parent
operator|->
name|norm
operator|->
name|Rs
operator|.
name|quote_T
condition|)
return|return
operator|(
name|termp_quote_pre
argument_list|(
name|p
argument_list|,
name|pair
argument_list|,
name|meta
argument_list|,
name|n
argument_list|)
operator|)
return|;
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_UNDER
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_under_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_UNDER
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

end_unit

