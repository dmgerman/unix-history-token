begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$Id: mdoc_term.c,v 1.364 2017/06/14 17:51:15 schwarze Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2008, 2009, 2010, 2011 Kristaps Dzonsons<kristaps@bsd.lv>  * Copyright (c) 2010, 2012-2017 Ingo Schwarze<schwarze@openbsd.org>  * Copyright (c) 2013 Franco Fichtner<franco@lastsummer.de>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"mandoc_aux.h"
end_include

begin_include
include|#
directive|include
file|"mandoc.h"
end_include

begin_include
include|#
directive|include
file|"roff.h"
end_include

begin_include
include|#
directive|include
file|"mdoc.h"
end_include

begin_include
include|#
directive|include
file|"out.h"
end_include

begin_include
include|#
directive|include
file|"term.h"
end_include

begin_include
include|#
directive|include
file|"tag.h"
end_include

begin_include
include|#
directive|include
file|"main.h"
end_include

begin_struct
struct|struct
name|termpair
block|{
name|struct
name|termpair
modifier|*
name|ppair
decl_stmt|;
name|int
name|count
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DECL_ARGS
value|struct termp *p, \ 		  struct termpair *pair, \ 		  const struct roff_meta *meta, \ 		  struct roff_node *n
end_define

begin_struct
struct|struct
name|termact
block|{
name|int
function_decl|(
modifier|*
name|pre
function_decl|)
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|post
function_decl|)
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|a2width
parameter_list|(
specifier|const
name|struct
name|termp
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_bvspace
parameter_list|(
name|struct
name|termp
modifier|*
parameter_list|,
specifier|const
name|struct
name|roff_node
modifier|*
parameter_list|,
specifier|const
name|struct
name|roff_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_mdoc_node
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_mdoc_nodelist
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_mdoc_head
parameter_list|(
name|struct
name|termp
modifier|*
parameter_list|,
specifier|const
name|struct
name|roff_meta
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_mdoc_foot
parameter_list|(
name|struct
name|termp
modifier|*
parameter_list|,
specifier|const
name|struct
name|roff_meta
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|synopsis_pre
parameter_list|(
name|struct
name|termp
modifier|*
parameter_list|,
specifier|const
name|struct
name|roff_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|termp____post
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|termp__t_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|termp_bd_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|termp_bk_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|termp_bl_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|termp_eo_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|termp_fd_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|termp_fo_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|termp_in_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|termp_it_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|termp_lb_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|termp_nm_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|termp_pf_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|termp_quote_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|termp_sh_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|termp_ss_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|termp_xx_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp__a_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp__t_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_an_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_ap_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_bd_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_bf_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_bk_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_bl_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_bold_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_cd_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_d1_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_eo_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_em_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_er_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_ex_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_fa_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_fd_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_fl_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_fn_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_fo_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_ft_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_in_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_it_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_li_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_lk_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_nd_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_nm_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_ns_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_quote_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_rs_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_sh_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_skip_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_sm_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_pp_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_ss_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_sy_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_tag_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_under_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_vt_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_xr_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|termp_xx_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|termact
name|__termacts
index|[
name|MDOC_MAX
operator|-
name|MDOC_Dd
index|]
init|=
block|{
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Dd */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Dt */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Os */
block|{
name|termp_sh_pre
block|,
name|termp_sh_post
block|}
block|,
comment|/* Sh */
block|{
name|termp_ss_pre
block|,
name|termp_ss_post
block|}
block|,
comment|/* Ss */
block|{
name|termp_pp_pre
block|,
name|NULL
block|}
block|,
comment|/* Pp */
block|{
name|termp_d1_pre
block|,
name|termp_bl_post
block|}
block|,
comment|/* D1 */
block|{
name|termp_d1_pre
block|,
name|termp_bl_post
block|}
block|,
comment|/* Dl */
block|{
name|termp_bd_pre
block|,
name|termp_bd_post
block|}
block|,
comment|/* Bd */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ed */
block|{
name|termp_bl_pre
block|,
name|termp_bl_post
block|}
block|,
comment|/* Bl */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* El */
block|{
name|termp_it_pre
block|,
name|termp_it_post
block|}
block|,
comment|/* It */
block|{
name|termp_under_pre
block|,
name|NULL
block|}
block|,
comment|/* Ad */
block|{
name|termp_an_pre
block|,
name|NULL
block|}
block|,
comment|/* An */
block|{
name|termp_ap_pre
block|,
name|NULL
block|}
block|,
comment|/* Ap */
block|{
name|termp_under_pre
block|,
name|NULL
block|}
block|,
comment|/* Ar */
block|{
name|termp_cd_pre
block|,
name|NULL
block|}
block|,
comment|/* Cd */
block|{
name|termp_bold_pre
block|,
name|NULL
block|}
block|,
comment|/* Cm */
block|{
name|termp_li_pre
block|,
name|NULL
block|}
block|,
comment|/* Dv */
block|{
name|termp_er_pre
block|,
name|NULL
block|}
block|,
comment|/* Er */
block|{
name|termp_tag_pre
block|,
name|NULL
block|}
block|,
comment|/* Ev */
block|{
name|termp_ex_pre
block|,
name|NULL
block|}
block|,
comment|/* Ex */
block|{
name|termp_fa_pre
block|,
name|NULL
block|}
block|,
comment|/* Fa */
block|{
name|termp_fd_pre
block|,
name|termp_fd_post
block|}
block|,
comment|/* Fd */
block|{
name|termp_fl_pre
block|,
name|NULL
block|}
block|,
comment|/* Fl */
block|{
name|termp_fn_pre
block|,
name|NULL
block|}
block|,
comment|/* Fn */
block|{
name|termp_ft_pre
block|,
name|NULL
block|}
block|,
comment|/* Ft */
block|{
name|termp_bold_pre
block|,
name|NULL
block|}
block|,
comment|/* Ic */
block|{
name|termp_in_pre
block|,
name|termp_in_post
block|}
block|,
comment|/* In */
block|{
name|termp_li_pre
block|,
name|NULL
block|}
block|,
comment|/* Li */
block|{
name|termp_nd_pre
block|,
name|NULL
block|}
block|,
comment|/* Nd */
block|{
name|termp_nm_pre
block|,
name|termp_nm_post
block|}
block|,
comment|/* Nm */
block|{
name|termp_quote_pre
block|,
name|termp_quote_post
block|}
block|,
comment|/* Op */
block|{
name|termp_ft_pre
block|,
name|NULL
block|}
block|,
comment|/* Ot */
block|{
name|termp_under_pre
block|,
name|NULL
block|}
block|,
comment|/* Pa */
block|{
name|termp_ex_pre
block|,
name|NULL
block|}
block|,
comment|/* Rv */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* St */
block|{
name|termp_under_pre
block|,
name|NULL
block|}
block|,
comment|/* Va */
block|{
name|termp_vt_pre
block|,
name|NULL
block|}
block|,
comment|/* Vt */
block|{
name|termp_xr_pre
block|,
name|NULL
block|}
block|,
comment|/* Xr */
block|{
name|termp__a_pre
block|,
name|termp____post
block|}
block|,
comment|/* %A */
block|{
name|termp_under_pre
block|,
name|termp____post
block|}
block|,
comment|/* %B */
block|{
name|NULL
block|,
name|termp____post
block|}
block|,
comment|/* %D */
block|{
name|termp_under_pre
block|,
name|termp____post
block|}
block|,
comment|/* %I */
block|{
name|termp_under_pre
block|,
name|termp____post
block|}
block|,
comment|/* %J */
block|{
name|NULL
block|,
name|termp____post
block|}
block|,
comment|/* %N */
block|{
name|NULL
block|,
name|termp____post
block|}
block|,
comment|/* %O */
block|{
name|NULL
block|,
name|termp____post
block|}
block|,
comment|/* %P */
block|{
name|NULL
block|,
name|termp____post
block|}
block|,
comment|/* %R */
block|{
name|termp__t_pre
block|,
name|termp__t_post
block|}
block|,
comment|/* %T */
block|{
name|NULL
block|,
name|termp____post
block|}
block|,
comment|/* %V */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ac */
block|{
name|termp_quote_pre
block|,
name|termp_quote_post
block|}
block|,
comment|/* Ao */
block|{
name|termp_quote_pre
block|,
name|termp_quote_post
block|}
block|,
comment|/* Aq */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* At */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Bc */
block|{
name|termp_bf_pre
block|,
name|NULL
block|}
block|,
comment|/* Bf */
block|{
name|termp_quote_pre
block|,
name|termp_quote_post
block|}
block|,
comment|/* Bo */
block|{
name|termp_quote_pre
block|,
name|termp_quote_post
block|}
block|,
comment|/* Bq */
block|{
name|termp_xx_pre
block|,
name|termp_xx_post
block|}
block|,
comment|/* Bsx */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Bx */
block|{
name|termp_skip_pre
block|,
name|NULL
block|}
block|,
comment|/* Db */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Dc */
block|{
name|termp_quote_pre
block|,
name|termp_quote_post
block|}
block|,
comment|/* Do */
block|{
name|termp_quote_pre
block|,
name|termp_quote_post
block|}
block|,
comment|/* Dq */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ec */
comment|/* FIXME: no space */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ef */
block|{
name|termp_em_pre
block|,
name|NULL
block|}
block|,
comment|/* Em */
block|{
name|termp_eo_pre
block|,
name|termp_eo_post
block|}
block|,
comment|/* Eo */
block|{
name|termp_xx_pre
block|,
name|termp_xx_post
block|}
block|,
comment|/* Fx */
block|{
name|termp_bold_pre
block|,
name|NULL
block|}
block|,
comment|/* Ms */
block|{
name|termp_li_pre
block|,
name|NULL
block|}
block|,
comment|/* No */
block|{
name|termp_ns_pre
block|,
name|NULL
block|}
block|,
comment|/* Ns */
block|{
name|termp_xx_pre
block|,
name|termp_xx_post
block|}
block|,
comment|/* Nx */
block|{
name|termp_xx_pre
block|,
name|termp_xx_post
block|}
block|,
comment|/* Ox */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Pc */
block|{
name|NULL
block|,
name|termp_pf_post
block|}
block|,
comment|/* Pf */
block|{
name|termp_quote_pre
block|,
name|termp_quote_post
block|}
block|,
comment|/* Po */
block|{
name|termp_quote_pre
block|,
name|termp_quote_post
block|}
block|,
comment|/* Pq */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Qc */
block|{
name|termp_quote_pre
block|,
name|termp_quote_post
block|}
block|,
comment|/* Ql */
block|{
name|termp_quote_pre
block|,
name|termp_quote_post
block|}
block|,
comment|/* Qo */
block|{
name|termp_quote_pre
block|,
name|termp_quote_post
block|}
block|,
comment|/* Qq */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Re */
block|{
name|termp_rs_pre
block|,
name|NULL
block|}
block|,
comment|/* Rs */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Sc */
block|{
name|termp_quote_pre
block|,
name|termp_quote_post
block|}
block|,
comment|/* So */
block|{
name|termp_quote_pre
block|,
name|termp_quote_post
block|}
block|,
comment|/* Sq */
block|{
name|termp_sm_pre
block|,
name|NULL
block|}
block|,
comment|/* Sm */
block|{
name|termp_under_pre
block|,
name|NULL
block|}
block|,
comment|/* Sx */
block|{
name|termp_sy_pre
block|,
name|NULL
block|}
block|,
comment|/* Sy */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Tn */
block|{
name|termp_xx_pre
block|,
name|termp_xx_post
block|}
block|,
comment|/* Ux */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Xc */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Xo */
block|{
name|termp_fo_pre
block|,
name|termp_fo_post
block|}
block|,
comment|/* Fo */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Fc */
block|{
name|termp_quote_pre
block|,
name|termp_quote_post
block|}
block|,
comment|/* Oo */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Oc */
block|{
name|termp_bk_pre
block|,
name|termp_bk_post
block|}
block|,
comment|/* Bk */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ek */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Bt */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Hf */
block|{
name|termp_under_pre
block|,
name|NULL
block|}
block|,
comment|/* Fr */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ud */
block|{
name|NULL
block|,
name|termp_lb_post
block|}
block|,
comment|/* Lb */
block|{
name|termp_pp_pre
block|,
name|NULL
block|}
block|,
comment|/* Lp */
block|{
name|termp_lk_pre
block|,
name|NULL
block|}
block|,
comment|/* Lk */
block|{
name|termp_under_pre
block|,
name|NULL
block|}
block|,
comment|/* Mt */
block|{
name|termp_quote_pre
block|,
name|termp_quote_post
block|}
block|,
comment|/* Brq */
block|{
name|termp_quote_pre
block|,
name|termp_quote_post
block|}
block|,
comment|/* Bro */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Brc */
block|{
name|NULL
block|,
name|termp____post
block|}
block|,
comment|/* %C */
block|{
name|termp_skip_pre
block|,
name|NULL
block|}
block|,
comment|/* Es */
block|{
name|termp_quote_pre
block|,
name|termp_quote_post
block|}
block|,
comment|/* En */
block|{
name|termp_xx_pre
block|,
name|termp_xx_post
block|}
block|,
comment|/* Dx */
block|{
name|NULL
block|,
name|termp____post
block|}
block|,
comment|/* %Q */
block|{
name|NULL
block|,
name|termp____post
block|}
block|,
comment|/* %U */
block|{
name|NULL
block|,
name|NULL
block|}
block|,
comment|/* Ta */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|termact
modifier|*
specifier|const
name|termacts
init|=
name|__termacts
operator|-
name|MDOC_Dd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fn_prio
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|terminal_mdoc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|struct
name|roff_man
modifier|*
name|mdoc
parameter_list|)
block|{
name|struct
name|roff_node
modifier|*
name|n
decl_stmt|;
name|struct
name|termp
modifier|*
name|p
decl_stmt|;
name|size_t
name|save_defindent
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|termp
operator|*
operator|)
name|arg
expr_stmt|;
name|p
operator|->
name|tcol
operator|->
name|rmargin
operator|=
name|p
operator|->
name|maxrmargin
operator|=
name|p
operator|->
name|defrmargin
expr_stmt|;
name|term_tab_set
argument_list|(
name|p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|term_tab_set
argument_list|(
name|p
argument_list|,
literal|"T"
argument_list|)
expr_stmt|;
name|term_tab_set
argument_list|(
name|p
argument_list|,
literal|".5i"
argument_list|)
expr_stmt|;
name|n
operator|=
name|mdoc
operator|->
name|first
operator|->
name|child
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|synopsisonly
condition|)
block|{
while|while
condition|(
name|n
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|tok
operator|==
name|MDOC_Sh
operator|&&
name|n
operator|->
name|sec
operator|==
name|SEC_SYNOPSIS
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|child
operator|->
name|next
operator|->
name|child
operator|!=
name|NULL
condition|)
name|print_mdoc_nodelist
argument_list|(
name|p
argument_list|,
name|NULL
argument_list|,
operator|&
name|mdoc
operator|->
name|meta
argument_list|,
name|n
operator|->
name|child
operator|->
name|next
operator|->
name|child
argument_list|)
expr_stmt|;
name|term_newln
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
name|n
operator|=
name|n
operator|->
name|next
expr_stmt|;
block|}
block|}
else|else
block|{
name|save_defindent
operator|=
name|p
operator|->
name|defindent
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|defindent
operator|==
literal|0
condition|)
name|p
operator|->
name|defindent
operator|=
literal|5
expr_stmt|;
name|term_begin
argument_list|(
name|p
argument_list|,
name|print_mdoc_head
argument_list|,
name|print_mdoc_foot
argument_list|,
operator|&
name|mdoc
operator|->
name|meta
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|!=
name|NULL
operator|&&
name|n
operator|->
name|flags
operator|&
name|NODE_NOPRT
condition|)
name|n
operator|=
name|n
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|tok
operator|!=
name|MDOC_Sh
condition|)
name|term_vspace
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|print_mdoc_nodelist
argument_list|(
name|p
argument_list|,
name|NULL
argument_list|,
operator|&
name|mdoc
operator|->
name|meta
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
name|term_end
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|defindent
operator|=
name|save_defindent
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_mdoc_nodelist
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
while|while
condition|(
name|n
operator|!=
name|NULL
condition|)
block|{
name|print_mdoc_node
argument_list|(
name|p
argument_list|,
name|pair
argument_list|,
name|meta
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|n
operator|=
name|n
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_mdoc_node
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|int
name|chld
decl_stmt|;
name|struct
name|termpair
name|npair
decl_stmt|;
name|size_t
name|offset
decl_stmt|,
name|rmargin
decl_stmt|;
if|if
condition|(
name|n
operator|->
name|flags
operator|&
name|NODE_NOPRT
condition|)
return|return;
name|chld
operator|=
literal|1
expr_stmt|;
name|offset
operator|=
name|p
operator|->
name|tcol
operator|->
name|offset
expr_stmt|;
name|rmargin
operator|=
name|p
operator|->
name|tcol
operator|->
name|rmargin
expr_stmt|;
name|n
operator|->
name|flags
operator|&=
operator|~
name|NODE_ENDED
expr_stmt|;
name|n
operator|->
name|prev_font
operator|=
name|p
operator|->
name|fonti
expr_stmt|;
name|memset
argument_list|(
operator|&
name|npair
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|termpair
argument_list|)
argument_list|)
expr_stmt|;
name|npair
operator|.
name|ppair
operator|=
name|pair
expr_stmt|;
comment|/* 	 * Keeps only work until the end of a line.  If a keep was 	 * invoked in a prior line, revert it to PREKEEP. 	 */
if|if
condition|(
name|p
operator|->
name|flags
operator|&
name|TERMP_KEEP
operator|&&
name|n
operator|->
name|flags
operator|&
name|NODE_LINE
condition|)
block|{
name|p
operator|->
name|flags
operator|&=
operator|~
name|TERMP_KEEP
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_PREKEEP
expr_stmt|;
block|}
comment|/* 	 * After the keep flags have been set up, we may now 	 * produce output.  Note that some pre-handlers do so. 	 */
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
case|case
name|ROFFT_TEXT
case|:
if|if
condition|(
operator|*
name|n
operator|->
name|string
operator|==
literal|' '
operator|&&
name|n
operator|->
name|flags
operator|&
name|NODE_LINE
operator|&&
operator|(
name|p
operator|->
name|flags
operator|&
name|TERMP_NONEWLINE
operator|)
operator|==
literal|0
condition|)
name|term_newln
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|NODE_DELIMC
operator|&
name|n
operator|->
name|flags
condition|)
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
name|n
operator|->
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|NODE_DELIMO
operator|&
name|n
operator|->
name|flags
condition|)
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
break|break;
case|case
name|ROFFT_EQN
case|:
if|if
condition|(
operator|!
operator|(
name|n
operator|->
name|flags
operator|&
name|NODE_LINE
operator|)
condition|)
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_eqn
argument_list|(
name|p
argument_list|,
name|n
operator|->
name|eqn
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|next
operator|!=
name|NULL
operator|&&
operator|!
operator|(
name|n
operator|->
name|next
operator|->
name|flags
operator|&
name|NODE_LINE
operator|)
condition|)
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
break|break;
case|case
name|ROFFT_TBL
case|:
if|if
condition|(
name|p
operator|->
name|tbl
operator|.
name|cols
operator|==
name|NULL
condition|)
name|term_newln
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|term_tbl
argument_list|(
name|p
argument_list|,
name|n
operator|->
name|span
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|n
operator|->
name|tok
operator|<
name|ROFF_MAX
condition|)
block|{
name|roff_term_pre
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return;
block|}
name|assert
argument_list|(
name|n
operator|->
name|tok
operator|>=
name|MDOC_Dd
operator|&&
name|n
operator|->
name|tok
operator|<
name|MDOC_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|termacts
index|[
name|n
operator|->
name|tok
index|]
operator|.
name|pre
operator|!=
name|NULL
operator|&&
operator|(
name|n
operator|->
name|end
operator|==
name|ENDBODY_NOT
operator|||
name|n
operator|->
name|child
operator|!=
name|NULL
operator|)
condition|)
name|chld
operator|=
operator|(
operator|*
name|termacts
index|[
name|n
operator|->
name|tok
index|]
operator|.
name|pre
operator|)
operator|(
name|p
operator|,
operator|&
name|npair
operator|,
name|meta
operator|,
name|n
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|chld
operator|&&
name|n
operator|->
name|child
condition|)
name|print_mdoc_nodelist
argument_list|(
name|p
argument_list|,
operator|&
name|npair
argument_list|,
name|meta
argument_list|,
name|n
operator|->
name|child
argument_list|)
expr_stmt|;
name|term_fontpopq
argument_list|(
name|p
argument_list|,
operator|(
name|ENDBODY_NOT
operator|==
name|n
operator|->
name|end
condition|?
name|n
else|:
name|n
operator|->
name|body
operator|)
operator|->
name|prev_font
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
case|case
name|ROFFT_TEXT
case|:
break|break;
case|case
name|ROFFT_TBL
case|:
break|break;
case|case
name|ROFFT_EQN
case|:
break|break;
default|default:
if|if
condition|(
name|termacts
index|[
name|n
operator|->
name|tok
index|]
operator|.
name|post
operator|==
name|NULL
operator|||
name|n
operator|->
name|flags
operator|&
name|NODE_ENDED
condition|)
break|break;
call|(
name|void
call|)
argument_list|(
operator|*
name|termacts
index|[
name|n
operator|->
name|tok
index|]
operator|.
name|post
argument_list|)
argument_list|(
name|p
argument_list|,
operator|&
name|npair
argument_list|,
name|meta
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* 		 * Explicit end tokens not only call the post 		 * handler, but also tell the respective block 		 * that it must not call the post handler again. 		 */
if|if
condition|(
name|ENDBODY_NOT
operator|!=
name|n
operator|->
name|end
condition|)
name|n
operator|->
name|body
operator|->
name|flags
operator||=
name|NODE_ENDED
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|NODE_EOS
operator|&
name|n
operator|->
name|flags
condition|)
name|p
operator|->
name|flags
operator||=
name|TERMP_SENTENCE
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|type
operator|!=
name|ROFFT_TEXT
condition|)
name|p
operator|->
name|tcol
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|p
operator|->
name|tcol
operator|->
name|rmargin
operator|=
name|rmargin
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_mdoc_foot
parameter_list|(
name|struct
name|termp
modifier|*
name|p
parameter_list|,
specifier|const
name|struct
name|roff_meta
modifier|*
name|meta
parameter_list|)
block|{
name|size_t
name|sz
decl_stmt|;
name|term_fontrepl
argument_list|(
name|p
argument_list|,
name|TERMFONT_NONE
argument_list|)
expr_stmt|;
comment|/* 	 * Output the footer in new-groff style, that is, three columns 	 * with the middle being the manual date and flanking columns 	 * being the operating system: 	 * 	 * SYSTEM                  DATE                    SYSTEM 	 */
name|term_vspace
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|tcol
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|sz
operator|=
name|term_strlen
argument_list|(
name|p
argument_list|,
name|meta
operator|->
name|date
argument_list|)
expr_stmt|;
name|p
operator|->
name|tcol
operator|->
name|rmargin
operator|=
name|p
operator|->
name|maxrmargin
operator|>
name|sz
condition|?
operator|(
name|p
operator|->
name|maxrmargin
operator|+
name|term_len
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
operator|-
name|sz
operator|)
operator|/
literal|2
else|:
literal|0
expr_stmt|;
name|p
operator|->
name|trailspace
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
operator||
name|TERMP_NOBREAK
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
name|meta
operator|->
name|os
argument_list|)
expr_stmt|;
name|term_flushln
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|tcol
operator|->
name|offset
operator|=
name|p
operator|->
name|tcol
operator|->
name|rmargin
expr_stmt|;
name|sz
operator|=
name|term_strlen
argument_list|(
name|p
argument_list|,
name|meta
operator|->
name|os
argument_list|)
expr_stmt|;
name|p
operator|->
name|tcol
operator|->
name|rmargin
operator|=
name|p
operator|->
name|maxrmargin
operator|>
name|sz
condition|?
name|p
operator|->
name|maxrmargin
operator|-
name|sz
else|:
literal|0
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
name|meta
operator|->
name|date
argument_list|)
expr_stmt|;
name|term_flushln
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|tcol
operator|->
name|offset
operator|=
name|p
operator|->
name|tcol
operator|->
name|rmargin
expr_stmt|;
name|p
operator|->
name|tcol
operator|->
name|rmargin
operator|=
name|p
operator|->
name|maxrmargin
expr_stmt|;
name|p
operator|->
name|trailspace
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|flags
operator|&=
operator|~
name|TERMP_NOBREAK
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
name|meta
operator|->
name|os
argument_list|)
expr_stmt|;
name|term_flushln
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|tcol
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|tcol
operator|->
name|rmargin
operator|=
name|p
operator|->
name|maxrmargin
expr_stmt|;
name|p
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_mdoc_head
parameter_list|(
name|struct
name|termp
modifier|*
name|p
parameter_list|,
specifier|const
name|struct
name|roff_meta
modifier|*
name|meta
parameter_list|)
block|{
name|char
modifier|*
name|volume
decl_stmt|,
modifier|*
name|title
decl_stmt|;
name|size_t
name|vollen
decl_stmt|,
name|titlen
decl_stmt|;
comment|/* 	 * The header is strange.  It has three components, which are 	 * really two with the first duplicated.  It goes like this: 	 * 	 * IDENTIFIER              TITLE                   IDENTIFIER 	 * 	 * The IDENTIFIER is NAME(SECTION), which is the command-name 	 * (if given, or "unknown" if not) followed by the manual page 	 * section.  These are given in `Dt'.  The TITLE is a free-form 	 * string depending on the manual volume.  If not specified, it 	 * switches on the manual section. 	 */
name|assert
argument_list|(
name|meta
operator|->
name|vol
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|meta
operator|->
name|arch
condition|)
name|volume
operator|=
name|mandoc_strdup
argument_list|(
name|meta
operator|->
name|vol
argument_list|)
expr_stmt|;
else|else
name|mandoc_asprintf
argument_list|(
operator|&
name|volume
argument_list|,
literal|"%s (%s)"
argument_list|,
name|meta
operator|->
name|vol
argument_list|,
name|meta
operator|->
name|arch
argument_list|)
expr_stmt|;
name|vollen
operator|=
name|term_strlen
argument_list|(
name|p
argument_list|,
name|volume
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|meta
operator|->
name|msec
condition|)
name|title
operator|=
name|mandoc_strdup
argument_list|(
name|meta
operator|->
name|title
argument_list|)
expr_stmt|;
else|else
name|mandoc_asprintf
argument_list|(
operator|&
name|title
argument_list|,
literal|"%s(%s)"
argument_list|,
name|meta
operator|->
name|title
argument_list|,
name|meta
operator|->
name|msec
argument_list|)
expr_stmt|;
name|titlen
operator|=
name|term_strlen
argument_list|(
name|p
argument_list|,
name|title
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOBREAK
operator||
name|TERMP_NOSPACE
expr_stmt|;
name|p
operator|->
name|trailspace
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|tcol
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|tcol
operator|->
name|rmargin
operator|=
literal|2
operator|*
operator|(
name|titlen
operator|+
literal|1
operator|)
operator|+
name|vollen
operator|<
name|p
operator|->
name|maxrmargin
condition|?
operator|(
name|p
operator|->
name|maxrmargin
operator|-
name|vollen
operator|+
name|term_len
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
operator|)
operator|/
literal|2
else|:
name|vollen
operator|<
name|p
operator|->
name|maxrmargin
condition|?
name|p
operator|->
name|maxrmargin
operator|-
name|vollen
else|:
literal|0
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
name|title
argument_list|)
expr_stmt|;
name|term_flushln
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|p
operator|->
name|tcol
operator|->
name|offset
operator|=
name|p
operator|->
name|tcol
operator|->
name|rmargin
expr_stmt|;
name|p
operator|->
name|tcol
operator|->
name|rmargin
operator|=
name|p
operator|->
name|tcol
operator|->
name|offset
operator|+
name|vollen
operator|+
name|titlen
operator|<
name|p
operator|->
name|maxrmargin
condition|?
name|p
operator|->
name|maxrmargin
operator|-
name|titlen
else|:
name|p
operator|->
name|maxrmargin
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
name|volume
argument_list|)
expr_stmt|;
name|term_flushln
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator|&=
operator|~
name|TERMP_NOBREAK
expr_stmt|;
name|p
operator|->
name|trailspace
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|tcol
operator|->
name|rmargin
operator|+
name|titlen
operator|<=
name|p
operator|->
name|maxrmargin
condition|)
block|{
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|p
operator|->
name|tcol
operator|->
name|offset
operator|=
name|p
operator|->
name|tcol
operator|->
name|rmargin
expr_stmt|;
name|p
operator|->
name|tcol
operator|->
name|rmargin
operator|=
name|p
operator|->
name|maxrmargin
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
name|title
argument_list|)
expr_stmt|;
name|term_flushln
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|flags
operator|&=
operator|~
name|TERMP_NOSPACE
expr_stmt|;
name|p
operator|->
name|tcol
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|tcol
operator|->
name|rmargin
operator|=
name|p
operator|->
name|maxrmargin
expr_stmt|;
name|free
argument_list|(
name|title
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|volume
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|a2width
parameter_list|(
specifier|const
name|struct
name|termp
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|v
parameter_list|)
block|{
name|struct
name|roffsu
name|su
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
decl_stmt|;
name|end
operator|=
name|a2roffsu
argument_list|(
name|v
argument_list|,
operator|&
name|su
argument_list|,
name|SCALE_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|==
name|NULL
operator|||
operator|*
name|end
operator|!=
literal|'\0'
condition|)
block|{
name|SCALE_HS_INIT
argument_list|(
operator|&
name|su
argument_list|,
name|term_strlen
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|su
operator|.
name|scale
operator|/=
name|term_strlen
argument_list|(
name|p
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
block|}
return|return
name|term_hen
argument_list|(
name|p
argument_list|,
operator|&
name|su
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine how much space to print out before block elements of `It'  * (and thus `Bl') and `Bd'.  And then go ahead and print that space,  * too.  */
end_comment

begin_function
specifier|static
name|void
name|print_bvspace
parameter_list|(
name|struct
name|termp
modifier|*
name|p
parameter_list|,
specifier|const
name|struct
name|roff_node
modifier|*
name|bl
parameter_list|,
specifier|const
name|struct
name|roff_node
modifier|*
name|n
parameter_list|)
block|{
specifier|const
name|struct
name|roff_node
modifier|*
name|nn
decl_stmt|;
name|assert
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|term_newln
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|MDOC_Bd
operator|==
name|bl
operator|->
name|tok
operator|&&
name|bl
operator|->
name|norm
operator|->
name|Bd
operator|.
name|comp
condition|)
return|return;
if|if
condition|(
name|MDOC_Bl
operator|==
name|bl
operator|->
name|tok
operator|&&
name|bl
operator|->
name|norm
operator|->
name|Bl
operator|.
name|comp
condition|)
return|return;
comment|/* Do not vspace directly after Ss/Sh. */
name|nn
operator|=
name|n
expr_stmt|;
while|while
condition|(
name|nn
operator|->
name|prev
operator|!=
name|NULL
operator|&&
name|nn
operator|->
name|prev
operator|->
name|flags
operator|&
name|NODE_NOPRT
condition|)
name|nn
operator|=
name|nn
operator|->
name|prev
expr_stmt|;
while|while
condition|(
name|nn
operator|->
name|prev
operator|==
name|NULL
condition|)
block|{
do|do
block|{
name|nn
operator|=
name|nn
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|nn
operator|->
name|type
operator|==
name|ROFFT_ROOT
condition|)
return|return;
block|}
do|while
condition|(
name|nn
operator|->
name|type
operator|!=
name|ROFFT_BLOCK
condition|)
do|;
if|if
condition|(
name|nn
operator|->
name|tok
operator|==
name|MDOC_Sh
operator|||
name|nn
operator|->
name|tok
operator|==
name|MDOC_Ss
condition|)
return|return;
if|if
condition|(
name|nn
operator|->
name|tok
operator|==
name|MDOC_It
operator|&&
name|nn
operator|->
name|parent
operator|->
name|parent
operator|->
name|norm
operator|->
name|Bl
operator|.
name|type
operator|!=
name|LIST_item
condition|)
break|break;
block|}
comment|/* A `-column' does not assert vspace within the list. */
if|if
condition|(
name|MDOC_Bl
operator|==
name|bl
operator|->
name|tok
operator|&&
name|LIST_column
operator|==
name|bl
operator|->
name|norm
operator|->
name|Bl
operator|.
name|type
condition|)
if|if
condition|(
name|n
operator|->
name|prev
operator|&&
name|MDOC_It
operator|==
name|n
operator|->
name|prev
operator|->
name|tok
condition|)
return|return;
comment|/* A `-diag' without body does not vspace. */
if|if
condition|(
name|MDOC_Bl
operator|==
name|bl
operator|->
name|tok
operator|&&
name|LIST_diag
operator|==
name|bl
operator|->
name|norm
operator|->
name|Bl
operator|.
name|type
condition|)
if|if
condition|(
name|n
operator|->
name|prev
operator|&&
name|MDOC_It
operator|==
name|n
operator|->
name|prev
operator|->
name|tok
condition|)
block|{
name|assert
argument_list|(
name|n
operator|->
name|prev
operator|->
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|prev
operator|->
name|body
operator|->
name|child
condition|)
return|return;
block|}
name|term_vspace
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_it_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|struct
name|roffsu
name|su
decl_stmt|;
name|char
name|buf
index|[
literal|24
index|]
decl_stmt|;
specifier|const
name|struct
name|roff_node
modifier|*
name|bl
decl_stmt|,
modifier|*
name|nn
decl_stmt|;
name|size_t
name|ncols
decl_stmt|,
name|dcol
decl_stmt|;
name|int
name|i
decl_stmt|,
name|offset
decl_stmt|,
name|width
decl_stmt|;
name|enum
name|mdoc_list
name|type
decl_stmt|;
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_BLOCK
condition|)
block|{
name|print_bvspace
argument_list|(
name|p
argument_list|,
name|n
operator|->
name|parent
operator|->
name|parent
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|bl
operator|=
name|n
operator|->
name|parent
operator|->
name|parent
operator|->
name|parent
expr_stmt|;
name|type
operator|=
name|bl
operator|->
name|norm
operator|->
name|Bl
operator|.
name|type
expr_stmt|;
comment|/* 	 * Defaults for specific list types. 	 */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|LIST_bullet
case|:
case|case
name|LIST_dash
case|:
case|case
name|LIST_hyphen
case|:
case|case
name|LIST_enum
case|:
name|width
operator|=
name|term_len
argument_list|(
name|p
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIST_hang
case|:
case|case
name|LIST_tag
case|:
name|width
operator|=
name|term_len
argument_list|(
name|p
argument_list|,
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIST_column
case|:
name|width
operator|=
name|term_len
argument_list|(
name|p
argument_list|,
literal|10
argument_list|)
expr_stmt|;
break|break;
default|default:
name|width
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* 	 * First calculate width and offset.  This is pretty easy unless 	 * we're a -column list, in which case all prior columns must 	 * be accounted for. 	 */
if|if
condition|(
name|bl
operator|->
name|norm
operator|->
name|Bl
operator|.
name|offs
operator|!=
name|NULL
condition|)
block|{
name|offset
operator|=
name|a2width
argument_list|(
name|p
argument_list|,
name|bl
operator|->
name|norm
operator|->
name|Bl
operator|.
name|offs
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
operator|&&
call|(
name|size_t
call|)
argument_list|(
operator|-
name|offset
argument_list|)
operator|>
name|p
operator|->
name|tcol
operator|->
name|offset
condition|)
name|offset
operator|=
operator|-
name|p
operator|->
name|tcol
operator|->
name|offset
expr_stmt|;
elseif|else
if|if
condition|(
name|offset
operator|>
name|SHRT_MAX
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|LIST_column
case|:
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_HEAD
condition|)
break|break;
comment|/* 		 * Imitate groff's column handling: 		 * - For each earlier column, add its width. 		 * - For less than 5 columns, add four more blanks per 		 *   column. 		 * - For exactly 5 columns, add three more blank per 		 *   column. 		 * - For more than 5 columns, add only one column. 		 */
name|ncols
operator|=
name|bl
operator|->
name|norm
operator|->
name|Bl
operator|.
name|ncols
expr_stmt|;
name|dcol
operator|=
name|ncols
operator|<
literal|5
condition|?
name|term_len
argument_list|(
name|p
argument_list|,
literal|4
argument_list|)
else|:
name|ncols
operator|==
literal|5
condition|?
name|term_len
argument_list|(
name|p
argument_list|,
literal|3
argument_list|)
else|:
name|term_len
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * Calculate the offset by applying all prior ROFFT_BODY, 		 * so we stop at the ROFFT_HEAD (nn->prev == NULL). 		 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|nn
operator|=
name|n
operator|->
name|prev
init|;
name|nn
operator|->
name|prev
operator|&&
name|i
operator|<
operator|(
name|int
operator|)
name|ncols
condition|;
name|nn
operator|=
name|nn
operator|->
name|prev
operator|,
name|i
operator|++
control|)
block|{
name|SCALE_HS_INIT
argument_list|(
operator|&
name|su
argument_list|,
name|term_strlen
argument_list|(
name|p
argument_list|,
name|bl
operator|->
name|norm
operator|->
name|Bl
operator|.
name|cols
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|su
operator|.
name|scale
operator|/=
name|term_strlen
argument_list|(
name|p
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|term_hen
argument_list|(
name|p
argument_list|,
operator|&
name|su
argument_list|)
operator|+
name|dcol
expr_stmt|;
block|}
comment|/* 		 * When exceeding the declared number of columns, leave 		 * the remaining widths at 0.  This will later be 		 * adjusted to the default width of 10, or, for the last 		 * column, stretched to the right margin. 		 */
if|if
condition|(
name|i
operator|>=
operator|(
name|int
operator|)
name|ncols
condition|)
break|break;
comment|/* 		 * Use the declared column widths, extended as explained 		 * in the preceding paragraph. 		 */
name|SCALE_HS_INIT
argument_list|(
operator|&
name|su
argument_list|,
name|term_strlen
argument_list|(
name|p
argument_list|,
name|bl
operator|->
name|norm
operator|->
name|Bl
operator|.
name|cols
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|su
operator|.
name|scale
operator|/=
name|term_strlen
argument_list|(
name|p
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
name|width
operator|=
name|term_hen
argument_list|(
name|p
argument_list|,
operator|&
name|su
argument_list|)
operator|+
name|dcol
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|NULL
operator|==
name|bl
operator|->
name|norm
operator|->
name|Bl
operator|.
name|width
condition|)
break|break;
comment|/* 		 * Note: buffer the width by 2, which is groff's magic 		 * number for buffering single arguments.  See the above 		 * handling for column for how this changes. 		 */
name|width
operator|=
name|a2width
argument_list|(
name|p
argument_list|,
name|bl
operator|->
name|norm
operator|->
name|Bl
operator|.
name|width
argument_list|)
operator|+
name|term_len
argument_list|(
name|p
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|<
literal|0
operator|&&
call|(
name|size_t
call|)
argument_list|(
operator|-
name|width
argument_list|)
operator|>
name|p
operator|->
name|tcol
operator|->
name|offset
condition|)
name|width
operator|=
operator|-
name|p
operator|->
name|tcol
operator|->
name|offset
expr_stmt|;
elseif|else
if|if
condition|(
name|width
operator|>
name|SHRT_MAX
condition|)
name|width
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* 	 * Whitespace control.  Inset bodies need an initial space, 	 * while diagonal bodies need two. 	 */
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|LIST_diag
case|:
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_BODY
condition|)
name|term_word
argument_list|(
name|p
argument_list|,
literal|"\\ \\ "
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIST_inset
case|:
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_BODY
operator|&&
name|n
operator|->
name|parent
operator|->
name|head
operator|->
name|child
operator|!=
name|NULL
condition|)
name|term_word
argument_list|(
name|p
argument_list|,
literal|"\\ "
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|LIST_diag
case|:
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_HEAD
condition|)
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_BOLD
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* 	 * Pad and break control.  This is the tricky part.  These flags 	 * are documented in term_flushln() in term.c.  Note that we're 	 * going to unset all of these flags in termp_it_post() when we 	 * exit. 	 */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|LIST_enum
case|:
case|case
name|LIST_bullet
case|:
case|case
name|LIST_dash
case|:
case|case
name|LIST_hyphen
case|:
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_HEAD
condition|)
block|{
name|p
operator|->
name|flags
operator||=
name|TERMP_NOBREAK
operator||
name|TERMP_HANG
expr_stmt|;
name|p
operator|->
name|trailspace
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|width
operator|<=
operator|(
name|int
operator|)
name|term_len
argument_list|(
name|p
argument_list|,
literal|2
argument_list|)
condition|)
name|p
operator|->
name|flags
operator||=
name|TERMP_NOPAD
expr_stmt|;
break|break;
case|case
name|LIST_hang
case|:
if|if
condition|(
name|n
operator|->
name|type
operator|!=
name|ROFFT_HEAD
condition|)
break|break;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOBREAK
operator||
name|TERMP_BRIND
operator||
name|TERMP_HANG
expr_stmt|;
name|p
operator|->
name|trailspace
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|LIST_tag
case|:
if|if
condition|(
name|n
operator|->
name|type
operator|!=
name|ROFFT_HEAD
condition|)
break|break;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOBREAK
operator||
name|TERMP_BRTRSP
operator||
name|TERMP_BRIND
expr_stmt|;
name|p
operator|->
name|trailspace
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|next
operator|||
name|NULL
operator|==
name|n
operator|->
name|next
operator|->
name|child
condition|)
name|p
operator|->
name|flags
operator||=
name|TERMP_HANG
expr_stmt|;
break|break;
case|case
name|LIST_column
case|:
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_HEAD
condition|)
break|break;
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|next
condition|)
block|{
name|p
operator|->
name|flags
operator|&=
operator|~
name|TERMP_NOBREAK
expr_stmt|;
name|p
operator|->
name|trailspace
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|flags
operator||=
name|TERMP_NOBREAK
expr_stmt|;
name|p
operator|->
name|trailspace
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|LIST_diag
case|:
if|if
condition|(
name|n
operator|->
name|type
operator|!=
name|ROFFT_HEAD
condition|)
break|break;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOBREAK
operator||
name|TERMP_BRIND
expr_stmt|;
name|p
operator|->
name|trailspace
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* 	 * Margin control.  Set-head-width lists have their right 	 * margins shortened.  The body for these lists has the offset 	 * necessarily lengthened.  Everybody gets the offset. 	 */
name|p
operator|->
name|tcol
operator|->
name|offset
operator|+=
name|offset
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|LIST_bullet
case|:
case|case
name|LIST_dash
case|:
case|case
name|LIST_enum
case|:
case|case
name|LIST_hyphen
case|:
case|case
name|LIST_hang
case|:
case|case
name|LIST_tag
case|:
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_HEAD
condition|)
name|p
operator|->
name|tcol
operator|->
name|rmargin
operator|=
name|p
operator|->
name|tcol
operator|->
name|offset
operator|+
name|width
expr_stmt|;
else|else
name|p
operator|->
name|tcol
operator|->
name|offset
operator|+=
name|width
expr_stmt|;
break|break;
case|case
name|LIST_column
case|:
name|assert
argument_list|(
name|width
argument_list|)
expr_stmt|;
name|p
operator|->
name|tcol
operator|->
name|rmargin
operator|=
name|p
operator|->
name|tcol
operator|->
name|offset
operator|+
name|width
expr_stmt|;
comment|/* 		 * XXX - this behaviour is not documented: the 		 * right-most column is filled to the right margin. 		 */
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_HEAD
condition|)
break|break;
if|if
condition|(
name|n
operator|->
name|next
operator|==
name|NULL
operator|&&
name|p
operator|->
name|tcol
operator|->
name|rmargin
operator|<
name|p
operator|->
name|maxrmargin
condition|)
name|p
operator|->
name|tcol
operator|->
name|rmargin
operator|=
name|p
operator|->
name|maxrmargin
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* 	 * The dash, hyphen, bullet and enum lists all have a special 	 * HEAD character (temporarily bold, in some cases). 	 */
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_HEAD
condition|)
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|LIST_bullet
case|:
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_BOLD
argument_list|)
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|"\\[bu]"
argument_list|)
expr_stmt|;
name|term_fontpop
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIST_dash
case|:
case|case
name|LIST_hyphen
case|:
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_BOLD
argument_list|)
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|term_fontpop
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIST_enum
case|:
operator|(
name|pair
operator|->
name|ppair
operator|->
name|ppair
operator|->
name|count
operator|)
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%d."
argument_list|,
name|pair
operator|->
name|ppair
operator|->
name|ppair
operator|->
name|count
argument_list|)
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* 	 * If we're not going to process our children, indicate so here. 	 */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|LIST_bullet
case|:
case|case
name|LIST_item
case|:
case|case
name|LIST_dash
case|:
case|case
name|LIST_hyphen
case|:
case|case
name|LIST_enum
case|:
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_HEAD
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|LIST_column
case|:
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_HEAD
condition|)
return|return
literal|0
return|;
name|p
operator|->
name|minbl
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|termp_it_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|enum
name|mdoc_list
name|type
decl_stmt|;
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_BLOCK
condition|)
return|return;
name|type
operator|=
name|n
operator|->
name|parent
operator|->
name|parent
operator|->
name|parent
operator|->
name|norm
operator|->
name|Bl
operator|.
name|type
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|LIST_item
case|:
case|case
name|LIST_diag
case|:
case|case
name|LIST_inset
case|:
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_BODY
condition|)
name|term_newln
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|LIST_column
case|:
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_BODY
condition|)
name|term_flushln
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
default|default:
name|term_newln
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * Now that our output is flushed, we can reset our tags.  Since 	 * only `It' sets these flags, we're free to assume that nobody 	 * has munged them in the meanwhile. 	 */
name|p
operator|->
name|flags
operator|&=
operator|~
operator|(
name|TERMP_NOBREAK
operator||
name|TERMP_BRTRSP
operator||
name|TERMP_BRIND
operator||
name|TERMP_HANG
operator|)
expr_stmt|;
name|p
operator|->
name|trailspace
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_nm_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_BLOCK
condition|)
block|{
name|p
operator|->
name|flags
operator||=
name|TERMP_PREKEEP
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_BODY
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|child
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|cp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|prev
operator|->
name|child
operator|!=
name|NULL
condition|)
name|cp
operator|=
name|n
operator|->
name|prev
operator|->
name|child
operator|->
name|string
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|cp
operator|=
name|meta
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|p
operator|->
name|tcol
operator|->
name|offset
operator|+=
name|term_len
argument_list|(
name|p
argument_list|,
literal|6
argument_list|)
expr_stmt|;
else|else
name|p
operator|->
name|tcol
operator|->
name|offset
operator|+=
name|term_len
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
operator|+
name|term_strlen
argument_list|(
name|p
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|n
operator|->
name|child
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_HEAD
condition|)
name|synopsis_pre
argument_list|(
name|p
argument_list|,
name|n
operator|->
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_HEAD
operator|&&
name|n
operator|->
name|next
operator|!=
name|NULL
operator|&&
name|n
operator|->
name|next
operator|->
name|child
operator|!=
name|NULL
condition|)
block|{
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
operator||
name|TERMP_NOBREAK
operator||
name|TERMP_BRIND
expr_stmt|;
name|p
operator|->
name|trailspace
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|tcol
operator|->
name|rmargin
operator|=
name|p
operator|->
name|tcol
operator|->
name|offset
operator|+
name|term_len
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|child
operator|==
name|NULL
condition|)
name|p
operator|->
name|tcol
operator|->
name|rmargin
operator|+=
name|term_strlen
argument_list|(
name|p
argument_list|,
name|meta
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|->
name|child
operator|->
name|type
operator|==
name|ROFFT_TEXT
condition|)
block|{
name|p
operator|->
name|tcol
operator|->
name|rmargin
operator|+=
name|term_strlen
argument_list|(
name|p
argument_list|,
name|n
operator|->
name|child
operator|->
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|child
operator|->
name|next
operator|!=
name|NULL
condition|)
name|p
operator|->
name|flags
operator||=
name|TERMP_HANG
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|tcol
operator|->
name|rmargin
operator|+=
name|term_len
argument_list|(
name|p
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_HANG
expr_stmt|;
block|}
block|}
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_BOLD
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|termp_nm_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_BLOCK
condition|)
block|{
name|p
operator|->
name|flags
operator|&=
operator|~
operator|(
name|TERMP_KEEP
operator||
name|TERMP_PREKEEP
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_HEAD
operator|&&
name|NULL
operator|!=
name|n
operator|->
name|next
operator|&&
name|NULL
operator|!=
name|n
operator|->
name|next
operator|->
name|child
condition|)
block|{
name|term_flushln
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator|&=
operator|~
operator|(
name|TERMP_NOBREAK
operator||
name|TERMP_BRIND
operator||
name|TERMP_HANG
operator|)
expr_stmt|;
name|p
operator|->
name|trailspace
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_BODY
operator|&&
name|n
operator|->
name|child
operator|!=
name|NULL
condition|)
name|term_flushln
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_fl_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|termp_tag_pre
argument_list|(
name|p
argument_list|,
name|pair
argument_list|,
name|meta
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_BOLD
argument_list|)
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|"\\-"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|n
operator|->
name|child
operator|==
name|NULL
operator|&&
operator|(
name|n
operator|->
name|next
operator|==
name|NULL
operator|||
name|n
operator|->
name|next
operator|->
name|type
operator|==
name|ROFFT_TEXT
operator|||
name|n
operator|->
name|next
operator|->
name|flags
operator|&
name|NODE_LINE
operator|)
operator|)
condition|)
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp__a_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|n
operator|->
name|prev
operator|&&
name|MDOC__A
operator|==
name|n
operator|->
name|prev
operator|->
name|tok
condition|)
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|next
operator|||
name|MDOC__A
operator|!=
name|n
operator|->
name|next
operator|->
name|tok
condition|)
name|term_word
argument_list|(
name|p
argument_list|,
literal|"and"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_an_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|n
operator|->
name|norm
operator|->
name|An
operator|.
name|auth
operator|==
name|AUTH_split
condition|)
block|{
name|p
operator|->
name|flags
operator|&=
operator|~
name|TERMP_NOSPLIT
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_SPLIT
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|n
operator|->
name|norm
operator|->
name|An
operator|.
name|auth
operator|==
name|AUTH_nosplit
condition|)
block|{
name|p
operator|->
name|flags
operator|&=
operator|~
name|TERMP_SPLIT
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPLIT
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|p
operator|->
name|flags
operator|&
name|TERMP_SPLIT
condition|)
name|term_newln
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|sec
operator|==
name|SEC_AUTHORS
operator|&&
operator|!
operator|(
name|p
operator|->
name|flags
operator|&
name|TERMP_NOSPLIT
operator|)
condition|)
name|p
operator|->
name|flags
operator||=
name|TERMP_SPLIT
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_ns_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|NODE_LINE
operator|&
name|n
operator|->
name|flags
operator|)
condition|)
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_rs_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|SEC_SEE_ALSO
operator|!=
name|n
operator|->
name|sec
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_BLOCK
operator|&&
name|n
operator|->
name|prev
operator|!=
name|NULL
condition|)
name|term_vspace
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_ex_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|term_newln
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_nd_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_BODY
condition|)
name|term_word
argument_list|(
name|p
argument_list|,
literal|"\\(en"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_bl_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
return|return
name|n
operator|->
name|type
operator|!=
name|ROFFT_HEAD
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|termp_bl_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|n
operator|->
name|type
operator|!=
name|ROFFT_BLOCK
condition|)
return|return;
name|term_newln
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|tok
operator|!=
name|MDOC_Bl
operator|||
name|n
operator|->
name|norm
operator|->
name|Bl
operator|.
name|type
operator|!=
name|LIST_column
condition|)
return|return;
name|term_tab_set
argument_list|(
name|p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|term_tab_set
argument_list|(
name|p
argument_list|,
literal|"T"
argument_list|)
expr_stmt|;
name|term_tab_set
argument_list|(
name|p
argument_list|,
literal|".5i"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_xr_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|NULL
operator|==
operator|(
name|n
operator|=
name|n
operator|->
name|child
operator|)
condition|)
return|return
literal|0
return|;
name|assert
argument_list|(
name|n
operator|->
name|type
operator|==
name|ROFFT_TEXT
argument_list|)
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
name|n
operator|->
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|n
operator|=
name|n
operator|->
name|next
operator|)
condition|)
return|return
literal|0
return|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|assert
argument_list|(
name|n
operator|->
name|type
operator|==
name|ROFFT_TEXT
argument_list|)
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
name|n
operator|->
name|string
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * This decides how to assert whitespace before any of the SYNOPSIS set  * of macros (which, as in the case of Ft/Fo and Ft/Fn, may contain  * macro combos).  */
end_comment

begin_function
specifier|static
name|void
name|synopsis_pre
parameter_list|(
name|struct
name|termp
modifier|*
name|p
parameter_list|,
specifier|const
name|struct
name|roff_node
modifier|*
name|n
parameter_list|)
block|{
comment|/* 	 * Obviously, if we're not in a SYNOPSIS or no prior macros 	 * exist, do nothing. 	 */
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|prev
operator|||
operator|!
operator|(
name|NODE_SYNPRETTY
operator|&
name|n
operator|->
name|flags
operator|)
condition|)
return|return;
comment|/* 	 * If we're the second in a pair of like elements, emit our 	 * newline and return.  UNLESS we're `Fo', `Fn', `Fn', in which 	 * case we soldier on. 	 */
if|if
condition|(
name|n
operator|->
name|prev
operator|->
name|tok
operator|==
name|n
operator|->
name|tok
operator|&&
name|MDOC_Ft
operator|!=
name|n
operator|->
name|tok
operator|&&
name|MDOC_Fo
operator|!=
name|n
operator|->
name|tok
operator|&&
name|MDOC_Fn
operator|!=
name|n
operator|->
name|tok
condition|)
block|{
name|term_newln
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If we're one of the SYNOPSIS set and non-like pair-wise after 	 * another (or Fn/Fo, which we've let slip through) then assert 	 * vertical space, else only newline and move on. 	 */
switch|switch
condition|(
name|n
operator|->
name|prev
operator|->
name|tok
condition|)
block|{
case|case
name|MDOC_Fd
case|:
case|case
name|MDOC_Fn
case|:
case|case
name|MDOC_Fo
case|:
case|case
name|MDOC_In
case|:
case|case
name|MDOC_Vt
case|:
name|term_vspace
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDOC_Ft
case|:
if|if
condition|(
name|MDOC_Fn
operator|!=
name|n
operator|->
name|tok
operator|&&
name|MDOC_Fo
operator|!=
name|n
operator|->
name|tok
condition|)
block|{
name|term_vspace
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
default|default:
name|term_newln
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|termp_vt_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_ELEM
condition|)
block|{
name|synopsis_pre
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|termp_under_pre
argument_list|(
name|p
argument_list|,
name|pair
argument_list|,
name|meta
argument_list|,
name|n
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_BLOCK
condition|)
block|{
name|synopsis_pre
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_HEAD
condition|)
return|return
literal|0
return|;
return|return
name|termp_under_pre
argument_list|(
name|p
argument_list|,
name|pair
argument_list|,
name|meta
argument_list|,
name|n
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_bold_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|termp_tag_pre
argument_list|(
name|p
argument_list|,
name|pair
argument_list|,
name|meta
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_BOLD
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_fd_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|synopsis_pre
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|termp_bold_pre
argument_list|(
name|p
argument_list|,
name|pair
argument_list|,
name|meta
argument_list|,
name|n
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|termp_fd_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|term_newln
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_sh_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
case|case
name|ROFFT_BLOCK
case|:
comment|/* 		 * Vertical space before sections, except 		 * when the previous section was empty. 		 */
if|if
condition|(
name|n
operator|->
name|prev
operator|==
name|NULL
operator|||
name|n
operator|->
name|prev
operator|->
name|tok
operator|!=
name|MDOC_Sh
operator|||
operator|(
name|n
operator|->
name|prev
operator|->
name|body
operator|!=
name|NULL
operator|&&
name|n
operator|->
name|prev
operator|->
name|body
operator|->
name|child
operator|!=
name|NULL
operator|)
condition|)
name|term_vspace
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|ROFFT_HEAD
case|:
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_BOLD
argument_list|)
expr_stmt|;
break|break;
case|case
name|ROFFT_BODY
case|:
name|p
operator|->
name|tcol
operator|->
name|offset
operator|=
name|term_len
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|defindent
argument_list|)
expr_stmt|;
name|term_tab_set
argument_list|(
name|p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|term_tab_set
argument_list|(
name|p
argument_list|,
literal|"T"
argument_list|)
expr_stmt|;
name|term_tab_set
argument_list|(
name|p
argument_list|,
literal|".5i"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|n
operator|->
name|sec
condition|)
block|{
case|case
name|SEC_DESCRIPTION
case|:
name|fn_prio
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SEC_AUTHORS
case|:
name|p
operator|->
name|flags
operator|&=
operator|~
operator|(
name|TERMP_SPLIT
operator||
name|TERMP_NOSPLIT
operator|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
default|default:
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|termp_sh_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
case|case
name|ROFFT_HEAD
case|:
name|term_newln
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|ROFFT_BODY
case|:
name|term_newln
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|tcol
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|termp_lb_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|SEC_LIBRARY
operator|==
name|n
operator|->
name|sec
operator|&&
name|NODE_LINE
operator|&
name|n
operator|->
name|flags
condition|)
name|term_newln
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_d1_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|n
operator|->
name|type
operator|!=
name|ROFFT_BLOCK
condition|)
return|return
literal|1
return|;
name|term_newln
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|tcol
operator|->
name|offset
operator|+=
name|term_len
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|defindent
operator|+
literal|1
argument_list|)
expr_stmt|;
name|term_tab_set
argument_list|(
name|p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|term_tab_set
argument_list|(
name|p
argument_list|,
literal|"T"
argument_list|)
expr_stmt|;
name|term_tab_set
argument_list|(
name|p
argument_list|,
literal|".5i"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_ft_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
comment|/* NB: NODE_LINE does not effect this! */
name|synopsis_pre
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_UNDER
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_fn_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|size_t
name|rmargin
init|=
literal|0
decl_stmt|;
name|int
name|pretty
decl_stmt|;
name|pretty
operator|=
name|NODE_SYNPRETTY
operator|&
name|n
operator|->
name|flags
expr_stmt|;
name|synopsis_pre
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|n
operator|=
name|n
operator|->
name|child
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|pretty
condition|)
block|{
name|rmargin
operator|=
name|p
operator|->
name|tcol
operator|->
name|rmargin
expr_stmt|;
name|p
operator|->
name|tcol
operator|->
name|rmargin
operator|=
name|p
operator|->
name|tcol
operator|->
name|offset
operator|+
name|term_len
argument_list|(
name|p
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOBREAK
operator||
name|TERMP_BRIND
operator||
name|TERMP_HANG
expr_stmt|;
block|}
name|assert
argument_list|(
name|n
operator|->
name|type
operator|==
name|ROFFT_TEXT
argument_list|)
expr_stmt|;
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_BOLD
argument_list|)
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
name|n
operator|->
name|string
argument_list|)
expr_stmt|;
name|term_fontpop
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|sec
operator|==
name|SEC_DESCRIPTION
operator|||
name|n
operator|->
name|sec
operator|==
name|SEC_CUSTOM
condition|)
name|tag_put
argument_list|(
name|n
operator|->
name|string
argument_list|,
operator|++
name|fn_prio
argument_list|,
name|p
operator|->
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|pretty
condition|)
block|{
name|term_flushln
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator|&=
operator|~
operator|(
name|TERMP_NOBREAK
operator||
name|TERMP_BRIND
operator||
name|TERMP_HANG
operator|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOPAD
expr_stmt|;
name|p
operator|->
name|tcol
operator|->
name|offset
operator|=
name|p
operator|->
name|tcol
operator|->
name|rmargin
expr_stmt|;
name|p
operator|->
name|tcol
operator|->
name|rmargin
operator|=
name|rmargin
expr_stmt|;
block|}
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
for|for
control|(
name|n
operator|=
name|n
operator|->
name|next
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
block|{
name|assert
argument_list|(
name|n
operator|->
name|type
operator|==
name|ROFFT_TEXT
argument_list|)
expr_stmt|;
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_UNDER
argument_list|)
expr_stmt|;
if|if
condition|(
name|pretty
condition|)
name|p
operator|->
name|flags
operator||=
name|TERMP_NBRWORD
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
name|n
operator|->
name|string
argument_list|)
expr_stmt|;
name|term_fontpop
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|next
condition|)
block|{
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
block|}
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pretty
condition|)
block|{
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
name|term_flushln
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_fa_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
specifier|const
name|struct
name|roff_node
modifier|*
name|nn
decl_stmt|;
if|if
condition|(
name|n
operator|->
name|parent
operator|->
name|tok
operator|!=
name|MDOC_Fo
condition|)
block|{
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_UNDER
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
for|for
control|(
name|nn
operator|=
name|n
operator|->
name|child
init|;
name|nn
condition|;
name|nn
operator|=
name|nn
operator|->
name|next
control|)
block|{
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_UNDER
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NBRWORD
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
name|nn
operator|->
name|string
argument_list|)
expr_stmt|;
name|term_fontpop
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|nn
operator|->
name|next
operator|||
operator|(
name|n
operator|->
name|next
operator|&&
name|n
operator|->
name|next
operator|->
name|tok
operator|==
name|MDOC_Fa
operator|)
condition|)
block|{
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_bd_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|size_t
name|lm
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|roff_node
modifier|*
name|nn
decl_stmt|;
name|int
name|offset
decl_stmt|;
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_BLOCK
condition|)
block|{
name|print_bvspace
argument_list|(
name|p
argument_list|,
name|n
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_HEAD
condition|)
return|return
literal|0
return|;
comment|/* Handle the -offset argument. */
if|if
condition|(
name|n
operator|->
name|norm
operator|->
name|Bd
operator|.
name|offs
operator|==
name|NULL
operator|||
operator|!
name|strcmp
argument_list|(
name|n
operator|->
name|norm
operator|->
name|Bd
operator|.
name|offs
argument_list|,
literal|"left"
argument_list|)
condition|)
comment|/* nothing */
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|n
operator|->
name|norm
operator|->
name|Bd
operator|.
name|offs
argument_list|,
literal|"indent"
argument_list|)
condition|)
name|p
operator|->
name|tcol
operator|->
name|offset
operator|+=
name|term_len
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|defindent
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|n
operator|->
name|norm
operator|->
name|Bd
operator|.
name|offs
argument_list|,
literal|"indent-two"
argument_list|)
condition|)
name|p
operator|->
name|tcol
operator|->
name|offset
operator|+=
name|term_len
argument_list|(
name|p
argument_list|,
operator|(
name|p
operator|->
name|defindent
operator|+
literal|1
operator|)
operator|*
literal|2
argument_list|)
expr_stmt|;
else|else
block|{
name|offset
operator|=
name|a2width
argument_list|(
name|p
argument_list|,
name|n
operator|->
name|norm
operator|->
name|Bd
operator|.
name|offs
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
operator|&&
call|(
name|size_t
call|)
argument_list|(
operator|-
name|offset
argument_list|)
operator|>
name|p
operator|->
name|tcol
operator|->
name|offset
condition|)
name|p
operator|->
name|tcol
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|offset
operator|<
name|SHRT_MAX
condition|)
name|p
operator|->
name|tcol
operator|->
name|offset
operator|+=
name|offset
expr_stmt|;
block|}
comment|/* 	 * If -ragged or -filled are specified, the block does nothing 	 * but change the indentation.  If -unfilled or -literal are 	 * specified, text is printed exactly as entered in the display: 	 * for macro lines, a newline is appended to the line.  Blank 	 * lines are allowed. 	 */
if|if
condition|(
name|n
operator|->
name|norm
operator|->
name|Bd
operator|.
name|type
operator|!=
name|DISP_literal
operator|&&
name|n
operator|->
name|norm
operator|->
name|Bd
operator|.
name|type
operator|!=
name|DISP_unfilled
operator|&&
name|n
operator|->
name|norm
operator|->
name|Bd
operator|.
name|type
operator|!=
name|DISP_centered
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|n
operator|->
name|norm
operator|->
name|Bd
operator|.
name|type
operator|==
name|DISP_literal
condition|)
block|{
name|term_tab_set
argument_list|(
name|p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|term_tab_set
argument_list|(
name|p
argument_list|,
literal|"T"
argument_list|)
expr_stmt|;
name|term_tab_set
argument_list|(
name|p
argument_list|,
literal|"8n"
argument_list|)
expr_stmt|;
block|}
name|lm
operator|=
name|p
operator|->
name|tcol
operator|->
name|offset
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_BRNEVER
expr_stmt|;
for|for
control|(
name|nn
operator|=
name|n
operator|->
name|child
init|;
name|nn
operator|!=
name|NULL
condition|;
name|nn
operator|=
name|nn
operator|->
name|next
control|)
block|{
if|if
condition|(
name|n
operator|->
name|norm
operator|->
name|Bd
operator|.
name|type
operator|==
name|DISP_centered
condition|)
block|{
if|if
condition|(
name|nn
operator|->
name|type
operator|==
name|ROFFT_TEXT
condition|)
block|{
name|len
operator|=
name|term_strlen
argument_list|(
name|p
argument_list|,
name|nn
operator|->
name|string
argument_list|)
expr_stmt|;
name|p
operator|->
name|tcol
operator|->
name|offset
operator|=
name|len
operator|>=
name|p
operator|->
name|tcol
operator|->
name|rmargin
condition|?
literal|0
else|:
name|lm
operator|+
name|len
operator|>=
name|p
operator|->
name|tcol
operator|->
name|rmargin
condition|?
name|p
operator|->
name|tcol
operator|->
name|rmargin
operator|-
name|len
else|:
operator|(
name|lm
operator|+
name|p
operator|->
name|tcol
operator|->
name|rmargin
operator|-
name|len
operator|)
operator|/
literal|2
expr_stmt|;
block|}
else|else
name|p
operator|->
name|tcol
operator|->
name|offset
operator|=
name|lm
expr_stmt|;
block|}
name|print_mdoc_node
argument_list|(
name|p
argument_list|,
name|pair
argument_list|,
name|meta
argument_list|,
name|nn
argument_list|)
expr_stmt|;
comment|/* 		 * If the printed node flushes its own line, then we 		 * needn't do it here as well.  This is hacky, but the 		 * notion of selective eoln whitespace is pretty dumb 		 * anyway, so don't sweat it. 		 */
if|if
condition|(
name|nn
operator|->
name|tok
operator|<
name|ROFF_MAX
condition|)
continue|continue;
switch|switch
condition|(
name|nn
operator|->
name|tok
condition|)
block|{
case|case
name|MDOC_Sm
case|:
case|case
name|MDOC_Bl
case|:
case|case
name|MDOC_D1
case|:
case|case
name|MDOC_Dl
case|:
case|case
name|MDOC_Lp
case|:
case|case
name|MDOC_Pp
case|:
continue|continue;
default|default:
break|break;
block|}
if|if
condition|(
name|p
operator|->
name|flags
operator|&
name|TERMP_NONEWLINE
operator|||
operator|(
name|nn
operator|->
name|next
operator|&&
operator|!
operator|(
name|nn
operator|->
name|next
operator|->
name|flags
operator|&
name|NODE_LINE
operator|)
operator|)
condition|)
continue|continue;
name|term_flushln
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
block|}
name|p
operator|->
name|flags
operator|&=
operator|~
name|TERMP_BRNEVER
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|termp_bd_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|n
operator|->
name|type
operator|!=
name|ROFFT_BODY
condition|)
return|return;
if|if
condition|(
name|DISP_literal
operator|==
name|n
operator|->
name|norm
operator|->
name|Bd
operator|.
name|type
operator|||
name|DISP_unfilled
operator|==
name|n
operator|->
name|norm
operator|->
name|Bd
operator|.
name|type
condition|)
name|p
operator|->
name|flags
operator||=
name|TERMP_BRNEVER
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_newln
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator|&=
operator|~
name|TERMP_BRNEVER
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_xx_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
operator|(
name|n
operator|->
name|aux
operator|=
name|p
operator|->
name|flags
operator|&
name|TERMP_PREKEEP
operator|)
operator|==
literal|0
condition|)
name|p
operator|->
name|flags
operator||=
name|TERMP_PREKEEP
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|termp_xx_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|n
operator|->
name|aux
operator|==
literal|0
condition|)
name|p
operator|->
name|flags
operator|&=
operator|~
operator|(
name|TERMP_KEEP
operator||
name|TERMP_PREKEEP
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|termp_pf_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|n
operator|->
name|next
operator|==
name|NULL
operator|||
name|n
operator|->
name|next
operator|->
name|flags
operator|&
name|NODE_LINE
operator|)
condition|)
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_ss_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|struct
name|roff_node
modifier|*
name|nn
decl_stmt|;
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
case|case
name|ROFFT_BLOCK
case|:
name|term_newln
argument_list|(
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|nn
operator|=
name|n
operator|->
name|prev
init|;
name|nn
operator|!=
name|NULL
condition|;
name|nn
operator|=
name|nn
operator|->
name|prev
control|)
if|if
condition|(
operator|(
name|nn
operator|->
name|flags
operator|&
name|NODE_NOPRT
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|nn
operator|!=
name|NULL
condition|)
name|term_vspace
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|ROFFT_HEAD
case|:
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_BOLD
argument_list|)
expr_stmt|;
name|p
operator|->
name|tcol
operator|->
name|offset
operator|=
name|term_len
argument_list|(
name|p
argument_list|,
operator|(
name|p
operator|->
name|defindent
operator|+
literal|1
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|ROFFT_BODY
case|:
name|p
operator|->
name|tcol
operator|->
name|offset
operator|=
name|term_len
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|defindent
argument_list|)
expr_stmt|;
name|term_tab_set
argument_list|(
name|p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|term_tab_set
argument_list|(
name|p
argument_list|,
literal|"T"
argument_list|)
expr_stmt|;
name|term_tab_set
argument_list|(
name|p
argument_list|,
literal|".5i"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|termp_ss_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_HEAD
operator|||
name|n
operator|->
name|type
operator|==
name|ROFFT_BODY
condition|)
name|term_newln
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_cd_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|synopsis_pre
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_BOLD
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_in_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|synopsis_pre
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|NODE_SYNPRETTY
operator|&
name|n
operator|->
name|flags
operator|&&
name|NODE_LINE
operator|&
name|n
operator|->
name|flags
condition|)
block|{
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_BOLD
argument_list|)
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|"#include"
argument_list|)
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|term_word
argument_list|(
name|p
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_UNDER
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|termp_in_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|NODE_SYNPRETTY
operator|&
name|n
operator|->
name|flags
condition|)
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_BOLD
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NODE_SYNPRETTY
operator|&
name|n
operator|->
name|flags
condition|)
name|term_fontpop
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_pp_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|fn_prio
operator|=
literal|0
expr_stmt|;
name|term_vspace
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_skip_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_quote_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|n
operator|->
name|type
operator|!=
name|ROFFT_BODY
operator|&&
name|n
operator|->
name|type
operator|!=
name|ROFFT_ELEM
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|n
operator|->
name|tok
condition|)
block|{
case|case
name|MDOC_Ao
case|:
case|case
name|MDOC_Aq
case|:
name|term_word
argument_list|(
name|p
argument_list|,
name|n
operator|->
name|child
operator|!=
name|NULL
operator|&&
name|n
operator|->
name|child
operator|->
name|next
operator|==
name|NULL
operator|&&
name|n
operator|->
name|child
operator|->
name|tok
operator|==
name|MDOC_Mt
condition|?
literal|"<"
else|:
literal|"\\(la"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDOC_Bro
case|:
case|case
name|MDOC_Brq
case|:
name|term_word
argument_list|(
name|p
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDOC_Oo
case|:
case|case
name|MDOC_Op
case|:
case|case
name|MDOC_Bo
case|:
case|case
name|MDOC_Bq
case|:
name|term_word
argument_list|(
name|p
argument_list|,
literal|"["
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDOC__T
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_Do
case|:
case|case
name|MDOC_Dq
case|:
name|term_word
argument_list|(
name|p
argument_list|,
literal|"\\(Lq"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDOC_En
case|:
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|norm
operator|->
name|Es
operator|||
name|NULL
operator|==
name|n
operator|->
name|norm
operator|->
name|Es
operator|->
name|child
condition|)
return|return
literal|1
return|;
name|term_word
argument_list|(
name|p
argument_list|,
name|n
operator|->
name|norm
operator|->
name|Es
operator|->
name|child
operator|->
name|string
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDOC_Po
case|:
case|case
name|MDOC_Pq
case|:
name|term_word
argument_list|(
name|p
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDOC_Qo
case|:
case|case
name|MDOC_Qq
case|:
name|term_word
argument_list|(
name|p
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDOC_Ql
case|:
case|case
name|MDOC_So
case|:
case|case
name|MDOC_Sq
case|:
name|term_word
argument_list|(
name|p
argument_list|,
literal|"\\(oq"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|termp_quote_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|n
operator|->
name|type
operator|!=
name|ROFFT_BODY
operator|&&
name|n
operator|->
name|type
operator|!=
name|ROFFT_ELEM
condition|)
return|return;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
switch|switch
condition|(
name|n
operator|->
name|tok
condition|)
block|{
case|case
name|MDOC_Ao
case|:
case|case
name|MDOC_Aq
case|:
name|term_word
argument_list|(
name|p
argument_list|,
name|n
operator|->
name|child
operator|!=
name|NULL
operator|&&
name|n
operator|->
name|child
operator|->
name|next
operator|==
name|NULL
operator|&&
name|n
operator|->
name|child
operator|->
name|tok
operator|==
name|MDOC_Mt
condition|?
literal|">"
else|:
literal|"\\(ra"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDOC_Bro
case|:
case|case
name|MDOC_Brq
case|:
name|term_word
argument_list|(
name|p
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDOC_Oo
case|:
case|case
name|MDOC_Op
case|:
case|case
name|MDOC_Bo
case|:
case|case
name|MDOC_Bq
case|:
name|term_word
argument_list|(
name|p
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDOC__T
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_Do
case|:
case|case
name|MDOC_Dq
case|:
name|term_word
argument_list|(
name|p
argument_list|,
literal|"\\(Rq"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDOC_En
case|:
if|if
condition|(
name|n
operator|->
name|norm
operator|->
name|Es
operator|==
name|NULL
operator|||
name|n
operator|->
name|norm
operator|->
name|Es
operator|->
name|child
operator|==
name|NULL
operator|||
name|n
operator|->
name|norm
operator|->
name|Es
operator|->
name|child
operator|->
name|next
operator|==
name|NULL
condition|)
name|p
operator|->
name|flags
operator|&=
operator|~
name|TERMP_NOSPACE
expr_stmt|;
else|else
name|term_word
argument_list|(
name|p
argument_list|,
name|n
operator|->
name|norm
operator|->
name|Es
operator|->
name|child
operator|->
name|next
operator|->
name|string
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDOC_Po
case|:
case|case
name|MDOC_Pq
case|:
name|term_word
argument_list|(
name|p
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDOC_Qo
case|:
case|case
name|MDOC_Qq
case|:
name|term_word
argument_list|(
name|p
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDOC_Ql
case|:
case|case
name|MDOC_So
case|:
case|case
name|MDOC_Sq
case|:
name|term_word
argument_list|(
name|p
argument_list|,
literal|"\\(cq"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|termp_eo_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|n
operator|->
name|type
operator|!=
name|ROFFT_BODY
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|n
operator|->
name|end
operator|==
name|ENDBODY_NOT
operator|&&
name|n
operator|->
name|parent
operator|->
name|head
operator|->
name|child
operator|==
name|NULL
operator|&&
name|n
operator|->
name|child
operator|!=
name|NULL
operator|&&
name|n
operator|->
name|child
operator|->
name|end
operator|!=
name|ENDBODY_NOT
condition|)
name|term_word
argument_list|(
name|p
argument_list|,
literal|"\\&"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|->
name|end
operator|!=
name|ENDBODY_NOT
condition|?
name|n
operator|->
name|child
operator|!=
name|NULL
else|:
name|n
operator|->
name|parent
operator|->
name|head
operator|->
name|child
operator|!=
name|NULL
operator|&&
operator|(
name|n
operator|->
name|child
operator|!=
name|NULL
operator|||
operator|(
name|n
operator|->
name|parent
operator|->
name|tail
operator|!=
name|NULL
operator|&&
name|n
operator|->
name|parent
operator|->
name|tail
operator|->
name|child
operator|!=
name|NULL
operator|)
operator|)
condition|)
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|termp_eo_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|int
name|body
decl_stmt|,
name|tail
decl_stmt|;
if|if
condition|(
name|n
operator|->
name|type
operator|!=
name|ROFFT_BODY
condition|)
return|return;
if|if
condition|(
name|n
operator|->
name|end
operator|!=
name|ENDBODY_NOT
condition|)
block|{
name|p
operator|->
name|flags
operator|&=
operator|~
name|TERMP_NOSPACE
expr_stmt|;
return|return;
block|}
name|body
operator|=
name|n
operator|->
name|child
operator|!=
name|NULL
operator|||
name|n
operator|->
name|parent
operator|->
name|head
operator|->
name|child
operator|!=
name|NULL
expr_stmt|;
name|tail
operator|=
name|n
operator|->
name|parent
operator|->
name|tail
operator|!=
name|NULL
operator|&&
name|n
operator|->
name|parent
operator|->
name|tail
operator|->
name|child
operator|!=
name|NULL
expr_stmt|;
if|if
condition|(
name|body
operator|&&
name|tail
condition|)
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|body
operator|||
name|tail
operator|)
condition|)
name|term_word
argument_list|(
name|p
argument_list|,
literal|"\\&"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|tail
condition|)
name|p
operator|->
name|flags
operator|&=
operator|~
name|TERMP_NOSPACE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_fo_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|size_t
name|rmargin
init|=
literal|0
decl_stmt|;
name|int
name|pretty
decl_stmt|;
name|pretty
operator|=
name|NODE_SYNPRETTY
operator|&
name|n
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_BLOCK
condition|)
block|{
name|synopsis_pre
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_BODY
condition|)
block|{
if|if
condition|(
name|pretty
condition|)
block|{
name|rmargin
operator|=
name|p
operator|->
name|tcol
operator|->
name|rmargin
expr_stmt|;
name|p
operator|->
name|tcol
operator|->
name|rmargin
operator|=
name|p
operator|->
name|tcol
operator|->
name|offset
operator|+
name|term_len
argument_list|(
name|p
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOBREAK
operator||
name|TERMP_BRIND
operator||
name|TERMP_HANG
expr_stmt|;
block|}
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
if|if
condition|(
name|pretty
condition|)
block|{
name|term_flushln
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator|&=
operator|~
operator|(
name|TERMP_NOBREAK
operator||
name|TERMP_BRIND
operator||
name|TERMP_HANG
operator|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOPAD
expr_stmt|;
name|p
operator|->
name|tcol
operator|->
name|offset
operator|=
name|p
operator|->
name|tcol
operator|->
name|rmargin
expr_stmt|;
name|p
operator|->
name|tcol
operator|->
name|rmargin
operator|=
name|rmargin
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|child
condition|)
return|return
literal|0
return|;
comment|/* XXX: we drop non-initial arguments as per groff. */
name|assert
argument_list|(
name|n
operator|->
name|child
operator|->
name|string
argument_list|)
expr_stmt|;
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_BOLD
argument_list|)
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
name|n
operator|->
name|child
operator|->
name|string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|termp_fo_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|n
operator|->
name|type
operator|!=
name|ROFFT_BODY
condition|)
return|return;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NODE_SYNPRETTY
operator|&
name|n
operator|->
name|flags
condition|)
block|{
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
name|term_flushln
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|termp_bf_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_HEAD
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|n
operator|->
name|type
operator|!=
name|ROFFT_BODY
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|FONT_Em
operator|==
name|n
operator|->
name|norm
operator|->
name|Bf
operator|.
name|font
condition|)
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_UNDER
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|FONT_Sy
operator|==
name|n
operator|->
name|norm
operator|->
name|Bf
operator|.
name|font
condition|)
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_BOLD
argument_list|)
expr_stmt|;
else|else
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_NONE
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_sm_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|child
condition|)
name|p
operator|->
name|flags
operator|^=
name|TERMP_NONOSPACE
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
literal|"on"
argument_list|,
name|n
operator|->
name|child
operator|->
name|string
argument_list|)
condition|)
name|p
operator|->
name|flags
operator|&=
operator|~
name|TERMP_NONOSPACE
expr_stmt|;
else|else
name|p
operator|->
name|flags
operator||=
name|TERMP_NONOSPACE
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|col
operator|&&
operator|!
operator|(
name|TERMP_NONOSPACE
operator|&
name|p
operator|->
name|flags
operator|)
condition|)
name|p
operator|->
name|flags
operator|&=
operator|~
name|TERMP_NOSPACE
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_ap_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|termp____post
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
comment|/* 	 * Handle lists of authors.  In general, print each followed by 	 * a comma.  Don't print the comma if there are only two 	 * authors. 	 */
if|if
condition|(
name|MDOC__A
operator|==
name|n
operator|->
name|tok
operator|&&
name|n
operator|->
name|next
operator|&&
name|MDOC__A
operator|==
name|n
operator|->
name|next
operator|->
name|tok
condition|)
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|next
operator|->
name|next
operator|||
name|MDOC__A
operator|!=
name|n
operator|->
name|next
operator|->
name|next
operator|->
name|tok
condition|)
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|prev
operator|||
name|MDOC__A
operator|!=
name|n
operator|->
name|prev
operator|->
name|tok
condition|)
return|return;
comment|/* TODO: %U. */
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|parent
operator|||
name|MDOC_Rs
operator|!=
name|n
operator|->
name|parent
operator|->
name|tok
condition|)
return|return;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|next
condition|)
block|{
name|term_word
argument_list|(
name|p
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_SENTENCE
expr_stmt|;
block|}
else|else
name|term_word
argument_list|(
name|p
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_li_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|termp_tag_pre
argument_list|(
name|p
argument_list|,
name|pair
argument_list|,
name|meta
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_NONE
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_lk_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
specifier|const
name|struct
name|roff_node
modifier|*
name|link
decl_stmt|,
modifier|*
name|descr
decl_stmt|,
modifier|*
name|punct
decl_stmt|;
name|int
name|display
decl_stmt|;
if|if
condition|(
operator|(
name|link
operator|=
name|n
operator|->
name|child
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Find beginning of trailing punctuation. */
name|punct
operator|=
name|n
operator|->
name|last
expr_stmt|;
while|while
condition|(
name|punct
operator|!=
name|link
operator|&&
name|punct
operator|->
name|flags
operator|&
name|NODE_DELIMC
condition|)
name|punct
operator|=
name|punct
operator|->
name|prev
expr_stmt|;
name|punct
operator|=
name|punct
operator|->
name|next
expr_stmt|;
comment|/* Link text. */
if|if
condition|(
operator|(
name|descr
operator|=
name|link
operator|->
name|next
operator|)
operator|!=
name|NULL
operator|&&
name|descr
operator|!=
name|punct
condition|)
block|{
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_UNDER
argument_list|)
expr_stmt|;
while|while
condition|(
name|descr
operator|!=
name|punct
condition|)
block|{
if|if
condition|(
name|descr
operator|->
name|flags
operator|&
operator|(
name|NODE_DELIMC
operator||
name|NODE_DELIMO
operator|)
condition|)
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
name|descr
operator|->
name|string
argument_list|)
expr_stmt|;
name|descr
operator|=
name|descr
operator|->
name|next
expr_stmt|;
block|}
name|term_fontpop
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
comment|/* Link target. */
name|display
operator|=
name|term_strlen
argument_list|(
name|p
argument_list|,
name|link
operator|->
name|string
argument_list|)
operator|>=
literal|26
expr_stmt|;
if|if
condition|(
name|display
condition|)
block|{
name|term_newln
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|tcol
operator|->
name|offset
operator|+=
name|term_len
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|defindent
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_BOLD
argument_list|)
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
name|link
operator|->
name|string
argument_list|)
expr_stmt|;
name|term_fontpop
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Trailing punctuation. */
while|while
condition|(
name|punct
operator|!=
name|NULL
condition|)
block|{
name|p
operator|->
name|flags
operator||=
name|TERMP_NOSPACE
expr_stmt|;
name|term_word
argument_list|(
name|p
argument_list|,
name|punct
operator|->
name|string
argument_list|)
expr_stmt|;
name|punct
operator|=
name|punct
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|display
condition|)
name|term_newln
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_bk_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
case|case
name|ROFFT_BLOCK
case|:
break|break;
case|case
name|ROFFT_HEAD
case|:
return|return
literal|0
return|;
case|case
name|ROFFT_BODY
case|:
if|if
condition|(
name|n
operator|->
name|parent
operator|->
name|args
operator|!=
name|NULL
operator|||
name|n
operator|->
name|prev
operator|->
name|child
operator|==
name|NULL
condition|)
name|p
operator|->
name|flags
operator||=
name|TERMP_PREKEEP
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|termp_bk_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|ROFFT_BODY
condition|)
name|p
operator|->
name|flags
operator|&=
operator|~
operator|(
name|TERMP_KEEP
operator||
name|TERMP_PREKEEP
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|termp__t_post
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
comment|/* 	 * If we're in an `Rs' and there's a journal present, then quote 	 * us instead of underlining us (for disambiguation). 	 */
if|if
condition|(
name|n
operator|->
name|parent
operator|&&
name|MDOC_Rs
operator|==
name|n
operator|->
name|parent
operator|->
name|tok
operator|&&
name|n
operator|->
name|parent
operator|->
name|norm
operator|->
name|Rs
operator|.
name|quote_T
condition|)
name|termp_quote_post
argument_list|(
name|p
argument_list|,
name|pair
argument_list|,
name|meta
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|termp____post
argument_list|(
name|p
argument_list|,
name|pair
argument_list|,
name|meta
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp__t_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
comment|/* 	 * If we're in an `Rs' and there's a journal present, then quote 	 * us instead of underlining us (for disambiguation). 	 */
if|if
condition|(
name|n
operator|->
name|parent
operator|&&
name|MDOC_Rs
operator|==
name|n
operator|->
name|parent
operator|->
name|tok
operator|&&
name|n
operator|->
name|parent
operator|->
name|norm
operator|->
name|Rs
operator|.
name|quote_T
condition|)
return|return
name|termp_quote_pre
argument_list|(
name|p
argument_list|,
name|pair
argument_list|,
name|meta
argument_list|,
name|n
argument_list|)
return|;
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_UNDER
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_under_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_UNDER
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_em_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|n
operator|->
name|child
operator|!=
name|NULL
operator|&&
name|n
operator|->
name|child
operator|->
name|type
operator|==
name|ROFFT_TEXT
condition|)
name|tag_put
argument_list|(
name|n
operator|->
name|child
operator|->
name|string
argument_list|,
literal|0
argument_list|,
name|p
operator|->
name|line
argument_list|)
expr_stmt|;
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_UNDER
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_sy_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|n
operator|->
name|child
operator|!=
name|NULL
operator|&&
name|n
operator|->
name|child
operator|->
name|type
operator|==
name|ROFFT_TEXT
condition|)
name|tag_put
argument_list|(
name|n
operator|->
name|child
operator|->
name|string
argument_list|,
literal|0
argument_list|,
name|p
operator|->
name|line
argument_list|)
expr_stmt|;
name|term_fontpush
argument_list|(
name|p
argument_list|,
name|TERMFONT_BOLD
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_er_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|n
operator|->
name|sec
operator|==
name|SEC_ERRORS
operator|&&
operator|(
name|n
operator|->
name|parent
operator|->
name|tok
operator|==
name|MDOC_It
operator|||
operator|(
name|n
operator|->
name|parent
operator|->
name|tok
operator|==
name|MDOC_Bq
operator|&&
name|n
operator|->
name|parent
operator|->
name|parent
operator|->
name|parent
operator|->
name|tok
operator|==
name|MDOC_It
operator|)
operator|)
condition|)
name|tag_put
argument_list|(
name|n
operator|->
name|child
operator|->
name|string
argument_list|,
literal|1
argument_list|,
name|p
operator|->
name|line
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termp_tag_pre
parameter_list|(
name|DECL_ARGS
parameter_list|)
block|{
if|if
condition|(
name|n
operator|->
name|child
operator|!=
name|NULL
operator|&&
name|n
operator|->
name|child
operator|->
name|type
operator|==
name|ROFFT_TEXT
operator|&&
operator|(
name|n
operator|->
name|prev
operator|==
name|NULL
operator|||
operator|(
name|n
operator|->
name|prev
operator|->
name|type
operator|==
name|ROFFT_TEXT
operator|&&
name|strcmp
argument_list|(
name|n
operator|->
name|prev
operator|->
name|string
argument_list|,
literal|"|"
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|&&
operator|(
name|n
operator|->
name|parent
operator|->
name|tok
operator|==
name|MDOC_It
operator|||
operator|(
name|n
operator|->
name|parent
operator|->
name|tok
operator|==
name|MDOC_Xo
operator|&&
name|n
operator|->
name|parent
operator|->
name|parent
operator|->
name|prev
operator|==
name|NULL
operator|&&
name|n
operator|->
name|parent
operator|->
name|parent
operator|->
name|parent
operator|->
name|tok
operator|==
name|MDOC_It
operator|)
operator|)
condition|)
name|tag_put
argument_list|(
name|n
operator|->
name|child
operator|->
name|string
argument_list|,
literal|1
argument_list|,
name|p
operator|->
name|line
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

end_unit

