begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$Id: mdoc_argv.c,v 1.115 2017/05/30 16:22:03 schwarze Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2008, 2009, 2010, 2011 Kristaps Dzonsons<kristaps@bsd.lv>  * Copyright (c) 2012, 2014-2017 Ingo Schwarze<schwarze@openbsd.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"mandoc_aux.h"
end_include

begin_include
include|#
directive|include
file|"mandoc.h"
end_include

begin_include
include|#
directive|include
file|"roff.h"
end_include

begin_include
include|#
directive|include
file|"mdoc.h"
end_include

begin_include
include|#
directive|include
file|"libmandoc.h"
end_include

begin_include
include|#
directive|include
file|"roff_int.h"
end_include

begin_include
include|#
directive|include
file|"libmdoc.h"
end_include

begin_define
define|#
directive|define
name|MULTI_STEP
value|5
end_define

begin_comment
comment|/* pre-allocate argument values */
end_comment

begin_define
define|#
directive|define
name|DELIMSZ
value|6
end_define

begin_comment
comment|/* max possible size of a delimiter */
end_comment

begin_enum
enum|enum
name|argsflag
block|{
name|ARGSFL_NONE
init|=
literal|0
block|,
name|ARGSFL_DELIM
block|,
comment|/* handle delimiters of [[::delim::][ ]+]+ */
name|ARGSFL_TABSEP
comment|/* handle tab/`Ta' separated phrases */
block|}
enum|;
end_enum

begin_enum
enum|enum
name|argvflag
block|{
name|ARGV_NONE
block|,
comment|/* no args to flag (e.g., -split) */
name|ARGV_SINGLE
block|,
comment|/* one arg to flag (e.g., -file xxx)  */
name|ARGV_MULTI
comment|/* multiple args (e.g., -column xxx yyy) */
block|}
enum|;
end_enum

begin_struct
struct|struct
name|mdocarg
block|{
name|enum
name|argsflag
name|flags
decl_stmt|;
specifier|const
name|enum
name|mdocargt
modifier|*
name|argvs
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|argn_free
parameter_list|(
name|struct
name|mdoc_arg
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|margserr
name|args
parameter_list|(
name|struct
name|roff_man
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|enum
name|argsflag
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|args_checkpunct
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|argv_multi
parameter_list|(
name|struct
name|roff_man
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|mdoc_argv
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|argv_single
parameter_list|(
name|struct
name|roff_man
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|mdoc_argv
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|enum
name|argvflag
name|argvflags
index|[
name|MDOC_ARG_MAX
index|]
init|=
block|{
name|ARGV_NONE
block|,
comment|/* MDOC_Split */
name|ARGV_NONE
block|,
comment|/* MDOC_Nosplit */
name|ARGV_NONE
block|,
comment|/* MDOC_Ragged */
name|ARGV_NONE
block|,
comment|/* MDOC_Unfilled */
name|ARGV_NONE
block|,
comment|/* MDOC_Literal */
name|ARGV_SINGLE
block|,
comment|/* MDOC_File */
name|ARGV_SINGLE
block|,
comment|/* MDOC_Offset */
name|ARGV_NONE
block|,
comment|/* MDOC_Bullet */
name|ARGV_NONE
block|,
comment|/* MDOC_Dash */
name|ARGV_NONE
block|,
comment|/* MDOC_Hyphen */
name|ARGV_NONE
block|,
comment|/* MDOC_Item */
name|ARGV_NONE
block|,
comment|/* MDOC_Enum */
name|ARGV_NONE
block|,
comment|/* MDOC_Tag */
name|ARGV_NONE
block|,
comment|/* MDOC_Diag */
name|ARGV_NONE
block|,
comment|/* MDOC_Hang */
name|ARGV_NONE
block|,
comment|/* MDOC_Ohang */
name|ARGV_NONE
block|,
comment|/* MDOC_Inset */
name|ARGV_MULTI
block|,
comment|/* MDOC_Column */
name|ARGV_SINGLE
block|,
comment|/* MDOC_Width */
name|ARGV_NONE
block|,
comment|/* MDOC_Compact */
name|ARGV_NONE
block|,
comment|/* MDOC_Std */
name|ARGV_NONE
block|,
comment|/* MDOC_Filled */
name|ARGV_NONE
block|,
comment|/* MDOC_Words */
name|ARGV_NONE
block|,
comment|/* MDOC_Emphasis */
name|ARGV_NONE
block|,
comment|/* MDOC_Symbolic */
name|ARGV_NONE
comment|/* MDOC_Symbolic */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|enum
name|mdocargt
name|args_Ex
index|[]
init|=
block|{
name|MDOC_Std
block|,
name|MDOC_ARG_MAX
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|enum
name|mdocargt
name|args_An
index|[]
init|=
block|{
name|MDOC_Split
block|,
name|MDOC_Nosplit
block|,
name|MDOC_ARG_MAX
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|enum
name|mdocargt
name|args_Bd
index|[]
init|=
block|{
name|MDOC_Ragged
block|,
name|MDOC_Unfilled
block|,
name|MDOC_Filled
block|,
name|MDOC_Literal
block|,
name|MDOC_File
block|,
name|MDOC_Offset
block|,
name|MDOC_Compact
block|,
name|MDOC_Centred
block|,
name|MDOC_ARG_MAX
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|enum
name|mdocargt
name|args_Bf
index|[]
init|=
block|{
name|MDOC_Emphasis
block|,
name|MDOC_Literal
block|,
name|MDOC_Symbolic
block|,
name|MDOC_ARG_MAX
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|enum
name|mdocargt
name|args_Bk
index|[]
init|=
block|{
name|MDOC_Words
block|,
name|MDOC_ARG_MAX
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|enum
name|mdocargt
name|args_Bl
index|[]
init|=
block|{
name|MDOC_Bullet
block|,
name|MDOC_Dash
block|,
name|MDOC_Hyphen
block|,
name|MDOC_Item
block|,
name|MDOC_Enum
block|,
name|MDOC_Tag
block|,
name|MDOC_Diag
block|,
name|MDOC_Hang
block|,
name|MDOC_Ohang
block|,
name|MDOC_Inset
block|,
name|MDOC_Column
block|,
name|MDOC_Width
block|,
name|MDOC_Offset
block|,
name|MDOC_Compact
block|,
name|MDOC_Nested
block|,
name|MDOC_ARG_MAX
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|mdocarg
name|__mdocargs
index|[
name|MDOC_MAX
operator|-
name|MDOC_Dd
index|]
init|=
block|{
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* Dd */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* Dt */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* Os */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* Sh */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* Ss */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* Pp */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* D1 */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Dl */
block|{
name|ARGSFL_NONE
block|,
name|args_Bd
block|}
block|,
comment|/* Bd */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* Ed */
block|{
name|ARGSFL_NONE
block|,
name|args_Bl
block|}
block|,
comment|/* Bl */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* El */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* It */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Ad */
block|{
name|ARGSFL_DELIM
block|,
name|args_An
block|}
block|,
comment|/* An */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Ap */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Ar */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Cd */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Cm */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Dv */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Er */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Ev */
block|{
name|ARGSFL_NONE
block|,
name|args_Ex
block|}
block|,
comment|/* Ex */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Fa */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* Fd */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Fl */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Fn */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Ft */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Ic */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* In */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Li */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* Nd */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Nm */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Op */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Ot */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Pa */
block|{
name|ARGSFL_NONE
block|,
name|args_Ex
block|}
block|,
comment|/* Rv */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* St */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Va */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Vt */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Xr */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* %A */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* %B */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* %D */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* %I */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* %J */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* %N */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* %O */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* %P */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* %R */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* %T */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* %V */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Ac */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* Ao */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Aq */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* At */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Bc */
block|{
name|ARGSFL_NONE
block|,
name|args_Bf
block|}
block|,
comment|/* Bf */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* Bo */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Bq */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Bsx */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Bx */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* Db */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Dc */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* Do */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Dq */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Ec */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* Ef */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Em */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* Eo */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Fx */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Ms */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* No */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Ns */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Nx */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Ox */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Pc */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Pf */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* Po */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Pq */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Qc */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Ql */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* Qo */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Qq */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* Re */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* Rs */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Sc */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* So */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Sq */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* Sm */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Sx */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Sy */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Tn */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Ux */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Xc */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* Xo */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* Fo */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Fc */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* Oo */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Oc */
block|{
name|ARGSFL_NONE
block|,
name|args_Bk
block|}
block|,
comment|/* Bk */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* Ek */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* Bt */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* Hf */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Fr */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* Ud */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Lb */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* Lp */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Lk */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Mt */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Brq */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* Bro */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Brc */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* %C */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* Es */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* En */
block|{
name|ARGSFL_DELIM
block|,
name|NULL
block|}
block|,
comment|/* Dx */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* %Q */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* %U */
block|{
name|ARGSFL_NONE
block|,
name|NULL
block|}
block|,
comment|/* Ta */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|mdocarg
modifier|*
specifier|const
name|mdocargs
init|=
name|__mdocargs
operator|-
name|MDOC_Dd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Parse flags and their arguments from the input line.  * These come in the form -flag [argument ...].  * Some flags take no argument, some one, some multiple.  */
end_comment

begin_function
name|void
name|mdoc_argv
parameter_list|(
name|struct
name|roff_man
modifier|*
name|mdoc
parameter_list|,
name|int
name|line
parameter_list|,
name|enum
name|roff_tok
name|tok
parameter_list|,
name|struct
name|mdoc_arg
modifier|*
modifier|*
name|reta
parameter_list|,
name|int
modifier|*
name|pos
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|mdoc_argv
name|tmpv
decl_stmt|;
name|struct
name|mdoc_argv
modifier|*
modifier|*
name|retv
decl_stmt|;
specifier|const
name|enum
name|mdocargt
modifier|*
name|argtable
decl_stmt|;
name|char
modifier|*
name|argname
decl_stmt|;
name|int
name|ipos
decl_stmt|,
name|retc
decl_stmt|;
name|char
name|savechar
decl_stmt|;
operator|*
name|reta
operator|=
name|NULL
expr_stmt|;
comment|/* Which flags does this macro support? */
name|assert
argument_list|(
name|tok
operator|>=
name|MDOC_Dd
operator|&&
name|tok
operator|<
name|MDOC_MAX
argument_list|)
expr_stmt|;
name|argtable
operator|=
name|mdocargs
index|[
name|tok
index|]
operator|.
name|argvs
expr_stmt|;
if|if
condition|(
name|argtable
operator|==
name|NULL
condition|)
return|return;
comment|/* Loop over the flags on the input line. */
name|ipos
operator|=
operator|*
name|pos
expr_stmt|;
while|while
condition|(
name|buf
index|[
name|ipos
index|]
operator|==
literal|'-'
condition|)
block|{
comment|/* Seek to the first unescaped space. */
for|for
control|(
name|argname
operator|=
name|buf
operator|+
operator|++
name|ipos
init|;
name|buf
index|[
name|ipos
index|]
operator|!=
literal|'\0'
condition|;
name|ipos
operator|++
control|)
if|if
condition|(
name|buf
index|[
name|ipos
index|]
operator|==
literal|' '
operator|&&
name|buf
index|[
name|ipos
operator|-
literal|1
index|]
operator|!=
literal|'\\'
condition|)
break|break;
comment|/* 		 * We want to nil-terminate the word to look it up. 		 * But we may not have a flag, in which case we need 		 * to restore the line as-is.  So keep around the 		 * stray byte, which we'll reset upon exiting. 		 */
if|if
condition|(
operator|(
name|savechar
operator|=
name|buf
index|[
name|ipos
index|]
operator|)
operator|!=
literal|'\0'
condition|)
name|buf
index|[
name|ipos
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 		 * Now look up the word as a flag.  Use temporary 		 * storage that we'll copy into the node's flags. 		 */
while|while
condition|(
operator|(
name|tmpv
operator|.
name|arg
operator|=
operator|*
name|argtable
operator|++
operator|)
operator|!=
name|MDOC_ARG_MAX
condition|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argname
argument_list|,
name|mdoc_argnames
index|[
name|tmpv
operator|.
name|arg
index|]
argument_list|)
condition|)
break|break;
comment|/* If it isn't a flag, restore the saved byte. */
if|if
condition|(
name|tmpv
operator|.
name|arg
operator|==
name|MDOC_ARG_MAX
condition|)
block|{
if|if
condition|(
name|savechar
operator|!=
literal|'\0'
condition|)
name|buf
index|[
name|ipos
operator|-
literal|1
index|]
operator|=
name|savechar
expr_stmt|;
break|break;
block|}
comment|/* Read to the next word (the first argument). */
while|while
condition|(
name|buf
index|[
name|ipos
index|]
operator|==
literal|' '
condition|)
name|ipos
operator|++
expr_stmt|;
comment|/* Parse the arguments of the flag. */
name|tmpv
operator|.
name|line
operator|=
name|line
expr_stmt|;
name|tmpv
operator|.
name|pos
operator|=
operator|*
name|pos
expr_stmt|;
name|tmpv
operator|.
name|sz
operator|=
literal|0
expr_stmt|;
name|tmpv
operator|.
name|value
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|argvflags
index|[
name|tmpv
operator|.
name|arg
index|]
condition|)
block|{
case|case
name|ARGV_SINGLE
case|:
name|argv_single
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
operator|&
name|tmpv
argument_list|,
operator|&
name|ipos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARGV_MULTI
case|:
name|argv_multi
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
operator|&
name|tmpv
argument_list|,
operator|&
name|ipos
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARGV_NONE
case|:
break|break;
block|}
comment|/* Append to the return values. */
if|if
condition|(
operator|*
name|reta
operator|==
name|NULL
condition|)
operator|*
name|reta
operator|=
name|mandoc_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|reta
argument_list|)
argument_list|)
expr_stmt|;
name|retc
operator|=
operator|++
operator|(
operator|*
name|reta
operator|)
operator|->
name|argc
expr_stmt|;
name|retv
operator|=
operator|&
operator|(
operator|*
name|reta
operator|)
operator|->
name|argv
expr_stmt|;
operator|*
name|retv
operator|=
name|mandoc_reallocarray
argument_list|(
operator|*
name|retv
argument_list|,
name|retc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|retv
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|*
name|retv
operator|+
name|retc
operator|-
literal|1
argument_list|,
operator|&
name|tmpv
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|retv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Prepare for parsing the next flag. */
operator|*
name|pos
operator|=
name|ipos
expr_stmt|;
name|argtable
operator|=
name|mdocargs
index|[
name|tok
index|]
operator|.
name|argvs
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|mdoc_argv_free
parameter_list|(
name|struct
name|mdoc_arg
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
name|p
condition|)
return|return;
if|if
condition|(
name|p
operator|->
name|refcnt
condition|)
block|{
operator|--
operator|(
name|p
operator|->
name|refcnt
operator|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|refcnt
condition|)
return|return;
block|}
name|assert
argument_list|(
name|p
operator|->
name|argc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|int
operator|)
name|p
operator|->
name|argc
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|argn_free
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|argv
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|argn_free
parameter_list|(
name|struct
name|mdoc_arg
modifier|*
name|p
parameter_list|,
name|int
name|iarg
parameter_list|)
block|{
name|struct
name|mdoc_argv
modifier|*
name|arg
decl_stmt|;
name|int
name|j
decl_stmt|;
name|arg
operator|=
operator|&
name|p
operator|->
name|argv
index|[
name|iarg
index|]
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|sz
operator|&&
name|arg
operator|->
name|value
condition|)
block|{
for|for
control|(
name|j
operator|=
operator|(
name|int
operator|)
name|arg
operator|->
name|sz
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|free
argument_list|(
name|arg
operator|->
name|value
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|arg
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
for|for
control|(
operator|--
name|p
operator|->
name|argc
init|;
name|iarg
operator|<
operator|(
name|int
operator|)
name|p
operator|->
name|argc
condition|;
name|iarg
operator|++
control|)
name|p
operator|->
name|argv
index|[
name|iarg
index|]
operator|=
name|p
operator|->
name|argv
index|[
name|iarg
operator|+
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_function
name|enum
name|margserr
name|mdoc_args
parameter_list|(
name|struct
name|roff_man
modifier|*
name|mdoc
parameter_list|,
name|int
name|line
parameter_list|,
name|int
modifier|*
name|pos
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|enum
name|roff_tok
name|tok
parameter_list|,
name|char
modifier|*
modifier|*
name|v
parameter_list|)
block|{
name|struct
name|roff_node
modifier|*
name|n
decl_stmt|;
name|char
modifier|*
name|v_local
decl_stmt|;
name|enum
name|argsflag
name|fl
decl_stmt|;
if|if
condition|(
name|v
operator|==
name|NULL
condition|)
name|v
operator|=
operator|&
name|v_local
expr_stmt|;
name|fl
operator|=
name|tok
operator|==
name|TOKEN_NONE
condition|?
name|ARGSFL_NONE
else|:
name|mdocargs
index|[
name|tok
index|]
operator|.
name|flags
expr_stmt|;
comment|/* 	 * We know that we're in an `It', so it's reasonable to expect 	 * us to be sitting in a `Bl'.  Someday this may not be the case 	 * (if we allow random `It's sitting out there), so provide a 	 * safe fall-back into the default behaviour. 	 */
if|if
condition|(
name|tok
operator|==
name|MDOC_It
condition|)
block|{
for|for
control|(
name|n
operator|=
name|mdoc
operator|->
name|last
init|;
name|n
operator|!=
name|NULL
condition|;
name|n
operator|=
name|n
operator|->
name|parent
control|)
block|{
if|if
condition|(
name|n
operator|->
name|tok
operator|!=
name|MDOC_Bl
condition|)
continue|continue;
if|if
condition|(
name|n
operator|->
name|norm
operator|->
name|Bl
operator|.
name|type
operator|==
name|LIST_column
condition|)
name|fl
operator|=
name|ARGSFL_TABSEP
expr_stmt|;
break|break;
block|}
block|}
return|return
name|args
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|,
name|fl
argument_list|,
name|v
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|margserr
name|args
parameter_list|(
name|struct
name|roff_man
modifier|*
name|mdoc
parameter_list|,
name|int
name|line
parameter_list|,
name|int
modifier|*
name|pos
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|enum
name|argsflag
name|fl
parameter_list|,
name|char
modifier|*
modifier|*
name|v
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|pairs
decl_stmt|;
if|if
condition|(
name|buf
index|[
operator|*
name|pos
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|mdoc
operator|->
name|flags
operator|&
name|MDOC_PHRASELIT
operator|&&
operator|!
operator|(
name|mdoc
operator|->
name|flags
operator|&
name|MDOC_PHRASE
operator|)
condition|)
block|{
name|mandoc_msg
argument_list|(
name|MANDOCERR_ARG_QUOTE
argument_list|,
name|mdoc
operator|->
name|parse
argument_list|,
name|line
argument_list|,
operator|*
name|pos
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mdoc
operator|->
name|flags
operator|&=
operator|~
name|MDOC_PHRASELIT
expr_stmt|;
block|}
return|return
name|ARGS_EOLN
return|;
block|}
operator|*
name|v
operator|=
name|buf
operator|+
operator|*
name|pos
expr_stmt|;
if|if
condition|(
name|fl
operator|==
name|ARGSFL_DELIM
operator|&&
name|args_checkpunct
argument_list|(
name|buf
argument_list|,
operator|*
name|pos
argument_list|)
condition|)
return|return
name|ARGS_PUNCT
return|;
comment|/* 	 * Tabs in `It' lines in `Bl -column' can't be escaped. 	 * Phrases are reparsed for `Ta' and other macros later. 	 */
if|if
condition|(
name|fl
operator|==
name|ARGSFL_TABSEP
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
operator|*
name|v
argument_list|,
literal|'\t'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Words right before and right after 			 * tab characters are not parsed, 			 * unless there is a blank in between. 			 */
if|if
condition|(
name|p
operator|>
name|buf
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|' '
condition|)
name|mdoc
operator|->
name|flags
operator||=
name|MDOC_PHRASEQL
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|!=
literal|' '
condition|)
name|mdoc
operator|->
name|flags
operator||=
name|MDOC_PHRASEQN
expr_stmt|;
comment|/* 			 * One or more blanks after a tab cause 			 * one leading blank in the next column. 			 * So skip all but one of them. 			 */
operator|*
name|pos
operator|+=
call|(
name|int
call|)
argument_list|(
name|p
operator|-
operator|*
name|v
argument_list|)
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|buf
index|[
operator|*
name|pos
index|]
operator|==
literal|' '
operator|&&
name|buf
index|[
operator|*
name|pos
operator|+
literal|1
index|]
operator|==
literal|' '
condition|)
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
comment|/* 			 * A tab at the end of an input line 			 * switches to the next column. 			 */
if|if
condition|(
name|buf
index|[
operator|*
name|pos
index|]
operator|==
literal|'\0'
operator|||
name|buf
index|[
operator|*
name|pos
operator|+
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|mdoc
operator|->
name|flags
operator||=
name|MDOC_PHRASEQN
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|strchr
argument_list|(
operator|*
name|v
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|mandoc_msg
argument_list|(
name|MANDOCERR_SPACE_EOL
argument_list|,
name|mdoc
operator|->
name|parse
argument_list|,
name|line
argument_list|,
operator|*
name|pos
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|pos
operator|+=
call|(
name|int
call|)
argument_list|(
name|p
operator|-
operator|*
name|v
argument_list|)
expr_stmt|;
block|}
comment|/* Skip any trailing blank characters. */
while|while
condition|(
name|p
operator|>
operator|*
name|v
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|&&
operator|(
name|p
operator|-
literal|1
operator|==
operator|*
name|v
operator|||
name|p
index|[
operator|-
literal|2
index|]
operator|!=
literal|'\\'
operator|)
condition|)
name|p
operator|--
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|ARGS_PHRASE
return|;
block|}
comment|/* 	 * Process a quoted literal.  A quote begins with a double-quote 	 * and ends with a double-quote NOT preceded by a double-quote. 	 * NUL-terminate the literal in place. 	 * Collapse pairs of quotes inside quoted literals. 	 * Whitespace is NOT involved in literal termination. 	 */
if|if
condition|(
name|mdoc
operator|->
name|flags
operator|&
name|MDOC_PHRASELIT
operator|||
name|buf
index|[
operator|*
name|pos
index|]
operator|==
literal|'\"'
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|mdoc
operator|->
name|flags
operator|&
name|MDOC_PHRASELIT
operator|)
condition|)
operator|*
name|v
operator|=
operator|&
name|buf
index|[
operator|++
operator|(
operator|*
name|pos
operator|)
index|]
expr_stmt|;
if|if
condition|(
name|mdoc
operator|->
name|flags
operator|&
name|MDOC_PHRASE
condition|)
name|mdoc
operator|->
name|flags
operator||=
name|MDOC_PHRASELIT
expr_stmt|;
name|pairs
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|buf
index|[
operator|*
name|pos
index|]
condition|;
operator|(
operator|*
name|pos
operator|)
operator|++
control|)
block|{
comment|/* Move following text left after quoted quotes. */
if|if
condition|(
name|pairs
condition|)
name|buf
index|[
operator|*
name|pos
operator|-
name|pairs
index|]
operator|=
name|buf
index|[
operator|*
name|pos
index|]
expr_stmt|;
if|if
condition|(
literal|'\"'
operator|!=
name|buf
index|[
operator|*
name|pos
index|]
condition|)
continue|continue;
comment|/* Unquoted quotes end quoted args. */
if|if
condition|(
literal|'\"'
operator|!=
name|buf
index|[
operator|*
name|pos
operator|+
literal|1
index|]
condition|)
break|break;
comment|/* Quoted quotes collapse. */
name|pairs
operator|++
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|pairs
condition|)
name|buf
index|[
operator|*
name|pos
operator|-
name|pairs
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|buf
index|[
operator|*
name|pos
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|mdoc
operator|->
name|flags
operator|&
name|MDOC_PHRASE
operator|)
condition|)
name|mandoc_msg
argument_list|(
name|MANDOCERR_ARG_QUOTE
argument_list|,
name|mdoc
operator|->
name|parse
argument_list|,
name|line
argument_list|,
operator|*
name|pos
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|ARGS_WORD
return|;
block|}
name|mdoc
operator|->
name|flags
operator|&=
operator|~
name|MDOC_PHRASELIT
expr_stmt|;
name|buf
index|[
operator|(
operator|*
name|pos
operator|)
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
literal|'\0'
operator|==
name|buf
index|[
operator|*
name|pos
index|]
condition|)
return|return
name|ARGS_WORD
return|;
while|while
condition|(
literal|' '
operator|==
name|buf
index|[
operator|*
name|pos
index|]
condition|)
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
if|if
condition|(
literal|'\0'
operator|==
name|buf
index|[
operator|*
name|pos
index|]
condition|)
name|mandoc_msg
argument_list|(
name|MANDOCERR_SPACE_EOL
argument_list|,
name|mdoc
operator|->
name|parse
argument_list|,
name|line
argument_list|,
operator|*
name|pos
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|ARGS_WORD
return|;
block|}
name|p
operator|=
operator|&
name|buf
index|[
operator|*
name|pos
index|]
expr_stmt|;
operator|*
name|v
operator|=
name|mandoc_getarg
argument_list|(
name|mdoc
operator|->
name|parse
argument_list|,
operator|&
name|p
argument_list|,
name|line
argument_list|,
name|pos
argument_list|)
expr_stmt|;
comment|/* 	 * After parsing the last word in this phrase, 	 * tell lookup() whether or not to interpret it. 	 */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
operator|&&
name|mdoc
operator|->
name|flags
operator|&
name|MDOC_PHRASEQL
condition|)
block|{
name|mdoc
operator|->
name|flags
operator|&=
operator|~
name|MDOC_PHRASEQL
expr_stmt|;
name|mdoc
operator|->
name|flags
operator||=
name|MDOC_PHRASEQF
expr_stmt|;
block|}
return|return
name|ARGS_WORD
return|;
block|}
end_function

begin_comment
comment|/*  * Check if the string consists only of space-separated closing  * delimiters.  This is a bit of a dance: the first must be a close  * delimiter, but it may be followed by middle delimiters.  Arbitrary  * whitespace may separate these tokens.  */
end_comment

begin_function
specifier|static
name|int
name|args_checkpunct
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|int
name|j
decl_stmt|;
name|char
name|dbuf
index|[
name|DELIMSZ
index|]
decl_stmt|;
name|enum
name|mdelim
name|d
decl_stmt|;
comment|/* First token must be a close-delimiter. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|buf
index|[
name|i
index|]
operator|&&
literal|' '
operator|!=
name|buf
index|[
name|i
index|]
operator|&&
name|j
operator|<
name|DELIMSZ
condition|;
name|j
operator|++
operator|,
name|i
operator|++
control|)
name|dbuf
index|[
name|j
index|]
operator|=
name|buf
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|DELIMSZ
operator|==
name|j
condition|)
return|return
literal|0
return|;
name|dbuf
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|DELIM_CLOSE
operator|!=
name|mdoc_isdelim
argument_list|(
name|dbuf
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
literal|' '
operator|==
name|buf
index|[
name|i
index|]
condition|)
name|i
operator|++
expr_stmt|;
comment|/* Remaining must NOT be open/none. */
while|while
condition|(
name|buf
index|[
name|i
index|]
condition|)
block|{
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|buf
index|[
name|i
index|]
operator|&&
literal|' '
operator|!=
name|buf
index|[
name|i
index|]
operator|&&
name|j
operator|<
name|DELIMSZ
condition|)
name|dbuf
index|[
name|j
operator|++
index|]
operator|=
name|buf
index|[
name|i
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|DELIMSZ
operator|==
name|j
condition|)
return|return
literal|0
return|;
name|dbuf
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
name|d
operator|=
name|mdoc_isdelim
argument_list|(
name|dbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|DELIM_NONE
operator|==
name|d
operator|||
name|DELIM_OPEN
operator|==
name|d
condition|)
return|return
literal|0
return|;
while|while
condition|(
literal|' '
operator|==
name|buf
index|[
name|i
index|]
condition|)
name|i
operator|++
expr_stmt|;
block|}
return|return
literal|'\0'
operator|==
name|buf
index|[
name|i
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|argv_multi
parameter_list|(
name|struct
name|roff_man
modifier|*
name|mdoc
parameter_list|,
name|int
name|line
parameter_list|,
name|struct
name|mdoc_argv
modifier|*
name|v
parameter_list|,
name|int
modifier|*
name|pos
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|enum
name|margserr
name|ac
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|v
operator|->
name|sz
operator|=
literal|0
init|;
condition|;
name|v
operator|->
name|sz
operator|++
control|)
block|{
if|if
condition|(
name|buf
index|[
operator|*
name|pos
index|]
operator|==
literal|'-'
condition|)
break|break;
name|ac
operator|=
name|args
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|,
name|ARGSFL_NONE
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
operator|==
name|ARGS_EOLN
condition|)
break|break;
if|if
condition|(
name|v
operator|->
name|sz
operator|%
name|MULTI_STEP
operator|==
literal|0
condition|)
name|v
operator|->
name|value
operator|=
name|mandoc_reallocarray
argument_list|(
name|v
operator|->
name|value
argument_list|,
name|v
operator|->
name|sz
operator|+
name|MULTI_STEP
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|->
name|value
index|[
operator|(
name|int
operator|)
name|v
operator|->
name|sz
index|]
operator|=
name|mandoc_strdup
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|argv_single
parameter_list|(
name|struct
name|roff_man
modifier|*
name|mdoc
parameter_list|,
name|int
name|line
parameter_list|,
name|struct
name|mdoc_argv
modifier|*
name|v
parameter_list|,
name|int
modifier|*
name|pos
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|enum
name|margserr
name|ac
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|ac
operator|=
name|args
argument_list|(
name|mdoc
argument_list|,
name|line
argument_list|,
name|pos
argument_list|,
name|buf
argument_list|,
name|ARGSFL_NONE
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
operator|==
name|ARGS_EOLN
condition|)
return|return;
name|v
operator|->
name|sz
operator|=
literal|1
expr_stmt|;
name|v
operator|->
name|value
operator|=
name|mandoc_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|->
name|value
index|[
literal|0
index|]
operator|=
name|mandoc_strdup
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

