begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$Id: preconv.c,v 1.13 2014/12/19 04:58:35 schwarze Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2011 Kristaps Dzonsons<kristaps@bsd.lv>  * Copyright (c) 2014 Ingo Schwarze<schwarze@openbsd.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"mandoc.h"
end_include

begin_include
include|#
directive|include
file|"libmandoc.h"
end_include

begin_function
name|int
name|preconv_encode
parameter_list|(
name|struct
name|buf
modifier|*
name|ib
parameter_list|,
name|size_t
modifier|*
name|ii
parameter_list|,
name|struct
name|buf
modifier|*
name|ob
parameter_list|,
name|size_t
modifier|*
name|oi
parameter_list|,
name|int
modifier|*
name|filenc
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|cu
decl_stmt|;
name|int
name|nby
decl_stmt|;
name|unsigned
name|int
name|accum
decl_stmt|;
name|cu
operator|=
name|ib
operator|->
name|buf
operator|+
operator|*
name|ii
expr_stmt|;
name|assert
argument_list|(
operator|*
name|cu
operator|&
literal|0x80
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|filenc
operator|&
name|MPARSE_UTF8
operator|)
condition|)
goto|goto
name|latin
goto|;
name|nby
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|nby
operator|<
literal|5
operator|&&
operator|*
name|cu
operator|&
operator|(
literal|1
operator|<<
operator|(
literal|7
operator|-
name|nby
operator|)
operator|)
condition|)
name|nby
operator|++
expr_stmt|;
switch|switch
condition|(
name|nby
condition|)
block|{
case|case
literal|2
case|:
name|accum
operator|=
operator|*
name|cu
operator|&
literal|0x1f
expr_stmt|;
if|if
condition|(
name|accum
operator|<
literal|0x02
condition|)
comment|/* Obfuscated ASCII. */
goto|goto
name|latin
goto|;
break|break;
case|case
literal|3
case|:
name|accum
operator|=
operator|*
name|cu
operator|&
literal|0x0f
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|accum
operator|=
operator|*
name|cu
operator|&
literal|0x07
expr_stmt|;
if|if
condition|(
name|accum
operator|>
literal|0x04
condition|)
comment|/* Beyond Unicode. */
goto|goto
name|latin
goto|;
break|break;
default|default:
comment|/* Bad sequence header. */
goto|goto
name|latin
goto|;
block|}
name|cu
operator|++
expr_stmt|;
switch|switch
condition|(
name|nby
condition|)
block|{
case|case
literal|3
case|:
if|if
condition|(
operator|(
name|accum
operator|==
literal|0x00
operator|&&
operator|!
operator|(
operator|*
name|cu
operator|&
literal|0x20
operator|)
operator|)
operator|||
comment|/* Use 2-byte. */
operator|(
name|accum
operator|==
literal|0x0d
operator|&&
operator|*
name|cu
operator|&
literal|0x20
operator|)
condition|)
comment|/* Surrogates. */
goto|goto
name|latin
goto|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
operator|(
name|accum
operator|==
literal|0x00
operator|&&
operator|!
operator|(
operator|*
name|cu
operator|&
literal|0x30
operator|)
operator|)
operator|||
comment|/* Use 3-byte. */
operator|(
name|accum
operator|==
literal|0x04
operator|&&
operator|*
name|cu
operator|&
literal|0x30
operator|)
condition|)
comment|/* Beyond Unicode. */
goto|goto
name|latin
goto|;
break|break;
default|default:
break|break;
block|}
while|while
condition|(
operator|--
name|nby
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|cu
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
comment|/* Invalid continuation. */
goto|goto
name|latin
goto|;
name|accum
operator|<<=
literal|6
expr_stmt|;
name|accum
operator|+=
operator|*
name|cu
operator|&
literal|0x3f
expr_stmt|;
name|cu
operator|++
expr_stmt|;
block|}
name|assert
argument_list|(
name|accum
operator|>
literal|0x7f
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|accum
operator|<
literal|0x110000
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|accum
operator|<
literal|0xd800
operator|||
name|accum
operator|>
literal|0xdfff
argument_list|)
expr_stmt|;
operator|*
name|oi
operator|+=
name|snprintf
argument_list|(
name|ob
operator|->
name|buf
operator|+
operator|*
name|oi
argument_list|,
literal|11
argument_list|,
literal|"\\[u%.4X]"
argument_list|,
name|accum
argument_list|)
expr_stmt|;
operator|*
name|ii
operator|=
operator|(
name|char
operator|*
operator|)
name|cu
operator|-
name|ib
operator|->
name|buf
expr_stmt|;
operator|*
name|filenc
operator|&=
operator|~
name|MPARSE_LATIN1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
name|latin
label|:
if|if
condition|(
operator|!
operator|(
operator|*
name|filenc
operator|&
name|MPARSE_LATIN1
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|oi
operator|+=
name|snprintf
argument_list|(
name|ob
operator|->
name|buf
operator|+
operator|*
name|oi
argument_list|,
literal|11
argument_list|,
literal|"\\[u%.4X]"
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|ib
operator|->
name|buf
index|[
operator|(
operator|*
name|ii
operator|)
operator|++
index|]
argument_list|)
expr_stmt|;
operator|*
name|filenc
operator|&=
operator|~
name|MPARSE_UTF8
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|preconv_cue
parameter_list|(
specifier|const
name|struct
name|buf
modifier|*
name|b
parameter_list|,
name|size_t
name|offset
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ln
decl_stmt|,
modifier|*
name|eoln
decl_stmt|,
modifier|*
name|eoph
decl_stmt|;
name|size_t
name|sz
decl_stmt|,
name|phsz
decl_stmt|;
name|ln
operator|=
name|b
operator|->
name|buf
operator|+
name|offset
expr_stmt|;
name|sz
operator|=
name|b
operator|->
name|sz
operator|-
name|offset
expr_stmt|;
comment|/* Look for the end-of-line. */
if|if
condition|(
name|NULL
operator|==
operator|(
name|eoln
operator|=
name|memchr
argument_list|(
name|ln
argument_list|,
literal|'\n'
argument_list|,
name|sz
argument_list|)
operator|)
condition|)
name|eoln
operator|=
name|ln
operator|+
name|sz
expr_stmt|;
comment|/* Check if we have the correct header/trailer. */
if|if
condition|(
operator|(
name|sz
operator|=
call|(
name|size_t
call|)
argument_list|(
name|eoln
operator|-
name|ln
argument_list|)
operator|)
operator|<
literal|10
operator|||
name|memcmp
argument_list|(
name|ln
argument_list|,
literal|".\\\" -*-"
argument_list|,
literal|7
argument_list|)
operator|||
name|memcmp
argument_list|(
name|eoln
operator|-
literal|3
argument_list|,
literal|"-*-"
argument_list|,
literal|3
argument_list|)
condition|)
return|return
operator|(
name|MPARSE_UTF8
operator||
name|MPARSE_LATIN1
operator|)
return|;
comment|/* Move after the header and adjust for the trailer. */
name|ln
operator|+=
literal|7
expr_stmt|;
name|sz
operator|-=
literal|10
expr_stmt|;
while|while
condition|(
name|sz
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|sz
operator|>
literal|0
operator|&&
literal|' '
operator|==
operator|*
name|ln
condition|)
block|{
name|ln
operator|++
expr_stmt|;
name|sz
operator|--
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|==
name|sz
condition|)
break|break;
comment|/* Find the end-of-phrase marker (or eoln). */
if|if
condition|(
name|NULL
operator|==
operator|(
name|eoph
operator|=
name|memchr
argument_list|(
name|ln
argument_list|,
literal|';'
argument_list|,
name|sz
argument_list|)
operator|)
condition|)
name|eoph
operator|=
name|eoln
operator|-
literal|3
expr_stmt|;
else|else
name|eoph
operator|++
expr_stmt|;
comment|/* Only account for the "coding" phrase. */
if|if
condition|(
operator|(
name|phsz
operator|=
name|eoph
operator|-
name|ln
operator|)
operator|<
literal|7
operator|||
name|strncasecmp
argument_list|(
name|ln
argument_list|,
literal|"coding:"
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|sz
operator|-=
name|phsz
expr_stmt|;
name|ln
operator|+=
name|phsz
expr_stmt|;
continue|continue;
block|}
name|sz
operator|-=
literal|7
expr_stmt|;
name|ln
operator|+=
literal|7
expr_stmt|;
while|while
condition|(
name|sz
operator|>
literal|0
operator|&&
literal|' '
operator|==
operator|*
name|ln
condition|)
block|{
name|ln
operator|++
expr_stmt|;
name|sz
operator|--
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|==
name|sz
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Check us against known encodings. */
if|if
condition|(
name|phsz
operator|>
literal|4
operator|&&
operator|!
name|strncasecmp
argument_list|(
name|ln
argument_list|,
literal|"utf-8"
argument_list|,
literal|5
argument_list|)
condition|)
return|return
operator|(
name|MPARSE_UTF8
operator|)
return|;
if|if
condition|(
name|phsz
operator|>
literal|10
operator|&&
operator|!
name|strncasecmp
argument_list|(
name|ln
argument_list|,
literal|"iso-latin-1"
argument_list|,
literal|11
argument_list|)
condition|)
return|return
operator|(
name|MPARSE_LATIN1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|MPARSE_UTF8
operator||
name|MPARSE_LATIN1
operator|)
return|;
block|}
end_function

end_unit

