begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$Id: out.c,v 1.54 2014/12/04 02:05:42 schwarze Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2009, 2010, 2011 Kristaps Dzonsons<kristaps@bsd.lv>  * Copyright (c) 2011, 2014 Ingo Schwarze<schwarze@openbsd.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|"mandoc_aux.h"
end_include

begin_include
include|#
directive|include
file|"mandoc.h"
end_include

begin_include
include|#
directive|include
file|"out.h"
end_include

begin_function_decl
specifier|static
name|void
name|tblcalc_data
parameter_list|(
name|struct
name|rofftbl
modifier|*
parameter_list|,
name|struct
name|roffcol
modifier|*
parameter_list|,
specifier|const
name|struct
name|tbl_opts
modifier|*
parameter_list|,
specifier|const
name|struct
name|tbl_dat
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tblcalc_literal
parameter_list|(
name|struct
name|rofftbl
modifier|*
parameter_list|,
name|struct
name|roffcol
modifier|*
parameter_list|,
specifier|const
name|struct
name|tbl_dat
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tblcalc_number
parameter_list|(
name|struct
name|rofftbl
modifier|*
parameter_list|,
name|struct
name|roffcol
modifier|*
parameter_list|,
specifier|const
name|struct
name|tbl_opts
modifier|*
parameter_list|,
specifier|const
name|struct
name|tbl_dat
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Convert a `scaling unit' to a consistent form, or fail.  Scaling  * units are documented in groff.7, mdoc.7, man.7.  */
end_comment

begin_function
name|int
name|a2roffsu
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|struct
name|roffsu
modifier|*
name|dst
parameter_list|,
name|enum
name|roffscale
name|def
parameter_list|)
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|hasd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|enum
name|roffscale
name|unit
decl_stmt|;
if|if
condition|(
literal|'\0'
operator|==
operator|*
name|src
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|i
operator|=
name|hasd
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
operator|*
name|src
condition|)
block|{
case|case
literal|'+'
case|:
name|src
operator|++
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|buf
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|src
operator|++
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
literal|'\0'
operator|==
operator|*
name|src
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
name|i
operator|<
name|BUFSIZ
condition|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|src
argument_list|)
condition|)
block|{
if|if
condition|(
literal|'.'
operator|!=
operator|*
name|src
condition|)
break|break;
elseif|else
if|if
condition|(
name|hasd
condition|)
break|break;
else|else
name|hasd
operator|=
literal|1
expr_stmt|;
block|}
name|buf
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|src
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|BUFSIZ
operator|==
name|i
operator|||
operator|(
operator|*
name|src
operator|&&
operator|*
operator|(
name|src
operator|+
literal|1
operator|)
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
switch|switch
condition|(
operator|*
name|src
condition|)
block|{
case|case
literal|'c'
case|:
name|unit
operator|=
name|SCALE_CM
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|unit
operator|=
name|SCALE_IN
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|unit
operator|=
name|SCALE_PC
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|unit
operator|=
name|SCALE_PT
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|unit
operator|=
name|SCALE_FS
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|unit
operator|=
name|SCALE_VS
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|unit
operator|=
name|SCALE_EM
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
if|if
condition|(
name|SCALE_MAX
operator|==
name|def
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|unit
operator|=
name|def
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|unit
operator|=
name|SCALE_BU
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|unit
operator|=
name|SCALE_MM
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|unit
operator|=
name|SCALE_EN
expr_stmt|;
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* FIXME: do this in the caller. */
if|if
condition|(
operator|(
name|dst
operator|->
name|scale
operator|=
name|atof
argument_list|(
name|buf
argument_list|)
operator|)
operator|<
literal|0.0
condition|)
name|dst
operator|->
name|scale
operator|=
literal|0.0
expr_stmt|;
name|dst
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate the abstract widths and decimal positions of columns in a  * table.  This routine allocates the columns structures then runs over  * all rows and cells in the table.  The function pointers in "tbl" are  * used for the actual width calculations.  */
end_comment

begin_function
name|void
name|tblcalc
parameter_list|(
name|struct
name|rofftbl
modifier|*
name|tbl
parameter_list|,
specifier|const
name|struct
name|tbl_span
modifier|*
name|sp
parameter_list|,
name|size_t
name|totalwidth
parameter_list|)
block|{
specifier|const
name|struct
name|tbl_dat
modifier|*
name|dp
decl_stmt|;
name|struct
name|roffcol
modifier|*
name|col
decl_stmt|;
name|size_t
name|ewidth
decl_stmt|,
name|xwidth
decl_stmt|;
name|int
name|spans
decl_stmt|;
name|int
name|icol
decl_stmt|,
name|maxcol
decl_stmt|,
name|necol
decl_stmt|,
name|nxcol
decl_stmt|;
comment|/* 	 * Allocate the master column specifiers.  These will hold the 	 * widths and decimal positions for all cells in the column.  It 	 * must be freed and nullified by the caller. 	 */
name|assert
argument_list|(
name|NULL
operator|==
name|tbl
operator|->
name|cols
argument_list|)
expr_stmt|;
name|tbl
operator|->
name|cols
operator|=
name|mandoc_calloc
argument_list|(
operator|(
name|size_t
operator|)
name|sp
operator|->
name|opts
operator|->
name|cols
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|roffcol
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|maxcol
operator|=
operator|-
literal|1
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|TBL_SPAN_DATA
operator|!=
name|sp
operator|->
name|pos
condition|)
continue|continue;
name|spans
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Account for the data cells in the layout, matching it 		 * to data cells in the data section. 		 */
for|for
control|(
name|dp
operator|=
name|sp
operator|->
name|first
init|;
name|dp
condition|;
name|dp
operator|=
name|dp
operator|->
name|next
control|)
block|{
comment|/* Do not used spanned cells in the calculation. */
if|if
condition|(
literal|0
operator|<
operator|--
name|spans
condition|)
continue|continue;
name|spans
operator|=
name|dp
operator|->
name|spans
expr_stmt|;
if|if
condition|(
literal|1
operator|<
name|spans
condition|)
continue|continue;
name|icol
operator|=
name|dp
operator|->
name|layout
operator|->
name|head
operator|->
name|ident
expr_stmt|;
if|if
condition|(
name|maxcol
operator|<
name|icol
condition|)
name|maxcol
operator|=
name|icol
expr_stmt|;
name|col
operator|=
name|tbl
operator|->
name|cols
operator|+
name|icol
expr_stmt|;
name|col
operator|->
name|flags
operator||=
name|dp
operator|->
name|layout
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|layout
operator|->
name|flags
operator|&
name|TBL_CELL_WIGN
condition|)
continue|continue;
name|tblcalc_data
argument_list|(
name|tbl
argument_list|,
name|col
argument_list|,
name|sp
operator|->
name|opts
argument_list|,
name|dp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Count columns to equalize and columns to maximize. 	 * Find maximum width of the columns to equalize. 	 * Find total width of the columns *not* to maximize. 	 */
name|necol
operator|=
name|nxcol
operator|=
literal|0
expr_stmt|;
name|ewidth
operator|=
name|xwidth
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|icol
operator|=
literal|0
init|;
name|icol
operator|<=
name|maxcol
condition|;
name|icol
operator|++
control|)
block|{
name|col
operator|=
name|tbl
operator|->
name|cols
operator|+
name|icol
expr_stmt|;
if|if
condition|(
name|col
operator|->
name|flags
operator|&
name|TBL_CELL_EQUAL
condition|)
block|{
name|necol
operator|++
expr_stmt|;
if|if
condition|(
name|ewidth
operator|<
name|col
operator|->
name|width
condition|)
name|ewidth
operator|=
name|col
operator|->
name|width
expr_stmt|;
block|}
if|if
condition|(
name|col
operator|->
name|flags
operator|&
name|TBL_CELL_WMAX
condition|)
name|nxcol
operator|++
expr_stmt|;
else|else
name|xwidth
operator|+=
name|col
operator|->
name|width
expr_stmt|;
block|}
comment|/* 	 * Equalize columns, if requested for any of them. 	 * Update total width of the columns not to maximize. 	 */
if|if
condition|(
name|necol
condition|)
block|{
for|for
control|(
name|icol
operator|=
literal|0
init|;
name|icol
operator|<=
name|maxcol
condition|;
name|icol
operator|++
control|)
block|{
name|col
operator|=
name|tbl
operator|->
name|cols
operator|+
name|icol
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|col
operator|->
name|flags
operator|&
name|TBL_CELL_EQUAL
operator|)
condition|)
continue|continue;
if|if
condition|(
name|col
operator|->
name|width
operator|==
name|ewidth
condition|)
continue|continue;
if|if
condition|(
name|nxcol
operator|&&
name|totalwidth
condition|)
name|xwidth
operator|+=
name|ewidth
operator|-
name|col
operator|->
name|width
expr_stmt|;
name|col
operator|->
name|width
operator|=
name|ewidth
expr_stmt|;
block|}
block|}
comment|/* 	 * If there are any columns to maximize, find the total 	 * available width, deducting 3n margins between columns. 	 * Distribute the available width evenly. 	 */
if|if
condition|(
name|nxcol
operator|&&
name|totalwidth
condition|)
block|{
name|xwidth
operator|=
name|totalwidth
operator|-
literal|3
operator|*
name|maxcol
operator|-
name|xwidth
expr_stmt|;
for|for
control|(
name|icol
operator|=
literal|0
init|;
name|icol
operator|<=
name|maxcol
condition|;
name|icol
operator|++
control|)
block|{
name|col
operator|=
name|tbl
operator|->
name|cols
operator|+
name|icol
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|col
operator|->
name|flags
operator|&
name|TBL_CELL_WMAX
operator|)
condition|)
continue|continue;
name|col
operator|->
name|width
operator|=
name|xwidth
operator|/
name|nxcol
operator|--
expr_stmt|;
name|xwidth
operator|-=
name|col
operator|->
name|width
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|tblcalc_data
parameter_list|(
name|struct
name|rofftbl
modifier|*
name|tbl
parameter_list|,
name|struct
name|roffcol
modifier|*
name|col
parameter_list|,
specifier|const
name|struct
name|tbl_opts
modifier|*
name|opts
parameter_list|,
specifier|const
name|struct
name|tbl_dat
modifier|*
name|dp
parameter_list|)
block|{
name|size_t
name|sz
decl_stmt|;
comment|/* Branch down into data sub-types. */
switch|switch
condition|(
name|dp
operator|->
name|layout
operator|->
name|pos
condition|)
block|{
case|case
name|TBL_CELL_HORIZ
case|:
comment|/* FALLTHROUGH */
case|case
name|TBL_CELL_DHORIZ
case|:
name|sz
operator|=
call|(
modifier|*
name|tbl
operator|->
name|len
call|)
argument_list|(
literal|1
argument_list|,
name|tbl
operator|->
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|col
operator|->
name|width
operator|<
name|sz
condition|)
name|col
operator|->
name|width
operator|=
name|sz
expr_stmt|;
break|break;
case|case
name|TBL_CELL_LONG
case|:
comment|/* FALLTHROUGH */
case|case
name|TBL_CELL_CENTRE
case|:
comment|/* FALLTHROUGH */
case|case
name|TBL_CELL_LEFT
case|:
comment|/* FALLTHROUGH */
case|case
name|TBL_CELL_RIGHT
case|:
name|tblcalc_literal
argument_list|(
name|tbl
argument_list|,
name|col
argument_list|,
name|dp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TBL_CELL_NUMBER
case|:
name|tblcalc_number
argument_list|(
name|tbl
argument_list|,
name|col
argument_list|,
name|opts
argument_list|,
name|dp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TBL_CELL_DOWN
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|tblcalc_literal
parameter_list|(
name|struct
name|rofftbl
modifier|*
name|tbl
parameter_list|,
name|struct
name|roffcol
modifier|*
name|col
parameter_list|,
specifier|const
name|struct
name|tbl_dat
modifier|*
name|dp
parameter_list|)
block|{
name|size_t
name|sz
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|str
operator|=
name|dp
operator|->
name|string
condition|?
name|dp
operator|->
name|string
else|:
literal|""
expr_stmt|;
name|sz
operator|=
call|(
modifier|*
name|tbl
operator|->
name|slen
call|)
argument_list|(
name|str
argument_list|,
name|tbl
operator|->
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|col
operator|->
name|width
operator|<
name|sz
condition|)
name|col
operator|->
name|width
operator|=
name|sz
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tblcalc_number
parameter_list|(
name|struct
name|rofftbl
modifier|*
name|tbl
parameter_list|,
name|struct
name|roffcol
modifier|*
name|col
parameter_list|,
specifier|const
name|struct
name|tbl_opts
modifier|*
name|opts
parameter_list|,
specifier|const
name|struct
name|tbl_dat
modifier|*
name|dp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|size_t
name|sz
decl_stmt|,
name|psz
decl_stmt|,
name|ssz
decl_stmt|,
name|d
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
comment|/* 	 * First calculate number width and decimal place (last + 1 for 	 * non-decimal numbers).  If the stored decimal is subsequent to 	 * ours, make our size longer by that difference 	 * (right-"shifting"); similarly, if ours is subsequent the 	 * stored, then extend the stored size by the difference. 	 * Finally, re-assign the stored values. 	 */
name|str
operator|=
name|dp
operator|->
name|string
condition|?
name|dp
operator|->
name|string
else|:
literal|""
expr_stmt|;
name|sz
operator|=
call|(
modifier|*
name|tbl
operator|->
name|slen
call|)
argument_list|(
name|str
argument_list|,
name|tbl
operator|->
name|arg
argument_list|)
expr_stmt|;
comment|/* FIXME: TBL_DATA_HORIZ et al.? */
name|buf
index|[
literal|0
index|]
operator|=
name|opts
operator|->
name|decimal
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|psz
operator|=
call|(
modifier|*
name|tbl
operator|->
name|slen
call|)
argument_list|(
name|buf
argument_list|,
name|tbl
operator|->
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|str
argument_list|,
name|opts
operator|->
name|decimal
argument_list|)
operator|)
condition|)
block|{
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|ssz
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|cp
operator|!=
operator|&
name|str
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|str
index|[
name|i
index|]
expr_stmt|;
name|ssz
operator|+=
call|(
modifier|*
name|tbl
operator|->
name|slen
call|)
argument_list|(
name|buf
argument_list|,
name|tbl
operator|->
name|arg
argument_list|)
expr_stmt|;
block|}
name|d
operator|=
name|ssz
operator|+
name|psz
expr_stmt|;
block|}
else|else
name|d
operator|=
name|sz
operator|+
name|psz
expr_stmt|;
comment|/* Adjust the settings for this column. */
if|if
condition|(
name|col
operator|->
name|decimal
operator|>
name|d
condition|)
block|{
name|sz
operator|+=
name|col
operator|->
name|decimal
operator|-
name|d
expr_stmt|;
name|d
operator|=
name|col
operator|->
name|decimal
expr_stmt|;
block|}
else|else
name|col
operator|->
name|width
operator|+=
name|d
operator|-
name|col
operator|->
name|decimal
expr_stmt|;
if|if
condition|(
name|sz
operator|>
name|col
operator|->
name|width
condition|)
name|col
operator|->
name|width
operator|=
name|sz
expr_stmt|;
if|if
condition|(
name|d
operator|>
name|col
operator|->
name|decimal
condition|)
name|col
operator|->
name|decimal
operator|=
name|d
expr_stmt|;
block|}
end_function

end_unit

