begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$Id: mandocdb.c,v 1.185 2015/02/27 16:22:09 schwarze Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2011, 2012 Kristaps Dzonsons<kristaps@bsd.lv>  * Copyright (c) 2011-2015 Ingo Schwarze<schwarze@openbsd.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_if
if|#
directive|if
name|HAVE_FTS
end_if

begin_include
include|#
directive|include
file|<fts.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"compat_fts.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_if
if|#
directive|if
name|HAVE_OHASH
end_if

begin_include
include|#
directive|include
file|<ohash.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"compat_ohash.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sqlite3.h>
end_include

begin_include
include|#
directive|include
file|"mdoc.h"
end_include

begin_include
include|#
directive|include
file|"man.h"
end_include

begin_include
include|#
directive|include
file|"mandoc.h"
end_include

begin_include
include|#
directive|include
file|"mandoc_aux.h"
end_include

begin_include
include|#
directive|include
file|"manpath.h"
end_include

begin_include
include|#
directive|include
file|"mansearch.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|mansearch_keymax
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|char
modifier|*
specifier|const
name|mansearch_keynames
index|[]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SQL_EXEC
parameter_list|(
name|_v
parameter_list|)
define|\
value|if (SQLITE_OK != sqlite3_exec(db, (_v), NULL, NULL, NULL)) \ 		say("", "%s: %s", (_v), sqlite3_errmsg(db))
end_define

begin_define
define|#
directive|define
name|SQL_BIND_TEXT
parameter_list|(
name|_s
parameter_list|,
name|_i
parameter_list|,
name|_v
parameter_list|)
define|\
value|if (SQLITE_OK != sqlite3_bind_text \ 		((_s), (_i)++, (_v), -1, SQLITE_STATIC)) \ 		say(mlink->file, "%s", sqlite3_errmsg(db))
end_define

begin_define
define|#
directive|define
name|SQL_BIND_INT
parameter_list|(
name|_s
parameter_list|,
name|_i
parameter_list|,
name|_v
parameter_list|)
define|\
value|if (SQLITE_OK != sqlite3_bind_int \ 		((_s), (_i)++, (_v))) \ 		say(mlink->file, "%s", sqlite3_errmsg(db))
end_define

begin_define
define|#
directive|define
name|SQL_BIND_INT64
parameter_list|(
name|_s
parameter_list|,
name|_i
parameter_list|,
name|_v
parameter_list|)
define|\
value|if (SQLITE_OK != sqlite3_bind_int64 \ 		((_s), (_i)++, (_v))) \ 		say(mlink->file, "%s", sqlite3_errmsg(db))
end_define

begin_define
define|#
directive|define
name|SQL_STEP
parameter_list|(
name|_s
parameter_list|)
define|\
value|if (SQLITE_DONE != sqlite3_step((_s))) \ 		say(mlink->file, "%s", sqlite3_errmsg(db))
end_define

begin_enum
enum|enum
name|op
block|{
name|OP_DEFAULT
init|=
literal|0
block|,
comment|/* new dbs from dir list or default config */
name|OP_CONFFILE
block|,
comment|/* new databases from custom config file */
name|OP_UPDATE
block|,
comment|/* delete/add entries in existing database */
name|OP_DELETE
block|,
comment|/* delete entries from existing database */
name|OP_TEST
comment|/* change no databases, report potential problems */
block|}
enum|;
end_enum

begin_struct
struct|struct
name|str
block|{
specifier|const
name|struct
name|mpage
modifier|*
name|mpage
decl_stmt|;
comment|/* if set, the owning parse */
name|uint64_t
name|mask
decl_stmt|;
comment|/* bitmask in sequence */
name|char
name|key
index|[]
decl_stmt|;
comment|/* rendered text */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|inodev
block|{
name|ino_t
name|st_ino
decl_stmt|;
name|dev_t
name|st_dev
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mpage
block|{
name|struct
name|inodev
name|inodev
decl_stmt|;
comment|/* used for hashing routine */
name|int64_t
name|pageid
decl_stmt|;
comment|/* pageid in mpages SQL table */
name|char
modifier|*
name|sec
decl_stmt|;
comment|/* section from file content */
name|char
modifier|*
name|arch
decl_stmt|;
comment|/* architecture from file content */
name|char
modifier|*
name|title
decl_stmt|;
comment|/* title from file content */
name|char
modifier|*
name|desc
decl_stmt|;
comment|/* description from file content */
name|struct
name|mlink
modifier|*
name|mlinks
decl_stmt|;
comment|/* singly linked list */
name|int
name|form
decl_stmt|;
comment|/* format from file content */
name|int
name|name_head_done
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mlink
block|{
name|char
name|file
index|[
name|PATH_MAX
index|]
decl_stmt|;
comment|/* filename rel. to manpath */
name|char
modifier|*
name|dsec
decl_stmt|;
comment|/* section from directory */
name|char
modifier|*
name|arch
decl_stmt|;
comment|/* architecture from directory */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name from file name (not empty) */
name|char
modifier|*
name|fsec
decl_stmt|;
comment|/* section from file name suffix */
name|struct
name|mlink
modifier|*
name|next
decl_stmt|;
comment|/* singly linked list */
name|struct
name|mpage
modifier|*
name|mpage
decl_stmt|;
comment|/* parent */
name|int
name|dform
decl_stmt|;
comment|/* format from directory */
name|int
name|fform
decl_stmt|;
comment|/* format from file name suffix */
name|int
name|gzip
decl_stmt|;
comment|/* filename has a .gz suffix */
block|}
struct|;
end_struct

begin_enum
enum|enum
name|stmt
block|{
name|STMT_DELETE_PAGE
init|=
literal|0
block|,
comment|/* delete mpage */
name|STMT_INSERT_PAGE
block|,
comment|/* insert mpage */
name|STMT_INSERT_LINK
block|,
comment|/* insert mlink */
name|STMT_INSERT_NAME
block|,
comment|/* insert name */
name|STMT_SELECT_NAME
block|,
comment|/* retrieve existing name flags */
name|STMT_INSERT_KEY
block|,
comment|/* insert parsed key */
name|STMT__MAX
block|}
enum|;
end_enum

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|mdoc_fp
function_decl|)
parameter_list|(
name|struct
name|mpage
modifier|*
parameter_list|,
specifier|const
name|struct
name|mdoc_meta
modifier|*
parameter_list|,
specifier|const
name|struct
name|mdoc_node
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_struct
struct|struct
name|mdoc_handler
block|{
name|mdoc_fp
name|fp
decl_stmt|;
comment|/* optional handler */
name|uint64_t
name|mask
decl_stmt|;
comment|/* set unless handler returns 0 */
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|dbclose
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbadd
parameter_list|(
name|struct
name|mpage
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbadd_mlink
parameter_list|(
specifier|const
name|struct
name|mlink
modifier|*
name|mlink
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbadd_mlink_name
parameter_list|(
specifier|const
name|struct
name|mlink
modifier|*
name|mlink
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dbopen
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbprune
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|filescan
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|hash_alloc
parameter_list|(
name|size_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hash_free
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|hash_calloc
parameter_list|(
name|size_t
parameter_list|,
name|size_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mlink_add
parameter_list|(
name|struct
name|mlink
modifier|*
parameter_list|,
specifier|const
name|struct
name|stat
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mlink_check
parameter_list|(
name|struct
name|mpage
modifier|*
parameter_list|,
name|struct
name|mlink
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mlink_free
parameter_list|(
name|struct
name|mlink
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mlinks_undupe
parameter_list|(
name|struct
name|mpage
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpages_free
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpages_merge
parameter_list|(
name|struct
name|mparse
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|names_check
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_cat
parameter_list|(
name|struct
name|mpage
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_man
parameter_list|(
name|struct
name|mpage
modifier|*
parameter_list|,
specifier|const
name|struct
name|man_meta
modifier|*
parameter_list|,
specifier|const
name|struct
name|man_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_mdoc
parameter_list|(
name|struct
name|mpage
modifier|*
parameter_list|,
specifier|const
name|struct
name|mdoc_meta
modifier|*
parameter_list|,
specifier|const
name|struct
name|mdoc_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parse_mdoc_body
parameter_list|(
name|struct
name|mpage
modifier|*
parameter_list|,
specifier|const
name|struct
name|mdoc_meta
modifier|*
parameter_list|,
specifier|const
name|struct
name|mdoc_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parse_mdoc_head
parameter_list|(
name|struct
name|mpage
modifier|*
parameter_list|,
specifier|const
name|struct
name|mdoc_meta
modifier|*
parameter_list|,
specifier|const
name|struct
name|mdoc_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parse_mdoc_Fd
parameter_list|(
name|struct
name|mpage
modifier|*
parameter_list|,
specifier|const
name|struct
name|mdoc_meta
modifier|*
parameter_list|,
specifier|const
name|struct
name|mdoc_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_mdoc_fname
parameter_list|(
name|struct
name|mpage
modifier|*
parameter_list|,
specifier|const
name|struct
name|mdoc_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parse_mdoc_Fn
parameter_list|(
name|struct
name|mpage
modifier|*
parameter_list|,
specifier|const
name|struct
name|mdoc_meta
modifier|*
parameter_list|,
specifier|const
name|struct
name|mdoc_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parse_mdoc_Fo
parameter_list|(
name|struct
name|mpage
modifier|*
parameter_list|,
specifier|const
name|struct
name|mdoc_meta
modifier|*
parameter_list|,
specifier|const
name|struct
name|mdoc_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parse_mdoc_Nd
parameter_list|(
name|struct
name|mpage
modifier|*
parameter_list|,
specifier|const
name|struct
name|mdoc_meta
modifier|*
parameter_list|,
specifier|const
name|struct
name|mdoc_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parse_mdoc_Nm
parameter_list|(
name|struct
name|mpage
modifier|*
parameter_list|,
specifier|const
name|struct
name|mdoc_meta
modifier|*
parameter_list|,
specifier|const
name|struct
name|mdoc_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parse_mdoc_Sh
parameter_list|(
name|struct
name|mpage
modifier|*
parameter_list|,
specifier|const
name|struct
name|mdoc_meta
modifier|*
parameter_list|,
specifier|const
name|struct
name|mdoc_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parse_mdoc_Xr
parameter_list|(
name|struct
name|mpage
modifier|*
parameter_list|,
specifier|const
name|struct
name|mdoc_meta
modifier|*
parameter_list|,
specifier|const
name|struct
name|mdoc_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|putkey
parameter_list|(
specifier|const
name|struct
name|mpage
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|uint64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|putkeys
parameter_list|(
specifier|const
name|struct
name|mpage
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|uint64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|putmdockey
parameter_list|(
specifier|const
name|struct
name|mpage
modifier|*
parameter_list|,
specifier|const
name|struct
name|mdoc_node
modifier|*
parameter_list|,
name|uint64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|render_string
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|say
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_basedir
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|treescan
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|utf8
parameter_list|(
name|unsigned
name|int
parameter_list|,
name|char
index|[
literal|7
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|char
name|tempfilename
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nodb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* no database changes */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mparse_options
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* abort the parse early */
end_comment

begin_decl_stmt
specifier|static
name|int
name|use_all
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* use all found files */
end_comment

begin_decl_stmt
specifier|static
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* print what we're doing */
end_comment

begin_decl_stmt
specifier|static
name|int
name|warnings
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* warn about crap */
end_comment

begin_decl_stmt
specifier|static
name|int
name|write_utf8
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* write UTF-8 output; else ASCII */
end_comment

begin_decl_stmt
specifier|static
name|int
name|exitcode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* to be returned by main */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|op
name|op
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* operational mode */
end_comment

begin_decl_stmt
specifier|static
name|char
name|basedir
index|[
name|PATH_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current base directory */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mchars
modifier|*
name|mchars
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table of named characters */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ohash
name|mpages
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table of distinct manual pages */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ohash
name|mlinks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table of directory entries */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ohash
name|names
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table of all names */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ohash
name|strings
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table of all strings */
end_comment

begin_decl_stmt
specifier|static
name|sqlite3
modifier|*
name|db
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current database */
end_comment

begin_decl_stmt
specifier|static
name|sqlite3_stmt
modifier|*
name|stmts
index|[
name|STMT__MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current statements */
end_comment

begin_decl_stmt
specifier|static
name|uint64_t
name|name_mask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|mdoc_handler
name|mdocs
index|[
name|MDOC_MAX
index|]
init|=
block|{
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Ap */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Dd */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Dt */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Os */
block|{
name|parse_mdoc_Sh
block|,
name|TYPE_Sh
block|}
block|,
comment|/* Sh */
block|{
name|parse_mdoc_head
block|,
name|TYPE_Ss
block|}
block|,
comment|/* Ss */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Pp */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* D1 */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Dl */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Bd */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Ed */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Bl */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* El */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* It */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Ad */
block|{
name|NULL
block|,
name|TYPE_An
block|}
block|,
comment|/* An */
block|{
name|NULL
block|,
name|TYPE_Ar
block|}
block|,
comment|/* Ar */
block|{
name|NULL
block|,
name|TYPE_Cd
block|}
block|,
comment|/* Cd */
block|{
name|NULL
block|,
name|TYPE_Cm
block|}
block|,
comment|/* Cm */
block|{
name|NULL
block|,
name|TYPE_Dv
block|}
block|,
comment|/* Dv */
block|{
name|NULL
block|,
name|TYPE_Er
block|}
block|,
comment|/* Er */
block|{
name|NULL
block|,
name|TYPE_Ev
block|}
block|,
comment|/* Ev */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Ex */
block|{
name|NULL
block|,
name|TYPE_Fa
block|}
block|,
comment|/* Fa */
block|{
name|parse_mdoc_Fd
block|,
literal|0
block|}
block|,
comment|/* Fd */
block|{
name|NULL
block|,
name|TYPE_Fl
block|}
block|,
comment|/* Fl */
block|{
name|parse_mdoc_Fn
block|,
literal|0
block|}
block|,
comment|/* Fn */
block|{
name|NULL
block|,
name|TYPE_Ft
block|}
block|,
comment|/* Ft */
block|{
name|NULL
block|,
name|TYPE_Ic
block|}
block|,
comment|/* Ic */
block|{
name|NULL
block|,
name|TYPE_In
block|}
block|,
comment|/* In */
block|{
name|NULL
block|,
name|TYPE_Li
block|}
block|,
comment|/* Li */
block|{
name|parse_mdoc_Nd
block|,
literal|0
block|}
block|,
comment|/* Nd */
block|{
name|parse_mdoc_Nm
block|,
literal|0
block|}
block|,
comment|/* Nm */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Op */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Ot */
block|{
name|NULL
block|,
name|TYPE_Pa
block|}
block|,
comment|/* Pa */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Rv */
block|{
name|NULL
block|,
name|TYPE_St
block|}
block|,
comment|/* St */
block|{
name|NULL
block|,
name|TYPE_Va
block|}
block|,
comment|/* Va */
block|{
name|parse_mdoc_body
block|,
name|TYPE_Va
block|}
block|,
comment|/* Vt */
block|{
name|parse_mdoc_Xr
block|,
literal|0
block|}
block|,
comment|/* Xr */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* %A */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* %B */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* %D */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* %I */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* %J */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* %N */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* %O */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* %P */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* %R */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* %T */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* %V */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Ac */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Ao */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Aq */
block|{
name|NULL
block|,
name|TYPE_At
block|}
block|,
comment|/* At */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Bc */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Bf */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Bo */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Bq */
block|{
name|NULL
block|,
name|TYPE_Bsx
block|}
block|,
comment|/* Bsx */
block|{
name|NULL
block|,
name|TYPE_Bx
block|}
block|,
comment|/* Bx */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Db */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Dc */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Do */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Dq */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Ec */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Ef */
block|{
name|NULL
block|,
name|TYPE_Em
block|}
block|,
comment|/* Em */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Eo */
block|{
name|NULL
block|,
name|TYPE_Fx
block|}
block|,
comment|/* Fx */
block|{
name|NULL
block|,
name|TYPE_Ms
block|}
block|,
comment|/* Ms */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* No */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Ns */
block|{
name|NULL
block|,
name|TYPE_Nx
block|}
block|,
comment|/* Nx */
block|{
name|NULL
block|,
name|TYPE_Ox
block|}
block|,
comment|/* Ox */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Pc */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Pf */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Po */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Pq */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Qc */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Ql */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Qo */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Qq */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Re */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Rs */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Sc */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* So */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Sq */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Sm */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Sx */
block|{
name|NULL
block|,
name|TYPE_Sy
block|}
block|,
comment|/* Sy */
block|{
name|NULL
block|,
name|TYPE_Tn
block|}
block|,
comment|/* Tn */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Ux */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Xc */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Xo */
block|{
name|parse_mdoc_Fo
block|,
literal|0
block|}
block|,
comment|/* Fo */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Fc */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Oo */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Oc */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Bk */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Ek */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Bt */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Hf */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Fr */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Ud */
block|{
name|NULL
block|,
name|TYPE_Lb
block|}
block|,
comment|/* Lb */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Lp */
block|{
name|NULL
block|,
name|TYPE_Lk
block|}
block|,
comment|/* Lk */
block|{
name|NULL
block|,
name|TYPE_Mt
block|}
block|,
comment|/* Mt */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Brq */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Bro */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Brc */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* %C */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Es */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* En */
block|{
name|NULL
block|,
name|TYPE_Dx
block|}
block|,
comment|/* Dx */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* %Q */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* br */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* sp */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* %U */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* Ta */
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* ll */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|mandocdb
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|ch
decl_stmt|,
name|i
decl_stmt|;
name|size_t
name|j
decl_stmt|,
name|sz
decl_stmt|;
specifier|const
name|char
modifier|*
name|path_arg
decl_stmt|;
name|struct
name|manpaths
name|dirs
decl_stmt|;
name|struct
name|mparse
modifier|*
name|mp
decl_stmt|;
name|struct
name|ohash_info
name|mpages_info
decl_stmt|,
name|mlinks_info
decl_stmt|;
name|memset
argument_list|(
name|stmts
argument_list|,
literal|0
argument_list|,
name|STMT__MAX
operator|*
sizeof|sizeof
argument_list|(
name|sqlite3_stmt
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|dirs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|manpaths
argument_list|)
argument_list|)
expr_stmt|;
name|mpages_info
operator|.
name|alloc
operator|=
name|mlinks_info
operator|.
name|alloc
operator|=
name|hash_alloc
expr_stmt|;
name|mpages_info
operator|.
name|calloc
operator|=
name|mlinks_info
operator|.
name|calloc
operator|=
name|hash_calloc
expr_stmt|;
name|mpages_info
operator|.
name|free
operator|=
name|mlinks_info
operator|.
name|free
operator|=
name|hash_free
expr_stmt|;
name|mpages_info
operator|.
name|data
operator|=
name|mlinks_info
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
name|mpages_info
operator|.
name|key_offset
operator|=
name|offsetof
argument_list|(
expr|struct
name|mpage
argument_list|,
name|inodev
argument_list|)
expr_stmt|;
name|mlinks_info
operator|.
name|key_offset
operator|=
name|offsetof
argument_list|(
expr|struct
name|mlink
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|progname
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|progname
operator|==
name|NULL
condition|)
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
else|else
operator|++
name|progname
expr_stmt|;
comment|/* 	 * We accept a few different invocations. 	 * The CHECKOP macro makes sure that invocation styles don't 	 * clobber each other. 	 */
define|#
directive|define
name|CHECKOP
parameter_list|(
name|_op
parameter_list|,
name|_ch
parameter_list|)
value|do \ 	if (OP_DEFAULT != (_op)) { \ 		fprintf(stderr, "%s: -%c: Conflicting option\n", \ 		    progname, (_ch)); \ 		goto usage; \ 	} while (
comment|/*CONSTCOND*/
value|0)
name|path_arg
operator|=
name|NULL
expr_stmt|;
name|op
operator|=
name|OP_DEFAULT
expr_stmt|;
while|while
condition|(
operator|-
literal|1
operator|!=
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"aC:Dd:npQT:tu:v"
argument_list|)
operator|)
condition|)
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'a'
case|:
name|use_all
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|CHECKOP
argument_list|(
name|op
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|path_arg
operator|=
name|optarg
expr_stmt|;
name|op
operator|=
name|OP_CONFFILE
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|debug
operator|++
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|CHECKOP
argument_list|(
name|op
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|path_arg
operator|=
name|optarg
expr_stmt|;
name|op
operator|=
name|OP_UPDATE
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|nodb
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|warnings
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
name|mparse_options
operator||=
name|MPARSE_QUICK
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"utf8"
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: -T%s: "
literal|"Unsupported output format\n"
argument_list|,
name|progname
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
block|}
name|write_utf8
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|CHECKOP
argument_list|(
name|op
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|STDERR_FILENO
argument_list|)
expr_stmt|;
name|op
operator|=
name|OP_TEST
expr_stmt|;
name|nodb
operator|=
name|warnings
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|CHECKOP
argument_list|(
name|op
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|path_arg
operator|=
name|optarg
expr_stmt|;
name|op
operator|=
name|OP_DELETE
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* Compatibility with espie@'s makewhatis. */
break|break;
default|default:
goto|goto
name|usage
goto|;
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|OP_CONFFILE
operator|==
name|op
operator|&&
name|argc
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: -C: Too many arguments\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
block|}
name|exitcode
operator|=
operator|(
name|int
operator|)
name|MANDOCLEVEL_OK
expr_stmt|;
name|mchars
operator|=
name|mchars_alloc
argument_list|()
expr_stmt|;
name|mp
operator|=
name|mparse_alloc
argument_list|(
name|mparse_options
argument_list|,
name|MANDOCLEVEL_BADARG
argument_list|,
name|NULL
argument_list|,
name|mchars
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ohash_init
argument_list|(
operator|&
name|mpages
argument_list|,
literal|6
argument_list|,
operator|&
name|mpages_info
argument_list|)
expr_stmt|;
name|ohash_init
argument_list|(
operator|&
name|mlinks
argument_list|,
literal|6
argument_list|,
operator|&
name|mlinks_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|OP_UPDATE
operator|==
name|op
operator|||
name|OP_DELETE
operator|==
name|op
operator|||
name|OP_TEST
operator|==
name|op
condition|)
block|{
comment|/* 		 * Most of these deal with a specific directory. 		 * Jump into that directory first. 		 */
if|if
condition|(
name|OP_TEST
operator|!=
name|op
operator|&&
literal|0
operator|==
name|set_basedir
argument_list|(
name|path_arg
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|dbopen
argument_list|(
literal|1
argument_list|)
condition|)
block|{
comment|/* 			 * The existing database is usable.  Process 			 * all files specified on the command-line. 			 */
name|use_all
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
name|filescan
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|OP_TEST
operator|!=
name|op
condition|)
name|dbprune
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Database missing or corrupt. 			 * Recreate from scratch. 			 */
name|exitcode
operator|=
operator|(
name|int
operator|)
name|MANDOCLEVEL_OK
expr_stmt|;
name|op
operator|=
name|OP_DEFAULT
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|treescan
argument_list|()
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
literal|0
operator|==
name|dbopen
argument_list|(
literal|0
argument_list|)
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|OP_DELETE
operator|!=
name|op
condition|)
name|mpages_merge
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|dbclose
argument_list|(
name|OP_DEFAULT
operator|==
name|op
condition|?
literal|0
else|:
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If we have arguments, use them as our manpaths. 		 * If we don't, grok from manpath(1) or however else 		 * manpath_parse() wants to do it. 		 */
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
name|dirs
operator|.
name|paths
operator|=
name|mandoc_reallocarray
argument_list|(
name|NULL
argument_list|,
name|argc
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|dirs
operator|.
name|sz
operator|=
operator|(
name|size_t
operator|)
name|argc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
name|dirs
operator|.
name|paths
index|[
name|i
index|]
operator|=
name|mandoc_strdup
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|manpath_parse
argument_list|(
operator|&
name|dirs
argument_list|,
name|path_arg
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|dirs
operator|.
name|sz
condition|)
block|{
name|exitcode
operator|=
operator|(
name|int
operator|)
name|MANDOCLEVEL_BADARG
expr_stmt|;
name|say
argument_list|(
literal|""
argument_list|,
literal|"Empty manpath"
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * First scan the tree rooted at a base directory, then 		 * build a new database and finally move it into place. 		 * Ignore zero-length directories and strip trailing 		 * slashes. 		 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|dirs
operator|.
name|sz
condition|;
name|j
operator|++
control|)
block|{
name|sz
operator|=
name|strlen
argument_list|(
name|dirs
operator|.
name|paths
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sz
operator|&&
literal|'/'
operator|==
name|dirs
operator|.
name|paths
index|[
name|j
index|]
index|[
name|sz
operator|-
literal|1
index|]
condition|)
name|dirs
operator|.
name|paths
index|[
name|j
index|]
index|[
operator|--
name|sz
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|sz
condition|)
continue|continue;
if|if
condition|(
name|j
condition|)
block|{
name|ohash_init
argument_list|(
operator|&
name|mpages
argument_list|,
literal|6
argument_list|,
operator|&
name|mpages_info
argument_list|)
expr_stmt|;
name|ohash_init
argument_list|(
operator|&
name|mlinks
argument_list|,
literal|6
argument_list|,
operator|&
name|mlinks_info
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|==
name|set_basedir
argument_list|(
name|dirs
operator|.
name|paths
index|[
name|j
index|]
argument_list|,
name|argc
operator|>
literal|0
argument_list|)
condition|)
continue|continue;
if|if
condition|(
literal|0
operator|==
name|treescan
argument_list|()
condition|)
continue|continue;
if|if
condition|(
literal|0
operator|==
name|dbopen
argument_list|(
literal|0
argument_list|)
condition|)
continue|continue;
name|mpages_merge
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|warnings
operator|&&
operator|!
name|nodb
operator|&&
operator|!
operator|(
name|MPARSE_QUICK
operator|&
name|mparse_options
operator|)
condition|)
name|names_check
argument_list|()
expr_stmt|;
name|dbclose
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|+
literal|1
operator|<
name|dirs
operator|.
name|sz
condition|)
block|{
name|mpages_free
argument_list|()
expr_stmt|;
name|ohash_delete
argument_list|(
operator|&
name|mpages
argument_list|)
expr_stmt|;
name|ohash_delete
argument_list|(
operator|&
name|mlinks
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|out
label|:
name|manpath_free
argument_list|(
operator|&
name|dirs
argument_list|)
expr_stmt|;
name|mparse_free
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mchars_free
argument_list|(
name|mchars
argument_list|)
expr_stmt|;
name|mpages_free
argument_list|()
expr_stmt|;
name|ohash_delete
argument_list|(
operator|&
name|mpages
argument_list|)
expr_stmt|;
name|ohash_delete
argument_list|(
operator|&
name|mlinks
argument_list|)
expr_stmt|;
return|return
operator|(
name|exitcode
operator|)
return|;
name|usage
label|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [-aDnpQ] [-C file] [-Tutf8]\n"
literal|"       %s [-aDnpQ] [-Tutf8] dir ...\n"
literal|"       %s [-DnpQ] [-Tutf8] -d dir [file ...]\n"
literal|"       %s [-Dnp] -u dir [file ...]\n"
literal|"       %s [-Q] -t file ...\n"
argument_list|,
name|progname
argument_list|,
name|progname
argument_list|,
name|progname
argument_list|,
name|progname
argument_list|,
name|progname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_BADARG
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Scan a directory tree rooted at "basedir" for manpages.  * We use fts(), scanning directory parts along the way for clues to our  * section and architecture.  *  * If use_all has been specified, grok all files.  * If not, sanitise paths to the following:  *  *   [./]man*[/<arch>]/<name>.<section>  *   or  *   [./]cat<section>[/<arch>]/<name>.0  *  * TODO: accomodate for multi-language directories.  */
end_comment

begin_function
specifier|static
name|int
name|treescan
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|buf
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|FTS
modifier|*
name|f
decl_stmt|;
name|FTSENT
modifier|*
name|ff
decl_stmt|;
name|struct
name|mlink
modifier|*
name|mlink
decl_stmt|;
name|int
name|dform
decl_stmt|,
name|gzip
decl_stmt|;
name|char
modifier|*
name|dsec
decl_stmt|,
modifier|*
name|arch
decl_stmt|,
modifier|*
name|fsec
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|argv
index|[
literal|2
index|]
decl_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
literal|"."
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|f
operator|=
name|fts_open
argument_list|(
operator|(
name|char
operator|*
specifier|const
operator|*
operator|)
name|argv
argument_list|,
name|FTS_PHYSICAL
operator||
name|FTS_NOCHDIR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|f
condition|)
block|{
name|exitcode
operator|=
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
expr_stmt|;
name|say
argument_list|(
literal|""
argument_list|,
literal|"&fts_open"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dsec
operator|=
name|arch
operator|=
name|NULL
expr_stmt|;
name|dform
operator|=
name|FORM_NONE
expr_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|ff
operator|=
name|fts_read
argument_list|(
name|f
argument_list|)
operator|)
condition|)
block|{
name|path
operator|=
name|ff
operator|->
name|fts_path
operator|+
literal|2
expr_stmt|;
switch|switch
condition|(
name|ff
operator|->
name|fts_info
condition|)
block|{
comment|/* 		 * Symbolic links require various sanity checks, 		 * then get handled just like regular files. 		 */
case|case
name|FTS_SL
case|:
if|if
condition|(
name|NULL
operator|==
name|realpath
argument_list|(
name|path
argument_list|,
name|buf
argument_list|)
condition|)
block|{
if|if
condition|(
name|warnings
condition|)
name|say
argument_list|(
name|path
argument_list|,
literal|"&realpath"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strstr
argument_list|(
name|buf
argument_list|,
name|basedir
argument_list|)
operator|!=
name|buf
ifdef|#
directive|ifdef
name|HOMEBREWDIR
operator|&&
name|strstr
argument_list|(
name|buf
argument_list|,
name|HOMEBREWDIR
argument_list|)
operator|!=
name|buf
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
name|warnings
condition|)
name|say
argument_list|(
literal|""
argument_list|,
literal|"%s: outside base directory"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Use logical inode to avoid mpages dupe. */
if|if
condition|(
operator|-
literal|1
operator|==
name|stat
argument_list|(
name|path
argument_list|,
name|ff
operator|->
name|fts_statp
argument_list|)
condition|)
block|{
if|if
condition|(
name|warnings
condition|)
name|say
argument_list|(
name|path
argument_list|,
literal|"&stat"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* FALLTHROUGH */
comment|/* 		 * If we're a regular file, add an mlink by using the 		 * stored directory data and handling the filename. 		 */
case|case
name|FTS_F
case|:
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|path
argument_list|,
name|MANDOC_DB
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|use_all
operator|&&
name|ff
operator|->
name|fts_level
operator|<
literal|2
condition|)
block|{
if|if
condition|(
name|warnings
condition|)
name|say
argument_list|(
name|path
argument_list|,
literal|"Extraneous file"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|gzip
operator|=
literal|0
expr_stmt|;
name|fsec
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|NULL
operator|==
name|fsec
condition|)
block|{
name|fsec
operator|=
name|strrchr
argument_list|(
name|ff
operator|->
name|fts_name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|fsec
operator|||
name|strcmp
argument_list|(
name|fsec
operator|+
literal|1
argument_list|,
literal|"gz"
argument_list|)
condition|)
break|break;
name|gzip
operator|=
literal|1
expr_stmt|;
operator|*
name|fsec
operator|=
literal|'\0'
expr_stmt|;
name|fsec
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|NULL
operator|==
name|fsec
condition|)
block|{
if|if
condition|(
operator|!
name|use_all
condition|)
block|{
if|if
condition|(
name|warnings
condition|)
name|say
argument_list|(
name|path
argument_list|,
literal|"No filename suffix"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
operator|++
name|fsec
argument_list|,
literal|"html"
argument_list|)
condition|)
block|{
if|if
condition|(
name|warnings
condition|)
name|say
argument_list|(
name|path
argument_list|,
literal|"Skip html"
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|fsec
argument_list|,
literal|"ps"
argument_list|)
condition|)
block|{
if|if
condition|(
name|warnings
condition|)
name|say
argument_list|(
name|path
argument_list|,
literal|"Skip ps"
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|fsec
argument_list|,
literal|"pdf"
argument_list|)
condition|)
block|{
if|if
condition|(
name|warnings
condition|)
name|say
argument_list|(
name|path
argument_list|,
literal|"Skip pdf"
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
name|use_all
operator|&&
operator|(
operator|(
name|FORM_SRC
operator|==
name|dform
operator|&&
name|strncmp
argument_list|(
name|fsec
argument_list|,
name|dsec
argument_list|,
name|strlen
argument_list|(
name|dsec
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|FORM_CAT
operator|==
name|dform
operator|&&
name|strcmp
argument_list|(
name|fsec
argument_list|,
literal|"0"
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|warnings
condition|)
name|say
argument_list|(
name|path
argument_list|,
literal|"Wrong filename suffix"
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
name|fsec
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|mlink
operator|=
name|mandoc_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mlink
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlcpy
argument_list|(
name|mlink
operator|->
name|file
argument_list|,
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|mlink
operator|->
name|file
argument_list|)
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|mlink
operator|->
name|file
argument_list|)
condition|)
block|{
name|say
argument_list|(
name|path
argument_list|,
literal|"Filename too long"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mlink
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|mlink
operator|->
name|dform
operator|=
name|dform
expr_stmt|;
name|mlink
operator|->
name|dsec
operator|=
name|dsec
expr_stmt|;
name|mlink
operator|->
name|arch
operator|=
name|arch
expr_stmt|;
name|mlink
operator|->
name|name
operator|=
name|ff
operator|->
name|fts_name
expr_stmt|;
name|mlink
operator|->
name|fsec
operator|=
name|fsec
expr_stmt|;
name|mlink
operator|->
name|gzip
operator|=
name|gzip
expr_stmt|;
name|mlink_add
argument_list|(
name|mlink
argument_list|,
name|ff
operator|->
name|fts_statp
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|FTS_D
case|:
comment|/* FALLTHROUGH */
case|case
name|FTS_DP
case|:
break|break;
default|default:
if|if
condition|(
name|warnings
condition|)
name|say
argument_list|(
name|path
argument_list|,
literal|"Not a regular file"
argument_list|)
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|ff
operator|->
name|fts_level
condition|)
block|{
case|case
literal|0
case|:
comment|/* Ignore the root directory. */
break|break;
case|case
literal|1
case|:
comment|/* 			 * This might contain manX/ or catX/. 			 * Try to infer this from the name. 			 * If we're not in use_all, enforce it. 			 */
name|cp
operator|=
name|ff
operator|->
name|fts_name
expr_stmt|;
if|if
condition|(
name|FTS_DP
operator|==
name|ff
operator|->
name|fts_info
condition|)
break|break;
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"man"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|dform
operator|=
name|FORM_SRC
expr_stmt|;
name|dsec
operator|=
name|cp
operator|+
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"cat"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|dform
operator|=
name|FORM_CAT
expr_stmt|;
name|dsec
operator|=
name|cp
operator|+
literal|3
expr_stmt|;
block|}
else|else
block|{
name|dform
operator|=
name|FORM_NONE
expr_stmt|;
name|dsec
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|NULL
operator|!=
name|dsec
operator|||
name|use_all
condition|)
break|break;
if|if
condition|(
name|warnings
condition|)
name|say
argument_list|(
name|path
argument_list|,
literal|"Unknown directory part"
argument_list|)
expr_stmt|;
name|fts_set
argument_list|(
name|f
argument_list|,
name|ff
argument_list|,
name|FTS_SKIP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* 			 * Possibly our architecture. 			 * If we're descending, keep tabs on it. 			 */
if|if
condition|(
name|FTS_DP
operator|!=
name|ff
operator|->
name|fts_info
operator|&&
name|NULL
operator|!=
name|dsec
condition|)
name|arch
operator|=
name|ff
operator|->
name|fts_name
expr_stmt|;
else|else
name|arch
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|FTS_DP
operator|==
name|ff
operator|->
name|fts_info
operator|||
name|use_all
condition|)
break|break;
if|if
condition|(
name|warnings
condition|)
name|say
argument_list|(
name|path
argument_list|,
literal|"Extraneous directory part"
argument_list|)
expr_stmt|;
name|fts_set
argument_list|(
name|f
argument_list|,
name|ff
argument_list|,
name|FTS_SKIP
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|fts_close
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a file to the mlinks table.  * Do not verify that it's a "valid" looking manpage (we'll do that  * later).  *  * Try to infer the manual section, architecture, and page name from the  * path, assuming it looks like  *  *   [./]man*[/<arch>]/<name>.<section>  *   or  *   [./]cat<section>[/<arch>]/<name>.0  *  * See treescan() for the fts(3) version of this.  */
end_comment

begin_function
specifier|static
name|void
name|filescan
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|)
block|{
name|char
name|buf
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|struct
name|mlink
modifier|*
name|mlink
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|start
decl_stmt|;
name|assert
argument_list|(
name|use_all
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|file
argument_list|,
literal|"./"
argument_list|,
literal|2
argument_list|)
condition|)
name|file
operator|+=
literal|2
expr_stmt|;
comment|/* 	 * We have to do lstat(2) before realpath(3) loses 	 * the information whether this is a symbolic link. 	 * We need to know that because for symbolic links, 	 * we want to use the orginal file name, while for 	 * regular files, we want to use the real path. 	 */
if|if
condition|(
operator|-
literal|1
operator|==
name|lstat
argument_list|(
name|file
argument_list|,
operator|&
name|st
argument_list|)
condition|)
block|{
name|exitcode
operator|=
operator|(
name|int
operator|)
name|MANDOCLEVEL_BADARG
expr_stmt|;
name|say
argument_list|(
name|file
argument_list|,
literal|"&lstat"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
literal|0
operator|==
operator|(
operator|(
name|S_IFREG
operator||
name|S_IFLNK
operator|)
operator|&
name|st
operator|.
name|st_mode
operator|)
condition|)
block|{
name|exitcode
operator|=
operator|(
name|int
operator|)
name|MANDOCLEVEL_BADARG
expr_stmt|;
name|say
argument_list|(
name|file
argument_list|,
literal|"Not a regular file"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * We have to resolve the file name to the real path 	 * in any case for the base directory check. 	 */
if|if
condition|(
name|NULL
operator|==
name|realpath
argument_list|(
name|file
argument_list|,
name|buf
argument_list|)
condition|)
block|{
name|exitcode
operator|=
operator|(
name|int
operator|)
name|MANDOCLEVEL_BADARG
expr_stmt|;
name|say
argument_list|(
name|file
argument_list|,
literal|"&realpath"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|OP_TEST
operator|==
name|op
condition|)
name|start
operator|=
name|buf
expr_stmt|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|buf
argument_list|,
name|basedir
argument_list|)
operator|==
name|buf
condition|)
name|start
operator|=
name|buf
operator|+
name|strlen
argument_list|(
name|basedir
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HOMEBREWDIR
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|buf
argument_list|,
name|HOMEBREWDIR
argument_list|)
operator|==
name|buf
condition|)
name|start
operator|=
name|buf
expr_stmt|;
endif|#
directive|endif
else|else
block|{
name|exitcode
operator|=
operator|(
name|int
operator|)
name|MANDOCLEVEL_BADARG
expr_stmt|;
name|say
argument_list|(
literal|""
argument_list|,
literal|"%s: outside base directory"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Now we are sure the file is inside our tree. 	 * If it is a symbolic link, ignore the real path 	 * and use the original name. 	 * This implies passing stuff like "cat1/../man1/foo.1" 	 * on the command line won't work.  So don't do that. 	 * Note the stat(2) can still fail if the link target 	 * doesn't exist. 	 */
if|if
condition|(
name|S_IFLNK
operator|&
name|st
operator|.
name|st_mode
condition|)
block|{
if|if
condition|(
operator|-
literal|1
operator|==
name|stat
argument_list|(
name|buf
argument_list|,
operator|&
name|st
argument_list|)
condition|)
block|{
name|exitcode
operator|=
operator|(
name|int
operator|)
name|MANDOCLEVEL_BADARG
expr_stmt|;
name|say
argument_list|(
name|file
argument_list|,
literal|"&stat"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|file
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
block|{
name|say
argument_list|(
name|file
argument_list|,
literal|"Filename too long"
argument_list|)
expr_stmt|;
return|return;
block|}
name|start
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|OP_TEST
operator|!=
name|op
operator|&&
name|strstr
argument_list|(
name|buf
argument_list|,
name|basedir
argument_list|)
operator|==
name|buf
condition|)
name|start
operator|+=
name|strlen
argument_list|(
name|basedir
argument_list|)
expr_stmt|;
block|}
name|mlink
operator|=
name|mandoc_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mlink
argument_list|)
argument_list|)
expr_stmt|;
name|mlink
operator|->
name|dform
operator|=
name|FORM_NONE
expr_stmt|;
if|if
condition|(
name|strlcpy
argument_list|(
name|mlink
operator|->
name|file
argument_list|,
name|start
argument_list|,
sizeof|sizeof
argument_list|(
name|mlink
operator|->
name|file
argument_list|)
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|mlink
operator|->
name|file
argument_list|)
condition|)
block|{
name|say
argument_list|(
name|start
argument_list|,
literal|"Filename too long"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mlink
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * First try to guess our directory structure. 	 * If we find a separator, try to look for man* or cat*. 	 * If we find one of these and what's underneath is a directory, 	 * assume it's an architecture. 	 */
if|if
condition|(
name|NULL
operator|!=
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|start
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|start
argument_list|,
literal|"man"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|mlink
operator|->
name|dform
operator|=
name|FORM_SRC
expr_stmt|;
name|mlink
operator|->
name|dsec
operator|=
name|start
operator|+
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|start
argument_list|,
literal|"cat"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|mlink
operator|->
name|dform
operator|=
name|FORM_CAT
expr_stmt|;
name|mlink
operator|->
name|dsec
operator|=
name|start
operator|+
literal|3
expr_stmt|;
block|}
name|start
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|mlink
operator|->
name|dsec
operator|&&
name|NULL
operator|!=
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|start
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|mlink
operator|->
name|arch
operator|=
name|start
expr_stmt|;
name|start
operator|=
name|p
expr_stmt|;
block|}
block|}
comment|/* 	 * Now check the file suffix. 	 * Suffix of `.0' indicates a catpage, `.1-9' is a manpage. 	 */
name|p
operator|=
name|strrchr
argument_list|(
name|start
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|--
operator|>
name|start
operator|&&
literal|'/'
operator|!=
operator|*
name|p
operator|&&
literal|'.'
operator|!=
operator|*
name|p
condition|)
comment|/* Loop. */
empty_stmt|;
if|if
condition|(
literal|'.'
operator|==
operator|*
name|p
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|mlink
operator|->
name|fsec
operator|=
name|p
expr_stmt|;
block|}
comment|/* 	 * Now try to parse the name. 	 * Use the filename portion of the path. 	 */
name|mlink
operator|->
name|name
operator|=
name|start
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|start
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|)
block|{
name|mlink
operator|->
name|name
operator|=
name|p
operator|+
literal|1
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
name|mlink_add
argument_list|(
name|mlink
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlink_add
parameter_list|(
name|struct
name|mlink
modifier|*
name|mlink
parameter_list|,
specifier|const
name|struct
name|stat
modifier|*
name|st
parameter_list|)
block|{
name|struct
name|inodev
name|inodev
decl_stmt|;
name|struct
name|mpage
modifier|*
name|mpage
decl_stmt|;
name|unsigned
name|int
name|slot
decl_stmt|;
name|assert
argument_list|(
name|NULL
operator|!=
name|mlink
operator|->
name|file
argument_list|)
expr_stmt|;
name|mlink
operator|->
name|dsec
operator|=
name|mandoc_strdup
argument_list|(
name|mlink
operator|->
name|dsec
condition|?
name|mlink
operator|->
name|dsec
else|:
literal|""
argument_list|)
expr_stmt|;
name|mlink
operator|->
name|arch
operator|=
name|mandoc_strdup
argument_list|(
name|mlink
operator|->
name|arch
condition|?
name|mlink
operator|->
name|arch
else|:
literal|""
argument_list|)
expr_stmt|;
name|mlink
operator|->
name|name
operator|=
name|mandoc_strdup
argument_list|(
name|mlink
operator|->
name|name
condition|?
name|mlink
operator|->
name|name
else|:
literal|""
argument_list|)
expr_stmt|;
name|mlink
operator|->
name|fsec
operator|=
name|mandoc_strdup
argument_list|(
name|mlink
operator|->
name|fsec
condition|?
name|mlink
operator|->
name|fsec
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
literal|'0'
operator|==
operator|*
name|mlink
operator|->
name|fsec
condition|)
block|{
name|free
argument_list|(
name|mlink
operator|->
name|fsec
argument_list|)
expr_stmt|;
name|mlink
operator|->
name|fsec
operator|=
name|mandoc_strdup
argument_list|(
name|mlink
operator|->
name|dsec
argument_list|)
expr_stmt|;
name|mlink
operator|->
name|fform
operator|=
name|FORM_CAT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|'1'
operator|<=
operator|*
name|mlink
operator|->
name|fsec
operator|&&
literal|'9'
operator|>=
operator|*
name|mlink
operator|->
name|fsec
condition|)
name|mlink
operator|->
name|fform
operator|=
name|FORM_SRC
expr_stmt|;
else|else
name|mlink
operator|->
name|fform
operator|=
name|FORM_NONE
expr_stmt|;
name|slot
operator|=
name|ohash_qlookup
argument_list|(
operator|&
name|mlinks
argument_list|,
name|mlink
operator|->
name|file
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|NULL
operator|==
name|ohash_find
argument_list|(
operator|&
name|mlinks
argument_list|,
name|slot
argument_list|)
argument_list|)
expr_stmt|;
name|ohash_insert
argument_list|(
operator|&
name|mlinks
argument_list|,
name|slot
argument_list|,
name|mlink
argument_list|)
expr_stmt|;
name|inodev
operator|.
name|st_ino
operator|=
name|st
operator|->
name|st_ino
expr_stmt|;
name|inodev
operator|.
name|st_dev
operator|=
name|st
operator|->
name|st_dev
expr_stmt|;
name|slot
operator|=
name|ohash_lookup_memory
argument_list|(
operator|&
name|mpages
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|inodev
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|inodev
argument_list|)
argument_list|,
name|inodev
operator|.
name|st_ino
argument_list|)
expr_stmt|;
name|mpage
operator|=
name|ohash_find
argument_list|(
operator|&
name|mpages
argument_list|,
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|mpage
condition|)
block|{
name|mpage
operator|=
name|mandoc_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mpage
argument_list|)
argument_list|)
expr_stmt|;
name|mpage
operator|->
name|inodev
operator|.
name|st_ino
operator|=
name|inodev
operator|.
name|st_ino
expr_stmt|;
name|mpage
operator|->
name|inodev
operator|.
name|st_dev
operator|=
name|inodev
operator|.
name|st_dev
expr_stmt|;
name|ohash_insert
argument_list|(
operator|&
name|mpages
argument_list|,
name|slot
argument_list|,
name|mpage
argument_list|)
expr_stmt|;
block|}
else|else
name|mlink
operator|->
name|next
operator|=
name|mpage
operator|->
name|mlinks
expr_stmt|;
name|mpage
operator|->
name|mlinks
operator|=
name|mlink
expr_stmt|;
name|mlink
operator|->
name|mpage
operator|=
name|mpage
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlink_free
parameter_list|(
name|struct
name|mlink
modifier|*
name|mlink
parameter_list|)
block|{
name|free
argument_list|(
name|mlink
operator|->
name|dsec
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mlink
operator|->
name|arch
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mlink
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mlink
operator|->
name|fsec
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mlink
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpages_free
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|mpage
modifier|*
name|mpage
decl_stmt|;
name|struct
name|mlink
modifier|*
name|mlink
decl_stmt|;
name|unsigned
name|int
name|slot
decl_stmt|;
name|mpage
operator|=
name|ohash_first
argument_list|(
operator|&
name|mpages
argument_list|,
operator|&
name|slot
argument_list|)
expr_stmt|;
while|while
condition|(
name|NULL
operator|!=
name|mpage
condition|)
block|{
while|while
condition|(
name|NULL
operator|!=
operator|(
name|mlink
operator|=
name|mpage
operator|->
name|mlinks
operator|)
condition|)
block|{
name|mpage
operator|->
name|mlinks
operator|=
name|mlink
operator|->
name|next
expr_stmt|;
name|mlink_free
argument_list|(
name|mlink
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|mpage
operator|->
name|sec
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mpage
operator|->
name|arch
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mpage
operator|->
name|title
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mpage
operator|->
name|desc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mpage
argument_list|)
expr_stmt|;
name|mpage
operator|=
name|ohash_next
argument_list|(
operator|&
name|mpages
argument_list|,
operator|&
name|slot
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * For each mlink to the mpage, check whether the path looks like  * it is formatted, and if it does, check whether a source manual  * exists by the same name, ignoring the suffix.  * If both conditions hold, drop the mlink.  */
end_comment

begin_function
specifier|static
name|void
name|mlinks_undupe
parameter_list|(
name|struct
name|mpage
modifier|*
name|mpage
parameter_list|)
block|{
name|char
name|buf
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|struct
name|mlink
modifier|*
modifier|*
name|prev
decl_stmt|;
name|struct
name|mlink
modifier|*
name|mlink
decl_stmt|;
name|char
modifier|*
name|bufp
decl_stmt|;
name|mpage
operator|->
name|form
operator|=
name|FORM_CAT
expr_stmt|;
name|prev
operator|=
operator|&
name|mpage
operator|->
name|mlinks
expr_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|mlink
operator|=
operator|*
name|prev
operator|)
condition|)
block|{
if|if
condition|(
name|FORM_CAT
operator|!=
name|mlink
operator|->
name|dform
condition|)
block|{
name|mpage
operator|->
name|form
operator|=
name|FORM_NONE
expr_stmt|;
goto|goto
name|nextlink
goto|;
block|}
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|mlink
operator|->
name|file
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|bufp
operator|=
name|strstr
argument_list|(
name|buf
argument_list|,
literal|"cat"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|NULL
operator|!=
name|bufp
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|bufp
argument_list|,
literal|"man"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|bufp
operator|=
name|strrchr
argument_list|(
name|buf
argument_list|,
literal|'.'
argument_list|)
operator|)
condition|)
operator|*
operator|++
name|bufp
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|buf
argument_list|,
name|mlink
operator|->
name|dsec
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|ohash_find
argument_list|(
operator|&
name|mlinks
argument_list|,
name|ohash_qlookup
argument_list|(
operator|&
name|mlinks
argument_list|,
name|buf
argument_list|)
argument_list|)
condition|)
goto|goto
name|nextlink
goto|;
if|if
condition|(
name|warnings
condition|)
name|say
argument_list|(
name|mlink
operator|->
name|file
argument_list|,
literal|"Man source exists: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_all
condition|)
goto|goto
name|nextlink
goto|;
operator|*
name|prev
operator|=
name|mlink
operator|->
name|next
expr_stmt|;
name|mlink_free
argument_list|(
name|mlink
argument_list|)
expr_stmt|;
continue|continue;
name|nextlink
label|:
name|prev
operator|=
operator|&
operator|(
operator|*
name|prev
operator|)
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mlink_check
parameter_list|(
name|struct
name|mpage
modifier|*
name|mpage
parameter_list|,
name|struct
name|mlink
modifier|*
name|mlink
parameter_list|)
block|{
name|struct
name|str
modifier|*
name|str
decl_stmt|;
name|unsigned
name|int
name|slot
decl_stmt|;
comment|/* 	 * Check whether the manual section given in a file 	 * agrees with the directory where the file is located. 	 * Some manuals have suffixes like (3p) on their 	 * section number either inside the file or in the 	 * directory name, some are linked into more than one 	 * section, like encrypt(1) = makekey(8). 	 */
if|if
condition|(
name|FORM_SRC
operator|==
name|mpage
operator|->
name|form
operator|&&
name|strcasecmp
argument_list|(
name|mpage
operator|->
name|sec
argument_list|,
name|mlink
operator|->
name|dsec
argument_list|)
condition|)
name|say
argument_list|(
name|mlink
operator|->
name|file
argument_list|,
literal|"Section \"%s\" manual in %s directory"
argument_list|,
name|mpage
operator|->
name|sec
argument_list|,
name|mlink
operator|->
name|dsec
argument_list|)
expr_stmt|;
comment|/* 	 * Manual page directories exist for each kernel 	 * architecture as returned by machine(1). 	 * However, many manuals only depend on the 	 * application architecture as returned by arch(1). 	 * For example, some (2/ARM) manuals are shared 	 * across the "armish" and "zaurus" kernel 	 * architectures. 	 * A few manuals are even shared across completely 	 * different architectures, for example fdformat(1) 	 * on amd64, i386, sparc, and sparc64. 	 */
if|if
condition|(
name|strcasecmp
argument_list|(
name|mpage
operator|->
name|arch
argument_list|,
name|mlink
operator|->
name|arch
argument_list|)
condition|)
name|say
argument_list|(
name|mlink
operator|->
name|file
argument_list|,
literal|"Architecture \"%s\" manual in "
literal|"\"%s\" directory"
argument_list|,
name|mpage
operator|->
name|arch
argument_list|,
name|mlink
operator|->
name|arch
argument_list|)
expr_stmt|;
comment|/* 	 * XXX 	 * parse_cat() doesn't set NAME_TITLE yet. 	 */
if|if
condition|(
name|FORM_CAT
operator|==
name|mpage
operator|->
name|form
condition|)
return|return;
comment|/* 	 * Check whether this mlink 	 * appears as a name in the NAME section. 	 */
name|slot
operator|=
name|ohash_qlookup
argument_list|(
operator|&
name|names
argument_list|,
name|mlink
operator|->
name|name
argument_list|)
expr_stmt|;
name|str
operator|=
name|ohash_find
argument_list|(
operator|&
name|names
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|NULL
operator|!=
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|NAME_TITLE
operator|&
name|str
operator|->
name|mask
operator|)
condition|)
name|say
argument_list|(
name|mlink
operator|->
name|file
argument_list|,
literal|"Name missing in NAME section"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Run through the files in the global vector "mpages"  * and add them to the database specified in "basedir".  *  * This handles the parsing scheme itself, using the cues of directory  * and filename to determine whether the file is parsable or not.  */
end_comment

begin_function
specifier|static
name|void
name|mpages_merge
parameter_list|(
name|struct
name|mparse
modifier|*
name|mp
parameter_list|)
block|{
name|char
name|any
index|[]
init|=
literal|"any"
decl_stmt|;
name|struct
name|ohash_info
name|str_info
decl_stmt|;
name|struct
name|mpage
modifier|*
name|mpage
decl_stmt|,
modifier|*
name|mpage_dest
decl_stmt|;
name|struct
name|mlink
modifier|*
name|mlink
decl_stmt|,
modifier|*
name|mlink_dest
decl_stmt|;
name|struct
name|mdoc
modifier|*
name|mdoc
decl_stmt|;
name|struct
name|man
modifier|*
name|man
decl_stmt|;
name|char
modifier|*
name|sodest
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|unsigned
name|int
name|pslot
decl_stmt|;
name|str_info
operator|.
name|alloc
operator|=
name|hash_alloc
expr_stmt|;
name|str_info
operator|.
name|calloc
operator|=
name|hash_calloc
expr_stmt|;
name|str_info
operator|.
name|free
operator|=
name|hash_free
expr_stmt|;
name|str_info
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
name|str_info
operator|.
name|key_offset
operator|=
name|offsetof
argument_list|(
expr|struct
name|str
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nodb
condition|)
name|SQL_EXEC
argument_list|(
literal|"BEGIN TRANSACTION"
argument_list|)
expr_stmt|;
name|mpage
operator|=
name|ohash_first
argument_list|(
operator|&
name|mpages
argument_list|,
operator|&
name|pslot
argument_list|)
expr_stmt|;
while|while
condition|(
name|mpage
operator|!=
name|NULL
condition|)
block|{
name|mlinks_undupe
argument_list|(
name|mpage
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mlink
operator|=
name|mpage
operator|->
name|mlinks
operator|)
operator|==
name|NULL
condition|)
block|{
name|mpage
operator|=
name|ohash_next
argument_list|(
operator|&
name|mpages
argument_list|,
operator|&
name|pslot
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|name_mask
operator|=
name|NAME_MASK
expr_stmt|;
name|ohash_init
argument_list|(
operator|&
name|names
argument_list|,
literal|4
argument_list|,
operator|&
name|str_info
argument_list|)
expr_stmt|;
name|ohash_init
argument_list|(
operator|&
name|strings
argument_list|,
literal|6
argument_list|,
operator|&
name|str_info
argument_list|)
expr_stmt|;
name|mparse_reset
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mdoc
operator|=
name|NULL
expr_stmt|;
name|man
operator|=
name|NULL
expr_stmt|;
name|sodest
operator|=
name|NULL
expr_stmt|;
name|mparse_open
argument_list|(
name|mp
argument_list|,
operator|&
name|fd
argument_list|,
name|mlink
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|say
argument_list|(
name|mlink
operator|->
name|file
argument_list|,
literal|"&open"
argument_list|)
expr_stmt|;
goto|goto
name|nextpage
goto|;
block|}
comment|/* 		 * Interpret the file as mdoc(7) or man(7) source 		 * code, unless it is known to be formatted. 		 */
if|if
condition|(
name|mlink
operator|->
name|dform
operator|!=
name|FORM_CAT
operator|||
name|mlink
operator|->
name|fform
operator|!=
name|FORM_CAT
condition|)
block|{
name|mparse_readfd
argument_list|(
name|mp
argument_list|,
name|fd
argument_list|,
name|mlink
operator|->
name|file
argument_list|)
expr_stmt|;
name|mparse_result
argument_list|(
name|mp
argument_list|,
operator|&
name|mdoc
argument_list|,
operator|&
name|man
argument_list|,
operator|&
name|sodest
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sodest
operator|!=
name|NULL
condition|)
block|{
name|mlink_dest
operator|=
name|ohash_find
argument_list|(
operator|&
name|mlinks
argument_list|,
name|ohash_qlookup
argument_list|(
operator|&
name|mlinks
argument_list|,
name|sodest
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlink_dest
operator|==
name|NULL
condition|)
block|{
name|mandoc_asprintf
argument_list|(
operator|&
name|cp
argument_list|,
literal|"%s.gz"
argument_list|,
name|sodest
argument_list|)
expr_stmt|;
name|mlink_dest
operator|=
name|ohash_find
argument_list|(
operator|&
name|mlinks
argument_list|,
name|ohash_qlookup
argument_list|(
operator|&
name|mlinks
argument_list|,
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mlink_dest
operator|!=
name|NULL
condition|)
block|{
comment|/* The .so target exists. */
name|mpage_dest
operator|=
name|mlink_dest
operator|->
name|mpage
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|mlink
operator|->
name|mpage
operator|=
name|mpage_dest
expr_stmt|;
comment|/* 					 * If the target was already 					 * processed, add the links 					 * to the database now. 					 * Otherwise, this will 					 * happen when we come 					 * to the target. 					 */
if|if
condition|(
name|mpage_dest
operator|->
name|pageid
condition|)
name|dbadd_mlink_name
argument_list|(
name|mlink
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlink
operator|->
name|next
operator|==
name|NULL
condition|)
break|break;
name|mlink
operator|=
name|mlink
operator|->
name|next
expr_stmt|;
block|}
comment|/* Move all links to the target. */
name|mlink
operator|->
name|next
operator|=
name|mlink_dest
operator|->
name|next
expr_stmt|;
name|mlink_dest
operator|->
name|next
operator|=
name|mpage
operator|->
name|mlinks
expr_stmt|;
name|mpage
operator|->
name|mlinks
operator|=
name|NULL
expr_stmt|;
block|}
goto|goto
name|nextpage
goto|;
block|}
elseif|else
if|if
condition|(
name|mdoc
operator|!=
name|NULL
condition|)
block|{
name|mpage
operator|->
name|form
operator|=
name|FORM_SRC
expr_stmt|;
name|mpage
operator|->
name|sec
operator|=
name|mdoc_meta
argument_list|(
name|mdoc
argument_list|)
operator|->
name|msec
expr_stmt|;
name|mpage
operator|->
name|sec
operator|=
name|mandoc_strdup
argument_list|(
name|mpage
operator|->
name|sec
operator|==
name|NULL
condition|?
literal|""
else|:
name|mpage
operator|->
name|sec
argument_list|)
expr_stmt|;
name|mpage
operator|->
name|arch
operator|=
name|mdoc_meta
argument_list|(
name|mdoc
argument_list|)
operator|->
name|arch
expr_stmt|;
name|mpage
operator|->
name|arch
operator|=
name|mandoc_strdup
argument_list|(
name|mpage
operator|->
name|arch
operator|==
name|NULL
condition|?
literal|""
else|:
name|mpage
operator|->
name|arch
argument_list|)
expr_stmt|;
name|mpage
operator|->
name|title
operator|=
name|mandoc_strdup
argument_list|(
name|mdoc_meta
argument_list|(
name|mdoc
argument_list|)
operator|->
name|title
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|man
operator|!=
name|NULL
condition|)
block|{
name|mpage
operator|->
name|form
operator|=
name|FORM_SRC
expr_stmt|;
name|mpage
operator|->
name|sec
operator|=
name|mandoc_strdup
argument_list|(
name|man_meta
argument_list|(
name|man
argument_list|)
operator|->
name|msec
argument_list|)
expr_stmt|;
name|mpage
operator|->
name|arch
operator|=
name|mandoc_strdup
argument_list|(
name|mlink
operator|->
name|arch
argument_list|)
expr_stmt|;
name|mpage
operator|->
name|title
operator|=
name|mandoc_strdup
argument_list|(
name|man_meta
argument_list|(
name|man
argument_list|)
operator|->
name|title
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mpage
operator|->
name|form
operator|=
name|FORM_CAT
expr_stmt|;
name|mpage
operator|->
name|sec
operator|=
name|mandoc_strdup
argument_list|(
name|mlink
operator|->
name|dsec
argument_list|)
expr_stmt|;
name|mpage
operator|->
name|arch
operator|=
name|mandoc_strdup
argument_list|(
name|mlink
operator|->
name|arch
argument_list|)
expr_stmt|;
name|mpage
operator|->
name|title
operator|=
name|mandoc_strdup
argument_list|(
name|mlink
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|putkey
argument_list|(
name|mpage
argument_list|,
name|mpage
operator|->
name|sec
argument_list|,
name|TYPE_sec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mpage
operator|->
name|arch
operator|!=
literal|'\0'
condition|)
name|putkey
argument_list|(
name|mpage
argument_list|,
name|mpage
operator|->
name|arch
argument_list|,
name|TYPE_arch
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|mlink
operator|!=
name|NULL
condition|;
name|mlink
operator|=
name|mlink
operator|->
name|next
control|)
block|{
if|if
condition|(
literal|'\0'
operator|!=
operator|*
name|mlink
operator|->
name|dsec
condition|)
name|putkey
argument_list|(
name|mpage
argument_list|,
name|mlink
operator|->
name|dsec
argument_list|,
name|TYPE_sec
argument_list|)
expr_stmt|;
if|if
condition|(
literal|'\0'
operator|!=
operator|*
name|mlink
operator|->
name|fsec
condition|)
name|putkey
argument_list|(
name|mpage
argument_list|,
name|mlink
operator|->
name|fsec
argument_list|,
name|TYPE_sec
argument_list|)
expr_stmt|;
name|putkey
argument_list|(
name|mpage
argument_list|,
literal|'\0'
operator|==
operator|*
name|mlink
operator|->
name|arch
condition|?
name|any
else|:
name|mlink
operator|->
name|arch
argument_list|,
name|TYPE_arch
argument_list|)
expr_stmt|;
name|putkey
argument_list|(
name|mpage
argument_list|,
name|mlink
operator|->
name|name
argument_list|,
name|NAME_FILE
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|mpage
operator|->
name|desc
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdoc
operator|!=
name|NULL
condition|)
name|parse_mdoc
argument_list|(
name|mpage
argument_list|,
name|mdoc_meta
argument_list|(
name|mdoc
argument_list|)
argument_list|,
name|mdoc_node
argument_list|(
name|mdoc
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|man
operator|!=
name|NULL
condition|)
name|parse_man
argument_list|(
name|mpage
argument_list|,
name|man_meta
argument_list|(
name|man
argument_list|)
argument_list|,
name|man_node
argument_list|(
name|man
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|parse_cat
argument_list|(
name|mpage
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpage
operator|->
name|desc
operator|==
name|NULL
condition|)
name|mpage
operator|->
name|desc
operator|=
name|mandoc_strdup
argument_list|(
name|mpage
operator|->
name|mlinks
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|warnings
operator|&&
operator|!
name|use_all
condition|)
for|for
control|(
name|mlink
operator|=
name|mpage
operator|->
name|mlinks
init|;
name|mlink
condition|;
name|mlink
operator|=
name|mlink
operator|->
name|next
control|)
name|mlink_check
argument_list|(
name|mpage
argument_list|,
name|mlink
argument_list|)
expr_stmt|;
name|dbadd
argument_list|(
name|mpage
argument_list|)
expr_stmt|;
name|mlink
operator|=
name|mpage
operator|->
name|mlinks
expr_stmt|;
name|nextpage
label|:
if|if
condition|(
name|mparse_wait
argument_list|(
name|mp
argument_list|)
operator|!=
name|MANDOCLEVEL_OK
condition|)
block|{
name|exitcode
operator|=
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
expr_stmt|;
name|say
argument_list|(
name|mlink
operator|->
name|file
argument_list|,
literal|"&wait gunzip"
argument_list|)
expr_stmt|;
block|}
name|ohash_delete
argument_list|(
operator|&
name|strings
argument_list|)
expr_stmt|;
name|ohash_delete
argument_list|(
operator|&
name|names
argument_list|)
expr_stmt|;
name|mpage
operator|=
name|ohash_next
argument_list|(
operator|&
name|mpages
argument_list|,
operator|&
name|pslot
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|==
name|nodb
condition|)
name|SQL_EXEC
argument_list|(
literal|"END TRANSACTION"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|names_check
parameter_list|(
name|void
parameter_list|)
block|{
name|sqlite3_stmt
modifier|*
name|stmt
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|sec
decl_stmt|,
modifier|*
name|arch
decl_stmt|,
modifier|*
name|key
decl_stmt|;
name|int
name|irc
decl_stmt|;
name|sqlite3_prepare_v2
argument_list|(
name|db
argument_list|,
literal|"SELECT name, sec, arch, key FROM ("
literal|"SELECT name AS key, pageid FROM names "
literal|"WHERE bits& ? AND NOT EXISTS ("
literal|"SELECT pageid FROM mlinks "
literal|"WHERE mlinks.pageid == names.pageid "
literal|"AND mlinks.name == names.name"
literal|")"
literal|") JOIN ("
literal|"SELECT sec, arch, name, pageid FROM mlinks "
literal|"GROUP BY pageid"
literal|") USING (pageid);"
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|stmt
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|SQLITE_OK
operator|!=
name|sqlite3_bind_int64
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|,
name|NAME_TITLE
argument_list|)
condition|)
name|say
argument_list|(
literal|""
argument_list|,
literal|"%s"
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|db
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|SQLITE_ROW
operator|==
operator|(
name|irc
operator|=
name|sqlite3_step
argument_list|(
name|stmt
argument_list|)
operator|)
condition|)
block|{
name|name
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sec
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|arch
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|stmt
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|key
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sqlite3_column_text
argument_list|(
name|stmt
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|say
argument_list|(
literal|""
argument_list|,
literal|"%s(%s%s%s) lacks mlink \"%s\""
argument_list|,
name|name
argument_list|,
name|sec
argument_list|,
literal|'\0'
operator|==
operator|*
name|arch
condition|?
literal|""
else|:
literal|"/"
argument_list|,
literal|'\0'
operator|==
operator|*
name|arch
condition|?
literal|""
else|:
name|arch
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
name|sqlite3_finalize
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|parse_cat
parameter_list|(
name|struct
name|mpage
modifier|*
name|mpage
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|title
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|plen
decl_stmt|,
name|titlesz
decl_stmt|;
name|stream
operator|=
operator|(
operator|-
literal|1
operator|==
name|fd
operator|)
condition|?
name|fopen
argument_list|(
name|mpage
operator|->
name|mlinks
operator|->
name|file
argument_list|,
literal|"r"
argument_list|)
else|:
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|stream
condition|)
block|{
if|if
condition|(
operator|-
literal|1
operator|!=
name|fd
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|warnings
condition|)
name|say
argument_list|(
name|mpage
operator|->
name|mlinks
operator|->
name|file
argument_list|,
literal|"&fopen"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Skip to first blank line. */
while|while
condition|(
name|NULL
operator|!=
operator|(
name|line
operator|=
name|fgetln
argument_list|(
name|stream
argument_list|,
operator|&
name|len
argument_list|)
operator|)
condition|)
if|if
condition|(
literal|'\n'
operator|==
operator|*
name|line
condition|)
break|break;
comment|/* 	 * Assume the first line that is not indented 	 * is the first section header.  Skip to it. 	 */
while|while
condition|(
name|NULL
operator|!=
operator|(
name|line
operator|=
name|fgetln
argument_list|(
name|stream
argument_list|,
operator|&
name|len
argument_list|)
operator|)
condition|)
if|if
condition|(
literal|'\n'
operator|!=
operator|*
name|line
operator|&&
literal|' '
operator|!=
operator|*
name|line
condition|)
break|break;
comment|/* 	 * Read up until the next section into a buffer. 	 * Strip the leading and trailing newline from each read line, 	 * appending a trailing space. 	 * Ignore empty (whitespace-only) lines. 	 */
name|titlesz
operator|=
literal|0
expr_stmt|;
name|title
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|NULL
operator|!=
operator|(
name|line
operator|=
name|fgetln
argument_list|(
name|stream
argument_list|,
operator|&
name|len
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
literal|' '
operator|!=
operator|*
name|line
operator|||
literal|'\n'
operator|!=
name|line
index|[
name|len
operator|-
literal|1
index|]
condition|)
break|break;
while|while
condition|(
name|len
operator|>
literal|0
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|line
argument_list|)
condition|)
block|{
name|line
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
if|if
condition|(
literal|1
operator|==
name|len
condition|)
continue|continue;
name|title
operator|=
name|mandoc_realloc
argument_list|(
name|title
argument_list|,
name|titlesz
operator|+
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|title
operator|+
name|titlesz
argument_list|,
name|line
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|titlesz
operator|+=
name|len
expr_stmt|;
name|title
index|[
name|titlesz
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
block|}
comment|/* 	 * If no page content can be found, or the input line 	 * is already the next section header, or there is no 	 * trailing newline, reuse the page title as the page 	 * description. 	 */
if|if
condition|(
name|NULL
operator|==
name|title
operator|||
literal|'\0'
operator|==
operator|*
name|title
condition|)
block|{
if|if
condition|(
name|warnings
condition|)
name|say
argument_list|(
name|mpage
operator|->
name|mlinks
operator|->
name|file
argument_list|,
literal|"Cannot find NAME section"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|title
argument_list|)
expr_stmt|;
return|return;
block|}
name|title
operator|=
name|mandoc_realloc
argument_list|(
name|title
argument_list|,
name|titlesz
operator|+
literal|1
argument_list|)
expr_stmt|;
name|title
index|[
name|titlesz
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * Skip to the first dash. 	 * Use the remaining line as the description (no more than 70 	 * bytes). 	 */
if|if
condition|(
name|NULL
operator|!=
operator|(
name|p
operator|=
name|strstr
argument_list|(
name|title
argument_list|,
literal|"- "
argument_list|)
operator|)
condition|)
block|{
for|for
control|(
name|p
operator|+=
literal|2
init|;
literal|' '
operator|==
operator|*
name|p
operator|||
literal|'\b'
operator|==
operator|*
name|p
condition|;
name|p
operator|++
control|)
comment|/* Skip to next word. */
empty_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|warnings
condition|)
name|say
argument_list|(
name|mpage
operator|->
name|mlinks
operator|->
name|file
argument_list|,
literal|"No dash in title line"
argument_list|)
expr_stmt|;
name|p
operator|=
name|title
expr_stmt|;
block|}
name|plen
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Strip backspace-encoding from line. */
while|while
condition|(
name|NULL
operator|!=
operator|(
name|line
operator|=
name|memchr
argument_list|(
name|p
argument_list|,
literal|'\b'
argument_list|,
name|plen
argument_list|)
operator|)
condition|)
block|{
name|len
operator|=
name|line
operator|-
name|p
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|len
condition|)
block|{
name|memmove
argument_list|(
name|line
argument_list|,
name|line
operator|+
literal|1
argument_list|,
name|plen
operator|--
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|memmove
argument_list|(
name|line
operator|-
literal|1
argument_list|,
name|line
operator|+
literal|1
argument_list|,
name|plen
operator|-
name|len
argument_list|)
expr_stmt|;
name|plen
operator|-=
literal|2
expr_stmt|;
block|}
name|mpage
operator|->
name|desc
operator|=
name|mandoc_strdup
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|title
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Put a type/word pair into the word database for this particular file.  */
end_comment

begin_function
specifier|static
name|void
name|putkey
parameter_list|(
specifier|const
name|struct
name|mpage
modifier|*
name|mpage
parameter_list|,
name|char
modifier|*
name|value
parameter_list|,
name|uint64_t
name|type
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|assert
argument_list|(
name|NULL
operator|!=
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_arch
operator|==
name|type
condition|)
for|for
control|(
name|cp
operator|=
name|value
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|isupper
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|_tolower
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
expr_stmt|;
name|putkeys
argument_list|(
name|mpage
argument_list|,
name|value
argument_list|,
name|strlen
argument_list|(
name|value
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Grok all nodes at or below a certain mdoc node into putkey().  */
end_comment

begin_function
specifier|static
name|void
name|putmdockey
parameter_list|(
specifier|const
name|struct
name|mpage
modifier|*
name|mpage
parameter_list|,
specifier|const
name|struct
name|mdoc_node
modifier|*
name|n
parameter_list|,
name|uint64_t
name|m
parameter_list|)
block|{
for|for
control|(
init|;
name|NULL
operator|!=
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
block|{
if|if
condition|(
name|NULL
operator|!=
name|n
operator|->
name|child
condition|)
name|putmdockey
argument_list|(
name|mpage
argument_list|,
name|n
operator|->
name|child
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|MDOC_TEXT
operator|==
name|n
operator|->
name|type
condition|)
name|putkey
argument_list|(
name|mpage
argument_list|,
name|n
operator|->
name|string
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|parse_man
parameter_list|(
name|struct
name|mpage
modifier|*
name|mpage
parameter_list|,
specifier|const
name|struct
name|man_meta
modifier|*
name|meta
parameter_list|,
specifier|const
name|struct
name|man_node
modifier|*
name|n
parameter_list|)
block|{
specifier|const
name|struct
name|man_node
modifier|*
name|head
decl_stmt|,
modifier|*
name|body
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|,
modifier|*
name|title
decl_stmt|;
name|char
name|byte
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
name|n
condition|)
return|return;
comment|/* 	 * We're only searching for one thing: the first text child in 	 * the BODY of a NAME section.  Since we don't keep track of 	 * sections in -man, run some hoops to find out whether we're in 	 * the correct section or not. 	 */
if|if
condition|(
name|MAN_BODY
operator|==
name|n
operator|->
name|type
operator|&&
name|MAN_SH
operator|==
name|n
operator|->
name|tok
condition|)
block|{
name|body
operator|=
name|n
expr_stmt|;
name|assert
argument_list|(
name|body
operator|->
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|head
operator|=
name|body
operator|->
name|parent
operator|->
name|head
operator|)
operator|&&
literal|1
operator|==
name|head
operator|->
name|nchild
operator|&&
name|NULL
operator|!=
operator|(
name|head
operator|=
operator|(
name|head
operator|->
name|child
operator|)
operator|)
operator|&&
name|MAN_TEXT
operator|==
name|head
operator|->
name|type
operator|&&
literal|0
operator|==
name|strcmp
argument_list|(
name|head
operator|->
name|string
argument_list|,
literal|"NAME"
argument_list|)
operator|&&
name|NULL
operator|!=
name|body
operator|->
name|child
condition|)
block|{
comment|/* 			 * Suck the entire NAME section into memory. 			 * Yes, we might run away. 			 * But too many manuals have big, spread-out 			 * NAME sections over many lines. 			 */
name|title
operator|=
name|NULL
expr_stmt|;
name|man_deroff
argument_list|(
operator|&
name|title
argument_list|,
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|title
condition|)
return|return;
comment|/* 			 * Go through a special heuristic dance here. 			 * Conventionally, one or more manual names are 			 * comma-specified prior to a whitespace, then a 			 * dash, then a description.  Try to puzzle out 			 * the name parts here. 			 */
name|start
operator|=
name|title
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|sz
operator|=
name|strcspn
argument_list|(
name|start
argument_list|,
literal|" ,"
argument_list|)
expr_stmt|;
if|if
condition|(
literal|'\0'
operator|==
name|start
index|[
name|sz
index|]
condition|)
break|break;
name|byte
operator|=
name|start
index|[
name|sz
index|]
expr_stmt|;
name|start
index|[
name|sz
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 				 * Assume a stray trailing comma in the 				 * name list if a name begins with a dash. 				 */
if|if
condition|(
literal|'-'
operator|==
name|start
index|[
literal|0
index|]
operator|||
operator|(
literal|'\\'
operator|==
name|start
index|[
literal|0
index|]
operator|&&
literal|'-'
operator|==
name|start
index|[
literal|1
index|]
operator|)
condition|)
break|break;
name|putkey
argument_list|(
name|mpage
argument_list|,
name|start
argument_list|,
name|NAME_TITLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mpage
operator|->
name|name_head_done
operator|||
name|strcasecmp
argument_list|(
name|start
argument_list|,
name|meta
operator|->
name|title
argument_list|)
operator|)
condition|)
block|{
name|putkey
argument_list|(
name|mpage
argument_list|,
name|start
argument_list|,
name|NAME_HEAD
argument_list|)
expr_stmt|;
name|mpage
operator|->
name|name_head_done
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
literal|' '
operator|==
name|byte
condition|)
block|{
name|start
operator|+=
name|sz
operator|+
literal|1
expr_stmt|;
break|break;
block|}
name|assert
argument_list|(
literal|','
operator|==
name|byte
argument_list|)
expr_stmt|;
name|start
operator|+=
name|sz
operator|+
literal|1
expr_stmt|;
while|while
condition|(
literal|' '
operator|==
operator|*
name|start
condition|)
name|start
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|start
operator|==
name|title
condition|)
block|{
name|putkey
argument_list|(
name|mpage
argument_list|,
name|start
argument_list|,
name|NAME_TITLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mpage
operator|->
name|name_head_done
operator|||
name|strcasecmp
argument_list|(
name|start
argument_list|,
name|meta
operator|->
name|title
argument_list|)
operator|)
condition|)
block|{
name|putkey
argument_list|(
name|mpage
argument_list|,
name|start
argument_list|,
name|NAME_HEAD
argument_list|)
expr_stmt|;
name|mpage
operator|->
name|name_head_done
operator|=
literal|1
expr_stmt|;
block|}
name|free
argument_list|(
name|title
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|start
argument_list|)
condition|)
name|start
operator|++
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|start
argument_list|,
literal|"-"
argument_list|,
literal|1
argument_list|)
condition|)
name|start
operator|+=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|start
argument_list|,
literal|"\\-\\-"
argument_list|,
literal|4
argument_list|)
condition|)
name|start
operator|+=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|start
argument_list|,
literal|"\\-"
argument_list|,
literal|2
argument_list|)
condition|)
name|start
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|start
argument_list|,
literal|"\\(en"
argument_list|,
literal|4
argument_list|)
condition|)
name|start
operator|+=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strncmp
argument_list|(
name|start
argument_list|,
literal|"\\(em"
argument_list|,
literal|4
argument_list|)
condition|)
name|start
operator|+=
literal|4
expr_stmt|;
while|while
condition|(
literal|' '
operator|==
operator|*
name|start
condition|)
name|start
operator|++
expr_stmt|;
name|mpage
operator|->
name|desc
operator|=
name|mandoc_strdup
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|title
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
for|for
control|(
name|n
operator|=
name|n
operator|->
name|child
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
block|{
if|if
condition|(
name|NULL
operator|!=
name|mpage
operator|->
name|desc
condition|)
break|break;
name|parse_man
argument_list|(
name|mpage
argument_list|,
name|meta
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|parse_mdoc
parameter_list|(
name|struct
name|mpage
modifier|*
name|mpage
parameter_list|,
specifier|const
name|struct
name|mdoc_meta
modifier|*
name|meta
parameter_list|,
specifier|const
name|struct
name|mdoc_node
modifier|*
name|n
parameter_list|)
block|{
name|assert
argument_list|(
name|NULL
operator|!=
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|n
operator|->
name|child
init|;
name|NULL
operator|!=
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
block|{
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
case|case
name|MDOC_ELEM
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_BLOCK
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_HEAD
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_BODY
case|:
comment|/* FALLTHROUGH */
case|case
name|MDOC_TAIL
case|:
if|if
condition|(
name|NULL
operator|!=
name|mdocs
index|[
name|n
operator|->
name|tok
index|]
operator|.
name|fp
condition|)
if|if
condition|(
literal|0
operator|==
operator|(
operator|*
name|mdocs
index|[
name|n
operator|->
name|tok
index|]
operator|.
name|fp
operator|)
operator|(
name|mpage
operator|,
name|meta
operator|,
name|n
operator|)
condition|)
break|break;
if|if
condition|(
name|mdocs
index|[
name|n
operator|->
name|tok
index|]
operator|.
name|mask
condition|)
name|putmdockey
argument_list|(
name|mpage
argument_list|,
name|n
operator|->
name|child
argument_list|,
name|mdocs
index|[
name|n
operator|->
name|tok
index|]
operator|.
name|mask
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
name|MDOC_ROOT
operator|!=
name|n
operator|->
name|type
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|NULL
operator|!=
name|n
operator|->
name|child
condition|)
name|parse_mdoc
argument_list|(
name|mpage
argument_list|,
name|meta
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|parse_mdoc_Fd
parameter_list|(
name|struct
name|mpage
modifier|*
name|mpage
parameter_list|,
specifier|const
name|struct
name|mdoc_meta
modifier|*
name|meta
parameter_list|,
specifier|const
name|struct
name|mdoc_node
modifier|*
name|n
parameter_list|)
block|{
name|char
modifier|*
name|start
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
if|if
condition|(
name|SEC_SYNOPSIS
operator|!=
name|n
operator|->
name|sec
operator|||
name|NULL
operator|==
operator|(
name|n
operator|=
name|n
operator|->
name|child
operator|)
operator|||
name|MDOC_TEXT
operator|!=
name|n
operator|->
name|type
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Only consider those `Fd' macro fields that begin with an 	 * "inclusion" token (versus, e.g., #define). 	 */
if|if
condition|(
name|strcmp
argument_list|(
literal|"#include"
argument_list|,
name|n
operator|->
name|string
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|n
operator|=
name|n
operator|->
name|next
operator|)
operator|||
name|MDOC_TEXT
operator|!=
name|n
operator|->
name|type
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Strip away the enclosing angle brackets and make sure we're 	 * not zero-length. 	 */
name|start
operator|=
name|n
operator|->
name|string
expr_stmt|;
if|if
condition|(
literal|'<'
operator|==
operator|*
name|start
operator|||
literal|'"'
operator|==
operator|*
name|start
condition|)
name|start
operator|++
expr_stmt|;
if|if
condition|(
literal|0
operator|==
operator|(
name|sz
operator|=
name|strlen
argument_list|(
name|start
argument_list|)
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|end
operator|=
operator|&
name|start
index|[
operator|(
name|int
operator|)
name|sz
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
literal|'>'
operator|==
operator|*
name|end
operator|||
literal|'"'
operator|==
operator|*
name|end
condition|)
name|end
operator|--
expr_stmt|;
if|if
condition|(
name|end
operator|>
name|start
condition|)
name|putkeys
argument_list|(
name|mpage
argument_list|,
name|start
argument_list|,
name|end
operator|-
name|start
operator|+
literal|1
argument_list|,
name|TYPE_In
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|parse_mdoc_fname
parameter_list|(
name|struct
name|mpage
modifier|*
name|mpage
parameter_list|,
specifier|const
name|struct
name|mdoc_node
modifier|*
name|n
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
if|if
condition|(
name|n
operator|->
name|type
operator|!=
name|MDOC_TEXT
condition|)
return|return;
comment|/* Skip function pointer punctuation. */
name|cp
operator|=
name|n
operator|->
name|string
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|==
literal|'('
operator|||
operator|*
name|cp
operator|==
literal|'*'
condition|)
name|cp
operator|++
expr_stmt|;
name|sz
operator|=
name|strcspn
argument_list|(
name|cp
argument_list|,
literal|"()"
argument_list|)
expr_stmt|;
name|putkeys
argument_list|(
name|mpage
argument_list|,
name|cp
argument_list|,
name|sz
argument_list|,
name|TYPE_Fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|sec
operator|==
name|SEC_SYNOPSIS
condition|)
name|putkeys
argument_list|(
name|mpage
argument_list|,
name|cp
argument_list|,
name|sz
argument_list|,
name|NAME_SYN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_mdoc_Fn
parameter_list|(
name|struct
name|mpage
modifier|*
name|mpage
parameter_list|,
specifier|const
name|struct
name|mdoc_meta
modifier|*
name|meta
parameter_list|,
specifier|const
name|struct
name|mdoc_node
modifier|*
name|n
parameter_list|)
block|{
if|if
condition|(
name|n
operator|->
name|child
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|parse_mdoc_fname
argument_list|(
name|mpage
argument_list|,
name|n
operator|->
name|child
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|n
operator|->
name|child
operator|->
name|next
init|;
name|n
operator|!=
name|NULL
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
if|if
condition|(
name|n
operator|->
name|type
operator|==
name|MDOC_TEXT
condition|)
name|putkey
argument_list|(
name|mpage
argument_list|,
name|n
operator|->
name|string
argument_list|,
name|TYPE_Fa
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_mdoc_Fo
parameter_list|(
name|struct
name|mpage
modifier|*
name|mpage
parameter_list|,
specifier|const
name|struct
name|mdoc_meta
modifier|*
name|meta
parameter_list|,
specifier|const
name|struct
name|mdoc_node
modifier|*
name|n
parameter_list|)
block|{
if|if
condition|(
name|n
operator|->
name|type
operator|!=
name|MDOC_HEAD
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|n
operator|->
name|child
operator|!=
name|NULL
condition|)
name|parse_mdoc_fname
argument_list|(
name|mpage
argument_list|,
name|n
operator|->
name|child
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_mdoc_Xr
parameter_list|(
name|struct
name|mpage
modifier|*
name|mpage
parameter_list|,
specifier|const
name|struct
name|mdoc_meta
modifier|*
name|meta
parameter_list|,
specifier|const
name|struct
name|mdoc_node
modifier|*
name|n
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|n
operator|=
name|n
operator|->
name|child
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|NULL
operator|==
name|n
operator|->
name|next
condition|)
block|{
name|putkey
argument_list|(
name|mpage
argument_list|,
name|n
operator|->
name|string
argument_list|,
name|TYPE_Xr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|mandoc_asprintf
argument_list|(
operator|&
name|cp
argument_list|,
literal|"%s(%s)"
argument_list|,
name|n
operator|->
name|string
argument_list|,
name|n
operator|->
name|next
operator|->
name|string
argument_list|)
expr_stmt|;
name|putkey
argument_list|(
name|mpage
argument_list|,
name|cp
argument_list|,
name|TYPE_Xr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_mdoc_Nd
parameter_list|(
name|struct
name|mpage
modifier|*
name|mpage
parameter_list|,
specifier|const
name|struct
name|mdoc_meta
modifier|*
name|meta
parameter_list|,
specifier|const
name|struct
name|mdoc_node
modifier|*
name|n
parameter_list|)
block|{
if|if
condition|(
name|MDOC_BODY
operator|==
name|n
operator|->
name|type
condition|)
name|mdoc_deroff
argument_list|(
operator|&
name|mpage
operator|->
name|desc
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_mdoc_Nm
parameter_list|(
name|struct
name|mpage
modifier|*
name|mpage
parameter_list|,
specifier|const
name|struct
name|mdoc_meta
modifier|*
name|meta
parameter_list|,
specifier|const
name|struct
name|mdoc_node
modifier|*
name|n
parameter_list|)
block|{
if|if
condition|(
name|SEC_NAME
operator|==
name|n
operator|->
name|sec
condition|)
name|putmdockey
argument_list|(
name|mpage
argument_list|,
name|n
operator|->
name|child
argument_list|,
name|NAME_TITLE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SEC_SYNOPSIS
operator|==
name|n
operator|->
name|sec
operator|&&
name|MDOC_HEAD
operator|==
name|n
operator|->
name|type
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|child
operator|==
name|NULL
condition|)
name|putkey
argument_list|(
name|mpage
argument_list|,
name|meta
operator|->
name|name
argument_list|,
name|NAME_SYN
argument_list|)
expr_stmt|;
else|else
name|putmdockey
argument_list|(
name|mpage
argument_list|,
name|n
operator|->
name|child
argument_list|,
name|NAME_SYN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|mpage
operator|->
name|name_head_done
operator|||
name|n
operator|->
name|child
operator|==
name|NULL
operator|||
name|n
operator|->
name|child
operator|->
name|string
operator|==
name|NULL
operator|||
name|strcasecmp
argument_list|(
name|n
operator|->
name|child
operator|->
name|string
argument_list|,
name|meta
operator|->
name|title
argument_list|)
operator|)
condition|)
block|{
name|putkey
argument_list|(
name|mpage
argument_list|,
name|n
operator|->
name|child
operator|->
name|string
argument_list|,
name|NAME_HEAD
argument_list|)
expr_stmt|;
name|mpage
operator|->
name|name_head_done
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_mdoc_Sh
parameter_list|(
name|struct
name|mpage
modifier|*
name|mpage
parameter_list|,
specifier|const
name|struct
name|mdoc_meta
modifier|*
name|meta
parameter_list|,
specifier|const
name|struct
name|mdoc_node
modifier|*
name|n
parameter_list|)
block|{
return|return
operator|(
name|SEC_CUSTOM
operator|==
name|n
operator|->
name|sec
operator|&&
name|MDOC_HEAD
operator|==
name|n
operator|->
name|type
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_mdoc_head
parameter_list|(
name|struct
name|mpage
modifier|*
name|mpage
parameter_list|,
specifier|const
name|struct
name|mdoc_meta
modifier|*
name|meta
parameter_list|,
specifier|const
name|struct
name|mdoc_node
modifier|*
name|n
parameter_list|)
block|{
return|return
operator|(
name|MDOC_HEAD
operator|==
name|n
operator|->
name|type
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_mdoc_body
parameter_list|(
name|struct
name|mpage
modifier|*
name|mpage
parameter_list|,
specifier|const
name|struct
name|mdoc_meta
modifier|*
name|meta
parameter_list|,
specifier|const
name|struct
name|mdoc_node
modifier|*
name|n
parameter_list|)
block|{
return|return
operator|(
name|MDOC_BODY
operator|==
name|n
operator|->
name|type
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a string to the hash table for the current manual.  * Each string has a bitmask telling which macros it belongs to.  * When we finish the manual, we'll dump the table.  */
end_comment

begin_function
specifier|static
name|void
name|putkeys
parameter_list|(
specifier|const
name|struct
name|mpage
modifier|*
name|mpage
parameter_list|,
name|char
modifier|*
name|cp
parameter_list|,
name|size_t
name|sz
parameter_list|,
name|uint64_t
name|v
parameter_list|)
block|{
name|struct
name|ohash
modifier|*
name|htab
decl_stmt|;
name|struct
name|str
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
decl_stmt|;
name|unsigned
name|int
name|slot
decl_stmt|;
name|int
name|i
decl_stmt|,
name|mustfree
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|sz
condition|)
return|return;
name|mustfree
operator|=
name|render_string
argument_list|(
operator|&
name|cp
argument_list|,
operator|&
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_Nm
operator|&
name|v
condition|)
block|{
name|htab
operator|=
operator|&
name|names
expr_stmt|;
name|v
operator|&=
name|name_mask
expr_stmt|;
if|if
condition|(
name|v
operator|&
name|NAME_FIRST
condition|)
name|name_mask
operator|&=
operator|~
name|NAME_FIRST
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|say
argument_list|(
name|mpage
operator|->
name|mlinks
operator|->
name|file
argument_list|,
literal|"Adding name %*s, bits=%d"
argument_list|,
name|sz
argument_list|,
name|cp
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|htab
operator|=
operator|&
name|strings
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mansearch_keymax
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|uint64_t
operator|)
literal|1
operator|<<
name|i
operator|&
name|v
condition|)
name|say
argument_list|(
name|mpage
operator|->
name|mlinks
operator|->
name|file
argument_list|,
literal|"Adding key %s=%*s"
argument_list|,
name|mansearch_keynames
index|[
name|i
index|]
argument_list|,
name|sz
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
name|end
operator|=
name|cp
operator|+
name|sz
expr_stmt|;
name|slot
operator|=
name|ohash_qlookupi
argument_list|(
name|htab
argument_list|,
name|cp
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
name|s
operator|=
name|ohash_find
argument_list|(
name|htab
argument_list|,
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|s
operator|&&
name|mpage
operator|==
name|s
operator|->
name|mpage
condition|)
block|{
name|s
operator|->
name|mask
operator||=
name|v
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|NULL
operator|==
name|s
condition|)
block|{
name|s
operator|=
name|mandoc_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|str
argument_list|)
operator|+
name|sz
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|key
argument_list|,
name|cp
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|ohash_insert
argument_list|(
name|htab
argument_list|,
name|slot
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|mpage
operator|=
name|mpage
expr_stmt|;
name|s
operator|->
name|mask
operator|=
name|v
expr_stmt|;
if|if
condition|(
name|mustfree
condition|)
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Take a Unicode codepoint and produce its UTF-8 encoding.  * This isn't the best way to do this, but it works.  * The magic numbers are from the UTF-8 packaging.  * They're not as scary as they seem: read the UTF-8 spec for details.  */
end_comment

begin_function
specifier|static
name|size_t
name|utf8
parameter_list|(
name|unsigned
name|int
name|cp
parameter_list|,
name|char
name|out
index|[
literal|7
index|]
parameter_list|)
block|{
name|size_t
name|rc
decl_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cp
operator|<=
literal|0x0000007F
condition|)
block|{
name|rc
operator|=
literal|1
expr_stmt|;
name|out
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
name|cp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
operator|<=
literal|0x000007FF
condition|)
block|{
name|rc
operator|=
literal|2
expr_stmt|;
name|out
index|[
literal|0
index|]
operator|=
operator|(
name|cp
operator|>>
literal|6
operator|&
literal|31
operator|)
operator||
literal|192
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
operator|(
name|cp
operator|&
literal|63
operator|)
operator||
literal|128
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
operator|<=
literal|0x0000FFFF
condition|)
block|{
name|rc
operator|=
literal|3
expr_stmt|;
name|out
index|[
literal|0
index|]
operator|=
operator|(
name|cp
operator|>>
literal|12
operator|&
literal|15
operator|)
operator||
literal|224
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
operator|(
name|cp
operator|>>
literal|6
operator|&
literal|63
operator|)
operator||
literal|128
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|=
operator|(
name|cp
operator|&
literal|63
operator|)
operator||
literal|128
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
operator|<=
literal|0x001FFFFF
condition|)
block|{
name|rc
operator|=
literal|4
expr_stmt|;
name|out
index|[
literal|0
index|]
operator|=
operator|(
name|cp
operator|>>
literal|18
operator|&
literal|7
operator|)
operator||
literal|240
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
operator|(
name|cp
operator|>>
literal|12
operator|&
literal|63
operator|)
operator||
literal|128
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|=
operator|(
name|cp
operator|>>
literal|6
operator|&
literal|63
operator|)
operator||
literal|128
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|=
operator|(
name|cp
operator|&
literal|63
operator|)
operator||
literal|128
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
operator|<=
literal|0x03FFFFFF
condition|)
block|{
name|rc
operator|=
literal|5
expr_stmt|;
name|out
index|[
literal|0
index|]
operator|=
operator|(
name|cp
operator|>>
literal|24
operator|&
literal|3
operator|)
operator||
literal|248
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
operator|(
name|cp
operator|>>
literal|18
operator|&
literal|63
operator|)
operator||
literal|128
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|=
operator|(
name|cp
operator|>>
literal|12
operator|&
literal|63
operator|)
operator||
literal|128
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|=
operator|(
name|cp
operator|>>
literal|6
operator|&
literal|63
operator|)
operator||
literal|128
expr_stmt|;
name|out
index|[
literal|4
index|]
operator|=
operator|(
name|cp
operator|&
literal|63
operator|)
operator||
literal|128
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
operator|<=
literal|0x7FFFFFFF
condition|)
block|{
name|rc
operator|=
literal|6
expr_stmt|;
name|out
index|[
literal|0
index|]
operator|=
operator|(
name|cp
operator|>>
literal|30
operator|&
literal|1
operator|)
operator||
literal|252
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
operator|(
name|cp
operator|>>
literal|24
operator|&
literal|63
operator|)
operator||
literal|128
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|=
operator|(
name|cp
operator|>>
literal|18
operator|&
literal|63
operator|)
operator||
literal|128
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|=
operator|(
name|cp
operator|>>
literal|12
operator|&
literal|63
operator|)
operator||
literal|128
expr_stmt|;
name|out
index|[
literal|4
index|]
operator|=
operator|(
name|cp
operator|>>
literal|6
operator|&
literal|63
operator|)
operator||
literal|128
expr_stmt|;
name|out
index|[
literal|5
index|]
operator|=
operator|(
name|cp
operator|&
literal|63
operator|)
operator||
literal|128
expr_stmt|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
name|out
index|[
name|rc
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If the string contains escape sequences,  * replace it with an allocated rendering and return 1,  * such that the caller can free it after use.  * Otherwise, do nothing and return 0.  */
end_comment

begin_function
specifier|static
name|int
name|render_string
parameter_list|(
name|char
modifier|*
modifier|*
name|public
parameter_list|,
name|size_t
modifier|*
name|psz
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|src
decl_stmt|,
modifier|*
name|scp
decl_stmt|,
modifier|*
name|addcp
decl_stmt|,
modifier|*
name|seq
decl_stmt|;
name|char
modifier|*
name|dst
decl_stmt|;
name|size_t
name|ssz
decl_stmt|,
name|dsz
decl_stmt|,
name|addsz
decl_stmt|;
name|char
name|utfbuf
index|[
literal|7
index|]
decl_stmt|,
name|res
index|[
literal|6
index|]
decl_stmt|;
name|int
name|seqlen
decl_stmt|,
name|unicode
decl_stmt|;
name|res
index|[
literal|0
index|]
operator|=
literal|'\\'
expr_stmt|;
name|res
index|[
literal|1
index|]
operator|=
literal|'\t'
expr_stmt|;
name|res
index|[
literal|2
index|]
operator|=
name|ASCII_NBRSP
expr_stmt|;
name|res
index|[
literal|3
index|]
operator|=
name|ASCII_HYPH
expr_stmt|;
name|res
index|[
literal|4
index|]
operator|=
name|ASCII_BREAK
expr_stmt|;
name|res
index|[
literal|5
index|]
operator|=
literal|'\0'
expr_stmt|;
name|src
operator|=
name|scp
operator|=
operator|*
name|public
expr_stmt|;
name|ssz
operator|=
operator|*
name|psz
expr_stmt|;
name|dst
operator|=
name|NULL
expr_stmt|;
name|dsz
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|scp
operator|<
name|src
operator|+
operator|*
name|psz
condition|)
block|{
comment|/* Leave normal characters unchanged. */
if|if
condition|(
name|strchr
argument_list|(
name|res
argument_list|,
operator|*
name|scp
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|dst
operator|!=
name|NULL
condition|)
name|dst
index|[
name|dsz
operator|++
index|]
operator|=
operator|*
name|scp
expr_stmt|;
name|scp
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Found something that requires replacing, 		 * make sure we have a destination buffer. 		 */
if|if
condition|(
name|dst
operator|==
name|NULL
condition|)
block|{
name|dst
operator|=
name|mandoc_malloc
argument_list|(
name|ssz
operator|+
literal|1
argument_list|)
expr_stmt|;
name|dsz
operator|=
name|scp
operator|-
name|src
expr_stmt|;
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|dsz
argument_list|)
expr_stmt|;
block|}
comment|/* Handle single-char special characters. */
switch|switch
condition|(
operator|*
name|scp
condition|)
block|{
case|case
literal|'\\'
case|:
break|break;
case|case
literal|'\t'
case|:
comment|/* FALLTHROUGH */
case|case
name|ASCII_NBRSP
case|:
name|dst
index|[
name|dsz
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|scp
operator|++
expr_stmt|;
continue|continue;
case|case
name|ASCII_HYPH
case|:
name|dst
index|[
name|dsz
operator|++
index|]
operator|=
literal|'-'
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|ASCII_BREAK
case|:
name|scp
operator|++
expr_stmt|;
continue|continue;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* 		 * Found an escape sequence. 		 * Read past the slash, then parse it. 		 * Ignore everything except characters. 		 */
name|scp
operator|++
expr_stmt|;
if|if
condition|(
name|mandoc_escape
argument_list|(
operator|&
name|scp
argument_list|,
operator|&
name|seq
argument_list|,
operator|&
name|seqlen
argument_list|)
operator|!=
name|ESCAPE_SPECIAL
condition|)
continue|continue;
comment|/* 		 * Render the special character 		 * as either UTF-8 or ASCII. 		 */
if|if
condition|(
name|write_utf8
condition|)
block|{
name|unicode
operator|=
name|mchars_spec2cp
argument_list|(
name|mchars
argument_list|,
name|seq
argument_list|,
name|seqlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|unicode
operator|<=
literal|0
condition|)
continue|continue;
name|addsz
operator|=
name|utf8
argument_list|(
name|unicode
argument_list|,
name|utfbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|addsz
operator|==
literal|0
condition|)
continue|continue;
name|addcp
operator|=
name|utfbuf
expr_stmt|;
block|}
else|else
block|{
name|addcp
operator|=
name|mchars_spec2str
argument_list|(
name|mchars
argument_list|,
name|seq
argument_list|,
name|seqlen
argument_list|,
operator|&
name|addsz
argument_list|)
expr_stmt|;
if|if
condition|(
name|addcp
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|*
name|addcp
operator|==
name|ASCII_NBRSP
condition|)
block|{
name|addcp
operator|=
literal|" "
expr_stmt|;
name|addsz
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Copy the rendered glyph into the stream. */
name|ssz
operator|+=
name|addsz
expr_stmt|;
name|dst
operator|=
name|mandoc_realloc
argument_list|(
name|dst
argument_list|,
name|ssz
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dst
operator|+
name|dsz
argument_list|,
name|addcp
argument_list|,
name|addsz
argument_list|)
expr_stmt|;
name|dsz
operator|+=
name|addsz
expr_stmt|;
block|}
if|if
condition|(
name|dst
operator|!=
name|NULL
condition|)
block|{
operator|*
name|public
operator|=
name|dst
expr_stmt|;
operator|*
name|psz
operator|=
name|dsz
expr_stmt|;
block|}
comment|/* Trim trailing whitespace and NUL-terminate. */
while|while
condition|(
operator|*
name|psz
operator|>
literal|0
operator|&&
operator|(
operator|*
name|public
operator|)
index|[
operator|*
name|psz
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
operator|--
operator|*
name|psz
expr_stmt|;
if|if
condition|(
name|dst
operator|!=
name|NULL
condition|)
block|{
operator|(
operator|*
name|public
operator|)
index|[
operator|*
name|psz
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dbadd_mlink
parameter_list|(
specifier|const
name|struct
name|mlink
modifier|*
name|mlink
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
name|SQL_BIND_TEXT
argument_list|(
name|stmts
index|[
name|STMT_INSERT_LINK
index|]
argument_list|,
name|i
argument_list|,
name|mlink
operator|->
name|dsec
argument_list|)
expr_stmt|;
name|SQL_BIND_TEXT
argument_list|(
name|stmts
index|[
name|STMT_INSERT_LINK
index|]
argument_list|,
name|i
argument_list|,
name|mlink
operator|->
name|arch
argument_list|)
expr_stmt|;
name|SQL_BIND_TEXT
argument_list|(
name|stmts
index|[
name|STMT_INSERT_LINK
index|]
argument_list|,
name|i
argument_list|,
name|mlink
operator|->
name|name
argument_list|)
expr_stmt|;
name|SQL_BIND_INT64
argument_list|(
name|stmts
index|[
name|STMT_INSERT_LINK
index|]
argument_list|,
name|i
argument_list|,
name|mlink
operator|->
name|mpage
operator|->
name|pageid
argument_list|)
expr_stmt|;
name|SQL_STEP
argument_list|(
name|stmts
index|[
name|STMT_INSERT_LINK
index|]
argument_list|)
expr_stmt|;
name|sqlite3_reset
argument_list|(
name|stmts
index|[
name|STMT_INSERT_LINK
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dbadd_mlink_name
parameter_list|(
specifier|const
name|struct
name|mlink
modifier|*
name|mlink
parameter_list|)
block|{
name|uint64_t
name|bits
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|dbadd_mlink
argument_list|(
name|mlink
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
name|SQL_BIND_INT64
argument_list|(
name|stmts
index|[
name|STMT_SELECT_NAME
index|]
argument_list|,
name|i
argument_list|,
name|mlink
operator|->
name|mpage
operator|->
name|pageid
argument_list|)
expr_stmt|;
name|bits
operator|=
name|NAME_FILE
operator|&
name|NAME_MASK
expr_stmt|;
if|if
condition|(
name|sqlite3_step
argument_list|(
name|stmts
index|[
name|STMT_SELECT_NAME
index|]
argument_list|)
operator|==
name|SQLITE_ROW
condition|)
block|{
name|bits
operator||=
name|sqlite3_column_int64
argument_list|(
name|stmts
index|[
name|STMT_SELECT_NAME
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sqlite3_reset
argument_list|(
name|stmts
index|[
name|STMT_SELECT_NAME
index|]
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|1
expr_stmt|;
name|SQL_BIND_INT64
argument_list|(
name|stmts
index|[
name|STMT_INSERT_NAME
index|]
argument_list|,
name|i
argument_list|,
name|bits
argument_list|)
expr_stmt|;
name|SQL_BIND_TEXT
argument_list|(
name|stmts
index|[
name|STMT_INSERT_NAME
index|]
argument_list|,
name|i
argument_list|,
name|mlink
operator|->
name|name
argument_list|)
expr_stmt|;
name|SQL_BIND_INT64
argument_list|(
name|stmts
index|[
name|STMT_INSERT_NAME
index|]
argument_list|,
name|i
argument_list|,
name|mlink
operator|->
name|mpage
operator|->
name|pageid
argument_list|)
expr_stmt|;
name|SQL_STEP
argument_list|(
name|stmts
index|[
name|STMT_INSERT_NAME
index|]
argument_list|)
expr_stmt|;
name|sqlite3_reset
argument_list|(
name|stmts
index|[
name|STMT_INSERT_NAME
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Flush the current page's terms (and their bits) into the database.  * Wrap the entire set of additions in a transaction to make sqlite be a  * little faster.  * Also, handle escape sequences at the last possible moment.  */
end_comment

begin_function
specifier|static
name|void
name|dbadd
parameter_list|(
name|struct
name|mpage
modifier|*
name|mpage
parameter_list|)
block|{
name|struct
name|mlink
modifier|*
name|mlink
decl_stmt|;
name|struct
name|str
modifier|*
name|key
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|unsigned
name|int
name|slot
decl_stmt|;
name|int
name|mustfree
decl_stmt|;
name|mlink
operator|=
name|mpage
operator|->
name|mlinks
expr_stmt|;
if|if
condition|(
name|nodb
condition|)
block|{
for|for
control|(
name|key
operator|=
name|ohash_first
argument_list|(
operator|&
name|names
argument_list|,
operator|&
name|slot
argument_list|)
init|;
name|NULL
operator|!=
name|key
condition|;
name|key
operator|=
name|ohash_next
argument_list|(
operator|&
name|names
argument_list|,
operator|&
name|slot
argument_list|)
control|)
name|free
argument_list|(
name|key
argument_list|)
expr_stmt|;
for|for
control|(
name|key
operator|=
name|ohash_first
argument_list|(
operator|&
name|strings
argument_list|,
operator|&
name|slot
argument_list|)
init|;
name|NULL
operator|!=
name|key
condition|;
name|key
operator|=
name|ohash_next
argument_list|(
operator|&
name|strings
argument_list|,
operator|&
name|slot
argument_list|)
control|)
name|free
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|debug
condition|)
return|return;
while|while
condition|(
name|NULL
operator|!=
name|mlink
condition|)
block|{
name|fputs
argument_list|(
name|mlink
operator|->
name|name
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|mlink
operator|->
name|next
operator|||
name|strcmp
argument_list|(
name|mlink
operator|->
name|dsec
argument_list|,
name|mlink
operator|->
name|next
operator|->
name|dsec
argument_list|)
operator|||
name|strcmp
argument_list|(
name|mlink
operator|->
name|fsec
argument_list|,
name|mlink
operator|->
name|next
operator|->
name|fsec
argument_list|)
operator|||
name|strcmp
argument_list|(
name|mlink
operator|->
name|arch
argument_list|,
name|mlink
operator|->
name|next
operator|->
name|arch
argument_list|)
condition|)
block|{
name|putchar
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
if|if
condition|(
literal|'\0'
operator|==
operator|*
name|mlink
operator|->
name|dsec
condition|)
name|fputs
argument_list|(
name|mlink
operator|->
name|fsec
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
name|mlink
operator|->
name|dsec
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
literal|'\0'
operator|!=
operator|*
name|mlink
operator|->
name|arch
condition|)
name|printf
argument_list|(
literal|"/%s"
argument_list|,
name|mlink
operator|->
name|arch
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
name|mlink
operator|=
name|mlink
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|mlink
condition|)
name|fputs
argument_list|(
literal|", "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" - %s\n"
argument_list|,
name|mpage
operator|->
name|desc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|debug
condition|)
name|say
argument_list|(
name|mlink
operator|->
name|file
argument_list|,
literal|"Adding to database"
argument_list|)
expr_stmt|;
name|cp
operator|=
name|mpage
operator|->
name|desc
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|mustfree
operator|=
name|render_string
argument_list|(
operator|&
name|cp
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
name|SQL_BIND_TEXT
argument_list|(
name|stmts
index|[
name|STMT_INSERT_PAGE
index|]
argument_list|,
name|i
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|SQL_BIND_INT
argument_list|(
name|stmts
index|[
name|STMT_INSERT_PAGE
index|]
argument_list|,
name|i
argument_list|,
name|mpage
operator|->
name|form
argument_list|)
expr_stmt|;
name|SQL_STEP
argument_list|(
name|stmts
index|[
name|STMT_INSERT_PAGE
index|]
argument_list|)
expr_stmt|;
name|mpage
operator|->
name|pageid
operator|=
name|sqlite3_last_insert_rowid
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|sqlite3_reset
argument_list|(
name|stmts
index|[
name|STMT_INSERT_PAGE
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|mustfree
condition|)
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
while|while
condition|(
name|NULL
operator|!=
name|mlink
condition|)
block|{
name|dbadd_mlink
argument_list|(
name|mlink
argument_list|)
expr_stmt|;
name|mlink
operator|=
name|mlink
operator|->
name|next
expr_stmt|;
block|}
name|mlink
operator|=
name|mpage
operator|->
name|mlinks
expr_stmt|;
for|for
control|(
name|key
operator|=
name|ohash_first
argument_list|(
operator|&
name|names
argument_list|,
operator|&
name|slot
argument_list|)
init|;
name|NULL
operator|!=
name|key
condition|;
name|key
operator|=
name|ohash_next
argument_list|(
operator|&
name|names
argument_list|,
operator|&
name|slot
argument_list|)
control|)
block|{
name|assert
argument_list|(
name|key
operator|->
name|mpage
operator|==
name|mpage
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
name|SQL_BIND_INT64
argument_list|(
name|stmts
index|[
name|STMT_INSERT_NAME
index|]
argument_list|,
name|i
argument_list|,
name|key
operator|->
name|mask
argument_list|)
expr_stmt|;
name|SQL_BIND_TEXT
argument_list|(
name|stmts
index|[
name|STMT_INSERT_NAME
index|]
argument_list|,
name|i
argument_list|,
name|key
operator|->
name|key
argument_list|)
expr_stmt|;
name|SQL_BIND_INT64
argument_list|(
name|stmts
index|[
name|STMT_INSERT_NAME
index|]
argument_list|,
name|i
argument_list|,
name|mpage
operator|->
name|pageid
argument_list|)
expr_stmt|;
name|SQL_STEP
argument_list|(
name|stmts
index|[
name|STMT_INSERT_NAME
index|]
argument_list|)
expr_stmt|;
name|sqlite3_reset
argument_list|(
name|stmts
index|[
name|STMT_INSERT_NAME
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|key
operator|=
name|ohash_first
argument_list|(
operator|&
name|strings
argument_list|,
operator|&
name|slot
argument_list|)
init|;
name|NULL
operator|!=
name|key
condition|;
name|key
operator|=
name|ohash_next
argument_list|(
operator|&
name|strings
argument_list|,
operator|&
name|slot
argument_list|)
control|)
block|{
name|assert
argument_list|(
name|key
operator|->
name|mpage
operator|==
name|mpage
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
name|SQL_BIND_INT64
argument_list|(
name|stmts
index|[
name|STMT_INSERT_KEY
index|]
argument_list|,
name|i
argument_list|,
name|key
operator|->
name|mask
argument_list|)
expr_stmt|;
name|SQL_BIND_TEXT
argument_list|(
name|stmts
index|[
name|STMT_INSERT_KEY
index|]
argument_list|,
name|i
argument_list|,
name|key
operator|->
name|key
argument_list|)
expr_stmt|;
name|SQL_BIND_INT64
argument_list|(
name|stmts
index|[
name|STMT_INSERT_KEY
index|]
argument_list|,
name|i
argument_list|,
name|mpage
operator|->
name|pageid
argument_list|)
expr_stmt|;
name|SQL_STEP
argument_list|(
name|stmts
index|[
name|STMT_INSERT_KEY
index|]
argument_list|)
expr_stmt|;
name|sqlite3_reset
argument_list|(
name|stmts
index|[
name|STMT_INSERT_KEY
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dbprune
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|mpage
modifier|*
name|mpage
decl_stmt|;
name|struct
name|mlink
modifier|*
name|mlink
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|unsigned
name|int
name|slot
decl_stmt|;
if|if
condition|(
literal|0
operator|==
name|nodb
condition|)
name|SQL_EXEC
argument_list|(
literal|"BEGIN TRANSACTION"
argument_list|)
expr_stmt|;
for|for
control|(
name|mpage
operator|=
name|ohash_first
argument_list|(
operator|&
name|mpages
argument_list|,
operator|&
name|slot
argument_list|)
init|;
name|NULL
operator|!=
name|mpage
condition|;
name|mpage
operator|=
name|ohash_next
argument_list|(
operator|&
name|mpages
argument_list|,
operator|&
name|slot
argument_list|)
control|)
block|{
name|mlink
operator|=
name|mpage
operator|->
name|mlinks
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|say
argument_list|(
name|mlink
operator|->
name|file
argument_list|,
literal|"Deleting from database"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nodb
condition|)
continue|continue;
for|for
control|(
init|;
name|NULL
operator|!=
name|mlink
condition|;
name|mlink
operator|=
name|mlink
operator|->
name|next
control|)
block|{
name|i
operator|=
literal|1
expr_stmt|;
name|SQL_BIND_TEXT
argument_list|(
name|stmts
index|[
name|STMT_DELETE_PAGE
index|]
argument_list|,
name|i
argument_list|,
name|mlink
operator|->
name|dsec
argument_list|)
expr_stmt|;
name|SQL_BIND_TEXT
argument_list|(
name|stmts
index|[
name|STMT_DELETE_PAGE
index|]
argument_list|,
name|i
argument_list|,
name|mlink
operator|->
name|arch
argument_list|)
expr_stmt|;
name|SQL_BIND_TEXT
argument_list|(
name|stmts
index|[
name|STMT_DELETE_PAGE
index|]
argument_list|,
name|i
argument_list|,
name|mlink
operator|->
name|name
argument_list|)
expr_stmt|;
name|SQL_STEP
argument_list|(
name|stmts
index|[
name|STMT_DELETE_PAGE
index|]
argument_list|)
expr_stmt|;
name|sqlite3_reset
argument_list|(
name|stmts
index|[
name|STMT_DELETE_PAGE
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
literal|0
operator|==
name|nodb
condition|)
name|SQL_EXEC
argument_list|(
literal|"END TRANSACTION"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Close an existing database and its prepared statements.  * If "real" is not set, rename the temporary file into the real one.  */
end_comment

begin_function
specifier|static
name|void
name|dbclose
parameter_list|(
name|int
name|real
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|int
name|status
decl_stmt|;
name|pid_t
name|child
decl_stmt|;
if|if
condition|(
name|nodb
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STMT__MAX
condition|;
name|i
operator|++
control|)
block|{
name|sqlite3_finalize
argument_list|(
name|stmts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|stmts
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|sqlite3_close
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|db
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|real
condition|)
return|return;
if|if
condition|(
literal|'\0'
operator|==
operator|*
name|tempfilename
condition|)
block|{
if|if
condition|(
operator|-
literal|1
operator|==
name|rename
argument_list|(
name|MANDOC_DB
literal|"~"
argument_list|,
name|MANDOC_DB
argument_list|)
condition|)
block|{
name|exitcode
operator|=
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
expr_stmt|;
name|say
argument_list|(
name|MANDOC_DB
argument_list|,
literal|"&rename"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
switch|switch
condition|(
name|child
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|exitcode
operator|=
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
expr_stmt|;
name|say
argument_list|(
literal|""
argument_list|,
literal|"&fork cmp"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|0
case|:
name|execlp
argument_list|(
literal|"cmp"
argument_list|,
literal|"cmp"
argument_list|,
literal|"-s"
argument_list|,
name|tempfilename
argument_list|,
name|MANDOC_DB
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|say
argument_list|(
literal|""
argument_list|,
literal|"&exec cmp"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
if|if
condition|(
operator|-
literal|1
operator|==
name|waitpid
argument_list|(
name|child
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|exitcode
operator|=
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
expr_stmt|;
name|say
argument_list|(
literal|""
argument_list|,
literal|"&wait cmp"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|exitcode
operator|=
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
expr_stmt|;
name|say
argument_list|(
literal|""
argument_list|,
literal|"cmp died from signal %d"
argument_list|,
name|WTERMSIG
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|exitcode
operator|=
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
expr_stmt|;
name|say
argument_list|(
name|MANDOC_DB
argument_list|,
literal|"Data changed, but cannot replace database"
argument_list|)
expr_stmt|;
block|}
operator|*
name|strrchr
argument_list|(
name|tempfilename
argument_list|,
literal|'/'
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
switch|switch
condition|(
name|child
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|exitcode
operator|=
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
expr_stmt|;
name|say
argument_list|(
literal|""
argument_list|,
literal|"&fork rm"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|0
case|:
name|execlp
argument_list|(
literal|"rm"
argument_list|,
literal|"rm"
argument_list|,
literal|"-rf"
argument_list|,
name|tempfilename
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|say
argument_list|(
literal|""
argument_list|,
literal|"&exec rm"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
if|if
condition|(
operator|-
literal|1
operator|==
name|waitpid
argument_list|(
name|child
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|exitcode
operator|=
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
expr_stmt|;
name|say
argument_list|(
literal|""
argument_list|,
literal|"&wait rm"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
operator|||
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|exitcode
operator|=
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
expr_stmt|;
name|say
argument_list|(
literal|""
argument_list|,
literal|"%s: Cannot remove temporary directory"
argument_list|,
name|tempfilename
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This is straightforward stuff.  * Open a database connection to a "temporary" database, then open a set  * of prepared statements we'll use over and over again.  * If "real" is set, we use the existing database; if not, we truncate a  * temporary one.  * Must be matched by dbclose().  */
end_comment

begin_function
specifier|static
name|int
name|dbopen
parameter_list|(
name|int
name|real
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|sql
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|ofl
decl_stmt|;
if|if
condition|(
name|nodb
condition|)
return|return
operator|(
literal|1
operator|)
return|;
operator|*
name|tempfilename
operator|=
literal|'\0'
expr_stmt|;
name|ofl
operator|=
name|SQLITE_OPEN_READWRITE
expr_stmt|;
if|if
condition|(
name|real
condition|)
block|{
name|rc
operator|=
name|sqlite3_open_v2
argument_list|(
name|MANDOC_DB
argument_list|,
operator|&
name|db
argument_list|,
name|ofl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|SQLITE_OK
operator|!=
name|rc
condition|)
block|{
name|exitcode
operator|=
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
expr_stmt|;
if|if
condition|(
name|SQLITE_CANTOPEN
operator|!=
name|rc
condition|)
name|say
argument_list|(
name|MANDOC_DB
argument_list|,
literal|"%s"
argument_list|,
name|sqlite3_errstr
argument_list|(
name|rc
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
goto|goto
name|prepare_statements
goto|;
block|}
name|ofl
operator||=
name|SQLITE_OPEN_CREATE
operator||
name|SQLITE_OPEN_EXCLUSIVE
expr_stmt|;
name|remove
argument_list|(
name|MANDOC_DB
literal|"~"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_open_v2
argument_list|(
name|MANDOC_DB
literal|"~"
argument_list|,
operator|&
name|db
argument_list|,
name|ofl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|SQLITE_OK
operator|==
name|rc
condition|)
goto|goto
name|create_tables
goto|;
if|if
condition|(
name|MPARSE_QUICK
operator|&
name|mparse_options
condition|)
block|{
name|exitcode
operator|=
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
expr_stmt|;
name|say
argument_list|(
name|MANDOC_DB
literal|"~"
argument_list|,
literal|"%s"
argument_list|,
name|sqlite3_errstr
argument_list|(
name|rc
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|tempfilename
argument_list|,
literal|"/tmp/mandocdb.XXXXXX"
argument_list|,
sizeof|sizeof
argument_list|(
name|tempfilename
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|mkdtemp
argument_list|(
name|tempfilename
argument_list|)
condition|)
block|{
name|exitcode
operator|=
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
expr_stmt|;
name|say
argument_list|(
literal|""
argument_list|,
literal|"&%s"
argument_list|,
name|tempfilename
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|tempfilename
argument_list|,
literal|"/"
name|MANDOC_DB
argument_list|,
sizeof|sizeof
argument_list|(
name|tempfilename
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sqlite3_open_v2
argument_list|(
name|tempfilename
argument_list|,
operator|&
name|db
argument_list|,
name|ofl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|SQLITE_OK
operator|!=
name|rc
condition|)
block|{
name|exitcode
operator|=
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
expr_stmt|;
name|say
argument_list|(
literal|""
argument_list|,
literal|"%s: %s"
argument_list|,
name|tempfilename
argument_list|,
name|sqlite3_errstr
argument_list|(
name|rc
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|create_tables
label|:
name|sql
operator|=
literal|"CREATE TABLE \"mpages\" (\n"
literal|" \"desc\" TEXT NOT NULL,\n"
literal|" \"form\" INTEGER NOT NULL,\n"
literal|" \"pageid\" INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL\n"
literal|");\n"
literal|"\n"
literal|"CREATE TABLE \"mlinks\" (\n"
literal|" \"sec\" TEXT NOT NULL,\n"
literal|" \"arch\" TEXT NOT NULL,\n"
literal|" \"name\" TEXT NOT NULL,\n"
literal|" \"pageid\" INTEGER NOT NULL REFERENCES mpages(pageid) "
literal|"ON DELETE CASCADE\n"
literal|");\n"
literal|"CREATE INDEX mlinks_pageid_idx ON mlinks (pageid);\n"
literal|"\n"
literal|"CREATE TABLE \"names\" (\n"
literal|" \"bits\" INTEGER NOT NULL,\n"
literal|" \"name\" TEXT NOT NULL,\n"
literal|" \"pageid\" INTEGER NOT NULL REFERENCES mpages(pageid) "
literal|"ON DELETE CASCADE,\n"
literal|" UNIQUE (\"name\", \"pageid\") ON CONFLICT REPLACE\n"
literal|");\n"
literal|"\n"
literal|"CREATE TABLE \"keys\" (\n"
literal|" \"bits\" INTEGER NOT NULL,\n"
literal|" \"key\" TEXT NOT NULL,\n"
literal|" \"pageid\" INTEGER NOT NULL REFERENCES mpages(pageid) "
literal|"ON DELETE CASCADE\n"
literal|");\n"
literal|"CREATE INDEX keys_pageid_idx ON keys (pageid);\n"
expr_stmt|;
if|if
condition|(
name|SQLITE_OK
operator|!=
name|sqlite3_exec
argument_list|(
name|db
argument_list|,
name|sql
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|exitcode
operator|=
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
expr_stmt|;
name|say
argument_list|(
name|MANDOC_DB
argument_list|,
literal|"%s"
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|sqlite3_close
argument_list|(
name|db
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|prepare_statements
label|:
if|if
condition|(
name|SQLITE_OK
operator|!=
name|sqlite3_exec
argument_list|(
name|db
argument_list|,
literal|"PRAGMA foreign_keys = ON"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|exitcode
operator|=
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
expr_stmt|;
name|say
argument_list|(
name|MANDOC_DB
argument_list|,
literal|"PRAGMA foreign_keys: %s"
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|sqlite3_close
argument_list|(
name|db
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sql
operator|=
literal|"DELETE FROM mpages WHERE pageid IN "
literal|"(SELECT pageid FROM mlinks WHERE "
literal|"sec=? AND arch=? AND name=?)"
expr_stmt|;
name|sqlite3_prepare_v2
argument_list|(
name|db
argument_list|,
name|sql
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|stmts
index|[
name|STMT_DELETE_PAGE
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"INSERT INTO mpages "
literal|"(desc,form) VALUES (?,?)"
expr_stmt|;
name|sqlite3_prepare_v2
argument_list|(
name|db
argument_list|,
name|sql
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|stmts
index|[
name|STMT_INSERT_PAGE
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"INSERT INTO mlinks "
literal|"(sec,arch,name,pageid) VALUES (?,?,?,?)"
expr_stmt|;
name|sqlite3_prepare_v2
argument_list|(
name|db
argument_list|,
name|sql
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|stmts
index|[
name|STMT_INSERT_LINK
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"SELECT bits FROM names where pageid = ?"
expr_stmt|;
name|sqlite3_prepare_v2
argument_list|(
name|db
argument_list|,
name|sql
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|stmts
index|[
name|STMT_SELECT_NAME
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"INSERT INTO names "
literal|"(bits,name,pageid) VALUES (?,?,?)"
expr_stmt|;
name|sqlite3_prepare_v2
argument_list|(
name|db
argument_list|,
name|sql
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|stmts
index|[
name|STMT_INSERT_NAME
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sql
operator|=
literal|"INSERT INTO keys "
literal|"(bits,key,pageid) VALUES (?,?,?)"
expr_stmt|;
name|sqlite3_prepare_v2
argument_list|(
name|db
argument_list|,
name|sql
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|stmts
index|[
name|STMT_INSERT_KEY
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__APPLE__
comment|/* 	 * When opening a new database, we can turn off 	 * synchronous mode for much better performance. 	 */
if|if
condition|(
name|real
operator|&&
name|SQLITE_OK
operator|!=
name|sqlite3_exec
argument_list|(
name|db
argument_list|,
literal|"PRAGMA synchronous = OFF"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|exitcode
operator|=
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
expr_stmt|;
name|say
argument_list|(
name|MANDOC_DB
argument_list|,
literal|"PRAGMA synchronous: %s"
argument_list|,
name|sqlite3_errmsg
argument_list|(
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|sqlite3_close
argument_list|(
name|db
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|hash_calloc
parameter_list|(
name|size_t
name|n
parameter_list|,
name|size_t
name|sz
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
operator|(
name|mandoc_calloc
argument_list|(
name|n
argument_list|,
name|sz
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|hash_alloc
parameter_list|(
name|size_t
name|sz
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
operator|(
name|mandoc_malloc
argument_list|(
name|sz
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hash_free
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_basedir
parameter_list|(
specifier|const
name|char
modifier|*
name|targetdir
parameter_list|,
name|int
name|report_baddir
parameter_list|)
block|{
specifier|static
name|char
name|startdir
index|[
name|PATH_MAX
index|]
decl_stmt|;
specifier|static
name|int
name|getcwd_status
decl_stmt|;
comment|/* 1 = ok, 2 = failure */
specifier|static
name|int
name|chdir_status
decl_stmt|;
comment|/* 1 = changed directory */
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* 	 * Remember the original working directory, if possible. 	 * This will be needed if the second or a later directory 	 * on the command line is given as a relative path. 	 * Do not error out if the current directory is not 	 * searchable: Maybe it won't be needed after all. 	 */
if|if
condition|(
literal|0
operator|==
name|getcwd_status
condition|)
block|{
if|if
condition|(
name|NULL
operator|==
name|getcwd
argument_list|(
name|startdir
argument_list|,
sizeof|sizeof
argument_list|(
name|startdir
argument_list|)
argument_list|)
condition|)
block|{
name|getcwd_status
operator|=
literal|2
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|startdir
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|startdir
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|getcwd_status
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * We are leaving the old base directory. 	 * Do not use it any longer, not even for messages. 	 */
operator|*
name|basedir
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * If and only if the directory was changed earlier and 	 * the next directory to process is given as a relative path, 	 * first go back, or bail out if that is impossible. 	 */
if|if
condition|(
name|chdir_status
operator|&&
literal|'/'
operator|!=
operator|*
name|targetdir
condition|)
block|{
if|if
condition|(
literal|2
operator|==
name|getcwd_status
condition|)
block|{
name|exitcode
operator|=
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
expr_stmt|;
name|say
argument_list|(
literal|""
argument_list|,
literal|"getcwd: %s"
argument_list|,
name|startdir
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|-
literal|1
operator|==
name|chdir
argument_list|(
name|startdir
argument_list|)
condition|)
block|{
name|exitcode
operator|=
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
expr_stmt|;
name|say
argument_list|(
literal|""
argument_list|,
literal|"&chdir %s"
argument_list|,
name|startdir
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* 	 * Always resolve basedir to the canonicalized absolute 	 * pathname and append a trailing slash, such that 	 * we can reliably check whether files are inside. 	 */
if|if
condition|(
name|NULL
operator|==
name|realpath
argument_list|(
name|targetdir
argument_list|,
name|basedir
argument_list|)
condition|)
block|{
if|if
condition|(
name|report_baddir
operator|||
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|exitcode
operator|=
operator|(
name|int
operator|)
name|MANDOCLEVEL_BADARG
expr_stmt|;
name|say
argument_list|(
literal|""
argument_list|,
literal|"&%s: realpath"
argument_list|,
name|targetdir
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|-
literal|1
operator|==
name|chdir
argument_list|(
name|basedir
argument_list|)
condition|)
block|{
if|if
condition|(
name|report_baddir
operator|||
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|exitcode
operator|=
operator|(
name|int
operator|)
name|MANDOCLEVEL_BADARG
expr_stmt|;
name|say
argument_list|(
literal|""
argument_list|,
literal|"&chdir"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|chdir_status
operator|=
literal|1
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|basedir
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
if|if
condition|(
literal|'/'
operator|!=
name|cp
index|[
operator|-
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|cp
operator|-
name|basedir
operator|>=
name|PATH_MAX
operator|-
literal|1
condition|)
block|{
name|exitcode
operator|=
operator|(
name|int
operator|)
name|MANDOCLEVEL_SYSERR
expr_stmt|;
name|say
argument_list|(
literal|""
argument_list|,
literal|"Filename too long"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|cp
operator|++
operator|=
literal|'/'
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|say
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|int
name|use_errno
decl_stmt|;
if|if
condition|(
literal|'\0'
operator|!=
operator|*
name|basedir
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|basedir
argument_list|)
expr_stmt|;
if|if
condition|(
literal|'\0'
operator|!=
operator|*
name|basedir
operator|&&
literal|'\0'
operator|!=
operator|*
name|file
condition|)
name|fputc
argument_list|(
literal|'/'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
literal|'\0'
operator|!=
operator|*
name|file
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|use_errno
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|format
condition|)
block|{
switch|switch
condition|(
operator|*
name|format
condition|)
block|{
case|case
literal|'&'
case|:
name|format
operator|++
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
name|format
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
name|use_errno
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|NULL
operator|!=
name|format
condition|)
block|{
if|if
condition|(
literal|'\0'
operator|!=
operator|*
name|basedir
operator|||
literal|'\0'
operator|!=
operator|*
name|file
condition|)
name|fputs
argument_list|(
literal|": "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|use_errno
condition|)
block|{
if|if
condition|(
literal|'\0'
operator|!=
operator|*
name|basedir
operator|||
literal|'\0'
operator|!=
operator|*
name|file
operator|||
name|NULL
operator|!=
name|format
condition|)
name|fputs
argument_list|(
literal|": "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

