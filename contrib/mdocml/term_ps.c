begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$Id: term_ps.c,v 1.85 2017/06/07 17:38:26 schwarze Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2010, 2011 Kristaps Dzonsons<kristaps@bsd.lv>  * Copyright (c) 2014, 2015, 2016, 2017 Ingo Schwarze<schwarze@openbsd.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_if
if|#
directive|if
name|HAVE_ERR
end_if

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"mandoc_aux.h"
end_include

begin_include
include|#
directive|include
file|"out.h"
end_include

begin_include
include|#
directive|include
file|"term.h"
end_include

begin_include
include|#
directive|include
file|"manconf.h"
end_include

begin_include
include|#
directive|include
file|"main.h"
end_include

begin_comment
comment|/* These work the buffer used by the header and footer. */
end_comment

begin_define
define|#
directive|define
name|PS_BUFSLOP
value|128
end_define

begin_comment
comment|/* Convert PostScript point "x" to an AFM unit. */
end_comment

begin_define
define|#
directive|define
name|PNT2AFM
parameter_list|(
name|p
parameter_list|,
name|x
parameter_list|)
define|\
value|(size_t)((double)(x) * (1000.0 / (double)(p)->ps->scale))
end_define

begin_comment
comment|/* Convert an AFM unit "x" to a PostScript points */
end_comment

begin_define
define|#
directive|define
name|AFM2PNT
parameter_list|(
name|p
parameter_list|,
name|x
parameter_list|)
define|\
value|((double)(x) / (1000.0 / (double)(p)->ps->scale))
end_define

begin_struct
struct|struct
name|glyph
block|{
name|unsigned
name|short
name|wx
decl_stmt|;
comment|/* WX in AFM */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|font
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* FontName in AFM */
define|#
directive|define
name|MAXCHAR
value|95
comment|/* total characters we can handle */
name|struct
name|glyph
name|gly
index|[
name|MAXCHAR
index|]
decl_stmt|;
comment|/* glyph metrics */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|termp_ps
block|{
name|int
name|flags
decl_stmt|;
define|#
directive|define
name|PS_INLINE
value|(1<< 0)
comment|/* we're in a word */
define|#
directive|define
name|PS_MARGINS
value|(1<< 1)
comment|/* we're in the margins */
define|#
directive|define
name|PS_NEWPAGE
value|(1<< 2)
comment|/* new page, no words yet */
define|#
directive|define
name|PS_BACKSP
value|(1<< 3)
comment|/* last character was backspace */
name|size_t
name|pscol
decl_stmt|;
comment|/* visible column (AFM units) */
name|size_t
name|pscolnext
decl_stmt|;
comment|/* used for overstrike */
name|size_t
name|psrow
decl_stmt|;
comment|/* visible row (AFM units) */
name|char
modifier|*
name|psmarg
decl_stmt|;
comment|/* margin buf */
name|size_t
name|psmargsz
decl_stmt|;
comment|/* margin buf size */
name|size_t
name|psmargcur
decl_stmt|;
comment|/* cur index in margin buf */
name|char
name|last
decl_stmt|;
comment|/* last non-backspace seen */
name|enum
name|termfont
name|lastf
decl_stmt|;
comment|/* last set font */
name|enum
name|termfont
name|nextf
decl_stmt|;
comment|/* building next font here */
name|size_t
name|scale
decl_stmt|;
comment|/* font scaling factor */
name|size_t
name|pages
decl_stmt|;
comment|/* number of pages shown */
name|size_t
name|lineheight
decl_stmt|;
comment|/* line height (AFM units) */
name|size_t
name|top
decl_stmt|;
comment|/* body top (AFM units) */
name|size_t
name|bottom
decl_stmt|;
comment|/* body bottom (AFM units) */
name|size_t
name|height
decl_stmt|;
comment|/* page height (AFM units */
name|size_t
name|width
decl_stmt|;
comment|/* page width (AFM units) */
name|size_t
name|lastwidth
decl_stmt|;
comment|/* page width before last ll */
name|size_t
name|left
decl_stmt|;
comment|/* body left (AFM units) */
name|size_t
name|header
decl_stmt|;
comment|/* header pos (AFM units) */
name|size_t
name|footer
decl_stmt|;
comment|/* footer pos (AFM units) */
name|size_t
name|pdfbytes
decl_stmt|;
comment|/* current output byte */
name|size_t
name|pdflastpg
decl_stmt|;
comment|/* byte of last page mark */
name|size_t
name|pdfbody
decl_stmt|;
comment|/* start of body object */
name|size_t
modifier|*
name|pdfobjs
decl_stmt|;
comment|/* table of object offsets */
name|size_t
name|pdfobjsz
decl_stmt|;
comment|/* size of pdfobjs */
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|ps_hspan
parameter_list|(
specifier|const
name|struct
name|termp
modifier|*
parameter_list|,
specifier|const
name|struct
name|roffsu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|ps_width
parameter_list|(
specifier|const
name|struct
name|termp
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ps_advance
parameter_list|(
name|struct
name|termp
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ps_begin
parameter_list|(
name|struct
name|termp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ps_closepage
parameter_list|(
name|struct
name|termp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ps_end
parameter_list|(
name|struct
name|termp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ps_endline
parameter_list|(
name|struct
name|termp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ps_growbuf
parameter_list|(
name|struct
name|termp
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ps_letter
parameter_list|(
name|struct
name|termp
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ps_pclose
parameter_list|(
name|struct
name|termp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ps_plast
parameter_list|(
name|struct
name|termp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ps_pletter
parameter_list|(
name|struct
name|termp
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ps_printf
parameter_list|(
name|struct
name|termp
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(__format__
parameter_list|(
name|__printf__
parameter_list|,
function_decl|2
operator|,
function_decl|3
end_function_decl

begin_empty_stmt
unit|)))
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|void
name|ps_putchar
parameter_list|(
name|struct
name|termp
modifier|*
parameter_list|,
name|char
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ps_setfont
parameter_list|(
name|struct
name|termp
modifier|*
parameter_list|,
name|enum
name|termfont
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ps_setwidth
parameter_list|(
name|struct
name|termp
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|termp
modifier|*
name|pspdf_alloc
parameter_list|(
specifier|const
name|struct
name|manoutput
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pdf_obj
parameter_list|(
name|struct
name|termp
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * We define, for the time being, three fonts: bold, oblique/italic, and  * normal (roman).  The following table hard-codes the font metrics for  * ASCII, i.e., 32--127.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|font
name|fonts
index|[
name|TERMFONT__MAX
index|]
init|=
block|{
block|{
literal|"Times-Roman"
block|,
block|{
block|{
literal|250
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|408
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|833
block|}
block|,
block|{
literal|778
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|564
block|}
block|,
block|{
literal|250
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|250
block|}
block|,
block|{
literal|278
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|278
block|}
block|,
block|{
literal|278
block|}
block|,
block|{
literal|564
block|}
block|,
block|{
literal|564
block|}
block|,
block|{
literal|564
block|}
block|,
block|{
literal|444
block|}
block|,
block|{
literal|921
block|}
block|,
block|{
literal|722
block|}
block|,
block|{
literal|667
block|}
block|,
block|{
literal|667
block|}
block|,
block|{
literal|722
block|}
block|,
block|{
literal|611
block|}
block|,
block|{
literal|556
block|}
block|,
block|{
literal|722
block|}
block|,
block|{
literal|722
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|389
block|}
block|,
block|{
literal|722
block|}
block|,
block|{
literal|611
block|}
block|,
block|{
literal|889
block|}
block|,
block|{
literal|722
block|}
block|,
block|{
literal|722
block|}
block|,
block|{
literal|556
block|}
block|,
block|{
literal|722
block|}
block|,
block|{
literal|667
block|}
block|,
block|{
literal|556
block|}
block|,
block|{
literal|611
block|}
block|,
block|{
literal|722
block|}
block|,
block|{
literal|722
block|}
block|,
block|{
literal|944
block|}
block|,
block|{
literal|722
block|}
block|,
block|{
literal|722
block|}
block|,
block|{
literal|611
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|278
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|469
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|444
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|444
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|444
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|278
block|}
block|,
block|{
literal|278
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|278
block|}
block|,
block|{
literal|778
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|389
block|}
block|,
block|{
literal|278
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|722
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|444
block|}
block|,
block|{
literal|480
block|}
block|,
block|{
literal|200
block|}
block|,
block|{
literal|480
block|}
block|,
block|{
literal|541
block|}
block|, 	}
block|}
block|,
block|{
literal|"Times-Bold"
block|,
block|{
block|{
literal|250
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|555
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|1000
block|}
block|,
block|{
literal|833
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|570
block|}
block|,
block|{
literal|250
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|250
block|}
block|,
block|{
literal|278
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|570
block|}
block|,
block|{
literal|570
block|}
block|,
block|{
literal|570
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|930
block|}
block|,
block|{
literal|722
block|}
block|,
block|{
literal|667
block|}
block|,
block|{
literal|722
block|}
block|,
block|{
literal|722
block|}
block|,
block|{
literal|667
block|}
block|,
block|{
literal|611
block|}
block|,
block|{
literal|778
block|}
block|,
block|{
literal|778
block|}
block|,
block|{
literal|389
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|778
block|}
block|,
block|{
literal|667
block|}
block|,
block|{
literal|944
block|}
block|,
block|{
literal|722
block|}
block|,
block|{
literal|778
block|}
block|,
block|{
literal|611
block|}
block|,
block|{
literal|778
block|}
block|,
block|{
literal|722
block|}
block|,
block|{
literal|556
block|}
block|,
block|{
literal|667
block|}
block|,
block|{
literal|722
block|}
block|,
block|{
literal|722
block|}
block|,
block|{
literal|1000
block|}
block|,
block|{
literal|722
block|}
block|,
block|{
literal|722
block|}
block|,
block|{
literal|667
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|278
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|581
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|556
block|}
block|,
block|{
literal|444
block|}
block|,
block|{
literal|556
block|}
block|,
block|{
literal|444
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|556
block|}
block|,
block|{
literal|278
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|556
block|}
block|,
block|{
literal|278
block|}
block|,
block|{
literal|833
block|}
block|,
block|{
literal|556
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|556
block|}
block|,
block|{
literal|556
block|}
block|,
block|{
literal|444
block|}
block|,
block|{
literal|389
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|556
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|722
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|444
block|}
block|,
block|{
literal|394
block|}
block|,
block|{
literal|220
block|}
block|,
block|{
literal|394
block|}
block|,
block|{
literal|520
block|}
block|, 	}
block|}
block|,
block|{
literal|"Times-Italic"
block|,
block|{
block|{
literal|250
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|420
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|833
block|}
block|,
block|{
literal|778
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|675
block|}
block|,
block|{
literal|250
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|250
block|}
block|,
block|{
literal|278
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|675
block|}
block|,
block|{
literal|675
block|}
block|,
block|{
literal|675
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|920
block|}
block|,
block|{
literal|611
block|}
block|,
block|{
literal|611
block|}
block|,
block|{
literal|667
block|}
block|,
block|{
literal|722
block|}
block|,
block|{
literal|611
block|}
block|,
block|{
literal|611
block|}
block|,
block|{
literal|722
block|}
block|,
block|{
literal|722
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|444
block|}
block|,
block|{
literal|667
block|}
block|,
block|{
literal|556
block|}
block|,
block|{
literal|833
block|}
block|,
block|{
literal|667
block|}
block|,
block|{
literal|722
block|}
block|,
block|{
literal|611
block|}
block|,
block|{
literal|722
block|}
block|,
block|{
literal|611
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|556
block|}
block|,
block|{
literal|722
block|}
block|,
block|{
literal|611
block|}
block|,
block|{
literal|833
block|}
block|,
block|{
literal|611
block|}
block|,
block|{
literal|556
block|}
block|,
block|{
literal|556
block|}
block|,
block|{
literal|389
block|}
block|,
block|{
literal|278
block|}
block|,
block|{
literal|389
block|}
block|,
block|{
literal|422
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|444
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|444
block|}
block|,
block|{
literal|278
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|278
block|}
block|,
block|{
literal|278
block|}
block|,
block|{
literal|444
block|}
block|,
block|{
literal|278
block|}
block|,
block|{
literal|722
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|389
block|}
block|,
block|{
literal|389
block|}
block|,
block|{
literal|278
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|444
block|}
block|,
block|{
literal|667
block|}
block|,
block|{
literal|444
block|}
block|,
block|{
literal|444
block|}
block|,
block|{
literal|389
block|}
block|,
block|{
literal|400
block|}
block|,
block|{
literal|275
block|}
block|,
block|{
literal|400
block|}
block|,
block|{
literal|541
block|}
block|, 	}
block|}
block|,
block|{
literal|"Times-BoldItalic"
block|,
block|{
block|{
literal|250
block|}
block|,
block|{
literal|389
block|}
block|,
block|{
literal|555
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|833
block|}
block|,
block|{
literal|778
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|570
block|}
block|,
block|{
literal|250
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|250
block|}
block|,
block|{
literal|278
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|570
block|}
block|,
block|{
literal|570
block|}
block|,
block|{
literal|570
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|832
block|}
block|,
block|{
literal|667
block|}
block|,
block|{
literal|667
block|}
block|,
block|{
literal|667
block|}
block|,
block|{
literal|722
block|}
block|,
block|{
literal|667
block|}
block|,
block|{
literal|667
block|}
block|,
block|{
literal|722
block|}
block|,
block|{
literal|778
block|}
block|,
block|{
literal|389
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|667
block|}
block|,
block|{
literal|611
block|}
block|,
block|{
literal|889
block|}
block|,
block|{
literal|722
block|}
block|,
block|{
literal|722
block|}
block|,
block|{
literal|611
block|}
block|,
block|{
literal|722
block|}
block|,
block|{
literal|667
block|}
block|,
block|{
literal|556
block|}
block|,
block|{
literal|611
block|}
block|,
block|{
literal|722
block|}
block|,
block|{
literal|667
block|}
block|,
block|{
literal|889
block|}
block|,
block|{
literal|667
block|}
block|,
block|{
literal|611
block|}
block|,
block|{
literal|611
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|278
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|570
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|444
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|444
block|}
block|,
block|{
literal|333
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|556
block|}
block|,
block|{
literal|278
block|}
block|,
block|{
literal|278
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|278
block|}
block|,
block|{
literal|778
block|}
block|,
block|{
literal|556
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|389
block|}
block|,
block|{
literal|389
block|}
block|,
block|{
literal|278
block|}
block|,
block|{
literal|556
block|}
block|,
block|{
literal|444
block|}
block|,
block|{
literal|667
block|}
block|,
block|{
literal|500
block|}
block|,
block|{
literal|444
block|}
block|,
block|{
literal|389
block|}
block|,
block|{
literal|348
block|}
block|,
block|{
literal|220
block|}
block|,
block|{
literal|348
block|}
block|,
block|{
literal|570
block|}
block|, 	}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|void
modifier|*
name|pdf_alloc
parameter_list|(
specifier|const
name|struct
name|manoutput
modifier|*
name|outopts
parameter_list|)
block|{
name|struct
name|termp
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|p
operator|=
name|pspdf_alloc
argument_list|(
name|outopts
argument_list|)
operator|)
condition|)
name|p
operator|->
name|type
operator|=
name|TERMTYPE_PDF
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|ps_alloc
parameter_list|(
specifier|const
name|struct
name|manoutput
modifier|*
name|outopts
parameter_list|)
block|{
name|struct
name|termp
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|p
operator|=
name|pspdf_alloc
argument_list|(
name|outopts
argument_list|)
operator|)
condition|)
name|p
operator|->
name|type
operator|=
name|TERMTYPE_PS
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|termp
modifier|*
name|pspdf_alloc
parameter_list|(
specifier|const
name|struct
name|manoutput
modifier|*
name|outopts
parameter_list|)
block|{
name|struct
name|termp
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|pagex
decl_stmt|,
name|pagey
decl_stmt|;
name|size_t
name|marginx
decl_stmt|,
name|marginy
decl_stmt|,
name|lineheight
decl_stmt|;
specifier|const
name|char
modifier|*
name|pp
decl_stmt|;
name|p
operator|=
name|mandoc_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|tcol
operator|=
name|p
operator|->
name|tcols
operator|=
name|mandoc_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
operator|->
name|tcol
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|maxtcol
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|enc
operator|=
name|TERMENC_ASCII
expr_stmt|;
name|p
operator|->
name|fontq
operator|=
name|mandoc_reallocarray
argument_list|(
name|NULL
argument_list|,
operator|(
name|p
operator|->
name|fontsz
operator|=
literal|8
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
operator|->
name|fontq
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|fontq
index|[
literal|0
index|]
operator|=
name|p
operator|->
name|fontl
operator|=
name|TERMFONT_NONE
expr_stmt|;
name|p
operator|->
name|ps
operator|=
name|mandoc_calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
operator|->
name|ps
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|advance
operator|=
name|ps_advance
expr_stmt|;
name|p
operator|->
name|begin
operator|=
name|ps_begin
expr_stmt|;
name|p
operator|->
name|end
operator|=
name|ps_end
expr_stmt|;
name|p
operator|->
name|endline
operator|=
name|ps_endline
expr_stmt|;
name|p
operator|->
name|hspan
operator|=
name|ps_hspan
expr_stmt|;
name|p
operator|->
name|letter
operator|=
name|ps_letter
expr_stmt|;
name|p
operator|->
name|setwidth
operator|=
name|ps_setwidth
expr_stmt|;
name|p
operator|->
name|width
operator|=
name|ps_width
expr_stmt|;
comment|/* Default to US letter (millimetres). */
name|pagex
operator|=
literal|216
expr_stmt|;
name|pagey
operator|=
literal|279
expr_stmt|;
comment|/* 	 * The ISO-269 paper sizes can be calculated automatically, but 	 * it would require bringing in -lm for pow() and I'd rather not 	 * do that.  So just do it the easy way for now.  Since this 	 * only happens once, I'm not terribly concerned. 	 */
name|pp
operator|=
name|outopts
operator|->
name|paper
expr_stmt|;
if|if
condition|(
name|pp
operator|&&
name|strcasecmp
argument_list|(
name|pp
argument_list|,
literal|"letter"
argument_list|)
condition|)
block|{
if|if
condition|(
literal|0
operator|==
name|strcasecmp
argument_list|(
name|pp
argument_list|,
literal|"a3"
argument_list|)
condition|)
block|{
name|pagex
operator|=
literal|297
expr_stmt|;
name|pagey
operator|=
literal|420
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcasecmp
argument_list|(
name|pp
argument_list|,
literal|"a4"
argument_list|)
condition|)
block|{
name|pagex
operator|=
literal|210
expr_stmt|;
name|pagey
operator|=
literal|297
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcasecmp
argument_list|(
name|pp
argument_list|,
literal|"a5"
argument_list|)
condition|)
block|{
name|pagex
operator|=
literal|148
expr_stmt|;
name|pagey
operator|=
literal|210
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcasecmp
argument_list|(
name|pp
argument_list|,
literal|"legal"
argument_list|)
condition|)
block|{
name|pagex
operator|=
literal|216
expr_stmt|;
name|pagey
operator|=
literal|356
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|2
operator|!=
name|sscanf
argument_list|(
name|pp
argument_list|,
literal|"%ux%u"
argument_list|,
operator|&
name|pagex
argument_list|,
operator|&
name|pagey
argument_list|)
condition|)
name|warnx
argument_list|(
literal|"%s: Unknown paper"
argument_list|,
name|pp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * This MUST be defined before any PNT2AFM or AFM2PNT 	 * calculations occur. 	 */
name|p
operator|->
name|ps
operator|->
name|scale
operator|=
literal|11
expr_stmt|;
comment|/* Remember millimetres -> AFM units. */
name|pagex
operator|=
name|PNT2AFM
argument_list|(
name|p
argument_list|,
operator|(
operator|(
name|double
operator|)
name|pagex
operator|*
literal|2.834
operator|)
argument_list|)
expr_stmt|;
name|pagey
operator|=
name|PNT2AFM
argument_list|(
name|p
argument_list|,
operator|(
operator|(
name|double
operator|)
name|pagey
operator|*
literal|2.834
operator|)
argument_list|)
expr_stmt|;
comment|/* Margins are 1/9 the page x and y. */
name|marginx
operator|=
call|(
name|size_t
call|)
argument_list|(
operator|(
name|double
operator|)
name|pagex
operator|/
literal|9.0
argument_list|)
expr_stmt|;
name|marginy
operator|=
call|(
name|size_t
call|)
argument_list|(
operator|(
name|double
operator|)
name|pagey
operator|/
literal|9.0
argument_list|)
expr_stmt|;
comment|/* Line-height is 1.4em. */
name|lineheight
operator|=
name|PNT2AFM
argument_list|(
name|p
argument_list|,
operator|(
operator|(
name|double
operator|)
name|p
operator|->
name|ps
operator|->
name|scale
operator|*
literal|1.4
operator|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|ps
operator|->
name|width
operator|=
name|p
operator|->
name|ps
operator|->
name|lastwidth
operator|=
operator|(
name|size_t
operator|)
name|pagex
expr_stmt|;
name|p
operator|->
name|ps
operator|->
name|height
operator|=
operator|(
name|size_t
operator|)
name|pagey
expr_stmt|;
name|p
operator|->
name|ps
operator|->
name|header
operator|=
name|pagey
operator|-
operator|(
name|marginy
operator|/
literal|2
operator|)
operator|-
operator|(
name|lineheight
operator|/
literal|2
operator|)
expr_stmt|;
name|p
operator|->
name|ps
operator|->
name|top
operator|=
name|pagey
operator|-
name|marginy
expr_stmt|;
name|p
operator|->
name|ps
operator|->
name|footer
operator|=
operator|(
name|marginy
operator|/
literal|2
operator|)
operator|-
operator|(
name|lineheight
operator|/
literal|2
operator|)
expr_stmt|;
name|p
operator|->
name|ps
operator|->
name|bottom
operator|=
name|marginy
expr_stmt|;
name|p
operator|->
name|ps
operator|->
name|left
operator|=
name|marginx
expr_stmt|;
name|p
operator|->
name|ps
operator|->
name|lineheight
operator|=
name|lineheight
expr_stmt|;
name|p
operator|->
name|defrmargin
operator|=
name|pagex
operator|-
operator|(
name|marginx
operator|*
literal|2
operator|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ps_setwidth
parameter_list|(
name|struct
name|termp
modifier|*
name|p
parameter_list|,
name|int
name|iop
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|size_t
name|lastwidth
decl_stmt|;
name|lastwidth
operator|=
name|p
operator|->
name|ps
operator|->
name|width
expr_stmt|;
if|if
condition|(
name|iop
operator|>
literal|0
condition|)
name|p
operator|->
name|ps
operator|->
name|width
operator|+=
name|width
expr_stmt|;
elseif|else
if|if
condition|(
name|iop
operator|==
literal|0
condition|)
name|p
operator|->
name|ps
operator|->
name|width
operator|=
name|width
condition|?
operator|(
name|size_t
operator|)
name|width
else|:
name|p
operator|->
name|ps
operator|->
name|lastwidth
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|ps
operator|->
name|width
operator|>
operator|(
name|size_t
operator|)
name|width
condition|)
name|p
operator|->
name|ps
operator|->
name|width
operator|-=
name|width
expr_stmt|;
else|else
name|p
operator|->
name|ps
operator|->
name|width
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|ps
operator|->
name|lastwidth
operator|=
name|lastwidth
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pspdf_free
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|termp
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|termp
operator|*
operator|)
name|arg
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|ps
operator|->
name|psmarg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|ps
operator|->
name|pdfobjs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|ps
argument_list|)
expr_stmt|;
name|term_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ps_printf
parameter_list|(
name|struct
name|termp
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|int
name|pos
decl_stmt|,
name|len
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
comment|/* 	 * If we're running in regular mode, then pipe directly into 	 * vprintf().  If we're processing margins, then push the data 	 * into our growable margin buffer. 	 */
if|if
condition|(
operator|!
operator|(
name|PS_MARGINS
operator|&
name|p
operator|->
name|ps
operator|->
name|flags
operator|)
condition|)
block|{
name|len
operator|=
name|vprintf
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|p
operator|->
name|ps
operator|->
name|pdfbytes
operator|+=
name|len
operator|<
literal|0
condition|?
literal|0
else|:
operator|(
name|size_t
operator|)
name|len
expr_stmt|;
return|return;
block|}
comment|/* 	 * XXX: I assume that the in-margin print won't exceed 	 * PS_BUFSLOP (128 bytes), which is reasonable but still an 	 * assumption that will cause pukeage if it's not the case. 	 */
name|ps_growbuf
argument_list|(
name|p
argument_list|,
name|PS_BUFSLOP
argument_list|)
expr_stmt|;
name|pos
operator|=
operator|(
name|int
operator|)
name|p
operator|->
name|ps
operator|->
name|psmargcur
expr_stmt|;
name|vsnprintf
argument_list|(
operator|&
name|p
operator|->
name|ps
operator|->
name|psmarg
index|[
name|pos
index|]
argument_list|,
name|PS_BUFSLOP
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|p
operator|->
name|ps
operator|->
name|psmargcur
operator|=
name|strlen
argument_list|(
name|p
operator|->
name|ps
operator|->
name|psmarg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ps_putchar
parameter_list|(
name|struct
name|termp
modifier|*
name|p
parameter_list|,
name|char
name|c
parameter_list|)
block|{
name|int
name|pos
decl_stmt|;
comment|/* See ps_printf(). */
if|if
condition|(
operator|!
operator|(
name|PS_MARGINS
operator|&
name|p
operator|->
name|ps
operator|->
name|flags
operator|)
condition|)
block|{
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|p
operator|->
name|ps
operator|->
name|pdfbytes
operator|++
expr_stmt|;
return|return;
block|}
name|ps_growbuf
argument_list|(
name|p
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pos
operator|=
operator|(
name|int
operator|)
name|p
operator|->
name|ps
operator|->
name|psmargcur
operator|++
expr_stmt|;
name|p
operator|->
name|ps
operator|->
name|psmarg
index|[
name|pos
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|p
operator|->
name|ps
operator|->
name|psmarg
index|[
name|pos
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pdf_obj
parameter_list|(
name|struct
name|termp
modifier|*
name|p
parameter_list|,
name|size_t
name|obj
parameter_list|)
block|{
name|assert
argument_list|(
name|obj
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|obj
operator|-
literal|1
operator|)
operator|>=
name|p
operator|->
name|ps
operator|->
name|pdfobjsz
condition|)
block|{
name|p
operator|->
name|ps
operator|->
name|pdfobjsz
operator|=
name|obj
operator|+
literal|128
expr_stmt|;
name|p
operator|->
name|ps
operator|->
name|pdfobjs
operator|=
name|mandoc_reallocarray
argument_list|(
name|p
operator|->
name|ps
operator|->
name|pdfobjs
argument_list|,
name|p
operator|->
name|ps
operator|->
name|pdfobjsz
argument_list|,
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|ps
operator|->
name|pdfobjs
index|[
operator|(
name|int
operator|)
name|obj
operator|-
literal|1
index|]
operator|=
name|p
operator|->
name|ps
operator|->
name|pdfbytes
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"%zu 0 obj\n"
argument_list|,
name|obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ps_closepage
parameter_list|(
name|struct
name|termp
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|base
decl_stmt|;
comment|/* 	 * Close out a page that we've already flushed to output.  In 	 * PostScript, we simply note that the page must be showed.  In 	 * PDF, we must now create the Length, Resource, and Page node 	 * for the page contents. 	 */
name|assert
argument_list|(
name|p
operator|->
name|ps
operator|->
name|psmarg
operator|&&
name|p
operator|->
name|ps
operator|->
name|psmarg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"%s"
argument_list|,
name|p
operator|->
name|ps
operator|->
name|psmarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|TERMTYPE_PS
operator|!=
name|p
operator|->
name|type
condition|)
block|{
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"ET\n"
argument_list|)
expr_stmt|;
name|len
operator|=
name|p
operator|->
name|ps
operator|->
name|pdfbytes
operator|-
name|p
operator|->
name|ps
operator|->
name|pdflastpg
expr_stmt|;
name|base
operator|=
name|p
operator|->
name|ps
operator|->
name|pages
operator|*
literal|4
operator|+
name|p
operator|->
name|ps
operator|->
name|pdfbody
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"endstream\nendobj\n"
argument_list|)
expr_stmt|;
comment|/* Length of content. */
name|pdf_obj
argument_list|(
name|p
argument_list|,
name|base
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"%zu\nendobj\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Resource for content. */
name|pdf_obj
argument_list|(
name|p
argument_list|,
name|base
operator|+
literal|2
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"<<\n/ProcSet [/PDF /Text]\n"
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"/Font<<\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|TERMFONT__MAX
condition|;
name|i
operator|++
control|)
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"/F%d %d 0 R\n"
argument_list|,
name|i
argument_list|,
literal|3
operator|+
name|i
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|">>\n>>\n"
argument_list|)
expr_stmt|;
comment|/* Page node. */
name|pdf_obj
argument_list|(
name|p
argument_list|,
name|base
operator|+
literal|3
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"<<\n"
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"/Type /Page\n"
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"/Parent 2 0 R\n"
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"/Resources %zu 0 R\n"
argument_list|,
name|base
operator|+
literal|2
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"/Contents %zu 0 R\n"
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|">>\nendobj\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"showpage\n"
argument_list|)
expr_stmt|;
name|p
operator|->
name|ps
operator|->
name|pages
operator|++
expr_stmt|;
name|p
operator|->
name|ps
operator|->
name|psrow
operator|=
name|p
operator|->
name|ps
operator|->
name|top
expr_stmt|;
name|assert
argument_list|(
operator|!
operator|(
name|PS_NEWPAGE
operator|&
name|p
operator|->
name|ps
operator|->
name|flags
operator|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|ps
operator|->
name|flags
operator||=
name|PS_NEWPAGE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ps_end
parameter_list|(
name|struct
name|termp
modifier|*
name|p
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|xref
decl_stmt|,
name|base
decl_stmt|;
name|ps_plast
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ps_pclose
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 	 * At the end of the file, do one last showpage.  This is the 	 * same behaviour as groff(1) and works for multiple pages as 	 * well as just one. 	 */
if|if
condition|(
operator|!
operator|(
name|PS_NEWPAGE
operator|&
name|p
operator|->
name|ps
operator|->
name|flags
operator|)
condition|)
block|{
name|assert
argument_list|(
literal|0
operator|==
name|p
operator|->
name|ps
operator|->
name|flags
argument_list|)
expr_stmt|;
name|assert
argument_list|(
literal|'\0'
operator|==
name|p
operator|->
name|ps
operator|->
name|last
argument_list|)
expr_stmt|;
name|ps_closepage
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TERMTYPE_PS
operator|==
name|p
operator|->
name|type
condition|)
block|{
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"%%%%Trailer\n"
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"%%%%Pages: %zu\n"
argument_list|,
name|p
operator|->
name|ps
operator|->
name|pages
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"%%%%EOF\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pdf_obj
argument_list|(
name|p
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"<<\n/Type /Pages\n"
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"/MediaBox [0 0 %zu %zu]\n"
argument_list|,
operator|(
name|size_t
operator|)
name|AFM2PNT
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|ps
operator|->
name|width
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
name|AFM2PNT
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|ps
operator|->
name|height
argument_list|)
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"/Count %zu\n"
argument_list|,
name|p
operator|->
name|ps
operator|->
name|pages
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"/Kids ["
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|ps
operator|->
name|pages
condition|;
name|i
operator|++
control|)
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|" %zu 0 R"
argument_list|,
name|i
operator|*
literal|4
operator|+
name|p
operator|->
name|ps
operator|->
name|pdfbody
operator|+
literal|3
argument_list|)
expr_stmt|;
name|base
operator|=
operator|(
name|p
operator|->
name|ps
operator|->
name|pages
operator|-
literal|1
operator|)
operator|*
literal|4
operator|+
name|p
operator|->
name|ps
operator|->
name|pdfbody
operator|+
literal|4
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"]\n>>\nendobj\n"
argument_list|)
expr_stmt|;
name|pdf_obj
argument_list|(
name|p
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"<<\n"
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"/Type /Catalog\n"
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"/Pages 2 0 R\n"
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|">>\n"
argument_list|)
expr_stmt|;
name|xref
operator|=
name|p
operator|->
name|ps
operator|->
name|pdfbytes
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"xref\n"
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"0 %zu\n"
argument_list|,
name|base
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"0000000000 65535 f \n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|base
condition|;
name|i
operator|++
control|)
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"%.10zu 00000 n \n"
argument_list|,
name|p
operator|->
name|ps
operator|->
name|pdfobjs
index|[
operator|(
name|int
operator|)
name|i
index|]
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"trailer\n"
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"<<\n"
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"/Size %zu\n"
argument_list|,
name|base
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"/Root %zu 0 R\n"
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"/Info 1 0 R\n"
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|">>\n"
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"startxref\n"
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"%zu\n"
argument_list|,
name|xref
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"%%%%EOF\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ps_begin
parameter_list|(
name|struct
name|termp
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 	 * Print margins into margin buffer.  Nothing gets output to the 	 * screen yet, so we don't need to initialise the primary state. 	 */
if|if
condition|(
name|p
operator|->
name|ps
operator|->
name|psmarg
condition|)
block|{
name|assert
argument_list|(
name|p
operator|->
name|ps
operator|->
name|psmargsz
argument_list|)
expr_stmt|;
name|p
operator|->
name|ps
operator|->
name|psmarg
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/*p->ps->pdfbytes = 0;*/
name|p
operator|->
name|ps
operator|->
name|psmargcur
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|ps
operator|->
name|flags
operator|=
name|PS_MARGINS
expr_stmt|;
name|p
operator|->
name|ps
operator|->
name|pscol
operator|=
name|p
operator|->
name|ps
operator|->
name|left
expr_stmt|;
name|p
operator|->
name|ps
operator|->
name|psrow
operator|=
name|p
operator|->
name|ps
operator|->
name|header
expr_stmt|;
name|ps_setfont
argument_list|(
name|p
argument_list|,
name|TERMFONT_NONE
argument_list|)
expr_stmt|;
call|(
modifier|*
name|p
operator|->
name|headf
call|)
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|argf
argument_list|)
expr_stmt|;
call|(
modifier|*
name|p
operator|->
name|endline
call|)
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|ps
operator|->
name|pscol
operator|=
name|p
operator|->
name|ps
operator|->
name|left
expr_stmt|;
name|p
operator|->
name|ps
operator|->
name|psrow
operator|=
name|p
operator|->
name|ps
operator|->
name|footer
expr_stmt|;
call|(
modifier|*
name|p
operator|->
name|footf
call|)
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|argf
argument_list|)
expr_stmt|;
call|(
modifier|*
name|p
operator|->
name|endline
call|)
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|ps
operator|->
name|flags
operator|&=
operator|~
name|PS_MARGINS
expr_stmt|;
name|assert
argument_list|(
literal|0
operator|==
name|p
operator|->
name|ps
operator|->
name|flags
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|p
operator|->
name|ps
operator|->
name|psmarg
argument_list|)
expr_stmt|;
name|assert
argument_list|(
literal|'\0'
operator|!=
name|p
operator|->
name|ps
operator|->
name|psmarg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Print header and initialise page state.  Following this, 	 * stuff gets printed to the screen, so make sure we're sane. 	 */
if|if
condition|(
name|TERMTYPE_PS
operator|==
name|p
operator|->
name|type
condition|)
block|{
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"%%!PS-Adobe-3.0\n"
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"%%%%DocumentData: Clean7Bit\n"
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"%%%%Orientation: Portrait\n"
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"%%%%Pages: (atend)\n"
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"%%%%PageOrder: Ascend\n"
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"%%%%DocumentMedia: "
literal|"Default %zu %zu 0 () ()\n"
argument_list|,
operator|(
name|size_t
operator|)
name|AFM2PNT
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|ps
operator|->
name|width
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
name|AFM2PNT
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|ps
operator|->
name|height
argument_list|)
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"%%%%DocumentNeededResources: font"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|TERMFONT__MAX
condition|;
name|i
operator|++
control|)
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|" %s"
argument_list|,
name|fonts
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"\n%%%%EndComments\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"%%PDF-1.1\n"
argument_list|)
expr_stmt|;
name|pdf_obj
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"<<\n"
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|">>\n"
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"endobj\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|TERMFONT__MAX
condition|;
name|i
operator|++
control|)
block|{
name|pdf_obj
argument_list|(
name|p
argument_list|,
operator|(
name|size_t
operator|)
name|i
operator|+
literal|3
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"<<\n"
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"/Type /Font\n"
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"/Subtype /Type1\n"
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"/Name /F%d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"/BaseFont /%s\n"
argument_list|,
name|fonts
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|">>\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|p
operator|->
name|ps
operator|->
name|pdfbody
operator|=
operator|(
name|size_t
operator|)
name|TERMFONT__MAX
operator|+
literal|3
expr_stmt|;
name|p
operator|->
name|ps
operator|->
name|pscol
operator|=
name|p
operator|->
name|ps
operator|->
name|left
expr_stmt|;
name|p
operator|->
name|ps
operator|->
name|psrow
operator|=
name|p
operator|->
name|ps
operator|->
name|top
expr_stmt|;
name|p
operator|->
name|ps
operator|->
name|flags
operator||=
name|PS_NEWPAGE
expr_stmt|;
name|ps_setfont
argument_list|(
name|p
argument_list|,
name|TERMFONT_NONE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ps_pletter
parameter_list|(
name|struct
name|termp
modifier|*
name|p
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|int
name|f
decl_stmt|;
comment|/* 	 * If we haven't opened a page context, then output that we're 	 * in a new page and make sure the font is correctly set. 	 */
if|if
condition|(
name|PS_NEWPAGE
operator|&
name|p
operator|->
name|ps
operator|->
name|flags
condition|)
block|{
if|if
condition|(
name|TERMTYPE_PS
operator|==
name|p
operator|->
name|type
condition|)
block|{
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"%%%%Page: %zu %zu\n"
argument_list|,
name|p
operator|->
name|ps
operator|->
name|pages
operator|+
literal|1
argument_list|,
name|p
operator|->
name|ps
operator|->
name|pages
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"/%s %zu selectfont\n"
argument_list|,
name|fonts
index|[
operator|(
name|int
operator|)
name|p
operator|->
name|ps
operator|->
name|lastf
index|]
operator|.
name|name
argument_list|,
name|p
operator|->
name|ps
operator|->
name|scale
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pdf_obj
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|ps
operator|->
name|pdfbody
operator|+
name|p
operator|->
name|ps
operator|->
name|pages
operator|*
literal|4
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"<<\n"
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"/Length %zu 0 R\n"
argument_list|,
name|p
operator|->
name|ps
operator|->
name|pdfbody
operator|+
literal|1
operator|+
name|p
operator|->
name|ps
operator|->
name|pages
operator|*
literal|4
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|">>\nstream\n"
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|ps
operator|->
name|pdflastpg
operator|=
name|p
operator|->
name|ps
operator|->
name|pdfbytes
expr_stmt|;
name|p
operator|->
name|ps
operator|->
name|flags
operator|&=
operator|~
name|PS_NEWPAGE
expr_stmt|;
block|}
comment|/* 	 * If we're not in a PostScript "word" context, then open one 	 * now at the current cursor. 	 */
if|if
condition|(
operator|!
operator|(
name|PS_INLINE
operator|&
name|p
operator|->
name|ps
operator|->
name|flags
operator|)
condition|)
block|{
if|if
condition|(
name|TERMTYPE_PS
operator|!=
name|p
operator|->
name|type
condition|)
block|{
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"BT\n/F%d %zu Tf\n"
argument_list|,
operator|(
name|int
operator|)
name|p
operator|->
name|ps
operator|->
name|lastf
argument_list|,
name|p
operator|->
name|ps
operator|->
name|scale
argument_list|)
expr_stmt|;
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"%.3f %.3f Td\n("
argument_list|,
name|AFM2PNT
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|ps
operator|->
name|pscol
argument_list|)
argument_list|,
name|AFM2PNT
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|ps
operator|->
name|psrow
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"%.3f %.3f moveto\n("
argument_list|,
name|AFM2PNT
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|ps
operator|->
name|pscol
argument_list|)
argument_list|,
name|AFM2PNT
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|ps
operator|->
name|psrow
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|ps
operator|->
name|flags
operator||=
name|PS_INLINE
expr_stmt|;
block|}
name|assert
argument_list|(
operator|!
operator|(
name|PS_NEWPAGE
operator|&
name|p
operator|->
name|ps
operator|->
name|flags
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * We need to escape these characters as per the PostScript 	 * specification.  We would also escape non-graphable characters 	 * (like tabs), but none of them would get to this point and 	 * it's superfluous to abort() on them. 	 */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'('
case|:
case|case
literal|')'
case|:
case|case
literal|'\\'
case|:
name|ps_putchar
argument_list|(
name|p
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Write the character and adjust where we are on the page. */
name|f
operator|=
operator|(
name|int
operator|)
name|p
operator|->
name|ps
operator|->
name|lastf
expr_stmt|;
if|if
condition|(
name|c
operator|<=
literal|32
operator|||
name|c
operator|-
literal|32
operator|>=
name|MAXCHAR
condition|)
name|c
operator|=
literal|32
expr_stmt|;
name|ps_putchar
argument_list|(
name|p
argument_list|,
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
name|c
operator|-=
literal|32
expr_stmt|;
name|p
operator|->
name|ps
operator|->
name|pscol
operator|+=
operator|(
name|size_t
operator|)
name|fonts
index|[
name|f
index|]
operator|.
name|gly
index|[
name|c
index|]
operator|.
name|wx
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ps_pclose
parameter_list|(
name|struct
name|termp
modifier|*
name|p
parameter_list|)
block|{
comment|/* 	 * Spit out that we're exiting a word context (this is a 	 * "partial close" because we don't check the last-char buffer 	 * or anything). 	 */
if|if
condition|(
operator|!
operator|(
name|PS_INLINE
operator|&
name|p
operator|->
name|ps
operator|->
name|flags
operator|)
condition|)
return|return;
if|if
condition|(
name|TERMTYPE_PS
operator|!=
name|p
operator|->
name|type
condition|)
block|{
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|") Tj\nET\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|") show\n"
argument_list|)
expr_stmt|;
name|p
operator|->
name|ps
operator|->
name|flags
operator|&=
operator|~
name|PS_INLINE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If we have a `last' char that wasn't printed yet, print it now. */
end_comment

begin_function
specifier|static
name|void
name|ps_plast
parameter_list|(
name|struct
name|termp
modifier|*
name|p
parameter_list|)
block|{
name|size_t
name|wx
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|ps
operator|->
name|last
operator|==
literal|'\0'
condition|)
return|return;
comment|/* Check the font mode; open a new scope if it doesn't match. */
if|if
condition|(
name|p
operator|->
name|ps
operator|->
name|nextf
operator|!=
name|p
operator|->
name|ps
operator|->
name|lastf
condition|)
block|{
name|ps_pclose
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ps_setfont
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|ps
operator|->
name|nextf
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|ps
operator|->
name|nextf
operator|=
name|TERMFONT_NONE
expr_stmt|;
comment|/* 	 * For an overstrike, if a previous character 	 * was wider, advance to center the new one. 	 */
if|if
condition|(
name|p
operator|->
name|ps
operator|->
name|pscolnext
condition|)
block|{
name|wx
operator|=
name|fonts
index|[
name|p
operator|->
name|ps
operator|->
name|lastf
index|]
operator|.
name|gly
index|[
operator|(
name|int
operator|)
name|p
operator|->
name|ps
operator|->
name|last
operator|-
literal|32
index|]
operator|.
name|wx
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|ps
operator|->
name|pscol
operator|+
name|wx
operator|<
name|p
operator|->
name|ps
operator|->
name|pscolnext
condition|)
name|p
operator|->
name|ps
operator|->
name|pscol
operator|=
operator|(
name|p
operator|->
name|ps
operator|->
name|pscol
operator|+
name|p
operator|->
name|ps
operator|->
name|pscolnext
operator|-
name|wx
operator|)
operator|/
literal|2
expr_stmt|;
block|}
name|ps_pletter
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|ps
operator|->
name|last
argument_list|)
expr_stmt|;
name|p
operator|->
name|ps
operator|->
name|last
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * For an overstrike, if a previous character 	 * was wider, advance to the end of the old one. 	 */
if|if
condition|(
name|p
operator|->
name|ps
operator|->
name|pscol
operator|<
name|p
operator|->
name|ps
operator|->
name|pscolnext
condition|)
block|{
name|ps_pclose
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|ps
operator|->
name|pscol
operator|=
name|p
operator|->
name|ps
operator|->
name|pscolnext
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ps_letter
parameter_list|(
name|struct
name|termp
modifier|*
name|p
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
name|size_t
name|savecol
decl_stmt|;
name|char
name|c
decl_stmt|;
name|c
operator|=
name|arg
operator|>=
literal|128
operator|||
name|arg
operator|<=
literal|0
condition|?
literal|'?'
else|:
name|arg
expr_stmt|;
comment|/* 	 * When receiving a backspace, merely flag it. 	 * We don't know yet whether it is 	 * a font instruction or an overstrike. 	 */
if|if
condition|(
name|c
operator|==
literal|'\b'
condition|)
block|{
name|assert
argument_list|(
name|p
operator|->
name|ps
operator|->
name|last
operator|!=
literal|'\0'
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
operator|(
name|p
operator|->
name|ps
operator|->
name|flags
operator|&
name|PS_BACKSP
operator|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|ps
operator|->
name|flags
operator||=
name|PS_BACKSP
expr_stmt|;
return|return;
block|}
comment|/* 	 * Decode font instructions. 	 */
if|if
condition|(
name|p
operator|->
name|ps
operator|->
name|flags
operator|&
name|PS_BACKSP
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|ps
operator|->
name|last
operator|==
literal|'_'
condition|)
block|{
switch|switch
condition|(
name|p
operator|->
name|ps
operator|->
name|nextf
condition|)
block|{
case|case
name|TERMFONT_BI
case|:
break|break;
case|case
name|TERMFONT_BOLD
case|:
name|p
operator|->
name|ps
operator|->
name|nextf
operator|=
name|TERMFONT_BI
expr_stmt|;
break|break;
default|default:
name|p
operator|->
name|ps
operator|->
name|nextf
operator|=
name|TERMFONT_UNDER
expr_stmt|;
block|}
name|p
operator|->
name|ps
operator|->
name|last
operator|=
name|c
expr_stmt|;
name|p
operator|->
name|ps
operator|->
name|flags
operator|&=
operator|~
name|PS_BACKSP
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p
operator|->
name|ps
operator|->
name|last
operator|==
name|c
condition|)
block|{
switch|switch
condition|(
name|p
operator|->
name|ps
operator|->
name|nextf
condition|)
block|{
case|case
name|TERMFONT_BI
case|:
break|break;
case|case
name|TERMFONT_UNDER
case|:
name|p
operator|->
name|ps
operator|->
name|nextf
operator|=
name|TERMFONT_BI
expr_stmt|;
break|break;
default|default:
name|p
operator|->
name|ps
operator|->
name|nextf
operator|=
name|TERMFONT_BOLD
expr_stmt|;
block|}
name|p
operator|->
name|ps
operator|->
name|flags
operator|&=
operator|~
name|PS_BACKSP
expr_stmt|;
return|return;
block|}
comment|/* 		 * This is not a font instruction, but rather 		 * the next character.  Prepare for overstrike. 		 */
name|savecol
operator|=
name|p
operator|->
name|ps
operator|->
name|pscol
expr_stmt|;
block|}
else|else
name|savecol
operator|=
name|SIZE_MAX
expr_stmt|;
comment|/* 	 * We found the next character, so the font instructions 	 * for the previous one are complete. 	 * Use them and print it. 	 */
name|ps_plast
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 	 * Do not print the current character yet because font 	 * instructions might follow; only remember the character. 	 * It will get printed later from ps_plast(). 	 */
name|p
operator|->
name|ps
operator|->
name|last
operator|=
name|c
expr_stmt|;
comment|/* 	 * For an overstrike, back up to the previous position. 	 * If the previous character is wider than any it overstrikes, 	 * remember the current position, because it might also be 	 * wider than all that will overstrike it. 	 */
if|if
condition|(
name|savecol
operator|!=
name|SIZE_MAX
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|ps
operator|->
name|pscolnext
operator|<
name|p
operator|->
name|ps
operator|->
name|pscol
condition|)
name|p
operator|->
name|ps
operator|->
name|pscolnext
operator|=
name|p
operator|->
name|ps
operator|->
name|pscol
expr_stmt|;
name|ps_pclose
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|ps
operator|->
name|pscol
operator|=
name|savecol
expr_stmt|;
name|p
operator|->
name|ps
operator|->
name|flags
operator|&=
operator|~
name|PS_BACKSP
expr_stmt|;
block|}
else|else
name|p
operator|->
name|ps
operator|->
name|pscolnext
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ps_advance
parameter_list|(
name|struct
name|termp
modifier|*
name|p
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
comment|/* 	 * Advance some spaces.  This can probably be made smarter, 	 * i.e., to have multiple space-separated words in the same 	 * scope, but this is easier:  just close out the current scope 	 * and readjust our column settings. 	 */
name|ps_plast
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ps_pclose
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|ps
operator|->
name|pscol
operator|+=
name|len
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ps_endline
parameter_list|(
name|struct
name|termp
modifier|*
name|p
parameter_list|)
block|{
comment|/* Close out any scopes we have open: we're at eoln. */
name|ps_plast
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ps_pclose
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 	 * If we're in the margin, don't try to recalculate our current 	 * row.  XXX: if the column tries to be fancy with multiple 	 * lines, we'll do nasty stuff. 	 */
if|if
condition|(
name|PS_MARGINS
operator|&
name|p
operator|->
name|ps
operator|->
name|flags
condition|)
return|return;
comment|/* Left-justify. */
name|p
operator|->
name|ps
operator|->
name|pscol
operator|=
name|p
operator|->
name|ps
operator|->
name|left
expr_stmt|;
comment|/* If we haven't printed anything, return. */
if|if
condition|(
name|PS_NEWPAGE
operator|&
name|p
operator|->
name|ps
operator|->
name|flags
condition|)
return|return;
comment|/* 	 * Put us down a line.  If we're at the page bottom, spit out a 	 * showpage and restart our row. 	 */
if|if
condition|(
name|p
operator|->
name|ps
operator|->
name|psrow
operator|>=
name|p
operator|->
name|ps
operator|->
name|lineheight
operator|+
name|p
operator|->
name|ps
operator|->
name|bottom
condition|)
block|{
name|p
operator|->
name|ps
operator|->
name|psrow
operator|-=
name|p
operator|->
name|ps
operator|->
name|lineheight
expr_stmt|;
return|return;
block|}
name|ps_closepage
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|tcol
operator|->
name|offset
operator|-=
name|p
operator|->
name|ti
expr_stmt|;
name|p
operator|->
name|ti
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ps_setfont
parameter_list|(
name|struct
name|termp
modifier|*
name|p
parameter_list|,
name|enum
name|termfont
name|f
parameter_list|)
block|{
name|assert
argument_list|(
name|f
operator|<
name|TERMFONT__MAX
argument_list|)
expr_stmt|;
name|p
operator|->
name|ps
operator|->
name|lastf
operator|=
name|f
expr_stmt|;
comment|/* 	 * If we're still at the top of the page, let the font-setting 	 * be delayed until we actually have stuff to print. 	 */
if|if
condition|(
name|PS_NEWPAGE
operator|&
name|p
operator|->
name|ps
operator|->
name|flags
condition|)
return|return;
if|if
condition|(
name|TERMTYPE_PS
operator|==
name|p
operator|->
name|type
condition|)
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"/%s %zu selectfont\n"
argument_list|,
name|fonts
index|[
operator|(
name|int
operator|)
name|f
index|]
operator|.
name|name
argument_list|,
name|p
operator|->
name|ps
operator|->
name|scale
argument_list|)
expr_stmt|;
else|else
name|ps_printf
argument_list|(
name|p
argument_list|,
literal|"/F%d %zu Tf\n"
argument_list|,
operator|(
name|int
operator|)
name|f
argument_list|,
name|p
operator|->
name|ps
operator|->
name|scale
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|ps_width
parameter_list|(
specifier|const
name|struct
name|termp
modifier|*
name|p
parameter_list|,
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|<=
literal|32
operator|||
name|c
operator|-
literal|32
operator|>=
name|MAXCHAR
condition|)
name|c
operator|=
literal|0
expr_stmt|;
else|else
name|c
operator|-=
literal|32
expr_stmt|;
return|return
operator|(
name|size_t
operator|)
name|fonts
index|[
operator|(
name|int
operator|)
name|TERMFONT_NONE
index|]
operator|.
name|gly
index|[
name|c
index|]
operator|.
name|wx
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ps_hspan
parameter_list|(
specifier|const
name|struct
name|termp
modifier|*
name|p
parameter_list|,
specifier|const
name|struct
name|roffsu
modifier|*
name|su
parameter_list|)
block|{
name|double
name|r
decl_stmt|;
comment|/* 	 * All of these measurements are derived by converting from the 	 * native measurement to AFM units. 	 */
switch|switch
condition|(
name|su
operator|->
name|unit
condition|)
block|{
case|case
name|SCALE_BU
case|:
comment|/* 		 * Traditionally, the default unit is fixed to the 		 * output media.  So this would refer to the point.  In 		 * mandoc(1), however, we stick to the default terminal 		 * scaling unit so that output is the same regardless 		 * the media. 		 */
name|r
operator|=
name|PNT2AFM
argument_list|(
name|p
argument_list|,
name|su
operator|->
name|scale
operator|*
literal|72.0
operator|/
literal|240.0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCALE_CM
case|:
name|r
operator|=
name|PNT2AFM
argument_list|(
name|p
argument_list|,
name|su
operator|->
name|scale
operator|*
literal|72.0
operator|/
literal|2.54
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCALE_EM
case|:
name|r
operator|=
name|su
operator|->
name|scale
operator|*
name|fonts
index|[
operator|(
name|int
operator|)
name|TERMFONT_NONE
index|]
operator|.
name|gly
index|[
literal|109
operator|-
literal|32
index|]
operator|.
name|wx
expr_stmt|;
break|break;
case|case
name|SCALE_EN
case|:
name|r
operator|=
name|su
operator|->
name|scale
operator|*
name|fonts
index|[
operator|(
name|int
operator|)
name|TERMFONT_NONE
index|]
operator|.
name|gly
index|[
literal|110
operator|-
literal|32
index|]
operator|.
name|wx
expr_stmt|;
break|break;
case|case
name|SCALE_IN
case|:
name|r
operator|=
name|PNT2AFM
argument_list|(
name|p
argument_list|,
name|su
operator|->
name|scale
operator|*
literal|72.0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCALE_MM
case|:
name|r
operator|=
name|su
operator|->
name|scale
operator|*
name|fonts
index|[
operator|(
name|int
operator|)
name|TERMFONT_NONE
index|]
operator|.
name|gly
index|[
literal|109
operator|-
literal|32
index|]
operator|.
name|wx
operator|/
literal|100.0
expr_stmt|;
break|break;
case|case
name|SCALE_PC
case|:
name|r
operator|=
name|PNT2AFM
argument_list|(
name|p
argument_list|,
name|su
operator|->
name|scale
operator|*
literal|12.0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCALE_PT
case|:
name|r
operator|=
name|PNT2AFM
argument_list|(
name|p
argument_list|,
name|su
operator|->
name|scale
operator|*
literal|1.0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCALE_VS
case|:
name|r
operator|=
name|su
operator|->
name|scale
operator|*
name|p
operator|->
name|ps
operator|->
name|lineheight
expr_stmt|;
break|break;
default|default:
name|r
operator|=
name|su
operator|->
name|scale
expr_stmt|;
break|break;
block|}
return|return
name|r
operator|*
literal|24.0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ps_growbuf
parameter_list|(
name|struct
name|termp
modifier|*
name|p
parameter_list|,
name|size_t
name|sz
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|ps
operator|->
name|psmargcur
operator|+
name|sz
operator|<=
name|p
operator|->
name|ps
operator|->
name|psmargsz
condition|)
return|return;
if|if
condition|(
name|sz
operator|<
name|PS_BUFSLOP
condition|)
name|sz
operator|=
name|PS_BUFSLOP
expr_stmt|;
name|p
operator|->
name|ps
operator|->
name|psmargsz
operator|+=
name|sz
expr_stmt|;
name|p
operator|->
name|ps
operator|->
name|psmarg
operator|=
name|mandoc_realloc
argument_list|(
name|p
operator|->
name|ps
operator|->
name|psmarg
argument_list|,
name|p
operator|->
name|ps
operator|->
name|psmargsz
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

