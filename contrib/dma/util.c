begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2008-2014, Simon Schubert<2@0x2c.org>.  * Copyright (c) 2008 The DragonFly Project.  All rights reserved.  *  * This code is derived from software contributed to The DragonFly Project  * by Simon Schubert<2@0x2c.org>.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  * 3. Neither the name of The DragonFly Project nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific, prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE  * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING,  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"dma.h"
end_include

begin_function
specifier|const
name|char
modifier|*
name|hostname
parameter_list|(
name|void
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|HOST_NAME_MAX
define|#
directive|define
name|HOST_NAME_MAX
value|255
endif|#
directive|endif
specifier|static
name|char
name|name
index|[
name|HOST_NAME_MAX
operator|+
literal|1
index|]
decl_stmt|;
specifier|static
name|int
name|initialized
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|initialized
condition|)
return|return
operator|(
name|name
operator|)
return|;
if|if
condition|(
name|config
operator|.
name|mailname
operator|==
name|NULL
operator|||
operator|!
operator|*
name|config
operator|.
name|mailname
condition|)
goto|goto
name|local
goto|;
if|if
condition|(
name|config
operator|.
name|mailname
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
comment|/* 		 * If the mailname looks like an absolute path, 		 * treat it as a file. 		 */
name|FILE
modifier|*
name|fp
decl_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|config
operator|.
name|mailname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
goto|goto
name|local
goto|;
name|s
operator|=
name|fgets
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
goto|goto
name|local
goto|;
for|for
control|(
name|s
operator|=
name|name
init|;
operator|*
name|s
operator|!=
literal|0
operator|&&
operator|(
name|isalnum
argument_list|(
operator|*
name|s
argument_list|)
operator|||
name|strchr
argument_list|(
literal|"_.-"
argument_list|,
operator|*
name|s
argument_list|)
operator|)
condition|;
operator|++
name|s
control|)
comment|/* NOTHING */
empty_stmt|;
operator|*
name|s
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|name
condition|)
goto|goto
name|local
goto|;
name|initialized
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|name
operator|)
return|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|config
operator|.
name|mailname
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|name
operator|)
return|;
block|}
name|local
label|:
if|if
condition|(
name|gethostname
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
operator|*
name|name
operator|=
literal|0
expr_stmt|;
comment|/* 	 * gethostname() is allowed to truncate name without NUL-termination 	 * and at the same time not return an error. 	 */
name|name
index|[
sizeof|sizeof
argument_list|(
name|name
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s
operator|=
name|name
init|;
operator|*
name|s
operator|!=
literal|0
operator|&&
operator|(
name|isalnum
argument_list|(
operator|*
name|s
argument_list|)
operator|||
name|strchr
argument_list|(
literal|"_.-"
argument_list|,
operator|*
name|s
argument_list|)
operator|)
condition|;
operator|++
name|s
control|)
comment|/* NOTHING */
empty_stmt|;
operator|*
name|s
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|name
condition|)
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"unknown-hostname"
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_function
name|void
name|setlogident
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
specifier|static
name|char
name|tag
index|[
literal|50
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|tag
argument_list|,
sizeof|sizeof
argument_list|(
name|tag
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|logident_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|!=
name|NULL
condition|)
block|{
name|va_list
name|ap
decl_stmt|;
name|char
name|sufx
index|[
literal|50
index|]
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|sufx
argument_list|,
sizeof|sizeof
argument_list|(
name|sufx
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tag
argument_list|,
sizeof|sizeof
argument_list|(
name|tag
argument_list|)
argument_list|,
literal|"%s[%s]"
argument_list|,
name|logident_base
argument_list|,
name|sufx
argument_list|)
expr_stmt|;
block|}
name|closelog
argument_list|()
expr_stmt|;
name|openlog
argument_list|(
name|tag
argument_list|,
literal|0
argument_list|,
name|LOG_MAIL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|errlog
parameter_list|(
name|int
name|exitcode
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|oerrno
init|=
name|errno
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|char
name|outs
index|[
name|ERRMSG_SIZE
index|]
decl_stmt|;
name|outs
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fmt
operator|!=
name|NULL
condition|)
block|{
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|outs
argument_list|,
sizeof|sizeof
argument_list|(
name|outs
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
name|errno
operator|=
name|oerrno
expr_stmt|;
if|if
condition|(
operator|*
name|outs
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: %m"
argument_list|,
name|outs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: %s\n"
argument_list|,
name|getprogname
argument_list|()
argument_list|,
name|outs
argument_list|,
name|strerror
argument_list|(
name|oerrno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%m"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|getprogname
argument_list|()
argument_list|,
name|strerror
argument_list|(
name|oerrno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|exitcode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|errlogx
parameter_list|(
name|int
name|exitcode
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|char
name|outs
index|[
name|ERRMSG_SIZE
index|]
decl_stmt|;
name|outs
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fmt
operator|!=
name|NULL
condition|)
block|{
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|outs
argument_list|,
sizeof|sizeof
argument_list|(
name|outs
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|outs
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s"
argument_list|,
name|outs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|getprogname
argument_list|()
argument_list|,
name|outs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unknown error"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Unknown error\n"
argument_list|,
name|getprogname
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|exitcode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_username
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uid_t
name|ckuid
parameter_list|)
block|{
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|pwd
operator|=
name|getpwnam
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|==
name|NULL
operator|||
name|pwd
operator|->
name|pw_uid
operator|!=
name|ckuid
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|snprintf
argument_list|(
name|username
argument_list|,
sizeof|sizeof
argument_list|(
name|username
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|set_username
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
name|useruid
operator|=
name|getuid
argument_list|()
expr_stmt|;
if|if
condition|(
name|check_username
argument_list|(
name|getlogin
argument_list|()
argument_list|,
name|useruid
argument_list|)
condition|)
return|return;
if|if
condition|(
name|check_username
argument_list|(
name|getenv
argument_list|(
literal|"LOGNAME"
argument_list|)
argument_list|,
name|useruid
argument_list|)
condition|)
return|return;
if|if
condition|(
name|check_username
argument_list|(
name|getenv
argument_list|(
literal|"USER"
argument_list|)
argument_list|,
name|useruid
argument_list|)
condition|)
return|return;
name|pwd
operator|=
name|getpwuid
argument_list|(
name|useruid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|!=
name|NULL
operator|&&
name|pwd
operator|->
name|pw_name
operator|!=
name|NULL
operator|&&
name|pwd
operator|->
name|pw_name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|check_username
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|,
name|useruid
argument_list|)
condition|)
return|return;
block|}
name|snprintf
argument_list|(
name|username
argument_list|,
sizeof|sizeof
argument_list|(
name|username
argument_list|)
argument_list|,
literal|"uid=%ld"
argument_list|,
operator|(
name|long
operator|)
name|useruid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|deltmp
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|stritem
modifier|*
name|t
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|t
argument_list|,
argument|&tmpfs
argument_list|,
argument|next
argument_list|)
block|{
name|unlink
argument_list|(
name|t
operator|->
name|str
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|sigjmp_buf
name|sigbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sigbuf_valid
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|sigalrm_handler
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
operator|(
name|void
operator|)
name|signo
expr_stmt|;
comment|/* so that gcc doesn't complain */
if|if
condition|(
name|sigbuf_valid
condition|)
name|siglongjmp
argument_list|(
name|sigbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|do_timeout
parameter_list|(
name|int
name|timeout
parameter_list|,
name|int
name|dojmp
parameter_list|)
block|{
name|struct
name|sigaction
name|act
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|act
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|timeout
condition|)
block|{
name|act
operator|.
name|sa_handler
operator|=
name|sigalrm_handler
expr_stmt|;
if|if
condition|(
name|sigaction
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|act
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"can not set signal handler: %m"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dojmp
condition|)
block|{
name|ret
operator|=
name|sigsetjmp
argument_list|(
name|sigbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|disable
goto|;
comment|/* else just programmed */
name|sigbuf_valid
operator|=
literal|1
expr_stmt|;
block|}
name|alarm
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|disable
label|:
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_handler
operator|=
name|SIG_IGN
expr_stmt|;
if|if
condition|(
name|sigaction
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|act
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"can not remove signal handler: %m"
argument_list|)
expr_stmt|;
name|sigbuf_valid
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|open_locked
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
name|int
name|flags
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|mode
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|O_CREAT
condition|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|mode
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|O_EXLOCK
name|int
name|fd
decl_stmt|,
name|save_errno
decl_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|fname
argument_list|,
name|flags
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
operator|(
name|fd
operator|)
return|;
if|if
condition|(
name|flock
argument_list|(
name|fd
argument_list|,
name|LOCK_EX
operator||
operator|(
operator|(
name|flags
operator|&
name|O_NONBLOCK
operator|)
condition|?
name|LOCK_NB
else|:
literal|0
operator|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|save_errno
operator|=
name|errno
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|fd
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|open
argument_list|(
name|fname
argument_list|,
name|flags
operator||
name|O_EXLOCK
argument_list|,
name|mode
argument_list|)
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|char
modifier|*
name|rfc822date
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|char
name|str
index|[
literal|50
index|]
decl_stmt|;
name|size_t
name|error
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|now
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|strftime
argument_list|(
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
literal|"%a, %d %b %Y %T %z"
argument_list|,
name|localtime
argument_list|(
operator|&
name|now
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|str
argument_list|,
literal|"(date fail)"
argument_list|)
expr_stmt|;
return|return
operator|(
name|str
operator|)
return|;
block|}
end_function

begin_function
name|int
name|strprefixcmp
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
return|return
operator|(
name|strncasecmp
argument_list|(
name|str
argument_list|,
name|prefix
argument_list|,
name|strlen
argument_list|(
name|prefix
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|init_random
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|seed
decl_stmt|;
name|int
name|rf
decl_stmt|;
name|rf
operator|=
name|open
argument_list|(
literal|"/dev/urandom"
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf
operator|==
operator|-
literal|1
condition|)
name|rf
operator|=
name|open
argument_list|(
literal|"/dev/random"
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|rf
operator|!=
operator|-
literal|1
operator|&&
name|read
argument_list|(
name|rf
argument_list|,
operator|&
name|seed
argument_list|,
sizeof|sizeof
argument_list|(
name|seed
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|seed
argument_list|)
operator|)
condition|)
name|seed
operator|=
operator|(
name|time
argument_list|(
name|NULL
argument_list|)
operator|^
name|getpid
argument_list|()
operator|)
operator|+
operator|(
name|uintptr_t
operator|)
operator|&
name|seed
expr_stmt|;
name|srandom
argument_list|(
name|seed
argument_list|)
expr_stmt|;
if|if
condition|(
name|rf
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|rf
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

