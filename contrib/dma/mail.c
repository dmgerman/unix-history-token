begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2008 The DragonFly Project.  All rights reserved.  *  * This code is derived from software contributed to The DragonFly Project  * by Simon 'corecode' Schubert<corecode@fs.ei.tum.de>.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  * 3. Neither the name of The DragonFly Project nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific, prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE  * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING,  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"dma.h"
end_include

begin_function
name|void
name|bounce
parameter_list|(
name|struct
name|qitem
modifier|*
name|it
parameter_list|,
specifier|const
name|char
modifier|*
name|reason
parameter_list|)
block|{
name|struct
name|queue
name|bounceq
decl_stmt|;
name|char
name|line
index|[
literal|1000
index|]
decl_stmt|;
name|size_t
name|pos
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Don't bounce bounced mails */
if|if
condition|(
name|it
operator|->
name|sender
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"can not bounce a bounce message, discarding"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|&
name|bounceq
argument_list|,
sizeof|sizeof
argument_list|(
name|bounceq
argument_list|)
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|bounceq
operator|.
name|queue
argument_list|)
expr_stmt|;
name|bounceq
operator|.
name|sender
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|add_recp
argument_list|(
operator|&
name|bounceq
argument_list|,
name|it
operator|->
name|sender
argument_list|,
name|EXPAND_WILDCARD
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|newspoolf
argument_list|(
operator|&
name|bounceq
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"delivery failed, bouncing as %s"
argument_list|,
name|bounceq
operator|.
name|id
argument_list|)
expr_stmt|;
name|setlogident
argument_list|(
literal|"%s"
argument_list|,
name|bounceq
operator|.
name|id
argument_list|)
expr_stmt|;
name|error
operator|=
name|fprintf
argument_list|(
name|bounceq
operator|.
name|mailf
argument_list|,
literal|"Received: from MAILER-DAEMON\n"
literal|"\tid %s\n"
literal|"\tby %s (%s);\n"
literal|"\t%s\n"
literal|"X-Original-To:<%s>\n"
literal|"From: MAILER-DAEMON<>\n"
literal|"To: %s\n"
literal|"Subject: Mail delivery failed\n"
literal|"Message-Id:<%s@%s>\n"
literal|"Date: %s\n"
literal|"\n"
literal|"This is the %s at %s.\n"
literal|"\n"
literal|"There was an error delivering your mail to<%s>.\n"
literal|"\n"
literal|"%s\n"
literal|"\n"
literal|"%s\n"
literal|"\n"
argument_list|,
name|bounceq
operator|.
name|id
argument_list|,
name|hostname
argument_list|()
argument_list|,
name|VERSION
argument_list|,
name|rfc822date
argument_list|()
argument_list|,
name|it
operator|->
name|addr
argument_list|,
name|it
operator|->
name|sender
argument_list|,
name|bounceq
operator|.
name|id
argument_list|,
name|hostname
argument_list|()
argument_list|,
name|rfc822date
argument_list|()
argument_list|,
name|VERSION
argument_list|,
name|hostname
argument_list|()
argument_list|,
name|it
operator|->
name|addr
argument_list|,
name|reason
argument_list|,
name|config
operator|.
name|features
operator|&
name|FULLBOUNCE
condition|?
literal|"Original message follows."
else|:
literal|"Message headers follow."
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|<
literal|0
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|fseek
argument_list|(
name|it
operator|->
name|mailf
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|config
operator|.
name|features
operator|&
name|FULLBOUNCE
condition|)
block|{
while|while
condition|(
operator|(
name|pos
operator|=
name|fread
argument_list|(
name|line
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|it
operator|->
name|mailf
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|fwrite
argument_list|(
name|line
argument_list|,
literal|1
argument_list|,
name|pos
argument_list|,
name|bounceq
operator|.
name|mailf
argument_list|)
operator|!=
name|pos
condition|)
goto|goto
name|fail
goto|;
block|}
block|}
else|else
block|{
while|while
condition|(
operator|!
name|feof
argument_list|(
name|it
operator|->
name|mailf
argument_list|)
condition|)
block|{
if|if
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|it
operator|->
name|mailf
argument_list|)
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'\n'
condition|)
break|break;
if|if
condition|(
name|fwrite
argument_list|(
name|line
argument_list|,
name|strlen
argument_list|(
name|line
argument_list|)
argument_list|,
literal|1
argument_list|,
name|bounceq
operator|.
name|mailf
argument_list|)
operator|!=
literal|1
condition|)
goto|goto
name|fail
goto|;
block|}
block|}
if|if
condition|(
name|linkspool
argument_list|(
operator|&
name|bounceq
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* bounce is safe */
name|delqueue
argument_list|(
name|it
argument_list|)
expr_stmt|;
name|run_queue
argument_list|(
operator|&
name|bounceq
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
name|fail
label|:
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"error creating bounce: %m"
argument_list|)
expr_stmt|;
name|delqueue
argument_list|(
name|it
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|parse_state
block|{
name|char
name|addr
index|[
literal|1000
index|]
decl_stmt|;
name|int
name|pos
decl_stmt|;
enum|enum
block|{
name|NONE
init|=
literal|0
block|,
name|START
block|,
name|MAIN
block|,
name|EOL
block|,
name|QUIT
block|}
name|state
enum|;
name|int
name|comment
decl_stmt|;
name|int
name|quote
decl_stmt|;
name|int
name|brackets
decl_stmt|;
name|int
name|esc
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Simplified RFC2822 header/address parsing.  * We copy escapes and quoted strings directly, since  * we have to pass them like this to the mail server anyways.  * XXX local addresses will need treatment  */
end_comment

begin_function
specifier|static
name|int
name|parse_addrs
parameter_list|(
name|struct
name|parse_state
modifier|*
name|ps
parameter_list|,
name|char
modifier|*
name|s
parameter_list|,
name|struct
name|queue
modifier|*
name|queue
parameter_list|)
block|{
name|char
modifier|*
name|addr
decl_stmt|;
name|again
label|:
switch|switch
condition|(
name|ps
operator|->
name|state
condition|)
block|{
case|case
name|NONE
case|:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
name|START
case|:
comment|/* init our data */
name|bzero
argument_list|(
name|ps
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ps
argument_list|)
argument_list|)
expr_stmt|;
comment|/* skip over header name */
while|while
condition|(
operator|*
name|s
operator|!=
literal|':'
condition|)
name|s
operator|++
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|ps
operator|->
name|state
operator|=
name|MAIN
expr_stmt|;
break|break;
case|case
name|MAIN
case|:
comment|/* all fine */
break|break;
case|case
name|EOL
case|:
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
name|s
operator|++
expr_stmt|;
comment|/* continue */
break|break;
default|default:
name|ps
operator|->
name|state
operator|=
name|QUIT
expr_stmt|;
if|if
condition|(
name|ps
operator|->
name|pos
operator|!=
literal|0
condition|)
goto|goto
name|newaddr
goto|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|QUIT
case|:
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
init|;
operator|*
name|s
operator|!=
literal|0
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|ps
operator|->
name|esc
condition|)
block|{
name|ps
operator|->
name|esc
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
goto|goto
name|err
goto|;
default|default:
goto|goto
name|copy
goto|;
block|}
block|}
if|if
condition|(
name|ps
operator|->
name|quote
condition|)
block|{
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'"'
case|:
name|ps
operator|->
name|quote
operator|=
literal|0
expr_stmt|;
goto|goto
name|copy
goto|;
case|case
literal|'\\'
case|:
name|ps
operator|->
name|esc
operator|=
literal|1
expr_stmt|;
goto|goto
name|copy
goto|;
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
goto|goto
name|eol
goto|;
default|default:
goto|goto
name|copy
goto|;
block|}
block|}
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'('
case|:
name|ps
operator|->
name|comment
operator|++
expr_stmt|;
break|break;
case|case
literal|')'
case|:
if|if
condition|(
name|ps
operator|->
name|comment
condition|)
name|ps
operator|->
name|comment
operator|--
expr_stmt|;
else|else
goto|goto
name|err
goto|;
goto|goto
name|skip
goto|;
case|case
literal|'"'
case|:
name|ps
operator|->
name|quote
operator|=
literal|1
expr_stmt|;
goto|goto
name|copy
goto|;
case|case
literal|'\\'
case|:
name|ps
operator|->
name|esc
operator|=
literal|1
expr_stmt|;
goto|goto
name|copy
goto|;
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
goto|goto
name|eol
goto|;
block|}
if|if
condition|(
name|ps
operator|->
name|comment
condition|)
goto|goto
name|skip
goto|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
comment|/* ignore whitespace */
goto|goto
name|skip
goto|;
case|case
literal|'<'
case|:
comment|/* this is the real address now */
name|ps
operator|->
name|brackets
operator|=
literal|1
expr_stmt|;
name|ps
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
goto|goto
name|skip
goto|;
case|case
literal|'>'
case|:
if|if
condition|(
operator|!
name|ps
operator|->
name|brackets
condition|)
goto|goto
name|err
goto|;
name|ps
operator|->
name|brackets
operator|=
literal|0
expr_stmt|;
name|s
operator|++
expr_stmt|;
goto|goto
name|newaddr
goto|;
case|case
literal|':'
case|:
comment|/* group - ignore */
name|ps
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
goto|goto
name|skip
goto|;
case|case
literal|','
case|:
case|case
literal|';'
case|:
comment|/* 			 * Next address, copy previous one. 			 * However, we might be directly after 			 * a<address>, or have two consecutive 			 * commas. 			 * Skip the comma unless there is 			 * really something to copy. 			 */
if|if
condition|(
name|ps
operator|->
name|pos
operator|==
literal|0
condition|)
goto|goto
name|skip
goto|;
name|s
operator|++
expr_stmt|;
goto|goto
name|newaddr
goto|;
default|default:
goto|goto
name|copy
goto|;
block|}
name|copy
label|:
if|if
condition|(
name|ps
operator|->
name|comment
condition|)
goto|goto
name|skip
goto|;
if|if
condition|(
name|ps
operator|->
name|pos
operator|+
literal|1
operator|==
sizeof|sizeof
argument_list|(
name|ps
operator|->
name|addr
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|ps
operator|->
name|addr
index|[
name|ps
operator|->
name|pos
operator|++
index|]
operator|=
operator|*
name|s
expr_stmt|;
name|skip
label|:
empty_stmt|;
block|}
name|eol
label|:
name|ps
operator|->
name|state
operator|=
name|EOL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err
label|:
name|ps
operator|->
name|state
operator|=
name|QUIT
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|newaddr
label|:
name|ps
operator|->
name|addr
index|[
name|ps
operator|->
name|pos
index|]
operator|=
literal|0
expr_stmt|;
name|ps
operator|->
name|pos
operator|=
literal|0
expr_stmt|;
name|addr
operator|=
name|strdup
argument_list|(
name|ps
operator|->
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
name|NULL
condition|)
name|errlog
argument_list|(
literal|1
argument_list|,
literal|"strdup failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_recp
argument_list|(
name|queue
argument_list|,
name|addr
argument_list|,
name|EXPAND_WILDCARD
argument_list|)
operator|!=
literal|0
condition|)
name|errlogx
argument_list|(
literal|1
argument_list|,
literal|"invalid recipient `%s'"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
end_function

begin_function
name|int
name|readmail
parameter_list|(
name|struct
name|queue
modifier|*
name|queue
parameter_list|,
name|int
name|nodot
parameter_list|,
name|int
name|recp_from_header
parameter_list|)
block|{
name|struct
name|parse_state
name|parse_state
decl_stmt|;
name|char
name|line
index|[
literal|1000
index|]
decl_stmt|;
comment|/* by RFC2822 */
name|size_t
name|linelen
decl_stmt|;
name|size_t
name|error
decl_stmt|;
name|int
name|had_headers
init|=
literal|0
decl_stmt|;
name|int
name|had_from
init|=
literal|0
decl_stmt|;
name|int
name|had_messagid
init|=
literal|0
decl_stmt|;
name|int
name|had_date
init|=
literal|0
decl_stmt|;
name|int
name|had_last_line
init|=
literal|0
decl_stmt|;
name|int
name|nocopy
init|=
literal|0
decl_stmt|;
name|parse_state
operator|.
name|state
operator|=
name|NONE
expr_stmt|;
name|error
operator|=
name|fprintf
argument_list|(
name|queue
operator|->
name|mailf
argument_list|,
literal|"Received: from %s (uid %d)\n"
literal|"\t(envelope-from %s)\n"
literal|"\tid %s\n"
literal|"\tby %s (%s);\n"
literal|"\t%s\n"
argument_list|,
name|username
argument_list|,
name|useruid
argument_list|,
name|queue
operator|->
name|sender
argument_list|,
name|queue
operator|->
name|id
argument_list|,
name|hostname
argument_list|()
argument_list|,
name|VERSION
argument_list|,
name|rfc822date
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ssize_t
operator|)
name|error
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|stdin
argument_list|)
condition|)
block|{
if|if
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
operator|-
literal|1
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|had_last_line
condition|)
name|errlogx
argument_list|(
literal|1
argument_list|,
literal|"bad mail input format"
argument_list|)
expr_stmt|;
name|linelen
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|linelen
operator|==
literal|0
operator|||
name|line
index|[
name|linelen
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
comment|/* 			 * This line did not end with a newline character. 			 * If we fix it, it better be the last line of 			 * the file. 			 */
name|line
index|[
name|linelen
index|]
operator|=
literal|'\n'
expr_stmt|;
name|line
index|[
name|linelen
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|had_last_line
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|had_headers
condition|)
block|{
comment|/* 			 * Unless this is a continuation, switch of 			 * the Bcc: nocopy flag. 			 */
if|if
condition|(
operator|!
operator|(
name|line
index|[
literal|0
index|]
operator|==
literal|' '
operator|||
name|line
index|[
literal|0
index|]
operator|==
literal|'\t'
operator|)
condition|)
name|nocopy
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strprefixcmp
argument_list|(
name|line
argument_list|,
literal|"Date:"
argument_list|)
operator|==
literal|0
condition|)
name|had_date
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strprefixcmp
argument_list|(
name|line
argument_list|,
literal|"Message-Id:"
argument_list|)
operator|==
literal|0
condition|)
name|had_messagid
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strprefixcmp
argument_list|(
name|line
argument_list|,
literal|"From:"
argument_list|)
operator|==
literal|0
condition|)
name|had_from
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strprefixcmp
argument_list|(
name|line
argument_list|,
literal|"Bcc:"
argument_list|)
operator|==
literal|0
condition|)
name|nocopy
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|parse_state
operator|.
name|state
operator|!=
name|NONE
condition|)
block|{
if|if
condition|(
name|parse_addrs
argument_list|(
operator|&
name|parse_state
argument_list|,
name|line
argument_list|,
name|queue
argument_list|)
operator|<
literal|0
condition|)
block|{
name|errlogx
argument_list|(
literal|1
argument_list|,
literal|"invalid address in header\n"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
if|if
condition|(
name|recp_from_header
operator|&&
operator|(
name|strprefixcmp
argument_list|(
name|line
argument_list|,
literal|"To:"
argument_list|)
operator|==
literal|0
operator|||
name|strprefixcmp
argument_list|(
name|line
argument_list|,
literal|"Cc:"
argument_list|)
operator|==
literal|0
operator|||
name|strprefixcmp
argument_list|(
name|line
argument_list|,
literal|"Bcc:"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|parse_state
operator|.
name|state
operator|=
name|START
expr_stmt|;
if|if
condition|(
name|parse_addrs
argument_list|(
operator|&
name|parse_state
argument_list|,
name|line
argument_list|,
name|queue
argument_list|)
operator|<
literal|0
condition|)
block|{
name|errlogx
argument_list|(
literal|1
argument_list|,
literal|"invalid address in header\n"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"\n"
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|had_headers
condition|)
block|{
name|had_headers
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|!
name|had_date
operator|||
operator|!
name|had_messagid
operator|||
operator|!
name|had_from
condition|)
block|{
if|if
condition|(
operator|!
name|had_date
condition|)
block|{
name|had_date
operator|=
literal|1
expr_stmt|;
name|snprintf
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
literal|"Date: %s\n"
argument_list|,
name|rfc822date
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|had_messagid
condition|)
block|{
comment|/* XXX msgid, assign earlier and log? */
name|had_messagid
operator|=
literal|1
expr_stmt|;
name|snprintf
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
literal|"Message-Id:<%"
name|PRIxMAX
literal|".%s.%"
name|PRIxMAX
literal|"@%s>\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|,
name|queue
operator|->
name|id
argument_list|,
operator|(
name|uintmax_t
operator|)
name|random
argument_list|()
argument_list|,
name|hostname
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|had_from
condition|)
block|{
name|had_from
operator|=
literal|1
expr_stmt|;
name|snprintf
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
literal|"From:<%s>\n"
argument_list|,
name|queue
operator|->
name|sender
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fwrite
argument_list|(
name|line
argument_list|,
name|strlen
argument_list|(
name|line
argument_list|)
argument_list|,
literal|1
argument_list|,
name|queue
operator|->
name|mailf
argument_list|)
operator|!=
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|line
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nodot
operator|&&
name|linelen
operator|==
literal|2
operator|&&
name|line
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
break|break;
if|if
condition|(
operator|!
name|nocopy
condition|)
block|{
if|if
condition|(
name|fwrite
argument_list|(
name|line
argument_list|,
name|strlen
argument_list|(
name|line
argument_list|)
argument_list|,
literal|1
argument_list|,
name|queue
operator|->
name|mailf
argument_list|)
operator|!=
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

