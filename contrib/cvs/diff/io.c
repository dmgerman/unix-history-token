begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* File I/O for GNU DIFF.    Copyright (C) 1988, 1989, 1992, 1993, 1994 Free Software Foundation, Inc.  This file is part of GNU DIFF.  GNU DIFF is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU DIFF is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  */
end_comment

begin_include
include|#
directive|include
file|"diff.h"
end_include

begin_comment
comment|/* Rotate a value n bits to the left. */
end_comment

begin_define
define|#
directive|define
name|UINT_BIT
value|(sizeof (unsigned) * CHAR_BIT)
end_define

begin_define
define|#
directive|define
name|ROL
parameter_list|(
name|v
parameter_list|,
name|n
parameter_list|)
value|((v)<< (n) | (v)>> (UINT_BIT - (n)))
end_define

begin_comment
comment|/* Given a hash value and a new character, return a new hash value. */
end_comment

begin_define
define|#
directive|define
name|HASH
parameter_list|(
name|h
parameter_list|,
name|c
parameter_list|)
value|((c) + ROL (h, 7))
end_define

begin_comment
comment|/* Guess remaining number of lines from number N of lines so far,    size S so far, and total size T.  */
end_comment

begin_define
define|#
directive|define
name|GUESS_LINES
parameter_list|(
name|n
parameter_list|,
name|s
parameter_list|,
name|t
parameter_list|)
value|(((t) - (s)) / ((n)< 10 ? 32 : (s) / ((n)-1)) + 5)
end_define

begin_comment
comment|/* Type used for fast prefix comparison in find_identical_ends.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|word
end_ifndef

begin_define
define|#
directive|define
name|word
value|int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Lines are put into equivalence classes (of lines that match in line_cmp).    Each equivalence class is represented by one of these structures,    but only while the classes are being computed.    Afterward, each class is represented by a number.  */
end_comment

begin_struct
struct|struct
name|equivclass
block|{
name|int
name|next
decl_stmt|;
comment|/* Next item in this bucket. */
name|unsigned
name|hash
decl_stmt|;
comment|/* Hash of lines in this class.  */
name|char
specifier|const
modifier|*
name|line
decl_stmt|;
comment|/* A line that fits this class. */
name|size_t
name|length
decl_stmt|;
comment|/* That line's length, not counting its newline.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Hash-table: array of buckets, each being a chain of equivalence classes.    buckets[-1] is reserved for incomplete lines.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|buckets
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of buckets in the hash table array, not counting buckets[-1]. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nbuckets
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array in which the equivalence classes are allocated.    The bucket-chains go through the elements in this array.    The number of an equivalence class is its index in this array.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|equivclass
modifier|*
name|equivs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index of first free element in the array `equivs'.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|equivs_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements allocated in the array `equivs'.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|equivs_alloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_and_hash_each_line
name|PARAMS
argument_list|(
operator|(
expr|struct
name|file_data
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_identical_ends
name|PARAMS
argument_list|(
operator|(
expr|struct
name|file_data
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|prepare_text_end
name|PARAMS
argument_list|(
operator|(
expr|struct
name|file_data
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Check for binary files and compare them for exact identity.  */
end_comment

begin_comment
comment|/* Return 1 if BUF contains a non text character.    SIZE is the number of characters in BUF.  */
end_comment

begin_define
define|#
directive|define
name|binary_file_p
parameter_list|(
name|buf
parameter_list|,
name|size
parameter_list|)
value|(memchr (buf, '\0', size) != 0)
end_define

begin_comment
comment|/* Get ready to read the current file.    Return nonzero if SKIP_TEST is zero,    and if it appears to be a binary file.  */
end_comment

begin_function
name|int
name|sip
parameter_list|(
name|current
parameter_list|,
name|skip_test
parameter_list|)
name|struct
name|file_data
modifier|*
name|current
decl_stmt|;
name|int
name|skip_test
decl_stmt|;
block|{
comment|/* If we have a nonexistent file at this stage, treat it as empty.  */
if|if
condition|(
name|current
operator|->
name|desc
operator|<
literal|0
condition|)
block|{
comment|/* Leave room for a sentinel.  */
name|current
operator|->
name|bufsize
operator|=
sizeof|sizeof
argument_list|(
name|word
argument_list|)
expr_stmt|;
name|current
operator|->
name|buffer
operator|=
name|xmalloc
argument_list|(
name|current
operator|->
name|bufsize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|current
operator|->
name|bufsize
operator|=
name|STAT_BLOCKSIZE
argument_list|(
name|current
operator|->
name|stat
argument_list|)
expr_stmt|;
name|current
operator|->
name|buffer
operator|=
name|xmalloc
argument_list|(
name|current
operator|->
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|skip_test
condition|)
block|{
comment|/* Check first part of file to see if it's a binary file.  */
if|#
directive|if
name|HAVE_SETMODE
name|int
name|oldmode
init|=
name|setmode
argument_list|(
name|current
operator|->
name|desc
argument_list|,
name|O_BINARY
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|size_t
name|n
init|=
name|read
argument_list|(
name|current
operator|->
name|desc
argument_list|,
name|current
operator|->
name|buffer
argument_list|,
name|current
operator|->
name|bufsize
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
name|pfatal_with_name
argument_list|(
name|current
operator|->
name|name
argument_list|)
expr_stmt|;
name|current
operator|->
name|buffered_chars
operator|=
name|n
expr_stmt|;
if|#
directive|if
name|HAVE_SETMODE
if|if
condition|(
name|oldmode
operator|!=
name|O_BINARY
condition|)
block|{
if|if
condition|(
name|lseek
argument_list|(
name|current
operator|->
name|desc
argument_list|,
operator|-
operator|(
name|off_t
operator|)
name|n
argument_list|,
name|SEEK_CUR
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|pfatal_with_name
argument_list|(
name|current
operator|->
name|name
argument_list|)
expr_stmt|;
name|setmode
argument_list|(
name|current
operator|->
name|desc
argument_list|,
name|oldmode
argument_list|)
expr_stmt|;
name|current
operator|->
name|buffered_chars
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|binary_file_p
argument_list|(
name|current
operator|->
name|buffer
argument_list|,
name|n
argument_list|)
return|;
block|}
block|}
name|current
operator|->
name|buffered_chars
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Slurp the rest of the current file completely into memory.  */
end_comment

begin_function
name|void
name|slurp
parameter_list|(
name|current
parameter_list|)
name|struct
name|file_data
modifier|*
name|current
decl_stmt|;
block|{
name|size_t
name|cc
decl_stmt|;
if|if
condition|(
name|current
operator|->
name|desc
operator|<
literal|0
condition|)
comment|/* The file is nonexistent.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|S_ISREG
argument_list|(
name|current
operator|->
name|stat
operator|.
name|st_mode
argument_list|)
condition|)
block|{
comment|/* It's a regular file; slurp in the rest all at once.  */
comment|/* Get the size out of the stat block. 	 Allocate enough room for appended newline and sentinel.  */
name|cc
operator|=
name|current
operator|->
name|stat
operator|.
name|st_size
operator|+
literal|1
operator|+
sizeof|sizeof
argument_list|(
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|->
name|bufsize
operator|<
name|cc
condition|)
block|{
name|current
operator|->
name|bufsize
operator|=
name|cc
expr_stmt|;
name|current
operator|->
name|buffer
operator|=
name|xrealloc
argument_list|(
name|current
operator|->
name|buffer
argument_list|,
name|cc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|current
operator|->
name|buffered_chars
operator|<
name|current
operator|->
name|stat
operator|.
name|st_size
condition|)
block|{
name|cc
operator|=
name|read
argument_list|(
name|current
operator|->
name|desc
argument_list|,
name|current
operator|->
name|buffer
operator|+
name|current
operator|->
name|buffered_chars
argument_list|,
name|current
operator|->
name|stat
operator|.
name|st_size
operator|-
name|current
operator|->
name|buffered_chars
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|==
operator|-
literal|1
condition|)
name|pfatal_with_name
argument_list|(
name|current
operator|->
name|name
argument_list|)
expr_stmt|;
name|current
operator|->
name|buffered_chars
operator|+=
name|cc
expr_stmt|;
block|}
block|}
comment|/* It's not a regular file; read it, growing the buffer as needed.  */
elseif|else
if|if
condition|(
name|always_text_flag
operator|||
name|current
operator|->
name|buffered_chars
operator|!=
literal|0
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|current
operator|->
name|buffered_chars
operator|==
name|current
operator|->
name|bufsize
condition|)
block|{
name|current
operator|->
name|bufsize
operator|=
name|current
operator|->
name|bufsize
operator|*
literal|2
expr_stmt|;
name|current
operator|->
name|buffer
operator|=
name|xrealloc
argument_list|(
name|current
operator|->
name|buffer
argument_list|,
name|current
operator|->
name|bufsize
argument_list|)
expr_stmt|;
block|}
name|cc
operator|=
name|read
argument_list|(
name|current
operator|->
name|desc
argument_list|,
name|current
operator|->
name|buffer
operator|+
name|current
operator|->
name|buffered_chars
argument_list|,
name|current
operator|->
name|bufsize
operator|-
name|current
operator|->
name|buffered_chars
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|cc
operator|==
operator|-
literal|1
condition|)
name|pfatal_with_name
argument_list|(
name|current
operator|->
name|name
argument_list|)
expr_stmt|;
name|current
operator|->
name|buffered_chars
operator|+=
name|cc
expr_stmt|;
block|}
comment|/* Allocate just enough room for appended newline and sentinel.  */
name|current
operator|->
name|bufsize
operator|=
name|current
operator|->
name|buffered_chars
operator|+
literal|1
operator|+
sizeof|sizeof
argument_list|(
name|word
argument_list|)
expr_stmt|;
name|current
operator|->
name|buffer
operator|=
name|xrealloc
argument_list|(
name|current
operator|->
name|buffer
argument_list|,
name|current
operator|->
name|bufsize
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Split the file into lines, simultaneously computing the equivalence class for    each line. */
end_comment

begin_function
specifier|static
name|void
name|find_and_hash_each_line
parameter_list|(
name|current
parameter_list|)
name|struct
name|file_data
modifier|*
name|current
decl_stmt|;
block|{
name|unsigned
name|h
decl_stmt|;
name|unsigned
name|char
specifier|const
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
specifier|const
operator|*
operator|)
name|current
operator|->
name|prefix_end
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
name|int
name|i
decl_stmt|,
modifier|*
name|bucket
decl_stmt|;
name|size_t
name|length
decl_stmt|;
comment|/* Cache often-used quantities in local variables to help the compiler.  */
name|char
specifier|const
modifier|*
modifier|*
name|linbuf
init|=
name|current
operator|->
name|linbuf
decl_stmt|;
name|int
name|alloc_lines
init|=
name|current
operator|->
name|alloc_lines
decl_stmt|;
name|int
name|line
init|=
literal|0
decl_stmt|;
name|int
name|linbuf_base
init|=
name|current
operator|->
name|linbuf_base
decl_stmt|;
name|int
modifier|*
name|cureqs
init|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|alloc_lines
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|equivclass
modifier|*
name|eqs
init|=
name|equivs
decl_stmt|;
name|int
name|eqs_index
init|=
name|equivs_index
decl_stmt|;
name|int
name|eqs_alloc
init|=
name|equivs_alloc
decl_stmt|;
name|char
specifier|const
modifier|*
name|suffix_begin
init|=
name|current
operator|->
name|suffix_begin
decl_stmt|;
name|char
specifier|const
modifier|*
name|bufend
init|=
name|current
operator|->
name|buffer
operator|+
name|current
operator|->
name|buffered_chars
decl_stmt|;
name|int
name|use_line_cmp
init|=
name|ignore_some_line_changes
decl_stmt|;
while|while
condition|(
operator|(
name|char
specifier|const
operator|*
operator|)
name|p
operator|<
name|suffix_begin
condition|)
block|{
name|char
specifier|const
modifier|*
name|ip
init|=
operator|(
name|char
specifier|const
operator|*
operator|)
name|p
decl_stmt|;
comment|/* Compute the equivalence class for this line.  */
name|h
operator|=
literal|0
expr_stmt|;
comment|/* Hash this line until we find a newline. */
if|if
condition|(
name|ignore_case_flag
condition|)
block|{
if|if
condition|(
name|ignore_all_space_flag
condition|)
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
operator|!
name|ISSPACE
argument_list|(
name|c
argument_list|)
condition|)
name|h
operator|=
name|HASH
argument_list|(
name|h
argument_list|,
name|ISUPPER
argument_list|(
name|c
argument_list|)
condition|?
name|tolower
argument_list|(
name|c
argument_list|)
else|:
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ignore_space_change_flag
condition|)
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|ISSPACE
argument_list|(
name|c
argument_list|)
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ISSPACE
argument_list|(
name|c
argument_list|)
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
goto|goto
name|hashing_done
goto|;
block|}
name|h
operator|=
name|HASH
argument_list|(
name|h
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
comment|/* C is now the first non-space.  */
name|h
operator|=
name|HASH
argument_list|(
name|h
argument_list|,
name|ISUPPER
argument_list|(
name|c
argument_list|)
condition|?
name|tolower
argument_list|(
name|c
argument_list|)
else|:
name|c
argument_list|)
expr_stmt|;
block|}
else|else
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\n'
condition|)
name|h
operator|=
name|HASH
argument_list|(
name|h
argument_list|,
name|ISUPPER
argument_list|(
name|c
argument_list|)
condition|?
name|tolower
argument_list|(
name|c
argument_list|)
else|:
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ignore_all_space_flag
condition|)
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
operator|!
name|ISSPACE
argument_list|(
name|c
argument_list|)
condition|)
name|h
operator|=
name|HASH
argument_list|(
name|h
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ignore_space_change_flag
condition|)
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|ISSPACE
argument_list|(
name|c
argument_list|)
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ISSPACE
argument_list|(
name|c
argument_list|)
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
goto|goto
name|hashing_done
goto|;
block|}
name|h
operator|=
name|HASH
argument_list|(
name|h
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
comment|/* C is now the first non-space.  */
name|h
operator|=
name|HASH
argument_list|(
name|h
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\n'
condition|)
name|h
operator|=
name|HASH
argument_list|(
name|h
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|hashing_done
label|:
empty_stmt|;
name|bucket
operator|=
operator|&
name|buckets
index|[
name|h
operator|%
name|nbuckets
index|]
expr_stmt|;
name|length
operator|=
operator|(
name|char
specifier|const
operator|*
operator|)
name|p
operator|-
name|ip
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|char
specifier|const
operator|*
operator|)
name|p
operator|==
name|bufend
operator|&&
name|current
operator|->
name|missing_newline
operator|&&
name|ROBUST_OUTPUT_STYLE
argument_list|(
name|output_style
argument_list|)
condition|)
block|{
comment|/* This line is incomplete.  If this is significant, 	     put the line into bucket[-1].  */
if|if
condition|(
operator|!
operator|(
name|ignore_space_change_flag
operator||
name|ignore_all_space_flag
operator|)
condition|)
name|bucket
operator|=
operator|&
name|buckets
index|[
operator|-
literal|1
index|]
expr_stmt|;
comment|/* Omit the inserted newline when computing linbuf later.  */
name|p
operator|--
expr_stmt|;
name|bufend
operator|=
name|suffix_begin
operator|=
operator|(
name|char
specifier|const
operator|*
operator|)
name|p
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
operator|*
name|bucket
init|;
condition|;
name|i
operator|=
name|eqs
index|[
name|i
index|]
operator|.
name|next
control|)
if|if
condition|(
operator|!
name|i
condition|)
block|{
comment|/* Create a new equivalence class in this bucket. */
name|i
operator|=
name|eqs_index
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|eqs_alloc
condition|)
name|eqs
operator|=
operator|(
expr|struct
name|equivclass
operator|*
operator|)
name|xrealloc
argument_list|(
name|eqs
argument_list|,
operator|(
name|eqs_alloc
operator|*=
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|eqs
argument_list|)
argument_list|)
expr_stmt|;
name|eqs
index|[
name|i
index|]
operator|.
name|next
operator|=
operator|*
name|bucket
expr_stmt|;
name|eqs
index|[
name|i
index|]
operator|.
name|hash
operator|=
name|h
expr_stmt|;
name|eqs
index|[
name|i
index|]
operator|.
name|line
operator|=
name|ip
expr_stmt|;
name|eqs
index|[
name|i
index|]
operator|.
name|length
operator|=
name|length
expr_stmt|;
operator|*
name|bucket
operator|=
name|i
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|eqs
index|[
name|i
index|]
operator|.
name|hash
operator|==
name|h
condition|)
block|{
name|char
specifier|const
modifier|*
name|eqline
init|=
name|eqs
index|[
name|i
index|]
operator|.
name|line
decl_stmt|;
comment|/* Reuse existing equivalence class if the lines are identical. 	       This detects the common case of exact identity 	       faster than complete comparison would.  */
if|if
condition|(
name|eqs
index|[
name|i
index|]
operator|.
name|length
operator|==
name|length
operator|&&
name|memcmp
argument_list|(
name|eqline
argument_list|,
name|ip
argument_list|,
name|length
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* Reuse existing class if line_cmp reports the lines equal.  */
if|if
condition|(
name|use_line_cmp
operator|&&
name|line_cmp
argument_list|(
name|eqline
argument_list|,
name|ip
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* Maybe increase the size of the line table. */
if|if
condition|(
name|line
operator|==
name|alloc_lines
condition|)
block|{
comment|/* Double (alloc_lines - linbuf_base) by adding to alloc_lines.  */
name|alloc_lines
operator|=
literal|2
operator|*
name|alloc_lines
operator|-
name|linbuf_base
expr_stmt|;
name|cureqs
operator|=
operator|(
name|int
operator|*
operator|)
name|xrealloc
argument_list|(
name|cureqs
argument_list|,
name|alloc_lines
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cureqs
argument_list|)
argument_list|)
expr_stmt|;
name|linbuf
operator|=
operator|(
name|char
specifier|const
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|linbuf
operator|+
name|linbuf_base
argument_list|,
operator|(
name|alloc_lines
operator|-
name|linbuf_base
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|linbuf
argument_list|)
argument_list|)
operator|-
name|linbuf_base
expr_stmt|;
block|}
name|linbuf
index|[
name|line
index|]
operator|=
name|ip
expr_stmt|;
name|cureqs
index|[
name|line
index|]
operator|=
name|i
expr_stmt|;
operator|++
name|line
expr_stmt|;
block|}
name|current
operator|->
name|buffered_lines
operator|=
name|line
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
comment|/* Record the line start for lines in the suffix that we care about. 	 Record one more line start than lines, 	 so that we can compute the length of any buffered line.  */
if|if
condition|(
name|line
operator|==
name|alloc_lines
condition|)
block|{
comment|/* Double (alloc_lines - linbuf_base) by adding to alloc_lines.  */
name|alloc_lines
operator|=
literal|2
operator|*
name|alloc_lines
operator|-
name|linbuf_base
expr_stmt|;
name|linbuf
operator|=
operator|(
name|char
specifier|const
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|linbuf
operator|+
name|linbuf_base
argument_list|,
operator|(
name|alloc_lines
operator|-
name|linbuf_base
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|linbuf
argument_list|)
argument_list|)
operator|-
name|linbuf_base
expr_stmt|;
block|}
name|linbuf
index|[
name|line
index|]
operator|=
operator|(
name|char
specifier|const
operator|*
operator|)
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|char
specifier|const
operator|*
operator|)
name|p
operator|==
name|bufend
condition|)
break|break;
if|if
condition|(
name|context
operator|<=
name|i
operator|&&
name|no_diff_means_no_output
condition|)
break|break;
name|line
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'\n'
condition|)
empty_stmt|;
block|}
comment|/* Done with cache in local variables.  */
name|current
operator|->
name|linbuf
operator|=
name|linbuf
expr_stmt|;
name|current
operator|->
name|valid_lines
operator|=
name|line
expr_stmt|;
name|current
operator|->
name|alloc_lines
operator|=
name|alloc_lines
expr_stmt|;
name|current
operator|->
name|equivs
operator|=
name|cureqs
expr_stmt|;
name|equivs
operator|=
name|eqs
expr_stmt|;
name|equivs_alloc
operator|=
name|eqs_alloc
expr_stmt|;
name|equivs_index
operator|=
name|eqs_index
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Prepare the end of the text.  Make sure it's initialized.    Make sure text ends in a newline,    but remember that we had to add one.  */
end_comment

begin_function
specifier|static
name|void
name|prepare_text_end
parameter_list|(
name|current
parameter_list|)
name|struct
name|file_data
modifier|*
name|current
decl_stmt|;
block|{
name|size_t
name|buffered_chars
init|=
name|current
operator|->
name|buffered_chars
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|current
operator|->
name|buffer
decl_stmt|;
if|if
condition|(
name|buffered_chars
operator|==
literal|0
operator|||
name|p
index|[
name|buffered_chars
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|current
operator|->
name|missing_newline
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|p
index|[
name|buffered_chars
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|current
operator|->
name|buffered_chars
operator|=
name|buffered_chars
expr_stmt|;
name|current
operator|->
name|missing_newline
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Don't use uninitialized storage when planting or using sentinels.  */
if|if
condition|(
name|p
condition|)
name|bzero
argument_list|(
name|p
operator|+
name|buffered_chars
argument_list|,
sizeof|sizeof
argument_list|(
name|word
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a vector of two file_data objects, find the identical    prefixes and suffixes of each object. */
end_comment

begin_function
specifier|static
name|void
name|find_identical_ends
parameter_list|(
name|filevec
parameter_list|)
name|struct
name|file_data
name|filevec
index|[]
decl_stmt|;
block|{
name|word
modifier|*
name|w0
decl_stmt|,
modifier|*
name|w1
decl_stmt|;
name|char
modifier|*
name|p0
decl_stmt|,
modifier|*
name|p1
decl_stmt|,
modifier|*
name|buffer0
decl_stmt|,
modifier|*
name|buffer1
decl_stmt|;
name|char
specifier|const
modifier|*
name|end0
decl_stmt|,
modifier|*
name|beg0
decl_stmt|;
name|char
specifier|const
modifier|*
modifier|*
name|linbuf0
decl_stmt|,
modifier|*
modifier|*
name|linbuf1
decl_stmt|;
name|int
name|i
decl_stmt|,
name|lines
decl_stmt|;
name|size_t
name|n0
decl_stmt|,
name|n1
decl_stmt|,
name|tem
decl_stmt|;
name|int
name|alloc_lines0
decl_stmt|,
name|alloc_lines1
decl_stmt|;
name|int
name|buffered_prefix
decl_stmt|,
name|prefix_count
decl_stmt|,
name|prefix_mask
decl_stmt|;
name|slurp
argument_list|(
operator|&
name|filevec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|filevec
index|[
literal|0
index|]
operator|.
name|desc
operator|!=
name|filevec
index|[
literal|1
index|]
operator|.
name|desc
condition|)
name|slurp
argument_list|(
operator|&
name|filevec
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|filevec
index|[
literal|1
index|]
operator|.
name|buffer
operator|=
name|filevec
index|[
literal|0
index|]
operator|.
name|buffer
expr_stmt|;
name|filevec
index|[
literal|1
index|]
operator|.
name|bufsize
operator|=
name|filevec
index|[
literal|0
index|]
operator|.
name|bufsize
expr_stmt|;
name|filevec
index|[
literal|1
index|]
operator|.
name|buffered_chars
operator|=
name|filevec
index|[
literal|0
index|]
operator|.
name|buffered_chars
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
name|prepare_text_end
argument_list|(
operator|&
name|filevec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Find identical prefix.  */
name|p0
operator|=
name|buffer0
operator|=
name|filevec
index|[
literal|0
index|]
operator|.
name|buffer
expr_stmt|;
name|p1
operator|=
name|buffer1
operator|=
name|filevec
index|[
literal|1
index|]
operator|.
name|buffer
expr_stmt|;
name|n0
operator|=
name|filevec
index|[
literal|0
index|]
operator|.
name|buffered_chars
expr_stmt|;
name|n1
operator|=
name|filevec
index|[
literal|1
index|]
operator|.
name|buffered_chars
expr_stmt|;
if|if
condition|(
name|p0
operator|==
name|p1
condition|)
comment|/* The buffers are the same; sentinels won't work.  */
name|p0
operator|=
name|p1
operator|+=
name|n1
expr_stmt|;
else|else
block|{
comment|/* Insert end sentinels, in this case characters that are guaranteed 	 to make the equality test false, and thus terminate the loop.  */
if|if
condition|(
name|n0
operator|<
name|n1
condition|)
name|p0
index|[
name|n0
index|]
operator|=
operator|~
name|p1
index|[
name|n0
index|]
expr_stmt|;
else|else
name|p1
index|[
name|n1
index|]
operator|=
operator|~
name|p0
index|[
name|n1
index|]
expr_stmt|;
comment|/* Loop until first mismatch, or to the sentinel characters.  */
comment|/* Compare a word at a time for speed.  */
name|w0
operator|=
operator|(
name|word
operator|*
operator|)
name|p0
expr_stmt|;
name|w1
operator|=
operator|(
name|word
operator|*
operator|)
name|p1
expr_stmt|;
while|while
condition|(
operator|*
name|w0
operator|++
operator|==
operator|*
name|w1
operator|++
condition|)
empty_stmt|;
operator|--
name|w0
operator|,
operator|--
name|w1
expr_stmt|;
comment|/* Do the last few bytes of comparison a byte at a time.  */
name|p0
operator|=
operator|(
name|char
operator|*
operator|)
name|w0
expr_stmt|;
name|p1
operator|=
operator|(
name|char
operator|*
operator|)
name|w1
expr_stmt|;
while|while
condition|(
operator|*
name|p0
operator|++
operator|==
operator|*
name|p1
operator|++
condition|)
empty_stmt|;
operator|--
name|p0
operator|,
operator|--
name|p1
expr_stmt|;
comment|/* Don't mistakenly count missing newline as part of prefix. */
if|if
condition|(
name|ROBUST_OUTPUT_STYLE
argument_list|(
name|output_style
argument_list|)
operator|&&
operator|(
name|buffer0
operator|+
name|n0
operator|-
name|filevec
index|[
literal|0
index|]
operator|.
name|missing_newline
operator|<
name|p0
operator|)
operator|!=
operator|(
name|buffer1
operator|+
name|n1
operator|-
name|filevec
index|[
literal|1
index|]
operator|.
name|missing_newline
operator|<
name|p1
operator|)
condition|)
operator|--
name|p0
operator|,
operator|--
name|p1
expr_stmt|;
block|}
comment|/* Now P0 and P1 point at the first nonmatching characters.  */
comment|/* Skip back to last line-beginning in the prefix,      and then discard up to HORIZON_LINES lines from the prefix.  */
name|i
operator|=
name|horizon_lines
expr_stmt|;
while|while
condition|(
name|p0
operator|!=
name|buffer0
operator|&&
operator|(
name|p0
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
operator|||
name|i
operator|--
operator|)
condition|)
operator|--
name|p0
operator|,
operator|--
name|p1
expr_stmt|;
comment|/* Record the prefix.  */
name|filevec
index|[
literal|0
index|]
operator|.
name|prefix_end
operator|=
name|p0
expr_stmt|;
name|filevec
index|[
literal|1
index|]
operator|.
name|prefix_end
operator|=
name|p1
expr_stmt|;
comment|/* Find identical suffix.  */
comment|/* P0 and P1 point beyond the last chars not yet compared.  */
name|p0
operator|=
name|buffer0
operator|+
name|n0
expr_stmt|;
name|p1
operator|=
name|buffer1
operator|+
name|n1
expr_stmt|;
if|if
condition|(
operator|!
name|ROBUST_OUTPUT_STYLE
argument_list|(
name|output_style
argument_list|)
operator|||
name|filevec
index|[
literal|0
index|]
operator|.
name|missing_newline
operator|==
name|filevec
index|[
literal|1
index|]
operator|.
name|missing_newline
condition|)
block|{
name|end0
operator|=
name|p0
expr_stmt|;
comment|/* Addr of last char in file 0.  */
comment|/* Get value of P0 at which we should stop scanning backward: 	 this is when either P0 or P1 points just past the last char 	 of the identical prefix.  */
name|beg0
operator|=
name|filevec
index|[
literal|0
index|]
operator|.
name|prefix_end
operator|+
operator|(
name|n0
operator|<
name|n1
condition|?
literal|0
else|:
name|n0
operator|-
name|n1
operator|)
expr_stmt|;
comment|/* Scan back until chars don't match or we reach that point.  */
while|while
condition|(
name|p0
operator|!=
name|beg0
condition|)
if|if
condition|(
operator|*
operator|--
name|p0
operator|!=
operator|*
operator|--
name|p1
condition|)
block|{
comment|/* Point at the first char of the matching suffix.  */
operator|++
name|p0
operator|,
operator|++
name|p1
expr_stmt|;
name|beg0
operator|=
name|p0
expr_stmt|;
break|break;
block|}
comment|/* Are we at a line-beginning in both files?  If not, add the rest of 	 this line to the main body.  Discard up to HORIZON_LINES lines from 	 the identical suffix.  Also, discard one extra line, 	 because shift_boundaries may need it.  */
name|i
operator|=
name|horizon_lines
operator|+
operator|!
operator|(
operator|(
name|buffer0
operator|==
name|p0
operator|||
name|p0
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
operator|&&
operator|(
name|buffer1
operator|==
name|p1
operator|||
name|p1
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
operator|)
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|&&
name|p0
operator|!=
name|end0
condition|)
while|while
condition|(
operator|*
name|p0
operator|++
operator|!=
literal|'\n'
condition|)
empty_stmt|;
name|p1
operator|+=
name|p0
operator|-
name|beg0
expr_stmt|;
block|}
comment|/* Record the suffix.  */
name|filevec
index|[
literal|0
index|]
operator|.
name|suffix_begin
operator|=
name|p0
expr_stmt|;
name|filevec
index|[
literal|1
index|]
operator|.
name|suffix_begin
operator|=
name|p1
expr_stmt|;
comment|/* Calculate number of lines of prefix to save.       prefix_count == 0 means save the whole prefix;      we need this with for options like -D that output the whole file.      We also need it for options like -F that output some preceding line;      at least we will need to find the last few lines,      but since we don't know how many, it's easiest to find them all.       Otherwise, prefix_count != 0.  Save just prefix_count lines at start      of the line buffer; they'll be moved to the proper location later.      Handle 1 more line than the context says (because we count 1 too many),      rounded up to the next power of 2 to speed index computation.  */
if|if
condition|(
name|no_diff_means_no_output
operator|&&
operator|!
name|function_regexp_list
condition|)
block|{
for|for
control|(
name|prefix_count
operator|=
literal|1
init|;
name|prefix_count
operator|<
name|context
operator|+
literal|1
condition|;
name|prefix_count
operator|*=
literal|2
control|)
empty_stmt|;
name|prefix_mask
operator|=
name|prefix_count
operator|-
literal|1
expr_stmt|;
name|alloc_lines0
operator|=
name|prefix_count
operator|+
name|GUESS_LINES
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|p0
operator|-
name|filevec
index|[
literal|0
index|]
operator|.
name|prefix_end
argument_list|)
operator|+
name|context
expr_stmt|;
block|}
else|else
block|{
name|prefix_count
operator|=
literal|0
expr_stmt|;
name|prefix_mask
operator|=
operator|~
literal|0
expr_stmt|;
name|alloc_lines0
operator|=
name|GUESS_LINES
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|n0
argument_list|)
expr_stmt|;
block|}
name|lines
operator|=
literal|0
expr_stmt|;
name|linbuf0
operator|=
operator|(
name|char
specifier|const
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|alloc_lines0
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|linbuf0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the prefix is needed, find the prefix lines.  */
if|if
condition|(
operator|!
operator|(
name|no_diff_means_no_output
operator|&&
name|filevec
index|[
literal|0
index|]
operator|.
name|prefix_end
operator|==
name|p0
operator|&&
name|filevec
index|[
literal|1
index|]
operator|.
name|prefix_end
operator|==
name|p1
operator|)
condition|)
block|{
name|p0
operator|=
name|buffer0
expr_stmt|;
name|end0
operator|=
name|filevec
index|[
literal|0
index|]
operator|.
name|prefix_end
expr_stmt|;
while|while
condition|(
name|p0
operator|!=
name|end0
condition|)
block|{
name|int
name|l
init|=
name|lines
operator|++
operator|&
name|prefix_mask
decl_stmt|;
if|if
condition|(
name|l
operator|==
name|alloc_lines0
condition|)
name|linbuf0
operator|=
operator|(
name|char
specifier|const
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|linbuf0
argument_list|,
operator|(
name|alloc_lines0
operator|*=
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|linbuf0
argument_list|)
argument_list|)
expr_stmt|;
name|linbuf0
index|[
name|l
index|]
operator|=
name|p0
expr_stmt|;
while|while
condition|(
operator|*
name|p0
operator|++
operator|!=
literal|'\n'
condition|)
empty_stmt|;
block|}
block|}
name|buffered_prefix
operator|=
name|prefix_count
operator|&&
name|context
operator|<
name|lines
condition|?
name|context
else|:
name|lines
expr_stmt|;
comment|/* Allocate line buffer 1.  */
name|tem
operator|=
name|prefix_count
condition|?
name|filevec
index|[
literal|1
index|]
operator|.
name|suffix_begin
operator|-
name|buffer1
else|:
name|n1
expr_stmt|;
name|alloc_lines1
operator|=
operator|(
name|buffered_prefix
operator|+
name|GUESS_LINES
argument_list|(
name|lines
argument_list|,
name|filevec
index|[
literal|1
index|]
operator|.
name|prefix_end
operator|-
name|buffer1
argument_list|,
name|tem
argument_list|)
operator|+
name|context
operator|)
expr_stmt|;
name|linbuf1
operator|=
operator|(
name|char
specifier|const
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|alloc_lines1
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|linbuf1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffered_prefix
operator|!=
name|lines
condition|)
block|{
comment|/* Rotate prefix lines to proper location.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|buffered_prefix
condition|;
name|i
operator|++
control|)
name|linbuf1
index|[
name|i
index|]
operator|=
name|linbuf0
index|[
operator|(
name|lines
operator|-
name|context
operator|+
name|i
operator|)
operator|&
name|prefix_mask
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|buffered_prefix
condition|;
name|i
operator|++
control|)
name|linbuf0
index|[
name|i
index|]
operator|=
name|linbuf1
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* Initialize line buffer 1 from line buffer 0.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|buffered_prefix
condition|;
name|i
operator|++
control|)
name|linbuf1
index|[
name|i
index|]
operator|=
name|linbuf0
index|[
name|i
index|]
operator|-
name|buffer0
operator|+
name|buffer1
expr_stmt|;
comment|/* Record the line buffer, adjusted so that      linbuf*[0] points at the first differing line.  */
name|filevec
index|[
literal|0
index|]
operator|.
name|linbuf
operator|=
name|linbuf0
operator|+
name|buffered_prefix
expr_stmt|;
name|filevec
index|[
literal|1
index|]
operator|.
name|linbuf
operator|=
name|linbuf1
operator|+
name|buffered_prefix
expr_stmt|;
name|filevec
index|[
literal|0
index|]
operator|.
name|linbuf_base
operator|=
name|filevec
index|[
literal|1
index|]
operator|.
name|linbuf_base
operator|=
operator|-
name|buffered_prefix
expr_stmt|;
name|filevec
index|[
literal|0
index|]
operator|.
name|alloc_lines
operator|=
name|alloc_lines0
operator|-
name|buffered_prefix
expr_stmt|;
name|filevec
index|[
literal|1
index|]
operator|.
name|alloc_lines
operator|=
name|alloc_lines1
operator|-
name|buffered_prefix
expr_stmt|;
name|filevec
index|[
literal|0
index|]
operator|.
name|prefix_lines
operator|=
name|filevec
index|[
literal|1
index|]
operator|.
name|prefix_lines
operator|=
name|lines
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Largest primes less than some power of two, for nbuckets.  Values range    from useful to preposterous.  If one of these numbers isn't prime    after all, don't blame it on me, blame it on primes (6) . . . */
end_comment

begin_decl_stmt
specifier|static
name|int
specifier|const
name|primes
index|[]
init|=
block|{
literal|509
block|,
literal|1021
block|,
literal|2039
block|,
literal|4093
block|,
literal|8191
block|,
literal|16381
block|,
literal|32749
block|,
if|#
directive|if
literal|32767
operator|<
name|INT_MAX
literal|65521
block|,
literal|131071
block|,
literal|262139
block|,
literal|524287
block|,
literal|1048573
block|,
literal|2097143
block|,
literal|4194301
block|,
literal|8388593
block|,
literal|16777213
block|,
literal|33554393
block|,
literal|67108859
block|,
comment|/* Preposterously large . . . */
literal|134217689
block|,
literal|268435399
block|,
literal|536870909
block|,
literal|1073741789
block|,
literal|2147483647
block|,
endif|#
directive|endif
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given a vector of two file_data objects, read the file associated    with each one, and build the table of equivalence classes.    Return 1 if either file appears to be a binary file.    If PRETEND_BINARY is nonzero, pretend they are binary regardless.  */
end_comment

begin_function
name|int
name|read_files
parameter_list|(
name|filevec
parameter_list|,
name|pretend_binary
parameter_list|)
name|struct
name|file_data
name|filevec
index|[]
decl_stmt|;
name|int
name|pretend_binary
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|skip_test
init|=
name|always_text_flag
operator||
name|pretend_binary
decl_stmt|;
name|int
name|appears_binary
init|=
name|pretend_binary
operator||
name|sip
argument_list|(
operator|&
name|filevec
index|[
literal|0
index|]
argument_list|,
name|skip_test
argument_list|)
decl_stmt|;
if|if
condition|(
name|filevec
index|[
literal|0
index|]
operator|.
name|desc
operator|!=
name|filevec
index|[
literal|1
index|]
operator|.
name|desc
condition|)
name|appears_binary
operator||=
name|sip
argument_list|(
operator|&
name|filevec
index|[
literal|1
index|]
argument_list|,
name|skip_test
operator||
name|appears_binary
argument_list|)
expr_stmt|;
else|else
block|{
name|filevec
index|[
literal|1
index|]
operator|.
name|buffer
operator|=
name|filevec
index|[
literal|0
index|]
operator|.
name|buffer
expr_stmt|;
name|filevec
index|[
literal|1
index|]
operator|.
name|bufsize
operator|=
name|filevec
index|[
literal|0
index|]
operator|.
name|bufsize
expr_stmt|;
name|filevec
index|[
literal|1
index|]
operator|.
name|buffered_chars
operator|=
name|filevec
index|[
literal|0
index|]
operator|.
name|buffered_chars
expr_stmt|;
block|}
if|if
condition|(
name|appears_binary
condition|)
block|{
if|#
directive|if
name|HAVE_SETMODE
name|setmode
argument_list|(
name|filevec
index|[
literal|0
index|]
operator|.
name|desc
argument_list|,
name|O_BINARY
argument_list|)
expr_stmt|;
name|setmode
argument_list|(
name|filevec
index|[
literal|1
index|]
operator|.
name|desc
argument_list|,
name|O_BINARY
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
name|find_identical_ends
argument_list|(
name|filevec
argument_list|)
expr_stmt|;
name|equivs_alloc
operator|=
name|filevec
index|[
literal|0
index|]
operator|.
name|alloc_lines
operator|+
name|filevec
index|[
literal|1
index|]
operator|.
name|alloc_lines
operator|+
literal|1
expr_stmt|;
name|equivs
operator|=
operator|(
expr|struct
name|equivclass
operator|*
operator|)
name|xmalloc
argument_list|(
name|equivs_alloc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|equivclass
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Equivalence class 0 is permanently safe for lines that were not      hashed.  Real equivalence classes start at 1. */
name|equivs_index
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|primes
index|[
name|i
index|]
operator|<
name|equivs_alloc
operator|/
literal|3
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|primes
index|[
name|i
index|]
condition|)
name|abort
argument_list|()
expr_stmt|;
name|nbuckets
operator|=
name|primes
index|[
name|i
index|]
expr_stmt|;
name|buckets
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|nbuckets
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|buckets
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|buckets
operator|++
argument_list|,
operator|(
name|nbuckets
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|buckets
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
name|find_and_hash_each_line
argument_list|(
operator|&
name|filevec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|filevec
index|[
literal|0
index|]
operator|.
name|equiv_max
operator|=
name|filevec
index|[
literal|1
index|]
operator|.
name|equiv_max
operator|=
name|equivs_index
expr_stmt|;
name|free
argument_list|(
name|equivs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buckets
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

