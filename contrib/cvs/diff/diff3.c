begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Three way file comparison program (diff3) for Project GNU.    Copyright (C) 1988, 1989, 1992, 1993, 1994, 1997, 1998 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Written by Randy Smith */
end_comment

begin_comment
comment|/* Librarification by Tim Pierce */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|"diffrun.h"
end_include

begin_comment
comment|/* diff3.c has a real initialize_main function. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|initialize_main
end_ifdef

begin_undef
undef|#
directive|undef
name|initialize_main
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|char
specifier|const
name|diff_version_string
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|outfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|diff_callbacks
modifier|*
name|callbacks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|write_output
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|printf_output
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
operator|...
operator|)
argument_list|)
if|#
directive|if
name|__GNUC__
operator|>
literal|2
operator|||
operator|(
name|__GNUC__
operator|==
literal|2
operator|&&
name|__GNUC_MINOR__
operator|>
literal|6
operator|)
name|__attribute__
argument_list|(
operator|(
name|__format__
argument_list|(
name|__printf__
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
operator|)
argument_list|)
endif|#
directive|endif
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|flush_output
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|cvs_temp_name
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Internal data structures and macros for the diff3 program; includes  * data structures for both diff3 diffs and normal diffs.  */
end_comment

begin_comment
comment|/* Different files within a three way diff.  */
end_comment

begin_define
define|#
directive|define
name|FILE0
value|0
end_define

begin_define
define|#
directive|define
name|FILE1
value|1
end_define

begin_define
define|#
directive|define
name|FILE2
value|2
end_define

begin_comment
comment|/*  * A three way diff is built from two two-way diffs; the file which  * the two two-way diffs share is:  */
end_comment

begin_define
define|#
directive|define
name|FILEC
value|FILE2
end_define

begin_comment
comment|/*  * Different files within a two way diff.  * FC is the common file, FO the other file.  */
end_comment

begin_define
define|#
directive|define
name|FO
value|0
end_define

begin_define
define|#
directive|define
name|FC
value|1
end_define

begin_comment
comment|/* The ranges are indexed by */
end_comment

begin_define
define|#
directive|define
name|START
value|0
end_define

begin_define
define|#
directive|define
name|END
value|1
end_define

begin_enum
enum|enum
name|diff_type
block|{
name|ERROR
block|,
comment|/* Should not be used */
name|ADD
block|,
comment|/* Two way diff add */
name|CHANGE
block|,
comment|/* Two way diff change */
name|DELETE
block|,
comment|/* Two way diff delete */
name|DIFF_ALL
block|,
comment|/* All three are different */
name|DIFF_1ST
block|,
comment|/* Only the first is different */
name|DIFF_2ND
block|,
comment|/* Only the second */
name|DIFF_3RD
comment|/* Only the third */
block|}
enum|;
end_enum

begin_comment
comment|/* Two way diff */
end_comment

begin_struct
struct|struct
name|diff_block
block|{
name|int
name|ranges
index|[
literal|2
index|]
index|[
literal|2
index|]
decl_stmt|;
comment|/* Ranges are inclusive */
name|char
modifier|*
modifier|*
name|lines
index|[
literal|2
index|]
decl_stmt|;
comment|/* The actual lines (may contain nulls) */
name|size_t
modifier|*
name|lengths
index|[
literal|2
index|]
decl_stmt|;
comment|/* Line lengths (including newlines, if any) */
name|struct
name|diff_block
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Three way diff */
end_comment

begin_struct
struct|struct
name|diff3_block
block|{
name|enum
name|diff_type
name|correspond
decl_stmt|;
comment|/* Type of diff */
name|int
name|ranges
index|[
literal|3
index|]
index|[
literal|2
index|]
decl_stmt|;
comment|/* Ranges are inclusive */
name|char
modifier|*
modifier|*
name|lines
index|[
literal|3
index|]
decl_stmt|;
comment|/* The actual lines (may contain nulls) */
name|size_t
modifier|*
name|lengths
index|[
literal|3
index|]
decl_stmt|;
comment|/* Line lengths (including newlines, if any) */
name|struct
name|diff3_block
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Access the ranges on a diff block.  */
end_comment

begin_define
define|#
directive|define
name|D_LOWLINE
parameter_list|(
name|diff
parameter_list|,
name|filenum
parameter_list|)
define|\
value|((diff)->ranges[filenum][START])
end_define

begin_define
define|#
directive|define
name|D_HIGHLINE
parameter_list|(
name|diff
parameter_list|,
name|filenum
parameter_list|)
define|\
value|((diff)->ranges[filenum][END])
end_define

begin_define
define|#
directive|define
name|D_NUMLINES
parameter_list|(
name|diff
parameter_list|,
name|filenum
parameter_list|)
define|\
value|(D_HIGHLINE (diff, filenum) - D_LOWLINE (diff, filenum) + 1)
end_define

begin_comment
comment|/*  * Access the line numbers in a file in a diff by relative line  * numbers (i.e. line number within the diff itself).  Note that these  * are lvalues and can be used for assignment.  */
end_comment

begin_define
define|#
directive|define
name|D_RELNUM
parameter_list|(
name|diff
parameter_list|,
name|filenum
parameter_list|,
name|linenum
parameter_list|)
define|\
value|((diff)->lines[filenum][linenum])
end_define

begin_define
define|#
directive|define
name|D_RELLEN
parameter_list|(
name|diff
parameter_list|,
name|filenum
parameter_list|,
name|linenum
parameter_list|)
define|\
value|((diff)->lengths[filenum][linenum])
end_define

begin_comment
comment|/*  * And get at them directly, when that should be necessary.  */
end_comment

begin_define
define|#
directive|define
name|D_LINEARRAY
parameter_list|(
name|diff
parameter_list|,
name|filenum
parameter_list|)
define|\
value|((diff)->lines[filenum])
end_define

begin_define
define|#
directive|define
name|D_LENARRAY
parameter_list|(
name|diff
parameter_list|,
name|filenum
parameter_list|)
define|\
value|((diff)->lengths[filenum])
end_define

begin_comment
comment|/*  * Next block.  */
end_comment

begin_define
define|#
directive|define
name|D_NEXT
parameter_list|(
name|diff
parameter_list|)
value|((diff)->next)
end_define

begin_comment
comment|/*  * Access the type of a diff3 block.  */
end_comment

begin_define
define|#
directive|define
name|D3_TYPE
parameter_list|(
name|diff
parameter_list|)
value|((diff)->correspond)
end_define

begin_comment
comment|/*  * Line mappings based on diffs.  The first maps off the top of the  * diff, the second off of the bottom.  */
end_comment

begin_define
define|#
directive|define
name|D_HIGH_MAPLINE
parameter_list|(
name|diff
parameter_list|,
name|fromfile
parameter_list|,
name|tofile
parameter_list|,
name|lineno
parameter_list|)
define|\
value|((lineno)						\    - D_HIGHLINE ((diff), (fromfile))			\    + D_HIGHLINE ((diff), (tofile)))
end_define

begin_define
define|#
directive|define
name|D_LOW_MAPLINE
parameter_list|(
name|diff
parameter_list|,
name|fromfile
parameter_list|,
name|tofile
parameter_list|,
name|lineno
parameter_list|)
define|\
value|((lineno)						\    - D_LOWLINE ((diff), (fromfile))			\    + D_LOWLINE ((diff), (tofile)))
end_define

begin_comment
comment|/*  * General memory allocation function.  */
end_comment

begin_define
define|#
directive|define
name|ALLOCATE
parameter_list|(
name|number
parameter_list|,
name|type
parameter_list|)
define|\
value|(type *) xmalloc ((number) * sizeof (type))
end_define

begin_escape
end_escape

begin_comment
comment|/* Options variables for flags set on command line.  */
end_comment

begin_comment
comment|/* If nonzero, treat all files as text files, never as binary.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|always_text
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, write out an ed script instead of the standard diff3 format.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|edscript
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, in the case of overlapping diffs (type DIFF_ALL),    preserve the lines which would normally be deleted from    file 1 with a special flagging mechanism.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|flagging
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of lines to keep in identical prefix and suffix.  */
end_comment

begin_decl_stmt
specifier|static
name|int
specifier|const
name|horizon_lines
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Use a tab to align output lines (-T).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tab_align_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, do not output information for overlapping diffs.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|simple_only
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, do not output information for non-overlapping diffs.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|overlap_only
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, show information for DIFF_2ND diffs.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|show_2nd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, include `:wq' at the end of the script    to write out the file being edited.   */
end_comment

begin_decl_stmt
specifier|static
name|int
name|finalwrite
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, output a merged file.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|merge
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|diff_program_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|read_diff
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|char
specifier|const
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|scan_diff_line
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|size_t
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|diff_type
name|process_diff_control
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
expr|struct
name|diff_block
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compare_line_list
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
specifier|const
index|[]
operator|,
name|size_t
specifier|const
index|[]
operator|,
name|char
operator|*
specifier|const
index|[]
operator|,
name|size_t
specifier|const
index|[]
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|copy_stringlist
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
specifier|const
index|[]
operator|,
name|size_t
specifier|const
index|[]
operator|,
name|char
operator|*
index|[]
operator|,
name|size_t
index|[]
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dotlines
name|PARAMS
argument_list|(
operator|(
expr|struct
name|diff3_block
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|output_diff3_edscript
name|PARAMS
argument_list|(
operator|(
expr|struct
name|diff3_block
operator|*
operator|,
name|int
specifier|const
index|[
literal|3
index|]
operator|,
name|int
specifier|const
index|[
literal|3
index|]
operator|,
name|char
specifier|const
operator|*
operator|,
name|char
specifier|const
operator|*
operator|,
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|output_diff3_merge
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
expr|struct
name|diff3_block
operator|*
operator|,
name|int
specifier|const
index|[
literal|3
index|]
operator|,
name|int
specifier|const
index|[
literal|3
index|]
operator|,
name|char
specifier|const
operator|*
operator|,
name|char
specifier|const
operator|*
operator|,
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|myread
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|diff3_block
modifier|*
name|create_diff3_block
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|diff3_block
modifier|*
name|make_3way_diff
name|PARAMS
argument_list|(
operator|(
expr|struct
name|diff_block
operator|*
operator|,
expr|struct
name|diff_block
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|diff3_block
modifier|*
name|reverse_diff3_blocklist
name|PARAMS
argument_list|(
operator|(
expr|struct
name|diff3_block
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|diff3_block
modifier|*
name|using_to_diff3_block
name|PARAMS
argument_list|(
operator|(
expr|struct
name|diff_block
operator|*
index|[
literal|2
index|]
operator|,
expr|struct
name|diff_block
operator|*
index|[
literal|2
index|]
operator|,
name|int
operator|,
name|int
operator|,
expr|struct
name|diff3_block
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|diff_block
modifier|*
name|process_diff
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|char
specifier|const
operator|*
operator|,
expr|struct
name|diff_block
operator|*
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_output
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|diff3_fatal
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_diff3
name|PARAMS
argument_list|(
operator|(
expr|struct
name|diff3_block
operator|*
operator|,
name|int
specifier|const
index|[
literal|3
index|]
operator|,
name|int
specifier|const
index|[
literal|3
index|]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|diff3_perror_with_exit
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|try_help
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|undotlines
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|usage
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|initialize_main
name|PARAMS
argument_list|(
operator|(
name|int
operator|*
operator|,
name|char
operator|*
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_diff_blocks
name|PARAMS
argument_list|(
operator|(
expr|struct
name|diff_block
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_diff3_blocks
name|PARAMS
argument_list|(
operator|(
expr|struct
name|diff3_block
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Functions provided in libdiff.a or other external sources. */
end_comment

begin_decl_stmt
name|VOID
modifier|*
name|xmalloc
name|PARAMS
argument_list|(
operator|(
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|VOID
modifier|*
name|xrealloc
name|PARAMS
argument_list|(
operator|(
name|VOID
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|perror_with_name
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|diff_error
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|char
specifier|const
operator|*
operator|,
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Permit non-local exits from diff3. */
end_comment

begin_decl_stmt
specifier|static
name|jmp_buf
name|diff3_abort_buf
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DIFF3_ABORT
parameter_list|(
name|retval
parameter_list|)
value|longjmp(diff3_abort_buf, retval)
end_define

begin_decl_stmt
specifier|static
name|struct
name|option
specifier|const
name|longopts
index|[]
init|=
block|{
block|{
literal|"text"
block|,
literal|0
block|,
literal|0
block|,
literal|'a'
block|}
block|,
block|{
literal|"show-all"
block|,
literal|0
block|,
literal|0
block|,
literal|'A'
block|}
block|,
block|{
literal|"ed"
block|,
literal|0
block|,
literal|0
block|,
literal|'e'
block|}
block|,
block|{
literal|"show-overlap"
block|,
literal|0
block|,
literal|0
block|,
literal|'E'
block|}
block|,
block|{
literal|"label"
block|,
literal|1
block|,
literal|0
block|,
literal|'L'
block|}
block|,
block|{
literal|"merge"
block|,
literal|0
block|,
literal|0
block|,
literal|'m'
block|}
block|,
block|{
literal|"initial-tab"
block|,
literal|0
block|,
literal|0
block|,
literal|'T'
block|}
block|,
block|{
literal|"overlap-only"
block|,
literal|0
block|,
literal|0
block|,
literal|'x'
block|}
block|,
block|{
literal|"easy-only"
block|,
literal|0
block|,
literal|0
block|,
literal|'3'
block|}
block|,
block|{
literal|"version"
block|,
literal|0
block|,
literal|0
block|,
literal|'v'
block|}
block|,
block|{
literal|"help"
block|,
literal|0
block|,
literal|0
block|,
literal|129
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Main program.  Calls diff twice on two pairs of input files,  * combines the two diffs, and outputs them.  */
end_comment

begin_function
name|int
name|diff3_run
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|out
parameter_list|,
name|callbacks_arg
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|out
decl_stmt|;
specifier|const
name|struct
name|diff_callbacks
modifier|*
name|callbacks_arg
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
name|int
name|mapping
index|[
literal|3
index|]
decl_stmt|;
name|int
name|rev_mapping
index|[
literal|3
index|]
decl_stmt|;
name|int
name|incompat
init|=
literal|0
decl_stmt|;
name|int
name|conflicts_found
decl_stmt|;
name|int
name|status
decl_stmt|;
name|struct
name|diff_block
modifier|*
name|thread0
decl_stmt|,
modifier|*
name|thread1
decl_stmt|,
modifier|*
name|last_block
decl_stmt|;
name|char
modifier|*
name|content0
decl_stmt|,
modifier|*
name|content1
decl_stmt|;
name|struct
name|diff3_block
modifier|*
name|diff3
decl_stmt|;
name|int
name|tag_count
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|tag_strings
index|[
literal|3
index|]
decl_stmt|;
name|char
modifier|*
name|commonname
decl_stmt|;
name|char
modifier|*
modifier|*
name|file
decl_stmt|;
name|struct
name|stat
name|statb
decl_stmt|;
name|int
name|optind_old
decl_stmt|;
name|int
name|opened_file
init|=
literal|0
decl_stmt|;
name|callbacks
operator|=
name|callbacks_arg
expr_stmt|;
name|initialize_main
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
name|optind_old
operator|=
name|optind
expr_stmt|;
name|optind
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"aeimvx3AEL:TX"
argument_list|,
name|longopts
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|always_text
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|show_2nd
operator|=
literal|1
expr_stmt|;
name|flagging
operator|=
literal|1
expr_stmt|;
name|incompat
operator|++
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|overlap_only
operator|=
literal|1
expr_stmt|;
name|incompat
operator|++
expr_stmt|;
break|break;
case|case
literal|'3'
case|:
name|simple_only
operator|=
literal|1
expr_stmt|;
name|incompat
operator|++
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|finalwrite
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|merge
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|overlap_only
operator|=
literal|1
expr_stmt|;
comment|/* Falls through */
case|case
literal|'E'
case|:
name|flagging
operator|=
literal|1
expr_stmt|;
comment|/* Falls through */
case|case
literal|'e'
case|:
name|incompat
operator|++
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|tab_align_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
if|if
condition|(
name|callbacks
operator|&&
name|callbacks
operator|->
name|write_stdout
condition|)
block|{
call|(
modifier|*
name|callbacks
operator|->
name|write_stdout
call|)
argument_list|(
literal|"diff3 - GNU diffutils version "
argument_list|)
expr_stmt|;
call|(
modifier|*
name|callbacks
operator|->
name|write_stdout
call|)
argument_list|(
name|diff_version_string
argument_list|)
expr_stmt|;
call|(
modifier|*
name|callbacks
operator|->
name|write_stdout
call|)
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"diff3 - GNU diffutils version %s\n"
argument_list|,
name|diff_version_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|129
case|:
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|callbacks
operator|||
operator|!
name|callbacks
operator|->
name|write_stdout
condition|)
name|check_output
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|'L'
case|:
comment|/* Handle up to three -L options.  */
if|if
condition|(
name|tag_count
operator|<
literal|3
condition|)
block|{
name|tag_strings
index|[
name|tag_count
operator|++
index|]
operator|=
name|optarg
expr_stmt|;
break|break;
block|}
return|return
name|try_help
argument_list|(
literal|"Too many labels were given.  The limit is 3."
argument_list|)
return|;
default|default:
return|return
name|try_help
argument_list|(
literal|0
argument_list|)
return|;
block|}
block|}
name|edscript
operator|=
name|incompat
operator|&
operator|~
name|merge
expr_stmt|;
comment|/* -AeExX3 without -m implies ed script.  */
name|show_2nd
operator||=
operator|~
name|incompat
operator|&
name|merge
expr_stmt|;
comment|/* -m without -AeExX3 implies -A.  */
name|flagging
operator||=
operator|~
name|incompat
operator|&
name|merge
expr_stmt|;
if|if
condition|(
name|incompat
operator|>
literal|1
comment|/* Ensure at most one of -AeExX3.  */
operator|||
name|finalwrite
operator|&
name|merge
comment|/* -i -m would rewrite input file.  */
operator|||
operator|(
name|tag_count
operator|&&
operator|!
name|flagging
operator|)
condition|)
comment|/* -L requires one of -AEX.  */
return|return
name|try_help
argument_list|(
literal|"incompatible options"
argument_list|)
return|;
if|if
condition|(
name|argc
operator|-
name|optind
operator|!=
literal|3
condition|)
return|return
name|try_help
argument_list|(
name|argc
operator|-
name|optind
operator|<
literal|3
condition|?
literal|"missing operand"
else|:
literal|"extra operand"
argument_list|)
return|;
name|file
operator|=
operator|&
name|argv
index|[
name|optind
index|]
expr_stmt|;
name|optind
operator|=
name|optind_old
expr_stmt|;
for|for
control|(
name|i
operator|=
name|tag_count
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|tag_strings
index|[
name|i
index|]
operator|=
name|file
index|[
name|i
index|]
expr_stmt|;
comment|/* Always compare file1 to file2, even if file2 is "-".      This is needed for -mAeExX3.  Using the file0 as      the common file would produce wrong results, because if the      file0-file1 diffs didn't line up with the file0-file2 diffs      (which is entirely possible since we don't use diff's -n option),      diff3 might report phantom changes from file1 to file2.  */
comment|/* Also try to compare file0 to file1 because this is the where      changes are expected to come from.  Diffing between these pairs      of files is is most likely to return the intended changes.  There      can also be the same problem with phantom changes from file0 to      file1. */
comment|/* Historically, the default common file was file2.  Ediff for emacs      and possibly other applications, have therefore made file2 the      ancestor.  So, for compatibility, if this is simply a three      way diff (not a merge or edscript) then use the old way with      file2 as the common file. */
block|{
name|int
name|common
decl_stmt|;
if|if
condition|(
name|edscript
operator|||
name|merge
condition|)
block|{
name|common
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|common
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|file
index|[
name|common
index|]
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Sigh.  We've got standard input as the arg corresponding to 	   the desired common file.  We can't call diff twice on 	   stdin.  Use another arg as the common file instead.  */
name|common
operator|=
literal|3
operator|-
name|common
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|file
index|[
literal|0
index|]
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|file
index|[
name|common
index|]
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|diff_error
argument_list|(
literal|"%s"
argument_list|,
literal|"`-' specified for more than one input file"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
block|}
name|mapping
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|mapping
index|[
literal|1
index|]
operator|=
literal|3
operator|-
name|common
expr_stmt|;
name|mapping
index|[
literal|2
index|]
operator|=
name|common
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|rev_mapping
index|[
name|mapping
index|[
name|i
index|]
index|]
operator|=
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|file
index|[
name|i
index|]
argument_list|,
literal|"-"
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|file
index|[
name|i
index|]
argument_list|,
operator|&
name|statb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror_with_name
argument_list|(
name|file
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
elseif|else
if|if
condition|(
name|S_ISDIR
argument_list|(
name|statb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|diff_error
argument_list|(
literal|"%s: Is a directory"
argument_list|,
name|file
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
block|}
if|if
condition|(
name|callbacks
operator|&&
name|callbacks
operator|->
name|write_output
condition|)
block|{
if|if
condition|(
name|out
operator|!=
name|NULL
condition|)
block|{
name|diff_error
argument_list|(
literal|"write callback with output file"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|out
operator|==
name|NULL
condition|)
name|outfile
operator|=
name|stdout
expr_stmt|;
else|else
block|{
name|outfile
operator|=
name|fopen
argument_list|(
name|out
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|outfile
operator|==
name|NULL
condition|)
block|{
name|perror_with_name
argument_list|(
name|out
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
name|opened_file
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Set the jump buffer, so that diff may abort execution without      terminating the process. */
name|status
operator|=
name|setjmp
argument_list|(
name|diff3_abort_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|status
return|;
name|commonname
operator|=
name|file
index|[
name|rev_mapping
index|[
name|FILEC
index|]
index|]
expr_stmt|;
name|thread1
operator|=
name|process_diff
argument_list|(
name|file
index|[
name|rev_mapping
index|[
name|FILE1
index|]
index|]
argument_list|,
name|commonname
argument_list|,
operator|&
name|last_block
argument_list|,
operator|&
name|content1
argument_list|)
expr_stmt|;
comment|/* What is the intention behind determining horizon_lines from first      diff?  I think it is better to use the same parameters for each      diff so that equal differences in each diff will appear the      same. */
comment|/*   if (thread1)     for (i = 0; i< 2; i++)       { 	horizon_lines = max (horizon_lines, D_NUMLINES (thread1, i)); 	horizon_lines = max (horizon_lines, D_NUMLINES (last_block, i));       }   */
name|thread0
operator|=
name|process_diff
argument_list|(
name|file
index|[
name|rev_mapping
index|[
name|FILE0
index|]
index|]
argument_list|,
name|commonname
argument_list|,
operator|&
name|last_block
argument_list|,
operator|&
name|content0
argument_list|)
expr_stmt|;
name|diff3
operator|=
name|make_3way_diff
argument_list|(
name|thread0
argument_list|,
name|thread1
argument_list|)
expr_stmt|;
if|if
condition|(
name|edscript
condition|)
name|conflicts_found
operator|=
name|output_diff3_edscript
argument_list|(
name|diff3
argument_list|,
name|mapping
argument_list|,
name|rev_mapping
argument_list|,
name|tag_strings
index|[
literal|0
index|]
argument_list|,
name|tag_strings
index|[
literal|1
index|]
argument_list|,
name|tag_strings
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|merge
condition|)
block|{
name|FILE
modifier|*
name|mfp
init|=
name|fopen
argument_list|(
name|file
index|[
name|rev_mapping
index|[
name|FILE0
index|]
index|]
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mfp
condition|)
name|diff3_perror_with_exit
argument_list|(
name|file
index|[
name|rev_mapping
index|[
name|FILE0
index|]
index|]
argument_list|)
expr_stmt|;
name|conflicts_found
operator|=
name|output_diff3_merge
argument_list|(
name|mfp
argument_list|,
name|diff3
argument_list|,
name|mapping
argument_list|,
name|rev_mapping
argument_list|,
name|tag_strings
index|[
literal|0
index|]
argument_list|,
name|tag_strings
index|[
literal|1
index|]
argument_list|,
name|tag_strings
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|mfp
argument_list|)
condition|)
name|diff3_fatal
argument_list|(
literal|"read error"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|mfp
argument_list|)
operator|!=
literal|0
condition|)
name|perror_with_name
argument_list|(
name|file
index|[
name|rev_mapping
index|[
name|FILE0
index|]
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output_diff3
argument_list|(
name|diff3
argument_list|,
name|mapping
argument_list|,
name|rev_mapping
argument_list|)
expr_stmt|;
name|conflicts_found
operator|=
literal|0
expr_stmt|;
block|}
name|free
argument_list|(
name|content0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|content1
argument_list|)
expr_stmt|;
name|free_diff3_blocks
argument_list|(
name|diff3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|callbacks
operator|||
operator|!
name|callbacks
operator|->
name|write_output
condition|)
name|check_output
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|opened_file
condition|)
if|if
condition|(
name|fclose
argument_list|(
name|outfile
argument_list|)
operator|!=
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"close error on output file"
argument_list|)
expr_stmt|;
return|return
name|conflicts_found
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|try_help
parameter_list|(
name|reason
parameter_list|)
name|char
specifier|const
modifier|*
name|reason
decl_stmt|;
block|{
if|if
condition|(
name|reason
condition|)
name|diff_error
argument_list|(
literal|"%s"
argument_list|,
name|reason
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|diff_error
argument_list|(
literal|"Try `%s --help' for more information."
argument_list|,
name|diff_program_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_output
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
if|if
condition|(
name|ferror
argument_list|(
name|stream
argument_list|)
operator|||
name|fflush
argument_list|(
name|stream
argument_list|)
operator|!=
literal|0
condition|)
name|diff3_fatal
argument_list|(
literal|"write error"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Explain, patiently and kindly, how to use this program.  */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
if|if
condition|(
name|callbacks
operator|&&
name|callbacks
operator|->
name|write_stdout
condition|)
block|{
call|(
modifier|*
name|callbacks
operator|->
name|write_stdout
call|)
argument_list|(
literal|"Usage: "
argument_list|)
expr_stmt|;
call|(
modifier|*
name|callbacks
operator|->
name|write_stdout
call|)
argument_list|(
name|diff_program_name
argument_list|)
expr_stmt|;
call|(
modifier|*
name|callbacks
operator|->
name|write_stdout
call|)
argument_list|(
literal|" [OPTION]... MYFILE OLDFILE YOURFILE\n\n"
argument_list|)
expr_stmt|;
call|(
modifier|*
name|callbacks
operator|->
name|write_stdout
call|)
argument_list|(
literal|"\   -e  --ed  Output unmerged changes from OLDFILE to YOURFILE into MYFILE.\n\   -E  --show-overlap  Output unmerged changes, bracketing conflicts.\n\   -A  --show-all  Output all changes, bracketing conflicts.\n\   -x  --overlap-only  Output overlapping changes.\n\   -X  Output overlapping changes, bracketing them.\n\   -3  --easy-only  Output unmerged nonoverlapping changes.\n\n"
argument_list|)
expr_stmt|;
call|(
modifier|*
name|callbacks
operator|->
name|write_stdout
call|)
argument_list|(
literal|"\   -m  --merge  Output merged file instead of ed script (default -A).\n\   -L LABEL  --label=LABEL  Use LABEL instead of file name.\n\   -i  Append `w' and `q' commands to ed scripts.\n\   -a  --text  Treat all files as text.\n\   -T  --initial-tab  Make tabs line up by prepending a tab.\n\n"
argument_list|)
expr_stmt|;
call|(
modifier|*
name|callbacks
operator|->
name|write_stdout
call|)
argument_list|(
literal|"\   -v  --version  Output version info.\n\   --help  Output this help.\n\n"
argument_list|)
expr_stmt|;
call|(
modifier|*
name|callbacks
operator|->
name|write_stdout
call|)
argument_list|(
literal|"If a FILE is `-', read standard input.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Usage: %s [OPTION]... MYFILE OLDFILE YOURFILE\n\n"
argument_list|,
name|diff_program_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
literal|"\   -e  --ed  Output unmerged changes from OLDFILE to YOURFILE into MYFILE.\n\   -E  --show-overlap  Output unmerged changes, bracketing conflicts.\n\   -A  --show-all  Output all changes, bracketing conflicts.\n\   -x  --overlap-only  Output overlapping changes.\n\   -X  Output overlapping changes, bracketing them.\n\   -3  --easy-only  Output unmerged nonoverlapping changes.\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
literal|"\   -m  --merge  Output merged file instead of ed script (default -A).\n\   -L LABEL  --label=LABEL  Use LABEL instead of file name.\n\   -i  Append `w' and `q' commands to ed scripts.\n\   -a  --text  Treat all files as text.\n\   -T  --initial-tab  Make tabs line up by prepending a tab.\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
literal|"\   -v  --version  Output version info.\n\   --help  Output this help.\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"If a FILE is `-', read standard input.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Routines that combine the two diffs together into one.  The  * algorithm used follows:  *  *   File2 is shared in common between the two diffs.  *   Diff02 is the diff between 0 and 2.  *   Diff12 is the diff between 1 and 2.  *  *	1) Find the range for the first block in File2.  *	    a) Take the lowest of the two ranges (in File2) in the two  *	       current blocks (one from each diff) as being the low  *	       water mark.  Assign the upper end of this block as  *	       being the high water mark and move the current block up  *	       one.  Mark the block just moved over as to be used.  *	    b) Check the next block in the diff that the high water  *	       mark is *not* from.  *  *	       *If* the high water mark is above  *	       the low end of the range in that block,  *  *		   mark that block as to be used and move the current  *		   block up.  Set the high water mark to the max of  *		   the high end of this block and the current.  Repeat b.  *  *	 2) Find the corresponding ranges in File0 (from the blocks  *	    in diff02; line per line outside of diffs) and in File1.  *	    Create a diff3_block, reserving space as indicated by the ranges.  *  *	 3) Copy all of the pointers for file2 in.  At least for now,  *	    do memcmp's between corresponding strings in the two diffs.  *  *	 4) Copy all of the pointers for file0 and 1 in.  Get what you  *	    need from file2 (when there isn't a diff block, it's  *	    identical to file2 within the range between diff blocks).  *  *	 5) If the diff blocks you used came from only one of the two  *	    strings of diffs, then that file (i.e. the one other than  *	    the common file in that diff) is the odd person out.  If you used  *	    diff blocks from both sets, check to see if files 0 and 1 match:  *  *		Same number of lines?  If so, do a set of memcmp's (if a  *	    memcmp matches; copy the pointer over; it'll be easier later  *	    if you have to do any compares).  If they match, 0& 1 are  *	    the same.  If not, all three different.  *  *   Then you do it again, until you run out of blocks.  *  */
end_comment

begin_comment
comment|/*  * This routine makes a three way diff (chain of diff3_block's) from two  * two way diffs (chains of diff_block's).  It is assumed that each of  * the two diffs passed are onto the same file (i.e. that each of the  * diffs were made "to" the same file).  The three way diff pointer  * returned will have numbering FILE0--the other file in diff02,  * FILE1--the other file in diff12, and FILEC--the common file.  */
end_comment

begin_function
specifier|static
name|struct
name|diff3_block
modifier|*
name|make_3way_diff
parameter_list|(
name|thread0
parameter_list|,
name|thread1
parameter_list|)
name|struct
name|diff_block
modifier|*
name|thread0
decl_stmt|,
decl|*
name|thread1
decl_stmt|;
end_function

begin_block
block|{
comment|/*  * This routine works on the two diffs passed to it as threads.  * Thread number 0 is diff02, thread number 1 is diff12.  The USING  * array is set to the base of the list of blocks to be used to  * construct each block of the three way diff; if no blocks from a  * particular thread are to be used, that element of the using array  * is set to 0.  The elements LAST_USING array are set to the last  * elements on each of the using lists.  *  * The HIGH_WATER_MARK is set to the highest line number in the common file  * described in any of the diffs in either of the USING lists.  The  * HIGH_WATER_THREAD names the thread.  Similarly the BASE_WATER_MARK  * and BASE_WATER_THREAD describe the lowest line number in the common file  * described in any of the diffs in either of the USING lists.  The  * HIGH_WATER_DIFF is the diff from which the HIGH_WATER_MARK was  * taken.  *  * The HIGH_WATER_DIFF should always be equal to LAST_USING  * [HIGH_WATER_THREAD].  The OTHER_DIFF is the next diff to check for  * higher water, and should always be equal to  * CURRENT[HIGH_WATER_THREAD ^ 0x1].  The OTHER_THREAD is the thread  * in which the OTHER_DIFF is, and hence should always be equal to  * HIGH_WATER_THREAD ^ 0x1.  *  * The variable LAST_DIFF is kept set to the last diff block produced  * by this routine, for line correspondence purposes between that diff  * and the one currently being worked on.  It is initialized to  * ZERO_DIFF before any blocks have been created.  */
name|struct
name|diff_block
modifier|*
name|using
index|[
literal|2
index|]
decl_stmt|,
modifier|*
name|last_using
index|[
literal|2
index|]
decl_stmt|,
modifier|*
name|current
index|[
literal|2
index|]
decl_stmt|;
name|int
name|high_water_mark
decl_stmt|;
name|int
name|high_water_thread
decl_stmt|,
name|base_water_thread
decl_stmt|,
name|other_thread
decl_stmt|;
name|struct
name|diff_block
modifier|*
name|high_water_diff
decl_stmt|,
modifier|*
name|other_diff
decl_stmt|;
name|struct
name|diff3_block
modifier|*
name|result
decl_stmt|,
modifier|*
name|tmpblock
decl_stmt|,
modifier|*
modifier|*
name|result_end
decl_stmt|;
name|struct
name|diff3_block
specifier|const
modifier|*
name|last_diff3
decl_stmt|;
specifier|static
name|struct
name|diff3_block
specifier|const
name|zero_diff3
init|=
block|{
literal|0
block|}
decl_stmt|;
comment|/* Initialization */
name|result
operator|=
literal|0
expr_stmt|;
name|result_end
operator|=
operator|&
name|result
expr_stmt|;
name|current
index|[
literal|0
index|]
operator|=
name|thread0
expr_stmt|;
name|current
index|[
literal|1
index|]
operator|=
name|thread1
expr_stmt|;
name|last_diff3
operator|=
operator|&
name|zero_diff3
expr_stmt|;
comment|/* Sniff up the threads until we reach the end */
while|while
condition|(
name|current
index|[
literal|0
index|]
operator|||
name|current
index|[
literal|1
index|]
condition|)
block|{
name|using
index|[
literal|0
index|]
operator|=
name|using
index|[
literal|1
index|]
operator|=
name|last_using
index|[
literal|0
index|]
operator|=
name|last_using
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Setup low and high water threads, diffs, and marks.  */
if|if
condition|(
operator|!
name|current
index|[
literal|0
index|]
condition|)
name|base_water_thread
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|current
index|[
literal|1
index|]
condition|)
name|base_water_thread
operator|=
literal|0
expr_stmt|;
else|else
name|base_water_thread
operator|=
operator|(
name|D_LOWLINE
argument_list|(
name|current
index|[
literal|0
index|]
argument_list|,
name|FC
argument_list|)
operator|>
name|D_LOWLINE
argument_list|(
name|current
index|[
literal|1
index|]
argument_list|,
name|FC
argument_list|)
operator|)
expr_stmt|;
name|high_water_thread
operator|=
name|base_water_thread
expr_stmt|;
name|high_water_diff
operator|=
name|current
index|[
name|high_water_thread
index|]
expr_stmt|;
if|#
directive|if
literal|0
comment|/* low and high waters start off same diff */
block|base_water_mark = D_LOWLINE (high_water_diff, FC);
endif|#
directive|endif
name|high_water_mark
operator|=
name|D_HIGHLINE
argument_list|(
name|high_water_diff
argument_list|,
name|FC
argument_list|)
expr_stmt|;
comment|/* Make the diff you just got info from into the using class */
name|using
index|[
name|high_water_thread
index|]
operator|=
name|last_using
index|[
name|high_water_thread
index|]
operator|=
name|high_water_diff
expr_stmt|;
name|current
index|[
name|high_water_thread
index|]
operator|=
name|high_water_diff
operator|->
name|next
expr_stmt|;
name|last_using
index|[
name|high_water_thread
index|]
operator|->
name|next
operator|=
literal|0
expr_stmt|;
comment|/* And mark the other diff */
name|other_thread
operator|=
name|high_water_thread
operator|^
literal|0x1
expr_stmt|;
name|other_diff
operator|=
name|current
index|[
name|other_thread
index|]
expr_stmt|;
comment|/* Shuffle up the ladder, checking the other diff to see if it 	 needs to be incorporated.  */
while|while
condition|(
name|other_diff
operator|&&
name|D_LOWLINE
argument_list|(
name|other_diff
argument_list|,
name|FC
argument_list|)
operator|<=
name|high_water_mark
operator|+
literal|1
condition|)
block|{
comment|/* Incorporate this diff into the using list.  Note that 	     this doesn't take it off the current list */
if|if
condition|(
name|using
index|[
name|other_thread
index|]
condition|)
name|last_using
index|[
name|other_thread
index|]
operator|->
name|next
operator|=
name|other_diff
expr_stmt|;
else|else
name|using
index|[
name|other_thread
index|]
operator|=
name|other_diff
expr_stmt|;
name|last_using
index|[
name|other_thread
index|]
operator|=
name|other_diff
expr_stmt|;
comment|/* Take it off the current list.  Note that this following 	     code assumes that other_diff enters it equal to 	     current[high_water_thread ^ 0x1] */
name|current
index|[
name|other_thread
index|]
operator|=
name|current
index|[
name|other_thread
index|]
operator|->
name|next
expr_stmt|;
name|other_diff
operator|->
name|next
operator|=
literal|0
expr_stmt|;
comment|/* Set the high_water stuff 	     If this comparison is equal, then this is the last pass 	     through this loop; since diff blocks within a given 	     thread cannot overlap, the high_water_mark will be 	     *below* the range_start of either of the next diffs.  */
if|if
condition|(
name|high_water_mark
operator|<
name|D_HIGHLINE
argument_list|(
name|other_diff
argument_list|,
name|FC
argument_list|)
condition|)
block|{
name|high_water_thread
operator|^=
literal|1
expr_stmt|;
name|high_water_diff
operator|=
name|other_diff
expr_stmt|;
name|high_water_mark
operator|=
name|D_HIGHLINE
argument_list|(
name|other_diff
argument_list|,
name|FC
argument_list|)
expr_stmt|;
block|}
comment|/* Set the other diff */
name|other_thread
operator|=
name|high_water_thread
operator|^
literal|0x1
expr_stmt|;
name|other_diff
operator|=
name|current
index|[
name|other_thread
index|]
expr_stmt|;
block|}
comment|/* The using lists contain a list of all of the blocks to be 	 included in this diff3_block.  Create it.  */
name|tmpblock
operator|=
name|using_to_diff3_block
argument_list|(
name|using
argument_list|,
name|last_using
argument_list|,
name|base_water_thread
argument_list|,
name|high_water_thread
argument_list|,
name|last_diff3
argument_list|)
expr_stmt|;
name|free_diff_blocks
argument_list|(
name|using
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|free_diff_blocks
argument_list|(
name|using
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmpblock
condition|)
name|diff3_fatal
argument_list|(
literal|"internal error: screwup in format of diff blocks"
argument_list|)
expr_stmt|;
comment|/* Put it on the list.  */
operator|*
name|result_end
operator|=
name|tmpblock
expr_stmt|;
name|result_end
operator|=
operator|&
name|tmpblock
operator|->
name|next
expr_stmt|;
comment|/* Set up corresponding lines correctly.  */
name|last_diff3
operator|=
name|tmpblock
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_block

begin_comment
comment|/*  * using_to_diff3_block:  *   This routine takes two lists of blocks (from two separate diff  * threads) and puts them together into one diff3 block.  * It then returns a pointer to this diff3 block or 0 for failure.  *  * All arguments besides using are for the convenience of the routine;  * they could be derived from the using array.  * LAST_USING is a pair of pointers to the last blocks in the using  * structure.  * LOW_THREAD and HIGH_THREAD tell which threads contain the lowest  * and highest line numbers for File0.  * last_diff3 contains the last diff produced in the calling routine.  * This is used for lines mappings which would still be identical to  * the state that diff ended in.  *  * A distinction should be made in this routine between the two diffs  * that are part of a normal two diff block, and the three diffs that  * are part of a diff3_block.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|diff3_block
modifier|*
name|using_to_diff3_block
argument_list|(
name|using
argument_list|,
name|last_using
argument_list|,
name|low_thread
argument_list|,
name|high_thread
argument_list|,
name|last_diff3
argument_list|)
decl|struct
name|diff_block
modifier|*
name|using
index|[
literal|2
index|]
decl_stmt|,
modifier|*
name|last_using
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|low_thread
decl_stmt|,
name|high_thread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|diff3_block
specifier|const
modifier|*
name|last_diff3
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|low
index|[
literal|2
index|]
decl_stmt|,
name|high
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|diff3_block
modifier|*
name|result
decl_stmt|;
name|struct
name|diff_block
modifier|*
name|ptr
decl_stmt|;
name|int
name|d
decl_stmt|,
name|i
decl_stmt|;
comment|/* Find the range in the common file.  */
name|int
name|lowc
init|=
name|D_LOWLINE
argument_list|(
name|using
index|[
name|low_thread
index|]
argument_list|,
name|FC
argument_list|)
decl_stmt|;
name|int
name|highc
init|=
name|D_HIGHLINE
argument_list|(
name|last_using
index|[
name|high_thread
index|]
argument_list|,
name|FC
argument_list|)
decl_stmt|;
comment|/* Find the ranges in the other files.      If using[d] is null, that means that the file to which that diff      refers is equivalent to the common file over this range.  */
for|for
control|(
name|d
operator|=
literal|0
init|;
name|d
operator|<
literal|2
condition|;
name|d
operator|++
control|)
if|if
condition|(
name|using
index|[
name|d
index|]
condition|)
block|{
name|low
index|[
name|d
index|]
operator|=
name|D_LOW_MAPLINE
argument_list|(
name|using
index|[
name|d
index|]
argument_list|,
name|FC
argument_list|,
name|FO
argument_list|,
name|lowc
argument_list|)
expr_stmt|;
name|high
index|[
name|d
index|]
operator|=
name|D_HIGH_MAPLINE
argument_list|(
name|last_using
index|[
name|d
index|]
argument_list|,
name|FC
argument_list|,
name|FO
argument_list|,
name|highc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|low
index|[
name|d
index|]
operator|=
name|D_HIGH_MAPLINE
argument_list|(
name|last_diff3
argument_list|,
name|FILEC
argument_list|,
name|FILE0
operator|+
name|d
argument_list|,
name|lowc
argument_list|)
expr_stmt|;
name|high
index|[
name|d
index|]
operator|=
name|D_HIGH_MAPLINE
argument_list|(
name|last_diff3
argument_list|,
name|FILEC
argument_list|,
name|FILE0
operator|+
name|d
argument_list|,
name|highc
argument_list|)
expr_stmt|;
block|}
comment|/* Create a block with the appropriate sizes */
name|result
operator|=
name|create_diff3_block
argument_list|(
name|low
index|[
literal|0
index|]
argument_list|,
name|high
index|[
literal|0
index|]
argument_list|,
name|low
index|[
literal|1
index|]
argument_list|,
name|high
index|[
literal|1
index|]
argument_list|,
name|lowc
argument_list|,
name|highc
argument_list|)
expr_stmt|;
comment|/* Copy information for the common file.      Return with a zero if any of the compares failed.  */
for|for
control|(
name|d
operator|=
literal|0
init|;
name|d
operator|<
literal|2
condition|;
name|d
operator|++
control|)
for|for
control|(
name|ptr
operator|=
name|using
index|[
name|d
index|]
init|;
name|ptr
condition|;
name|ptr
operator|=
name|D_NEXT
argument_list|(
name|ptr
argument_list|)
control|)
block|{
name|int
name|result_offset
init|=
name|D_LOWLINE
argument_list|(
name|ptr
argument_list|,
name|FC
argument_list|)
operator|-
name|lowc
decl_stmt|;
if|if
condition|(
operator|!
name|copy_stringlist
argument_list|(
name|D_LINEARRAY
argument_list|(
name|ptr
argument_list|,
name|FC
argument_list|)
argument_list|,
name|D_LENARRAY
argument_list|(
name|ptr
argument_list|,
name|FC
argument_list|)
argument_list|,
name|D_LINEARRAY
argument_list|(
name|result
argument_list|,
name|FILEC
argument_list|)
operator|+
name|result_offset
argument_list|,
name|D_LENARRAY
argument_list|(
name|result
argument_list|,
name|FILEC
argument_list|)
operator|+
name|result_offset
argument_list|,
name|D_NUMLINES
argument_list|(
name|ptr
argument_list|,
name|FC
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* Copy information for file d.  First deal with anything that might be      before the first diff.  */
for|for
control|(
name|d
operator|=
literal|0
init|;
name|d
operator|<
literal|2
condition|;
name|d
operator|++
control|)
block|{
name|struct
name|diff_block
modifier|*
name|u
init|=
name|using
index|[
name|d
index|]
decl_stmt|;
name|int
name|lo
init|=
name|low
index|[
name|d
index|]
decl_stmt|,
name|hi
init|=
name|high
index|[
name|d
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|+
name|lo
operator|<
operator|(
name|u
condition|?
name|D_LOWLINE
argument_list|(
name|u
argument_list|,
name|FO
argument_list|)
else|:
name|hi
operator|+
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|D_RELNUM
argument_list|(
name|result
argument_list|,
name|FILE0
operator|+
name|d
argument_list|,
name|i
argument_list|)
operator|=
name|D_RELNUM
argument_list|(
name|result
argument_list|,
name|FILEC
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|D_RELLEN
argument_list|(
name|result
argument_list|,
name|FILE0
operator|+
name|d
argument_list|,
name|i
argument_list|)
operator|=
name|D_RELLEN
argument_list|(
name|result
argument_list|,
name|FILEC
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ptr
operator|=
name|u
init|;
name|ptr
condition|;
name|ptr
operator|=
name|D_NEXT
argument_list|(
name|ptr
argument_list|)
control|)
block|{
name|int
name|result_offset
init|=
name|D_LOWLINE
argument_list|(
name|ptr
argument_list|,
name|FO
argument_list|)
operator|-
name|lo
decl_stmt|;
name|int
name|linec
decl_stmt|;
if|if
condition|(
operator|!
name|copy_stringlist
argument_list|(
name|D_LINEARRAY
argument_list|(
name|ptr
argument_list|,
name|FO
argument_list|)
argument_list|,
name|D_LENARRAY
argument_list|(
name|ptr
argument_list|,
name|FO
argument_list|)
argument_list|,
name|D_LINEARRAY
argument_list|(
name|result
argument_list|,
name|FILE0
operator|+
name|d
argument_list|)
operator|+
name|result_offset
argument_list|,
name|D_LENARRAY
argument_list|(
name|result
argument_list|,
name|FILE0
operator|+
name|d
argument_list|)
operator|+
name|result_offset
argument_list|,
name|D_NUMLINES
argument_list|(
name|ptr
argument_list|,
name|FO
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Catch the lines between here and the next diff */
name|linec
operator|=
name|D_HIGHLINE
argument_list|(
name|ptr
argument_list|,
name|FC
argument_list|)
operator|+
literal|1
operator|-
name|lowc
expr_stmt|;
for|for
control|(
name|i
operator|=
name|D_HIGHLINE
argument_list|(
name|ptr
argument_list|,
name|FO
argument_list|)
operator|+
literal|1
operator|-
name|lo
init|;
name|i
operator|<
operator|(
name|D_NEXT
argument_list|(
name|ptr
argument_list|)
condition|?
name|D_LOWLINE
argument_list|(
name|D_NEXT
argument_list|(
name|ptr
argument_list|)
argument_list|,
name|FO
argument_list|)
else|:
name|hi
operator|+
literal|1
operator|)
operator|-
name|lo
condition|;
name|i
operator|++
control|)
block|{
name|D_RELNUM
argument_list|(
name|result
argument_list|,
name|FILE0
operator|+
name|d
argument_list|,
name|i
argument_list|)
operator|=
name|D_RELNUM
argument_list|(
name|result
argument_list|,
name|FILEC
argument_list|,
name|linec
argument_list|)
expr_stmt|;
name|D_RELLEN
argument_list|(
name|result
argument_list|,
name|FILE0
operator|+
name|d
argument_list|,
name|i
argument_list|)
operator|=
name|D_RELLEN
argument_list|(
name|result
argument_list|,
name|FILEC
argument_list|,
name|linec
argument_list|)
expr_stmt|;
name|linec
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* Set correspond */
if|if
condition|(
operator|!
name|using
index|[
literal|0
index|]
condition|)
name|D3_TYPE
argument_list|(
name|result
argument_list|)
operator|=
name|DIFF_2ND
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|using
index|[
literal|1
index|]
condition|)
name|D3_TYPE
argument_list|(
name|result
argument_list|)
operator|=
name|DIFF_1ST
expr_stmt|;
else|else
block|{
name|int
name|nl0
init|=
name|D_NUMLINES
argument_list|(
name|result
argument_list|,
name|FILE0
argument_list|)
decl_stmt|;
name|int
name|nl1
init|=
name|D_NUMLINES
argument_list|(
name|result
argument_list|,
name|FILE1
argument_list|)
decl_stmt|;
if|if
condition|(
name|nl0
operator|!=
name|nl1
operator|||
operator|!
name|compare_line_list
argument_list|(
name|D_LINEARRAY
argument_list|(
name|result
argument_list|,
name|FILE0
argument_list|)
argument_list|,
name|D_LENARRAY
argument_list|(
name|result
argument_list|,
name|FILE0
argument_list|)
argument_list|,
name|D_LINEARRAY
argument_list|(
name|result
argument_list|,
name|FILE1
argument_list|)
argument_list|,
name|D_LENARRAY
argument_list|(
name|result
argument_list|,
name|FILE1
argument_list|)
argument_list|,
name|nl0
argument_list|)
condition|)
name|D3_TYPE
argument_list|(
name|result
argument_list|)
operator|=
name|DIFF_ALL
expr_stmt|;
else|else
name|D3_TYPE
argument_list|(
name|result
argument_list|)
operator|=
name|DIFF_3RD
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_block

begin_comment
comment|/*  * This routine copies pointers from a list of strings to a different list  * of strings.  If a spot in the second list is already filled, it  * makes sure that it is filled with the same string; if not it  * returns 0, the copy incomplete.  * Upon successful completion of the copy, it returns 1.  */
end_comment

begin_function
specifier|static
name|int
name|copy_stringlist
parameter_list|(
name|fromptrs
parameter_list|,
name|fromlengths
parameter_list|,
name|toptrs
parameter_list|,
name|tolengths
parameter_list|,
name|copynum
parameter_list|)
name|char
modifier|*
specifier|const
name|fromptrs
index|[]
decl_stmt|;
name|char
modifier|*
name|toptrs
index|[]
decl_stmt|;
name|size_t
specifier|const
name|fromlengths
index|[]
decl_stmt|;
name|size_t
name|tolengths
index|[]
decl_stmt|;
name|int
name|copynum
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
specifier|const
modifier|*
name|f
init|=
name|fromptrs
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|t
init|=
name|toptrs
decl_stmt|;
specifier|register
name|size_t
specifier|const
modifier|*
name|fl
init|=
name|fromlengths
decl_stmt|;
specifier|register
name|size_t
modifier|*
name|tl
init|=
name|tolengths
decl_stmt|;
while|while
condition|(
name|copynum
operator|--
condition|)
block|{
if|if
condition|(
operator|*
name|t
condition|)
block|{
if|if
condition|(
operator|*
name|fl
operator|!=
operator|*
name|tl
operator|||
name|memcmp
argument_list|(
operator|*
name|f
argument_list|,
operator|*
name|t
argument_list|,
operator|*
name|fl
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
operator|*
name|t
operator|=
operator|*
name|f
expr_stmt|;
operator|*
name|tl
operator|=
operator|*
name|fl
expr_stmt|;
block|}
name|t
operator|++
expr_stmt|;
name|f
operator|++
expr_stmt|;
name|tl
operator|++
expr_stmt|;
name|fl
operator|++
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Create a diff3_block, with ranges as specified in the arguments.  * Allocate the arrays for the various pointers (and zero them) based  * on the arguments passed.  Return the block as a result.  */
end_comment

begin_function
specifier|static
name|struct
name|diff3_block
modifier|*
name|create_diff3_block
parameter_list|(
name|low0
parameter_list|,
name|high0
parameter_list|,
name|low1
parameter_list|,
name|high1
parameter_list|,
name|low2
parameter_list|,
name|high2
parameter_list|)
specifier|register
name|int
name|low0
decl_stmt|,
name|high0
decl_stmt|,
name|low1
decl_stmt|,
name|high1
decl_stmt|,
name|low2
decl_stmt|,
name|high2
decl_stmt|;
block|{
name|struct
name|diff3_block
modifier|*
name|result
init|=
name|ALLOCATE
argument_list|(
literal|1
argument_list|,
expr|struct
name|diff3_block
argument_list|)
decl_stmt|;
name|int
name|numlines
decl_stmt|;
name|D3_TYPE
argument_list|(
name|result
argument_list|)
operator|=
name|ERROR
expr_stmt|;
name|D_NEXT
argument_list|(
name|result
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Assign ranges */
name|D_LOWLINE
argument_list|(
name|result
argument_list|,
name|FILE0
argument_list|)
operator|=
name|low0
expr_stmt|;
name|D_HIGHLINE
argument_list|(
name|result
argument_list|,
name|FILE0
argument_list|)
operator|=
name|high0
expr_stmt|;
name|D_LOWLINE
argument_list|(
name|result
argument_list|,
name|FILE1
argument_list|)
operator|=
name|low1
expr_stmt|;
name|D_HIGHLINE
argument_list|(
name|result
argument_list|,
name|FILE1
argument_list|)
operator|=
name|high1
expr_stmt|;
name|D_LOWLINE
argument_list|(
name|result
argument_list|,
name|FILE2
argument_list|)
operator|=
name|low2
expr_stmt|;
name|D_HIGHLINE
argument_list|(
name|result
argument_list|,
name|FILE2
argument_list|)
operator|=
name|high2
expr_stmt|;
comment|/* Allocate and zero space */
name|numlines
operator|=
name|D_NUMLINES
argument_list|(
name|result
argument_list|,
name|FILE0
argument_list|)
expr_stmt|;
if|if
condition|(
name|numlines
condition|)
block|{
name|D_LINEARRAY
argument_list|(
name|result
argument_list|,
name|FILE0
argument_list|)
operator|=
name|ALLOCATE
argument_list|(
name|numlines
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|D_LENARRAY
argument_list|(
name|result
argument_list|,
name|FILE0
argument_list|)
operator|=
name|ALLOCATE
argument_list|(
name|numlines
argument_list|,
name|size_t
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|D_LINEARRAY
argument_list|(
name|result
argument_list|,
name|FILE0
argument_list|)
argument_list|,
operator|(
name|numlines
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|D_LENARRAY
argument_list|(
name|result
argument_list|,
name|FILE0
argument_list|)
argument_list|,
operator|(
name|numlines
operator|*
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|D_LINEARRAY
argument_list|(
name|result
argument_list|,
name|FILE0
argument_list|)
operator|=
literal|0
expr_stmt|;
name|D_LENARRAY
argument_list|(
name|result
argument_list|,
name|FILE0
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|numlines
operator|=
name|D_NUMLINES
argument_list|(
name|result
argument_list|,
name|FILE1
argument_list|)
expr_stmt|;
if|if
condition|(
name|numlines
condition|)
block|{
name|D_LINEARRAY
argument_list|(
name|result
argument_list|,
name|FILE1
argument_list|)
operator|=
name|ALLOCATE
argument_list|(
name|numlines
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|D_LENARRAY
argument_list|(
name|result
argument_list|,
name|FILE1
argument_list|)
operator|=
name|ALLOCATE
argument_list|(
name|numlines
argument_list|,
name|size_t
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|D_LINEARRAY
argument_list|(
name|result
argument_list|,
name|FILE1
argument_list|)
argument_list|,
operator|(
name|numlines
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|D_LENARRAY
argument_list|(
name|result
argument_list|,
name|FILE1
argument_list|)
argument_list|,
operator|(
name|numlines
operator|*
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|D_LINEARRAY
argument_list|(
name|result
argument_list|,
name|FILE1
argument_list|)
operator|=
literal|0
expr_stmt|;
name|D_LENARRAY
argument_list|(
name|result
argument_list|,
name|FILE1
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|numlines
operator|=
name|D_NUMLINES
argument_list|(
name|result
argument_list|,
name|FILE2
argument_list|)
expr_stmt|;
if|if
condition|(
name|numlines
condition|)
block|{
name|D_LINEARRAY
argument_list|(
name|result
argument_list|,
name|FILE2
argument_list|)
operator|=
name|ALLOCATE
argument_list|(
name|numlines
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|D_LENARRAY
argument_list|(
name|result
argument_list|,
name|FILE2
argument_list|)
operator|=
name|ALLOCATE
argument_list|(
name|numlines
argument_list|,
name|size_t
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|D_LINEARRAY
argument_list|(
name|result
argument_list|,
name|FILE2
argument_list|)
argument_list|,
operator|(
name|numlines
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|D_LENARRAY
argument_list|(
name|result
argument_list|,
name|FILE2
argument_list|)
argument_list|,
operator|(
name|numlines
operator|*
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|D_LINEARRAY
argument_list|(
name|result
argument_list|,
name|FILE2
argument_list|)
operator|=
literal|0
expr_stmt|;
name|D_LENARRAY
argument_list|(
name|result
argument_list|,
name|FILE2
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Return */
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Compare two lists of lines of text.  * Return 1 if they are equivalent, 0 if not.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|compare_line_list
argument_list|(
name|list1
argument_list|,
name|lengths1
argument_list|,
name|list2
argument_list|,
name|lengths2
argument_list|,
name|nl
argument_list|)
name|char
modifier|*
decl|const
name|list1
index|[]
decl_stmt|,
modifier|*
decl_stmt|const
name|list2
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
specifier|const
name|lengths1
index|[]
decl_stmt|,
name|lengths2
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nl
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
specifier|const
modifier|*
name|l1
init|=
name|list1
decl_stmt|,
modifier|*
decl_stmt|const
modifier|*
name|l2
init|=
name|list2
decl_stmt|;
name|size_t
specifier|const
modifier|*
name|lgths1
init|=
name|lengths1
decl_stmt|,
modifier|*
name|lgths2
init|=
name|lengths2
decl_stmt|;
while|while
condition|(
name|nl
operator|--
condition|)
if|if
condition|(
operator|!
operator|*
name|l1
operator|||
operator|!
operator|*
name|l2
operator|||
operator|*
name|lgths1
operator|!=
operator|*
name|lgths2
operator|++
operator|||
name|memcmp
argument_list|(
operator|*
name|l1
operator|++
argument_list|,
operator|*
name|l2
operator|++
argument_list|,
operator|*
name|lgths1
operator|++
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Routines to input and parse two way diffs.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|diff_block
modifier|*
name|process_diff
parameter_list|(
name|filea
parameter_list|,
name|fileb
parameter_list|,
name|last_block
parameter_list|,
name|diff_contents
parameter_list|)
name|char
specifier|const
modifier|*
name|filea
decl_stmt|,
decl|*
name|fileb
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|diff_block
modifier|*
modifier|*
name|last_block
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|diff_contents
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|diff_limit
decl_stmt|;
name|char
modifier|*
name|scan_diff
decl_stmt|;
name|enum
name|diff_type
name|dt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|diff_block
modifier|*
name|block_list
decl_stmt|,
modifier|*
modifier|*
name|block_list_end
decl_stmt|,
modifier|*
name|bptr
decl_stmt|;
name|diff_limit
operator|=
name|read_diff
argument_list|(
name|filea
argument_list|,
name|fileb
argument_list|,
name|diff_contents
argument_list|)
expr_stmt|;
name|scan_diff
operator|=
operator|*
name|diff_contents
expr_stmt|;
name|block_list_end
operator|=
operator|&
name|block_list
expr_stmt|;
name|bptr
operator|=
literal|0
expr_stmt|;
comment|/* Pacify `gcc -W'.  */
while|while
condition|(
name|scan_diff
operator|<
name|diff_limit
condition|)
block|{
name|bptr
operator|=
name|ALLOCATE
argument_list|(
literal|1
argument_list|,
expr|struct
name|diff_block
argument_list|)
expr_stmt|;
name|bptr
operator|->
name|lines
index|[
literal|0
index|]
operator|=
name|bptr
operator|->
name|lines
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|bptr
operator|->
name|lengths
index|[
literal|0
index|]
operator|=
name|bptr
operator|->
name|lengths
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|dt
operator|=
name|process_diff_control
argument_list|(
operator|&
name|scan_diff
argument_list|,
name|bptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dt
operator|==
name|ERROR
operator|||
operator|*
name|scan_diff
operator|!=
literal|'\n'
condition|)
block|{
name|char
modifier|*
name|serr
decl_stmt|;
for|for
control|(
name|serr
operator|=
name|scan_diff
init|;
operator|*
name|serr
operator|!=
literal|'\n'
condition|;
name|serr
operator|++
control|)
empty_stmt|;
operator|*
name|serr
operator|=
literal|'\0'
expr_stmt|;
name|diff_error
argument_list|(
literal|"diff error: %s"
argument_list|,
name|scan_diff
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|serr
operator|=
literal|'\n'
expr_stmt|;
name|DIFF3_ABORT
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|scan_diff
operator|++
expr_stmt|;
comment|/* Force appropriate ranges to be null, if necessary */
switch|switch
condition|(
name|dt
condition|)
block|{
case|case
name|ADD
case|:
name|bptr
operator|->
name|ranges
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|++
expr_stmt|;
break|break;
case|case
name|DELETE
case|:
name|bptr
operator|->
name|ranges
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|++
expr_stmt|;
break|break;
case|case
name|CHANGE
case|:
break|break;
default|default:
name|diff3_fatal
argument_list|(
literal|"internal error: invalid diff type in process_diff"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Allocate space for the pointers for the lines from filea, and 	 parcel them out among these pointers */
if|if
condition|(
name|dt
operator|!=
name|ADD
condition|)
block|{
name|int
name|numlines
init|=
name|D_NUMLINES
argument_list|(
name|bptr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|bptr
operator|->
name|lines
index|[
literal|0
index|]
operator|=
name|ALLOCATE
argument_list|(
name|numlines
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|bptr
operator|->
name|lengths
index|[
literal|0
index|]
operator|=
name|ALLOCATE
argument_list|(
name|numlines
argument_list|,
name|size_t
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numlines
condition|;
name|i
operator|++
control|)
name|scan_diff
operator|=
name|scan_diff_line
argument_list|(
name|scan_diff
argument_list|,
operator|&
operator|(
name|bptr
operator|->
name|lines
index|[
literal|0
index|]
index|[
name|i
index|]
operator|)
argument_list|,
operator|&
operator|(
name|bptr
operator|->
name|lengths
index|[
literal|0
index|]
index|[
name|i
index|]
operator|)
argument_list|,
name|diff_limit
argument_list|,
literal|'<'
argument_list|)
expr_stmt|;
block|}
comment|/* Get past the separator for changes */
if|if
condition|(
name|dt
operator|==
name|CHANGE
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|scan_diff
argument_list|,
literal|"---\n"
argument_list|,
literal|4
argument_list|)
condition|)
name|diff3_fatal
argument_list|(
literal|"invalid diff format; invalid change separator"
argument_list|)
expr_stmt|;
name|scan_diff
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* Allocate space for the pointers for the lines from fileb, and 	 parcel them out among these pointers */
if|if
condition|(
name|dt
operator|!=
name|DELETE
condition|)
block|{
name|int
name|numlines
init|=
name|D_NUMLINES
argument_list|(
name|bptr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|bptr
operator|->
name|lines
index|[
literal|1
index|]
operator|=
name|ALLOCATE
argument_list|(
name|numlines
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|bptr
operator|->
name|lengths
index|[
literal|1
index|]
operator|=
name|ALLOCATE
argument_list|(
name|numlines
argument_list|,
name|size_t
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numlines
condition|;
name|i
operator|++
control|)
name|scan_diff
operator|=
name|scan_diff_line
argument_list|(
name|scan_diff
argument_list|,
operator|&
operator|(
name|bptr
operator|->
name|lines
index|[
literal|1
index|]
index|[
name|i
index|]
operator|)
argument_list|,
operator|&
operator|(
name|bptr
operator|->
name|lengths
index|[
literal|1
index|]
index|[
name|i
index|]
operator|)
argument_list|,
name|diff_limit
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
block|}
comment|/* Place this block on the blocklist.  */
operator|*
name|block_list_end
operator|=
name|bptr
expr_stmt|;
name|block_list_end
operator|=
operator|&
name|bptr
operator|->
name|next
expr_stmt|;
block|}
operator|*
name|block_list_end
operator|=
literal|0
expr_stmt|;
operator|*
name|last_block
operator|=
name|bptr
expr_stmt|;
return|return
name|block_list
return|;
block|}
end_block

begin_comment
comment|/*  * This routine will parse a normal format diff control string.  It  * returns the type of the diff (ERROR if the format is bad).  All of  * the other important information is filled into to the structure  * pointed to by db, and the string pointer (whose location is passed  * to this routine) is updated to point beyond the end of the string  * parsed.  Note that only the ranges in the diff_block will be set by  * this routine.  *  * If some specific pair of numbers has been reduced to a single  * number, then both corresponding numbers in the diff block are set  * to that number.  In general these numbers are interpetted as ranges  * inclusive, unless being used by the ADD or DELETE commands.  It is  * assumed that these will be special cased in a superior routine.  */
end_comment

begin_function
specifier|static
name|enum
name|diff_type
name|process_diff_control
parameter_list|(
name|string
parameter_list|,
name|db
parameter_list|)
name|char
modifier|*
modifier|*
name|string
decl_stmt|;
name|struct
name|diff_block
modifier|*
name|db
decl_stmt|;
block|{
name|char
modifier|*
name|s
init|=
operator|*
name|string
decl_stmt|;
name|int
name|holdnum
decl_stmt|;
name|enum
name|diff_type
name|type
decl_stmt|;
comment|/* These macros are defined here because they can use variables    defined in this function.  Don't try this at home kids, we're    trained professionals!     Also note that SKIPWHITE only recognizes tabs and spaces, and    that READNUM can only read positive, integral numbers */
define|#
directive|define
name|SKIPWHITE
parameter_list|(
name|s
parameter_list|)
value|{ while (*s == ' ' || *s == '\t') s++; }
define|#
directive|define
name|READNUM
parameter_list|(
name|s
parameter_list|,
name|num
parameter_list|)
define|\
value|{ unsigned char c = *s; if (!ISDIGIT (c)) return ERROR; holdnum = 0; \ 	  do { holdnum = (c - '0' + holdnum * 10); }	\ 	  while (ISDIGIT (c = *++s)); (num) = holdnum; }
comment|/* Read first set of digits */
name|SKIPWHITE
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|READNUM
argument_list|(
name|s
argument_list|,
name|db
operator|->
name|ranges
index|[
literal|0
index|]
index|[
name|START
index|]
argument_list|)
expr_stmt|;
comment|/* Was that the only digit? */
name|SKIPWHITE
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
block|{
comment|/* Get the next digit */
name|s
operator|++
expr_stmt|;
name|READNUM
argument_list|(
name|s
argument_list|,
name|db
operator|->
name|ranges
index|[
literal|0
index|]
index|[
name|END
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|db
operator|->
name|ranges
index|[
literal|0
index|]
index|[
name|END
index|]
operator|=
name|db
operator|->
name|ranges
index|[
literal|0
index|]
index|[
name|START
index|]
expr_stmt|;
comment|/* Get the letter */
name|SKIPWHITE
argument_list|(
name|s
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'a'
case|:
name|type
operator|=
name|ADD
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|type
operator|=
name|CHANGE
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|type
operator|=
name|DELETE
expr_stmt|;
break|break;
default|default:
return|return
name|ERROR
return|;
comment|/* Bad format */
block|}
name|s
operator|++
expr_stmt|;
comment|/* Past letter */
comment|/* Read second set of digits */
name|SKIPWHITE
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|READNUM
argument_list|(
name|s
argument_list|,
name|db
operator|->
name|ranges
index|[
literal|1
index|]
index|[
name|START
index|]
argument_list|)
expr_stmt|;
comment|/* Was that the only digit? */
name|SKIPWHITE
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
block|{
comment|/* Get the next digit */
name|s
operator|++
expr_stmt|;
name|READNUM
argument_list|(
name|s
argument_list|,
name|db
operator|->
name|ranges
index|[
literal|1
index|]
index|[
name|END
index|]
argument_list|)
expr_stmt|;
name|SKIPWHITE
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* To move to end */
block|}
else|else
name|db
operator|->
name|ranges
index|[
literal|1
index|]
index|[
name|END
index|]
operator|=
name|db
operator|->
name|ranges
index|[
literal|1
index|]
index|[
name|START
index|]
expr_stmt|;
operator|*
name|string
operator|=
name|s
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|read_diff
parameter_list|(
name|filea
parameter_list|,
name|fileb
parameter_list|,
name|output_placement
parameter_list|)
name|char
specifier|const
modifier|*
name|filea
decl_stmt|,
decl|*
name|fileb
decl_stmt|;
end_function

begin_decl_stmt
name|char
modifier|*
modifier|*
name|output_placement
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|diff_result
decl_stmt|;
name|size_t
name|bytes
decl_stmt|,
name|current_chunk_size
decl_stmt|,
name|total
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|wstatus
decl_stmt|;
name|struct
name|stat
name|pipestat
decl_stmt|;
name|FILE
modifier|*
name|outfile_hold
decl_stmt|;
specifier|const
name|struct
name|diff_callbacks
modifier|*
name|callbacks_hold
decl_stmt|;
name|struct
name|diff_callbacks
name|my_callbacks
decl_stmt|;
name|struct
name|diff_callbacks
modifier|*
name|my_callbacks_arg
decl_stmt|;
comment|/* 302 / 1000 is log10(2.0) rounded up.  Subtract 1 for the sign bit;      add 1 for integer division truncation; add 1 more for a minus sign.  */
define|#
directive|define
name|INT_STRLEN_BOUND
parameter_list|(
name|type
parameter_list|)
value|((sizeof(type)*CHAR_BIT - 1) * 302 / 1000 + 2)
name|char
specifier|const
modifier|*
name|argv
index|[
literal|7
index|]
decl_stmt|;
name|char
name|horizon_arg
index|[
literal|17
operator|+
name|INT_STRLEN_BOUND
argument_list|(
name|int
argument_list|)
index|]
decl_stmt|;
name|char
specifier|const
modifier|*
modifier|*
name|ap
decl_stmt|;
name|char
modifier|*
name|diffout
decl_stmt|;
name|ap
operator|=
name|argv
expr_stmt|;
operator|*
name|ap
operator|++
operator|=
literal|"diff"
expr_stmt|;
if|if
condition|(
name|always_text
condition|)
operator|*
name|ap
operator|++
operator|=
literal|"-a"
expr_stmt|;
name|sprintf
argument_list|(
name|horizon_arg
argument_list|,
literal|"--horizon-lines=%d"
argument_list|,
name|horizon_lines
argument_list|)
expr_stmt|;
operator|*
name|ap
operator|++
operator|=
name|horizon_arg
expr_stmt|;
operator|*
name|ap
operator|++
operator|=
literal|"--"
expr_stmt|;
operator|*
name|ap
operator|++
operator|=
name|filea
expr_stmt|;
operator|*
name|ap
operator|++
operator|=
name|fileb
expr_stmt|;
operator|*
name|ap
operator|=
literal|0
expr_stmt|;
name|diffout
operator|=
name|cvs_temp_name
argument_list|()
expr_stmt|;
name|outfile_hold
operator|=
name|outfile
expr_stmt|;
name|callbacks_hold
operator|=
name|callbacks
expr_stmt|;
comment|/* We want to call diff_run preserving any stdout and stderr      callbacks, but discarding any callbacks to handle file output,      since we want the file output to go to our temporary file.      FIXME: We should use callbacks to just read it into a memory      buffer; that's we do with the temporary file just below anyhow.  */
if|if
condition|(
name|callbacks
operator|==
name|NULL
condition|)
name|my_callbacks_arg
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|my_callbacks
operator|=
operator|*
name|callbacks
expr_stmt|;
name|my_callbacks
operator|.
name|write_output
operator|=
name|NULL
expr_stmt|;
name|my_callbacks
operator|.
name|flush_output
operator|=
name|NULL
expr_stmt|;
name|my_callbacks_arg
operator|=
operator|&
name|my_callbacks
expr_stmt|;
block|}
name|wstatus
operator|=
name|diff_run
argument_list|(
name|ap
operator|-
name|argv
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|argv
argument_list|,
name|diffout
argument_list|,
name|my_callbacks_arg
argument_list|)
expr_stmt|;
name|outfile
operator|=
name|outfile_hold
expr_stmt|;
name|callbacks
operator|=
name|callbacks_hold
expr_stmt|;
if|if
condition|(
name|wstatus
operator|==
literal|2
condition|)
name|diff3_fatal
argument_list|(
literal|"subsidiary diff failed"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
operator|(
name|fd
operator|=
name|open
argument_list|(
name|diffout
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
condition|)
name|diff3_fatal
argument_list|(
literal|"could not open temporary diff file"
argument_list|)
expr_stmt|;
name|current_chunk_size
operator|=
literal|8
operator|*
literal|1024
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|pipestat
argument_list|)
operator|==
literal|0
condition|)
name|current_chunk_size
operator|=
name|max
argument_list|(
name|current_chunk_size
argument_list|,
name|STAT_BLOCKSIZE
argument_list|(
name|pipestat
argument_list|)
argument_list|)
expr_stmt|;
name|diff_result
operator|=
name|xmalloc
argument_list|(
name|current_chunk_size
argument_list|)
expr_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|bytes
operator|=
name|myread
argument_list|(
name|fd
argument_list|,
name|diff_result
operator|+
name|total
argument_list|,
name|current_chunk_size
operator|-
name|total
argument_list|)
expr_stmt|;
name|total
operator|+=
name|bytes
expr_stmt|;
if|if
condition|(
name|total
operator|==
name|current_chunk_size
condition|)
block|{
if|if
condition|(
name|current_chunk_size
operator|<
literal|2
operator|*
name|current_chunk_size
condition|)
name|current_chunk_size
operator|=
literal|2
operator|*
name|current_chunk_size
expr_stmt|;
elseif|else
if|if
condition|(
name|current_chunk_size
operator|<
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
name|current_chunk_size
operator|=
operator|(
name|size_t
operator|)
operator|-
literal|1
expr_stmt|;
else|else
name|diff3_fatal
argument_list|(
literal|"files are too large to fit into memory"
argument_list|)
expr_stmt|;
name|diff_result
operator|=
name|xrealloc
argument_list|(
name|diff_result
argument_list|,
operator|(
name|current_chunk_size
operator|*=
literal|2
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|bytes
condition|)
do|;
if|if
condition|(
name|total
operator|!=
literal|0
operator|&&
name|diff_result
index|[
name|total
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|diff3_fatal
argument_list|(
literal|"invalid diff format; incomplete last line"
argument_list|)
expr_stmt|;
operator|*
name|output_placement
operator|=
name|diff_result
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|!=
literal|0
condition|)
name|diff3_perror_with_exit
argument_list|(
literal|"pipe close"
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|diffout
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|diffout
argument_list|)
expr_stmt|;
return|return
name|diff_result
operator|+
name|total
return|;
block|}
end_block

begin_comment
comment|/*  * Scan a regular diff line (consisting of> or<, followed by a  * space, followed by text (including nulls) up to a newline.  *  * This next routine began life as a macro and many parameters in it  * are used as call-by-reference values.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|scan_diff_line
parameter_list|(
name|scan_ptr
parameter_list|,
name|set_start
parameter_list|,
name|set_length
parameter_list|,
name|limit
parameter_list|,
name|leadingchar
parameter_list|)
name|char
modifier|*
name|scan_ptr
decl_stmt|,
decl|*
modifier|*
name|set_start
decl_stmt|;
end_function

begin_decl_stmt
name|size_t
modifier|*
name|set_length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|limit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|leadingchar
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|line_ptr
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|scan_ptr
index|[
literal|0
index|]
operator|==
name|leadingchar
operator|&&
name|scan_ptr
index|[
literal|1
index|]
operator|==
literal|' '
operator|)
condition|)
name|diff3_fatal
argument_list|(
literal|"invalid diff format; incorrect leading line chars"
argument_list|)
expr_stmt|;
operator|*
name|set_start
operator|=
name|line_ptr
operator|=
name|scan_ptr
operator|+
literal|2
expr_stmt|;
while|while
condition|(
operator|*
name|line_ptr
operator|++
operator|!=
literal|'\n'
condition|)
empty_stmt|;
comment|/* Include newline if the original line ended in a newline,      or if an edit script is being generated.      Copy any missing newline message to stderr if an edit script is being      generated, because edit scripts cannot handle missing newlines.      Return the beginning of the next line.  */
operator|*
name|set_length
operator|=
name|line_ptr
operator|-
operator|*
name|set_start
expr_stmt|;
if|if
condition|(
name|line_ptr
operator|<
name|limit
operator|&&
operator|*
name|line_ptr
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
operator|!
name|edscript
condition|)
block|{
operator|--
operator|*
name|set_length
expr_stmt|;
name|line_ptr
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|line_ptr
operator|++
operator|!=
literal|'\n'
condition|)
empty_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|serr
decl_stmt|;
name|line_ptr
operator|++
expr_stmt|;
name|serr
operator|=
name|line_ptr
expr_stmt|;
while|while
condition|(
operator|*
name|line_ptr
operator|++
operator|!=
literal|'\n'
condition|)
empty_stmt|;
name|line_ptr
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|diff_error
argument_list|(
literal|"%s"
argument_list|,
name|serr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|line_ptr
index|[
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
return|return
name|line_ptr
return|;
block|}
end_block

begin_comment
comment|/*  * This routine outputs a three way diff passed as a list of  * diff3_block's.  * The argument MAPPING is indexed by external file number (in the  * argument list) and contains the internal file number (from the  * diff passed).  This is important because the user expects his  * outputs in terms of the argument list number, and the diff passed  * may have been done slightly differently (if the last argument  * was "-", for example).  * REV_MAPPING is the inverse of MAPPING.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|output_diff3
argument_list|(
name|diff
argument_list|,
name|mapping
argument_list|,
name|rev_mapping
argument_list|)
decl|struct
name|diff3_block
modifier|*
name|diff
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
specifier|const
name|mapping
index|[
literal|3
index|]
decl_stmt|,
name|rev_mapping
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|int
name|oddoneout
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|diff3_block
modifier|*
name|ptr
decl_stmt|;
name|int
name|line
decl_stmt|;
name|size_t
name|length
decl_stmt|;
name|int
name|dontprint
decl_stmt|;
specifier|static
name|int
name|skew_increment
index|[
literal|3
index|]
init|=
block|{
literal|2
block|,
literal|3
block|,
literal|1
block|}
decl_stmt|;
comment|/* 0==>2==>1==>3 */
name|char
specifier|const
modifier|*
name|line_prefix
init|=
name|tab_align_flag
condition|?
literal|"\t"
else|:
literal|"  "
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|diff
init|;
name|ptr
condition|;
name|ptr
operator|=
name|D_NEXT
argument_list|(
name|ptr
argument_list|)
control|)
block|{
name|char
name|x
index|[
literal|2
index|]
decl_stmt|;
switch|switch
condition|(
name|ptr
operator|->
name|correspond
condition|)
block|{
case|case
name|DIFF_ALL
case|:
name|x
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dontprint
operator|=
literal|3
expr_stmt|;
comment|/* Print them all */
name|oddoneout
operator|=
literal|3
expr_stmt|;
comment|/* Nobody's odder than anyone else */
break|break;
case|case
name|DIFF_1ST
case|:
case|case
name|DIFF_2ND
case|:
case|case
name|DIFF_3RD
case|:
name|oddoneout
operator|=
name|rev_mapping
index|[
operator|(
name|int
operator|)
name|ptr
operator|->
name|correspond
operator|-
operator|(
name|int
operator|)
name|DIFF_1ST
index|]
expr_stmt|;
name|x
index|[
literal|0
index|]
operator|=
name|oddoneout
operator|+
literal|'1'
expr_stmt|;
name|x
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dontprint
operator|=
name|oddoneout
operator|==
literal|0
expr_stmt|;
break|break;
default|default:
name|diff3_fatal
argument_list|(
literal|"internal error: invalid diff type passed to output"
argument_list|)
expr_stmt|;
block|}
name|printf_output
argument_list|(
literal|"====%s\n"
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Go 0, 2, 1 if the first and third outputs are equivalent.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|=
operator|(
name|oddoneout
operator|==
literal|1
condition|?
name|skew_increment
index|[
name|i
index|]
else|:
name|i
operator|+
literal|1
operator|)
control|)
block|{
name|int
name|realfile
init|=
name|mapping
index|[
name|i
index|]
decl_stmt|;
name|int
name|lowt
init|=
name|D_LOWLINE
argument_list|(
name|ptr
argument_list|,
name|realfile
argument_list|)
decl_stmt|,
name|hight
init|=
name|D_HIGHLINE
argument_list|(
name|ptr
argument_list|,
name|realfile
argument_list|)
decl_stmt|;
name|printf_output
argument_list|(
literal|"%d:"
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|lowt
operator|-
name|hight
condition|)
block|{
case|case
literal|1
case|:
name|printf_output
argument_list|(
literal|"%da\n"
argument_list|,
name|lowt
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|printf_output
argument_list|(
literal|"%dc\n"
argument_list|,
name|lowt
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf_output
argument_list|(
literal|"%d,%dc\n"
argument_list|,
name|lowt
argument_list|,
name|hight
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|dontprint
condition|)
continue|continue;
if|if
condition|(
name|lowt
operator|<=
name|hight
condition|)
block|{
name|line
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|printf_output
argument_list|(
name|line_prefix
argument_list|)
expr_stmt|;
name|cp
operator|=
name|D_RELNUM
argument_list|(
name|ptr
argument_list|,
name|realfile
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|length
operator|=
name|D_RELLEN
argument_list|(
name|ptr
argument_list|,
name|realfile
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|write_output
argument_list|(
name|cp
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|line
operator|<
name|hight
operator|-
name|lowt
operator|+
literal|1
condition|)
do|;
if|if
condition|(
name|cp
index|[
name|length
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|printf_output
argument_list|(
literal|"\n\\ No newline at end of file\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Output the lines of B taken from FILENUM.  * Double any initial '.'s; yield nonzero if any initial '.'s were doubled.  */
end_comment

begin_function
specifier|static
name|int
name|dotlines
parameter_list|(
name|b
parameter_list|,
name|filenum
parameter_list|)
name|struct
name|diff3_block
modifier|*
name|b
decl_stmt|;
name|int
name|filenum
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|leading_dot
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|D_NUMLINES
argument_list|(
name|b
argument_list|,
name|filenum
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|line
init|=
name|D_RELNUM
argument_list|(
name|b
argument_list|,
name|filenum
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
name|leading_dot
operator|=
literal|1
expr_stmt|;
name|write_output
argument_list|(
literal|"."
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|write_output
argument_list|(
name|line
argument_list|,
name|D_RELLEN
argument_list|(
name|b
argument_list|,
name|filenum
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|leading_dot
return|;
block|}
end_function

begin_comment
comment|/*  * Output to OUTPUTFILE a '.' line.  If LEADING_DOT is nonzero,  * also output a command that removes initial '.'s  * starting with line START and continuing for NUM lines.  */
end_comment

begin_function
specifier|static
name|void
name|undotlines
parameter_list|(
name|leading_dot
parameter_list|,
name|start
parameter_list|,
name|num
parameter_list|)
name|int
name|leading_dot
decl_stmt|,
name|start
decl_stmt|,
name|num
decl_stmt|;
block|{
name|write_output
argument_list|(
literal|".\n"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|leading_dot
condition|)
if|if
condition|(
name|num
operator|==
literal|1
condition|)
name|printf_output
argument_list|(
literal|"%ds/^\\.//\n"
argument_list|,
name|start
argument_list|)
expr_stmt|;
else|else
name|printf_output
argument_list|(
literal|"%d,%ds/^\\.//\n"
argument_list|,
name|start
argument_list|,
name|start
operator|+
name|num
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine outputs a diff3 set of blocks as an ed script.  This  * script applies the changes between file's 2& 3 to file 1.  It  * takes the precise format of the ed script to be output from global  * variables set during options processing.  Note that it does  * destructive things to the set of diff3 blocks it is passed; it  * reverses their order (this gets around the problems involved with  * changing line numbers in an ed script).  *  * Note that this routine has the same problem of mapping as the last  * one did; the variable MAPPING maps from file number according to  * the argument list to file number according to the diff passed.  All  * files listed below are in terms of the argument list.  * REV_MAPPING is the inverse of MAPPING.  *  * The arguments FILE0, FILE1 and FILE2 are the strings to print  * as the names of the three files.  These may be the actual names,  * or may be the arguments specified with -L.  *  * Returns 1 if conflicts were found.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|output_diff3_edscript
argument_list|(
name|diff
argument_list|,
name|mapping
argument_list|,
name|rev_mapping
argument_list|,
name|file0
argument_list|,
name|file1
argument_list|,
name|file2
argument_list|)
decl|struct
name|diff3_block
modifier|*
name|diff
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
specifier|const
name|mapping
index|[
literal|3
index|]
decl_stmt|,
name|rev_mapping
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
specifier|const
modifier|*
name|file0
decl_stmt|,
modifier|*
name|file1
decl_stmt|,
modifier|*
name|file2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|leading_dot
decl_stmt|;
name|int
name|conflicts_found
init|=
literal|0
decl_stmt|,
name|conflict
decl_stmt|;
name|struct
name|diff3_block
modifier|*
name|b
decl_stmt|;
for|for
control|(
name|b
operator|=
name|reverse_diff3_blocklist
argument_list|(
name|diff
argument_list|)
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|next
control|)
block|{
comment|/* Must do mapping correctly.  */
name|enum
name|diff_type
name|type
init|=
operator|(
operator|(
name|b
operator|->
name|correspond
operator|==
name|DIFF_ALL
operator|)
condition|?
name|DIFF_ALL
else|:
operator|(
operator|(
expr|enum
name|diff_type
operator|)
operator|(
operator|(
operator|(
name|int
operator|)
name|DIFF_1ST
operator|)
operator|+
name|rev_mapping
index|[
operator|(
name|int
operator|)
name|b
operator|->
name|correspond
operator|-
operator|(
name|int
operator|)
name|DIFF_1ST
index|]
operator|)
operator|)
operator|)
decl_stmt|;
comment|/* If we aren't supposed to do this output block, skip it.  */
switch|switch
condition|(
name|type
condition|)
block|{
default|default:
continue|continue;
case|case
name|DIFF_2ND
case|:
if|if
condition|(
operator|!
name|show_2nd
condition|)
continue|continue;
name|conflict
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DIFF_3RD
case|:
if|if
condition|(
name|overlap_only
condition|)
continue|continue;
name|conflict
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DIFF_ALL
case|:
if|if
condition|(
name|simple_only
condition|)
continue|continue;
name|conflict
operator|=
name|flagging
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|conflict
condition|)
block|{
name|conflicts_found
operator|=
literal|1
expr_stmt|;
comment|/* Mark end of conflict.  */
name|printf_output
argument_list|(
literal|"%da\n"
argument_list|,
name|D_HIGHLINE
argument_list|(
name|b
argument_list|,
name|mapping
index|[
name|FILE0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|leading_dot
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|DIFF_ALL
condition|)
block|{
if|if
condition|(
name|show_2nd
condition|)
block|{
comment|/* Append lines from FILE1.  */
name|printf_output
argument_list|(
literal|"||||||| %s\n"
argument_list|,
name|file1
argument_list|)
expr_stmt|;
name|leading_dot
operator|=
name|dotlines
argument_list|(
name|b
argument_list|,
name|mapping
index|[
name|FILE1
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Append lines from FILE2.  */
name|printf_output
argument_list|(
literal|"=======\n"
argument_list|)
expr_stmt|;
name|leading_dot
operator||=
name|dotlines
argument_list|(
name|b
argument_list|,
name|mapping
index|[
name|FILE2
index|]
argument_list|)
expr_stmt|;
block|}
name|printf_output
argument_list|(
literal|">>>>>>> %s\n"
argument_list|,
name|file2
argument_list|)
expr_stmt|;
name|undotlines
argument_list|(
name|leading_dot
argument_list|,
name|D_HIGHLINE
argument_list|(
name|b
argument_list|,
name|mapping
index|[
name|FILE0
index|]
argument_list|)
operator|+
literal|2
argument_list|,
operator|(
name|D_NUMLINES
argument_list|(
name|b
argument_list|,
name|mapping
index|[
name|FILE1
index|]
argument_list|)
operator|+
name|D_NUMLINES
argument_list|(
name|b
argument_list|,
name|mapping
index|[
name|FILE2
index|]
argument_list|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* Mark start of conflict.  */
name|printf_output
argument_list|(
literal|"%da\n<<<<<<< %s\n"
argument_list|,
name|D_LOWLINE
argument_list|(
name|b
argument_list|,
name|mapping
index|[
name|FILE0
index|]
argument_list|)
operator|-
literal|1
argument_list|,
name|type
operator|==
name|DIFF_ALL
condition|?
name|file0
else|:
name|file1
argument_list|)
expr_stmt|;
name|leading_dot
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|DIFF_2ND
condition|)
block|{
comment|/* Prepend lines from FILE1.  */
name|leading_dot
operator|=
name|dotlines
argument_list|(
name|b
argument_list|,
name|mapping
index|[
name|FILE1
index|]
argument_list|)
expr_stmt|;
name|printf_output
argument_list|(
literal|"=======\n"
argument_list|)
expr_stmt|;
block|}
name|undotlines
argument_list|(
name|leading_dot
argument_list|,
name|D_LOWLINE
argument_list|(
name|b
argument_list|,
name|mapping
index|[
name|FILE0
index|]
argument_list|)
operator|+
literal|1
argument_list|,
name|D_NUMLINES
argument_list|(
name|b
argument_list|,
name|mapping
index|[
name|FILE1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|D_NUMLINES
argument_list|(
name|b
argument_list|,
name|mapping
index|[
name|FILE2
index|]
argument_list|)
operator|==
literal|0
condition|)
comment|/* Write out a delete */
block|{
if|if
condition|(
name|D_NUMLINES
argument_list|(
name|b
argument_list|,
name|mapping
index|[
name|FILE0
index|]
argument_list|)
operator|==
literal|1
condition|)
name|printf_output
argument_list|(
literal|"%dd\n"
argument_list|,
name|D_LOWLINE
argument_list|(
name|b
argument_list|,
name|mapping
index|[
name|FILE0
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf_output
argument_list|(
literal|"%d,%dd\n"
argument_list|,
name|D_LOWLINE
argument_list|(
name|b
argument_list|,
name|mapping
index|[
name|FILE0
index|]
argument_list|)
argument_list|,
name|D_HIGHLINE
argument_list|(
name|b
argument_list|,
name|mapping
index|[
name|FILE0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Write out an add or change */
block|{
switch|switch
condition|(
name|D_NUMLINES
argument_list|(
name|b
argument_list|,
name|mapping
index|[
name|FILE0
index|]
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|printf_output
argument_list|(
literal|"%da\n"
argument_list|,
name|D_HIGHLINE
argument_list|(
name|b
argument_list|,
name|mapping
index|[
name|FILE0
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|printf_output
argument_list|(
literal|"%dc\n"
argument_list|,
name|D_HIGHLINE
argument_list|(
name|b
argument_list|,
name|mapping
index|[
name|FILE0
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf_output
argument_list|(
literal|"%d,%dc\n"
argument_list|,
name|D_LOWLINE
argument_list|(
name|b
argument_list|,
name|mapping
index|[
name|FILE0
index|]
argument_list|)
argument_list|,
name|D_HIGHLINE
argument_list|(
name|b
argument_list|,
name|mapping
index|[
name|FILE0
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|undotlines
argument_list|(
name|dotlines
argument_list|(
name|b
argument_list|,
name|mapping
index|[
name|FILE2
index|]
argument_list|)
argument_list|,
name|D_LOWLINE
argument_list|(
name|b
argument_list|,
name|mapping
index|[
name|FILE0
index|]
argument_list|)
argument_list|,
name|D_NUMLINES
argument_list|(
name|b
argument_list|,
name|mapping
index|[
name|FILE2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|finalwrite
condition|)
name|printf_output
argument_list|(
literal|"w\nq\n"
argument_list|)
expr_stmt|;
return|return
name|conflicts_found
return|;
block|}
end_block

begin_comment
comment|/*  * Read from INFILE and output to the standard output file a set of  * diff3_ blocks DIFF as a merged file.  This acts like 'ed file0  *<[output_diff3_edscript]', except that it works even for binary  * data or incomplete lines.  *  * As before, MAPPING maps from arg list file number to diff file number,  * REV_MAPPING is its inverse,  * and FILE0, FILE1, and FILE2 are the names of the files.  *  * Returns 1 if conflicts were found.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|output_diff3_merge
argument_list|(
name|infile
argument_list|,
name|diff
argument_list|,
name|mapping
argument_list|,
name|rev_mapping
argument_list|,
name|file0
argument_list|,
name|file1
argument_list|,
name|file2
argument_list|)
name|FILE
modifier|*
name|infile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|diff3_block
modifier|*
name|diff
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
specifier|const
name|mapping
index|[
literal|3
index|]
decl_stmt|,
name|rev_mapping
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
specifier|const
modifier|*
name|file0
decl_stmt|,
modifier|*
name|file1
decl_stmt|,
modifier|*
name|file2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
name|char
name|cc
decl_stmt|;
name|int
name|conflicts_found
init|=
literal|0
decl_stmt|,
name|conflict
decl_stmt|;
name|struct
name|diff3_block
modifier|*
name|b
decl_stmt|;
name|int
name|linesread
init|=
literal|0
decl_stmt|;
for|for
control|(
name|b
operator|=
name|diff
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|next
control|)
block|{
comment|/* Must do mapping correctly.  */
name|enum
name|diff_type
name|type
init|=
operator|(
operator|(
name|b
operator|->
name|correspond
operator|==
name|DIFF_ALL
operator|)
condition|?
name|DIFF_ALL
else|:
operator|(
operator|(
expr|enum
name|diff_type
operator|)
operator|(
operator|(
operator|(
name|int
operator|)
name|DIFF_1ST
operator|)
operator|+
name|rev_mapping
index|[
operator|(
name|int
operator|)
name|b
operator|->
name|correspond
operator|-
operator|(
name|int
operator|)
name|DIFF_1ST
index|]
operator|)
operator|)
operator|)
decl_stmt|;
name|char
specifier|const
modifier|*
name|format_2nd
init|=
literal|"<<<<<<< %s\n"
decl_stmt|;
comment|/* If we aren't supposed to do this output block, skip it.  */
switch|switch
condition|(
name|type
condition|)
block|{
default|default:
continue|continue;
case|case
name|DIFF_2ND
case|:
if|if
condition|(
operator|!
name|show_2nd
condition|)
continue|continue;
name|conflict
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DIFF_3RD
case|:
if|if
condition|(
name|overlap_only
condition|)
continue|continue;
name|conflict
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DIFF_ALL
case|:
if|if
condition|(
name|simple_only
condition|)
continue|continue;
name|conflict
operator|=
name|flagging
expr_stmt|;
name|format_2nd
operator|=
literal|"||||||| %s\n"
expr_stmt|;
break|break;
block|}
comment|/* Copy I lines from file 0.  */
name|i
operator|=
name|D_LOWLINE
argument_list|(
name|b
argument_list|,
name|FILE0
argument_list|)
operator|-
name|linesread
operator|-
literal|1
expr_stmt|;
name|linesread
operator|+=
name|i
expr_stmt|;
while|while
condition|(
literal|0
operator|<=
operator|--
name|i
condition|)
do|do
block|{
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
if|if
condition|(
name|ferror
argument_list|(
name|infile
argument_list|)
condition|)
name|diff3_perror_with_exit
argument_list|(
literal|"input file"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|feof
argument_list|(
name|infile
argument_list|)
condition|)
name|diff3_fatal
argument_list|(
literal|"input file shrank"
argument_list|)
expr_stmt|;
name|cc
operator|=
name|c
expr_stmt|;
name|write_output
argument_list|(
operator|&
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
do|;
if|if
condition|(
name|conflict
condition|)
block|{
name|conflicts_found
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|DIFF_ALL
condition|)
block|{
comment|/* Put in lines from FILE0 with bracket.  */
name|printf_output
argument_list|(
literal|"<<<<<<< %s\n"
argument_list|,
name|file0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|D_NUMLINES
argument_list|(
name|b
argument_list|,
name|mapping
index|[
name|FILE0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
name|write_output
argument_list|(
name|D_RELNUM
argument_list|(
name|b
argument_list|,
name|mapping
index|[
name|FILE0
index|]
argument_list|,
name|i
argument_list|)
argument_list|,
name|D_RELLEN
argument_list|(
name|b
argument_list|,
name|mapping
index|[
name|FILE0
index|]
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|show_2nd
condition|)
block|{
comment|/* Put in lines from FILE1 with bracket.  */
name|printf_output
argument_list|(
name|format_2nd
argument_list|,
name|file1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|D_NUMLINES
argument_list|(
name|b
argument_list|,
name|mapping
index|[
name|FILE1
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
name|write_output
argument_list|(
name|D_RELNUM
argument_list|(
name|b
argument_list|,
name|mapping
index|[
name|FILE1
index|]
argument_list|,
name|i
argument_list|)
argument_list|,
name|D_RELLEN
argument_list|(
name|b
argument_list|,
name|mapping
index|[
name|FILE1
index|]
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf_output
argument_list|(
literal|"=======\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Put in lines from FILE2.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|D_NUMLINES
argument_list|(
name|b
argument_list|,
name|mapping
index|[
name|FILE2
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
name|write_output
argument_list|(
name|D_RELNUM
argument_list|(
name|b
argument_list|,
name|mapping
index|[
name|FILE2
index|]
argument_list|,
name|i
argument_list|)
argument_list|,
name|D_RELLEN
argument_list|(
name|b
argument_list|,
name|mapping
index|[
name|FILE2
index|]
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|conflict
condition|)
name|printf_output
argument_list|(
literal|">>>>>>> %s\n"
argument_list|,
name|file2
argument_list|)
expr_stmt|;
comment|/* Skip I lines in file 0.  */
name|i
operator|=
name|D_NUMLINES
argument_list|(
name|b
argument_list|,
name|FILE0
argument_list|)
expr_stmt|;
name|linesread
operator|+=
name|i
expr_stmt|;
while|while
condition|(
literal|0
operator|<=
operator|--
name|i
condition|)
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
if|if
condition|(
name|ferror
argument_list|(
name|infile
argument_list|)
condition|)
name|diff3_perror_with_exit
argument_list|(
literal|"input file"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|feof
argument_list|(
name|infile
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|||
name|b
operator|->
name|next
condition|)
name|diff3_fatal
argument_list|(
literal|"input file shrank"
argument_list|)
expr_stmt|;
return|return
name|conflicts_found
return|;
block|}
block|}
comment|/* Copy rest of common file.  */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
operator|)
operator|!=
name|EOF
operator|||
operator|!
operator|(
name|ferror
argument_list|(
name|infile
argument_list|)
operator||
name|feof
argument_list|(
name|infile
argument_list|)
operator|)
condition|)
block|{
name|cc
operator|=
name|c
expr_stmt|;
name|write_output
argument_list|(
operator|&
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|conflicts_found
return|;
block|}
end_block

begin_comment
comment|/*  * Reverse the order of the list of diff3 blocks.  */
end_comment

begin_function
specifier|static
name|struct
name|diff3_block
modifier|*
name|reverse_diff3_blocklist
parameter_list|(
name|diff
parameter_list|)
name|struct
name|diff3_block
modifier|*
name|diff
decl_stmt|;
block|{
specifier|register
name|struct
name|diff3_block
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
for|for
control|(
name|tmp
operator|=
name|diff
operator|,
name|prev
operator|=
literal|0
init|;
name|tmp
condition|;
name|tmp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|tmp
operator|->
name|next
expr_stmt|;
name|tmp
operator|->
name|next
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|tmp
expr_stmt|;
block|}
return|return
name|prev
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|size_t
name|myread
parameter_list|(
name|fd
parameter_list|,
name|ptr
parameter_list|,
name|size
parameter_list|)
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
name|ssize_t
name|result
init|=
name|read
argument_list|(
name|fd
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
operator|-
literal|1
condition|)
name|diff3_perror_with_exit
argument_list|(
literal|"read failed"
argument_list|)
expr_stmt|;
return|return
operator|(
name|size_t
operator|)
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|diff3_fatal
parameter_list|(
name|string
parameter_list|)
name|char
specifier|const
modifier|*
name|string
decl_stmt|;
block|{
name|diff_error
argument_list|(
literal|"%s"
argument_list|,
name|string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DIFF3_ABORT
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|diff3_perror_with_exit
parameter_list|(
name|string
parameter_list|)
name|char
specifier|const
modifier|*
name|string
decl_stmt|;
block|{
name|perror_with_name
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|DIFF3_ABORT
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|initialize_main
parameter_list|(
name|argcp
parameter_list|,
name|argvp
parameter_list|)
name|int
modifier|*
name|argcp
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
name|always_text
operator|=
literal|0
expr_stmt|;
name|edscript
operator|=
literal|0
expr_stmt|;
name|flagging
operator|=
literal|0
expr_stmt|;
name|tab_align_flag
operator|=
literal|0
expr_stmt|;
name|simple_only
operator|=
literal|0
expr_stmt|;
name|overlap_only
operator|=
literal|0
expr_stmt|;
name|show_2nd
operator|=
literal|0
expr_stmt|;
name|finalwrite
operator|=
literal|0
expr_stmt|;
name|merge
operator|=
literal|0
expr_stmt|;
name|diff_program_name
operator|=
operator|(
operator|*
name|argvp
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|outfile
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_diff_blocks
parameter_list|(
name|p
parameter_list|)
name|struct
name|diff_block
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|struct
name|diff_block
modifier|*
name|next
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|lines
index|[
literal|0
index|]
condition|)
name|free
argument_list|(
name|p
operator|->
name|lines
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|lines
index|[
literal|1
index|]
condition|)
name|free
argument_list|(
name|p
operator|->
name|lines
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|lengths
index|[
literal|0
index|]
condition|)
name|free
argument_list|(
name|p
operator|->
name|lengths
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|lengths
index|[
literal|1
index|]
condition|)
name|free
argument_list|(
name|p
operator|->
name|lengths
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|free_diff3_blocks
parameter_list|(
name|p
parameter_list|)
name|struct
name|diff3_block
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|struct
name|diff3_block
modifier|*
name|next
decl_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|lines
index|[
literal|0
index|]
condition|)
name|free
argument_list|(
name|p
operator|->
name|lines
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|lines
index|[
literal|1
index|]
condition|)
name|free
argument_list|(
name|p
operator|->
name|lines
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|lines
index|[
literal|2
index|]
condition|)
name|free
argument_list|(
name|p
operator|->
name|lines
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|lengths
index|[
literal|0
index|]
condition|)
name|free
argument_list|(
name|p
operator|->
name|lengths
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|lengths
index|[
literal|1
index|]
condition|)
name|free
argument_list|(
name|p
operator|->
name|lengths
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|lengths
index|[
literal|2
index|]
condition|)
name|free
argument_list|(
name|p
operator|->
name|lengths
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

end_unit

