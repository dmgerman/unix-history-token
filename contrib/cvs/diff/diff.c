begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GNU DIFF entry routine.    Copyright (C) 1988, 1989, 1992, 1993, 1994, 1997, 1998 Free Software Foundation, Inc.  This file is part of GNU DIFF.  GNU DIFF is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU DIFF is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  */
end_comment

begin_comment
comment|/* GNU DIFF was written by Mike Haertel, David Hayes,    Richard Stallman, Len Tower, and Paul Eggert.  */
end_comment

begin_define
define|#
directive|define
name|GDIFF_MAIN
end_define

begin_include
include|#
directive|include
file|"diff.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|"fnmatch.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_WIDTH
end_ifndef

begin_define
define|#
directive|define
name|DEFAULT_WIDTH
value|130
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|GUTTER_WIDTH_MINIMUM
end_ifndef

begin_define
define|#
directive|define
name|GUTTER_WIDTH_MINIMUM
value|3
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* diff.c has a real initialize_main function. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|initialize_main
end_ifdef

begin_undef
undef|#
directive|undef
name|initialize_main
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|filetype
name|PARAMS
argument_list|(
operator|(
expr|struct
name|stat
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|option_list
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|add_exclude_file
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ck_atoi
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compare_files
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|char
specifier|const
operator|*
operator|,
name|char
specifier|const
operator|*
operator|,
name|char
specifier|const
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|specify_format
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_exclude
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_regexp
name|PARAMS
argument_list|(
operator|(
expr|struct
name|regexp_list
operator|*
operator|*
operator|,
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|specify_style
name|PARAMS
argument_list|(
operator|(
expr|enum
name|output_style
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|try_help
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_output
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|usage
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|initialize_main
name|PARAMS
argument_list|(
operator|(
name|int
operator|*
operator|,
name|char
operator|*
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for -r: if comparing two directories,    compare their common subdirectories recursively.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|recursive
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For debugging: don't do discard_confusing_lines.  */
end_comment

begin_decl_stmt
name|int
name|no_discards
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|HAVE_SETMODE
end_if

begin_comment
comment|/* I/O mode: nonzero only if using binary input/output.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|binary_I_O
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return a string containing the command options with which diff was invoked.    Spaces appear between what were separate ARGV-elements.    There is a space at the beginning but none at the end.    If there were no options, the result is an empty string.     Arguments: OPTIONVEC, a vector containing separate ARGV-elements, and COUNT,    the length of that vector.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|option_list
parameter_list|(
name|optionvec
parameter_list|,
name|count
parameter_list|)
name|char
modifier|*
modifier|*
name|optionvec
decl_stmt|;
comment|/* Was `vector', but that collides on Alliant.  */
name|int
name|count
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|size_t
name|length
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|length
operator|+=
name|strlen
argument_list|(
name|optionvec
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
name|result
operator|=
name|xmalloc
argument_list|(
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|result
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|strcat
argument_list|(
name|result
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|result
argument_list|,
name|optionvec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert STR to a positive integer, storing the result in *OUT.    If STR is not a valid integer, return -1 (otherwise 0). */
end_comment

begin_function
specifier|static
name|int
name|ck_atoi
parameter_list|(
name|str
parameter_list|,
name|out
parameter_list|)
name|char
specifier|const
modifier|*
name|str
decl_stmt|;
name|int
modifier|*
name|out
decl_stmt|;
block|{
name|char
specifier|const
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|str
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|<
literal|'0'
operator|||
operator|*
name|p
operator|>
literal|'9'
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|out
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Keep track of excluded file name patterns.  */
end_comment

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
modifier|*
name|exclude
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|exclude_alloc
decl_stmt|,
name|exclude_count
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|excluded_filename
parameter_list|(
name|f
parameter_list|)
name|char
specifier|const
modifier|*
name|f
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|exclude_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fnmatch
argument_list|(
name|exclude
index|[
name|i
index|]
argument_list|,
name|f
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_exclude
parameter_list|(
name|pattern
parameter_list|)
name|char
specifier|const
modifier|*
name|pattern
decl_stmt|;
block|{
if|if
condition|(
name|exclude_alloc
operator|<=
name|exclude_count
condition|)
name|exclude
operator|=
operator|(
name|char
specifier|const
operator|*
operator|*
operator|)
operator|(
name|exclude_alloc
operator|==
literal|0
condition|?
name|xmalloc
argument_list|(
operator|(
name|exclude_alloc
operator|=
literal|64
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|exclude
argument_list|)
argument_list|)
else|:
name|xrealloc
argument_list|(
name|exclude
argument_list|,
operator|(
name|exclude_alloc
operator|*=
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|exclude
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|exclude
index|[
name|exclude_count
operator|++
index|]
operator|=
name|pattern
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|add_exclude_file
parameter_list|(
name|name
parameter_list|)
name|char
specifier|const
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|file_data
name|f
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|lim
decl_stmt|;
name|f
operator|.
name|name
operator|=
name|optarg
expr_stmt|;
name|f
operator|.
name|desc
operator|=
operator|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|?
name|STDIN_FILENO
else|:
name|open
argument_list|(
name|optarg
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|f
operator|.
name|desc
operator|<
literal|0
operator|||
name|fstat
argument_list|(
name|f
operator|.
name|desc
argument_list|,
operator|&
name|f
operator|.
name|stat
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|sip
argument_list|(
operator|&
name|f
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|slurp
argument_list|(
operator|&
name|f
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|f
operator|.
name|buffer
operator|,
name|lim
operator|=
name|p
operator|+
name|f
operator|.
name|buffered_chars
init|;
name|p
operator|<
name|lim
condition|;
name|p
operator|=
name|q
control|)
block|{
name|q
operator|=
operator|(
name|char
operator|*
operator|)
name|memchr
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|,
name|lim
operator|-
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
condition|)
name|q
operator|=
name|lim
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|0
expr_stmt|;
name|add_exclude
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|close
argument_list|(
name|f
operator|.
name|desc
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The numbers 129- that appear in the fourth element of some entries    tell the big switch in `diff_run' how to process those options.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|option
specifier|const
name|longopts
index|[]
init|=
block|{
block|{
literal|"ignore-blank-lines"
block|,
literal|0
block|,
literal|0
block|,
literal|'B'
block|}
block|,
block|{
literal|"context"
block|,
literal|2
block|,
literal|0
block|,
literal|'C'
block|}
block|,
block|{
literal|"ifdef"
block|,
literal|1
block|,
literal|0
block|,
literal|'D'
block|}
block|,
block|{
literal|"show-function-line"
block|,
literal|1
block|,
literal|0
block|,
literal|'F'
block|}
block|,
block|{
literal|"speed-large-files"
block|,
literal|0
block|,
literal|0
block|,
literal|'H'
block|}
block|,
block|{
literal|"ignore-matching-lines"
block|,
literal|1
block|,
literal|0
block|,
literal|'I'
block|}
block|,
block|{
literal|"label"
block|,
literal|1
block|,
literal|0
block|,
literal|'L'
block|}
block|,
block|{
literal|"file-label"
block|,
literal|1
block|,
literal|0
block|,
literal|'L'
block|}
block|,
comment|/* An alias, no longer recommended */
block|{
literal|"new-file"
block|,
literal|0
block|,
literal|0
block|,
literal|'N'
block|}
block|,
block|{
literal|"entire-new-file"
block|,
literal|0
block|,
literal|0
block|,
literal|'N'
block|}
block|,
comment|/* An alias, no longer recommended */
block|{
literal|"unidirectional-new-file"
block|,
literal|0
block|,
literal|0
block|,
literal|'P'
block|}
block|,
block|{
literal|"starting-file"
block|,
literal|1
block|,
literal|0
block|,
literal|'S'
block|}
block|,
block|{
literal|"initial-tab"
block|,
literal|0
block|,
literal|0
block|,
literal|'T'
block|}
block|,
block|{
literal|"width"
block|,
literal|1
block|,
literal|0
block|,
literal|'W'
block|}
block|,
block|{
literal|"text"
block|,
literal|0
block|,
literal|0
block|,
literal|'a'
block|}
block|,
block|{
literal|"ascii"
block|,
literal|0
block|,
literal|0
block|,
literal|'a'
block|}
block|,
comment|/* An alias, no longer recommended */
block|{
literal|"ignore-space-change"
block|,
literal|0
block|,
literal|0
block|,
literal|'b'
block|}
block|,
block|{
literal|"minimal"
block|,
literal|0
block|,
literal|0
block|,
literal|'d'
block|}
block|,
block|{
literal|"ed"
block|,
literal|0
block|,
literal|0
block|,
literal|'e'
block|}
block|,
block|{
literal|"forward-ed"
block|,
literal|0
block|,
literal|0
block|,
literal|'f'
block|}
block|,
block|{
literal|"ignore-case"
block|,
literal|0
block|,
literal|0
block|,
literal|'i'
block|}
block|,
block|{
literal|"paginate"
block|,
literal|0
block|,
literal|0
block|,
literal|'l'
block|}
block|,
block|{
literal|"print"
block|,
literal|0
block|,
literal|0
block|,
literal|'l'
block|}
block|,
comment|/* An alias, no longer recommended */
block|{
literal|"rcs"
block|,
literal|0
block|,
literal|0
block|,
literal|'n'
block|}
block|,
block|{
literal|"show-c-function"
block|,
literal|0
block|,
literal|0
block|,
literal|'p'
block|}
block|,
block|{
literal|"brief"
block|,
literal|0
block|,
literal|0
block|,
literal|'q'
block|}
block|,
block|{
literal|"recursive"
block|,
literal|0
block|,
literal|0
block|,
literal|'r'
block|}
block|,
block|{
literal|"report-identical-files"
block|,
literal|0
block|,
literal|0
block|,
literal|'s'
block|}
block|,
block|{
literal|"expand-tabs"
block|,
literal|0
block|,
literal|0
block|,
literal|'t'
block|}
block|,
block|{
literal|"version"
block|,
literal|0
block|,
literal|0
block|,
literal|'v'
block|}
block|,
block|{
literal|"ignore-all-space"
block|,
literal|0
block|,
literal|0
block|,
literal|'w'
block|}
block|,
block|{
literal|"exclude"
block|,
literal|1
block|,
literal|0
block|,
literal|'x'
block|}
block|,
block|{
literal|"exclude-from"
block|,
literal|1
block|,
literal|0
block|,
literal|'X'
block|}
block|,
block|{
literal|"side-by-side"
block|,
literal|0
block|,
literal|0
block|,
literal|'y'
block|}
block|,
block|{
literal|"unified"
block|,
literal|2
block|,
literal|0
block|,
literal|'U'
block|}
block|,
block|{
literal|"left-column"
block|,
literal|0
block|,
literal|0
block|,
literal|129
block|}
block|,
block|{
literal|"suppress-common-lines"
block|,
literal|0
block|,
literal|0
block|,
literal|130
block|}
block|,
block|{
literal|"sdiff-merge-assist"
block|,
literal|0
block|,
literal|0
block|,
literal|131
block|}
block|,
block|{
literal|"old-line-format"
block|,
literal|1
block|,
literal|0
block|,
literal|132
block|}
block|,
block|{
literal|"new-line-format"
block|,
literal|1
block|,
literal|0
block|,
literal|133
block|}
block|,
block|{
literal|"unchanged-line-format"
block|,
literal|1
block|,
literal|0
block|,
literal|134
block|}
block|,
block|{
literal|"line-format"
block|,
literal|1
block|,
literal|0
block|,
literal|135
block|}
block|,
block|{
literal|"old-group-format"
block|,
literal|1
block|,
literal|0
block|,
literal|136
block|}
block|,
block|{
literal|"new-group-format"
block|,
literal|1
block|,
literal|0
block|,
literal|137
block|}
block|,
block|{
literal|"unchanged-group-format"
block|,
literal|1
block|,
literal|0
block|,
literal|138
block|}
block|,
block|{
literal|"changed-group-format"
block|,
literal|1
block|,
literal|0
block|,
literal|139
block|}
block|,
block|{
literal|"horizon-lines"
block|,
literal|1
block|,
literal|0
block|,
literal|140
block|}
block|,
block|{
literal|"help"
block|,
literal|0
block|,
literal|0
block|,
literal|141
block|}
block|,
block|{
literal|"binary"
block|,
literal|0
block|,
literal|0
block|,
literal|142
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|diff_run
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|out
parameter_list|,
name|callbacks_arg
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
name|char
modifier|*
name|out
decl_stmt|;
specifier|const
name|struct
name|diff_callbacks
modifier|*
name|callbacks_arg
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|prev
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|width
init|=
name|DEFAULT_WIDTH
decl_stmt|;
name|int
name|show_c_function
init|=
literal|0
decl_stmt|;
name|int
name|optind_old
decl_stmt|;
name|int
name|opened_file
init|=
literal|0
decl_stmt|;
name|callbacks
operator|=
name|callbacks_arg
expr_stmt|;
comment|/* Do our initializations.  */
name|initialize_main
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
name|optind_old
operator|=
name|optind
expr_stmt|;
name|optind
operator|=
literal|0
expr_stmt|;
comment|/* Set the jump buffer, so that diff may abort execution without      terminating the process. */
name|val
operator|=
name|setjmp
argument_list|(
name|diff_abort_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
block|{
name|optind
operator|=
name|optind_old
expr_stmt|;
if|if
condition|(
name|opened_file
condition|)
name|fclose
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
comment|/* Decode the options.  */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"0123456789abBcC:dD:efF:hHiI:lL:nNpPqrsS:tTuU:vwW:x:X:y"
argument_list|,
name|longopts
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
comment|/* All digits combine in decimal to specify the context-size.  */
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'0'
case|:
if|if
condition|(
name|context
operator|==
operator|-
literal|1
condition|)
name|context
operator|=
literal|0
expr_stmt|;
comment|/* If a context length has already been specified, 	     more digits allowed only if they follow right after the others. 	     Reject two separate runs of digits, or digits after -C.  */
elseif|else
if|if
condition|(
name|prev
operator|<
literal|'0'
operator|||
name|prev
operator|>
literal|'9'
condition|)
name|fatal
argument_list|(
literal|"context length specified twice"
argument_list|)
expr_stmt|;
name|context
operator|=
name|context
operator|*
literal|10
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* Treat all files as text files; never treat as binary.  */
name|always_text_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* Ignore changes in amount of white space.  */
name|ignore_space_change_flag
operator|=
literal|1
expr_stmt|;
name|ignore_some_changes
operator|=
literal|1
expr_stmt|;
name|ignore_some_line_changes
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* Ignore changes affecting only blank lines.  */
name|ignore_blank_lines_flag
operator|=
literal|1
expr_stmt|;
name|ignore_some_changes
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* +context[=lines] */
case|case
literal|'U'
case|:
comment|/* +unified[=lines] */
if|if
condition|(
name|optarg
condition|)
block|{
if|if
condition|(
name|context
operator|>=
literal|0
condition|)
name|fatal
argument_list|(
literal|"context length specified twice"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ck_atoi
argument_list|(
name|optarg
argument_list|,
operator|&
name|context
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"invalid context length argument"
argument_list|)
expr_stmt|;
block|}
comment|/* Falls through.  */
case|case
literal|'c'
case|:
comment|/* Make context-style output.  */
name|specify_style
argument_list|(
name|c
operator|==
literal|'U'
condition|?
name|OUTPUT_UNIFIED
else|:
name|OUTPUT_CONTEXT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* Don't discard lines.  This makes things slower (sometimes much 	     slower) but will find a guaranteed minimal set of changes.  */
name|no_discards
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* Make merged #ifdef output.  */
name|specify_style
argument_list|(
name|OUTPUT_IFDEF
argument_list|)
expr_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
specifier|static
name|char
specifier|const
name|C_ifdef_group_formats
index|[]
init|=
literal|"#ifndef %s\n%%<#endif /* not %s */\n%c#ifdef %s\n%%>#endif /* %s */\n%c%%=%c#ifndef %s\n%%<#else /* %s */\n%%>#endif /* %s */\n"
decl_stmt|;
name|char
modifier|*
name|b
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|C_ifdef_group_formats
argument_list|)
operator|+
literal|7
operator|*
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|-
literal|14
comment|/* 7*"%s" */
operator|-
literal|8
comment|/* 5*"%%" + 3*"%c" */
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|b
argument_list|,
name|C_ifdef_group_formats
argument_list|,
name|optarg
argument_list|,
name|optarg
argument_list|,
literal|0
argument_list|,
name|optarg
argument_list|,
name|optarg
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|optarg
argument_list|,
name|optarg
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|err
operator||=
name|specify_format
argument_list|(
operator|&
name|group_format
index|[
name|i
index|]
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|b
operator|+=
name|strlen
argument_list|(
name|b
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
name|diff_error
argument_list|(
literal|"conflicting #ifdef formats"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'e'
case|:
comment|/* Make output that is a valid `ed' script.  */
name|specify_style
argument_list|(
name|OUTPUT_ED
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* Make output that looks vaguely like an `ed' script 	     but has changes in the order they appear in the file.  */
name|specify_style
argument_list|(
name|OUTPUT_FORWARD_ED
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* Show, for each set of changes, the previous line that 	     matches the specified regexp.  Currently affects only 	     context-style output.  */
name|add_regexp
argument_list|(
operator|&
name|function_regexp_list
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* Split the files into chunks of around 1500 lines 	     for faster processing.  Usually does not change the result.  	     This currently has no effect.  */
break|break;
case|case
literal|'H'
case|:
comment|/* Turn on heuristics that speed processing of large files 	     with a small density of changes.  */
name|heuristic
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* Ignore changes in case.  */
name|ignore_case_flag
operator|=
literal|1
expr_stmt|;
name|ignore_some_changes
operator|=
literal|1
expr_stmt|;
name|ignore_some_line_changes
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* Ignore changes affecting only lines that match the 	     specified regexp.  */
name|add_regexp
argument_list|(
operator|&
name|ignore_regexp_list
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|ignore_some_changes
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* Pass the output through `pr' to paginate it.  */
name|paginate_flag
operator|=
literal|1
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SIGCHLD
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIGCLD
argument_list|)
define|#
directive|define
name|SIGCHLD
value|SIGCLD
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGCHLD
comment|/* Pagination requires forking and waiting, and 	     System V fork+wait does not work if SIGCHLD is ignored.  */
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'L'
case|:
comment|/* Specify file labels for `-c' output headers.  */
if|if
condition|(
operator|!
name|file_label
index|[
literal|0
index|]
condition|)
name|file_label
index|[
literal|0
index|]
operator|=
name|optarg
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|file_label
index|[
literal|1
index|]
condition|)
name|file_label
index|[
literal|1
index|]
operator|=
name|optarg
expr_stmt|;
else|else
name|fatal
argument_list|(
literal|"too many file label options"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* Output RCS-style diffs, like `-f' except that each command 	     specifies the number of lines affected.  */
name|specify_style
argument_list|(
name|OUTPUT_RCS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
comment|/* When comparing directories, if a file appears only in one 	     directory, treat it as present but empty in the other.  */
name|entire_new_file_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* Make context-style output and show name of last C function.  */
name|show_c_function
operator|=
literal|1
expr_stmt|;
name|add_regexp
argument_list|(
operator|&
name|function_regexp_list
argument_list|,
literal|"^[_a-zA-Z$]"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* When comparing directories, if a file appears only in 	     the second directory of the two, 	     treat it as present but empty in the other.  */
name|unidirectional_new_file_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|no_details_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* When comparing directories, 	     recursively compare any subdirectories found.  */
name|recursive
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* Print a message if the files are the same.  */
name|print_file_same_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* When comparing directories, start with the specified 	     file name.  This is used for resuming an aborted comparison.  */
name|dir_start_file
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* Expand tabs to spaces in the output so that it preserves 	     the alignment of the input files.  */
name|tab_expand_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
comment|/* Use a tab in the output, rather than a space, before the 	     text of an input line, so as to keep the proper alignment 	     in the input line without changing the characters in it.  */
name|tab_align_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* Output the context diff in unidiff format.  */
name|specify_style
argument_list|(
name|OUTPUT_UNIFIED
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
if|if
condition|(
name|callbacks
operator|&&
name|callbacks
operator|->
name|write_stdout
condition|)
block|{
call|(
modifier|*
name|callbacks
operator|->
name|write_stdout
call|)
argument_list|(
literal|"diff - GNU diffutils version "
argument_list|)
expr_stmt|;
call|(
modifier|*
name|callbacks
operator|->
name|write_stdout
call|)
argument_list|(
name|diff_version_string
argument_list|)
expr_stmt|;
call|(
modifier|*
name|callbacks
operator|->
name|write_stdout
call|)
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"diff - GNU diffutils version %s\n"
argument_list|,
name|diff_version_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|'w'
case|:
comment|/* Ignore horizontal white space when comparing lines.  */
name|ignore_all_space_flag
operator|=
literal|1
expr_stmt|;
name|ignore_some_changes
operator|=
literal|1
expr_stmt|;
name|ignore_some_line_changes
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|add_exclude
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
if|if
condition|(
name|add_exclude_file
argument_list|(
name|optarg
argument_list|)
operator|!=
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
comment|/* Use side-by-side (sdiff-style) columnar output. */
name|specify_style
argument_list|(
name|OUTPUT_SDIFF
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
comment|/* Set the line width for OUTPUT_SDIFF.  */
if|if
condition|(
name|ck_atoi
argument_list|(
name|optarg
argument_list|,
operator|&
name|width
argument_list|)
operator|||
name|width
operator|<=
literal|0
condition|)
name|fatal
argument_list|(
literal|"column width must be a positive integer"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|129
case|:
name|sdiff_left_only
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|130
case|:
name|sdiff_skip_common_lines
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|131
case|:
comment|/* sdiff-style columns output. */
name|specify_style
argument_list|(
name|OUTPUT_SDIFF
argument_list|)
expr_stmt|;
name|sdiff_help_sdiff
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|132
case|:
case|case
literal|133
case|:
case|case
literal|134
case|:
name|specify_style
argument_list|(
name|OUTPUT_IFDEF
argument_list|)
expr_stmt|;
if|if
condition|(
name|specify_format
argument_list|(
operator|&
name|line_format
index|[
name|c
operator|-
literal|132
index|]
argument_list|,
name|optarg
argument_list|)
operator|!=
literal|0
condition|)
name|diff_error
argument_list|(
literal|"conflicting line format"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|135
case|:
name|specify_style
argument_list|(
name|OUTPUT_IFDEF
argument_list|)
expr_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|line_format
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|line_format
argument_list|)
condition|;
name|i
operator|++
control|)
name|err
operator||=
name|specify_format
argument_list|(
operator|&
name|line_format
index|[
name|i
index|]
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|diff_error
argument_list|(
literal|"conflicting line format"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|136
case|:
case|case
literal|137
case|:
case|case
literal|138
case|:
case|case
literal|139
case|:
name|specify_style
argument_list|(
name|OUTPUT_IFDEF
argument_list|)
expr_stmt|;
if|if
condition|(
name|specify_format
argument_list|(
operator|&
name|group_format
index|[
name|c
operator|-
literal|136
index|]
argument_list|,
name|optarg
argument_list|)
operator|!=
literal|0
condition|)
name|diff_error
argument_list|(
literal|"conflicting group format"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|140
case|:
if|if
condition|(
name|ck_atoi
argument_list|(
name|optarg
argument_list|,
operator|&
name|horizon_lines
argument_list|)
operator|||
name|horizon_lines
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"horizon must be a nonnegative integer"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|141
case|:
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|callbacks
operator|||
operator|!
name|callbacks
operator|->
name|write_stdout
condition|)
name|check_output
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|142
case|:
comment|/* Use binary I/O when reading and writing data. 	     On Posix hosts, this has no effect.  */
if|#
directive|if
name|HAVE_SETMODE
name|binary_I_O
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Because this code is leftover from pre-library days, 	     there is no way to set stdout back to the default mode 	     when we are done.  As it turns out, I think the only 	     parts of CVS that pass out == NULL, and thus cause diff 	     to write to stdout, are "cvs diff" and "cvs rdiff".  So 	     I'm not going to worry about this too much yet.  */
block|setmode (STDOUT_FILENO, O_BINARY);
else|#
directive|else
if|if
condition|(
name|out
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: did not set stdout to binary mode"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
break|break;
default|default:
return|return
name|try_help
argument_list|(
literal|0
argument_list|)
return|;
block|}
name|prev
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|-
name|optind
operator|!=
literal|2
condition|)
return|return
name|try_help
argument_list|(
name|argc
operator|-
name|optind
operator|<
literal|2
condition|?
literal|"missing operand"
else|:
literal|"extra operand"
argument_list|)
return|;
block|{
comment|/*      *	We maximize first the half line width, and then the gutter width,      *	according to the following constraints:      *	1.  Two half lines plus a gutter must fit in a line.      *	2.  If the half line width is nonzero:      *	    a.  The gutter width is at least GUTTER_WIDTH_MINIMUM.      *	    b.  If tabs are not expanded to spaces,      *		a half line plus a gutter is an integral number of tabs,      *		so that tabs in the right column line up.      */
name|int
name|t
init|=
name|tab_expand_flag
condition|?
literal|1
else|:
name|TAB_WIDTH
decl_stmt|;
name|int
name|off
init|=
operator|(
name|width
operator|+
name|t
operator|+
name|GUTTER_WIDTH_MINIMUM
operator|)
operator|/
operator|(
literal|2
operator|*
name|t
operator|)
operator|*
name|t
decl_stmt|;
name|sdiff_half_width
operator|=
name|max
argument_list|(
literal|0
argument_list|,
name|min
argument_list|(
name|off
operator|-
name|GUTTER_WIDTH_MINIMUM
argument_list|,
name|width
operator|-
name|off
argument_list|)
argument_list|)
operator|,
name|sdiff_column2_offset
operator|=
name|sdiff_half_width
condition|?
name|off
else|:
name|width
expr_stmt|;
block|}
if|if
condition|(
name|show_c_function
operator|&&
name|output_style
operator|!=
name|OUTPUT_UNIFIED
condition|)
name|specify_style
argument_list|(
name|OUTPUT_CONTEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_style
operator|!=
name|OUTPUT_CONTEXT
operator|&&
name|output_style
operator|!=
name|OUTPUT_UNIFIED
condition|)
name|context
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|context
operator|==
operator|-
literal|1
condition|)
comment|/* Default amount of context for -c.  */
name|context
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|output_style
operator|==
name|OUTPUT_IFDEF
condition|)
block|{
comment|/* Format arrays are char *, not char const *, 	 because integer formats are temporarily modified. 	 But it is safe to assign a constant like "%=" to a format array, 	 since "%=" does not format any integers.  */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|line_format
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|line_format
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|line_format
index|[
name|i
index|]
condition|)
name|line_format
index|[
name|i
index|]
operator|=
literal|"%l\n"
expr_stmt|;
if|if
condition|(
operator|!
name|group_format
index|[
name|OLD
index|]
condition|)
name|group_format
index|[
name|OLD
index|]
operator|=
name|group_format
index|[
name|UNCHANGED
index|]
condition|?
name|group_format
index|[
name|UNCHANGED
index|]
else|:
literal|"%<"
expr_stmt|;
if|if
condition|(
operator|!
name|group_format
index|[
name|NEW
index|]
condition|)
name|group_format
index|[
name|NEW
index|]
operator|=
name|group_format
index|[
name|UNCHANGED
index|]
condition|?
name|group_format
index|[
name|UNCHANGED
index|]
else|:
literal|"%>"
expr_stmt|;
if|if
condition|(
operator|!
name|group_format
index|[
name|UNCHANGED
index|]
condition|)
name|group_format
index|[
name|UNCHANGED
index|]
operator|=
literal|"%="
expr_stmt|;
if|if
condition|(
operator|!
name|group_format
index|[
name|CHANGED
index|]
condition|)
name|group_format
index|[
name|CHANGED
index|]
operator|=
name|concat
argument_list|(
name|group_format
index|[
name|OLD
index|]
argument_list|,
name|group_format
index|[
name|NEW
index|]
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|no_diff_means_no_output
operator|=
operator|(
name|output_style
operator|==
name|OUTPUT_IFDEF
condition|?
operator|(
operator|!
operator|*
name|group_format
index|[
name|UNCHANGED
index|]
operator|||
operator|(
name|strcmp
argument_list|(
name|group_format
index|[
name|UNCHANGED
index|]
argument_list|,
literal|"%="
argument_list|)
operator|==
literal|0
operator|&&
operator|!
operator|*
name|line_format
index|[
name|UNCHANGED
index|]
operator|)
operator|)
else|:
name|output_style
operator|==
name|OUTPUT_SDIFF
condition|?
name|sdiff_skip_common_lines
else|:
literal|1
operator|)
expr_stmt|;
name|switch_string
operator|=
name|option_list
argument_list|(
name|argv
operator|+
literal|1
argument_list|,
name|optind
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|callbacks
operator|&&
name|callbacks
operator|->
name|write_output
condition|)
block|{
if|if
condition|(
name|out
operator|!=
name|NULL
condition|)
block|{
name|diff_error
argument_list|(
literal|"write callback with output file"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|out
operator|==
name|NULL
condition|)
name|outfile
operator|=
name|stdout
expr_stmt|;
else|else
block|{
if|#
directive|if
name|HAVE_SETMODE
comment|/* A diff which is full of ^Z and such isn't going to work 	     very well in text mode.  */
if|if
condition|(
name|binary_I_O
condition|)
name|outfile
operator|=
name|fopen
argument_list|(
name|out
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|outfile
operator|=
name|fopen
argument_list|(
name|out
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|outfile
operator|==
name|NULL
condition|)
block|{
name|perror_with_name
argument_list|(
literal|"could not open output file"
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
name|opened_file
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|val
operator|=
name|compare_files
argument_list|(
literal|0
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|,
literal|0
argument_list|,
name|argv
index|[
name|optind
operator|+
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Print any messages that were saved up for last.  */
name|print_message_queue
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|switch_string
argument_list|)
expr_stmt|;
name|optind
operator|=
name|optind_old
expr_stmt|;
if|if
condition|(
operator|!
name|callbacks
operator|||
operator|!
name|callbacks
operator|->
name|write_output
condition|)
name|check_output
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|opened_file
condition|)
if|if
condition|(
name|fclose
argument_list|(
name|outfile
argument_list|)
operator|!=
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"close error on output file"
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Add the compiled form of regexp PATTERN to REGLIST.  */
end_comment

begin_function
specifier|static
name|void
name|add_regexp
parameter_list|(
name|reglist
parameter_list|,
name|pattern
parameter_list|)
name|struct
name|regexp_list
modifier|*
modifier|*
name|reglist
decl_stmt|;
name|char
specifier|const
modifier|*
name|pattern
decl_stmt|;
block|{
name|struct
name|regexp_list
modifier|*
name|r
decl_stmt|;
name|char
specifier|const
modifier|*
name|m
decl_stmt|;
name|r
operator|=
operator|(
expr|struct
name|regexp_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|r
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|->
name|buf
operator|.
name|fastmap
operator|=
name|xmalloc
argument_list|(
literal|256
argument_list|)
expr_stmt|;
name|m
operator|=
name|re_compile_pattern
argument_list|(
name|pattern
argument_list|,
name|strlen
argument_list|(
name|pattern
argument_list|)
argument_list|,
operator|&
name|r
operator|->
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
literal|0
condition|)
name|diff_error
argument_list|(
literal|"%s: %s"
argument_list|,
name|pattern
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Add to the start of the list, since it's easier than the end.  */
name|r
operator|->
name|next
operator|=
operator|*
name|reglist
expr_stmt|;
operator|*
name|reglist
operator|=
name|r
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|try_help
parameter_list|(
name|reason
parameter_list|)
name|char
specifier|const
modifier|*
name|reason
decl_stmt|;
block|{
if|if
condition|(
name|reason
condition|)
name|diff_error
argument_list|(
literal|"%s"
argument_list|,
name|reason
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|diff_error
argument_list|(
literal|"Try `%s --help' for more information."
argument_list|,
name|diff_program_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_output
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
if|if
condition|(
name|ferror
argument_list|(
name|file
argument_list|)
operator|||
name|fflush
argument_list|(
name|file
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"write error"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
specifier|const
name|option_help
index|[]
init|=
block|{
literal|"-i  --ignore-case  Consider upper- and lower-case to be the same."
block|,
literal|"-w  --ignore-all-space  Ignore all white space."
block|,
literal|"-b  --ignore-space-change  Ignore changes in the amount of white space."
block|,
literal|"-B  --ignore-blank-lines  Ignore changes whose lines are all blank."
block|,
literal|"-I RE  --ignore-matching-lines=RE  Ignore changes whose lines all match RE."
block|,
if|#
directive|if
name|HAVE_SETMODE
literal|"--binary  Read and write data in binary mode."
block|,
endif|#
directive|endif
literal|"-a  --text  Treat all files as text.\n"
block|,
literal|"-c  -C NUM  --context[=NUM]  Output NUM (default 2) lines of copied context."
block|,
literal|"-u  -U NUM  --unified[=NUM]  Output NUM (default 2) lines of unified context."
block|,
literal|"  -NUM  Use NUM context lines."
block|,
literal|"  -L LABEL  --label LABEL  Use LABEL instead of file name."
block|,
literal|"  -p  --show-c-function  Show which C function each change is in."
block|,
literal|"  -F RE  --show-function-line=RE  Show the most recent line matching RE."
block|,
literal|"-q  --brief  Output only whether files differ."
block|,
literal|"-e  --ed  Output an ed script."
block|,
literal|"-n  --rcs  Output an RCS format diff."
block|,
literal|"-y  --side-by-side  Output in two columns."
block|,
literal|"  -w NUM  --width=NUM  Output at most NUM (default 130) characters per line."
block|,
literal|"  --left-column  Output only the left column of common lines."
block|,
literal|"  --suppress-common-lines  Do not output common lines."
block|,
literal|"-DNAME  --ifdef=NAME  Output merged file to show `#ifdef NAME' diffs."
block|,
literal|"--GTYPE-group-format=GFMT  Similar, but format GTYPE input groups with GFMT."
block|,
literal|"--line-format=LFMT  Similar, but format all input lines with LFMT."
block|,
literal|"--LTYPE-line-format=LFMT  Similar, but format LTYPE input lines with LFMT."
block|,
literal|"  LTYPE is `old', `new', or `unchanged'.  GTYPE is LTYPE or `changed'."
block|,
literal|"  GFMT may contain:"
block|,
literal|"    %<  lines from FILE1"
block|,
literal|"    %>  lines from FILE2"
block|,
literal|"    %=  lines common to FILE1 and FILE2"
block|,
literal|"    %[-][WIDTH][.[PREC]]{doxX}LETTER  printf-style spec for LETTER"
block|,
literal|"      LETTERs are as follows for new group, lower case for old group:"
block|,
literal|"        F  first line number"
block|,
literal|"        L  last line number"
block|,
literal|"        N  number of lines = L-F+1"
block|,
literal|"        E  F-1"
block|,
literal|"        M  L+1"
block|,
literal|"  LFMT may contain:"
block|,
literal|"    %L  contents of line"
block|,
literal|"    %l  contents of line, excluding any trailing newline"
block|,
literal|"    %[-][WIDTH][.[PREC]]{doxX}n  printf-style spec for input line number"
block|,
literal|"  Either GFMT or LFMT may contain:"
block|,
literal|"    %%  %"
block|,
literal|"    %c'C'  the single character C"
block|,
literal|"    %c'\\OOO'  the character with octal code OOO\n"
block|,
literal|"-l  --paginate  Pass the output through `pr' to paginate it."
block|,
literal|"-t  --expand-tabs  Expand tabs to spaces in output."
block|,
literal|"-T  --initial-tab  Make tabs line up by prepending a tab.\n"
block|,
literal|"-r  --recursive  Recursively compare any subdirectories found."
block|,
literal|"-N  --new-file  Treat absent files as empty."
block|,
literal|"-P  --unidirectional-new-file  Treat absent first files as empty."
block|,
literal|"-s  --report-identical-files  Report when two files are the same."
block|,
literal|"-x PAT  --exclude=PAT  Exclude files that match PAT."
block|,
literal|"-X FILE  --exclude-from=FILE  Exclude files that match any pattern in FILE."
block|,
literal|"-S FILE  --starting-file=FILE  Start with FILE when comparing directories.\n"
block|,
literal|"--horizon-lines=NUM  Keep NUM lines of the common prefix and suffix."
block|,
literal|"-d  --minimal  Try hard to find a smaller set of changes."
block|,
literal|"-H  --speed-large-files  Assume large files and many scattered small changes.\n"
block|,
literal|"-v  --version  Output version info."
block|,
literal|"--help  Output this help."
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|callbacks
operator|&&
name|callbacks
operator|->
name|write_stdout
condition|)
block|{
call|(
modifier|*
name|callbacks
operator|->
name|write_stdout
call|)
argument_list|(
literal|"Usage: "
argument_list|)
expr_stmt|;
call|(
modifier|*
name|callbacks
operator|->
name|write_stdout
call|)
argument_list|(
name|diff_program_name
argument_list|)
expr_stmt|;
call|(
modifier|*
name|callbacks
operator|->
name|write_stdout
call|)
argument_list|(
literal|" [OPTION]... FILE1 FILE2\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|option_help
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
call|(
modifier|*
name|callbacks
operator|->
name|write_stdout
call|)
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
call|(
modifier|*
name|callbacks
operator|->
name|write_stdout
call|)
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
call|(
modifier|*
name|callbacks
operator|->
name|write_stdout
call|)
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|callbacks
operator|->
name|write_stdout
call|)
argument_list|(
literal|"\nIf FILE1 or FILE2 is `-', read standard input.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Usage: %s [OPTION]... FILE1 FILE2\n\n"
argument_list|,
name|diff_program_name
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|option_help
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
name|printf
argument_list|(
literal|"  %s\n"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nIf FILE1 or FILE2 is `-', read standard input.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|specify_format
parameter_list|(
name|var
parameter_list|,
name|value
parameter_list|)
name|char
modifier|*
modifier|*
name|var
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
block|{
name|int
name|err
init|=
operator|*
name|var
condition|?
name|strcmp
argument_list|(
operator|*
name|var
argument_list|,
name|value
argument_list|)
else|:
literal|0
decl_stmt|;
operator|*
name|var
operator|=
name|value
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|specify_style
parameter_list|(
name|style
parameter_list|)
name|enum
name|output_style
name|style
decl_stmt|;
block|{
if|if
condition|(
name|output_style
operator|!=
name|OUTPUT_NORMAL
operator|&&
name|output_style
operator|!=
name|style
condition|)
name|diff_error
argument_list|(
literal|"conflicting specifications of output style"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|output_style
operator|=
name|style
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|char
specifier|const
modifier|*
name|filetype
parameter_list|(
name|st
parameter_list|)
name|struct
name|stat
specifier|const
modifier|*
name|st
decl_stmt|;
block|{
comment|/* See Posix.2 section 4.17.6.1.1 and Table 5-1 for these formats.      To keep diagnostics grammatical, the returned string must start      with a consonant.  */
if|if
condition|(
name|S_ISREG
argument_list|(
name|st
operator|->
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|st
operator|->
name|st_size
operator|==
literal|0
condition|)
return|return
literal|"regular empty file"
return|;
comment|/* Posix.2 section 5.14.2 seems to suggest that we must read the file 	 and guess whether it's C, Fortran, etc., but this is somewhat useless 	 and doesn't reflect historical practice.  We're allowed to guess 	 wrong, so we don't bother to read the file.  */
return|return
literal|"regular file"
return|;
block|}
if|if
condition|(
name|S_ISDIR
argument_list|(
name|st
operator|->
name|st_mode
argument_list|)
condition|)
return|return
literal|"directory"
return|;
comment|/* other Posix.1 file types */
ifdef|#
directive|ifdef
name|S_ISBLK
if|if
condition|(
name|S_ISBLK
argument_list|(
name|st
operator|->
name|st_mode
argument_list|)
condition|)
return|return
literal|"block special file"
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_ISCHR
if|if
condition|(
name|S_ISCHR
argument_list|(
name|st
operator|->
name|st_mode
argument_list|)
condition|)
return|return
literal|"character special file"
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_ISFIFO
if|if
condition|(
name|S_ISFIFO
argument_list|(
name|st
operator|->
name|st_mode
argument_list|)
condition|)
return|return
literal|"fifo"
return|;
endif|#
directive|endif
comment|/* other Posix.1b file types */
ifdef|#
directive|ifdef
name|S_TYPEISMQ
if|if
condition|(
name|S_TYPEISMQ
argument_list|(
name|st
argument_list|)
condition|)
return|return
literal|"message queue"
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_TYPEISSEM
if|if
condition|(
name|S_TYPEISSEM
argument_list|(
name|st
argument_list|)
condition|)
return|return
literal|"semaphore"
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_TYPEISSHM
if|if
condition|(
name|S_TYPEISSHM
argument_list|(
name|st
argument_list|)
condition|)
return|return
literal|"shared memory object"
return|;
endif|#
directive|endif
comment|/* other popular file types */
comment|/* S_ISLNK is impossible with `fstat' and `stat'.  */
ifdef|#
directive|ifdef
name|S_ISSOCK
if|if
condition|(
name|S_ISSOCK
argument_list|(
name|st
operator|->
name|st_mode
argument_list|)
condition|)
return|return
literal|"socket"
return|;
endif|#
directive|endif
return|return
literal|"weird file"
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compare two files (or dirs) with specified names    DIR0/NAME0 and DIR1/NAME1, at level DEPTH in directory recursion.    (if DIR0 is 0, then the name is just NAME0, etc.)    This is self-contained; it opens the files and closes them.     Value is 0 if files are the same, 1 if different,    2 if there is a problem opening them.  */
end_comment

begin_function
specifier|static
name|int
name|compare_files
parameter_list|(
name|dir0
parameter_list|,
name|name0
parameter_list|,
name|dir1
parameter_list|,
name|name1
parameter_list|,
name|depth
parameter_list|)
name|char
specifier|const
modifier|*
name|dir0
decl_stmt|,
decl|*
name|dir1
decl_stmt|;
end_function

begin_decl_stmt
name|char
specifier|const
modifier|*
name|name0
decl_stmt|,
modifier|*
name|name1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|depth
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|file_data
name|inf
index|[
literal|2
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|val
decl_stmt|;
name|int
name|same_files
decl_stmt|;
name|int
name|failed
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|free0
init|=
literal|0
decl_stmt|,
modifier|*
name|free1
init|=
literal|0
decl_stmt|;
comment|/* If this is directory comparison, perhaps we have a file      that exists only in one of the directories.      If so, just print a message to that effect.  */
if|if
condition|(
operator|!
operator|(
operator|(
name|name0
operator|!=
literal|0
operator|&&
name|name1
operator|!=
literal|0
operator|)
operator|||
operator|(
name|unidirectional_new_file_flag
operator|&&
name|name1
operator|!=
literal|0
operator|)
operator|||
name|entire_new_file_flag
operator|)
condition|)
block|{
name|char
specifier|const
modifier|*
name|name
init|=
name|name0
operator|==
literal|0
condition|?
name|name1
else|:
name|name0
decl_stmt|;
name|char
specifier|const
modifier|*
name|dir
init|=
name|name0
operator|==
literal|0
condition|?
name|dir1
else|:
name|dir0
decl_stmt|;
name|message
argument_list|(
literal|"Only in %s: %s\n"
argument_list|,
name|dir
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Return 1 so that diff_dirs will return 1 ("some files differ").  */
return|return
literal|1
return|;
block|}
name|bzero
argument_list|(
name|inf
argument_list|,
sizeof|sizeof
argument_list|(
name|inf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mark any nonexistent file with -1 in the desc field.  */
comment|/* Mark unopened files (e.g. directories) with -2. */
name|inf
index|[
literal|0
index|]
operator|.
name|desc
operator|=
name|name0
operator|==
literal|0
condition|?
operator|-
literal|1
else|:
operator|-
literal|2
expr_stmt|;
name|inf
index|[
literal|1
index|]
operator|.
name|desc
operator|=
name|name1
operator|==
literal|0
condition|?
operator|-
literal|1
else|:
operator|-
literal|2
expr_stmt|;
comment|/* Now record the full name of each file, including nonexistent ones.  */
if|if
condition|(
name|name0
operator|==
literal|0
condition|)
name|name0
operator|=
name|name1
expr_stmt|;
if|if
condition|(
name|name1
operator|==
literal|0
condition|)
name|name1
operator|=
name|name0
expr_stmt|;
name|inf
index|[
literal|0
index|]
operator|.
name|name
operator|=
name|dir0
operator|==
literal|0
condition|?
name|name0
else|:
operator|(
name|free0
operator|=
name|dir_file_pathname
argument_list|(
name|dir0
argument_list|,
name|name0
argument_list|)
operator|)
expr_stmt|;
name|inf
index|[
literal|1
index|]
operator|.
name|name
operator|=
name|dir1
operator|==
literal|0
condition|?
name|name1
else|:
operator|(
name|free1
operator|=
name|dir_file_pathname
argument_list|(
name|dir1
argument_list|,
name|name1
argument_list|)
operator|)
expr_stmt|;
comment|/* Stat the files.  Record whether they are directories.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|inf
index|[
name|i
index|]
operator|.
name|desc
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|stat_result
decl_stmt|;
if|if
condition|(
name|i
operator|&&
name|filename_cmp
argument_list|(
name|inf
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|inf
index|[
literal|0
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|inf
index|[
name|i
index|]
operator|.
name|stat
operator|=
name|inf
index|[
literal|0
index|]
operator|.
name|stat
expr_stmt|;
name|stat_result
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|inf
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|inf
index|[
name|i
index|]
operator|.
name|desc
operator|=
name|STDIN_FILENO
expr_stmt|;
name|stat_result
operator|=
name|fstat
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|&
name|inf
index|[
name|i
index|]
operator|.
name|stat
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat_result
operator|==
literal|0
operator|&&
name|S_ISREG
argument_list|(
name|inf
index|[
name|i
index|]
operator|.
name|stat
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|off_t
name|pos
init|=
name|lseek
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|==
operator|-
literal|1
condition|)
name|stat_result
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|pos
operator|<=
name|inf
index|[
name|i
index|]
operator|.
name|stat
operator|.
name|st_size
condition|)
name|inf
index|[
name|i
index|]
operator|.
name|stat
operator|.
name|st_size
operator|-=
name|pos
expr_stmt|;
else|else
name|inf
index|[
name|i
index|]
operator|.
name|stat
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
comment|/* Posix.2 4.17.6.1.4 requires current time for stdin.  */
name|time
argument_list|(
operator|&
name|inf
index|[
name|i
index|]
operator|.
name|stat
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|stat_result
operator|=
name|stat
argument_list|(
name|inf
index|[
name|i
index|]
operator|.
name|name
argument_list|,
operator|&
name|inf
index|[
name|i
index|]
operator|.
name|stat
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat_result
operator|!=
literal|0
condition|)
block|{
name|perror_with_name
argument_list|(
name|inf
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|failed
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|inf
index|[
name|i
index|]
operator|.
name|dir_p
operator|=
name|S_ISDIR
argument_list|(
name|inf
index|[
name|i
index|]
operator|.
name|stat
operator|.
name|st_mode
argument_list|)
operator|&&
name|inf
index|[
name|i
index|]
operator|.
name|desc
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|inf
index|[
literal|1
operator|-
name|i
index|]
operator|.
name|desc
operator|==
operator|-
literal|1
condition|)
block|{
name|inf
index|[
literal|1
operator|-
name|i
index|]
operator|.
name|dir_p
operator|=
name|inf
index|[
name|i
index|]
operator|.
name|dir_p
expr_stmt|;
name|inf
index|[
literal|1
operator|-
name|i
index|]
operator|.
name|stat
operator|.
name|st_mode
operator|=
name|inf
index|[
name|i
index|]
operator|.
name|stat
operator|.
name|st_mode
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|failed
operator|&&
name|depth
operator|==
literal|0
operator|&&
name|inf
index|[
literal|0
index|]
operator|.
name|dir_p
operator|!=
name|inf
index|[
literal|1
index|]
operator|.
name|dir_p
condition|)
block|{
comment|/* If one is a directory, and it was specified in the command line, 	 use the file in that dir with the other file's basename.  */
name|int
name|fnm_arg
init|=
name|inf
index|[
literal|0
index|]
operator|.
name|dir_p
decl_stmt|;
name|int
name|dir_arg
init|=
literal|1
operator|-
name|fnm_arg
decl_stmt|;
name|char
specifier|const
modifier|*
name|fnm
init|=
name|inf
index|[
name|fnm_arg
index|]
operator|.
name|name
decl_stmt|;
name|char
specifier|const
modifier|*
name|dir
init|=
name|inf
index|[
name|dir_arg
index|]
operator|.
name|name
decl_stmt|;
name|char
specifier|const
modifier|*
name|p
init|=
name|filename_lastdirchar
argument_list|(
name|fnm
argument_list|)
decl_stmt|;
name|char
specifier|const
modifier|*
name|filename
init|=
name|inf
index|[
name|dir_arg
index|]
operator|.
name|name
operator|=
name|dir_file_pathname
argument_list|(
name|dir
argument_list|,
name|p
condition|?
name|p
operator|+
literal|1
else|:
name|fnm
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|fnm
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"can't compare - to a directory"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|inf
index|[
name|dir_arg
index|]
operator|.
name|stat
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|failed
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|inf
index|[
name|dir_arg
index|]
operator|.
name|dir_p
operator|=
name|S_ISDIR
argument_list|(
name|inf
index|[
name|dir_arg
index|]
operator|.
name|stat
operator|.
name|st_mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|failed
condition|)
block|{
comment|/* If either file should exist but does not, return 2.  */
name|val
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|same_files
operator|=
name|inf
index|[
literal|0
index|]
operator|.
name|desc
operator|!=
operator|-
literal|1
operator|&&
name|inf
index|[
literal|1
index|]
operator|.
name|desc
operator|!=
operator|-
literal|1
operator|&&
literal|0
operator|<
name|same_file
argument_list|(
operator|&
name|inf
index|[
literal|0
index|]
operator|.
name|stat
argument_list|,
operator|&
name|inf
index|[
literal|1
index|]
operator|.
name|stat
argument_list|)
operator|)
operator|&&
name|no_diff_means_no_output
condition|)
block|{
comment|/* The two named files are actually the same physical file. 	 We know they are identical without actually reading them.  */
name|val
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inf
index|[
literal|0
index|]
operator|.
name|dir_p
operator|&
name|inf
index|[
literal|1
index|]
operator|.
name|dir_p
condition|)
block|{
if|if
condition|(
name|output_style
operator|==
name|OUTPUT_IFDEF
condition|)
name|fatal
argument_list|(
literal|"-D option not supported with directories"
argument_list|)
expr_stmt|;
comment|/* If both are directories, compare the files in them.  */
if|if
condition|(
name|depth
operator|>
literal|0
operator|&&
operator|!
name|recursive
condition|)
block|{
comment|/* But don't compare dir contents one level down 	     unless -r was specified.  */
name|message
argument_list|(
literal|"Common subdirectories: %s and %s\n"
argument_list|,
name|inf
index|[
literal|0
index|]
operator|.
name|name
argument_list|,
name|inf
index|[
literal|1
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|diff_dirs
argument_list|(
name|inf
argument_list|,
name|compare_files
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|inf
index|[
literal|0
index|]
operator|.
name|dir_p
operator||
name|inf
index|[
literal|1
index|]
operator|.
name|dir_p
operator|)
operator|||
operator|(
name|depth
operator|>
literal|0
operator|&&
operator|(
operator|!
name|S_ISREG
argument_list|(
name|inf
index|[
literal|0
index|]
operator|.
name|stat
operator|.
name|st_mode
argument_list|)
operator|||
operator|!
name|S_ISREG
argument_list|(
name|inf
index|[
literal|1
index|]
operator|.
name|stat
operator|.
name|st_mode
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* Perhaps we have a subdirectory that exists only in one directory. 	 If so, just print a message to that effect.  */
if|if
condition|(
name|inf
index|[
literal|0
index|]
operator|.
name|desc
operator|==
operator|-
literal|1
operator|||
name|inf
index|[
literal|1
index|]
operator|.
name|desc
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|inf
index|[
literal|0
index|]
operator|.
name|dir_p
operator||
name|inf
index|[
literal|1
index|]
operator|.
name|dir_p
operator|)
operator|&&
name|recursive
operator|&&
operator|(
name|entire_new_file_flag
operator|||
operator|(
name|unidirectional_new_file_flag
operator|&&
name|inf
index|[
literal|0
index|]
operator|.
name|desc
operator|==
operator|-
literal|1
operator|)
operator|)
condition|)
name|val
operator|=
name|diff_dirs
argument_list|(
name|inf
argument_list|,
name|compare_files
argument_list|,
name|depth
argument_list|)
expr_stmt|;
else|else
block|{
name|char
specifier|const
modifier|*
name|dir
init|=
operator|(
name|inf
index|[
literal|0
index|]
operator|.
name|desc
operator|==
operator|-
literal|1
operator|)
condition|?
name|dir1
else|:
name|dir0
decl_stmt|;
comment|/* See Posix.2 section 4.17.6.1.1 for this format.  */
name|message
argument_list|(
literal|"Only in %s: %s\n"
argument_list|,
name|dir
argument_list|,
name|name0
argument_list|)
expr_stmt|;
name|val
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We have two files that are not to be compared.  */
comment|/* See Posix.2 section 4.17.6.1.1 for this format.  */
name|message5
argument_list|(
literal|"File %s is a %s while file %s is a %s\n"
argument_list|,
name|inf
index|[
literal|0
index|]
operator|.
name|name
argument_list|,
name|filetype
argument_list|(
operator|&
name|inf
index|[
literal|0
index|]
operator|.
name|stat
argument_list|)
argument_list|,
name|inf
index|[
literal|1
index|]
operator|.
name|name
argument_list|,
name|filetype
argument_list|(
operator|&
name|inf
index|[
literal|1
index|]
operator|.
name|stat
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This is a difference.  */
name|val
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|no_details_flag
operator|&
operator|~
name|ignore_some_changes
operator|)
operator|&&
name|inf
index|[
literal|0
index|]
operator|.
name|stat
operator|.
name|st_size
operator|!=
name|inf
index|[
literal|1
index|]
operator|.
name|stat
operator|.
name|st_size
operator|&&
operator|(
name|inf
index|[
literal|0
index|]
operator|.
name|desc
operator|==
operator|-
literal|1
operator|||
name|S_ISREG
argument_list|(
name|inf
index|[
literal|0
index|]
operator|.
name|stat
operator|.
name|st_mode
argument_list|)
operator|)
operator|&&
operator|(
name|inf
index|[
literal|1
index|]
operator|.
name|desc
operator|==
operator|-
literal|1
operator|||
name|S_ISREG
argument_list|(
name|inf
index|[
literal|1
index|]
operator|.
name|stat
operator|.
name|st_mode
argument_list|)
operator|)
condition|)
block|{
name|message
argument_list|(
literal|"Files %s and %s differ\n"
argument_list|,
name|inf
index|[
literal|0
index|]
operator|.
name|name
argument_list|,
name|inf
index|[
literal|1
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|val
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Both exist and neither is a directory.  */
comment|/* Open the files and record their descriptors.  */
if|if
condition|(
name|inf
index|[
literal|0
index|]
operator|.
name|desc
operator|==
operator|-
literal|2
condition|)
if|if
condition|(
operator|(
name|inf
index|[
literal|0
index|]
operator|.
name|desc
operator|=
name|open
argument_list|(
name|inf
index|[
literal|0
index|]
operator|.
name|name
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror_with_name
argument_list|(
name|inf
index|[
literal|0
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|failed
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|inf
index|[
literal|1
index|]
operator|.
name|desc
operator|==
operator|-
literal|2
condition|)
block|{
if|if
condition|(
name|same_files
condition|)
name|inf
index|[
literal|1
index|]
operator|.
name|desc
operator|=
name|inf
index|[
literal|0
index|]
operator|.
name|desc
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|inf
index|[
literal|1
index|]
operator|.
name|desc
operator|=
name|open
argument_list|(
name|inf
index|[
literal|1
index|]
operator|.
name|name
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror_with_name
argument_list|(
name|inf
index|[
literal|1
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|failed
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|#
directive|if
name|HAVE_SETMODE
if|if
condition|(
name|binary_I_O
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
literal|0
operator|<=
name|inf
index|[
name|i
index|]
operator|.
name|desc
condition|)
name|setmode
argument_list|(
name|inf
index|[
name|i
index|]
operator|.
name|desc
argument_list|,
name|O_BINARY
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Compare the files, if no error was found.  */
name|val
operator|=
name|failed
condition|?
literal|2
else|:
name|diff_2_files
argument_list|(
name|inf
argument_list|,
name|depth
argument_list|)
expr_stmt|;
comment|/* Close the file descriptors.  */
if|if
condition|(
name|inf
index|[
literal|0
index|]
operator|.
name|desc
operator|>=
literal|0
operator|&&
name|close
argument_list|(
name|inf
index|[
literal|0
index|]
operator|.
name|desc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|perror_with_name
argument_list|(
name|inf
index|[
literal|0
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|val
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|inf
index|[
literal|1
index|]
operator|.
name|desc
operator|>=
literal|0
operator|&&
name|inf
index|[
literal|0
index|]
operator|.
name|desc
operator|!=
name|inf
index|[
literal|1
index|]
operator|.
name|desc
operator|&&
name|close
argument_list|(
name|inf
index|[
literal|1
index|]
operator|.
name|desc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|perror_with_name
argument_list|(
name|inf
index|[
literal|1
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|val
operator|=
literal|2
expr_stmt|;
block|}
block|}
comment|/* Now the comparison has been done, if no error prevented it,      and VAL is the value this function will return.  */
if|if
condition|(
name|val
operator|==
literal|0
operator|&&
operator|!
name|inf
index|[
literal|0
index|]
operator|.
name|dir_p
condition|)
block|{
if|if
condition|(
name|print_file_same_flag
condition|)
name|message
argument_list|(
literal|"Files %s and %s are identical\n"
argument_list|,
name|inf
index|[
literal|0
index|]
operator|.
name|name
argument_list|,
name|inf
index|[
literal|1
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|flush_output
argument_list|()
expr_stmt|;
if|if
condition|(
name|free0
condition|)
name|free
argument_list|(
name|free0
argument_list|)
expr_stmt|;
if|if
condition|(
name|free1
condition|)
name|free
argument_list|(
name|free1
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_comment
comment|/* Initialize status variables and flag variables used in libdiff,    to permit repeated calls to diff_run. */
end_comment

begin_function
specifier|static
name|void
name|initialize_main
parameter_list|(
name|argcp
parameter_list|,
name|argvp
parameter_list|)
name|int
modifier|*
name|argcp
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
comment|/* These variables really must be reset each time diff_run is called. */
name|output_style
operator|=
name|OUTPUT_NORMAL
expr_stmt|;
name|context
operator|=
operator|-
literal|1
expr_stmt|;
name|file_label
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|file_label
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|diff_program_name
operator|=
operator|(
operator|*
name|argvp
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|outfile
operator|=
name|NULL
expr_stmt|;
comment|/* Reset these also, just for safety's sake. (If one invocation turns      on ignore_case_flag, it must be turned off before diff_run is called      again.  But it is possible to make many diffs before encountering      such a problem. */
name|recursive
operator|=
literal|0
expr_stmt|;
name|no_discards
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|HAVE_SETMODE
name|binary_I_O
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|no_diff_means_no_output
operator|=
literal|0
expr_stmt|;
name|always_text_flag
operator|=
literal|0
expr_stmt|;
name|horizon_lines
operator|=
literal|0
expr_stmt|;
name|ignore_space_change_flag
operator|=
literal|0
expr_stmt|;
name|ignore_all_space_flag
operator|=
literal|0
expr_stmt|;
name|ignore_blank_lines_flag
operator|=
literal|0
expr_stmt|;
name|ignore_some_line_changes
operator|=
literal|0
expr_stmt|;
name|ignore_some_changes
operator|=
literal|0
expr_stmt|;
name|ignore_case_flag
operator|=
literal|0
expr_stmt|;
name|function_regexp_list
operator|=
name|NULL
expr_stmt|;
name|ignore_regexp_list
operator|=
name|NULL
expr_stmt|;
name|no_details_flag
operator|=
literal|0
expr_stmt|;
name|print_file_same_flag
operator|=
literal|0
expr_stmt|;
name|tab_align_flag
operator|=
literal|0
expr_stmt|;
name|tab_expand_flag
operator|=
literal|0
expr_stmt|;
name|dir_start_file
operator|=
name|NULL
expr_stmt|;
name|entire_new_file_flag
operator|=
literal|0
expr_stmt|;
name|unidirectional_new_file_flag
operator|=
literal|0
expr_stmt|;
name|paginate_flag
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|group_format
argument_list|,
sizeof|sizeof
argument_list|(
name|group_format
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|line_format
argument_list|,
sizeof|sizeof
argument_list|(
name|line_format
argument_list|)
argument_list|)
expr_stmt|;
name|sdiff_help_sdiff
operator|=
literal|0
expr_stmt|;
name|sdiff_left_only
operator|=
literal|0
expr_stmt|;
name|sdiff_skip_common_lines
operator|=
literal|0
expr_stmt|;
name|sdiff_half_width
operator|=
literal|0
expr_stmt|;
name|sdiff_column2_offset
operator|=
literal|0
expr_stmt|;
name|switch_string
operator|=
name|NULL
expr_stmt|;
name|heuristic
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|files
argument_list|,
sizeof|sizeof
argument_list|(
name|files
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

