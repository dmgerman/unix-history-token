begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Output routines for ed-script format.    Copyright (C) 1988, 89, 91, 92, 93, 1998 Free Software Foundation, Inc.  This file is part of GNU DIFF.  GNU DIFF is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU DIFF is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU DIFF; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"diff.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|print_ed_hunk
name|PARAMS
argument_list|(
operator|(
expr|struct
name|change
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_rcs_hunk
name|PARAMS
argument_list|(
operator|(
expr|struct
name|change
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pr_forward_ed_hunk
name|PARAMS
argument_list|(
operator|(
expr|struct
name|change
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Print our script as ed commands.  */
end_comment

begin_function
name|void
name|print_ed_script
parameter_list|(
name|script
parameter_list|)
name|struct
name|change
modifier|*
name|script
decl_stmt|;
block|{
name|print_script
argument_list|(
name|script
argument_list|,
name|find_reverse_change
argument_list|,
name|print_ed_hunk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a hunk of an ed diff */
end_comment

begin_function
specifier|static
name|void
name|print_ed_hunk
parameter_list|(
name|hunk
parameter_list|)
name|struct
name|change
modifier|*
name|hunk
decl_stmt|;
block|{
name|int
name|f0
decl_stmt|,
name|l0
decl_stmt|,
name|f1
decl_stmt|,
name|l1
decl_stmt|;
name|int
name|deletes
decl_stmt|,
name|inserts
decl_stmt|;
if|#
directive|if
literal|0
block|hunk = flip_script (hunk);
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
name|debug_script
argument_list|(
name|hunk
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Determine range of line numbers involved in each file.  */
name|analyze_hunk
argument_list|(
name|hunk
argument_list|,
operator|&
name|f0
argument_list|,
operator|&
name|l0
argument_list|,
operator|&
name|f1
argument_list|,
operator|&
name|l1
argument_list|,
operator|&
name|deletes
argument_list|,
operator|&
name|inserts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|deletes
operator|&&
operator|!
name|inserts
condition|)
return|return;
name|begin_output
argument_list|()
expr_stmt|;
comment|/* Print out the line number header for this hunk */
name|print_number_range
argument_list|(
literal|','
argument_list|,
operator|&
name|files
index|[
literal|0
index|]
argument_list|,
name|f0
argument_list|,
name|l0
argument_list|)
expr_stmt|;
name|printf_output
argument_list|(
literal|"%c\n"
argument_list|,
name|change_letter
argument_list|(
name|inserts
argument_list|,
name|deletes
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Print new/changed lines from second file, if needed */
if|if
condition|(
name|inserts
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|inserting
init|=
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
name|f1
init|;
name|i
operator|<=
name|l1
condition|;
name|i
operator|++
control|)
block|{
comment|/* Resume the insert, if we stopped.  */
if|if
condition|(
operator|!
name|inserting
condition|)
name|printf_output
argument_list|(
literal|"%da\n"
argument_list|,
name|i
operator|-
name|f1
operator|+
name|translate_line_number
argument_list|(
operator|&
name|files
index|[
literal|0
index|]
argument_list|,
name|f0
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|inserting
operator|=
literal|1
expr_stmt|;
comment|/* If the file's line is just a dot, it would confuse `ed'. 	     So output it with a double dot, and set the flag LEADING_DOT 	     so that we will output another ed-command later 	     to change the double dot into a single dot.  */
if|if
condition|(
name|files
index|[
literal|1
index|]
operator|.
name|linbuf
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|files
index|[
literal|1
index|]
operator|.
name|linbuf
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|printf_output
argument_list|(
literal|"..\n"
argument_list|)
expr_stmt|;
name|printf_output
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
comment|/* Now change that double dot to the desired single dot.  */
name|printf_output
argument_list|(
literal|"%ds/^\\.\\././\n"
argument_list|,
name|i
operator|-
name|f1
operator|+
name|translate_line_number
argument_list|(
operator|&
name|files
index|[
literal|0
index|]
argument_list|,
name|f0
argument_list|)
argument_list|)
expr_stmt|;
name|inserting
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* Line is not `.', so output it unmodified.  */
name|print_1_line
argument_list|(
literal|""
argument_list|,
operator|&
name|files
index|[
literal|1
index|]
operator|.
name|linbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* End insert mode, if we are still in it.  */
if|if
condition|(
name|inserting
condition|)
name|printf_output
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print change script in the style of ed commands,    but print the changes in the order they appear in the input files,    which means that the commands are not truly useful with ed.  */
end_comment

begin_function
name|void
name|pr_forward_ed_script
parameter_list|(
name|script
parameter_list|)
name|struct
name|change
modifier|*
name|script
decl_stmt|;
block|{
name|print_script
argument_list|(
name|script
argument_list|,
name|find_change
argument_list|,
name|pr_forward_ed_hunk
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pr_forward_ed_hunk
parameter_list|(
name|hunk
parameter_list|)
name|struct
name|change
modifier|*
name|hunk
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|f0
decl_stmt|,
name|l0
decl_stmt|,
name|f1
decl_stmt|,
name|l1
decl_stmt|;
name|int
name|deletes
decl_stmt|,
name|inserts
decl_stmt|;
comment|/* Determine range of line numbers involved in each file.  */
name|analyze_hunk
argument_list|(
name|hunk
argument_list|,
operator|&
name|f0
argument_list|,
operator|&
name|l0
argument_list|,
operator|&
name|f1
argument_list|,
operator|&
name|l1
argument_list|,
operator|&
name|deletes
argument_list|,
operator|&
name|inserts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|deletes
operator|&&
operator|!
name|inserts
condition|)
return|return;
name|begin_output
argument_list|()
expr_stmt|;
name|printf_output
argument_list|(
literal|"%c"
argument_list|,
name|change_letter
argument_list|(
name|inserts
argument_list|,
name|deletes
argument_list|)
argument_list|)
expr_stmt|;
name|print_number_range
argument_list|(
literal|' '
argument_list|,
name|files
argument_list|,
name|f0
argument_list|,
name|l0
argument_list|)
expr_stmt|;
name|printf_output
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* If deletion only, print just the number range.  */
if|if
condition|(
operator|!
name|inserts
condition|)
return|return;
comment|/* For insertion (with or without deletion), print the number range      and the lines from file 2.  */
for|for
control|(
name|i
operator|=
name|f1
init|;
name|i
operator|<=
name|l1
condition|;
name|i
operator|++
control|)
name|print_1_line
argument_list|(
literal|""
argument_list|,
operator|&
name|files
index|[
literal|1
index|]
operator|.
name|linbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf_output
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print in a format somewhat like ed commands    except that each insert command states the number of lines it inserts.    This format is used for RCS.  */
end_comment

begin_function
name|void
name|print_rcs_script
parameter_list|(
name|script
parameter_list|)
name|struct
name|change
modifier|*
name|script
decl_stmt|;
block|{
name|print_script
argument_list|(
name|script
argument_list|,
name|find_change
argument_list|,
name|print_rcs_hunk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a hunk of an RCS diff */
end_comment

begin_function
specifier|static
name|void
name|print_rcs_hunk
parameter_list|(
name|hunk
parameter_list|)
name|struct
name|change
modifier|*
name|hunk
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|f0
decl_stmt|,
name|l0
decl_stmt|,
name|f1
decl_stmt|,
name|l1
decl_stmt|;
name|int
name|deletes
decl_stmt|,
name|inserts
decl_stmt|;
name|int
name|tf0
decl_stmt|,
name|tl0
decl_stmt|,
name|tf1
decl_stmt|,
name|tl1
decl_stmt|;
comment|/* Determine range of line numbers involved in each file.  */
name|analyze_hunk
argument_list|(
name|hunk
argument_list|,
operator|&
name|f0
argument_list|,
operator|&
name|l0
argument_list|,
operator|&
name|f1
argument_list|,
operator|&
name|l1
argument_list|,
operator|&
name|deletes
argument_list|,
operator|&
name|inserts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|deletes
operator|&&
operator|!
name|inserts
condition|)
return|return;
name|begin_output
argument_list|()
expr_stmt|;
name|translate_range
argument_list|(
operator|&
name|files
index|[
literal|0
index|]
argument_list|,
name|f0
argument_list|,
name|l0
argument_list|,
operator|&
name|tf0
argument_list|,
operator|&
name|tl0
argument_list|)
expr_stmt|;
if|if
condition|(
name|deletes
condition|)
block|{
name|printf_output
argument_list|(
literal|"d"
argument_list|)
expr_stmt|;
comment|/* For deletion, print just the starting line number from file 0 	 and the number of lines deleted.  */
name|printf_output
argument_list|(
literal|"%d %d\n"
argument_list|,
name|tf0
argument_list|,
operator|(
name|tl0
operator|>=
name|tf0
condition|?
name|tl0
operator|-
name|tf0
operator|+
literal|1
else|:
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inserts
condition|)
block|{
name|printf_output
argument_list|(
literal|"a"
argument_list|)
expr_stmt|;
comment|/* Take last-line-number from file 0 and # lines from file 1.  */
name|translate_range
argument_list|(
operator|&
name|files
index|[
literal|1
index|]
argument_list|,
name|f1
argument_list|,
name|l1
argument_list|,
operator|&
name|tf1
argument_list|,
operator|&
name|tl1
argument_list|)
expr_stmt|;
name|printf_output
argument_list|(
literal|"%d %d\n"
argument_list|,
name|tl0
argument_list|,
operator|(
name|tl1
operator|>=
name|tf1
condition|?
name|tl1
operator|-
name|tf1
operator|+
literal|1
else|:
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* Print the inserted lines.  */
for|for
control|(
name|i
operator|=
name|f1
init|;
name|i
operator|<=
name|l1
condition|;
name|i
operator|++
control|)
name|print_1_line
argument_list|(
literal|""
argument_list|,
operator|&
name|files
index|[
literal|1
index|]
operator|.
name|linbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

