begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Read, sort and compare two directories.  Used for GNU DIFF.    Copyright (C) 1988, 1989, 1992, 1993, 1994 Free Software Foundation, Inc.  This file is part of GNU DIFF.  GNU DIFF is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU DIFF is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU DIFF; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"diff.h"
end_include

begin_comment
comment|/* Read the directory named by DIR and store into DIRDATA a sorted vector    of filenames for its contents.  DIR->desc == -1 means this directory is    known to be nonexistent, so set DIRDATA to an empty vector.    Return -1 (setting errno) if error, 0 otherwise.  */
end_comment

begin_struct
struct|struct
name|dirdata
block|{
name|char
specifier|const
modifier|*
modifier|*
name|names
decl_stmt|;
comment|/* Sorted names of files in dir, 0-terminated.  */
name|char
modifier|*
name|data
decl_stmt|;
comment|/* Allocated storage for file names.  */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|compare_names
name|PARAMS
argument_list|(
operator|(
name|void
specifier|const
operator|*
operator|,
name|void
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dir_sort
name|PARAMS
argument_list|(
operator|(
expr|struct
name|file_data
specifier|const
operator|*
operator|,
expr|struct
name|dirdata
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_define
define|#
directive|define
name|CLOSEDIR_VOID
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|dir_sort
parameter_list|(
name|dir
parameter_list|,
name|dirdata
parameter_list|)
name|struct
name|file_data
specifier|const
modifier|*
name|dir
decl_stmt|;
name|struct
name|dirdata
modifier|*
name|dirdata
decl_stmt|;
block|{
specifier|register
name|struct
name|dirent
modifier|*
name|next
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Address of block containing the files that are described.  */
name|char
specifier|const
modifier|*
modifier|*
name|names
decl_stmt|;
comment|/* Number of files in directory.  */
name|size_t
name|nnames
decl_stmt|;
comment|/* Allocated and used storage for file name data.  */
name|char
modifier|*
name|data
decl_stmt|;
name|size_t
name|data_alloc
decl_stmt|,
name|data_used
decl_stmt|;
name|dirdata
operator|->
name|names
operator|=
literal|0
expr_stmt|;
name|dirdata
operator|->
name|data
operator|=
literal|0
expr_stmt|;
name|nnames
operator|=
literal|0
expr_stmt|;
name|data
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dir
operator|->
name|desc
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* Open the directory and check for errors.  */
specifier|register
name|DIR
modifier|*
name|reading
init|=
name|opendir
argument_list|(
name|dir
operator|->
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|reading
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Initialize the table of filenames.  */
name|data_alloc
operator|=
name|max
argument_list|(
literal|1
argument_list|,
operator|(
name|size_t
operator|)
name|dir
operator|->
name|stat
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|data_used
operator|=
literal|0
expr_stmt|;
name|dirdata
operator|->
name|data
operator|=
name|data
operator|=
name|xmalloc
argument_list|(
name|data_alloc
argument_list|)
expr_stmt|;
comment|/* Read the directory entries, and insert the subfiles 	 into the `data' table.  */
while|while
condition|(
operator|(
name|errno
operator|=
literal|0
operator|,
operator|(
name|next
operator|=
name|readdir
argument_list|(
name|reading
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|char
modifier|*
name|d_name
init|=
name|next
operator|->
name|d_name
decl_stmt|;
name|size_t
name|d_size
init|=
name|NAMLEN
argument_list|(
name|next
argument_list|)
operator|+
literal|1
decl_stmt|;
comment|/* Ignore the files `.' and `..' */
if|if
condition|(
name|d_name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|d_name
index|[
literal|1
index|]
operator|==
literal|0
operator|||
operator|(
name|d_name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|d_name
index|[
literal|2
index|]
operator|==
literal|0
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|excluded_filename
argument_list|(
name|d_name
argument_list|)
condition|)
continue|continue;
while|while
condition|(
name|data_alloc
operator|<
name|data_used
operator|+
name|d_size
condition|)
name|dirdata
operator|->
name|data
operator|=
name|data
operator|=
name|xrealloc
argument_list|(
name|data
argument_list|,
name|data_alloc
operator|*=
literal|2
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|data
operator|+
name|data_used
argument_list|,
name|d_name
argument_list|,
name|d_size
argument_list|)
expr_stmt|;
name|data_used
operator|+=
name|d_size
expr_stmt|;
name|nnames
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|errno
condition|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|closedir
argument_list|(
name|reading
argument_list|)
expr_stmt|;
name|errno
operator|=
name|e
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|#
directive|if
name|CLOSEDIR_VOID
name|closedir
argument_list|(
name|reading
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|closedir
argument_list|(
name|reading
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
block|}
comment|/* Create the `names' table from the `data' table.  */
name|dirdata
operator|->
name|names
operator|=
name|names
operator|=
operator|(
name|char
specifier|const
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|nnames
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nnames
condition|;
name|i
operator|++
control|)
block|{
name|names
index|[
name|i
index|]
operator|=
name|data
expr_stmt|;
name|data
operator|+=
name|strlen
argument_list|(
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|names
index|[
name|nnames
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Sort the table.  */
name|qsort
argument_list|(
name|names
argument_list|,
name|nnames
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|compare_names
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Sort the files now in the table.  */
end_comment

begin_function
specifier|static
name|int
name|compare_names
parameter_list|(
name|file1
parameter_list|,
name|file2
parameter_list|)
name|void
specifier|const
modifier|*
name|file1
decl_stmt|,
decl|*
name|file2
decl_stmt|;
end_function

begin_block
block|{
return|return
name|filename_cmp
argument_list|(
operator|*
operator|(
name|char
specifier|const
operator|*
specifier|const
operator|*
operator|)
name|file1
argument_list|,
operator|*
operator|(
name|char
specifier|const
operator|*
specifier|const
operator|*
operator|)
name|file2
argument_list|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Compare the contents of two directories named in FILEVEC[0] and FILEVEC[1].    This is a top-level routine; it does everything necessary for diff    on two directories.     FILEVEC[0].desc == -1 says directory FILEVEC[0] doesn't exist,    but pretend it is empty.  Likewise for FILEVEC[1].     HANDLE_FILE is a caller-provided subroutine called to handle each file.    It gets five operands: dir and name (rel to original working dir) of file    in dir 0, dir and name pathname of file in dir 1, and the recursion depth.     For a file that appears in only one of the dirs, one of the name-args    to HANDLE_FILE is zero.     DEPTH is the current depth in recursion, used for skipping top-level    files by the -S option.     Returns the maximum of all the values returned by HANDLE_FILE,    or 2 if trouble is encountered in opening files.  */
end_comment

begin_function_decl
name|int
name|diff_dirs
parameter_list|(
name|filevec
parameter_list|,
name|handle_file
parameter_list|,
name|depth
parameter_list|)
name|struct
name|file_data
specifier|const
name|filevec
index|[]
decl_stmt|;
function_decl|int
parameter_list|(
function_decl|*handle_file
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|char
specifier|const
operator|*
operator|,
name|char
specifier|const
operator|*
operator|,
name|char
specifier|const
operator|*
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|depth
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|dirdata
name|dirdata
index|[
literal|2
index|]
decl_stmt|;
name|int
name|val
init|=
literal|0
decl_stmt|;
comment|/* Return value.  */
name|int
name|i
decl_stmt|;
comment|/* Get sorted contents of both dirs.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|dir_sort
argument_list|(
operator|&
name|filevec
index|[
name|i
index|]
argument_list|,
operator|&
name|dirdata
index|[
name|i
index|]
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|perror_with_name
argument_list|(
name|filevec
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|val
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
specifier|register
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|names0
init|=
name|dirdata
index|[
literal|0
index|]
operator|.
name|names
decl_stmt|;
specifier|register
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|names1
init|=
name|dirdata
index|[
literal|1
index|]
operator|.
name|names
decl_stmt|;
name|char
specifier|const
modifier|*
name|name0
init|=
name|filevec
index|[
literal|0
index|]
operator|.
name|name
decl_stmt|;
name|char
specifier|const
modifier|*
name|name1
init|=
name|filevec
index|[
literal|1
index|]
operator|.
name|name
decl_stmt|;
comment|/* If `-S name' was given, and this is the topmost level of comparison, 	 ignore all file names less than the specified starting name.  */
if|if
condition|(
name|dir_start_file
operator|&&
name|depth
operator|==
literal|0
condition|)
block|{
while|while
condition|(
operator|*
name|names0
operator|&&
name|filename_cmp
argument_list|(
operator|*
name|names0
argument_list|,
name|dir_start_file
argument_list|)
operator|<
literal|0
condition|)
name|names0
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|names1
operator|&&
name|filename_cmp
argument_list|(
operator|*
name|names1
argument_list|,
name|dir_start_file
argument_list|)
operator|<
literal|0
condition|)
name|names1
operator|++
expr_stmt|;
block|}
comment|/* Loop while files remain in one or both dirs.  */
while|while
condition|(
operator|*
name|names0
operator|||
operator|*
name|names1
condition|)
block|{
comment|/* Compare next name in dir 0 with next name in dir 1. 	     At the end of a dir, 	     pretend the "next name" in that dir is very large.  */
name|int
name|nameorder
init|=
operator|(
operator|!
operator|*
name|names0
condition|?
literal|1
else|:
operator|!
operator|*
name|names1
condition|?
operator|-
literal|1
else|:
name|filename_cmp
argument_list|(
operator|*
name|names0
argument_list|,
operator|*
name|names1
argument_list|)
operator|)
decl_stmt|;
name|int
name|v1
init|=
call|(
modifier|*
name|handle_file
call|)
argument_list|(
name|name0
argument_list|,
literal|0
operator|<
name|nameorder
condition|?
literal|0
else|:
operator|*
name|names0
operator|++
argument_list|,
name|name1
argument_list|,
name|nameorder
operator|<
literal|0
condition|?
literal|0
else|:
operator|*
name|names1
operator|++
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|v1
operator|>
name|val
condition|)
name|val
operator|=
name|v1
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dirdata
index|[
name|i
index|]
operator|.
name|names
condition|)
name|free
argument_list|(
name|dirdata
index|[
name|i
index|]
operator|.
name|names
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirdata
index|[
name|i
index|]
operator|.
name|data
condition|)
name|free
argument_list|(
name|dirdata
index|[
name|i
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_block

end_unit

