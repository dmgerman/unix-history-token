begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* sdiff-format output routines for GNU DIFF.    Copyright (C) 1991, 1992, 1993, 1998 Free Software Foundation, Inc.  This file is part of GNU DIFF.  GNU DIFF is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU DIFF General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU DIFF, but only under the conditions described in the GNU DIFF General Public License.   A copy of this license is supposed to have been given to you along with GNU DIFF so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_include
include|#
directive|include
file|"diff.h"
end_include

begin_decl_stmt
specifier|static
name|unsigned
name|print_half_line
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
specifier|const
operator|*
operator|,
name|unsigned
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|tab_from_to
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_1sdiff_line
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
specifier|const
operator|*
operator|,
name|int
operator|,
name|char
specifier|const
operator|*
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_sdiff_common_lines
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_sdiff_hunk
name|PARAMS
argument_list|(
operator|(
expr|struct
name|change
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Next line number to be printed in the two input files.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|next0
decl_stmt|,
name|next1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print the edit-script SCRIPT as a sdiff style output.  */
end_comment

begin_function
name|void
name|print_sdiff_script
parameter_list|(
name|script
parameter_list|)
name|struct
name|change
modifier|*
name|script
decl_stmt|;
block|{
name|begin_output
argument_list|()
expr_stmt|;
name|next0
operator|=
name|next1
operator|=
operator|-
name|files
index|[
literal|0
index|]
operator|.
name|prefix_lines
expr_stmt|;
name|print_script
argument_list|(
name|script
argument_list|,
name|find_change
argument_list|,
name|print_sdiff_hunk
argument_list|)
expr_stmt|;
name|print_sdiff_common_lines
argument_list|(
name|files
index|[
literal|0
index|]
operator|.
name|valid_lines
argument_list|,
name|files
index|[
literal|1
index|]
operator|.
name|valid_lines
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tab from column FROM to column TO, where FROM<= TO.  Yield TO.  */
end_comment

begin_function
specifier|static
name|unsigned
name|tab_from_to
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|unsigned
name|from
decl_stmt|,
name|to
decl_stmt|;
block|{
name|unsigned
name|tab
decl_stmt|;
if|if
condition|(
operator|!
name|tab_expand_flag
condition|)
for|for
control|(
name|tab
operator|=
name|from
operator|+
name|TAB_WIDTH
operator|-
name|from
operator|%
name|TAB_WIDTH
init|;
name|tab
operator|<=
name|to
condition|;
name|tab
operator|+=
name|TAB_WIDTH
control|)
block|{
name|write_output
argument_list|(
literal|"\t"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|from
operator|=
name|tab
expr_stmt|;
block|}
while|while
condition|(
name|from
operator|++
operator|<
name|to
condition|)
name|write_output
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|to
return|;
block|}
end_function

begin_comment
comment|/*  * Print the text for half an sdiff line.  This means truncate to width  * observing tabs, and trim a trailing newline.  Returns the last column  * written (not the number of chars).  */
end_comment

begin_function
specifier|static
name|unsigned
name|print_half_line
parameter_list|(
name|line
parameter_list|,
name|indent
parameter_list|,
name|out_bound
parameter_list|)
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|line
decl_stmt|;
name|unsigned
name|indent
decl_stmt|,
name|out_bound
decl_stmt|;
block|{
specifier|register
name|unsigned
name|in_position
init|=
literal|0
decl_stmt|,
name|out_position
init|=
literal|0
decl_stmt|;
specifier|register
name|char
specifier|const
modifier|*
name|text_pointer
init|=
name|line
index|[
literal|0
index|]
decl_stmt|,
modifier|*
name|text_limit
init|=
name|line
index|[
literal|1
index|]
decl_stmt|;
while|while
condition|(
name|text_pointer
operator|<
name|text_limit
condition|)
block|{
specifier|register
name|unsigned
name|char
name|c
init|=
operator|*
name|text_pointer
operator|++
decl_stmt|;
comment|/* We use CC to avoid taking the address of the register          variable C.  */
name|char
name|cc
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\t'
case|:
block|{
name|unsigned
name|spaces
init|=
name|TAB_WIDTH
operator|-
name|in_position
operator|%
name|TAB_WIDTH
decl_stmt|;
if|if
condition|(
name|in_position
operator|==
name|out_position
condition|)
block|{
name|unsigned
name|tabstop
init|=
name|out_position
operator|+
name|spaces
decl_stmt|;
if|if
condition|(
name|tab_expand_flag
condition|)
block|{
if|if
condition|(
name|out_bound
operator|<
name|tabstop
condition|)
name|tabstop
operator|=
name|out_bound
expr_stmt|;
for|for
control|(
init|;
name|out_position
operator|<
name|tabstop
condition|;
name|out_position
operator|++
control|)
name|write_output
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tabstop
operator|<
name|out_bound
condition|)
block|{
name|out_position
operator|=
name|tabstop
expr_stmt|;
name|cc
operator|=
name|c
expr_stmt|;
name|write_output
argument_list|(
operator|&
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|in_position
operator|+=
name|spaces
expr_stmt|;
block|}
break|break;
case|case
literal|'\r'
case|:
block|{
name|cc
operator|=
name|c
expr_stmt|;
name|write_output
argument_list|(
operator|&
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tab_from_to
argument_list|(
literal|0
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|in_position
operator|=
name|out_position
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|'\b'
case|:
if|if
condition|(
name|in_position
operator|!=
literal|0
operator|&&
operator|--
name|in_position
operator|<
name|out_bound
condition|)
if|if
condition|(
name|out_position
operator|<=
name|in_position
condition|)
comment|/* Add spaces to make up for suppressed tab past out_bound.  */
for|for
control|(
init|;
name|out_position
operator|<
name|in_position
condition|;
name|out_position
operator|++
control|)
name|write_output
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|out_position
operator|=
name|in_position
expr_stmt|;
name|cc
operator|=
name|c
expr_stmt|;
name|write_output
argument_list|(
operator|&
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'\f'
case|:
case|case
literal|'\v'
case|:
name|control_char
label|:
if|if
condition|(
name|in_position
operator|<
name|out_bound
condition|)
block|{
name|cc
operator|=
name|c
expr_stmt|;
name|write_output
argument_list|(
operator|&
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
operator|!
name|ISPRINT
argument_list|(
name|c
argument_list|)
condition|)
goto|goto
name|control_char
goto|;
comment|/* falls through */
case|case
literal|' '
case|:
if|if
condition|(
name|in_position
operator|++
operator|<
name|out_bound
condition|)
block|{
name|out_position
operator|=
name|in_position
expr_stmt|;
name|cc
operator|=
name|c
expr_stmt|;
name|write_output
argument_list|(
operator|&
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'\n'
case|:
return|return
name|out_position
return|;
block|}
block|}
return|return
name|out_position
return|;
block|}
end_function

begin_comment
comment|/*  * Print side by side lines with a separator in the middle.  * 0 parameters are taken to indicate white space text.  * Blank lines that can easily be caught are reduced to a single newline.  */
end_comment

begin_function
specifier|static
name|void
name|print_1sdiff_line
parameter_list|(
name|left
parameter_list|,
name|sep
parameter_list|,
name|right
parameter_list|)
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|left
decl_stmt|;
name|int
name|sep
decl_stmt|;
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|right
decl_stmt|;
block|{
name|unsigned
name|hw
init|=
name|sdiff_half_width
decl_stmt|,
name|c2o
init|=
name|sdiff_column2_offset
decl_stmt|;
name|unsigned
name|col
init|=
literal|0
decl_stmt|;
name|int
name|put_newline
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|left
condition|)
block|{
if|if
condition|(
name|left
index|[
literal|1
index|]
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|put_newline
operator|=
literal|1
expr_stmt|;
name|col
operator|=
name|print_half_line
argument_list|(
name|left
argument_list|,
literal|0
argument_list|,
name|hw
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sep
operator|!=
literal|' '
condition|)
block|{
name|char
name|cc
decl_stmt|;
name|col
operator|=
name|tab_from_to
argument_list|(
name|col
argument_list|,
operator|(
name|hw
operator|+
name|c2o
operator|-
literal|1
operator|)
operator|/
literal|2
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|sep
operator|==
literal|'|'
operator|&&
name|put_newline
operator|!=
operator|(
name|right
index|[
literal|1
index|]
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
condition|)
name|sep
operator|=
name|put_newline
condition|?
literal|'/'
else|:
literal|'\\'
expr_stmt|;
name|cc
operator|=
name|sep
expr_stmt|;
name|write_output
argument_list|(
operator|&
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|right
condition|)
block|{
if|if
condition|(
name|right
index|[
literal|1
index|]
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|put_newline
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|right
operator|!=
literal|'\n'
condition|)
block|{
name|col
operator|=
name|tab_from_to
argument_list|(
name|col
argument_list|,
name|c2o
argument_list|)
expr_stmt|;
name|print_half_line
argument_list|(
name|right
argument_list|,
name|col
argument_list|,
name|hw
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|put_newline
condition|)
name|write_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print lines common to both files in side-by-side format.  */
end_comment

begin_function
specifier|static
name|void
name|print_sdiff_common_lines
parameter_list|(
name|limit0
parameter_list|,
name|limit1
parameter_list|)
name|int
name|limit0
decl_stmt|,
name|limit1
decl_stmt|;
block|{
name|int
name|i0
init|=
name|next0
decl_stmt|,
name|i1
init|=
name|next1
decl_stmt|;
if|if
condition|(
operator|!
name|sdiff_skip_common_lines
operator|&&
operator|(
name|i0
operator|!=
name|limit0
operator|||
name|i1
operator|!=
name|limit1
operator|)
condition|)
block|{
if|if
condition|(
name|sdiff_help_sdiff
condition|)
name|printf_output
argument_list|(
literal|"i%d,%d\n"
argument_list|,
name|limit0
operator|-
name|i0
argument_list|,
name|limit1
operator|-
name|i1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sdiff_left_only
condition|)
block|{
while|while
condition|(
name|i0
operator|!=
name|limit0
operator|&&
name|i1
operator|!=
name|limit1
condition|)
name|print_1sdiff_line
argument_list|(
operator|&
name|files
index|[
literal|0
index|]
operator|.
name|linbuf
index|[
name|i0
operator|++
index|]
argument_list|,
literal|' '
argument_list|,
operator|&
name|files
index|[
literal|1
index|]
operator|.
name|linbuf
index|[
name|i1
operator|++
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|i1
operator|!=
name|limit1
condition|)
name|print_1sdiff_line
argument_list|(
literal|0
argument_list|,
literal|')'
argument_list|,
operator|&
name|files
index|[
literal|1
index|]
operator|.
name|linbuf
index|[
name|i1
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|i0
operator|!=
name|limit0
condition|)
name|print_1sdiff_line
argument_list|(
operator|&
name|files
index|[
literal|0
index|]
operator|.
name|linbuf
index|[
name|i0
operator|++
index|]
argument_list|,
literal|'('
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|next0
operator|=
name|limit0
expr_stmt|;
name|next1
operator|=
name|limit1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a hunk of an sdiff diff.    This is a contiguous portion of a complete edit script,    describing changes in consecutive lines.  */
end_comment

begin_function
specifier|static
name|void
name|print_sdiff_hunk
parameter_list|(
name|hunk
parameter_list|)
name|struct
name|change
modifier|*
name|hunk
decl_stmt|;
block|{
name|int
name|first0
decl_stmt|,
name|last0
decl_stmt|,
name|first1
decl_stmt|,
name|last1
decl_stmt|,
name|deletes
decl_stmt|,
name|inserts
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Determine range of line numbers involved in each file.  */
name|analyze_hunk
argument_list|(
name|hunk
argument_list|,
operator|&
name|first0
argument_list|,
operator|&
name|last0
argument_list|,
operator|&
name|first1
argument_list|,
operator|&
name|last1
argument_list|,
operator|&
name|deletes
argument_list|,
operator|&
name|inserts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|deletes
operator|&&
operator|!
name|inserts
condition|)
return|return;
comment|/* Print out lines up to this change.  */
name|print_sdiff_common_lines
argument_list|(
name|first0
argument_list|,
name|first1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdiff_help_sdiff
condition|)
name|printf_output
argument_list|(
literal|"c%d,%d\n"
argument_list|,
name|last0
operator|-
name|first0
operator|+
literal|1
argument_list|,
name|last1
operator|-
name|first1
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Print ``xxx  |  xxx '' lines */
if|if
condition|(
name|inserts
operator|&&
name|deletes
condition|)
block|{
for|for
control|(
name|i
operator|=
name|first0
operator|,
name|j
operator|=
name|first1
init|;
name|i
operator|<=
name|last0
operator|&&
name|j
operator|<=
name|last1
condition|;
operator|++
name|i
operator|,
operator|++
name|j
control|)
name|print_1sdiff_line
argument_list|(
operator|&
name|files
index|[
literal|0
index|]
operator|.
name|linbuf
index|[
name|i
index|]
argument_list|,
literal|'|'
argument_list|,
operator|&
name|files
index|[
literal|1
index|]
operator|.
name|linbuf
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|deletes
operator|=
name|i
operator|<=
name|last0
expr_stmt|;
name|inserts
operator|=
name|j
operator|<=
name|last1
expr_stmt|;
name|next0
operator|=
name|first0
operator|=
name|i
expr_stmt|;
name|next1
operator|=
name|first1
operator|=
name|j
expr_stmt|;
block|}
comment|/* Print ``>  xxx '' lines */
if|if
condition|(
name|inserts
condition|)
block|{
for|for
control|(
name|j
operator|=
name|first1
init|;
name|j
operator|<=
name|last1
condition|;
operator|++
name|j
control|)
name|print_1sdiff_line
argument_list|(
literal|0
argument_list|,
literal|'>'
argument_list|,
operator|&
name|files
index|[
literal|1
index|]
operator|.
name|linbuf
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|next1
operator|=
name|j
expr_stmt|;
block|}
comment|/* Print ``xxx<     '' lines */
if|if
condition|(
name|deletes
condition|)
block|{
for|for
control|(
name|i
operator|=
name|first0
init|;
name|i
operator|<=
name|last0
condition|;
operator|++
name|i
control|)
name|print_1sdiff_line
argument_list|(
operator|&
name|files
index|[
literal|0
index|]
operator|.
name|linbuf
index|[
name|i
index|]
argument_list|,
literal|'<'
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|next0
operator|=
name|i
expr_stmt|;
block|}
block|}
end_function

end_unit

