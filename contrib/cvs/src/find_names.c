begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  * Copyright (c) 1989-1992, Brian Berliner  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS 1.4 kit.  *   * Find Names  *   * Finds all the pertinent file names, both from the administration and from the  * repository  *   * Find Dirs  *   * Finds all pertinent sub-directories of the checked out instantiation and the  * repository (and optionally the attic)  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|find_dirs
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|dir
operator|,
name|List
operator|*
name|list
operator|,
name|int
name|checkadm
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_rcs
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|dir
operator|,
name|List
operator|*
name|list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|List
modifier|*
name|filelist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * add the key from entry on entries list to the files list  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|add_entries_proc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|add_entries_proc
parameter_list|(
name|node
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|node
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|Node
modifier|*
name|fnode
decl_stmt|;
name|fnode
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|fnode
operator|->
name|type
operator|=
name|FILES
expr_stmt|;
name|fnode
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|node
operator|->
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|addnode
argument_list|(
name|filelist
argument_list|,
name|fnode
argument_list|)
operator|!=
literal|0
condition|)
name|freenode
argument_list|(
name|fnode
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * compare two files list node (for sort)  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fsortcmp
name|PROTO
argument_list|(
operator|(
specifier|const
name|Node
operator|*
operator|,
specifier|const
name|Node
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|fsortcmp
parameter_list|(
name|p
parameter_list|,
name|q
parameter_list|)
specifier|const
name|Node
modifier|*
name|p
decl_stmt|;
specifier|const
name|Node
modifier|*
name|q
decl_stmt|;
block|{
return|return
operator|(
name|strcmp
argument_list|(
name|p
operator|->
name|key
argument_list|,
name|q
operator|->
name|key
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|List
modifier|*
name|Find_Names
parameter_list|(
name|repository
parameter_list|,
name|which
parameter_list|,
name|aflag
parameter_list|,
name|optentries
parameter_list|)
name|char
modifier|*
name|repository
decl_stmt|;
name|int
name|which
decl_stmt|;
name|int
name|aflag
decl_stmt|;
name|List
modifier|*
modifier|*
name|optentries
decl_stmt|;
block|{
name|List
modifier|*
name|entries
decl_stmt|;
name|List
modifier|*
name|files
decl_stmt|;
name|char
name|dir
index|[
name|PATH_MAX
index|]
decl_stmt|;
comment|/* make a list for the files */
name|files
operator|=
name|filelist
operator|=
name|getlist
argument_list|()
expr_stmt|;
comment|/* look at entries (if necessary) */
if|if
condition|(
name|which
operator|&
name|W_LOCAL
condition|)
block|{
comment|/* parse the entries file (if it exists) */
name|entries
operator|=
name|Entries_Open
argument_list|(
name|aflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|entries
operator|!=
name|NULL
condition|)
block|{
comment|/* walk the entries file adding elements to the files list */
operator|(
name|void
operator|)
name|walklist
argument_list|(
name|entries
argument_list|,
name|add_entries_proc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* if our caller wanted the entries list, return it; else free it */
if|if
condition|(
name|optentries
operator|!=
name|NULL
condition|)
operator|*
name|optentries
operator|=
name|entries
expr_stmt|;
else|else
name|Entries_Close
argument_list|(
name|entries
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|which
operator|&
name|W_REPOS
operator|)
operator|&&
name|repository
operator|&&
operator|!
name|isreadable
argument_list|(
name|CVSADM_ENTSTAT
argument_list|)
condition|)
block|{
comment|/* search the repository */
if|if
condition|(
name|find_rcs
argument_list|(
name|repository
argument_list|,
name|files
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot open directory %s"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
comment|/* search the attic too */
if|if
condition|(
name|which
operator|&
name|W_ATTIC
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dir
argument_list|,
literal|"%s/%s"
argument_list|,
name|repository
argument_list|,
name|CVSATTIC
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|find_rcs
argument_list|(
name|dir
argument_list|,
name|files
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* sort the list into alphabetical order and return it */
name|sortlist
argument_list|(
name|files
argument_list|,
name|fsortcmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|files
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * create a list of directories to traverse from the current directory  */
end_comment

begin_function
name|List
modifier|*
name|Find_Directories
parameter_list|(
name|repository
parameter_list|,
name|which
parameter_list|)
name|char
modifier|*
name|repository
decl_stmt|;
name|int
name|which
decl_stmt|;
block|{
name|List
modifier|*
name|dirlist
decl_stmt|;
comment|/* make a list for the directories */
name|dirlist
operator|=
name|getlist
argument_list|()
expr_stmt|;
comment|/* find the local ones */
if|if
condition|(
name|which
operator|&
name|W_LOCAL
condition|)
block|{
comment|/* look only for CVS controlled sub-directories */
if|if
condition|(
name|find_dirs
argument_list|(
literal|"."
argument_list|,
name|dirlist
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot open current directory"
argument_list|)
expr_stmt|;
block|}
comment|/* look for sub-dirs in the repository */
if|if
condition|(
operator|(
name|which
operator|&
name|W_REPOS
operator|)
operator|&&
name|repository
condition|)
block|{
comment|/* search the repository */
if|if
condition|(
name|find_dirs
argument_list|(
name|repository
argument_list|,
name|dirlist
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot open directory %s"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATTIC_DIR_SUPPORT
comment|/* XXX - FIXME */
comment|/* search the attic too */
if|if
condition|(
name|which
operator|&
name|W_ATTIC
condition|)
block|{
name|char
name|dir
index|[
name|PATH_MAX
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dir
argument_list|,
literal|"%s/%s"
argument_list|,
name|repository
argument_list|,
name|CVSATTIC
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|find_dirs
argument_list|(
name|dir
argument_list|,
name|dirlist
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* sort the list into alphabetical order and return it */
name|sortlist
argument_list|(
name|dirlist
argument_list|,
name|fsortcmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|dirlist
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Finds all the ,v files in the argument directory, and adds them to the  * files list.  Returns 0 for success and non-zero if the argument directory  * cannot be opened.  */
end_comment

begin_function
specifier|static
name|int
name|find_rcs
parameter_list|(
name|dir
parameter_list|,
name|list
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|List
modifier|*
name|list
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
name|DIR
modifier|*
name|dirp
decl_stmt|;
comment|/* set up to read the dir */
if|if
condition|(
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
name|dir
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* read the dir, grabbing the ,v files */
while|while
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fnmatch
argument_list|(
name|RCSPAT
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|comma
decl_stmt|;
name|comma
operator|=
name|strrchr
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|','
argument_list|)
expr_stmt|;
comment|/* strip the ,v */
operator|*
name|comma
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|FILES
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|addnode
argument_list|(
name|list
argument_list|,
name|p
argument_list|)
operator|!=
literal|0
condition|)
name|freenode
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Finds all the subdirectories of the argument dir and adds them to the  * specified list.  Sub-directories without a CVS administration directory  * are optionally ignored  Returns 0 for success or 1 on error.  */
end_comment

begin_function
specifier|static
name|int
name|find_dirs
parameter_list|(
name|dir
parameter_list|,
name|list
parameter_list|,
name|checkadm
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|List
modifier|*
name|list
decl_stmt|;
name|int
name|checkadm
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|char
name|tmp
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
name|DIR
modifier|*
name|dirp
decl_stmt|;
comment|/* set up to read the dir */
if|if
condition|(
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
name|dir
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* read the dir, grabbing sub-dirs */
while|while
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|CVSATTIC
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|CVSLCK
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|CVSREP
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|DT_DIR
if|if
condition|(
name|dp
operator|->
name|d_type
operator|!=
name|DT_DIR
condition|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_type
operator|!=
name|DT_UNKNOWN
operator|&&
name|dp
operator|->
name|d_type
operator|!=
name|DT_LNK
condition|)
continue|continue;
endif|#
directive|endif
comment|/* don't bother stating ,v files */
if|if
condition|(
name|fnmatch
argument_list|(
name|RCSPAT
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isdir
argument_list|(
name|tmp
argument_list|)
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|DT_DIR
block|}
endif|#
directive|endif
comment|/* check for administration directories (if needed) */
if|if
condition|(
name|checkadm
condition|)
block|{
comment|/* blow off symbolic links to dirs in local dir */
ifdef|#
directive|ifdef
name|DT_DIR
if|if
condition|(
name|dp
operator|->
name|d_type
operator|!=
name|DT_DIR
condition|)
block|{
comment|/* we're either unknown or a symlink at this point */
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|DT_LNK
condition|)
continue|continue;
endif|#
directive|endif
if|if
condition|(
name|islink
argument_list|(
name|tmp
argument_list|)
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|DT_DIR
block|}
endif|#
directive|endif
comment|/* check for new style */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|dir
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
name|CVSADM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isdir
argument_list|(
name|tmp
argument_list|)
condition|)
continue|continue;
block|}
comment|/* put it in the list */
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|DIRS
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|addnode
argument_list|(
name|list
argument_list|,
name|p
argument_list|)
operator|!=
literal|0
condition|)
name|freenode
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

