begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *    Copyright (c) 1992, Brian Berliner and Jeff Polk  *    Copyright (c) 1989-1992, Brian Berliner  *  *    You may distribute under the terms of the GNU General Public License  *    as specified in the README file that comes with the CVS source distribution.  *  * This is the main C driver for the CVS system.  *  * Credit to Dick Grune, Vrije Universiteit, Amsterdam, for writing  * the shell-script CVS system that this is based on.  *  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_WINSOCK_H
end_ifdef

begin_include
include|#
directive|include
file|<winsock.h>
end_include

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|int
name|gethostname
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|program_path
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|command_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* I'd dynamically allocate this, but it seems like gethostname    requires a fixed size array.  If I'm remembering the RFCs right,    256 should be enough.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAXHOSTNAMELEN
end_ifndef

begin_define
define|#
directive|define
name|MAXHOSTNAMELEN
value|256
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|hostname
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|use_editor
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|use_cvsrc
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cvswrite
init|=
operator|!
name|CVSREAD_DFLT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|really_quiet
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|quiet
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|trace
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|noexec
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|logoff
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|mode_t
name|cvsumask
init|=
name|UMASK_DFLT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|CurDir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Defaults, for the environment variables that are not set  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Tmpdir
init|=
name|TMPDIR_DFLT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Editor
init|=
name|EDITOR_DFLT
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
specifier|const
struct|struct
name|cmd
block|{
name|char
modifier|*
name|fullname
decl_stmt|;
comment|/* Full name of the function (e.g. "commit") */
comment|/* Synonyms for the command, nick1 and nick2.  We supply them        mostly for two reasons: (1) CVS has always supported them, and        we need to maintain compatibility, (2) if there is a need for a        version which is shorter than the fullname, for ease in typing.        Synonyms have the disadvantage that people will see "new" and        then have to think about it, or look it up, to realize that is        the operation they know as "add".  Also, this means that one        cannot create a command "cvs new" with a different meaning.  So        new synonyms are probably best used sparingly, and where used        should be abbreviations of the fullname (preferably consisting        of the first 2 or 3 or so letters).         One thing that some systems do is to recognize any unique        abbreviation, for example "annotat" "annota", etc., for        "annotate".  The problem with this is that scripts and user        habits will expect a certain abbreviation to be unique, and in        a future release of CVS it may not be.  So it is better to        accept only an explicit list of abbreviations and plan on        supporting them in the future as well as now.  */
name|char
modifier|*
name|nick1
decl_stmt|;
name|char
modifier|*
name|nick2
decl_stmt|;
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
comment|/* Function takes (argc, argv) arguments. */
block|}
name|cmds
index|[]
init|=
block|{
block|{
literal|"add"
block|,
literal|"ad"
block|,
literal|"new"
block|,
name|add
block|}
block|,
block|{
literal|"admin"
block|,
literal|"adm"
block|,
literal|"rcs"
block|,
name|admin
block|}
block|,
block|{
literal|"annotate"
block|,
literal|"ann"
block|,
name|NULL
block|,
name|annotate
block|}
block|,
block|{
literal|"checkout"
block|,
literal|"co"
block|,
literal|"get"
block|,
name|checkout
block|}
block|,
block|{
literal|"commit"
block|,
literal|"ci"
block|,
literal|"com"
block|,
name|commit
block|}
block|,
block|{
literal|"diff"
block|,
literal|"di"
block|,
literal|"dif"
block|,
name|diff
block|}
block|,
block|{
literal|"edit"
block|,
name|NULL
block|,
name|NULL
block|,
name|edit
block|}
block|,
block|{
literal|"editors"
block|,
name|NULL
block|,
name|NULL
block|,
name|editors
block|}
block|,
block|{
literal|"export"
block|,
literal|"exp"
block|,
literal|"ex"
block|,
name|checkout
block|}
block|,
block|{
literal|"history"
block|,
literal|"hi"
block|,
literal|"his"
block|,
name|history
block|}
block|,
block|{
literal|"import"
block|,
literal|"im"
block|,
literal|"imp"
block|,
name|import
block|}
block|,
block|{
literal|"init"
block|,
name|NULL
block|,
name|NULL
block|,
name|init
block|}
block|,
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
block|{
literal|"kserver"
block|,
name|NULL
block|,
name|NULL
block|,
name|server
block|}
block|,
comment|/* placeholder */
endif|#
directive|endif
block|{
literal|"log"
block|,
literal|"lo"
block|,
literal|"rlog"
block|,
name|cvslog
block|}
block|,
ifdef|#
directive|ifdef
name|AUTH_CLIENT_SUPPORT
block|{
literal|"login"
block|,
literal|"logon"
block|,
literal|"lgn"
block|,
name|login
block|}
block|,
block|{
literal|"logout"
block|,
name|NULL
block|,
name|NULL
block|,
name|logout
block|}
block|,
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
block|{
literal|"pserver"
block|,
name|NULL
block|,
name|NULL
block|,
name|server
block|}
block|,
comment|/* placeholder */
endif|#
directive|endif
endif|#
directive|endif
comment|/* AUTH_CLIENT_SUPPORT */
block|{
literal|"rdiff"
block|,
literal|"patch"
block|,
literal|"pa"
block|,
name|patch
block|}
block|,
block|{
literal|"release"
block|,
literal|"re"
block|,
literal|"rel"
block|,
name|release
block|}
block|,
block|{
literal|"remove"
block|,
literal|"rm"
block|,
literal|"delete"
block|,
name|cvsremove
block|}
block|,
block|{
literal|"status"
block|,
literal|"st"
block|,
literal|"stat"
block|,
name|status
block|}
block|,
block|{
literal|"rtag"
block|,
literal|"rt"
block|,
literal|"rfreeze"
block|,
name|rtag
block|}
block|,
block|{
literal|"tag"
block|,
literal|"ta"
block|,
literal|"freeze"
block|,
name|cvstag
block|}
block|,
block|{
literal|"unedit"
block|,
name|NULL
block|,
name|NULL
block|,
name|unedit
block|}
block|,
block|{
literal|"update"
block|,
literal|"up"
block|,
literal|"upd"
block|,
name|update
block|}
block|,
block|{
literal|"watch"
block|,
name|NULL
block|,
name|NULL
block|,
name|watch
block|}
block|,
block|{
literal|"watchers"
block|,
name|NULL
block|,
name|NULL
block|,
name|watchers
block|}
block|,
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
block|{
literal|"server"
block|,
name|NULL
block|,
name|NULL
block|,
name|server
block|}
block|,
endif|#
directive|endif
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|, }
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|usg
index|[]
init|=
block|{
comment|/* CVS usage messages never have followed the GNU convention of        putting metavariables in uppercase.  I don't know whether that        is a good convention or not, but if it changes it would have to        change in all the usage messages.  For now, they consistently        use lowercase, as far as I know.  Puncutation is pretty funky,        though.  Sometimes they use none, as here.  Sometimes they use        single quotes (not the TeX-ish `' stuff), as in --help-options.        Sometimes they use double quotes, as in cvs -H add.         Most (not all) of the usage messages seem to have periods at        the end of each line.  I haven't tried to duplicate this style        in --help as it is a rather different format from the rest.  */
literal|"Usage: %s [cvs-options] command [command-options-and-arguments]\n"
block|,
literal|"  where cvs-options are -q, -n, etc.\n"
block|,
literal|"    (specify --help-options for a list of options)\n"
block|,
literal|"  where command is add, admin, etc.\n"
block|,
literal|"    (specify --help-commands for a list of commands\n"
block|,
literal|"     or --help-synonyms for a list of command synonyms)\n"
block|,
literal|"  where command-options-and-arguments depend on the specific command\n"
block|,
literal|"    (specify -H followed by a command name for command-specific help)\n"
block|,
literal|"  Specify --help to receive this message\n"
block|,
literal|"\n"
block|,
comment|/* Some people think that a bug-reporting address should go here.  IMHO,        the web sites are better because anything else is very likely to go        obsolete in the years between a release and when someone might be        reading this help.  Besides, we could never adequately discuss        bug reporting in a concise enough way to put in a help message.  */
comment|/* I was going to put this at the top, but usage() wants the %s to        be in the first line.  */
literal|"The Concurrent Versions System (CVS) is a tool for version control.\n"
block|,
comment|/* I really don't think I want to try to define "version control"        in one line.  I'm not sure one can get more concise than the        paragraph in ../cvs.spec without assuming the reader knows what        version control means.  */
literal|"For CVS updates and additional information, see\n"
block|,
literal|"    Cyclic Software at http://www.cyclic.com/ or\n"
block|,
literal|"    Pascal Molli's CVS site at http://www.loria.fr/~molli/cvs-index.html\n"
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|cmd_usage
index|[]
init|=
block|{
literal|"CVS commands are:\n"
block|,
literal|"        add          Add a new file/directory to the repository\n"
block|,
literal|"        admin        Administration front end for rcs\n"
block|,
literal|"        annotate     Show last revision where each line was modified\n"
block|,
literal|"        checkout     Checkout sources for editing\n"
block|,
literal|"        commit       Check files into the repository\n"
block|,
literal|"        diff         Show differences between revisions\n"
block|,
literal|"        edit         Get ready to edit a watched file\n"
block|,
literal|"        editors      See who is editing a watched file\n"
block|,
literal|"        export       Export sources from CVS, similar to checkout\n"
block|,
literal|"        history      Show repository access history\n"
block|,
literal|"        import       Import sources into CVS, using vendor branches\n"
block|,
literal|"        init         Create a CVS repository if it doesn't exist\n"
block|,
literal|"        log          Print out history information for files\n"
block|,
ifdef|#
directive|ifdef
name|AUTH_CLIENT_SUPPORT
literal|"        login        Prompt for password for authenticating server.\n"
block|,
literal|"        logout       Removes entry in .cvspass for remote repository.\n"
block|,
endif|#
directive|endif
comment|/* AUTH_CLIENT_SUPPORT */
literal|"        rdiff        Create 'patch' format diffs between releases\n"
block|,
literal|"        release      Indicate that a Module is no longer in use\n"
block|,
literal|"        remove       Remove an entry from the repository\n"
block|,
literal|"        rtag         Add a symbolic tag to a module\n"
block|,
literal|"        status       Display status information on checked out files\n"
block|,
literal|"        tag          Add a symbolic tag to checked out version of files\n"
block|,
literal|"        unedit       Undo an edit command\n"
block|,
literal|"        update       Bring work tree in sync with repository\n"
block|,
literal|"        watch        Set watches\n"
block|,
literal|"        watchers     See who is watching a file\n"
block|,
literal|"(Specify the --help option for a list of other help options)\n"
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|opt_usage
index|[]
init|=
block|{
literal|"CVS global options (specified before the command name) are:\n"
block|,
literal|"    -H           Displays usage information for command.\n"
block|,
literal|"    -Q           Cause CVS to be really quiet.\n"
block|,
literal|"    -q           Cause CVS to be somewhat quiet.\n"
block|,
literal|"    -r           Make checked-out files read-only.\n"
block|,
literal|"    -w           Make checked-out files read-write (default).\n"
block|,
literal|"    -l           Turn history logging off.\n"
block|,
literal|"    -n           Do not execute anything that will change the disk.\n"
block|,
literal|"    -t           Show trace of program execution -- try with -n.\n"
block|,
literal|"    -v           CVS version and copyright.\n"
block|,
literal|"    -b bindir    Find RCS programs in 'bindir'.\n"
block|,
literal|"    -T tmpdir    Use 'tmpdir' for temporary files.\n"
block|,
literal|"    -e editor    Use 'editor' for editing log information.\n"
block|,
literal|"    -d CVS_root  Overrides $CVSROOT as the root of the CVS tree.\n"
block|,
literal|"    -f           Do not use the ~/.cvsrc file.\n"
block|,
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
literal|"    -z #         Use compression level '#' for net traffic.\n"
block|,
ifdef|#
directive|ifdef
name|ENCRYPTION
literal|"    -x           Encrypt all net traffic.\n"
block|,
endif|#
directive|endif
literal|"    -a           Authenticate all net traffic.\n"
block|,
endif|#
directive|endif
literal|"    -s VAR=VAL   Set CVS user variable.\n"
block|,
literal|"(Specify the --help option for a list of other help options)\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|cmd_synonyms
parameter_list|()
block|{
name|char
modifier|*
modifier|*
name|synonyms
decl_stmt|;
name|char
modifier|*
modifier|*
name|line
decl_stmt|;
specifier|const
name|struct
name|cmd
modifier|*
name|c
init|=
operator|&
name|cmds
index|[
literal|0
index|]
decl_stmt|;
comment|/* Three more for title, "specify --help" line, and NULL.  */
name|int
name|numcmds
init|=
literal|3
decl_stmt|;
while|while
condition|(
name|c
operator|->
name|fullname
operator|!=
name|NULL
condition|)
block|{
name|numcmds
operator|++
expr_stmt|;
name|c
operator|++
expr_stmt|;
block|}
name|synonyms
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|numcmds
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|line
operator|=
name|synonyms
expr_stmt|;
operator|*
name|line
operator|++
operator|=
literal|"CVS command synonyms are:\n"
expr_stmt|;
for|for
control|(
name|c
operator|=
operator|&
name|cmds
index|[
literal|0
index|]
init|;
name|c
operator|->
name|fullname
operator|!=
name|NULL
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|->
name|nick1
operator|||
name|c
operator|->
name|nick2
condition|)
block|{
operator|*
name|line
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|c
operator|->
name|fullname
argument_list|)
operator|+
operator|(
name|c
operator|->
name|nick1
operator|!=
name|NULL
condition|?
name|strlen
argument_list|(
name|c
operator|->
name|nick1
argument_list|)
else|:
literal|0
operator|)
operator|+
operator|(
name|c
operator|->
name|nick2
operator|!=
name|NULL
condition|?
name|strlen
argument_list|(
name|c
operator|->
name|nick2
argument_list|)
else|:
literal|0
operator|)
operator|+
literal|40
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|*
name|line
argument_list|,
literal|"        %-12s %s %s\n"
argument_list|,
name|c
operator|->
name|fullname
argument_list|,
name|c
operator|->
name|nick1
condition|?
name|c
operator|->
name|nick1
else|:
literal|""
argument_list|,
name|c
operator|->
name|nick2
condition|?
name|c
operator|->
name|nick2
else|:
literal|""
argument_list|)
expr_stmt|;
name|line
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|line
operator|++
operator|=
literal|"(Specify the --help option for a list of other help options)\n"
expr_stmt|;
operator|*
name|line
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
specifier|const
name|char
operator|*
specifier|const
operator|*
operator|)
name|synonyms
return|;
comment|/* will never be freed */
block|}
end_function

begin_function
name|unsigned
name|long
name|int
name|lookup_command_attribute
parameter_list|(
name|cmd_name
parameter_list|)
name|char
modifier|*
name|cmd_name
decl_stmt|;
block|{
name|unsigned
name|long
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cmd_name
argument_list|,
literal|"import"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator||=
name|CVS_CMD_IGNORE_ADMROOT
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|cmd_name
argument_list|,
literal|"checkout"
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|cmd_name
argument_list|,
literal|"init"
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|cmd_name
argument_list|,
literal|"login"
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|cmd_name
argument_list|,
literal|"logout"
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|cmd_name
argument_list|,
literal|"rdiff"
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|cmd_name
argument_list|,
literal|"release"
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|cmd_name
argument_list|,
literal|"rtag"
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|ret
operator||=
name|CVS_CMD_USES_WORK_DIR
expr_stmt|;
block|}
comment|/* The following commands do not modify the repository; we        conservatively assume that everything else does.  Feel free to        add to this list if you are _certain_ something is safe. */
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|cmd_name
argument_list|,
literal|"checkout"
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|cmd_name
argument_list|,
literal|"diff"
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|cmd_name
argument_list|,
literal|"update"
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|cmd_name
argument_list|,
literal|"history"
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|cmd_name
argument_list|,
literal|"editors"
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|cmd_name
argument_list|,
literal|"export"
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|cmd_name
argument_list|,
literal|"history"
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|cmd_name
argument_list|,
literal|"log"
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|cmd_name
argument_list|,
literal|"noop"
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|cmd_name
argument_list|,
literal|"watchers"
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|cmd_name
argument_list|,
literal|"status"
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|ret
operator||=
name|CVS_CMD_MODIFIES_REPOSITORY
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|RETSIGTYPE
name|main_cleanup
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|DONT_USE_SIGNALS
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|temp
index|[
literal|10
index|]
decl_stmt|;
switch|switch
condition|(
name|sig
condition|)
block|{
ifdef|#
directive|ifdef
name|SIGHUP
case|case
name|SIGHUP
case|:
name|name
operator|=
literal|"hangup"
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGINT
case|case
name|SIGINT
case|:
name|name
operator|=
literal|"interrupt"
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGQUIT
case|case
name|SIGQUIT
case|:
name|name
operator|=
literal|"quit"
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGPIPE
case|case
name|SIGPIPE
case|:
name|name
operator|=
literal|"broken pipe"
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTERM
case|case
name|SIGTERM
case|:
name|name
operator|=
literal|"termination"
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
comment|/* This case should never be reached, because we list above all 	   the signals for which we actually establish a signal handler.  */
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%d"
argument_list|,
name|sig
argument_list|)
expr_stmt|;
name|name
operator|=
name|temp
expr_stmt|;
break|break;
block|}
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"received %s signal"
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !DONT_USE_SIGNALS */
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|CVSroot
init|=
name|CVSROOT_DFLT
decl_stmt|;
specifier|extern
name|char
modifier|*
name|version_string
decl_stmt|;
specifier|extern
name|char
modifier|*
name|config_string
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|end
decl_stmt|;
specifier|const
name|struct
name|cmd
modifier|*
name|cm
decl_stmt|;
name|int
name|c
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
name|int
name|tmpdir_update_env
decl_stmt|,
name|cvs_update_env
decl_stmt|;
name|int
name|free_CVSroot
init|=
literal|0
decl_stmt|;
name|int
name|free_Editor
init|=
literal|0
decl_stmt|;
name|int
name|free_Tmpdir
init|=
literal|0
decl_stmt|;
name|int
name|help
init|=
literal|0
decl_stmt|;
comment|/* Has the user asked for help?  This 				   lets us support the `cvs -H cmd' 				   convention to give help for cmd. */
specifier|static
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"help"
block|,
literal|0
block|,
name|NULL
block|,
literal|'H'
block|}
block|,
block|{
literal|"version"
block|,
literal|0
block|,
name|NULL
block|,
literal|'v'
block|}
block|,
block|{
literal|"help-commands"
block|,
literal|0
block|,
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"help-synonyms"
block|,
literal|0
block|,
name|NULL
block|,
literal|2
block|}
block|,
block|{
literal|"help-options"
block|,
literal|0
block|,
name|NULL
block|,
literal|4
block|}
block|,
block|{
literal|"allow-root"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|3
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
comment|/* `getopt_long' stores the option index here, but right now we         don't use it. */
name|int
name|option_index
init|=
literal|0
decl_stmt|;
name|int
name|need_to_create_root
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|SYSTEM_INITIALIZE
comment|/* Hook for OS-specific behavior, for example socket subsystems on        NT and OS2 or dealing with windows and arguments on Mac.  */
name|SYSTEM_INITIALIZE
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TZSET
comment|/* On systems that have tzset (which is almost all the ones I know        of), it's a good idea to call it.  */
name|tzset
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/*      * Just save the last component of the path for error messages      */
name|program_path
operator|=
name|xstrdup
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ARGV0_NOT_PROGRAM_NAME
comment|/* On some systems, e.g. VMS, argv[0] is not the name of the command        which the user types to invoke the program.  */
name|program_name
operator|=
literal|"cvs"
expr_stmt|;
else|#
directive|else
name|program_name
operator|=
name|last_component
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*      * Query the environment variables up-front, so that      * they can be overridden by command line arguments      */
name|cvs_update_env
operator|=
literal|0
expr_stmt|;
name|tmpdir_update_env
operator|=
operator|*
name|Tmpdir
expr_stmt|;
comment|/* TMPDIR_DFLT must be set */
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
name|TMPDIR_ENV
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|Tmpdir
operator|=
name|cp
expr_stmt|;
name|tmpdir_update_env
operator|=
literal|0
expr_stmt|;
comment|/* it's already there */
block|}
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
name|EDITOR1_ENV
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|Editor
operator|=
name|cp
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
name|EDITOR2_ENV
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|Editor
operator|=
name|cp
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
name|EDITOR3_ENV
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|Editor
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
name|CVSROOT_ENV
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|CVSroot
operator|=
name|cp
expr_stmt|;
name|cvs_update_env
operator|=
literal|0
expr_stmt|;
comment|/* it's already there */
block|}
if|if
condition|(
name|getenv
argument_list|(
name|CVSREAD_ENV
argument_list|)
operator|!=
name|NULL
condition|)
name|cvswrite
operator|=
literal|0
expr_stmt|;
comment|/* Set this to 0 to force getopt initialization.  getopt() sets        this to 1 internally.  */
name|optind
operator|=
literal|0
expr_stmt|;
comment|/* We have to parse the options twice because else there is no        chance to avoid reading the global options from ".cvsrc".  Set        opterr to 0 for avoiding error messages about invalid options.        */
name|opterr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"+f"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'f'
condition|)
name|use_cvsrc
operator|=
literal|0
expr_stmt|;
block|}
comment|/*      * Scan cvsrc file for global options.      */
if|if
condition|(
name|use_cvsrc
condition|)
name|read_cvsrc
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|,
literal|"cvs"
argument_list|)
expr_stmt|;
name|optind
operator|=
literal|0
expr_stmt|;
name|opterr
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"+Qqrwtnlvb:T:e:d:Hfz:s:xa"
argument_list|,
name|long_options
argument_list|,
operator|&
name|option_index
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|1
case|:
comment|/* --help-commands */
name|usage
argument_list|(
name|cmd_usage
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* --help-synonyms */
name|usage
argument_list|(
name|cmd_synonyms
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* --help-options */
name|usage
argument_list|(
name|opt_usage
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* --allow-root */
name|root_allow_add
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
name|really_quiet
operator|=
literal|1
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|'q'
case|:
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|cvswrite
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|cvswrite
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|trace
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|noexec
operator|=
literal|1
expr_stmt|;
case|case
literal|'l'
case|:
comment|/* Fall through */
name|logoff
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* Having the year here is a good idea, so people have 		   some idea of how long ago their version of CVS was 		   released.  */
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|version_string
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|config_string
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"\ Copyright (c) 1989-1998 Brian Berliner, david d `zoo' zuhn, \n\                         Jeff Polk, and other authors\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"CVS may be copied only under the terms of the GNU General Public License,\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"a copy of which can be found with the CVS distribution kit.\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"Specify the --help option for further information about CVS\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* This option used to specify the directory for RCS 		   executables.  But since we don't run them any more, 		   this is a noop.  Silently ignore it so that .cvsrc 		   and scripts and inetd.conf and such can work with 		   either new or old CVS.  */
break|break;
case|case
literal|'T'
case|:
name|Tmpdir
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|free_Tmpdir
operator|=
literal|1
expr_stmt|;
name|tmpdir_update_env
operator|=
literal|1
expr_stmt|;
comment|/* need to update environment */
break|break;
case|case
literal|'e'
case|:
name|Editor
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|free_Editor
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|CVSroot
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|free_CVSroot
operator|=
literal|1
expr_stmt|;
name|cvs_update_env
operator|=
literal|1
expr_stmt|;
comment|/* need to update environment */
break|break;
case|case
literal|'H'
case|:
name|help
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|use_cvsrc
operator|=
literal|0
expr_stmt|;
comment|/* unnecessary, since we've done it above */
break|break;
case|case
literal|'z'
case|:
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
name|gzip_level
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|gzip_level
operator|<=
literal|0
operator|||
name|gzip_level
operator|>
literal|9
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"gzip compression level must be between 1 and 9"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If no CLIENT_SUPPORT, we just silently ignore the gzip 		   level, so that users can have it in their .cvsrc and not 		   cause any trouble.  */
break|break;
case|case
literal|'s'
case|:
name|variable_set
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
name|cvsencrypt
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* CLIENT_SUPPORT */
comment|/* If no CLIENT_SUPPORT, ignore -x, so that users can                    have it in their .cvsrc and not cause any trouble.                    If no ENCRYPTION, we still accept -x, but issue an                    error if we are being run as a client.  */
break|break;
case|case
literal|'a'
case|:
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
name|cvsauthenticate
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* If no CLIENT_SUPPORT, ignore -a, so that users can                    have it in their .cvsrc and not cause any trouble.                    We will issue an error later if stream                    authentication is not supported.  */
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
name|usg
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
name|usage
argument_list|(
name|usg
argument_list|)
expr_stmt|;
comment|/* Look up the command name. */
name|command_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|cm
operator|=
name|cmds
init|;
name|cm
operator|->
name|fullname
condition|;
name|cm
operator|++
control|)
block|{
if|if
condition|(
name|cm
operator|->
name|nick1
operator|&&
operator|!
name|strcmp
argument_list|(
name|command_name
argument_list|,
name|cm
operator|->
name|nick1
argument_list|)
condition|)
break|break;
if|if
condition|(
name|cm
operator|->
name|nick2
operator|&&
operator|!
name|strcmp
argument_list|(
name|command_name
argument_list|,
name|cm
operator|->
name|nick2
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|command_name
argument_list|,
name|cm
operator|->
name|fullname
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|cm
operator|->
name|fullname
condition|)
name|usage
argument_list|(
name|cmd_usage
argument_list|)
expr_stmt|;
comment|/* no match */
else|else
name|command_name
operator|=
name|cm
operator|->
name|fullname
expr_stmt|;
comment|/* Global pointer for later use */
comment|/* This should probably remain a warning, rather than an error,        for quite a while.  For one thing the version of VC distributed        with GNU emacs 19.34 invokes 'cvs rlog' instead of 'cvs log'.  */
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"rlog"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: the rlog command is deprecated"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"use the synonymous log command instead"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|help
condition|)
name|argc
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* some functions only check for this */
else|else
block|{
comment|/* The user didn't ask for help, so go ahead and authenticate,            set up CVSROOT, and the rest of it. */
comment|/* The UMASK environment variable isn't handled with the 	   others above, since we don't want to signal errors if the 	   user has asked for help.  This won't work if somebody adds 	   a command-line flag to set the umask, since we'll have to 	   parse it before we get here. */
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
name|CVSUMASK_ENV
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* FIXME: Should be accepting symbolic as well as numeric mask.  */
name|cvsumask
operator|=
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|end
argument_list|,
literal|8
argument_list|)
operator|&
literal|0777
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|!=
literal|'\0'
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"invalid umask value in %s (%s)"
argument_list|,
name|CVSUMASK_ENV
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAVE_KERBEROS
argument_list|)
operator|&&
name|defined
argument_list|(
name|SERVER_SUPPORT
argument_list|)
comment|/* If we are invoked with a single argument "kserver", then we are 	   running as Kerberos server as root.  Do the authentication as 	   the very first thing, to minimize the amount of time we are 	   running as root.  */
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"kserver"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|kserver_authenticate_connection
argument_list|()
expr_stmt|;
comment|/* Pretend we were invoked as a plain server.  */
name|command_name
operator|=
literal|"server"
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_KERBEROS */
if|#
directive|if
operator|(
name|defined
argument_list|(
name|AUTH_SERVER_SUPPORT
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_GSSAPI
argument_list|)
operator|)
operator|&&
name|defined
argument_list|(
name|SERVER_SUPPORT
argument_list|)
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"pserver"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* The reason that --allow-root is not a command option 	       is mainly the comment in server() about how argc,argv 	       might be from .cvsrc.  I'm not sure about that, and 	       I'm not sure it is only true of command options, but 	       it seems easier to make it a global option.  */
comment|/* Gets username and password from client, authenticates, then 	       switches to run as that user and sends an ACK back to the 	       client. */
name|pserver_authenticate_connection
argument_list|()
expr_stmt|;
comment|/* Pretend we were invoked as a plain server.  */
name|command_name
operator|=
literal|"server"
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* (AUTH_SERVER_SUPPORT || HAVE_GSSAPI)&& SERVER_SUPPORT */
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
name|server_active
operator|=
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"server"
argument_list|)
operator|==
literal|0
expr_stmt|;
comment|/* Fiddling with CVSROOT doesn't make sense if we're running            in server mode, since the client will send the repository            directory after the connection is made. */
if|if
condition|(
operator|!
name|server_active
condition|)
endif|#
directive|endif
block|{
name|char
modifier|*
name|CVSADM_Root
decl_stmt|;
comment|/* See if we are able to find a 'better' value for CVSroot 	       in the CVSADM_ROOT directory. */
name|CVSADM_Root
operator|=
name|NULL
expr_stmt|;
comment|/* "cvs import" shouldn't check CVS/Root; in general it 	       ignores CVS directories and CVS/Root is likely to 	       specify a different repository than the one we are 	       importing to.  */
if|if
condition|(
name|lookup_command_attribute
argument_list|(
name|command_name
argument_list|)
operator|&
name|CVS_CMD_IGNORE_ADMROOT
condition|)
block|{
name|CVSADM_Root
operator|=
name|Name_Root
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CVSADM_Root
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|CVSroot
operator|==
name|NULL
operator|||
operator|!
name|cvs_update_env
condition|)
block|{
name|CVSroot
operator|=
name|CVSADM_Root
expr_stmt|;
name|cvs_update_env
operator|=
literal|1
expr_stmt|;
comment|/* need to update environment */
block|}
comment|/* Let -d override CVS/Root file.  The user might want 		   to change the access method, use a different server 		   (if there are two server machines which share the 		   repository using a networked file system), etc.  */
elseif|else
if|if
condition|(
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
operator|!
name|getenv
argument_list|(
literal|"CVS_IGNORE_REMOTE_ROOT"
argument_list|)
operator|&&
endif|#
directive|endif
name|strcmp
argument_list|(
name|CVSroot
argument_list|,
name|CVSADM_Root
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Once we have verified that this root is usable, 		       we will want to write it into CVS/Root.  		       Don't do it for the "login" command, however. 		       Consider: if the user executes "cvs login" with 		       the working directory inside an already checked 		       out module, we'd incorrectly change the 		       CVS/Root file to reflect the CVSROOT of the 		       "cvs login" command.  Ahh, the things one 		       discovers. */
if|if
condition|(
name|lookup_command_attribute
argument_list|(
name|command_name
argument_list|)
operator|&
name|CVS_CMD_USES_WORK_DIR
condition|)
block|{
name|need_to_create_root
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* Now we've reconciled CVSROOT from the command line, the                CVS/Root file, and the environment variable.  Do the                last sanity checks on the variable. */
if|if
condition|(
operator|!
name|CVSroot
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"No CVSROOT specified!  Please use the `-d' option"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"or set the %s environment variable."
argument_list|,
name|CVSROOT_ENV
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|CVSroot
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"CVSROOT is set but empty!  Make sure that the"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"specification of CVSROOT is legal, either via the"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"`-d' option, the %s environment variable, or the"
argument_list|,
name|CVSROOT_ENV
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"CVS/Root file (if any)."
argument_list|)
expr_stmt|;
block|}
comment|/* Now we're 100% sure that we have a valid CVSROOT 	       variable.  Parse it to see if we're supposed to do 	       remote accesses or use a special access method. */
if|if
condition|(
name|parse_cvsroot
argument_list|(
name|CVSroot
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Bad CVSROOT."
argument_list|)
expr_stmt|;
comment|/* 	     * Check to see if we can write into the history file.  If not, 	     * we assume that we can't work in the repository. 	     * BUT, only if the history file exists. 	     */
if|if
condition|(
operator|!
name|client_active
condition|)
block|{
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|save_errno
decl_stmt|;
name|path
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|CVSroot_directory
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSROOTADM
argument_list|)
operator|+
literal|20
operator|+
sizeof|sizeof
argument_list|(
name|CVSROOTADM_HISTORY
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|path
argument_list|,
literal|"%s/%s"
argument_list|,
name|CVSroot_directory
argument_list|,
name|CVSROOTADM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isaccessible
argument_list|(
name|path
argument_list|,
name|R_OK
operator||
name|X_OK
argument_list|)
condition|)
block|{
name|save_errno
operator|=
name|errno
expr_stmt|;
comment|/* If this is "cvs init", the root need not exist yet.  */
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"init"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
name|save_errno
argument_list|,
literal|"%s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|path
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|path
argument_list|,
name|CVSROOTADM_HISTORY
argument_list|)
expr_stmt|;
if|if
condition|(
name|isfile
argument_list|(
name|path
argument_list|)
operator|&&
operator|!
name|isaccessible
argument_list|(
name|path
argument_list|,
name|R_OK
operator||
name|W_OK
argument_list|)
condition|)
block|{
name|save_errno
operator|=
name|errno
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Sorry, you don't have read/write access to the history file"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
name|save_errno
argument_list|,
literal|"%s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_PUTENV
comment|/* Update the CVSROOT environment variable if necessary. */
if|if
condition|(
name|cvs_update_env
condition|)
block|{
name|char
modifier|*
name|env
decl_stmt|;
name|env
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|CVSROOT_ENV
argument_list|)
operator|+
name|strlen
argument_list|(
name|CVSroot
argument_list|)
operator|+
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|env
argument_list|,
literal|"%s=%s"
argument_list|,
name|CVSROOT_ENV
argument_list|,
name|CVSroot
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
comment|/* do not free env, as putenv has control of it */
block|}
endif|#
directive|endif
block|}
comment|/* This is only used for writing into the history file.  For 	   remote connections, it might be nice to have hostname 	   and/or remote path, on the other hand I'm not sure whether 	   it is worth the trouble.  */
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
name|CurDir
operator|=
name|xstrdup
argument_list|(
literal|"<remote>"
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
name|CurDir
operator|=
name|xgetwd
argument_list|()
expr_stmt|;
if|if
condition|(
name|CurDir
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot get working directory"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Tmpdir
operator|==
name|NULL
operator|||
name|Tmpdir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|Tmpdir
operator|=
literal|"/tmp"
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PUTENV
if|if
condition|(
name|tmpdir_update_env
condition|)
block|{
name|char
modifier|*
name|env
decl_stmt|;
name|env
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|TMPDIR_ENV
argument_list|)
operator|+
name|strlen
argument_list|(
name|Tmpdir
argument_list|)
operator|+
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|env
argument_list|,
literal|"%s=%s"
argument_list|,
name|TMPDIR_ENV
argument_list|,
name|Tmpdir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
comment|/* do not free env, as putenv has control of it */
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|DONT_USE_SIGNALS
comment|/* make sure we clean up on error */
ifdef|#
directive|ifdef
name|SIGHUP
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGHUP
argument_list|,
name|main_cleanup
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGHUP
argument_list|,
name|Lock_Cleanup
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGINT
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGINT
argument_list|,
name|main_cleanup
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGINT
argument_list|,
name|Lock_Cleanup
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGQUIT
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGQUIT
argument_list|,
name|main_cleanup
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGQUIT
argument_list|,
name|Lock_Cleanup
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGPIPE
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGPIPE
argument_list|,
name|main_cleanup
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGPIPE
argument_list|,
name|Lock_Cleanup
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTERM
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGTERM
argument_list|,
name|main_cleanup
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGTERM
argument_list|,
name|Lock_Cleanup
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* !DONT_USE_SIGNALS */
name|gethostname
argument_list|(
name|hostname
argument_list|,
sizeof|sizeof
argument_list|(
name|hostname
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KLUDGE_FOR_WNT_TESTSUITE
comment|/* Probably the need for this will go away at some point once 	   we call fflush enough places (e.g. fflush (stdout) in 	   cvs_outerr).  */
operator|(
name|void
operator|)
name|setvbuf
argument_list|(
name|stdout
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|_IONBF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setvbuf
argument_list|(
name|stderr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|_IONBF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* KLUDGE_FOR_WNT_TESTSUITE */
if|if
condition|(
name|use_cvsrc
condition|)
name|read_cvsrc
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|,
name|command_name
argument_list|)
expr_stmt|;
comment|/* Parse the CVSROOT/config file, but only for local.  For the 	   server, we parse it after we know $CVSROOT.  For the 	   client, it doesn't get parsed at all, obviously.  The 	   presence of the parse_config call here is not mean to 	   predetermine whether CVSROOT/config overrides things from 	   read_cvsrc and other such places or vice versa.  That sort 	   of thing probably needs more thought.  */
if|if
condition|(
literal|1
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
operator|&&
operator|!
name|server_active
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
operator|&&
operator|!
name|client_active
endif|#
directive|endif
condition|)
block|{
comment|/* If there was an error parsing the config file, parse_config 	       already printed an error.  We keep going.  Why?  Because 	       if we didn't, then there would be no way to check in a new 	       CVSROOT/config file to fix the broken one!  */
name|parse_config
argument_list|(
name|CVSroot_directory
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* end of stuff that gets done if the user DOESN'T ask for help */
name|err
operator|=
operator|(
operator|*
operator|(
name|cm
operator|->
name|func
operator|)
operator|)
operator|(
name|argc
operator|,
name|argv
operator|)
expr_stmt|;
if|if
condition|(
name|need_to_create_root
condition|)
block|{
comment|/* Update the CVS/Root file.  We might want to do this in 	   all directories that we recurse into, but currently we 	   don't.  Note that if there is an error writing the file, 	   we give an error/warning.  This is so if users try to rewrite 	   CVS/Root with the -d option (a documented feature), they will 	   either succeed, or be told why it didn't work.  */
name|Create_Root
argument_list|(
name|NULL
argument_list|,
name|CVSroot
argument_list|)
expr_stmt|;
block|}
name|Lock_Cleanup
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|program_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_CVSroot
condition|)
name|free
argument_list|(
name|CVSroot
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_Editor
condition|)
name|free
argument_list|(
name|Editor
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_Tmpdir
condition|)
name|free
argument_list|(
name|Tmpdir
argument_list|)
expr_stmt|;
name|root_allow_free
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SYSTEM_CLEANUP
comment|/* Hook for OS-specific behavior, for example socket subsystems on        NT and OS2 or dealing with windows and arguments on Mac.  */
name|SYSTEM_CLEANUP
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* This is exit rather than return because apparently that keeps        some tools which check for memory leaks happier.  */
name|exit
argument_list|(
name|err
condition|?
name|EXIT_FAILURE
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* Keep picky/stupid compilers (e.g. Visual C++ 5.0) happy.  */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|Make_Date
parameter_list|(
name|rawdate
parameter_list|)
name|char
modifier|*
name|rawdate
decl_stmt|;
block|{
name|struct
name|tm
modifier|*
name|ftm
decl_stmt|;
name|time_t
name|unixtime
decl_stmt|;
name|char
name|date
index|[
name|MAXDATELEN
index|]
decl_stmt|;
name|char
modifier|*
name|ret
decl_stmt|;
name|unixtime
operator|=
name|get_date
argument_list|(
name|rawdate
argument_list|,
operator|(
expr|struct
name|timeb
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|unixtime
operator|==
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Can't parse date/time: %s"
argument_list|,
name|rawdate
argument_list|)
expr_stmt|;
name|ftm
operator|=
name|gmtime
argument_list|(
operator|&
name|unixtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftm
operator|==
name|NULL
condition|)
comment|/* This is a system, like VMS, where the system clock is in local 	   time.  Hopefully using localtime here matches the "zero timezone" 	   hack I added to get_date.  */
name|ftm
operator|=
name|localtime
argument_list|(
operator|&
name|unixtime
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|date
argument_list|,
name|DATEFORM
argument_list|,
name|ftm
operator|->
name|tm_year
operator|+
operator|(
name|ftm
operator|->
name|tm_year
operator|<
literal|100
condition|?
literal|0
else|:
literal|1900
operator|)
argument_list|,
name|ftm
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|ftm
operator|->
name|tm_mday
argument_list|,
name|ftm
operator|->
name|tm_hour
argument_list|,
name|ftm
operator|->
name|tm_min
argument_list|,
name|ftm
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
name|ret
operator|=
name|xstrdup
argument_list|(
name|date
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|usage
parameter_list|(
name|cpp
parameter_list|)
specifier|register
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|cpp
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
operator|*
name|cpp
operator|++
argument_list|,
name|program_name
argument_list|,
name|command_name
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|cpp
condition|;
name|cpp
operator|++
control|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
name|error_exit
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

