begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *    Copyright (c) 1992, Brian Berliner and Jeff Polk  *    Copyright (c) 1989-1992, Brian Berliner  *  *    You may distribute under the terms of the GNU General Public License  *    as specified in the README file that comes with the CVS 1.4 kit.  *  * This is the main C driver for the CVS system.  *  * Credit to Dick Grune, Vrije Universiteit, Amsterdam, for writing  * the shell-script CVS system that this is based on.  *  * Usage:  *	cvs [options] command [options] [files/modules...]  *  * Where "command" is composed of:  *		admin		RCS command  *		checkout	Check out a module/dir/file  *		export		Like checkout, but used for exporting sources  *		update		Brings work tree in sync with repository  *		commit		Checks files into the repository  *		diff		Runs diffs between revisions  *		log		Prints "rlog" information for files  *		login		Record user, host, repos, password  *		add		Adds an entry to the repository  *		remove		Removes an entry from the repository  *		status		Status info on the revisions  *		rdiff		"patch" format diff listing between releases  *		tag		Add/delete a symbolic tag to the RCS file  *		rtag		Add/delete a symbolic tag to the RCS file  *		import		Import sources into CVS, using vendor branches  *		release		Indicate that Module is no longer in use.  *		history		Display history of Users and Modules.  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_WINSOCK_H
end_ifdef

begin_include
include|#
directive|include
file|<winsock.h>
end_include

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|int
name|gethostname
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_KERBEROS
end_if

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<krb.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_KRB_GET_ERR_TEXT
end_ifndef

begin_define
define|#
directive|define
name|krb_get_err_text
parameter_list|(
name|status
parameter_list|)
value|krb_err_txt[status]
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|program_path
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initialize comamnd_name to "cvs" so that the first call to  * read_cvsrc tries to find global cvs options.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|command_name
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Since some systems don't define this...  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAXHOSTNAMELEN
end_ifndef

begin_define
define|#
directive|define
name|MAXHOSTNAMELEN
value|256
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|hostname
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|AUTH_CLIENT_SUPPORT
end_ifdef

begin_decl_stmt
name|int
name|use_authenticating_server
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTH_CLIENT_SUPPORT */
end_comment

begin_decl_stmt
name|int
name|use_editor
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|use_cvsrc
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cvswrite
init|=
operator|!
name|CVSREAD_DFLT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|really_quiet
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|quiet
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|trace
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|noexec
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|logoff
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|mode_t
name|cvsumask
init|=
name|UMASK_DFLT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|CurDir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Defaults, for the environment variables that are not set  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Rcsbin
init|=
name|RCSBIN_DFLT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Editor
init|=
name|EDITOR_DFLT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|CVSroot
init|=
name|CVSROOT_DFLT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The path found in CVS/Root must match $CVSROOT and/or 'cvs -d root'  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|CVSADM_Root
init|=
name|CVSROOT_DFLT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|add
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|admin
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|checkout
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|commit
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|diff
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|history
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|import
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cvslog
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|AUTH_CLIENT_SUPPORT
end_ifdef

begin_decl_stmt
name|int
name|login
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTH_CLIENT_SUPPORT */
end_comment

begin_decl_stmt
name|int
name|patch
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|release
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cvsremove
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rtag
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|status
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tag
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|update
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct
specifier|const
struct|struct
name|cmd
block|{
name|char
modifier|*
name|fullname
decl_stmt|;
comment|/* Full name of the function (e.g. "commit") */
name|char
modifier|*
name|nick1
decl_stmt|;
comment|/* alternate name (e.g. "ci") */
name|char
modifier|*
name|nick2
decl_stmt|;
comment|/* another alternate names (e.g. "ci") */
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
comment|/* Function takes (argc, argv) arguments. */
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
name|int
function_decl|(
modifier|*
name|client_func
function_decl|)
parameter_list|()
function_decl|;
comment|/* Function to do it via the protocol.  */
endif|#
directive|endif
block|}
name|cmds
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
define|#
directive|define
name|CMD_ENTRY
parameter_list|(
name|n1
parameter_list|,
name|n2
parameter_list|,
name|n3
parameter_list|,
name|f1
parameter_list|,
name|f2
parameter_list|)
value|{ n1, n2, n3, f1, f2 }
else|#
directive|else
define|#
directive|define
name|CMD_ENTRY
parameter_list|(
name|n1
parameter_list|,
name|n2
parameter_list|,
name|n3
parameter_list|,
name|f1
parameter_list|,
name|f2
parameter_list|)
value|{ n1, n2, n3, f1 }
endif|#
directive|endif
name|CMD_ENTRY
argument_list|(
literal|"add"
argument_list|,
literal|"ad"
argument_list|,
literal|"new"
argument_list|,
name|add
argument_list|,
name|client_add
argument_list|)
block|,
name|CMD_ENTRY
argument_list|(
literal|"admin"
argument_list|,
literal|"adm"
argument_list|,
literal|"rcs"
argument_list|,
name|admin
argument_list|,
name|client_admin
argument_list|)
block|,
name|CMD_ENTRY
argument_list|(
literal|"annotate"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|annotate
argument_list|,
name|client_annotate
argument_list|)
block|,
name|CMD_ENTRY
argument_list|(
literal|"checkout"
argument_list|,
literal|"co"
argument_list|,
literal|"get"
argument_list|,
name|checkout
argument_list|,
name|client_checkout
argument_list|)
block|,
name|CMD_ENTRY
argument_list|(
literal|"commit"
argument_list|,
literal|"ci"
argument_list|,
literal|"com"
argument_list|,
name|commit
argument_list|,
name|client_commit
argument_list|)
block|,
name|CMD_ENTRY
argument_list|(
literal|"diff"
argument_list|,
literal|"di"
argument_list|,
literal|"dif"
argument_list|,
name|diff
argument_list|,
name|client_diff
argument_list|)
block|,
name|CMD_ENTRY
argument_list|(
literal|"edit"
argument_list|,
literal|"edit"
argument_list|,
literal|"edit"
argument_list|,
name|edit
argument_list|,
name|client_edit
argument_list|)
block|,
name|CMD_ENTRY
argument_list|(
literal|"editors"
argument_list|,
literal|"editors"
argument_list|,
literal|"editors"
argument_list|,
name|editors
argument_list|,
name|client_editors
argument_list|)
block|,
name|CMD_ENTRY
argument_list|(
literal|"export"
argument_list|,
literal|"exp"
argument_list|,
literal|"ex"
argument_list|,
name|checkout
argument_list|,
name|client_export
argument_list|)
block|,
name|CMD_ENTRY
argument_list|(
literal|"history"
argument_list|,
literal|"hi"
argument_list|,
literal|"his"
argument_list|,
name|history
argument_list|,
name|client_history
argument_list|)
block|,
name|CMD_ENTRY
argument_list|(
literal|"import"
argument_list|,
literal|"im"
argument_list|,
literal|"imp"
argument_list|,
name|import
argument_list|,
name|client_import
argument_list|)
block|,
name|CMD_ENTRY
argument_list|(
literal|"init"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|init
argument_list|,
name|client_init
argument_list|)
block|,
name|CMD_ENTRY
argument_list|(
literal|"log"
argument_list|,
literal|"lo"
argument_list|,
literal|"rlog"
argument_list|,
name|cvslog
argument_list|,
name|client_log
argument_list|)
block|,
ifdef|#
directive|ifdef
name|AUTH_CLIENT_SUPPORT
name|CMD_ENTRY
argument_list|(
literal|"login"
argument_list|,
literal|"logon"
argument_list|,
literal|"lgn"
argument_list|,
name|login
argument_list|,
name|login
argument_list|)
block|,
endif|#
directive|endif
comment|/* AUTH_CLIENT_SUPPORT */
name|CMD_ENTRY
argument_list|(
literal|"rdiff"
argument_list|,
literal|"patch"
argument_list|,
literal|"pa"
argument_list|,
name|patch
argument_list|,
name|client_rdiff
argument_list|)
block|,
name|CMD_ENTRY
argument_list|(
literal|"release"
argument_list|,
literal|"re"
argument_list|,
literal|"rel"
argument_list|,
name|release
argument_list|,
name|client_release
argument_list|)
block|,
name|CMD_ENTRY
argument_list|(
literal|"remove"
argument_list|,
literal|"rm"
argument_list|,
literal|"delete"
argument_list|,
name|cvsremove
argument_list|,
name|client_remove
argument_list|)
block|,
name|CMD_ENTRY
argument_list|(
literal|"status"
argument_list|,
literal|"st"
argument_list|,
literal|"stat"
argument_list|,
name|status
argument_list|,
name|client_status
argument_list|)
block|,
name|CMD_ENTRY
argument_list|(
literal|"rtag"
argument_list|,
literal|"rt"
argument_list|,
literal|"rfreeze"
argument_list|,
name|rtag
argument_list|,
name|client_rtag
argument_list|)
block|,
name|CMD_ENTRY
argument_list|(
literal|"tag"
argument_list|,
literal|"ta"
argument_list|,
literal|"freeze"
argument_list|,
name|tag
argument_list|,
name|client_tag
argument_list|)
block|,
name|CMD_ENTRY
argument_list|(
literal|"unedit"
argument_list|,
literal|"unedit"
argument_list|,
literal|"unedit"
argument_list|,
name|unedit
argument_list|,
name|client_unedit
argument_list|)
block|,
name|CMD_ENTRY
argument_list|(
literal|"update"
argument_list|,
literal|"up"
argument_list|,
literal|"upd"
argument_list|,
name|update
argument_list|,
name|client_update
argument_list|)
block|,
name|CMD_ENTRY
argument_list|(
literal|"watch"
argument_list|,
literal|"watch"
argument_list|,
literal|"watch"
argument_list|,
name|watch
argument_list|,
name|client_watch
argument_list|)
block|,
name|CMD_ENTRY
argument_list|(
literal|"watchers"
argument_list|,
literal|"watchers"
argument_list|,
literal|"watchers"
argument_list|,
name|watchers
argument_list|,
name|client_watchers
argument_list|)
block|,
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
comment|/*      * The client_func is also server because we might have picked up a      * CVSROOT environment variable containing a colon.  The client will send      * the real root later.      */
name|CMD_ENTRY
argument_list|(
literal|"server"
argument_list|,
literal|"server"
argument_list|,
literal|"server"
argument_list|,
name|server
argument_list|,
name|server
argument_list|)
block|,
endif|#
directive|endif
name|CMD_ENTRY
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
block|,
undef|#
directive|undef
name|CMD_ENTRY
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|usg
index|[]
init|=
block|{
literal|"Usage: %s [cvs-options] command [command-options] [files...]\n"
block|,
literal|"    Where 'cvs-options' are:\n"
block|,
literal|"        -H           Displays Usage information for command\n"
block|,
literal|"        -Q           Cause CVS to be really quiet.\n"
block|,
literal|"        -q           Cause CVS to be somewhat quiet.\n"
block|,
literal|"        -r           Make checked-out files read-only\n"
block|,
literal|"        -w           Make checked-out files read-write (default)\n"
block|,
literal|"        -l           Turn History logging off\n"
block|,
literal|"        -n           Do not execute anything that will change the disk\n"
block|,
literal|"        -t           Show trace of program execution -- Try with -n\n"
block|,
literal|"        -v           CVS version and copyright\n"
block|,
literal|"        -b bindir    Find RCS programs in 'bindir'\n"
block|,
literal|"        -e editor    Use 'editor' for editing log information\n"
block|,
literal|"        -d CVS_root  Overrides $CVSROOT as the root of the CVS tree\n"
block|,
literal|"        -f           Do not use the ~/.cvsrc file\n"
block|,
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
literal|"        -z #         Use 'gzip -#' for net traffic if possible.\n"
block|,
endif|#
directive|endif
literal|"        -s VAR=VAL   Set CVS user variable.\n"
block|,
literal|"\n"
block|,
literal|"    and where 'command' is: add, admin, etc. (use the --help-commands\n"
block|,
literal|"    option for a list of commands)\n"
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|cmd_usage
index|[]
init|=
block|{
literal|"CVS commands are:\n"
block|,
literal|"        add          Adds a new file/directory to the repository\n"
block|,
literal|"        admin        Administration front end for rcs\n"
block|,
literal|"        annotate     Show revision where each line was modified\n"
block|,
literal|"        checkout     Checkout sources for editing\n"
block|,
literal|"        commit       Checks files into the repository\n"
block|,
literal|"        diff         Runs diffs between revisions\n"
block|,
literal|"        edit         Get ready to edit a watched file\n"
block|,
literal|"        editors      See who is editing a watched file\n"
block|,
literal|"        history      Shows status of files and users\n"
block|,
literal|"        import       Import sources into CVS, using vendor branches\n"
block|,
literal|"        export       Export sources from CVS, similar to checkout\n"
block|,
literal|"        init         Initialize a new CVS repository\n"
block|,
literal|"        log          Prints out 'rlog' information for files\n"
block|,
ifdef|#
directive|ifdef
name|AUTH_CLIENT_SUPPORT
literal|"        login        Prompt for password for authenticating server.\n"
block|,
endif|#
directive|endif
comment|/* AUTH_CLIENT_SUPPORT */
literal|"        rdiff        'patch' format diffs between releases\n"
block|,
literal|"        release      Indicate that a Module is no longer in use\n"
block|,
literal|"        remove       Removes an entry from the repository\n"
block|,
literal|"        status       Status info on the revisions\n"
block|,
literal|"        tag          Add a symbolic tag to checked out version of RCS file\n"
block|,
literal|"        unedit       Undo an edit command\n"
block|,
literal|"        rtag         Add a symbolic tag to the RCS file\n"
block|,
literal|"        update       Brings work tree in sync with repository\n"
block|,
literal|"        watch        Set watches\n"
block|,
literal|"        watchers     See who is watching a file\n"
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|RETSIGTYPE
name|main_cleanup
parameter_list|()
block|{
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|error_cleanup
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
block|{
name|Lock_Cleanup
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
name|server_cleanup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|version_string
decl_stmt|;
specifier|extern
name|char
modifier|*
name|config_string
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|end
decl_stmt|;
specifier|const
name|struct
name|cmd
modifier|*
name|cm
decl_stmt|;
name|int
name|c
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|help
init|=
name|FALSE
decl_stmt|;
specifier|static
name|int
name|version_flag
init|=
name|FALSE
decl_stmt|;
specifier|static
name|int
name|help_commands
init|=
name|FALSE
decl_stmt|;
name|int
name|rcsbin_update_env
decl_stmt|,
name|cvs_update_env
init|=
literal|0
decl_stmt|;
specifier|static
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"help"
block|,
literal|0
block|,
operator|&
name|help
block|,
name|TRUE
block|}
block|,
block|{
literal|"version"
block|,
literal|0
block|,
operator|&
name|version_flag
block|,
name|TRUE
block|}
block|,
block|{
literal|"help-commands"
block|,
literal|0
block|,
operator|&
name|help_commands
block|,
name|TRUE
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
comment|/* `getopt_long' stores the option index here, but right now we         don't use it. */
name|int
name|option_index
init|=
literal|0
decl_stmt|;
name|error_set_cleanup
argument_list|(
name|error_cleanup
argument_list|)
expr_stmt|;
comment|/* The socket subsystems on NT and OS2 must be initialized before use */
ifdef|#
directive|ifdef
name|INITIALIZE_SOCKET_SUBSYSTEM
name|INITIALIZE_SOCKET_SUBSYSTEM
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* INITIALIZE_SOCKET_SUBSYSTEM */
comment|/*      * Just save the last component of the path for error messages      */
name|program_path
operator|=
name|xstrdup
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|program_name
operator|=
name|last_component
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|CurDir
operator|=
name|xmalloc
argument_list|(
name|PATH_MAX
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SERVER_SUPPORT
if|if
condition|(
operator|!
name|getwd
argument_list|(
name|CurDir
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot get working directory: %s"
argument_list|,
name|CurDir
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*      * Query the environment variables up-front, so that      * they can be overridden by command line arguments      */
name|rcsbin_update_env
operator|=
operator|*
name|Rcsbin
expr_stmt|;
comment|/* RCSBIN_DFLT must be set */
name|cvs_update_env
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
name|RCSBIN_ENV
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|Rcsbin
operator|=
name|cp
expr_stmt|;
name|rcsbin_update_env
operator|=
literal|0
expr_stmt|;
comment|/* it's already there */
block|}
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
name|EDITOR1_ENV
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|Editor
operator|=
name|cp
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
name|EDITOR2_ENV
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|Editor
operator|=
name|cp
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
name|EDITOR3_ENV
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|Editor
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
name|CVSROOT_ENV
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|CVSroot
operator|=
name|cp
expr_stmt|;
name|cvs_update_env
operator|=
literal|0
expr_stmt|;
comment|/* it's already there */
block|}
if|if
condition|(
name|getenv
argument_list|(
name|CVSREAD_ENV
argument_list|)
operator|!=
name|NULL
condition|)
name|cvswrite
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
name|CVSUMASK_ENV
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* FIXME: Should be accepting symbolic as well as numeric mask.  */
name|cvsumask
operator|=
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|end
argument_list|,
literal|8
argument_list|)
operator|&
literal|0777
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|!=
literal|'\0'
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"invalid umask value in %s (%s)"
argument_list|,
name|CVSUMASK_ENV
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
comment|/* This has the effect of setting getopt's ordering to REQUIRE_ORDER,        which is what we need to distinguish between global options and        command options.  FIXME: It would appear to be possible to do this        much less kludgily by passing "+" as the first character to the        option string we pass to getopt_long.  */
name|optind
operator|=
literal|1
expr_stmt|;
comment|/* We have to parse the options twice because else there is no        chance to avoid reading the global options from ".cvsrc".  Set        opterr to 0 for avoiding error messages about invalid options.        */
name|opterr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"f"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'f'
condition|)
name|use_cvsrc
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/*      * Scan cvsrc file for global options.      */
if|if
condition|(
name|use_cvsrc
condition|)
name|read_cvsrc
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|,
literal|"cvs"
argument_list|)
expr_stmt|;
name|optind
operator|=
literal|1
expr_stmt|;
name|opterr
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"Qqrwtnlvb:e:d:Hfz:s:"
argument_list|,
name|long_options
argument_list|,
operator|&
name|option_index
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|0
case|:
comment|/* getopt_long took care of setting the flag. */
break|break;
case|case
literal|'Q'
case|:
name|really_quiet
operator|=
name|TRUE
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|'q'
case|:
name|quiet
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|cvswrite
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|cvswrite
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|trace
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|noexec
operator|=
name|TRUE
expr_stmt|;
case|case
literal|'l'
case|:
comment|/* Fall through */
name|logoff
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|version_flag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|Rcsbin
operator|=
name|optarg
expr_stmt|;
name|rcsbin_update_env
operator|=
literal|1
expr_stmt|;
comment|/* need to update environment */
break|break;
case|case
literal|'e'
case|:
name|Editor
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|CVSroot
operator|=
name|optarg
expr_stmt|;
name|cvs_update_env
operator|=
literal|1
expr_stmt|;
comment|/* need to update environment */
break|break;
case|case
literal|'H'
case|:
name|use_cvsrc
operator|=
name|FALSE
expr_stmt|;
comment|/* this ensure that cvs -H works */
name|help
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|use_cvsrc
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
name|gzip_level
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|gzip_level
operator|<=
literal|0
operator|||
name|gzip_level
operator|>
literal|9
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"gzip compression level must be between 1 and 9"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If no CLIENT_SUPPORT, we just silently ignore the gzip 		   level, so that users can have it in their .cvsrc and not 		   cause any trouble.  */
break|break;
case|case
literal|'s'
case|:
name|variable_set
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
name|usg
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|version_flag
operator|==
name|TRUE
condition|)
block|{
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|version_string
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|config_string
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"Copyright (c) 1993-1994 Brian Berliner\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"Copyright (c) 1993-1994 david d `zoo' zuhn\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"Copyright (c) 1992, Brian Berliner and Jeff Polk\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"Copyright (c) 1989-1992, Brian Berliner\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"CVS may be copied only under the terms of the GNU General Public License,\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"a copy of which can be found with the CVS distribution kit.\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|help_commands
condition|)
name|usage
argument_list|(
name|cmd_usage
argument_list|)
expr_stmt|;
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
name|usage
argument_list|(
name|usg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_KERBEROS
comment|/* If we are invoked with a single argument "kserver", then we are        running as Kerberos server as root.  Do the authentication as        the very first thing, to minimize the amount of time we are        running as root.  */
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"kserver"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|status
decl_stmt|;
name|char
name|instance
index|[
name|INST_SZ
index|]
decl_stmt|;
name|struct
name|sockaddr_in
name|peer
decl_stmt|;
name|struct
name|sockaddr_in
name|laddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|KTEXT_ST
name|ticket
decl_stmt|;
name|AUTH_DAT
name|auth
decl_stmt|;
name|char
name|version
index|[
name|KRB_SENDAUTH_VLEN
index|]
decl_stmt|;
name|Key_schedule
name|sched
decl_stmt|;
name|char
name|user
index|[
name|ANAME_SZ
index|]
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|strcpy
argument_list|(
name|instance
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
name|peer
expr_stmt|;
if|if
condition|(
name|getpeername
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|peer
argument_list|,
operator|&
name|len
argument_list|)
operator|<
literal|0
operator|||
name|getsockname
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|laddr
argument_list|,
operator|&
name|len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"E Fatal error, aborting.\n\ error %s getpeername or getsockname failed\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
name|krb_recvauth
argument_list|(
name|KOPT_DO_MUTUAL
argument_list|,
name|STDIN_FILENO
argument_list|,
operator|&
name|ticket
argument_list|,
literal|"rcmd"
argument_list|,
name|instance
argument_list|,
operator|&
name|peer
argument_list|,
operator|&
name|laddr
argument_list|,
operator|&
name|auth
argument_list|,
literal|""
argument_list|,
name|sched
argument_list|,
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|KSUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"E Fatal error, aborting.\n\ error 0 kerberos: %s\n"
argument_list|,
name|krb_get_err_text
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
comment|/* Get the local name.  */
name|status
operator|=
name|krb_kntoln
argument_list|(
operator|&
name|auth
argument_list|,
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|KSUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"E Fatal error, aborting.\n\ error 0 kerberos: can't get local name: %s\n"
argument_list|,
name|krb_get_err_text
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|pw
operator|=
name|getpwnam
argument_list|(
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"E Fatal error, aborting.\n\ error 0 %s: no such user\n"
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|initgroups
argument_list|(
name|pw
operator|->
name|pw_name
argument_list|,
name|pw
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
name|setgid
argument_list|(
name|pw
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
name|setuid
argument_list|(
name|pw
operator|->
name|pw_uid
argument_list|)
expr_stmt|;
comment|/* Inhibit access by randoms.  Don't want people randomly 	   changing our temporary tree before we check things in.  */
name|umask
argument_list|(
literal|077
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_PUTENV
comment|/* Set LOGNAME and USER in the environment, in case they are            already set to something else.  */
block|{
name|char
modifier|*
name|env
decl_stmt|;
name|env
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
expr|"LOGNAME="
operator|+
name|strlen
argument_list|(
name|user
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|env
argument_list|,
literal|"LOGNAME=%s"
argument_list|,
name|user
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|env
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
expr|"USER="
operator|+
name|strlen
argument_list|(
name|user
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|env
argument_list|,
literal|"USER=%s"
argument_list|,
name|user
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Pretend we were invoked as a plain server.  */
name|argv
index|[
literal|0
index|]
operator|=
literal|"server"
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_KERBEROS */
if|#
directive|if
name|defined
argument_list|(
name|AUTH_SERVER_SUPPORT
argument_list|)
operator|&&
name|defined
argument_list|(
name|SERVER_SUPPORT
argument_list|)
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"pserver"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Gets username and password from client, authenticates, then          switches to run as that user and sends an ACK back to the          client. */
name|authenticate_connection
argument_list|()
expr_stmt|;
comment|/* Pretend we were invoked as a plain server.  */
name|argv
index|[
literal|0
index|]
operator|=
literal|"server"
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* AUTH_SERVER_SUPPORT&& SERVER_SUPPORT */
comment|/*      * See if we are able to find a 'better' value for CVSroot in the      * CVSADM_ROOT directory.      */
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"server"
argument_list|)
operator|==
literal|0
operator|&&
name|CVSroot
operator|==
name|NULL
condition|)
name|CVSADM_Root
operator|=
name|NULL
expr_stmt|;
else|else
name|CVSADM_Root
operator|=
name|Name_Root
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* No SERVER_SUPPORT */
name|CVSADM_Root
operator|=
name|Name_Root
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* No SERVER_SUPPORT */
if|if
condition|(
name|CVSADM_Root
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|CVSroot
operator|==
name|NULL
operator|||
operator|!
name|cvs_update_env
condition|)
block|{
name|CVSroot
operator|=
name|CVSADM_Root
expr_stmt|;
name|cvs_update_env
operator|=
literal|1
expr_stmt|;
comment|/* need to update environment */
block|}
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
elseif|else
if|if
condition|(
operator|!
name|getenv
argument_list|(
literal|"CVS_IGNORE_REMOTE_ROOT"
argument_list|)
condition|)
else|#
directive|else
comment|/* ! CLIENT_SUPPORT */
else|else
endif|#
directive|endif
comment|/* CLIENT_SUPPORT */
block|{
comment|/* 	     * Now for the hard part, compare the two directories. If they 	     * are not identical, then abort this command. 	     */
if|if
condition|(
operator|(
name|fncmp
argument_list|(
name|CVSroot
argument_list|,
name|CVSADM_Root
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|!
name|same_directories
argument_list|(
name|CVSroot
argument_list|,
name|CVSADM_Root
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s value for CVS Root found in %s"
argument_list|,
name|CVSADM_Root
argument_list|,
name|CVSADM_ROOT
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"does not match command line -d %s setting"
argument_list|,
name|CVSroot
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"you may wish to try the cvs command again without the -d option "
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* CVSroot may need fixing up, if an access-method was specified,      * but not a user.  Later code assumes that if CVSroot contains an      * access-method, then it also has a user.  We print a warning and      * die if we can't guarantee that.      */
if|if
condition|(
name|CVSroot
operator|&&
operator|*
name|CVSroot
operator|&&
operator|(
name|CVSroot
index|[
literal|0
index|]
operator|==
literal|':'
operator|)
operator|&&
operator|(
name|strchr
argument_list|(
name|CVSroot
argument_list|,
literal|'@'
argument_list|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"must also give a username if specifying access method"
argument_list|)
expr_stmt|;
block|}
comment|/*      * Specifying just the '-H' flag to the sub-command causes a Usage      * message to be displayed.      */
name|command_name
operator|=
name|cp
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|help
operator|==
name|TRUE
operator|||
operator|(
name|argc
operator|>
literal|1
operator|&&
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-H"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|argc
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
comment|/* 	 * Check to see if we can write into the history file.  If not, 	 * we assume that we can't work in the repository. 	 * BUT, only if the history file exists. 	 */
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"server"
argument_list|)
operator|!=
literal|0
operator|||
name|CVSroot
operator|!=
name|NULL
condition|)
endif|#
directive|endif
block|{
name|char
name|path
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|int
name|save_errno
decl_stmt|;
if|if
condition|(
operator|!
name|CVSroot
operator|||
operator|!
operator|*
name|CVSroot
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"You don't have a %s environment variable"
argument_list|,
name|CVSROOT_ENV
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|path
argument_list|,
literal|"%s/%s"
argument_list|,
name|CVSroot
argument_list|,
name|CVSROOTADM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isaccessible
argument_list|(
name|path
argument_list|,
name|R_OK
operator||
name|X_OK
argument_list|)
condition|)
block|{
name|save_errno
operator|=
name|errno
expr_stmt|;
comment|/* If this is "cvs init", the root need not exist yet.  */
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"init"
argument_list|)
operator|!=
literal|0
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
comment|/* If we are a remote client, the root need not exist 		       on the client machine (FIXME: we should also skip 		       the check for CVSROOTADM_HISTORY being writable; 		       it shouldn't matter if there is a read-only file 		       which happens to have the same name on the client 		       machine).  */
operator|&&
name|strchr
argument_list|(
name|CVSroot
argument_list|,
literal|':'
argument_list|)
operator|==
name|NULL
condition|)
endif|#
directive|endif
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Sorry, you don't have sufficient access to %s"
argument_list|,
name|CVSroot
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
name|save_errno
argument_list|,
literal|"%s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|path
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|path
argument_list|,
name|CVSROOTADM_HISTORY
argument_list|)
expr_stmt|;
if|if
condition|(
name|isfile
argument_list|(
name|path
argument_list|)
operator|&&
operator|!
name|isaccessible
argument_list|(
name|path
argument_list|,
name|R_OK
operator||
name|W_OK
argument_list|)
condition|)
block|{
name|save_errno
operator|=
name|errno
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Sorry, you don't have read/write access to the history file"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
name|save_errno
argument_list|,
literal|"%s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"server"
argument_list|)
operator|==
literal|0
condition|)
comment|/* This is only used for writing into the history file.  Might 	   be nice to have hostname and/or remote path, on the other hand 	   I'm not sure whether it is worth the trouble.  */
name|strcpy
argument_list|(
name|CurDir
argument_list|,
literal|"<remote>"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|getwd
argument_list|(
name|CurDir
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot get working directory: %s"
argument_list|,
name|CurDir
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_PUTENV
comment|/* Now, see if we should update the environment with the Rcsbin value */
if|if
condition|(
name|cvs_update_env
condition|)
block|{
name|char
modifier|*
name|env
decl_stmt|;
name|env
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|CVSROOT_ENV
argument_list|)
operator|+
name|strlen
argument_list|(
name|CVSroot
argument_list|)
operator|+
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|env
argument_list|,
literal|"%s=%s"
argument_list|,
name|CVSROOT_ENV
argument_list|,
name|CVSroot
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
comment|/* do not free env, as putenv has control of it */
block|}
if|if
condition|(
name|rcsbin_update_env
condition|)
block|{
name|char
modifier|*
name|env
decl_stmt|;
name|env
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|RCSBIN_ENV
argument_list|)
operator|+
name|strlen
argument_list|(
name|Rcsbin
argument_list|)
operator|+
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|env
argument_list|,
literal|"%s=%s"
argument_list|,
name|RCSBIN_ENV
argument_list|,
name|Rcsbin
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
comment|/* do not free env, as putenv has control of it */
block|}
endif|#
directive|endif
comment|/*      * If Rcsbin is set to something, make sure it is terminated with      * a slash character.  If not, add one.      */
if|if
condition|(
operator|*
name|Rcsbin
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|Rcsbin
argument_list|)
decl_stmt|;
name|char
modifier|*
name|rcsbin
decl_stmt|;
if|if
condition|(
name|Rcsbin
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
block|{
name|rcsbin
operator|=
name|Rcsbin
expr_stmt|;
name|Rcsbin
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* one for '/', one for NULL */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|Rcsbin
argument_list|,
name|rcsbin
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|Rcsbin
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|cm
operator|=
name|cmds
init|;
name|cm
operator|->
name|fullname
condition|;
name|cm
operator|++
control|)
block|{
if|if
condition|(
name|cm
operator|->
name|nick1
operator|&&
operator|!
name|strcmp
argument_list|(
name|cp
argument_list|,
name|cm
operator|->
name|nick1
argument_list|)
condition|)
break|break;
if|if
condition|(
name|cm
operator|->
name|nick2
operator|&&
operator|!
name|strcmp
argument_list|(
name|cp
argument_list|,
name|cm
operator|->
name|nick2
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cp
argument_list|,
name|cm
operator|->
name|fullname
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|cm
operator|->
name|fullname
condition|)
name|usage
argument_list|(
name|usg
argument_list|)
expr_stmt|;
comment|/* no match */
else|else
block|{
name|command_name
operator|=
name|cm
operator|->
name|fullname
expr_stmt|;
comment|/* Global pointer for later use */
comment|/* make sure we clean up on error */
ifdef|#
directive|ifdef
name|SIGHUP
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGHUP
argument_list|,
name|main_cleanup
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGHUP
argument_list|,
name|Lock_Cleanup
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGINT
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGINT
argument_list|,
name|main_cleanup
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGINT
argument_list|,
name|Lock_Cleanup
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGQUIT
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGQUIT
argument_list|,
name|main_cleanup
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGQUIT
argument_list|,
name|Lock_Cleanup
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGPIPE
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGPIPE
argument_list|,
name|main_cleanup
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGPIPE
argument_list|,
name|Lock_Cleanup
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTERM
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGTERM
argument_list|,
name|main_cleanup
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGTERM
argument_list|,
name|Lock_Cleanup
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|gethostname
argument_list|(
name|hostname
argument_list|,
sizeof|sizeof
argument_list|(
name|hostname
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SETVBUF
comment|/* 	 * Make stdout line buffered, so 'tail -f' can monitor progress. 	 * Patch creates too much output to monitor and it runs slowly. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|cm
operator|->
name|fullname
argument_list|,
literal|"patch"
argument_list|)
condition|)
operator|(
name|void
operator|)
name|setvbuf
argument_list|(
name|stdout
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|_IOLBF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|use_cvsrc
condition|)
name|read_cvsrc
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|,
name|command_name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
comment|/* If cvsroot contains a colon, try to do it via the protocol.  */
block|{
name|char
modifier|*
name|p
init|=
name|CVSroot
operator|==
name|NULL
condition|?
name|NULL
else|:
name|strchr
argument_list|(
name|CVSroot
argument_list|,
literal|':'
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
name|err
operator|=
operator|(
operator|*
operator|(
name|cm
operator|->
name|client_func
operator|)
operator|)
operator|(
name|argc
operator|,
name|argv
operator|)
expr_stmt|;
else|else
name|err
operator|=
operator|(
operator|*
operator|(
name|cm
operator|->
name|func
operator|)
operator|)
operator|(
name|argc
operator|,
name|argv
operator|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* No CLIENT_SUPPORT */
name|err
operator|=
operator|(
operator|*
operator|(
name|cm
operator|->
name|func
operator|)
operator|)
operator|(
name|argc
operator|,
name|argv
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* No CLIENT_SUPPORT */
block|}
name|Lock_Cleanup
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|EXIT_FAILURE
operator|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|Make_Date
parameter_list|(
name|rawdate
parameter_list|)
name|char
modifier|*
name|rawdate
decl_stmt|;
block|{
name|struct
name|tm
modifier|*
name|ftm
decl_stmt|;
name|time_t
name|unixtime
decl_stmt|;
name|char
name|date
index|[
literal|256
index|]
decl_stmt|;
comment|/* XXX bigger than we'll ever need? */
name|char
modifier|*
name|ret
decl_stmt|;
name|unixtime
operator|=
name|get_date
argument_list|(
name|rawdate
argument_list|,
operator|(
expr|struct
name|timeb
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|unixtime
operator|==
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Can't parse date/time: %s"
argument_list|,
name|rawdate
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_RCS5
name|ftm
operator|=
name|gmtime
argument_list|(
operator|&
name|unixtime
argument_list|)
expr_stmt|;
else|#
directive|else
name|ftm
operator|=
name|localtime
argument_list|(
operator|&
name|unixtime
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|date
argument_list|,
name|DATEFORM
argument_list|,
name|ftm
operator|->
name|tm_year
operator|+
operator|(
name|ftm
operator|->
name|tm_year
operator|<
literal|100
condition|?
literal|0
else|:
literal|1900
operator|)
argument_list|,
name|ftm
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|ftm
operator|->
name|tm_mday
argument_list|,
name|ftm
operator|->
name|tm_hour
argument_list|,
name|ftm
operator|->
name|tm_min
argument_list|,
name|ftm
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
name|ret
operator|=
name|xstrdup
argument_list|(
name|date
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|usage
parameter_list|(
name|cpp
parameter_list|)
specifier|register
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|cpp
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
operator|*
name|cpp
operator|++
argument_list|,
name|program_name
argument_list|,
name|command_name
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|cpp
condition|;
name|cpp
operator|++
control|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

