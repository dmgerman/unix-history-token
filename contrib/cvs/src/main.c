begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *    Copyright (c) 1992, Brian Berliner and Jeff Polk  *    Copyright (c) 1989-1992, Brian Berliner  *  *    You may distribute under the terms of the GNU General Public License  *    as specified in the README file that comes with the CVS source distribution.  *  * This is the main C driver for the CVS system.  *  * Credit to Dick Grune, Vrije Universiteit, Amsterdam, for writing  * the shell-script CVS system that this is based on.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"prepend_args.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_WINSOCK_H
end_ifdef

begin_include
include|#
directive|include
file|<winsock.h>
end_include

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|int
name|gethostname
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|const
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|program_path
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|cvs_cmd_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* I'd dynamically allocate this, but it seems like gethostname    requires a fixed size array.  If I'm remembering the RFCs right,    256 should be enough.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAXHOSTNAMELEN
end_ifndef

begin_define
define|#
directive|define
name|MAXHOSTNAMELEN
value|256
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|hostname
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|use_editor
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|use_cvsrc
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cvswrite
init|=
operator|!
name|CVSREAD_DFLT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|really_quiet
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|quiet
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|trace
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|noexec
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|readonlyfs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|require_real_user
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|logoff
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set if we should be writing CVSADM directories at top level.  At    least for now we'll make the default be off (the CVS 1.9, not CVS    1.9.2, behavior). */
end_comment

begin_decl_stmt
name|int
name|top_level_admin
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|mode_t
name|cvsumask
init|=
name|UMASK_DFLT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|CurDir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Defaults, for the environment variables that are not set  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Tmpdir
init|=
name|TMPDIR_DFLT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Editor
init|=
name|EDITOR_DFLT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When our working directory contains subdirectories with different    values in CVS/Root files, we maintain a list of them.  */
end_comment

begin_decl_stmt
name|List
modifier|*
name|root_directories
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We step through the above values.  This variable is set to reflect  * the currently active value.  *  * Now static.  FIXME - this variable should be removable (well, localizable)  * with a little more work.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|current_root
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
specifier|const
struct|struct
name|cmd
block|{
name|char
modifier|*
name|fullname
decl_stmt|;
comment|/* Full name of the function (e.g. "commit") */
comment|/* Synonyms for the command, nick1 and nick2.  We supply them        mostly for two reasons: (1) CVS has always supported them, and        we need to maintain compatibility, (2) if there is a need for a        version which is shorter than the fullname, for ease in typing.        Synonyms have the disadvantage that people will see "new" and        then have to think about it, or look it up, to realize that is        the operation they know as "add".  Also, this means that one        cannot create a command "cvs new" with a different meaning.  So        new synonyms are probably best used sparingly, and where used        should be abbreviations of the fullname (preferably consisting        of the first 2 or 3 or so letters).         One thing that some systems do is to recognize any unique        abbreviation, for example "annotat" "annota", etc., for        "annotate".  The problem with this is that scripts and user        habits will expect a certain abbreviation to be unique, and in        a future release of CVS it may not be.  So it is better to        accept only an explicit list of abbreviations and plan on        supporting them in the future as well as now.  */
name|char
modifier|*
name|nick1
decl_stmt|;
name|char
modifier|*
name|nick2
decl_stmt|;
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
comment|/* Function takes (argc, argv) arguments. */
name|unsigned
name|long
name|attr
decl_stmt|;
comment|/* Attributes. */
block|}
name|cmds
index|[]
init|=
block|{
block|{
literal|"add"
block|,
literal|"ad"
block|,
literal|"new"
block|,
name|add
block|,
name|CVS_CMD_MODIFIES_REPOSITORY
operator||
name|CVS_CMD_USES_WORK_DIR
block|}
block|,
block|{
literal|"admin"
block|,
literal|"adm"
block|,
literal|"rcs"
block|,
name|admin
block|,
name|CVS_CMD_MODIFIES_REPOSITORY
operator||
name|CVS_CMD_USES_WORK_DIR
block|}
block|,
block|{
literal|"annotate"
block|,
literal|"ann"
block|,
literal|"blame"
block|,
name|annotate
block|,
name|CVS_CMD_USES_WORK_DIR
block|}
block|,
block|{
literal|"checkout"
block|,
literal|"co"
block|,
literal|"get"
block|,
name|checkout
block|,
literal|0
block|}
block|,
block|{
literal|"commit"
block|,
literal|"ci"
block|,
literal|"com"
block|,
name|commit
block|,
name|CVS_CMD_MODIFIES_REPOSITORY
operator||
name|CVS_CMD_USES_WORK_DIR
block|}
block|,
block|{
literal|"diff"
block|,
literal|"di"
block|,
literal|"dif"
block|,
name|diff
block|,
name|CVS_CMD_USES_WORK_DIR
block|}
block|,
block|{
literal|"edit"
block|,
name|NULL
block|,
name|NULL
block|,
name|edit
block|,
name|CVS_CMD_MODIFIES_REPOSITORY
operator||
name|CVS_CMD_USES_WORK_DIR
block|}
block|,
block|{
literal|"editors"
block|,
name|NULL
block|,
name|NULL
block|,
name|editors
block|,
name|CVS_CMD_USES_WORK_DIR
block|}
block|,
block|{
literal|"export"
block|,
literal|"exp"
block|,
literal|"ex"
block|,
name|checkout
block|,
name|CVS_CMD_USES_WORK_DIR
block|}
block|,
block|{
literal|"history"
block|,
literal|"hi"
block|,
literal|"his"
block|,
name|history
block|,
name|CVS_CMD_USES_WORK_DIR
block|}
block|,
block|{
literal|"import"
block|,
literal|"im"
block|,
literal|"imp"
block|,
name|import
block|,
name|CVS_CMD_MODIFIES_REPOSITORY
operator||
name|CVS_CMD_USES_WORK_DIR
operator||
name|CVS_CMD_IGNORE_ADMROOT
block|}
block|,
block|{
literal|"init"
block|,
name|NULL
block|,
name|NULL
block|,
name|init
block|,
name|CVS_CMD_MODIFIES_REPOSITORY
block|}
block|,
if|#
directive|if
name|defined
argument_list|(
name|HAVE_KERBEROS
argument_list|)
operator|&&
name|defined
argument_list|(
name|SERVER_SUPPORT
argument_list|)
block|{
literal|"kserver"
block|,
name|NULL
block|,
name|NULL
block|,
name|server
block|,
name|CVS_CMD_MODIFIES_REPOSITORY
operator||
name|CVS_CMD_USES_WORK_DIR
block|}
block|,
comment|/* placeholder */
endif|#
directive|endif
block|{
literal|"log"
block|,
literal|"lo"
block|,
name|NULL
block|,
name|cvslog
block|,
name|CVS_CMD_USES_WORK_DIR
block|}
block|,
ifdef|#
directive|ifdef
name|AUTH_CLIENT_SUPPORT
block|{
literal|"login"
block|,
literal|"logon"
block|,
literal|"lgn"
block|,
name|login
block|,
literal|0
block|}
block|,
block|{
literal|"logout"
block|,
name|NULL
block|,
name|NULL
block|,
name|logout
block|,
literal|0
block|}
block|,
endif|#
directive|endif
comment|/* AUTH_CLIENT_SUPPORT */
if|#
directive|if
operator|(
name|defined
argument_list|(
name|AUTH_SERVER_SUPPORT
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_GSSAPI
argument_list|)
operator|)
operator|&&
name|defined
argument_list|(
name|SERVER_SUPPORT
argument_list|)
block|{
literal|"pserver"
block|,
name|NULL
block|,
name|NULL
block|,
name|server
block|,
name|CVS_CMD_MODIFIES_REPOSITORY
operator||
name|CVS_CMD_USES_WORK_DIR
block|}
block|,
comment|/* placeholder */
endif|#
directive|endif
block|{
literal|"rannotate"
block|,
literal|"rann"
block|,
literal|"ra"
block|,
name|annotate
block|,
literal|0
block|}
block|,
block|{
literal|"rdiff"
block|,
literal|"patch"
block|,
literal|"pa"
block|,
name|patch
block|,
literal|0
block|}
block|,
block|{
literal|"release"
block|,
literal|"re"
block|,
literal|"rel"
block|,
name|release
block|,
literal|0
block|}
block|,
block|{
literal|"remove"
block|,
literal|"rm"
block|,
literal|"delete"
block|,
name|cvsremove
block|,
name|CVS_CMD_MODIFIES_REPOSITORY
operator||
name|CVS_CMD_USES_WORK_DIR
block|}
block|,
block|{
literal|"rlog"
block|,
literal|"rl"
block|,
name|NULL
block|,
name|cvslog
block|,
literal|0
block|}
block|,
block|{
literal|"rtag"
block|,
literal|"rt"
block|,
literal|"rfreeze"
block|,
name|cvstag
block|,
name|CVS_CMD_MODIFIES_REPOSITORY
block|}
block|,
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
block|{
literal|"server"
block|,
name|NULL
block|,
name|NULL
block|,
name|server
block|,
name|CVS_CMD_MODIFIES_REPOSITORY
operator||
name|CVS_CMD_USES_WORK_DIR
block|}
block|,
endif|#
directive|endif
block|{
literal|"status"
block|,
literal|"st"
block|,
literal|"stat"
block|,
name|cvsstatus
block|,
name|CVS_CMD_USES_WORK_DIR
block|}
block|,
block|{
literal|"tag"
block|,
literal|"ta"
block|,
literal|"freeze"
block|,
name|cvstag
block|,
name|CVS_CMD_MODIFIES_REPOSITORY
operator||
name|CVS_CMD_USES_WORK_DIR
block|}
block|,
block|{
literal|"unedit"
block|,
name|NULL
block|,
name|NULL
block|,
name|unedit
block|,
name|CVS_CMD_MODIFIES_REPOSITORY
operator||
name|CVS_CMD_USES_WORK_DIR
block|}
block|,
block|{
literal|"update"
block|,
literal|"up"
block|,
literal|"upd"
block|,
name|update
block|,
name|CVS_CMD_USES_WORK_DIR
block|}
block|,
block|{
literal|"version"
block|,
literal|"ve"
block|,
literal|"ver"
block|,
name|version
block|,
literal|0
block|}
block|,
block|{
literal|"watch"
block|,
name|NULL
block|,
name|NULL
block|,
name|watch
block|,
name|CVS_CMD_MODIFIES_REPOSITORY
operator||
name|CVS_CMD_USES_WORK_DIR
block|}
block|,
block|{
literal|"watchers"
block|,
name|NULL
block|,
name|NULL
block|,
name|watchers
block|,
name|CVS_CMD_USES_WORK_DIR
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|, }
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|usg
index|[]
init|=
block|{
comment|/* CVS usage messages never have followed the GNU convention of        putting metavariables in uppercase.  I don't know whether that        is a good convention or not, but if it changes it would have to        change in all the usage messages.  For now, they consistently        use lowercase, as far as I know.  Punctuation is pretty funky,        though.  Sometimes they use none, as here.  Sometimes they use        single quotes (not the TeX-ish `' stuff), as in --help-options.        Sometimes they use double quotes, as in cvs -H add.         Most (not all) of the usage messages seem to have periods at        the end of each line.  I haven't tried to duplicate this style        in --help as it is a rather different format from the rest.  */
literal|"Usage: %s [cvs-options] command [command-options-and-arguments]\n"
block|,
literal|"  where cvs-options are -q, -n, etc.\n"
block|,
literal|"    (specify --help-options for a list of options)\n"
block|,
literal|"  where command is add, admin, etc.\n"
block|,
literal|"    (specify --help-commands for a list of commands\n"
block|,
literal|"     or --help-synonyms for a list of command synonyms)\n"
block|,
literal|"  where command-options-and-arguments depend on the specific command\n"
block|,
literal|"    (specify -H followed by a command name for command-specific help)\n"
block|,
literal|"  Specify --help to receive this message\n"
block|,
literal|"\n"
block|,
comment|/* Some people think that a bug-reporting address should go here.  IMHO,        the web sites are better because anything else is very likely to go        obsolete in the years between a release and when someone might be        reading this help.  Besides, we could never adequately discuss        bug reporting in a concise enough way to put in a help message.  */
comment|/* I was going to put this at the top, but usage() wants the %s to        be in the first line.  */
literal|"The Concurrent Versions System (CVS) is a tool for version control.\n"
block|,
comment|/* I really don't think I want to try to define "version control"        in one line.  I'm not sure one can get more concise than the        paragraph in ../cvs.spec without assuming the reader knows what        version control means.  */
literal|"For CVS updates and additional information, see\n"
block|,
literal|"    the CVS home page at http://www.cvshome.org/ or\n"
block|,
literal|"    Pascal Molli's CVS site at http://www.loria.fr/~molli/cvs-index.html\n"
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|cmd_usage
index|[]
init|=
block|{
literal|"CVS commands are:\n"
block|,
literal|"        add          Add a new file/directory to the repository\n"
block|,
literal|"        admin        Administration front end for rcs\n"
block|,
literal|"        annotate     Show last revision where each line was modified\n"
block|,
literal|"        checkout     Checkout sources for editing\n"
block|,
literal|"        commit       Check files into the repository\n"
block|,
literal|"        diff         Show differences between revisions\n"
block|,
literal|"        edit         Get ready to edit a watched file\n"
block|,
literal|"        editors      See who is editing a watched file\n"
block|,
literal|"        export       Export sources from CVS, similar to checkout\n"
block|,
literal|"        history      Show repository access history\n"
block|,
literal|"        import       Import sources into CVS, using vendor branches\n"
block|,
literal|"        init         Create a CVS repository if it doesn't exist\n"
block|,
if|#
directive|if
name|defined
argument_list|(
name|HAVE_KERBEROS
argument_list|)
operator|&&
name|defined
argument_list|(
name|SERVER_SUPPORT
argument_list|)
literal|"        kserver      Kerberos server mode\n"
block|,
endif|#
directive|endif
literal|"        log          Print out history information for files\n"
block|,
ifdef|#
directive|ifdef
name|AUTH_CLIENT_SUPPORT
literal|"        login        Prompt for password for authenticating server\n"
block|,
literal|"        logout       Removes entry in .cvspass for remote repository\n"
block|,
endif|#
directive|endif
comment|/* AUTH_CLIENT_SUPPORT */
if|#
directive|if
operator|(
name|defined
argument_list|(
name|AUTH_SERVER_SUPPORT
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_GSSAPI
argument_list|)
operator|)
operator|&&
name|defined
argument_list|(
name|SERVER_SUPPORT
argument_list|)
literal|"        pserver      Password server mode\n"
block|,
endif|#
directive|endif
literal|"        rannotate    Show last revision where each line of module was modified\n"
block|,
literal|"        rdiff        Create 'patch' format diffs between releases\n"
block|,
literal|"        release      Indicate that a Module is no longer in use\n"
block|,
literal|"        remove       Remove an entry from the repository\n"
block|,
literal|"        rlog         Print out history information for a module\n"
block|,
literal|"        rtag         Add a symbolic tag to a module\n"
block|,
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
literal|"        server       Server mode\n"
block|,
endif|#
directive|endif
literal|"        status       Display status information on checked out files\n"
block|,
literal|"        tag          Add a symbolic tag to checked out version of files\n"
block|,
literal|"        unedit       Undo an edit command\n"
block|,
literal|"        update       Bring work tree in sync with repository\n"
block|,
literal|"        version      Show current CVS version(s)\n"
block|,
literal|"        watch        Set watches\n"
block|,
literal|"        watchers     See who is watching a file\n"
block|,
literal|"(Specify the --help option for a list of other help options)\n"
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|opt_usage
index|[]
init|=
block|{
comment|/* Omit -b because it is just for compatibility.  */
literal|"CVS global options (specified before the command name) are:\n"
block|,
literal|"    -H           Displays usage information for command.\n"
block|,
literal|"    -Q           Cause CVS to be really quiet.\n"
block|,
literal|"    -q           Cause CVS to be somewhat quiet.\n"
block|,
literal|"    -r           Make checked-out files read-only.\n"
block|,
literal|"    -w           Make checked-out files read-write (default).\n"
block|,
literal|"    -g           Force group-write perms on checked-out files.\n"
block|,
literal|"    -n           Do not execute anything that will change the disk.\n"
block|,
literal|"    -t           Show trace of program execution -- try with -n.\n"
block|,
literal|"    -R           Assume repository is read-only, such as CDROM\n"
block|,
literal|"    -v           CVS version and copyright.\n"
block|,
literal|"    -T tmpdir    Use 'tmpdir' for temporary files.\n"
block|,
literal|"    -e editor    Use 'editor' for editing log information.\n"
block|,
literal|"    -d CVS_root  Overrides $CVSROOT as the root of the CVS tree.\n"
block|,
literal|"    -f           Do not use the ~/.cvsrc file.\n"
block|,
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
literal|"    -z #         Use compression level '#' for net traffic.\n"
block|,
ifdef|#
directive|ifdef
name|ENCRYPTION
literal|"    -x           Encrypt all net traffic.\n"
block|,
endif|#
directive|endif
literal|"    -a           Authenticate all net traffic.\n"
block|,
endif|#
directive|endif
literal|"    -s VAR=VAL   Set CVS user variable.\n"
block|,
literal|"(Specify the --help option for a list of other help options)\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|set_root_directory
parameter_list|(
name|p
parameter_list|,
name|ignored
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|ignored
decl_stmt|;
block|{
if|if
condition|(
name|current_root
operator|==
name|NULL
operator|&&
name|p
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|current_root
operator|=
name|p
operator|->
name|key
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|cmd_synonyms
parameter_list|()
block|{
name|char
modifier|*
modifier|*
name|synonyms
decl_stmt|;
name|char
modifier|*
modifier|*
name|line
decl_stmt|;
specifier|const
name|struct
name|cmd
modifier|*
name|c
init|=
operator|&
name|cmds
index|[
literal|0
index|]
decl_stmt|;
comment|/* Three more for title, "specify --help" line, and NULL.  */
name|int
name|numcmds
init|=
literal|3
decl_stmt|;
while|while
condition|(
name|c
operator|->
name|fullname
operator|!=
name|NULL
condition|)
block|{
name|numcmds
operator|++
expr_stmt|;
name|c
operator|++
expr_stmt|;
block|}
name|synonyms
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|numcmds
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|line
operator|=
name|synonyms
expr_stmt|;
operator|*
name|line
operator|++
operator|=
literal|"CVS command synonyms are:\n"
expr_stmt|;
for|for
control|(
name|c
operator|=
operator|&
name|cmds
index|[
literal|0
index|]
init|;
name|c
operator|->
name|fullname
operator|!=
name|NULL
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|->
name|nick1
operator|||
name|c
operator|->
name|nick2
condition|)
block|{
operator|*
name|line
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|c
operator|->
name|fullname
argument_list|)
operator|+
operator|(
name|c
operator|->
name|nick1
operator|!=
name|NULL
condition|?
name|strlen
argument_list|(
name|c
operator|->
name|nick1
argument_list|)
else|:
literal|0
operator|)
operator|+
operator|(
name|c
operator|->
name|nick2
operator|!=
name|NULL
condition|?
name|strlen
argument_list|(
name|c
operator|->
name|nick2
argument_list|)
else|:
literal|0
operator|)
operator|+
literal|40
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|*
name|line
argument_list|,
literal|"        %-12s %s %s\n"
argument_list|,
name|c
operator|->
name|fullname
argument_list|,
name|c
operator|->
name|nick1
condition|?
name|c
operator|->
name|nick1
else|:
literal|""
argument_list|,
name|c
operator|->
name|nick2
condition|?
name|c
operator|->
name|nick2
else|:
literal|""
argument_list|)
expr_stmt|;
name|line
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|line
operator|++
operator|=
literal|"(Specify the --help option for a list of other help options)\n"
expr_stmt|;
operator|*
name|line
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
specifier|const
name|char
operator|*
specifier|const
operator|*
operator|)
name|synonyms
return|;
comment|/* will never be freed */
block|}
end_function

begin_function
name|unsigned
name|long
name|int
name|lookup_command_attribute
parameter_list|(
name|cmd_name
parameter_list|)
name|char
modifier|*
name|cmd_name
decl_stmt|;
block|{
specifier|const
name|struct
name|cmd
modifier|*
name|cm
decl_stmt|;
for|for
control|(
name|cm
operator|=
name|cmds
init|;
name|cm
operator|->
name|fullname
condition|;
name|cm
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|cmd_name
argument_list|,
name|cm
operator|->
name|fullname
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|cm
operator|->
name|fullname
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"unknown command: %s"
argument_list|,
name|cmd_name
argument_list|)
expr_stmt|;
return|return
name|cm
operator|->
name|attr
return|;
block|}
end_function

begin_function
specifier|static
name|RETSIGTYPE
name|main_cleanup
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|DONT_USE_SIGNALS
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|temp
index|[
literal|10
index|]
decl_stmt|;
switch|switch
condition|(
name|sig
condition|)
block|{
ifdef|#
directive|ifdef
name|SIGABRT
case|case
name|SIGABRT
case|:
name|name
operator|=
literal|"abort"
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGHUP
case|case
name|SIGHUP
case|:
name|name
operator|=
literal|"hangup"
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGINT
case|case
name|SIGINT
case|:
name|name
operator|=
literal|"interrupt"
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGQUIT
case|case
name|SIGQUIT
case|:
name|name
operator|=
literal|"quit"
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGPIPE
case|case
name|SIGPIPE
case|:
name|name
operator|=
literal|"broken pipe"
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTERM
case|case
name|SIGTERM
case|:
name|name
operator|=
literal|"termination"
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
comment|/* This case should never be reached, because we list above all 	   the signals for which we actually establish a signal handler.  */
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%d"
argument_list|,
name|sig
argument_list|)
expr_stmt|;
name|name
operator|=
name|temp
expr_stmt|;
break|break;
block|}
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"received %s signal"
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !DONT_USE_SIGNALS */
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|CVSroot
init|=
name|CVSROOT_DFLT
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|end
decl_stmt|;
specifier|const
name|struct
name|cmd
modifier|*
name|cm
decl_stmt|;
name|int
name|c
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
name|int
name|tmpdir_update_env
decl_stmt|,
name|cvs_update_env
decl_stmt|;
name|int
name|free_CVSroot
init|=
literal|0
decl_stmt|;
name|int
name|free_Editor
init|=
literal|0
decl_stmt|;
name|int
name|free_Tmpdir
init|=
literal|0
decl_stmt|;
name|int
name|help
init|=
literal|0
decl_stmt|;
comment|/* Has the user asked for help?  This 				   lets us support the `cvs -H cmd' 				   convention to give help for cmd. */
specifier|static
specifier|const
name|char
name|short_options
index|[]
init|=
literal|"+QqgrwtnRvb:T:e:d:Hfz:s:xaU"
decl_stmt|;
specifier|static
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"help"
block|,
literal|0
block|,
name|NULL
block|,
literal|'H'
block|}
block|,
block|{
literal|"version"
block|,
literal|0
block|,
name|NULL
block|,
literal|'v'
block|}
block|,
block|{
literal|"help-commands"
block|,
literal|0
block|,
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"help-synonyms"
block|,
literal|0
block|,
name|NULL
block|,
literal|2
block|}
block|,
block|{
literal|"help-options"
block|,
literal|0
block|,
name|NULL
block|,
literal|4
block|}
block|,
block|{
literal|"allow-root"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|3
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
comment|/* `getopt_long' stores the option index here, but right now we         don't use it. */
name|int
name|option_index
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|SYSTEM_INITIALIZE
comment|/* Hook for OS-specific behavior, for example socket subsystems on        NT and OS2 or dealing with windows and arguments on Mac.  */
name|SYSTEM_INITIALIZE
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_TZSET
comment|/* On systems that have tzset (which is almost all the ones I know        of), it's a good idea to call it.  */
name|tzset
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/*      * Just save the last component of the path for error messages      */
name|program_path
operator|=
name|xstrdup
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ARGV0_NOT_PROGRAM_NAME
comment|/* On some systems, e.g. VMS, argv[0] is not the name of the command        which the user types to invoke the program.  */
name|program_name
operator|=
literal|"cvs"
expr_stmt|;
else|#
directive|else
name|program_name
operator|=
name|last_component
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*      * Query the environment variables up-front, so that      * they can be overridden by command line arguments      */
name|cvs_update_env
operator|=
literal|0
expr_stmt|;
name|tmpdir_update_env
operator|=
operator|*
name|Tmpdir
expr_stmt|;
comment|/* TMPDIR_DFLT must be set */
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
name|TMPDIR_ENV
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|Tmpdir
operator|=
name|cp
expr_stmt|;
name|tmpdir_update_env
operator|=
literal|0
expr_stmt|;
comment|/* it's already there */
block|}
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
name|EDITOR1_ENV
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|Editor
operator|=
name|cp
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
name|EDITOR2_ENV
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|Editor
operator|=
name|cp
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
name|EDITOR3_ENV
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|Editor
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
name|CVSROOT_ENV
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|CVSroot
operator|=
name|cp
expr_stmt|;
name|cvs_update_env
operator|=
literal|0
expr_stmt|;
comment|/* it's already there */
block|}
if|if
condition|(
name|getenv
argument_list|(
name|CVSREAD_ENV
argument_list|)
operator|!=
name|NULL
condition|)
name|cvswrite
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|getenv
argument_list|(
name|CVSREADONLYFS_ENV
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|readonlyfs
operator|=
literal|1
expr_stmt|;
name|logoff
operator|=
literal|1
expr_stmt|;
block|}
name|prepend_default_options
argument_list|(
name|getenv
argument_list|(
literal|"CVS_OPTIONS"
argument_list|)
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
comment|/* Set this to 0 to force getopt initialization.  getopt() sets        this to 1 internally.  */
name|optind
operator|=
literal|0
expr_stmt|;
comment|/* We have to parse the options twice because else there is no        chance to avoid reading the global options from ".cvsrc".  Set        opterr to 0 for avoiding error messages about invalid options.        */
name|opterr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|short_options
argument_list|,
name|long_options
argument_list|,
operator|&
name|option_index
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'f'
condition|)
name|use_cvsrc
operator|=
literal|0
expr_stmt|;
block|}
comment|/*      * Scan cvsrc file for global options.      */
if|if
condition|(
name|use_cvsrc
condition|)
name|read_cvsrc
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|,
literal|"cvs"
argument_list|)
expr_stmt|;
name|optind
operator|=
literal|0
expr_stmt|;
name|opterr
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|short_options
argument_list|,
name|long_options
argument_list|,
operator|&
name|option_index
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|1
case|:
comment|/* --help-commands */
name|usage
argument_list|(
name|cmd_usage
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* --help-synonyms */
name|usage
argument_list|(
name|cmd_synonyms
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* --help-options */
name|usage
argument_list|(
name|opt_usage
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* --allow-root */
name|root_allow_add
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
name|really_quiet
operator|=
literal|1
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|'q'
case|:
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|cvswrite
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|cvswrite
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
comment|/* 		 * force full group write perms (used for shared checked-out 		 * source trees, see manual page) 		 */
name|umask
argument_list|(
name|umask
argument_list|(
literal|077
argument_list|)
operator|&
literal|007
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|trace
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|readonlyfs
operator|=
literal|1
expr_stmt|;
name|logoff
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|noexec
operator|=
literal|1
expr_stmt|;
name|logoff
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|version
argument_list|(
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"\ Copyright (c) 1989-2004 Brian Berliner, david d `zoo' zuhn, \n\                         Jeff Polk, and other authors\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"CVS may be copied only under the terms of the GNU General Public License,\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"a copy of which can be found with the CVS distribution kit.\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"Specify the --help option for further information about CVS\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* This option used to specify the directory for RCS 		   executables.  But since we don't run them any more, 		   this is a noop.  Silently ignore it so that .cvsrc 		   and scripts and inetd.conf and such can work with 		   either new or old CVS.  */
break|break;
case|case
literal|'T'
case|:
name|Tmpdir
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|free_Tmpdir
operator|=
literal|1
expr_stmt|;
name|tmpdir_update_env
operator|=
literal|1
expr_stmt|;
comment|/* need to update environment */
break|break;
case|case
literal|'e'
case|:
name|Editor
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|free_Editor
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|CVSroot_cmdline
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|CVSroot_cmdline
argument_list|)
expr_stmt|;
name|CVSroot_cmdline
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_CVSroot
condition|)
name|free
argument_list|(
name|CVSroot
argument_list|)
expr_stmt|;
name|CVSroot
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|free_CVSroot
operator|=
literal|1
expr_stmt|;
name|cvs_update_env
operator|=
literal|1
expr_stmt|;
comment|/* need to update environment */
break|break;
case|case
literal|'H'
case|:
name|help
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|use_cvsrc
operator|=
literal|0
expr_stmt|;
comment|/* unnecessary, since we've done it above */
break|break;
case|case
literal|'z'
case|:
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
name|gzip_level
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|!=
literal|'\0'
operator|||
name|gzip_level
operator|<
literal|0
operator|||
name|gzip_level
operator|>
literal|9
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"gzip compression level must be between 0 and 9"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CLIENT_SUPPORT */
comment|/* If no CLIENT_SUPPORT, we just silently ignore the gzip 		 * level, so that users can have it in their .cvsrc and not 		 * cause any trouble. 		 * 		 * We still parse the argument to -z for correctness since 		 * one user complained of being bitten by a run of 		 * `cvs -z -n up' which read -n as the argument to -z without 		 * complaining.  */
break|break;
case|case
literal|'s'
case|:
name|variable_set
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
name|cvsencrypt
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* CLIENT_SUPPORT */
comment|/* If no CLIENT_SUPPORT, ignore -x, so that users can                    have it in their .cvsrc and not cause any trouble.                    If no ENCRYPTION, we still accept -x, but issue an                    error if we are being run as a client.  */
break|break;
case|case
literal|'a'
case|:
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
name|cvsauthenticate
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* If no CLIENT_SUPPORT, ignore -a, so that users can                    have it in their .cvsrc and not cause any trouble.                    We will issue an error later if stream                    authentication is not supported.  */
break|break;
case|case
literal|'U'
case|:
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
name|require_real_user
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
name|usg
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
name|usage
argument_list|(
name|usg
argument_list|)
expr_stmt|;
comment|/* Look up the command name. */
name|cvs_cmd_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|cm
operator|=
name|cmds
init|;
name|cm
operator|->
name|fullname
condition|;
name|cm
operator|++
control|)
block|{
if|if
condition|(
name|cm
operator|->
name|nick1
operator|&&
operator|!
name|strcmp
argument_list|(
name|cvs_cmd_name
argument_list|,
name|cm
operator|->
name|nick1
argument_list|)
condition|)
break|break;
if|if
condition|(
name|cm
operator|->
name|nick2
operator|&&
operator|!
name|strcmp
argument_list|(
name|cvs_cmd_name
argument_list|,
name|cm
operator|->
name|nick2
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cvs_cmd_name
argument_list|,
name|cm
operator|->
name|fullname
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|cm
operator|->
name|fullname
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown command: `%s'\n\n"
argument_list|,
name|cvs_cmd_name
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|cmd_usage
argument_list|)
expr_stmt|;
block|}
else|else
name|cvs_cmd_name
operator|=
name|cm
operator|->
name|fullname
expr_stmt|;
comment|/* Global pointer for later use */
if|if
condition|(
name|help
condition|)
block|{
name|argc
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* some functions only check for this */
name|err
operator|=
operator|(
operator|*
operator|(
name|cm
operator|->
name|func
operator|)
operator|)
operator|(
name|argc
operator|,
name|argv
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The user didn't ask for help, so go ahead and authenticate,            set up CVSROOT, and the rest of it. */
comment|/* The UMASK environment variable isn't handled with the 	   others above, since we don't want to signal errors if the 	   user has asked for help.  This won't work if somebody adds 	   a command-line flag to set the umask, since we'll have to 	   parse it before we get here. */
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
name|CVSUMASK_ENV
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* FIXME: Should be accepting symbolic as well as numeric mask.  */
name|cvsumask
operator|=
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|end
argument_list|,
literal|8
argument_list|)
operator|&
literal|0777
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|!=
literal|'\0'
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"invalid umask value in %s (%s)"
argument_list|,
name|CVSUMASK_ENV
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
ifdef|#
directive|ifdef
name|HAVE_KERBEROS
comment|/* If we are invoked with a single argument "kserver", then we are 	   running as Kerberos server as root.  Do the authentication as 	   the very first thing, to minimize the amount of time we are 	   running as root.  */
if|if
condition|(
name|strcmp
argument_list|(
name|cvs_cmd_name
argument_list|,
literal|"kserver"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|kserver_authenticate_connection
argument_list|()
expr_stmt|;
comment|/* Pretend we were invoked as a plain server.  */
name|cvs_cmd_name
operator|=
literal|"server"
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_KERBEROS */
if|#
directive|if
name|defined
argument_list|(
name|AUTH_SERVER_SUPPORT
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_GSSAPI
argument_list|)
if|if
condition|(
name|strcmp
argument_list|(
name|cvs_cmd_name
argument_list|,
literal|"pserver"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* The reason that --allow-root is not a command option 	       is mainly the comment in server() about how argc,argv 	       might be from .cvsrc.  I'm not sure about that, and 	       I'm not sure it is only true of command options, but 	       it seems easier to make it a global option.  */
comment|/* Gets username and password from client, authenticates, then 	       switches to run as that user and sends an ACK back to the 	       client. */
name|pserver_authenticate_connection
argument_list|()
expr_stmt|;
comment|/* Pretend we were invoked as a plain server.  */
name|cvs_cmd_name
operator|=
literal|"server"
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* AUTH_SERVER_SUPPORT || HAVE_GSSAPI */
name|server_active
operator|=
name|strcmp
argument_list|(
name|cvs_cmd_name
argument_list|,
literal|"server"
argument_list|)
operator|==
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* SERVER_SUPPORT */
comment|/* This is only used for writing into the history file.  For 	   remote connections, it might be nice to have hostname 	   and/or remote path, on the other hand I'm not sure whether 	   it is worth the trouble.  */
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
name|CurDir
operator|=
name|xstrdup
argument_list|(
literal|"<remote>"
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
name|CurDir
operator|=
name|xgetwd
argument_list|()
expr_stmt|;
if|if
condition|(
name|CurDir
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot get working directory"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Tmpdir
operator|==
name|NULL
operator|||
name|Tmpdir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|Tmpdir
operator|=
literal|"/tmp"
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PUTENV
if|if
condition|(
name|tmpdir_update_env
condition|)
block|{
name|char
modifier|*
name|env
decl_stmt|;
name|env
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|TMPDIR_ENV
argument_list|)
operator|+
name|strlen
argument_list|(
name|Tmpdir
argument_list|)
operator|+
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|env
argument_list|,
literal|"%s=%s"
argument_list|,
name|TMPDIR_ENV
argument_list|,
name|Tmpdir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
comment|/* do not free env, as putenv has control of it */
block|}
block|{
name|char
modifier|*
name|env
decl_stmt|;
name|env
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
expr|"CVS_PID="
operator|+
literal|32
argument_list|)
expr_stmt|;
comment|/* XXX pid< 10^32 */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|env
argument_list|,
literal|"CVS_PID=%ld"
argument_list|,
operator|(
name|long
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|DONT_USE_SIGNALS
comment|/* make sure we clean up on error */
ifdef|#
directive|ifdef
name|SIGABRT
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGABRT
argument_list|,
name|main_cleanup
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGHUP
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGHUP
argument_list|,
name|main_cleanup
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGINT
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGINT
argument_list|,
name|main_cleanup
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGQUIT
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGQUIT
argument_list|,
name|main_cleanup
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGPIPE
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGPIPE
argument_list|,
name|main_cleanup
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTERM
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGTERM
argument_list|,
name|main_cleanup
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* !DONT_USE_SIGNALS */
name|gethostname
argument_list|(
name|hostname
argument_list|,
sizeof|sizeof
argument_list|(
name|hostname
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KLUDGE_FOR_WNT_TESTSUITE
comment|/* Probably the need for this will go away at some point once 	   we call fflush enough places (e.g. fflush (stdout) in 	   cvs_outerr).  */
operator|(
name|void
operator|)
name|setvbuf
argument_list|(
name|stdout
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|_IONBF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setvbuf
argument_list|(
name|stderr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|_IONBF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* KLUDGE_FOR_WNT_TESTSUITE */
if|if
condition|(
name|use_cvsrc
condition|)
name|read_cvsrc
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|,
name|cvs_cmd_name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
comment|/* Fiddling with CVSROOT doesn't make sense if we're running 	       in server mode, since the client will send the repository 	       directory after the connection is made. */
if|if
condition|(
operator|!
name|server_active
condition|)
endif|#
directive|endif
block|{
name|char
modifier|*
name|CVSADM_Root
decl_stmt|;
comment|/* See if we are able to find a 'better' value for CVSroot 	       in the CVSADM_ROOT directory. */
name|CVSADM_Root
operator|=
name|NULL
expr_stmt|;
comment|/* "cvs import" shouldn't check CVS/Root; in general it 	       ignores CVS directories and CVS/Root is likely to 	       specify a different repository than the one we are 	       importing to.  */
if|if
condition|(
operator|!
operator|(
name|cm
operator|->
name|attr
operator|&
name|CVS_CMD_IGNORE_ADMROOT
operator|)
comment|/* -d overrides CVS/Root, so don't give an error if the 		   latter points to a nonexistent repository.  */
operator|&&
name|CVSroot_cmdline
operator|==
name|NULL
condition|)
block|{
name|CVSADM_Root
operator|=
name|Name_Root
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CVSADM_Root
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|CVSroot
operator|==
name|NULL
operator|||
operator|!
name|cvs_update_env
condition|)
block|{
name|CVSroot
operator|=
name|CVSADM_Root
expr_stmt|;
name|cvs_update_env
operator|=
literal|1
expr_stmt|;
comment|/* need to update environment */
block|}
block|}
comment|/* Now we've reconciled CVSROOT from the command line, the 	       CVS/Root file, and the environment variable.  Do the 	       last sanity checks on the variable. */
if|if
condition|(
operator|!
name|CVSroot
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"No CVSROOT specified!  Please use the `-d' option"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"or set the %s environment variable."
argument_list|,
name|CVSROOT_ENV
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|CVSroot
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"CVSROOT is set but empty!  Make sure that the"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"specification of CVSROOT is valid, either via the"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"`-d' option, the %s environment variable, or the"
argument_list|,
name|CVSROOT_ENV
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"CVS/Root file (if any)."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Here begins the big loop over unique cvsroot values.  We            need to call do_recursion once for each unique value found            in CVS/Root.  Prime the list with the current value. */
comment|/* Create the list. */
name|assert
argument_list|(
name|root_directories
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|root_directories
operator|=
name|getlist
argument_list|()
expr_stmt|;
comment|/* Prime it. */
if|if
condition|(
name|CVSroot
operator|!=
name|NULL
condition|)
block|{
name|Node
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|n
operator|->
name|type
operator|=
name|NT_UNKNOWN
expr_stmt|;
name|n
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|CVSroot
argument_list|)
expr_stmt|;
name|n
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|addnode
argument_list|(
name|root_directories
argument_list|,
name|n
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot add initial CVSROOT %s"
argument_list|,
name|n
operator|->
name|key
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|current_root
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* If we're running the server, we want to execute this main 	   loop once and only once (we won't be serving multiple roots 	   from this connection, so there's no need to do it more than 	   once).  To get out of the loop, we perform a "break" at the 	   end of things.  */
while|while
condition|(
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
name|server_active
operator|||
endif|#
directive|endif
name|walklist
argument_list|(
name|root_directories
argument_list|,
name|set_root_directory
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
comment|/* Fiddling with CVSROOT doesn't make sense if we're running 	       in server mode, since the client will send the repository 	       directory after the connection is made. */
if|if
condition|(
operator|!
name|server_active
condition|)
endif|#
directive|endif
block|{
comment|/* Now we're 100% sure that we have a valid CVSROOT 		   variable.  Parse it to see if we're supposed to do 		   remote accesses or use a special access method. */
if|if
condition|(
name|current_parsed_root
operator|!=
name|NULL
condition|)
name|free_cvsroot_t
argument_list|(
name|current_parsed_root
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|current_parsed_root
operator|=
name|parse_cvsroot
argument_list|(
name|current_root
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Bad CVSROOT: `%s'."
argument_list|,
name|current_root
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s-> main loop with CVSROOT=%s\n"
argument_list|,
name|CLIENT_SERVER_STR
argument_list|,
name|current_root
argument_list|)
expr_stmt|;
comment|/* 		 * Check to see if the repository exists. 		 */
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
if|if
condition|(
operator|!
name|current_parsed_root
operator|->
name|isremote
condition|)
endif|#
directive|endif
comment|/* CLIENT_SUPPORT */
block|{
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|save_errno
decl_stmt|;
name|path
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|current_parsed_root
operator|->
name|directory
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSROOTADM
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|path
argument_list|,
literal|"%s/%s"
argument_list|,
name|current_parsed_root
operator|->
name|directory
argument_list|,
name|CVSROOTADM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isaccessible
argument_list|(
name|path
argument_list|,
name|R_OK
operator||
name|X_OK
argument_list|)
condition|)
block|{
name|save_errno
operator|=
name|errno
expr_stmt|;
comment|/* If this is "cvs init", the root need not exist yet.  */
if|if
condition|(
name|strcmp
argument_list|(
name|cvs_cmd_name
argument_list|,
literal|"init"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
name|save_errno
argument_list|,
literal|"%s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_PUTENV
comment|/* Update the CVSROOT environment variable if necessary. */
comment|/* FIXME (njc): should we always set this with the CVSROOT from the command line? */
if|if
condition|(
name|cvs_update_env
condition|)
block|{
specifier|static
name|char
modifier|*
name|prev
decl_stmt|;
name|char
modifier|*
name|env
decl_stmt|;
name|env
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|CVSROOT_ENV
argument_list|)
operator|+
name|strlen
argument_list|(
name|CVSroot
argument_list|)
operator|+
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|env
argument_list|,
literal|"%s=%s"
argument_list|,
name|CVSROOT_ENV
argument_list|,
name|CVSroot
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
comment|/* do not free env yet, as putenv has control of it */
comment|/* but do free the previous value, if any */
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|prev
operator|=
name|env
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* Parse the CVSROOT/config file, but only for local.  For the 	       server, we parse it after we know $CVSROOT.  For the 	       client, it doesn't get parsed at all, obviously.  The 	       presence of the parse_config call here is not mean to 	       predetermine whether CVSROOT/config overrides things from 	       read_cvsrc and other such places or vice versa.  That sort 	       of thing probably needs more thought.  */
if|if
condition|(
literal|1
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
operator|&&
operator|!
name|server_active
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
operator|&&
operator|!
name|current_parsed_root
operator|->
name|isremote
endif|#
directive|endif
condition|)
block|{
comment|/* If there was an error parsing the config file, parse_config 		   already printed an error.  We keep going.  Why?  Because 		   if we didn't, then there would be no way to check in a new 		   CVSROOT/config file to fix the broken one!  */
name|parse_config
argument_list|(
name|current_parsed_root
operator|->
name|directory
argument_list|)
expr_stmt|;
comment|/* Now is a convenient time to read CVSROOT/options */
name|parseopts
argument_list|(
name|current_parsed_root
operator|->
name|directory
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
comment|/* Need to check for current_parsed_root != NULL here since 	     * we could still be in server mode before the server function 	     * gets called below and sets the root 	     */
if|if
condition|(
name|current_parsed_root
operator|!=
name|NULL
operator|&&
name|current_parsed_root
operator|->
name|isremote
condition|)
block|{
comment|/* Create a new list for directory names that we've 		   sent to the server. */
if|if
condition|(
name|dirs_sent_to_server
operator|!=
name|NULL
condition|)
name|dellist
argument_list|(
operator|&
name|dirs_sent_to_server
argument_list|)
expr_stmt|;
name|dirs_sent_to_server
operator|=
name|getlist
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|err
operator|=
operator|(
operator|*
operator|(
name|cm
operator|->
name|func
operator|)
operator|)
operator|(
name|argc
operator|,
name|argv
operator|)
expr_stmt|;
comment|/* Mark this root directory as done.  When the server is                active, current_root will be NULL -- don't try and                remove it from the list. */
if|if
condition|(
name|current_root
operator|!=
name|NULL
condition|)
block|{
name|Node
modifier|*
name|n
init|=
name|findnode
argument_list|(
name|root_directories
argument_list|,
name|current_root
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|n
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|n
operator|->
name|data
operator|=
operator|(
name|void
operator|*
operator|)
literal|1
expr_stmt|;
name|current_root
operator|=
name|NULL
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* This will not work yet, since it tries to free (void *) 1. */
block|dellist (&root_directories);
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
block|{
name|server_active
operator|=
literal|0
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
block|}
comment|/* end of loop for cvsroot values */
block|}
comment|/* end of stuff that gets done if the user DOESN'T ask for help */
name|Lock_Cleanup
argument_list|()
expr_stmt|;
comment|/* It's okay to cast out the const below since we know we allocated this in      * this function.  The const was to keep other functions from messing with      * this.      */
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|program_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVSroot_cmdline
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|CVSroot_cmdline
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_CVSroot
condition|)
name|free
argument_list|(
name|CVSroot
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_Editor
condition|)
name|free
argument_list|(
name|Editor
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_Tmpdir
condition|)
name|free
argument_list|(
name|Tmpdir
argument_list|)
expr_stmt|;
name|root_allow_free
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SYSTEM_CLEANUP
comment|/* Hook for OS-specific behavior, for example socket subsystems on        NT and OS2 or dealing with windows and arguments on Mac.  */
name|SYSTEM_CLEANUP
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* This is exit rather than return because apparently that keeps        some tools which check for memory leaks happier.  */
name|exit
argument_list|(
name|err
condition|?
name|EXIT_FAILURE
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* Keep picky/stupid compilers (e.g. Visual C++ 5.0) happy.  */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|Make_Date
parameter_list|(
name|rawdate
parameter_list|)
name|char
modifier|*
name|rawdate
decl_stmt|;
block|{
name|time_t
name|unixtime
decl_stmt|;
name|unixtime
operator|=
name|get_date
argument_list|(
name|rawdate
argument_list|,
operator|(
expr|struct
name|timeb
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|unixtime
operator|==
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Can't parse date/time: %s"
argument_list|,
name|rawdate
argument_list|)
expr_stmt|;
return|return
name|date_from_time_t
argument_list|(
name|unixtime
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Convert a time_t to an RCS format date.  This is mainly for the    use of "cvs history", because the CVSROOT/history file contains    time_t format dates; most parts of CVS will want to avoid using    time_t's directly, and instead use RCS_datecmp, Make_Date,&c.    Assuming that the time_t is in GMT (as it generally should be),    then the result will be in GMT too.     Returns a newly malloc'd string.  */
end_comment

begin_function
name|char
modifier|*
name|date_from_time_t
parameter_list|(
name|unixtime
parameter_list|)
name|time_t
name|unixtime
decl_stmt|;
block|{
name|struct
name|tm
modifier|*
name|ftm
decl_stmt|;
name|char
name|date
index|[
name|MAXDATELEN
index|]
decl_stmt|;
name|char
modifier|*
name|ret
decl_stmt|;
name|ftm
operator|=
name|gmtime
argument_list|(
operator|&
name|unixtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftm
operator|==
name|NULL
condition|)
comment|/* This is a system, like VMS, where the system clock is in local 	   time.  Hopefully using localtime here matches the "zero timezone" 	   hack I added to get_date (get_date of course being the relevant 	   issue for Make_Date, and for history.c too I think).  */
name|ftm
operator|=
name|localtime
argument_list|(
operator|&
name|unixtime
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|date
argument_list|,
name|DATEFORM
argument_list|,
name|ftm
operator|->
name|tm_year
operator|+
operator|(
name|ftm
operator|->
name|tm_year
operator|<
literal|100
condition|?
literal|0
else|:
literal|1900
operator|)
argument_list|,
name|ftm
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|ftm
operator|->
name|tm_mday
argument_list|,
name|ftm
operator|->
name|tm_hour
argument_list|,
name|ftm
operator|->
name|tm_min
argument_list|,
name|ftm
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
name|ret
operator|=
name|xstrdup
argument_list|(
name|date
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Convert a date to RFC822/1123 format.  This is used in contexts like    dates to send in the protocol; it should not vary based on locale or    other such conventions for users.  We should have another routine which    does that kind of thing.     The SOURCE date is in our internal RCS format.  DEST should point to    storage managed by the caller, at least MAXDATELEN characters.  */
end_comment

begin_function
name|void
name|date_to_internet
parameter_list|(
name|dest
parameter_list|,
name|source
parameter_list|)
name|char
modifier|*
name|dest
decl_stmt|;
specifier|const
name|char
modifier|*
name|source
decl_stmt|;
block|{
name|struct
name|tm
name|date
decl_stmt|;
name|date_to_tm
argument_list|(
operator|&
name|date
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|tm_to_internet
argument_list|(
name|dest
argument_list|,
operator|&
name|date
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|date_to_tm
parameter_list|(
name|dest
parameter_list|,
name|source
parameter_list|)
name|struct
name|tm
modifier|*
name|dest
decl_stmt|;
specifier|const
name|char
modifier|*
name|source
decl_stmt|;
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|source
argument_list|,
name|SDATEFORM
argument_list|,
operator|&
name|dest
operator|->
name|tm_year
argument_list|,
operator|&
name|dest
operator|->
name|tm_mon
argument_list|,
operator|&
name|dest
operator|->
name|tm_mday
argument_list|,
operator|&
name|dest
operator|->
name|tm_hour
argument_list|,
operator|&
name|dest
operator|->
name|tm_min
argument_list|,
operator|&
name|dest
operator|->
name|tm_sec
argument_list|)
operator|!=
literal|6
condition|)
comment|/* Is there a better way to handle errors here?  I made this 	   non-fatal in case we are called from the code which can't 	   deal with fatal errors.  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"internal error: bad date %s"
argument_list|,
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|->
name|tm_year
operator|>
literal|100
condition|)
name|dest
operator|->
name|tm_year
operator|-=
literal|1900
expr_stmt|;
name|dest
operator|->
name|tm_mon
operator|-=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert a date to RFC822/1123 format.  This is used in contexts like    dates to send in the protocol; it should not vary based on locale or    other such conventions for users.  We should have another routine which    does that kind of thing.     The SOURCE date is a pointer to a struct tm.  DEST should point to    storage managed by the caller, at least MAXDATELEN characters.  */
end_comment

begin_function
name|void
name|tm_to_internet
parameter_list|(
name|dest
parameter_list|,
name|source
parameter_list|)
name|char
modifier|*
name|dest
decl_stmt|;
specifier|const
name|struct
name|tm
modifier|*
name|source
decl_stmt|;
block|{
comment|/* Just to reiterate, these strings are from RFC822 and do not vary        according to locale.  */
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|month_names
index|[]
init|=
block|{
literal|"Jan"
block|,
literal|"Feb"
block|,
literal|"Mar"
block|,
literal|"Apr"
block|,
literal|"May"
block|,
literal|"Jun"
block|,
literal|"Jul"
block|,
literal|"Aug"
block|,
literal|"Sep"
block|,
literal|"Oct"
block|,
literal|"Nov"
block|,
literal|"Dec"
block|}
decl_stmt|;
name|sprintf
argument_list|(
name|dest
argument_list|,
literal|"%d %s %d %02d:%02d:%02d -0000"
argument_list|,
name|source
operator|->
name|tm_mday
argument_list|,
name|source
operator|->
name|tm_mon
operator|<
literal|0
operator|||
name|source
operator|->
name|tm_mon
operator|>
literal|11
condition|?
literal|"???"
else|:
name|month_names
index|[
name|source
operator|->
name|tm_mon
index|]
argument_list|,
name|source
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|source
operator|->
name|tm_hour
argument_list|,
name|source
operator|->
name|tm_min
argument_list|,
name|source
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|usage
parameter_list|(
name|cpp
parameter_list|)
specifier|register
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|cpp
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
operator|*
name|cpp
operator|++
argument_list|,
name|program_name
argument_list|,
name|cvs_cmd_name
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|cpp
condition|;
name|cpp
operator|++
control|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
name|error_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|parseopts
parameter_list|(
name|root
parameter_list|)
specifier|const
name|char
modifier|*
name|root
decl_stmt|;
block|{
name|char
name|path
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|int
name|save_errno
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|root
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"no CVSROOT in parseopts\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|p
operator|=
name|strchr
argument_list|(
name|root
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|p
operator|++
expr_stmt|;
else|else
name|p
operator|=
name|root
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"mangled CVSROOT in parseopts\n"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|path
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|p
argument_list|,
name|CVSROOTADM
argument_list|,
name|CVSROOTADM_OPTIONS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|path
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
continue|continue;
name|q
operator|=
name|strrchr
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"iso8601"
argument_list|)
condition|)
block|{
name|datesep
operator|=
literal|'-'
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"tag="
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|char
modifier|*
name|what
decl_stmt|;
name|char
modifier|*
name|rcs_localid
decl_stmt|;
name|rcs_localid
operator|=
name|buf
operator|+
literal|4
expr_stmt|;
name|RCS_setlocalid
argument_list|(
name|rcs_localid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"tagexpand="
argument_list|,
literal|10
argument_list|)
condition|)
block|{
name|char
modifier|*
name|what
decl_stmt|;
name|char
modifier|*
name|rcs_incexc
decl_stmt|;
name|rcs_incexc
operator|=
name|buf
operator|+
literal|10
expr_stmt|;
name|RCS_setincexc
argument_list|(
name|rcs_incexc
argument_list|)
expr_stmt|;
block|}
comment|/* 	     * OpenBSD has a "umask=" and "dlimit=" command, we silently 	     * ignore them here since they are not much use to us.  cvsumask 	     * defaults to 002 already, and the dlimit (data size limit) 	     * should really be handled elsewhere (eg: login.conf). 	     */
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

