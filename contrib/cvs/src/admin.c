begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  * Copyright (c) 1989-1992, Brian Berliner  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS source distribution.  *   * Administration ("cvs admin")  *   */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CVS_ADMIN_GROUP
end_ifdef

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_decl_stmt
specifier|static
name|Dtype
name|admin_dirproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
name|char
operator|*
name|dir
operator|,
name|char
operator|*
name|repos
operator|,
name|char
operator|*
name|update_dir
operator|,
name|List
operator|*
name|entries
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|admin_fileproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
expr|struct
name|file_info
operator|*
name|finfo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|admin_usage
index|[]
init|=
block|{
literal|"Usage: %s %s rcs-options files...\n"
block|,
literal|"(Specify the --help global option for a list of other help options)\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This structure is used to pass information through start_recursion.  */
end_comment

begin_struct
struct|struct
name|admin_data
block|{
comment|/* Set default branch (-b).  It is "-b" followed by the value        given, or NULL if not specified, or merely "-b" if -b is        specified without a value.  */
name|char
modifier|*
name|branch
decl_stmt|;
comment|/* Set comment leader (-c).  It is "-c" followed by the value        given, or NULL if not specified.  The comment leader is        relevant only for old versions of RCS, but we let people set it        anyway.  */
name|char
modifier|*
name|comment
decl_stmt|;
comment|/* Set strict locking (-L).  */
name|int
name|set_strict
decl_stmt|;
comment|/* Set nonstrict locking (-U).  */
name|int
name|set_nonstrict
decl_stmt|;
comment|/* Delete revisions (-o).  It is "-o" followed by the value specified.  */
name|char
modifier|*
name|delete_revs
decl_stmt|;
comment|/* Keyword substitution mode (-k), e.g. "-kb".  */
name|char
modifier|*
name|kflag
decl_stmt|;
comment|/* Description (-t).  See sanity.sh for various moanings about        files and stdin and such.  "" if -t specified without an        argument.  It is "-t" followed by the argument.  */
name|char
modifier|*
name|desc
decl_stmt|;
comment|/* Interactive (-I).  Problematic with client/server.  */
name|int
name|interactive
decl_stmt|;
comment|/* Quiet (-q).  Not the same as the global -q option, which is a bit        on the confusing side, perhaps.  */
name|int
name|quiet
decl_stmt|;
comment|/* This is the cheesy part.  It is a vector with the options which        we don't deal with above (e.g. "-afoo" "-abar,baz").  In the future        this presumably will be replaced by other variables which break        out the data in a more convenient fashion.  AV as well as each of        the strings it points to is malloc'd.  */
name|int
name|ac
decl_stmt|;
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
name|int
name|av_alloc
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Add an argument.  OPT is the option letter, e.g. 'a'.  ARG is the    argument to that option, or NULL if omitted (whether NULL can actually    happen depends on whether the option was specified as optional to    getopt).  */
end_comment

begin_function
specifier|static
name|void
name|arg_add
parameter_list|(
name|dat
parameter_list|,
name|opt
parameter_list|,
name|arg
parameter_list|)
name|struct
name|admin_data
modifier|*
name|dat
decl_stmt|;
name|int
name|opt
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|char
modifier|*
name|newelt
init|=
name|xmalloc
argument_list|(
operator|(
name|arg
operator|==
name|NULL
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|arg
argument_list|)
operator|)
operator|+
literal|3
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|newelt
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|newelt
index|[
literal|1
index|]
operator|=
name|opt
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
name|newelt
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|newelt
operator|+
literal|2
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|dat
operator|->
name|av_alloc
operator|==
literal|0
condition|)
block|{
name|dat
operator|->
name|av_alloc
operator|=
literal|1
expr_stmt|;
name|dat
operator|->
name|av
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|dat
operator|->
name|av_alloc
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dat
operator|->
name|av
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dat
operator|->
name|ac
operator|>=
name|dat
operator|->
name|av_alloc
condition|)
block|{
name|dat
operator|->
name|av_alloc
operator|*=
literal|2
expr_stmt|;
name|dat
operator|->
name|av
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|dat
operator|->
name|av
argument_list|,
name|dat
operator|->
name|av_alloc
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dat
operator|->
name|av
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dat
operator|->
name|av
index|[
name|dat
operator|->
name|ac
operator|++
index|]
operator|=
name|newelt
expr_stmt|;
block|}
end_function

begin_function
name|int
name|admin
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|err
decl_stmt|;
ifdef|#
directive|ifdef
name|CVS_ADMIN_GROUP
name|struct
name|group
modifier|*
name|grp
decl_stmt|;
name|struct
name|group
modifier|*
name|getgrnam
parameter_list|()
function_decl|;
endif|#
directive|endif
name|struct
name|admin_data
name|admin_data
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
name|usage
argument_list|(
name|admin_usage
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CVS_ADMIN_GROUP
name|grp
operator|=
name|getgrnam
argument_list|(
name|CVS_ADMIN_GROUP
argument_list|)
expr_stmt|;
comment|/* skip usage right check if group CVS_ADMIN_GROUP does not exist */
if|if
condition|(
name|grp
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|me
init|=
name|getcaller
argument_list|()
decl_stmt|;
name|char
modifier|*
modifier|*
name|grnam
init|=
name|grp
operator|->
name|gr_mem
decl_stmt|;
name|int
name|denied
init|=
literal|1
decl_stmt|;
while|while
condition|(
operator|*
name|grnam
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|grnam
argument_list|,
name|me
argument_list|)
operator|==
literal|0
condition|)
block|{
name|denied
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|grnam
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|denied
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"usage is restricted to members of the group %s"
argument_list|,
name|CVS_ADMIN_GROUP
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|wrap_setup
argument_list|()
expr_stmt|;
name|memset
argument_list|(
operator|&
name|admin_data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|admin_data
argument_list|)
expr_stmt|;
comment|/* TODO: get rid of `-' switch notation in admin_data.  For        example, admin_data->branch should be not `-bfoo' but simply `foo'. */
name|optind
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"+ib::c:a:A:e:l::u::LUn:N:m:o:s:t::IqxV:k:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'i'
case|:
comment|/* This has always been documented as useless in cvs.texinfo 		   and it really is--admin_fileproc silently does nothing 		   if vers->vn_user is NULL. */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"the -i option to admin is not supported"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"run add or import to create an RCS file"
argument_list|)
expr_stmt|;
goto|goto
name|usage_error
goto|;
case|case
literal|'b'
case|:
if|if
condition|(
name|admin_data
operator|.
name|branch
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"duplicate 'b' option"
argument_list|)
expr_stmt|;
goto|goto
name|usage_error
goto|;
block|}
if|if
condition|(
name|optarg
operator|==
name|NULL
condition|)
name|admin_data
operator|.
name|branch
operator|=
name|xstrdup
argument_list|(
literal|"-b"
argument_list|)
expr_stmt|;
else|else
block|{
name|admin_data
operator|.
name|branch
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|admin_data
operator|.
name|branch
argument_list|,
literal|"-b"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|admin_data
operator|.
name|branch
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
name|admin_data
operator|.
name|comment
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"duplicate 'c' option"
argument_list|)
expr_stmt|;
goto|goto
name|usage_error
goto|;
block|}
name|admin_data
operator|.
name|comment
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|admin_data
operator|.
name|comment
argument_list|,
literal|"-c"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|admin_data
operator|.
name|comment
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|arg_add
argument_list|(
operator|&
name|admin_data
argument_list|,
literal|'a'
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
comment|/* In the client/server case, this is cheesy because 		   we just pass along the name of the RCS file, which 		   then will want to exist on the server.  This is 		   accidental; having the client specify a pathname on 		   the server is not a design feature of the protocol.  */
name|arg_add
argument_list|(
operator|&
name|admin_data
argument_list|,
literal|'A'
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|arg_add
argument_list|(
operator|&
name|admin_data
argument_list|,
literal|'e'
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* Note that multiple -l options are legal.  */
name|arg_add
argument_list|(
operator|&
name|admin_data
argument_list|,
literal|'l'
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* Note that multiple -u options are legal.  */
name|arg_add
argument_list|(
operator|&
name|admin_data
argument_list|,
literal|'u'
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* Probably could also complain if -L is specified multiple 		   times, although RCS doesn't and I suppose it is reasonable 		   just to have it mean the same as a single -L.  */
if|if
condition|(
name|admin_data
operator|.
name|set_nonstrict
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"-U and -L are incompatible"
argument_list|)
expr_stmt|;
goto|goto
name|usage_error
goto|;
block|}
name|admin_data
operator|.
name|set_strict
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
comment|/* Probably could also complain if -U is specified multiple 		   times, although RCS doesn't and I suppose it is reasonable 		   just to have it mean the same as a single -U.  */
if|if
condition|(
name|admin_data
operator|.
name|set_strict
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"-U and -L are incompatible"
argument_list|)
expr_stmt|;
goto|goto
name|usage_error
goto|;
block|}
name|admin_data
operator|.
name|set_nonstrict
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* Mostly similar to cvs tag.  Could also be parsing 		   the syntax of optarg, although for now we just pass 		   it to rcs as-is.  Note that multiple -n options are 		   legal.  */
name|arg_add
argument_list|(
operator|&
name|admin_data
argument_list|,
literal|'n'
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
comment|/* Mostly similar to cvs tag.  Could also be parsing 		   the syntax of optarg, although for now we just pass 		   it to rcs as-is.  Note that multiple -N options are 		   legal.  */
name|arg_add
argument_list|(
operator|&
name|admin_data
argument_list|,
literal|'N'
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* Change log message.  Could also be parsing the syntax 		   of optarg, although for now we just pass it to rcs 		   as-is.  Note that multiple -m options are legal.  */
name|arg_add
argument_list|(
operator|&
name|admin_data
argument_list|,
literal|'m'
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* Delete revisions.  Probably should also be parsing the 		   syntax of optarg, so that the client can give errors 		   rather than making the server take care of that. 		   Other than that I'm not sure whether it matters much 		   whether we parse it here or in admin_fileproc.  		   Note that multiple -o options are illegal, in RCS 		   as well as here.  */
if|if
condition|(
name|admin_data
operator|.
name|delete_revs
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"duplicate '-o' option"
argument_list|)
expr_stmt|;
goto|goto
name|usage_error
goto|;
block|}
name|admin_data
operator|.
name|delete_revs
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|admin_data
operator|.
name|delete_revs
argument_list|,
literal|"-o"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|admin_data
operator|.
name|delete_revs
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* Note that multiple -s options are legal.  */
name|arg_add
argument_list|(
operator|&
name|admin_data
argument_list|,
literal|'s'
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|admin_data
operator|.
name|desc
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"duplicate 't' option"
argument_list|)
expr_stmt|;
goto|goto
name|usage_error
goto|;
block|}
if|if
condition|(
name|optarg
operator|==
name|NULL
condition|)
name|admin_data
operator|.
name|desc
operator|=
name|xstrdup
argument_list|(
literal|"-t"
argument_list|)
expr_stmt|;
else|else
block|{
name|admin_data
operator|.
name|desc
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|admin_data
operator|.
name|desc
argument_list|,
literal|"-t"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|admin_data
operator|.
name|desc
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'I'
case|:
comment|/* At least in RCS this can be specified several times, 		   with the same meaning as being specified once.  */
name|admin_data
operator|.
name|interactive
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|admin_data
operator|.
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"the -x option has never done anything useful"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"RCS files in CVS always end in ,v"
argument_list|)
expr_stmt|;
goto|goto
name|usage_error
goto|;
case|case
literal|'V'
case|:
comment|/* No longer supported. */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"the `-V' option is obsolete"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
if|if
condition|(
name|admin_data
operator|.
name|kflag
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"duplicate '-k' option"
argument_list|)
expr_stmt|;
goto|goto
name|usage_error
goto|;
block|}
name|admin_data
operator|.
name|kflag
operator|=
name|RCS_check_kflag
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
default|default:
case|case
literal|'?'
case|:
comment|/* getopt will have printed an error message.  */
name|usage_error
label|:
comment|/* Don't use command_name; it might be "server".  */
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"specify %s -H admin for usage information"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|admin_data
operator|.
name|ac
condition|;
operator|++
name|i
control|)
block|{
name|assert
argument_list|(
name|admin_data
operator|.
name|av
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|admin_data
operator|.
name|av
index|[
name|i
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'m'
case|:
case|case
literal|'l'
case|:
case|case
literal|'u'
case|:
name|check_numeric
argument_list|(
operator|&
name|admin_data
operator|.
name|av
index|[
name|i
index|]
index|[
literal|2
index|]
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|admin_data
operator|.
name|branch
operator|!=
name|NULL
condition|)
name|check_numeric
argument_list|(
name|admin_data
operator|.
name|branch
operator|+
literal|2
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|admin_data
operator|.
name|delete_revs
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|check_numeric
argument_list|(
name|admin_data
operator|.
name|delete_revs
operator|+
literal|2
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|admin_data
operator|.
name|delete_revs
operator|+
literal|2
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|isdigit
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
condition|)
name|check_numeric
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|':'
operator|&&
name|isdigit
argument_list|(
name|p
index|[
literal|2
index|]
argument_list|)
condition|)
name|check_numeric
argument_list|(
name|p
operator|+
literal|2
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
if|if
condition|(
name|client_active
condition|)
block|{
comment|/* We're the client side.  Fire up the remote server.  */
name|start_server
argument_list|()
expr_stmt|;
name|ign_setup
argument_list|()
expr_stmt|;
comment|/* Note that option_with_arg does not work for us, because some 	   of the options must be sent without a space between the option 	   and its argument.  */
if|if
condition|(
name|admin_data
operator|.
name|interactive
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"-I option not useful with client/server"
argument_list|)
expr_stmt|;
if|if
condition|(
name|admin_data
operator|.
name|branch
operator|!=
name|NULL
condition|)
name|send_arg
argument_list|(
name|admin_data
operator|.
name|branch
argument_list|)
expr_stmt|;
if|if
condition|(
name|admin_data
operator|.
name|comment
operator|!=
name|NULL
condition|)
name|send_arg
argument_list|(
name|admin_data
operator|.
name|comment
argument_list|)
expr_stmt|;
if|if
condition|(
name|admin_data
operator|.
name|set_strict
condition|)
name|send_arg
argument_list|(
literal|"-L"
argument_list|)
expr_stmt|;
if|if
condition|(
name|admin_data
operator|.
name|set_nonstrict
condition|)
name|send_arg
argument_list|(
literal|"-U"
argument_list|)
expr_stmt|;
if|if
condition|(
name|admin_data
operator|.
name|delete_revs
operator|!=
name|NULL
condition|)
name|send_arg
argument_list|(
name|admin_data
operator|.
name|delete_revs
argument_list|)
expr_stmt|;
if|if
condition|(
name|admin_data
operator|.
name|desc
operator|!=
name|NULL
condition|)
name|send_arg
argument_list|(
name|admin_data
operator|.
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|admin_data
operator|.
name|quiet
condition|)
name|send_arg
argument_list|(
literal|"-q"
argument_list|)
expr_stmt|;
if|if
condition|(
name|admin_data
operator|.
name|kflag
operator|!=
name|NULL
condition|)
name|send_arg
argument_list|(
name|admin_data
operator|.
name|kflag
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|admin_data
operator|.
name|ac
condition|;
operator|++
name|i
control|)
name|send_arg
argument_list|(
name|admin_data
operator|.
name|av
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|send_file_names
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|SEND_EXPAND_WILD
argument_list|)
expr_stmt|;
name|send_files
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SEND_NO_CONTENTS
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"admin\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
operator|=
name|get_responses_and_close
argument_list|()
expr_stmt|;
goto|goto
name|return_it
goto|;
block|}
endif|#
directive|endif
comment|/* CLIENT_SUPPORT */
name|lock_tree_for_write
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
operator|=
name|start_recursion
argument_list|(
name|admin_fileproc
argument_list|,
operator|(
name|FILESDONEPROC
operator|)
name|NULL
argument_list|,
name|admin_dirproc
argument_list|,
operator|(
name|DIRLEAVEPROC
operator|)
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|admin_data
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
literal|0
argument_list|,
name|W_LOCAL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Lock_Cleanup
argument_list|()
expr_stmt|;
name|return_it
label|:
if|if
condition|(
name|admin_data
operator|.
name|branch
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|admin_data
operator|.
name|branch
argument_list|)
expr_stmt|;
if|if
condition|(
name|admin_data
operator|.
name|comment
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|admin_data
operator|.
name|comment
argument_list|)
expr_stmt|;
if|if
condition|(
name|admin_data
operator|.
name|delete_revs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|admin_data
operator|.
name|delete_revs
argument_list|)
expr_stmt|;
if|if
condition|(
name|admin_data
operator|.
name|kflag
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|admin_data
operator|.
name|kflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|admin_data
operator|.
name|desc
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|admin_data
operator|.
name|desc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|admin_data
operator|.
name|ac
condition|;
operator|++
name|i
control|)
name|free
argument_list|(
name|admin_data
operator|.
name|av
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|admin_data
operator|.
name|av
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|admin_data
operator|.
name|av
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called to run "rcs" on a particular file.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|admin_fileproc
parameter_list|(
name|callerdat
parameter_list|,
name|finfo
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
block|{
name|struct
name|admin_data
modifier|*
name|admin_data
init|=
operator|(
expr|struct
name|admin_data
operator|*
operator|)
name|callerdat
decl_stmt|;
name|Vers_TS
modifier|*
name|vers
decl_stmt|;
name|char
modifier|*
name|version
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
name|RCSNode
modifier|*
name|rcs
decl_stmt|,
modifier|*
name|rcs2
decl_stmt|;
name|vers
operator|=
name|Version_TS
argument_list|(
name|finfo
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|version
operator|=
name|vers
operator|->
name|vn_user
expr_stmt|;
if|if
condition|(
name|version
operator|==
name|NULL
condition|)
goto|goto
name|exitfunc
goto|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|version
argument_list|,
literal|"0"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot admin newly added file `%s'"
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
goto|goto
name|exitfunc
goto|;
block|}
name|rcs
operator|=
name|vers
operator|->
name|srcfile
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|flags
operator|&
name|PARTIAL
condition|)
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|admin_data
operator|->
name|quiet
condition|)
block|{
name|cvs_output
argument_list|(
literal|"RCS file: "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|rcs
operator|->
name|path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|admin_data
operator|->
name|branch
operator|!=
name|NULL
condition|)
name|RCS_setbranch
argument_list|(
name|rcs
argument_list|,
operator|(
name|admin_data
operator|->
name|branch
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|?
name|NULL
else|:
name|admin_data
operator|->
name|branch
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|admin_data
operator|->
name|comment
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|rcs
operator|->
name|comment
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rcs
operator|->
name|comment
argument_list|)
expr_stmt|;
name|rcs
operator|->
name|comment
operator|=
name|xstrdup
argument_list|(
name|admin_data
operator|->
name|comment
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|admin_data
operator|->
name|set_strict
condition|)
name|rcs
operator|->
name|strict_locks
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|admin_data
operator|->
name|set_nonstrict
condition|)
name|rcs
operator|->
name|strict_locks
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|admin_data
operator|->
name|delete_revs
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|rev1
decl_stmt|,
modifier|*
name|rev2
decl_stmt|;
comment|/* Set for :, clear for ::.  */
name|int
name|inclusive
decl_stmt|;
name|char
modifier|*
name|t2
decl_stmt|;
name|s
operator|=
name|admin_data
operator|->
name|delete_revs
operator|+
literal|2
expr_stmt|;
name|inclusive
operator|=
literal|1
expr_stmt|;
name|t
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|t
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|inclusive
operator|=
literal|0
expr_stmt|;
name|t2
operator|=
name|t
operator|+
literal|2
expr_stmt|;
block|}
else|else
name|t2
operator|=
name|t
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Note that we don't support '-' for ranges.  RCS considers it 	   obsolete and it is problematic with tags containing '-'.  "cvs log" 	   has made the same decision.  */
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
block|{
comment|/* -orev */
name|rev1
operator|=
name|xstrdup
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|rev2
operator|=
name|xstrdup
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|s
condition|)
block|{
comment|/* -o:rev2 */
name|rev1
operator|=
name|NULL
expr_stmt|;
name|rev2
operator|=
name|xstrdup
argument_list|(
name|t2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
name|rev1
operator|=
name|xstrdup
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|*
name|t
operator|=
literal|':'
expr_stmt|;
comment|/* probably unnecessary */
if|if
condition|(
operator|*
name|t2
operator|==
literal|'\0'
condition|)
comment|/* -orev1: */
name|rev2
operator|=
name|NULL
expr_stmt|;
else|else
comment|/* -orev1:rev2 */
name|rev2
operator|=
name|xstrdup
argument_list|(
name|t2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rev1
operator|==
name|NULL
operator|&&
name|rev2
operator|==
name|NULL
condition|)
block|{
comment|/* RCS segfaults if `-o:' is given */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"no valid revisions specified in `%s' option"
argument_list|,
name|admin_data
operator|->
name|delete_revs
argument_list|)
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|status
operator||=
name|RCS_delete_revs
argument_list|(
name|rcs
argument_list|,
name|rev1
argument_list|,
name|rev2
argument_list|,
name|inclusive
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev1
condition|)
name|free
argument_list|(
name|rev1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev2
condition|)
name|free
argument_list|(
name|rev2
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|admin_data
operator|->
name|desc
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|rcs
operator|->
name|desc
argument_list|)
expr_stmt|;
name|rcs
operator|->
name|desc
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|admin_data
operator|->
name|desc
index|[
literal|2
index|]
operator|==
literal|'-'
condition|)
name|rcs
operator|->
name|desc
operator|=
name|xstrdup
argument_list|(
name|admin_data
operator|->
name|desc
operator|+
literal|3
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|descfile
init|=
name|admin_data
operator|->
name|desc
operator|+
literal|2
decl_stmt|;
name|size_t
name|bufsize
init|=
literal|0
decl_stmt|;
name|size_t
name|len
decl_stmt|;
comment|/* If -t specified with no argument, read from stdin. */
if|if
condition|(
operator|*
name|descfile
operator|==
literal|'\0'
condition|)
name|descfile
operator|=
name|NULL
expr_stmt|;
name|get_file
argument_list|(
name|descfile
argument_list|,
name|descfile
argument_list|,
literal|"r"
argument_list|,
operator|&
name|rcs
operator|->
name|desc
argument_list|,
operator|&
name|bufsize
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|admin_data
operator|->
name|kflag
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|kflag
init|=
name|admin_data
operator|->
name|kflag
operator|+
literal|2
decl_stmt|;
if|if
condition|(
operator|!
name|rcs
operator|->
name|expand
operator|||
name|strcmp
argument_list|(
name|rcs
operator|->
name|expand
argument_list|,
name|kflag
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rcs
operator|->
name|expand
condition|)
name|free
argument_list|(
name|rcs
operator|->
name|expand
argument_list|)
expr_stmt|;
name|rcs
operator|->
name|expand
operator|=
name|xstrdup
argument_list|(
name|kflag
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Handle miscellaneous options.  TODO: decide whether any or all        of these should have their own fields in the admin_data        structure. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|admin_data
operator|->
name|ac
condition|;
operator|++
name|i
control|)
block|{
name|char
modifier|*
name|arg
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|rev
decl_stmt|,
modifier|*
name|revnum
decl_stmt|,
modifier|*
name|tag
decl_stmt|,
modifier|*
name|msg
decl_stmt|;
name|char
modifier|*
modifier|*
name|users
decl_stmt|;
name|int
name|argc
decl_stmt|,
name|u
decl_stmt|;
name|Node
modifier|*
name|n
decl_stmt|;
name|RCSVers
modifier|*
name|delta
decl_stmt|;
name|arg
operator|=
name|admin_data
operator|->
name|av
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
name|arg
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'a'
case|:
comment|/* fall through */
case|case
literal|'e'
case|:
name|line2argv
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|users
argument_list|,
name|arg
operator|+
literal|2
argument_list|,
literal|" ,\t\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|==
literal|'a'
condition|)
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|argc
condition|;
operator|++
name|u
control|)
name|RCS_addaccess
argument_list|(
name|rcs
argument_list|,
name|users
index|[
name|u
index|]
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|argc
condition|;
operator|++
name|u
control|)
name|RCS_delaccess
argument_list|(
name|rcs
argument_list|,
name|users
index|[
name|u
index|]
argument_list|)
expr_stmt|;
name|free_names
argument_list|(
operator|&
name|argc
argument_list|,
name|users
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
comment|/* See admin-19a-admin and friends in sanity.sh for 		   relative pathnames.  It makes sense to think in 		   terms of a syntax which give pathnames relative to 		   the repository or repository corresponding to the 		   current directory or some such (and perhaps don't 		   include ,v), but trying to worry about such things 		   is a little pointless unless you first worry about 		   whether "cvs admin -A" as a whole makes any sense 		   (currently probably not, as access lists don't 		   affect the behavior of CVS).  */
name|rcs2
operator|=
name|RCS_parsercsfile
argument_list|(
name|arg
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs2
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot continue"
argument_list|)
expr_stmt|;
name|p
operator|=
name|xstrdup
argument_list|(
name|RCS_getaccess
argument_list|(
name|rcs2
argument_list|)
argument_list|)
expr_stmt|;
name|line2argv
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|users
argument_list|,
name|p
argument_list|,
literal|" \t\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|freercsnode
argument_list|(
operator|&
name|rcs2
argument_list|)
expr_stmt|;
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|argc
condition|;
operator|++
name|u
control|)
name|RCS_addaccess
argument_list|(
name|rcs
argument_list|,
name|users
index|[
name|u
index|]
argument_list|)
expr_stmt|;
name|free_names
argument_list|(
operator|&
name|argc
argument_list|,
name|users
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* fall through */
case|case
literal|'N'
case|:
if|if
condition|(
name|arg
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
name|cvs_outerr
argument_list|(
literal|"missing symbolic name after "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_outerr
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_outerr
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
name|p
operator|=
name|strchr
argument_list|(
name|arg
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|RCS_deltag
argument_list|(
name|rcs
argument_list|,
name|arg
operator|+
literal|2
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: Symbolic name %s is undefined."
argument_list|,
name|rcs
operator|->
name|path
argument_list|,
name|arg
operator|+
literal|2
argument_list|)
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|tag
operator|=
name|xstrdup
argument_list|(
name|arg
operator|+
literal|2
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|':'
expr_stmt|;
comment|/* Option `n' signals an error if this tag is already bound. */
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|==
literal|'n'
condition|)
block|{
name|n
operator|=
name|findnode
argument_list|(
name|RCS_symbols
argument_list|(
name|rcs
argument_list|)
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: symbolic name %s already bound to %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|,
name|tag
argument_list|,
name|n
operator|->
name|data
argument_list|)
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* Expand rev if necessary. */
name|rev
operator|=
name|RCS_gettag
argument_list|(
name|rcs
argument_list|,
name|p
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|RCS_settag
argument_list|(
name|rcs
argument_list|,
name|tag
argument_list|,
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tag
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|p
operator|=
name|strchr
argument_list|(
name|arg
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|tag
operator|=
name|xstrdup
argument_list|(
name|arg
operator|+
literal|2
argument_list|)
expr_stmt|;
name|rev
operator|=
name|RCS_head
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|tag
operator|=
name|xstrdup
argument_list|(
name|arg
operator|+
literal|2
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|':'
expr_stmt|;
name|rev
operator|=
name|xstrdup
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|revnum
operator|=
name|RCS_gettag
argument_list|(
name|rcs
argument_list|,
name|rev
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|revnum
operator|!=
name|NULL
condition|)
name|n
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|revnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|revnum
operator|==
name|NULL
operator|||
name|n
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: can't set state of nonexisting revision %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|,
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|revnum
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|revnum
argument_list|)
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|delta
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|n
operator|->
name|data
expr_stmt|;
name|free
argument_list|(
name|delta
operator|->
name|state
argument_list|)
expr_stmt|;
name|delta
operator|->
name|state
operator|=
name|tag
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|p
operator|=
name|strchr
argument_list|(
name|arg
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: -m option lacks revision number"
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|rev
operator|=
name|RCS_gettag
argument_list|(
name|rcs
argument_list|,
name|arg
operator|+
literal|2
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: no such revision %s"
argument_list|,
name|rcs
operator|->
name|path
argument_list|,
name|rev
argument_list|)
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
operator|*
name|p
operator|++
operator|=
literal|':'
expr_stmt|;
name|msg
operator|=
name|p
expr_stmt|;
name|n
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|rev
argument_list|)
expr_stmt|;
name|delta
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|n
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|delta
operator|->
name|text
operator|==
name|NULL
condition|)
block|{
name|delta
operator|->
name|text
operator|=
operator|(
name|Deltatext
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Deltatext
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|delta
operator|->
name|text
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|Deltatext
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|delta
operator|->
name|text
operator|->
name|version
operator|=
name|xstrdup
argument_list|(
name|delta
operator|->
name|version
argument_list|)
expr_stmt|;
name|delta
operator|->
name|text
operator|->
name|log
operator|=
name|make_message_rcslegal
argument_list|(
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|status
operator||=
name|RCS_lock
argument_list|(
name|rcs
argument_list|,
name|arg
index|[
literal|2
index|]
condition|?
name|arg
operator|+
literal|2
else|:
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|status
operator||=
name|RCS_unlock
argument_list|(
name|rcs
argument_list|,
name|arg
index|[
literal|2
index|]
condition|?
name|arg
operator|+
literal|2
else|:
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* can't happen */
block|}
block|}
comment|/* TODO: reconcile the weird discrepancies between        admin_data->quiet and quiet. */
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
name|RCS_rewrite
argument_list|(
name|rcs
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|admin_data
operator|->
name|quiet
condition|)
name|cvs_output
argument_list|(
literal|"done\n"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Note that this message should only occur after another 	   message has given a more specific error.  The point of this 	   additional message is to make it clear that the previous problems 	   caused CVS to forget about the idea of modifying the RCS file.  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot modify RCS file for `%s'"
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
comment|/* Upon failure, we want to abandon any changes made to the 	   RCS data structure.  Forcing a reparse does the trick, 	   but leaks memory and is kludgey.  Should we export 	   free_rcsnode_contents for this purpose? */
name|RCS_reparsercsfile
argument_list|(
name|rcs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|exitfunc
label|:
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*  * Print a warm fuzzy message  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|Dtype
name|admin_dirproc
parameter_list|(
name|callerdat
parameter_list|,
name|dir
parameter_list|,
name|repos
parameter_list|,
name|update_dir
parameter_list|,
name|entries
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|repos
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Administrating %s"
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
return|return
operator|(
name|R_PROCESS
operator|)
return|;
block|}
end_function

end_unit

