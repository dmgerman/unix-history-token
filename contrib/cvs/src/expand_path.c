begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* expand_path.c -- expand environmental variables in passed in string  *  * The main routine is expand_path(), it is the routine that handles  * the '~' character in four forms:   *     ~name  *     ~name/  *     ~/  *     ~  * and handles environment variables contained within the pathname  * which are defined by:  *     ${var_name}   (var_name is the name of the environ variable)  *     $var_name     (var_name ends w/ non-alphanumeric char other than '_')  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_decl_stmt
specifier|static
name|char
modifier|*
name|expand_variable
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|env
operator|,
name|char
operator|*
name|file
operator|,
name|int
name|line
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* User variables.  */
end_comment

begin_decl_stmt
name|List
modifier|*
name|variable_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|variable_delproc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|variable_delproc
parameter_list|(
name|node
parameter_list|)
name|Node
modifier|*
name|node
decl_stmt|;
block|{
name|free
argument_list|(
name|node
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Currently used by -s option; we might want a way to set user    variables in a file in the $CVSROOT/CVSROOT directory too.  */
end_comment

begin_function
name|void
name|variable_set
parameter_list|(
name|nameval
parameter_list|)
name|char
modifier|*
name|nameval
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|Node
modifier|*
name|node
decl_stmt|;
name|p
operator|=
name|nameval
expr_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'_'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'='
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"illegal character in user variable name in %s"
argument_list|,
name|nameval
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|nameval
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"empty user variable name in %s"
argument_list|,
name|nameval
argument_list|)
expr_stmt|;
name|name
operator|=
name|xmalloc
argument_list|(
name|p
operator|-
name|nameval
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|name
argument_list|,
name|nameval
argument_list|,
name|p
operator|-
name|nameval
argument_list|)
expr_stmt|;
name|name
index|[
name|p
operator|-
name|nameval
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Make p point to the value.  */
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\012'
argument_list|)
operator|!=
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"linefeed in user variable value in %s"
argument_list|,
name|nameval
argument_list|)
expr_stmt|;
if|if
condition|(
name|variable_list
operator|==
name|NULL
condition|)
name|variable_list
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|node
operator|=
name|findnode
argument_list|(
name|variable_list
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
block|{
name|node
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|node
operator|->
name|type
operator|=
name|VARIABLE
expr_stmt|;
name|node
operator|->
name|delproc
operator|=
name|variable_delproc
expr_stmt|;
name|node
operator|->
name|key
operator|=
name|name
expr_stmt|;
name|node
operator|->
name|data
operator|=
name|xstrdup
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|variable_list
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Replace the old value.  For example, this means that -s 	   options on the command line override ones from .cvsrc.  */
name|free
argument_list|(
name|node
operator|->
name|data
argument_list|)
expr_stmt|;
name|node
operator|->
name|data
operator|=
name|xstrdup
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This routine will expand the pathname to account for ~ and $    characters as described above.  Returns a pointer to a newly    malloc'd string.  If an error occurs, an error message is printed    via error() and NULL is returned.  FILE and LINE are the filename    and linenumber to include in the error message.  FILE must point    to something; LINE can be zero to indicate the line number is not    known.  */
end_comment

begin_function
name|char
modifier|*
name|expand_path
parameter_list|(
name|name
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|d
decl_stmt|;
name|char
modifier|*
name|mybuf
init|=
name|NULL
decl_stmt|;
name|size_t
name|mybuf_size
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|size_t
name|buf_size
init|=
literal|0
decl_stmt|;
name|size_t
name|doff
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
comment|/* Sorry this routine is so ugly; it is a head-on collision        between the `traditional' unix *d++ style and the need to        dynamically allocate.  It would be much cleaner (and probably        faster, not that this is a bottleneck for CVS) with more use of        strcpy& friends, but I haven't taken the effort to rewrite it        thusly.  */
comment|/* First copy from NAME to MYBUF, expanding $<foo> as we go.  */
name|s
operator|=
name|name
expr_stmt|;
name|d
operator|=
name|mybuf
expr_stmt|;
name|doff
operator|=
name|d
operator|-
name|mybuf
expr_stmt|;
name|expand_string
argument_list|(
operator|&
name|mybuf
argument_list|,
operator|&
name|mybuf_size
argument_list|,
name|doff
operator|+
literal|1
argument_list|)
expr_stmt|;
name|d
operator|=
name|mybuf
operator|+
name|doff
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|'$'
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|d
decl_stmt|;
name|char
modifier|*
name|e
decl_stmt|;
name|int
name|flag
init|=
operator|(
operator|*
name|s
operator|==
literal|'{'
operator|)
decl_stmt|;
name|doff
operator|=
name|d
operator|-
name|mybuf
expr_stmt|;
name|expand_string
argument_list|(
operator|&
name|mybuf
argument_list|,
operator|&
name|mybuf_size
argument_list|,
name|doff
operator|+
literal|1
argument_list|)
expr_stmt|;
name|d
operator|=
name|mybuf
operator|+
name|doff
expr_stmt|;
for|for
control|(
init|;
operator|(
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|)
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|flag
condition|?
operator|*
name|s
operator|==
literal|'}'
else|:
name|isalnum
argument_list|(
operator|*
name|s
argument_list|)
operator|==
literal|0
operator|&&
operator|*
name|s
operator|!=
literal|'_'
condition|)
break|break;
name|doff
operator|=
name|d
operator|-
name|mybuf
expr_stmt|;
name|expand_string
argument_list|(
operator|&
name|mybuf
argument_list|,
operator|&
name|mybuf_size
argument_list|,
name|doff
operator|+
literal|1
argument_list|)
expr_stmt|;
name|d
operator|=
name|mybuf
operator|+
name|doff
expr_stmt|;
block|}
operator|*
operator|--
name|d
operator|=
literal|'\0'
expr_stmt|;
name|e
operator|=
name|expand_variable
argument_list|(
operator|&
name|p
index|[
name|flag
index|]
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
block|{
name|doff
operator|=
name|d
operator|-
name|mybuf
expr_stmt|;
name|expand_string
argument_list|(
operator|&
name|mybuf
argument_list|,
operator|&
name|mybuf_size
argument_list|,
name|doff
operator|+
literal|1
argument_list|)
expr_stmt|;
name|d
operator|=
name|mybuf
operator|+
name|doff
expr_stmt|;
for|for
control|(
name|d
operator|=
operator|&
name|p
index|[
operator|-
literal|1
index|]
init|;
operator|(
operator|*
name|d
operator|++
operator|=
operator|*
name|e
operator|++
operator|)
condition|;
control|)
block|{
name|doff
operator|=
name|d
operator|-
name|mybuf
expr_stmt|;
name|expand_string
argument_list|(
operator|&
name|mybuf
argument_list|,
operator|&
name|mybuf_size
argument_list|,
name|doff
operator|+
literal|1
argument_list|)
expr_stmt|;
name|d
operator|=
name|mybuf
operator|+
name|doff
expr_stmt|;
block|}
operator|--
name|d
expr_stmt|;
if|if
condition|(
name|flag
operator|&&
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
block|}
else|else
comment|/* expand_variable has already printed an error message.  */
goto|goto
name|error_exit
goto|;
block|}
name|doff
operator|=
name|d
operator|-
name|mybuf
expr_stmt|;
name|expand_string
argument_list|(
operator|&
name|mybuf
argument_list|,
operator|&
name|mybuf_size
argument_list|,
name|doff
operator|+
literal|1
argument_list|)
expr_stmt|;
name|d
operator|=
name|mybuf
operator|+
name|doff
expr_stmt|;
block|}
name|doff
operator|=
name|d
operator|-
name|mybuf
expr_stmt|;
name|expand_string
argument_list|(
operator|&
name|mybuf
argument_list|,
operator|&
name|mybuf_size
argument_list|,
name|doff
operator|+
literal|1
argument_list|)
expr_stmt|;
name|d
operator|=
name|mybuf
operator|+
name|doff
expr_stmt|;
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
comment|/* Then copy from MYBUF to BUF, expanding ~.  */
name|s
operator|=
name|mybuf
expr_stmt|;
name|d
operator|=
name|buf
expr_stmt|;
comment|/* If you don't want ~username ~/ to be expanded simply remove      * This entire if statement including the else portion      */
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|'~'
condition|)
block|{
name|char
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|s
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'/'
operator|||
operator|*
name|s
operator|==
literal|0
condition|)
name|t
operator|=
name|get_homedir
argument_list|()
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|GETPWNAM_MISSING
for|for
control|(
init|;
operator|*
name|p
operator|!=
literal|'/'
operator|&&
operator|*
name|p
condition|;
name|p
operator|++
control|)
empty_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|line
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s:%d:tilde expansion not supported on this system"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s:tilde expansion not supported on this system"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
else|#
directive|else
name|struct
name|passwd
modifier|*
name|ps
decl_stmt|;
for|for
control|(
init|;
operator|*
name|p
operator|!=
literal|'/'
operator|&&
operator|*
name|p
condition|;
name|p
operator|++
control|)
empty_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|ps
operator|=
name|getpwnam
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|line
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s:%d: no such user %s"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: no such user %s"
argument_list|,
name|file
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|t
operator|=
name|ps
operator|->
name|pw_dir
expr_stmt|;
endif|#
directive|endif
block|}
name|doff
operator|=
name|d
operator|-
name|buf
expr_stmt|;
name|expand_string
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|buf_size
argument_list|,
name|doff
operator|+
literal|1
argument_list|)
expr_stmt|;
name|d
operator|=
name|buf
operator|+
name|doff
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|d
operator|++
operator|=
operator|*
name|t
operator|++
operator|)
condition|)
block|{
name|doff
operator|=
name|d
operator|-
name|buf
expr_stmt|;
name|expand_string
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|buf_size
argument_list|,
name|doff
operator|+
literal|1
argument_list|)
expr_stmt|;
name|d
operator|=
name|buf
operator|+
name|doff
expr_stmt|;
block|}
operator|--
name|d
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
comment|/* always add / */
name|s
operator|=
name|p
expr_stmt|;
block|}
else|else
operator|--
name|s
expr_stmt|;
comment|/* Kill up to here */
name|doff
operator|=
name|d
operator|-
name|buf
expr_stmt|;
name|expand_string
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|buf_size
argument_list|,
name|doff
operator|+
literal|1
argument_list|)
expr_stmt|;
name|d
operator|=
name|buf
operator|+
name|doff
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
operator|)
condition|)
block|{
name|doff
operator|=
name|d
operator|-
name|buf
expr_stmt|;
name|expand_string
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|buf_size
argument_list|,
name|doff
operator|+
literal|1
argument_list|)
expr_stmt|;
name|d
operator|=
name|buf
operator|+
name|doff
expr_stmt|;
block|}
name|doff
operator|=
name|d
operator|-
name|buf
expr_stmt|;
name|expand_string
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|buf_size
argument_list|,
name|doff
operator|+
literal|1
argument_list|)
expr_stmt|;
name|d
operator|=
name|buf
operator|+
name|doff
expr_stmt|;
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
comment|/* OK, buf contains the value we want to return.  Clean up and return        it.  */
name|free
argument_list|(
name|mybuf
argument_list|)
expr_stmt|;
comment|/* Save a little memory with xstrdup; buf will tend to allocate        more than it needs to.  */
name|result
operator|=
name|xstrdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|result
return|;
name|error_exit
label|:
if|if
condition|(
name|mybuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|mybuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|expand_variable
parameter_list|(
name|name
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|CVSROOT_ENV
argument_list|)
operator|==
literal|0
condition|)
return|return
name|CVSroot_original
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"RCSBIN"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"RCSBIN internal variable is no longer supported"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|EDITOR1_ENV
argument_list|)
operator|==
literal|0
condition|)
return|return
name|Editor
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|EDITOR2_ENV
argument_list|)
operator|==
literal|0
condition|)
return|return
name|Editor
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|EDITOR3_ENV
argument_list|)
operator|==
literal|0
condition|)
return|return
name|Editor
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"USER"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|getcaller
argument_list|()
return|;
elseif|else
if|if
condition|(
name|isalpha
argument_list|(
name|name
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
comment|/* These names are reserved for future versions of CVS, 	   so that is why it is an error.  */
if|if
condition|(
name|line
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s:%d: no such internal variable $%s"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: no such internal variable $%s"
argument_list|,
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
elseif|else
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'='
condition|)
block|{
name|Node
modifier|*
name|node
decl_stmt|;
comment|/* Crazy syntax for a user variable.  But we want 	   *something* that lets the user name a user variable 	   anything he wants, without interference from 	   (existing or future) internal variables.  */
name|node
operator|=
name|findnode
argument_list|(
name|variable_list
argument_list|,
name|name
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|line
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s:%d: no such user variable ${%s}"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: no such user variable ${%s}"
argument_list|,
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|node
operator|->
name|data
return|;
block|}
else|else
block|{
comment|/* It is an unrecognized character.  We return an error to 	   reserve these for future versions of CVS; it is plausible 	   that various crazy syntaxes might be invented for inserting 	   information about revisions, branches, etc.  */
if|if
condition|(
name|line
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s:%d: unrecognized variable syntax %s"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: unrecognized variable syntax %s"
argument_list|,
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

end_unit

