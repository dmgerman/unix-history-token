begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* expand_path.c -- expand environmental variables in passed in string  *  * Copyright (C) 1995-2005 The Free Software Foundation, Inc.  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2, or (at your option)  * any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * The main routine is expand_path(), it is the routine that handles  * the '~' character in four forms:   *     ~name  *     ~name/  *     ~/  *     ~  * and handles environment variables contained within the pathname  * which are defined by:  *     ${var_name}   (var_name is the name of the environ variable)  *     $var_name     (var_name ends w/ non-alphanumeric char other than '_')  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_decl_stmt
specifier|static
name|char
modifier|*
name|expand_variable
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|env
operator|,
specifier|const
name|char
operator|*
name|file
operator|,
name|int
name|line
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* User variables.  */
end_comment

begin_decl_stmt
name|List
modifier|*
name|variable_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|variable_delproc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|variable_delproc
parameter_list|(
name|node
parameter_list|)
name|Node
modifier|*
name|node
decl_stmt|;
block|{
name|free
argument_list|(
name|node
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Currently used by -s option; we might want a way to set user    variables in a file in the $CVSROOT/CVSROOT directory too.  */
end_comment

begin_function
name|void
name|variable_set
parameter_list|(
name|nameval
parameter_list|)
name|char
modifier|*
name|nameval
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|Node
modifier|*
name|node
decl_stmt|;
name|p
operator|=
name|nameval
expr_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'_'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'='
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"illegal character in user variable name in %s"
argument_list|,
name|nameval
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|nameval
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"empty user variable name in %s"
argument_list|,
name|nameval
argument_list|)
expr_stmt|;
name|name
operator|=
name|xmalloc
argument_list|(
name|p
operator|-
name|nameval
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|name
argument_list|,
name|nameval
argument_list|,
name|p
operator|-
name|nameval
argument_list|)
expr_stmt|;
name|name
index|[
name|p
operator|-
name|nameval
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Make p point to the value.  */
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\012'
argument_list|)
operator|!=
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"linefeed in user variable value in %s"
argument_list|,
name|nameval
argument_list|)
expr_stmt|;
if|if
condition|(
name|variable_list
operator|==
name|NULL
condition|)
name|variable_list
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|node
operator|=
name|findnode
argument_list|(
name|variable_list
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
block|{
name|node
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|node
operator|->
name|type
operator|=
name|VARIABLE
expr_stmt|;
name|node
operator|->
name|delproc
operator|=
name|variable_delproc
expr_stmt|;
name|node
operator|->
name|key
operator|=
name|name
expr_stmt|;
name|node
operator|->
name|data
operator|=
name|xstrdup
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|variable_list
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Replace the old value.  For example, this means that -s 	   options on the command line override ones from .cvsrc.  */
name|free
argument_list|(
name|node
operator|->
name|data
argument_list|)
expr_stmt|;
name|node
operator|->
name|data
operator|=
name|xstrdup
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This routine will expand the pathname to account for ~ and $    characters as described above.  Returns a pointer to a newly    malloc'd string.  If an error occurs, an error message is printed    via error() and NULL is returned.  FILE and LINE are the filename    and linenumber to include in the error message.  FILE must point    to something; LINE can be zero to indicate the line number is not    known.  */
end_comment

begin_function
name|char
modifier|*
name|expand_path
parameter_list|(
name|name
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|size_t
name|s
decl_stmt|,
name|d
decl_stmt|,
name|p
decl_stmt|;
name|char
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|mybuf
init|=
name|NULL
decl_stmt|;
name|size_t
name|mybuf_size
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|size_t
name|buf_size
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
comment|/* Sorry this routine is so ugly; it is a head-on collision        between the `traditional' unix *d++ style and the need to        dynamically allocate.  It would be much cleaner (and probably        faster, not that this is a bottleneck for CVS) with more use of        strcpy& friends, but I haven't taken the effort to rewrite it        thusly.  */
comment|/* First copy from NAME to MYBUF, expanding $<foo> as we go.  */
name|s
operator|=
name|d
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|name
index|[
name|s
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|name
index|[
name|s
index|]
operator|==
literal|'$'
condition|)
block|{
name|p
operator|=
name|d
expr_stmt|;
if|if
condition|(
name|name
index|[
operator|++
name|s
index|]
operator|==
literal|'{'
condition|)
block|{
while|while
condition|(
name|name
index|[
operator|++
name|s
index|]
operator|!=
literal|'}'
operator|&&
name|name
index|[
name|s
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|expand_string
argument_list|(
operator|&
name|mybuf
argument_list|,
operator|&
name|mybuf_size
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|mybuf
index|[
name|p
operator|++
index|]
operator|=
name|name
index|[
name|s
index|]
expr_stmt|;
block|}
if|if
condition|(
name|name
index|[
name|s
index|]
operator|!=
literal|'\0'
condition|)
operator|++
name|s
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|isalnum
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|name
index|[
name|s
index|]
argument_list|)
operator|||
name|name
index|[
name|s
index|]
operator|==
literal|'_'
condition|)
block|{
name|expand_string
argument_list|(
operator|&
name|mybuf
argument_list|,
operator|&
name|mybuf_size
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|mybuf
index|[
name|p
operator|++
index|]
operator|=
name|name
index|[
name|s
operator|++
index|]
expr_stmt|;
block|}
block|}
name|expand_string
argument_list|(
operator|&
name|mybuf
argument_list|,
operator|&
name|mybuf_size
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|mybuf
index|[
name|p
index|]
operator|=
literal|'\0'
expr_stmt|;
name|e
operator|=
name|expand_variable
argument_list|(
name|mybuf
operator|+
name|d
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
block|{
name|p
operator|=
name|strlen
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|expand_string
argument_list|(
operator|&
name|mybuf
argument_list|,
operator|&
name|mybuf_size
argument_list|,
name|d
operator|+
name|p
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|mybuf
operator|+
name|d
argument_list|,
name|e
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|d
operator|+=
name|p
expr_stmt|;
block|}
else|else
comment|/* expand_variable has already printed an error message.  */
goto|goto
name|error_exit
goto|;
block|}
else|else
block|{
name|expand_string
argument_list|(
operator|&
name|mybuf
argument_list|,
operator|&
name|mybuf_size
argument_list|,
name|d
operator|+
literal|1
argument_list|)
expr_stmt|;
name|mybuf
index|[
name|d
operator|++
index|]
operator|=
name|name
index|[
name|s
operator|++
index|]
expr_stmt|;
block|}
block|}
name|expand_string
argument_list|(
operator|&
name|mybuf
argument_list|,
operator|&
name|mybuf_size
argument_list|,
name|d
operator|+
literal|1
argument_list|)
expr_stmt|;
name|mybuf
index|[
name|d
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Then copy from MYBUF to BUF, expanding ~.  */
name|s
operator|=
name|d
operator|=
literal|0
expr_stmt|;
comment|/* If you don't want ~username ~/ to be expanded simply remove      * This entire if statement including the else portion      */
if|if
condition|(
name|mybuf
index|[
name|s
index|]
operator|==
literal|'~'
condition|)
block|{
name|p
operator|=
name|d
expr_stmt|;
while|while
condition|(
name|mybuf
index|[
operator|++
name|s
index|]
operator|!=
literal|'/'
operator|&&
name|mybuf
index|[
name|s
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|expand_string
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|buf_size
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|buf
index|[
name|p
operator|++
index|]
operator|=
name|name
index|[
name|s
index|]
expr_stmt|;
block|}
name|expand_string
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|buf_size
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|buf
index|[
name|p
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|d
condition|)
name|e
operator|=
name|get_homedir
argument_list|()
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|GETPWNAM_MISSING
if|if
condition|(
name|line
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s:%d:tilde expansion not supported on this system"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s:tilde expansion not supported on this system"
argument_list|,
name|file
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
else|#
directive|else
name|struct
name|passwd
modifier|*
name|ps
decl_stmt|;
name|ps
operator|=
name|getpwnam
argument_list|(
name|buf
operator|+
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|line
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s:%d: no such user %s"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|buf
operator|+
name|d
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: no such user %s"
argument_list|,
name|file
argument_list|,
name|buf
operator|+
name|d
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
name|e
operator|=
name|ps
operator|->
name|pw_dir
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot find home directory"
argument_list|)
expr_stmt|;
name|p
operator|=
name|strlen
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|expand_string
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|buf_size
argument_list|,
name|d
operator|+
name|p
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
operator|+
name|d
argument_list|,
name|e
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|d
operator|+=
name|p
expr_stmt|;
block|}
comment|/* Kill up to here */
name|p
operator|=
name|strlen
argument_list|(
name|mybuf
operator|+
name|s
argument_list|)
operator|+
literal|1
expr_stmt|;
name|expand_string
argument_list|(
operator|&
name|buf
argument_list|,
operator|&
name|buf_size
argument_list|,
name|d
operator|+
name|p
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
operator|+
name|d
argument_list|,
name|mybuf
operator|+
name|s
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* OK, buf contains the value we want to return.  Clean up and return        it.  */
name|free
argument_list|(
name|mybuf
argument_list|)
expr_stmt|;
comment|/* Save a little memory with xstrdup; buf will tend to allocate        more than it needs to.  */
name|result
operator|=
name|xstrdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|result
return|;
name|error_exit
label|:
if|if
condition|(
name|mybuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|mybuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|expand_variable
parameter_list|(
name|name
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|CVSROOT_ENV
argument_list|)
operator|==
literal|0
condition|)
return|return
name|current_parsed_root
operator|->
name|directory
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"RCSBIN"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"RCSBIN internal variable is no longer supported"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|EDITOR1_ENV
argument_list|)
operator|==
literal|0
condition|)
return|return
name|Editor
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|EDITOR2_ENV
argument_list|)
operator|==
literal|0
condition|)
return|return
name|Editor
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|EDITOR3_ENV
argument_list|)
operator|==
literal|0
condition|)
return|return
name|Editor
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"USER"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|getcaller
argument_list|()
return|;
elseif|else
if|if
condition|(
name|isalpha
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|name
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
comment|/* These names are reserved for future versions of CVS, 	   so that is why it is an error.  */
if|if
condition|(
name|line
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s:%d: no such internal variable $%s"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: no such internal variable $%s"
argument_list|,
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
elseif|else
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'='
condition|)
block|{
name|Node
modifier|*
name|node
decl_stmt|;
comment|/* Crazy syntax for a user variable.  But we want 	   *something* that lets the user name a user variable 	   anything he wants, without interference from 	   (existing or future) internal variables.  */
name|node
operator|=
name|findnode
argument_list|(
name|variable_list
argument_list|,
name|name
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|line
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s:%d: no such user variable ${%s}"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: no such user variable ${%s}"
argument_list|,
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|node
operator|->
name|data
return|;
block|}
else|else
block|{
comment|/* It is an unrecognized character.  We return an error to 	   reserve these for future versions of CVS; it is plausible 	   that various crazy syntaxes might be invented for inserting 	   information about revisions, branches, etc.  */
if|if
condition|(
name|line
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s:%d: unrecognized variable syntax %s"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s: unrecognized variable syntax %s"
argument_list|,
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

end_unit

