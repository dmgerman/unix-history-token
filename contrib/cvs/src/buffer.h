begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Declarations concerning the buffer data structure.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SERVER_SUPPORT
argument_list|)
operator|||
name|defined
argument_list|(
name|CLIENT_SUPPORT
argument_list|)
end_if

begin_comment
comment|/*  * We must read data from a child process and send it across the  * network.  We do not want to block on writing to the network, so we  * store the data from the child process in memory.  A BUFFER  * structure holds the status of one communication, and uses a linked  * list of buffer_data structures to hold data.  */
end_comment

begin_struct
struct|struct
name|buffer
block|{
comment|/* Data.  */
name|struct
name|buffer_data
modifier|*
name|data
decl_stmt|;
comment|/* Last buffer on data chain.  */
name|struct
name|buffer_data
modifier|*
name|last
decl_stmt|;
comment|/* Nonzero if the buffer is in nonblocking mode.  */
name|int
name|nonblocking
decl_stmt|;
comment|/* Functions must be provided to transfer data in and out of the        buffer.  Either the input or output field must be set, but not        both.  */
comment|/* Read data into the buffer DATA.  There is room for up to SIZE        bytes.  In blocking mode, wait until some input, at least NEED        bytes, is available (NEED may be 0 but that is the same as NEED        == 1).  In non-blocking mode return immediately no matter how        much input is available; NEED is ignored. Return 0 on success,        or -1 on end of file, or an errno code.  Set the number of        bytes read in *GOT.                If there are a nonzero number of bytes available, less than NEED,        followed by end of file, just read those bytes and return 0.  */
name|int
argument_list|(
argument|*input
argument_list|)
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|closure
operator|,
name|char
operator|*
name|data
operator|,
name|int
name|need
operator|,
name|int
name|size
operator|,
name|int
operator|*
name|got
operator|)
argument_list|)
expr_stmt|;
comment|/* Write data.  This should write up to HAVE bytes from DATA.        This should return 0 on success, or an errno code.  It should        set the number of bytes written in *WROTE.  */
name|int
argument_list|(
argument|*output
argument_list|)
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|closure
operator|,
specifier|const
name|char
operator|*
name|data
operator|,
name|int
name|have
operator|,
name|int
operator|*
name|wrote
operator|)
argument_list|)
expr_stmt|;
comment|/* Flush any data which may be buffered up after previous calls to        OUTPUT.  This should return 0 on success, or an errno code.  */
name|int
argument_list|(
argument|*flush
argument_list|)
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|closure
operator|)
argument_list|)
expr_stmt|;
comment|/* Change the blocking mode of the underlying communication        stream.  If BLOCK is non-zero, it should be placed into        blocking mode.  Otherwise, it should be placed into        non-blocking mode.  This should return 0 on success, or an        errno code.  */
name|int
argument_list|(
argument|*block
argument_list|)
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|closure
operator|,
name|int
name|block
operator|)
argument_list|)
expr_stmt|;
comment|/* Shut down the communication stream.  This does not mean that it        should be closed.  It merely means that no more data will be        read or written, and that any final processing that is        appropriate should be done at this point.  This may be NULL.        It should return 0 on success, or an errno code.  This entry        point exists for the compression code.  */
name|int
argument_list|(
argument|*shutdown
argument_list|)
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* This field is passed to the INPUT, OUTPUT, and BLOCK functions.  */
name|void
modifier|*
name|closure
decl_stmt|;
comment|/* Function to call if we can't allocate memory.  */
name|void
argument_list|(
argument|*memory_error
argument_list|)
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|)
argument_list|)
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Data is stored in lists of these structures.  */
end_comment

begin_struct
struct|struct
name|buffer_data
block|{
comment|/* Next buffer in linked list.  */
name|struct
name|buffer_data
modifier|*
name|next
decl_stmt|;
comment|/*      * A pointer into the data area pointed to by the text field.  This      * is where to find data that has not yet been written out.      */
name|char
modifier|*
name|bufp
decl_stmt|;
comment|/* The number of data bytes found at BUFP.  */
name|int
name|size
decl_stmt|;
comment|/*      * Actual buffer.  This never changes after the structure is      * allocated.  The buffer is BUFFER_DATA_SIZE bytes.      */
name|char
modifier|*
name|text
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The size we allocate for each buffer_data structure.  */
end_comment

begin_define
define|#
directive|define
name|BUFFER_DATA_SIZE
value|(4096)
end_define

begin_comment
comment|/* The type of a function passed as a memory error handler.  */
end_comment

begin_typedef
typedef|typedef
name|void
argument_list|(
argument|*BUFMEMERRPROC
argument_list|)
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|)
argument_list|)
expr_stmt|;
end_typedef

begin_decl_stmt
specifier|extern
name|struct
name|buffer
modifier|*
name|buf_initialize
name|PROTO
argument_list|(
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
name|char
operator|*
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
name|int
operator|*
argument_list|)
operator|,
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|int
argument_list|,
name|int
operator|*
argument_list|)
operator|,
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|,
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
name|int
argument_list|)
operator|,
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
expr|struct
name|buffer
operator|*
argument_list|)
operator|,
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
expr|struct
name|buffer
operator|*
argument_list|)
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|buf_free
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|buffer
modifier|*
name|buf_nonio_initialize
name|PROTO
argument_list|(
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
expr|struct
name|buffer
operator|*
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|buffer
modifier|*
name|stdio_buffer_initialize
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
expr|struct
name|buffer
operator|*
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|buffer
modifier|*
name|compress_buffer_initialize
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
expr|struct
name|buffer
operator|*
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|buffer
modifier|*
name|packetizing_buffer_initialize
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|,
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|char
operator|*
argument_list|,
name|int
argument_list|)
operator|,
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|char
operator|*
argument_list|,
name|int
argument_list|,
name|int
operator|*
argument_list|)
operator|,
name|void
operator|*
operator|,
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
expr|struct
name|buffer
operator|*
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|buf_empty_p
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|buf_output
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|buf_output0
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|buf_append_char
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|buf_send_output
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|buf_flush
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|set_nonblock
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|set_block
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|buf_send_counted
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|buf_send_special_count
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|buf_append_data
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|,
expr|struct
name|buffer_data
operator|*
operator|,
expr|struct
name|buffer_data
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|buf_append_buffer
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|,
expr|struct
name|buffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|buf_read_file
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|long
operator|,
expr|struct
name|buffer_data
operator|*
operator|*
operator|,
expr|struct
name|buffer_data
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|buf_read_file_to_eof
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
expr|struct
name|buffer_data
operator|*
operator|*
operator|,
expr|struct
name|buffer_data
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|buf_input_data
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|buf_read_line
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|buf_read_data
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|buf_copy_lines
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|,
expr|struct
name|buffer
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|buf_copy_counted
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|,
expr|struct
name|buffer
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|buf_chain_length
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer_data
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|buf_length
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|buf_shutdown
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SERVER_FLOWCONTROL
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|buf_count_mem
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SERVER_FLOWCONTROL */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined (SERVER_SUPPORT) || defined (CLIENT_SUPPORT) */
end_comment

end_unit

