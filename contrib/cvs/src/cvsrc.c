begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1993 david d zuhn  *   * Written by david d `zoo' zuhn while at Cygnus Support  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS source distribution.  *  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"getline.h"
end_include

begin_comment
comment|/* this file is to be found in the user's home directory */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CVSRC_FILENAME
end_ifndef

begin_define
define|#
directive|define
name|CVSRC_FILENAME
value|".cvsrc"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|cvsrc
index|[]
init|=
name|CVSRC_FILENAME
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|GROW
value|10
end_define

begin_function_decl
specifier|extern
name|char
modifier|*
name|strtok
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Read cvsrc, processing options matching CMDNAME ("cvs" for global    options, and update *ARGC and *ARGV accordingly.  */
end_comment

begin_function
name|void
name|read_cvsrc
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|cmdname
parameter_list|)
name|int
modifier|*
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|cmdname
decl_stmt|;
block|{
name|char
modifier|*
name|homedir
decl_stmt|;
name|char
modifier|*
name|homeinit
decl_stmt|;
name|FILE
modifier|*
name|cvsrcfile
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|line_length
decl_stmt|;
name|size_t
name|line_chars_allocated
decl_stmt|;
name|char
modifier|*
name|optstart
decl_stmt|;
name|int
name|command_len
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|new_argc
decl_stmt|;
name|int
name|max_new_argv
decl_stmt|;
name|char
modifier|*
modifier|*
name|new_argv
decl_stmt|;
comment|/* old_argc and old_argv hold the values returned from the        previous invocation of read_cvsrc and are used to free the        allocated memory.  The first invocation of read_cvsrc gets argv        from the system, this memory must not be free'd.  */
specifier|static
name|int
name|old_argc
init|=
literal|0
decl_stmt|;
specifier|static
name|char
modifier|*
modifier|*
name|old_argv
init|=
name|NULL
decl_stmt|;
comment|/* don't do anything if argc is -1, since that implies "help" mode */
if|if
condition|(
operator|*
name|argc
operator|==
operator|-
literal|1
condition|)
return|return;
comment|/* determine filename for ~/.cvsrc */
name|homedir
operator|=
name|get_homedir
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|homedir
condition|)
return|return;
name|homeinit
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|homedir
argument_list|)
operator|+
name|strlen
argument_list|(
name|cvsrc
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|homeinit
argument_list|,
name|homedir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|homeinit
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|homeinit
argument_list|,
name|cvsrc
argument_list|)
expr_stmt|;
comment|/* if it can't be read, there's no point to continuing */
if|if
condition|(
operator|!
name|isreadable
argument_list|(
name|homeinit
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|homeinit
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* now scan the file until we find the line for the command in question */
name|line
operator|=
name|NULL
expr_stmt|;
name|line_chars_allocated
operator|=
literal|0
expr_stmt|;
name|command_len
operator|=
name|strlen
argument_list|(
name|cmdname
argument_list|)
expr_stmt|;
name|cvsrcfile
operator|=
name|open_file
argument_list|(
name|homeinit
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|line_length
operator|=
name|getline
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|line_chars_allocated
argument_list|,
name|cvsrcfile
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
comment|/* skip over comment lines */
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
continue|continue;
comment|/* stop if we match the current command */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|line
argument_list|,
name|cmdname
argument_list|,
name|command_len
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
operator|(
name|line
operator|+
name|command_len
operator|)
argument_list|)
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|line_length
operator|<
literal|0
operator|&&
operator|!
name|feof
argument_list|(
name|cvsrcfile
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|homeinit
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|cvsrcfile
argument_list|)
expr_stmt|;
comment|/* setup the new options list */
name|new_argc
operator|=
literal|1
expr_stmt|;
name|max_new_argv
operator|=
operator|(
operator|*
name|argc
operator|)
operator|+
name|GROW
expr_stmt|;
name|new_argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_new_argv
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|new_argv
index|[
literal|0
index|]
operator|=
name|xstrdup
argument_list|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
block|{
comment|/* skip over command in the options line */
for|for
control|(
name|optstart
operator|=
name|strtok
argument_list|(
name|line
operator|+
name|command_len
argument_list|,
literal|"\t \n"
argument_list|)
init|;
name|optstart
condition|;
name|optstart
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|"\t \n"
argument_list|)
control|)
block|{
name|new_argv
index|[
name|new_argc
operator|++
index|]
operator|=
name|xstrdup
argument_list|(
name|optstart
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_argc
operator|>=
name|max_new_argv
condition|)
block|{
name|max_new_argv
operator|+=
name|GROW
expr_stmt|;
name|new_argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|new_argv
argument_list|,
name|max_new_argv
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|line
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|/* now copy the remaining arguments */
if|if
condition|(
name|new_argc
operator|+
operator|*
name|argc
operator|>
name|max_new_argv
condition|)
block|{
name|max_new_argv
operator|=
name|new_argc
operator|+
operator|*
name|argc
expr_stmt|;
name|new_argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|new_argv
argument_list|,
name|max_new_argv
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
operator|*
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|new_argv
index|[
name|new_argc
operator|++
index|]
operator|=
name|xstrdup
argument_list|(
operator|(
operator|*
name|argv
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|old_argv
operator|!=
name|NULL
condition|)
block|{
comment|/* Free the memory which was allocated in the previous            read_cvsrc call.  */
name|free_names
argument_list|(
operator|&
name|old_argc
argument_list|,
name|old_argv
argument_list|)
expr_stmt|;
block|}
name|old_argc
operator|=
operator|*
name|argc
operator|=
name|new_argc
expr_stmt|;
name|old_argv
operator|=
operator|*
name|argv
operator|=
name|new_argv
expr_stmt|;
name|free
argument_list|(
name|homeinit
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

