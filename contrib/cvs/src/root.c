begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Mark D. Baushke  *  * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS source distribution.  *   * Name of Root  *   * Determine the path to the CVSROOT and set "Root" accordingly.  * If this looks like of modified clone of Name_Repository() in  * repos.c, it is...   */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"getline.h"
end_include

begin_comment
comment|/* Printable names for things in the CVSroot_method enum variable.    Watch out if the enum is changed in cvs.h! */
end_comment

begin_decl_stmt
name|char
modifier|*
name|method_names
index|[]
init|=
block|{
literal|"local"
block|,
literal|"server (rsh)"
block|,
literal|"pserver"
block|,
literal|"kserver"
block|,
literal|"gserver"
block|,
literal|"ext"
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG
end_ifndef

begin_function
name|char
modifier|*
name|Name_Root
parameter_list|(
name|dir
parameter_list|,
name|update_dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
name|FILE
modifier|*
name|fpin
decl_stmt|;
name|char
modifier|*
name|ret
decl_stmt|,
modifier|*
name|xupdate_dir
decl_stmt|;
name|char
modifier|*
name|root
init|=
name|NULL
decl_stmt|;
name|size_t
name|root_allocated
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
name|char
modifier|*
name|cvsadm
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|update_dir
operator|&&
operator|*
name|update_dir
condition|)
name|xupdate_dir
operator|=
name|update_dir
expr_stmt|;
else|else
name|xupdate_dir
operator|=
literal|"."
expr_stmt|;
if|if
condition|(
name|dir
operator|!=
name|NULL
condition|)
block|{
name|cvsadm
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSADM
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cvsadm
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|CVSADM
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSADM_ROOT
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|CVSADM_ROOT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cvsadm
operator|=
name|xstrdup
argument_list|(
name|CVSADM
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|xstrdup
argument_list|(
name|CVSADM_ROOT
argument_list|)
expr_stmt|;
block|}
comment|/*      * Do not bother looking for a readable file if there is no cvsadm      * directory present.      *      * It is possible that not all repositories will have a CVS/Root      * file. This is ok, but the user will need to specify -d      * /path/name or have the environment variable CVSROOT set in      * order to continue.  */
if|if
condition|(
operator|(
operator|!
name|isdir
argument_list|(
name|cvsadm
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|isreadable
argument_list|(
name|tmp
argument_list|)
operator|)
condition|)
block|{
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*      * The assumption here is that the CVS Root is always contained in the      * first line of the "Root" file.      */
name|fpin
operator|=
name|open_file
argument_list|(
name|tmp
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|getline
argument_list|(
operator|&
name|root
argument_list|,
operator|&
name|root_allocated
argument_list|,
name|fpin
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* FIXME: should be checking for end of file separately; errno 	   is not set in that case.  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"in directory %s:"
argument_list|,
name|xupdate_dir
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|CVSADM_ROOT
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"please correct this problem"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fpin
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|root
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* strip the newline */
comment|/*      * root now contains a candidate for CVSroot. It must be an      * absolute pathname or specify a remote server.      */
if|if
condition|(
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
operator|(
name|strchr
argument_list|(
name|root
argument_list|,
literal|':'
argument_list|)
operator|==
name|NULL
operator|)
operator|&&
endif|#
directive|endif
operator|!
name|isabsolute
argument_list|(
name|root
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"in directory %s:"
argument_list|,
name|xupdate_dir
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"ignoring %s because it does not contain an absolute pathname."
argument_list|,
name|CVSADM_ROOT
argument_list|)
expr_stmt|;
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
if|if
condition|(
operator|(
name|strchr
argument_list|(
name|root
argument_list|,
literal|':'
argument_list|)
operator|==
name|NULL
operator|)
operator|&&
operator|!
name|isdir
argument_list|(
name|root
argument_list|)
condition|)
else|#
directive|else
comment|/* ! CLIENT_SUPPORT */
if|if
condition|(
operator|!
name|isdir
argument_list|(
name|root
argument_list|)
condition|)
endif|#
directive|endif
comment|/* CLIENT_SUPPORT */
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"in directory %s:"
argument_list|,
name|xupdate_dir
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"ignoring %s because it specifies a non-existent repository %s"
argument_list|,
name|CVSADM_ROOT
argument_list|,
name|root
argument_list|)
expr_stmt|;
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* allocate space to return and fill it in */
name|strip_trailing_slashes
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|ret
operator|=
name|xstrdup
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|cvsadm
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|root
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|root
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write the CVS/Root file so that the environment variable CVSROOT  * and/or the -d option to cvs will be validated or not necessary for  * future work.  */
end_comment

begin_function
name|void
name|Create_Root
parameter_list|(
name|dir
parameter_list|,
name|rootdir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|rootdir
decl_stmt|;
block|{
name|FILE
modifier|*
name|fout
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|noexec
condition|)
return|return;
comment|/* record the current cvs root */
if|if
condition|(
name|rootdir
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dir
operator|!=
name|NULL
condition|)
block|{
name|tmp
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSADM_ROOT
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|CVSADM_ROOT
argument_list|)
expr_stmt|;
block|}
else|else
name|tmp
operator|=
name|xstrdup
argument_list|(
name|CVSADM_ROOT
argument_list|)
expr_stmt|;
name|fout
operator|=
name|open_file
argument_list|(
name|tmp
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"%s\n"
argument_list|,
name|rootdir
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"write to %s failed"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fout
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! DEBUG */
end_comment

begin_comment
comment|/* The root_allow_* stuff maintains a list of legal CVSROOT    directories.  Then we can check against them when a remote user    hands us a CVSROOT directory.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|root_allow_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|root_allow_vector
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|root_allow_size
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|root_allow_add
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|root_allow_size
operator|<=
name|root_allow_count
condition|)
block|{
if|if
condition|(
name|root_allow_size
operator|==
literal|0
condition|)
block|{
name|root_allow_size
operator|=
literal|1
expr_stmt|;
name|root_allow_vector
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|root_allow_size
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|root_allow_size
operator|*=
literal|2
expr_stmt|;
name|root_allow_vector
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|root_allow_vector
argument_list|,
name|root_allow_size
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|root_allow_vector
operator|==
name|NULL
condition|)
block|{
name|no_memory
label|:
comment|/* Strictly speaking, we're not supposed to output anything 	       now.  But we're about to exit(), give it a try.  */
name|printf
argument_list|(
literal|"E Fatal server error, aborting.\n\ error ENOMEM Virtual memory exhausted.\n"
argument_list|)
expr_stmt|;
comment|/* I'm doing this manually rather than via error_exit () 	       because I'm not sure whether we want to call server_cleanup. 	       Needs more investigation....  */
ifdef|#
directive|ifdef
name|SYSTEM_CLEANUP
comment|/* Hook for OS-specific behavior, for example socket 	       subsystems on NT and OS2 or dealing with windows 	       and arguments on Mac.  */
name|SYSTEM_CLEANUP
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
name|p
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
goto|goto
name|no_memory
goto|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|root_allow_vector
index|[
name|root_allow_count
operator|++
index|]
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_function
name|void
name|root_allow_free
parameter_list|()
block|{
if|if
condition|(
name|root_allow_vector
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|root_allow_vector
argument_list|)
expr_stmt|;
name|root_allow_count
operator|=
literal|0
expr_stmt|;
name|root_allow_size
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|root_allow_ok
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|root_allow_count
operator|==
literal|0
condition|)
block|{
comment|/* Probably someone upgraded from CVS before 1.9.10 to 1.9.10 	   or later without reading the documentation about 	   --allow-root.  Printing an error here doesn't disclose any 	   particularly useful information to an attacker because a 	   CVS server configured in this way won't let *anyone* in.  */
comment|/* Note that we are called from a context where we can spit 	   back "error" rather than waiting for the next request which 	   expects responses.  */
name|printf
argument_list|(
literal|"\ error 0 Server configuration missing --allow-root in inetd.conf\n"
argument_list|)
expr_stmt|;
name|error_exit
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|root_allow_count
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|root_allow_vector
index|[
name|i
index|]
argument_list|,
name|arg
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Parse a CVSROOT variable into its constituent parts -- method,  * username, hostname, directory.  The prototypical CVSROOT variable  * looks like:  *  * :method:user@host:path  *  * Some methods may omit fields; local, for example, doesn't need user  * and host.  *  * Returns zero on success, non-zero on failure. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|CVSroot_original
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the CVSroot that was passed in */
end_comment

begin_decl_stmt
name|int
name|client_active
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nonzero if we are doing remote access */
end_comment

begin_decl_stmt
name|CVSmethod
name|CVSroot_method
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* one of the enum values defined in cvs.h */
end_comment

begin_decl_stmt
name|char
modifier|*
name|CVSroot_username
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the username or NULL if method == local */
end_comment

begin_decl_stmt
name|char
modifier|*
name|CVSroot_hostname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the hostname or NULL if method == local */
end_comment

begin_decl_stmt
name|char
modifier|*
name|CVSroot_directory
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the directory name */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AUTH_SERVER_SUPPORT
end_ifdef

begin_comment
comment|/* Die if CVSroot_directory and Pserver_Repos don't match. */
end_comment

begin_function
specifier|static
name|void
name|check_root_consistent
parameter_list|()
block|{
comment|/* FIXME: Should be using a deferred error, as the rest of        serve_root does.  As it is now the call to error could conceivably        cause deadlock, as noted in server_cleanup.  Best solution would        presumably be to write some code so that error() automatically        defers the error in those cases where that is needed.  */
comment|/* FIXME?  Possible that the wording should be more clear (e.g.           Root says "%s" but pserver protocol says "%s"        or something which would aid people who are writing implementations        of the client side of the CVS protocol.  I don't see any security        problem with revealing that information.  */
if|if
condition|(
operator|(
name|Pserver_Repos
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|CVSroot_directory
operator|!=
name|NULL
operator|)
condition|)
if|if
condition|(
name|strcmp
argument_list|(
name|Pserver_Repos
argument_list|,
name|CVSroot_directory
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"repository mismatch: \"%s\" vs \"%s\""
argument_list|,
name|Pserver_Repos
argument_list|,
name|CVSroot_directory
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTH_SERVER_SUPPORT */
end_comment

begin_function
name|int
name|parse_cvsroot
parameter_list|(
name|CVSroot
parameter_list|)
name|char
modifier|*
name|CVSroot
decl_stmt|;
block|{
specifier|static
name|int
name|cvsroot_parsed
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|cvsroot_copy
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|check_hostname
decl_stmt|;
comment|/* Don't go through the trouble twice. */
if|if
condition|(
name|cvsroot_parsed
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"WARNING (parse_cvsroot): someone called me twice!\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|CVSroot_original
operator|=
name|xstrdup
argument_list|(
name|CVSroot
argument_list|)
expr_stmt|;
name|cvsroot_copy
operator|=
name|xstrdup
argument_list|(
name|CVSroot
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|cvsroot_copy
operator|==
literal|':'
operator|)
condition|)
block|{
name|char
modifier|*
name|method
init|=
operator|++
name|cvsroot_copy
decl_stmt|;
comment|/* Access method specified, as in 	 * "cvs -d :pserver:user@host:/path", 	 * "cvs -d :local:e:\path", or 	 * "cvs -d :kserver:user@host:/path". 	 * We need to get past that part of CVSroot before parsing the 	 * rest of it. 	 */
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|method
argument_list|,
literal|':'
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"bad CVSroot: %s"
argument_list|,
name|CVSroot
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|cvsroot_copy
operator|=
operator|++
name|p
expr_stmt|;
comment|/* Now we have an access method -- see if it's valid. */
if|if
condition|(
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"local"
argument_list|)
operator|==
literal|0
condition|)
name|CVSroot_method
operator|=
name|local_method
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"pserver"
argument_list|)
operator|==
literal|0
condition|)
name|CVSroot_method
operator|=
name|pserver_method
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"kserver"
argument_list|)
operator|==
literal|0
condition|)
name|CVSroot_method
operator|=
name|kserver_method
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"gserver"
argument_list|)
operator|==
literal|0
condition|)
name|CVSroot_method
operator|=
name|gserver_method
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"server"
argument_list|)
operator|==
literal|0
condition|)
name|CVSroot_method
operator|=
name|server_method
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"ext"
argument_list|)
operator|==
literal|0
condition|)
name|CVSroot_method
operator|=
name|ext_method
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"unknown method in CVSroot: %s"
argument_list|,
name|CVSroot
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
else|else
block|{
comment|/* If the method isn't specified, assume 	   SERVER_METHOD/EXT_METHOD if the string contains a colon or 	   LOCAL_METHOD otherwise.  */
name|CVSroot_method
operator|=
operator|(
operator|(
name|strchr
argument_list|(
name|cvsroot_copy
argument_list|,
literal|':'
argument_list|)
operator|)
ifdef|#
directive|ifdef
name|RSH_NOT_TRANSPARENT
condition|?
name|server_method
else|#
directive|else
condition|?
name|ext_method
endif|#
directive|endif
else|:
name|local_method
operator|)
expr_stmt|;
block|}
name|client_active
operator|=
operator|(
name|CVSroot_method
operator|!=
name|local_method
operator|)
expr_stmt|;
comment|/* Check for username/hostname if we're not LOCAL_METHOD. */
name|CVSroot_username
operator|=
name|NULL
expr_stmt|;
name|CVSroot_hostname
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|CVSroot_method
operator|!=
name|local_method
condition|)
block|{
comment|/* Check to see if there is a username in the string. */
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|cvsroot_copy
argument_list|,
literal|'@'
argument_list|)
operator|)
condition|)
block|{
name|CVSroot_username
operator|=
name|cvsroot_copy
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|cvsroot_copy
operator|=
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|CVSroot_username
operator|==
literal|'\0'
condition|)
name|CVSroot_username
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|cvsroot_copy
argument_list|,
literal|':'
argument_list|)
operator|)
condition|)
block|{
name|CVSroot_hostname
operator|=
name|cvsroot_copy
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|cvsroot_copy
operator|=
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|CVSroot_hostname
operator|==
literal|'\0'
condition|)
name|CVSroot_hostname
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|CVSroot_directory
operator|=
name|cvsroot_copy
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTH_SERVER_SUPPORT
name|check_root_consistent
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* AUTH_SERVER_SUPPORT */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CLIENT_SUPPORT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|DEBUG
argument_list|)
if|if
condition|(
name|CVSroot_method
operator|!=
name|local_method
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Your CVSROOT is set for a remote access method"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"but your CVS executable doesn't support it"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"(%s)"
argument_list|,
name|CVSroot
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* Do various sanity checks. */
if|if
condition|(
name|CVSroot_username
operator|&&
operator|!
name|CVSroot_hostname
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"missing hostname in CVSROOT: %s"
argument_list|,
name|CVSroot
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|check_hostname
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|CVSroot_method
condition|)
block|{
case|case
name|local_method
case|:
if|if
condition|(
name|CVSroot_username
operator|||
name|CVSroot_hostname
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"can't specify hostname and username in CVSROOT"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"when using local access method"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"(%s)"
argument_list|,
name|CVSroot
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* cvs.texinfo has always told people that CVSROOT must be an 	   absolute pathname.  Furthermore, attempts to use a relative 	   pathname produced various errors (I couldn't get it to work), 	   so there would seem to be little risk in making this a fatal 	   error.  */
if|if
condition|(
operator|!
name|isabsolute
argument_list|(
name|CVSroot_directory
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"CVSROOT %s must be an absolute pathname"
argument_list|,
name|CVSroot_directory
argument_list|)
expr_stmt|;
break|break;
case|case
name|kserver_method
case|:
ifndef|#
directive|ifndef
name|HAVE_KERBEROS
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Your CVSROOT is set for a kerberos access method"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"but your CVS executable doesn't support it"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"(%s)"
argument_list|,
name|CVSroot
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
endif|#
directive|endif
name|check_hostname
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|gserver_method
case|:
ifndef|#
directive|ifndef
name|HAVE_GSSAPI
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Your CVSROOT is set for a GSSAPI access method"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"but your CVS executable doesn't support it"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"(%s)"
argument_list|,
name|CVSroot
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
endif|#
directive|endif
name|check_hostname
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|server_method
case|:
case|case
name|ext_method
case|:
case|case
name|pserver_method
case|:
name|check_hostname
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|check_hostname
condition|)
block|{
if|if
condition|(
operator|!
name|CVSroot_hostname
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"didn't specify hostname in CVSROOT: %s"
argument_list|,
name|CVSroot
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
operator|*
name|CVSroot_directory
operator|==
literal|'\0'
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"missing directory in CVSROOT: %s"
argument_list|,
name|CVSroot
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Hooray!  We finally parsed it! */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Set up the global CVSroot* variables as if we're using the local    repository DIR. */
end_comment

begin_function
name|void
name|set_local_cvsroot
parameter_list|(
name|dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
block|{
name|CVSroot_original
operator|=
name|xstrdup
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|CVSroot_method
operator|=
name|local_method
expr_stmt|;
name|CVSroot_directory
operator|=
name|CVSroot_original
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTH_SERVER_SUPPORT
name|check_root_consistent
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* AUTH_SERVER_SUPPORT */
name|CVSroot_username
operator|=
name|NULL
expr_stmt|;
name|CVSroot_hostname
operator|=
name|NULL
expr_stmt|;
name|client_active
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/* This is for testing the parsing function. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_decl_stmt
name|char
modifier|*
name|CVSroot
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|program_name
init|=
literal|"testing"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|command_name
init|=
literal|"parse_cvsroot"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX is this used??? */
end_comment

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s<CVSROOT>\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parse_cvsroot
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Parsing failed."
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"CVSroot: %s\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"CVSroot_method: %s\n"
argument_list|,
name|method_names
index|[
name|CVSroot_method
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"CVSroot_username: %s\n"
argument_list|,
name|CVSroot_username
condition|?
name|CVSroot_username
else|:
literal|"NULL"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"CVSroot_hostname: %s\n"
argument_list|,
name|CVSroot_hostname
condition|?
name|CVSroot_hostname
else|:
literal|"NULL"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"CVSroot_directory: %s\n"
argument_list|,
name|CVSroot_directory
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

