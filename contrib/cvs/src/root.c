begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Mark D. Baushke  *  * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS source distribution.  *   * Name of Root  *   * Determine the path to the CVSROOT and set "Root" accordingly.  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"getline.h"
end_include

begin_comment
comment|/* Printable names for things in the current_parsed_root->method enum variable.    Watch out if the enum is changed in cvs.h! */
end_comment

begin_decl_stmt
name|char
modifier|*
name|method_names
index|[]
init|=
block|{
literal|"undefined"
block|,
literal|"local"
block|,
literal|"server (rsh)"
block|,
literal|"pserver"
block|,
literal|"kserver"
block|,
literal|"gserver"
block|,
literal|"ext"
block|,
literal|"fork"
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG
end_ifndef

begin_function
name|char
modifier|*
name|Name_Root
parameter_list|(
name|dir
parameter_list|,
name|update_dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
block|{
name|FILE
modifier|*
name|fpin
decl_stmt|;
name|char
modifier|*
name|ret
decl_stmt|,
modifier|*
name|xupdate_dir
decl_stmt|;
name|char
modifier|*
name|root
init|=
name|NULL
decl_stmt|;
name|size_t
name|root_allocated
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
name|char
modifier|*
name|cvsadm
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|update_dir
operator|&&
operator|*
name|update_dir
condition|)
name|xupdate_dir
operator|=
name|update_dir
expr_stmt|;
else|else
name|xupdate_dir
operator|=
literal|"."
expr_stmt|;
if|if
condition|(
name|dir
operator|!=
name|NULL
condition|)
block|{
name|cvsadm
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSADM
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cvsadm
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|CVSADM
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSADM_ROOT
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|CVSADM_ROOT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cvsadm
operator|=
name|xstrdup
argument_list|(
name|CVSADM
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|xstrdup
argument_list|(
name|CVSADM_ROOT
argument_list|)
expr_stmt|;
block|}
comment|/*      * Do not bother looking for a readable file if there is no cvsadm      * directory present.      *      * It is possible that not all repositories will have a CVS/Root      * file. This is ok, but the user will need to specify -d      * /path/name or have the environment variable CVSROOT set in      * order to continue.  */
if|if
condition|(
operator|(
operator|!
name|isdir
argument_list|(
name|cvsadm
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|isreadable
argument_list|(
name|tmp
argument_list|)
operator|)
condition|)
block|{
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*      * The assumption here is that the CVS Root is always contained in the      * first line of the "Root" file.      */
name|fpin
operator|=
name|open_file
argument_list|(
name|tmp
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|getline
argument_list|(
operator|&
name|root
argument_list|,
operator|&
name|root_allocated
argument_list|,
name|fpin
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* FIXME: should be checking for end of file separately; errno 	   is not set in that case.  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"in directory %s:"
argument_list|,
name|xupdate_dir
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|CVSADM_ROOT
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"please correct this problem"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fpin
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|root
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* strip the newline */
comment|/*      * root now contains a candidate for CVSroot. It must be an      * absolute pathname or specify a remote server.      */
if|if
condition|(
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
operator|(
name|strchr
argument_list|(
name|root
argument_list|,
literal|':'
argument_list|)
operator|==
name|NULL
operator|)
operator|&&
endif|#
directive|endif
operator|!
name|isabsolute
argument_list|(
name|root
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"in directory %s:"
argument_list|,
name|xupdate_dir
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"ignoring %s because it does not contain an absolute pathname."
argument_list|,
name|CVSADM_ROOT
argument_list|)
expr_stmt|;
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
if|if
condition|(
operator|(
name|strchr
argument_list|(
name|root
argument_list|,
literal|':'
argument_list|)
operator|==
name|NULL
operator|)
operator|&&
operator|!
name|isdir
argument_list|(
name|root
argument_list|)
condition|)
else|#
directive|else
comment|/* ! CLIENT_SUPPORT */
if|if
condition|(
operator|!
name|isdir
argument_list|(
name|root
argument_list|)
condition|)
endif|#
directive|endif
comment|/* CLIENT_SUPPORT */
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"in directory %s:"
argument_list|,
name|xupdate_dir
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"ignoring %s because it specifies a non-existent repository %s"
argument_list|,
name|CVSADM_ROOT
argument_list|,
name|root
argument_list|)
expr_stmt|;
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* allocate space to return and fill it in */
name|strip_trailing_slashes
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|ret
operator|=
name|xstrdup
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|cvsadm
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|root
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|root
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write the CVS/Root file so that the environment variable CVSROOT  * and/or the -d option to cvs will be validated or not necessary for  * future work.  */
end_comment

begin_function
name|void
name|Create_Root
parameter_list|(
name|dir
parameter_list|,
name|rootdir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|rootdir
decl_stmt|;
block|{
name|FILE
modifier|*
name|fout
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|noexec
condition|)
return|return;
comment|/* record the current cvs root */
if|if
condition|(
name|rootdir
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dir
operator|!=
name|NULL
condition|)
block|{
name|tmp
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSADM_ROOT
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|CVSADM_ROOT
argument_list|)
expr_stmt|;
block|}
else|else
name|tmp
operator|=
name|xstrdup
argument_list|(
name|CVSADM_ROOT
argument_list|)
expr_stmt|;
name|fout
operator|=
name|open_file
argument_list|(
name|tmp
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fprintf
argument_list|(
name|fout
argument_list|,
literal|"%s\n"
argument_list|,
name|rootdir
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"write to %s failed"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fout
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! DEBUG */
end_comment

begin_comment
comment|/* The root_allow_* stuff maintains a list of legal CVSROOT    directories.  Then we can check against them when a remote user    hands us a CVSROOT directory.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|root_allow_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|root_allow_vector
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|root_allow_size
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|root_allow_add
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|root_allow_size
operator|<=
name|root_allow_count
condition|)
block|{
if|if
condition|(
name|root_allow_size
operator|==
literal|0
condition|)
block|{
name|root_allow_size
operator|=
literal|1
expr_stmt|;
name|root_allow_vector
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|root_allow_size
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|root_allow_size
operator|*=
literal|2
expr_stmt|;
name|root_allow_vector
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|root_allow_vector
argument_list|,
name|root_allow_size
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|root_allow_vector
operator|==
name|NULL
condition|)
block|{
name|no_memory
label|:
comment|/* Strictly speaking, we're not supposed to output anything 	       now.  But we're about to exit(), give it a try.  */
name|printf
argument_list|(
literal|"E Fatal server error, aborting.\n\ error ENOMEM Virtual memory exhausted.\n"
argument_list|)
expr_stmt|;
comment|/* I'm doing this manually rather than via error_exit () 	       because I'm not sure whether we want to call server_cleanup. 	       Needs more investigation....  */
ifdef|#
directive|ifdef
name|SYSTEM_CLEANUP
comment|/* Hook for OS-specific behavior, for example socket 	       subsystems on NT and OS2 or dealing with windows 	       and arguments on Mac.  */
name|SYSTEM_CLEANUP
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
name|p
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
goto|goto
name|no_memory
goto|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|root_allow_vector
index|[
name|root_allow_count
operator|++
index|]
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_function
name|void
name|root_allow_free
parameter_list|()
block|{
if|if
condition|(
name|root_allow_vector
operator|!=
name|NULL
condition|)
name|free_names
argument_list|(
operator|&
name|root_allow_count
argument_list|,
name|root_allow_vector
argument_list|)
expr_stmt|;
name|root_allow_size
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|root_allow_ok
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|root_allow_count
operator|==
literal|0
condition|)
block|{
comment|/* Probably someone upgraded from CVS before 1.9.10 to 1.9.10 	   or later without reading the documentation about 	   --allow-root.  Printing an error here doesn't disclose any 	   particularly useful information to an attacker because a 	   CVS server configured in this way won't let *anyone* in.  */
comment|/* Note that we are called from a context where we can spit 	   back "error" rather than waiting for the next request which 	   expects responses.  */
name|printf
argument_list|(
literal|"\ error 0 Server configuration missing --allow-root in inetd.conf\n"
argument_list|)
expr_stmt|;
name|error_exit
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|root_allow_count
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|root_allow_vector
index|[
name|i
index|]
argument_list|,
name|arg
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This global variable holds the global -d option.  It is NULL if -d    was not used, which means that we must get the CVSroot information    from the CVSROOT environment variable or from a CVS/Root file.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|CVSroot_cmdline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse a CVSROOT variable into its constituent parts -- method,  * username, hostname, directory.  The prototypical CVSROOT variable  * looks like:  *  * :method:user@host:path  *  * Some methods may omit fields; local, for example, doesn't need user  * and host.  *  * Returns pointer to new cvsroot_t on success, NULL on failure. */
end_comment

begin_decl_stmt
name|cvsroot_t
modifier|*
name|current_parsed_root
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* allocate and initialize a cvsroot_t  *  * We must initialize the strings to NULL so we know later what we should  * free  *  * Some of the other zeroes remain meaningful as, "never set, use default",  * or the like  */
end_comment

begin_function
specifier|static
name|cvsroot_t
modifier|*
name|new_cvsroot_t
parameter_list|()
block|{
name|cvsroot_t
modifier|*
name|newroot
decl_stmt|;
comment|/* gotta store it somewhere */
name|newroot
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|cvsroot_t
argument_list|)
argument_list|)
expr_stmt|;
name|newroot
operator|->
name|original
operator|=
name|NULL
expr_stmt|;
name|newroot
operator|->
name|method
operator|=
name|null_method
expr_stmt|;
name|newroot
operator|->
name|username
operator|=
name|NULL
expr_stmt|;
name|newroot
operator|->
name|password
operator|=
name|NULL
expr_stmt|;
name|newroot
operator|->
name|hostname
operator|=
name|NULL
expr_stmt|;
name|newroot
operator|->
name|port
operator|=
literal|0
expr_stmt|;
name|newroot
operator|->
name|directory
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
name|newroot
operator|->
name|isremote
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* CLIENT_SUPPORT */
return|return
name|newroot
return|;
block|}
end_function

begin_comment
comment|/* Dispose of a cvsroot_t and its component parts */
end_comment

begin_function
name|void
name|free_cvsroot_t
parameter_list|(
name|root
parameter_list|)
name|cvsroot_t
modifier|*
name|root
decl_stmt|;
block|{
if|if
condition|(
name|root
operator|->
name|original
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|root
operator|->
name|original
argument_list|)
expr_stmt|;
if|if
condition|(
name|root
operator|->
name|username
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|root
operator|->
name|username
argument_list|)
expr_stmt|;
if|if
condition|(
name|root
operator|->
name|password
operator|!=
name|NULL
condition|)
block|{
comment|/* I like to be paranoid */
name|memset
argument_list|(
name|root
operator|->
name|password
argument_list|,
literal|0
argument_list|,
name|strlen
argument_list|(
name|root
operator|->
name|password
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|root
operator|->
name|password
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|root
operator|->
name|hostname
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|root
operator|->
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
name|root
operator|->
name|directory
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|root
operator|->
name|directory
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|root
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * parse a CVSROOT string to allocate and return a new cvsroot_t structure  */
end_comment

begin_function
name|cvsroot_t
modifier|*
name|parse_cvsroot
parameter_list|(
name|root_in
parameter_list|)
name|char
modifier|*
name|root_in
decl_stmt|;
block|{
name|cvsroot_t
modifier|*
name|newroot
decl_stmt|;
comment|/* the new root to be returned */
name|char
modifier|*
name|cvsroot_save
decl_stmt|;
comment|/* what we allocated so we can dispose 					 * it when finished */
name|char
modifier|*
name|firstslash
decl_stmt|;
comment|/* save where the path spec starts 					 * while we parse 					 * [[user][:password]@]host[:[port]] 					 */
name|char
modifier|*
name|cvsroot_copy
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
comment|/* temporary pointers for parsing */
name|int
name|check_hostname
decl_stmt|,
name|no_port
decl_stmt|,
name|no_password
decl_stmt|;
comment|/* allocate some space */
name|newroot
operator|=
name|new_cvsroot_t
argument_list|()
expr_stmt|;
comment|/* save the original string */
name|newroot
operator|->
name|original
operator|=
name|xstrdup
argument_list|(
name|root_in
argument_list|)
expr_stmt|;
comment|/* and another copy we can munge while parsing */
name|cvsroot_save
operator|=
name|cvsroot_copy
operator|=
name|xstrdup
argument_list|(
name|root_in
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cvsroot_copy
operator|==
literal|':'
condition|)
block|{
name|char
modifier|*
name|method
init|=
operator|++
name|cvsroot_copy
decl_stmt|;
comment|/* Access method specified, as in 	 * "cvs -d :(gserver|kserver|pserver):[[user][:password]@]host[:[port]]/path", 	 * "cvs -d [:(ext|server):][[user]@]host[:]/path", 	 * "cvs -d :local:e:\path", 	 * "cvs -d :fork:/path". 	 * We need to get past that part of CVSroot before parsing the 	 * rest of it. 	 */
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|method
argument_list|,
literal|':'
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"bad CVSroot: %s"
argument_list|,
name|root_in
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cvsroot_save
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|cvsroot_copy
operator|=
operator|++
name|p
expr_stmt|;
comment|/* Now we have an access method -- see if it's valid. */
if|if
condition|(
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"local"
argument_list|)
operator|==
literal|0
condition|)
name|newroot
operator|->
name|method
operator|=
name|local_method
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"pserver"
argument_list|)
operator|==
literal|0
condition|)
name|newroot
operator|->
name|method
operator|=
name|pserver_method
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"kserver"
argument_list|)
operator|==
literal|0
condition|)
name|newroot
operator|->
name|method
operator|=
name|kserver_method
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"gserver"
argument_list|)
operator|==
literal|0
condition|)
name|newroot
operator|->
name|method
operator|=
name|gserver_method
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"server"
argument_list|)
operator|==
literal|0
condition|)
name|newroot
operator|->
name|method
operator|=
name|server_method
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"ext"
argument_list|)
operator|==
literal|0
condition|)
name|newroot
operator|->
name|method
operator|=
name|ext_method
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|method
argument_list|,
literal|"fork"
argument_list|)
operator|==
literal|0
condition|)
name|newroot
operator|->
name|method
operator|=
name|fork_method
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"unknown method in CVSroot: %s"
argument_list|,
name|root_in
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cvsroot_save
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
block|}
else|else
block|{
comment|/* If the method isn't specified, assume 	   SERVER_METHOD/EXT_METHOD if the string contains a colon or 	   LOCAL_METHOD otherwise.  */
name|newroot
operator|->
name|method
operator|=
operator|(
operator|(
operator|*
name|cvsroot_copy
operator|!=
literal|'/'
operator|&&
name|strchr
argument_list|(
name|cvsroot_copy
argument_list|,
literal|'/'
argument_list|)
operator|)
comment|/*#ifdef RSH_NOT_TRANSPARENT 			  ? server_method #else*/
condition|?
name|ext_method
comment|/*#endif*/
else|:
name|local_method
operator|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
name|newroot
operator|->
name|isremote
operator|=
operator|(
name|newroot
operator|->
name|method
operator|!=
name|local_method
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* CLIENT_SUPPORT */
if|if
condition|(
operator|(
name|newroot
operator|->
name|method
operator|!=
name|local_method
operator|)
operator|&&
operator|(
name|newroot
operator|->
name|method
operator|!=
name|fork_method
operator|)
condition|)
block|{
comment|/* split the string into [[user][:password]@]host[:[port]]& /path 	 * 	 * this will allow some characters such as '@'& ':' to remain unquoted 	 * in the path portion of the spec 	 */
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|cvsroot_copy
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"CVSROOT (\"%s\")"
argument_list|,
name|root_in
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"requires a path spec"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|":(gserver|kserver|pserver):[[user][:password]@]host[:[port]]/path"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"[:(ext|server):][[user]@]host[:]/path"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cvsroot_save
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
name|firstslash
operator|=
name|p
expr_stmt|;
comment|/* == NULL if '/' not in string */
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* Check to see if there is a username[:password] in the string. */
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|cvsroot_copy
argument_list|,
literal|'@'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* check for a password */
if|if
condition|(
operator|(
name|q
operator|=
name|strchr
argument_list|(
name|cvsroot_copy
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
name|newroot
operator|->
name|password
operator|=
name|xstrdup
argument_list|(
operator|++
name|q
argument_list|)
expr_stmt|;
comment|/* Don't check for *newroot->password == '\0' since 		 * a user could conceivably wish to specify a blank password 		 * (newroot->password == NULL means to use the 		 * password from .cvspass) 		 */
block|}
comment|/* copy the username */
if|if
condition|(
operator|*
name|cvsroot_copy
operator|!=
literal|'\0'
condition|)
comment|/* a blank username is impossible, so leave it NULL in that 		 * case so we know to use the default username 		 */
name|newroot
operator|->
name|username
operator|=
name|xstrdup
argument_list|(
name|cvsroot_copy
argument_list|)
expr_stmt|;
name|cvsroot_copy
operator|=
operator|++
name|p
expr_stmt|;
block|}
comment|/* now deal with host[:[port]] */
comment|/* the port */
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|cvsroot_copy
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|q
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
literal|'-'
condition|)
name|q
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|q
condition|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|q
operator|++
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"CVSROOT (\"%s\")"
argument_list|,
name|root_in
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"may only specify a positive, non-zero, integer port (not \"%s\")."
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"perhaps you entered a relative pathname?"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cvsroot_save
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|newroot
operator|->
name|port
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"CVSROOT (\"%s\")"
argument_list|,
name|root_in
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"may only specify a positive, non-zero, integer port (not \"%s\")."
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"perhaps you entered a relative pathname?"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cvsroot_save
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
block|}
block|}
comment|/* copy host */
if|if
condition|(
operator|*
name|cvsroot_copy
operator|!=
literal|'\0'
condition|)
comment|/* blank hostnames are invalid, but for now leave the field NULL 	     * and catch the error during the sanity checks later 	     */
name|newroot
operator|->
name|hostname
operator|=
name|xstrdup
argument_list|(
name|cvsroot_copy
argument_list|)
expr_stmt|;
comment|/* restore the '/' */
name|cvsroot_copy
operator|=
name|firstslash
expr_stmt|;
operator|*
name|cvsroot_copy
operator|=
literal|'/'
expr_stmt|;
block|}
comment|/* parse the path for all methods */
name|newroot
operator|->
name|directory
operator|=
name|xstrdup
argument_list|(
name|cvsroot_copy
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cvsroot_save
argument_list|)
expr_stmt|;
comment|/*      * Do various sanity checks.      */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CLIENT_SUPPORT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|DEBUG
argument_list|)
if|if
condition|(
name|newroot
operator|->
name|method
operator|!=
name|local_method
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"CVSROOT \"%s\""
argument_list|,
name|root_in
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"is set for a remote access method but your"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"CVS executable doesn't support it"
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SERVER_SUPPORT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|DEBUG
argument_list|)
if|if
condition|(
name|newroot
operator|->
name|method
operator|==
name|fork_method
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"CVSROOT \"%s\""
argument_list|,
name|root_in
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"is set to use the :fork: access method but your"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"CVS executable doesn't support it"
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
endif|#
directive|endif
if|if
condition|(
name|newroot
operator|->
name|username
operator|&&
operator|!
name|newroot
operator|->
name|hostname
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"missing hostname in CVSROOT: \"%s\""
argument_list|,
name|root_in
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
name|check_hostname
operator|=
literal|0
expr_stmt|;
name|no_password
operator|=
literal|0
expr_stmt|;
name|no_port
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|newroot
operator|->
name|method
condition|)
block|{
case|case
name|local_method
case|:
if|if
condition|(
name|newroot
operator|->
name|username
operator|||
name|newroot
operator|->
name|hostname
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"can't specify hostname and username in CVSROOT"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"(\"%s\")"
argument_list|,
name|root_in
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"when using local access method"
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
comment|/* cvs.texinfo has always told people that CVSROOT must be an 	   absolute pathname.  Furthermore, attempts to use a relative 	   pathname produced various errors (I couldn't get it to work), 	   so there would seem to be little risk in making this a fatal 	   error.  */
if|if
condition|(
operator|!
name|isabsolute
argument_list|(
name|newroot
operator|->
name|directory
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"CVSROOT \"%s\" must be an absolute pathname"
argument_list|,
name|newroot
operator|->
name|directory
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
name|no_port
operator|=
literal|1
expr_stmt|;
name|no_password
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|fork_method
case|:
comment|/* We want :fork: to behave the same as other remote access            methods.  Therefore, don't check to see that the repository            name is absolute -- let the server do it.  */
if|if
condition|(
name|newroot
operator|->
name|username
operator|||
name|newroot
operator|->
name|hostname
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"can't specify hostname and username in CVSROOT"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"(\"%s\")"
argument_list|,
name|root_in
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"when using fork access method"
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
if|if
condition|(
operator|!
name|isabsolute
argument_list|(
name|newroot
operator|->
name|directory
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"CVSROOT \"%s\" must be an absolute pathname"
argument_list|,
name|newroot
operator|->
name|directory
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
name|no_port
operator|=
literal|1
expr_stmt|;
name|no_password
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|kserver_method
case|:
ifndef|#
directive|ifndef
name|HAVE_KERBEROS
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"CVSROOT \"%s\""
argument_list|,
name|root_in
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"is set for a kerberos access method but your"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"CVS executable doesn't support it"
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
else|#
directive|else
name|check_hostname
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|gserver_method
case|:
ifndef|#
directive|ifndef
name|HAVE_GSSAPI
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"CVSROOT \"%s\""
argument_list|,
name|root_in
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"is set for a GSSAPI access method but your"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"CVS executable doesn't support it"
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
else|#
directive|else
name|check_hostname
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|server_method
case|:
case|case
name|ext_method
case|:
name|no_port
operator|=
literal|1
expr_stmt|;
name|no_password
operator|=
literal|1
expr_stmt|;
name|check_hostname
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|pserver_method
case|:
name|check_hostname
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|no_password
operator|&&
name|newroot
operator|->
name|password
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"CVSROOT password specification is only valid for"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"pserver connection method."
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
if|if
condition|(
name|check_hostname
operator|&&
operator|!
name|newroot
operator|->
name|hostname
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"didn't specify hostname in CVSROOT: %s"
argument_list|,
name|root_in
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
if|if
condition|(
name|no_port
operator|&&
name|newroot
operator|->
name|port
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"CVSROOT port specification is only valid for gserver, kserver,"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"and pserver connection methods."
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
if|if
condition|(
operator|*
name|newroot
operator|->
name|directory
operator|==
literal|'\0'
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"missing directory in CVSROOT: %s"
argument_list|,
name|root_in
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
comment|/* Hooray!  We finally parsed it! */
return|return
name|newroot
return|;
name|error_exit
label|:
name|free_cvsroot_t
argument_list|(
name|newroot
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|AUTH_CLIENT_SUPPORT
end_ifdef

begin_comment
comment|/* Use root->username, root->hostname, root->port, and root->directory  * to create a normalized CVSROOT fit for the .cvspass file  *  * username defaults to the result of getcaller()  * port defaults to the result of get_cvs_port_number()  *  * FIXME - we could cache the canonicalized version of a root inside the  * cvsroot_t, but we'd have to un'const the input here and stop expecting the  * caller to be responsible for our return value  */
end_comment

begin_function
name|char
modifier|*
name|normalize_cvsroot
parameter_list|(
name|root
parameter_list|)
specifier|const
name|cvsroot_t
modifier|*
name|root
decl_stmt|;
block|{
name|char
modifier|*
name|cvsroot_canonical
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|hostname
decl_stmt|,
modifier|*
name|username
decl_stmt|;
name|char
name|port_s
index|[
literal|64
index|]
decl_stmt|;
comment|/* get the appropriate port string */
name|sprintf
argument_list|(
name|port_s
argument_list|,
literal|"%d"
argument_list|,
name|get_cvs_port_number
argument_list|(
name|root
argument_list|)
argument_list|)
expr_stmt|;
comment|/* use a lower case hostname since we know hostnames are case insensitive */
comment|/* Some logic says we should be tacking our domain name on too if it isn't      * there already, but for now this works.  Reverse->Forward lookups are      * almost certainly too much since that would make CVS immune to some of      * the DNS trickery that makes life easier for sysadmins when they want to      * move a repository or the like      */
name|p
operator|=
name|hostname
operator|=
name|xstrdup
argument_list|(
name|root
operator|->
name|hostname
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
operator|*
name|p
operator|=
name|tolower
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
comment|/* get the username string */
name|username
operator|=
name|root
operator|->
name|username
condition|?
name|root
operator|->
name|username
else|:
name|getcaller
argument_list|()
expr_stmt|;
name|cvsroot_canonical
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|username
argument_list|)
operator|+
name|strlen
argument_list|(
name|hostname
argument_list|)
operator|+
name|strlen
argument_list|(
name|port_s
argument_list|)
operator|+
name|strlen
argument_list|(
name|root
operator|->
name|directory
argument_list|)
operator|+
literal|12
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|cvsroot_canonical
argument_list|,
literal|":pserver:%s@%s:%s%s"
argument_list|,
name|username
argument_list|,
name|hostname
argument_list|,
name|port_s
argument_list|,
name|root
operator|->
name|directory
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
return|return
name|cvsroot_canonical
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTH_CLIENT_SUPPORT */
end_comment

begin_comment
comment|/* allocate and return a cvsroot_t structure set up as if we're using the local  * repository DIR.  */
end_comment

begin_function
name|cvsroot_t
modifier|*
name|local_cvsroot
parameter_list|(
name|dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
block|{
name|cvsroot_t
modifier|*
name|newroot
init|=
name|new_cvsroot_t
argument_list|()
decl_stmt|;
name|newroot
operator|->
name|original
operator|=
name|xstrdup
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|newroot
operator|->
name|method
operator|=
name|local_method
expr_stmt|;
name|newroot
operator|->
name|directory
operator|=
name|xstrdup
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return
name|newroot
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/* This is for testing the parsing function.  Use       gcc -I. -I.. -I../lib -DDEBUG root.c -o root     to compile.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_decl_stmt
name|char
modifier|*
name|program_name
init|=
literal|"testing"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|command_name
init|=
literal|"parse_cvsroot"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX is this used??? */
end_comment

begin_comment
comment|/* Toy versions of various functions when debugging under unix.  Yes,    these make various bad assumptions, but they're pretty easy to    debug when something goes wrong.  */
end_comment

begin_decl_stmt
name|void
name|error_exit
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
block|{
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
name|int
name|isabsolute
parameter_list|(
name|dir
parameter_list|)
specifier|const
name|char
modifier|*
name|dir
decl_stmt|;
block|{
return|return
operator|(
name|dir
operator|&&
operator|(
operator|*
name|dir
operator|==
literal|'/'
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s<CVSROOT>\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|current_parsed_root
operator|=
name|parse_cvsroot
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Parsing failed.\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"CVSroot: %s\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"current_parsed_root->method: %s\n"
argument_list|,
name|method_names
index|[
name|current_parsed_root
operator|->
name|method
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"current_parsed_root->username: %s\n"
argument_list|,
name|current_parsed_root
operator|->
name|username
condition|?
name|current_parsed_root
operator|->
name|username
else|:
literal|"NULL"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"current_parsed_root->hostname: %s\n"
argument_list|,
name|current_parsed_root
operator|->
name|hostname
condition|?
name|current_parsed_root
operator|->
name|hostname
else|:
literal|"NULL"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"current_parsed_root->directory: %s\n"
argument_list|,
name|current_parsed_root
operator|->
name|directory
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

