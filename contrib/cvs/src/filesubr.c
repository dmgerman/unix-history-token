begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* filesubr.c --- subroutines for dealing with files    Jim Blandy<jimb@cyclic.com>     This file is part of GNU CVS.     GNU CVS is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by the    Free Software Foundation; either version 2, or (at your option) any    later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.  */
end_comment

begin_comment
comment|/* These functions were moved out of subr.c because they need different    definitions under operating systems (like, say, Windows NT) with different    file system semantics.  */
end_comment

begin_comment
comment|/*  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|deep_remove_dir
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|path
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Copies "from" to "to".  */
end_comment

begin_function
name|void
name|copy_file
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
specifier|const
name|char
modifier|*
name|from
decl_stmt|;
specifier|const
name|char
modifier|*
name|to
decl_stmt|;
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|struct
name|utimbuf
name|t
decl_stmt|;
name|int
name|fdin
decl_stmt|,
name|fdout
decl_stmt|;
if|if
condition|(
name|trace
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s-> copy(%s,%s)\n"
argument_list|,
name|CLIENT_SERVER_STR
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|noexec
condition|)
return|return;
comment|/* If the file to be copied is a link or a device, then just create        the new link or device appropriately. */
if|if
condition|(
name|islink
argument_list|(
name|from
argument_list|)
condition|)
block|{
name|char
modifier|*
name|source
init|=
name|xreadlink
argument_list|(
name|from
argument_list|)
decl_stmt|;
name|symlink
argument_list|(
name|source
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|source
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|isdevice
argument_list|(
name|from
argument_list|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MKNOD
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_STRUCT_STAT_ST_RDEV
argument_list|)
if|if
condition|(
name|stat
argument_list|(
name|from
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot stat %s"
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|mknod
argument_list|(
name|to
argument_list|,
name|sb
operator|.
name|st_mode
argument_list|,
name|sb
operator|.
name|st_rdev
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot copy device files on this system (%s)"
argument_list|,
name|from
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* Not a link or a device... probably a regular file. */
if|if
condition|(
operator|(
name|fdin
operator|=
name|open
argument_list|(
name|from
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s for copying"
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fdin
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot fstat %s"
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fdout
operator|=
name|creat
argument_list|(
name|to
argument_list|,
operator|(
name|int
operator|)
name|sb
operator|.
name|st_mode
operator|&
literal|07777
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot create %s for copying"
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|.
name|st_size
operator|>
literal|0
condition|)
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|n
operator|=
name|read
argument_list|(
name|fdin
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|EINTR
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
endif|#
directive|endif
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot read file %s for copying"
argument_list|,
name|from
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|write
argument_list|(
name|fdout
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
operator|!=
name|n
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot write file %s for copying"
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|HAVE_FSYNC
if|if
condition|(
name|fsync
argument_list|(
name|fdout
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot fsync file %s after copying"
argument_list|,
name|to
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|close
argument_list|(
name|fdin
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|fdout
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
comment|/* now, set the times for the copied file to match those of the original */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|t
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|.
name|actime
operator|=
name|sb
operator|.
name|st_atime
expr_stmt|;
name|t
operator|.
name|modtime
operator|=
name|sb
operator|.
name|st_mtime
expr_stmt|;
operator|(
name|void
operator|)
name|utime
argument_list|(
name|to
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* FIXME-krp: these functions would benefit from caching the char *&    stat buf.  */
end_comment

begin_comment
comment|/*  * Returns non-zero if the argument file is a directory, or is a symbolic  * link which points to a directory.  */
end_comment

begin_function
name|int
name|isdir
parameter_list|(
name|file
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|S_ISDIR
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns non-zero if the argument file is a symbolic link.  */
end_comment

begin_function
name|int
name|islink
parameter_list|(
name|file
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|S_ISLNK
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
name|CVS_LSTAT
argument_list|(
name|file
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|S_ISLNK
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
operator|)
return|;
else|#
directive|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Returns non-zero if the argument file is a block or  * character special device.  */
end_comment

begin_function
name|int
name|isdevice
parameter_list|(
name|file
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
name|CVS_LSTAT
argument_list|(
name|file
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|S_ISBLK
if|if
condition|(
name|S_ISBLK
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_ISCHR
if|if
condition|(
name|S_ISCHR
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Returns non-zero if the argument file exists.  */
end_comment

begin_function
name|int
name|isfile
parameter_list|(
name|file
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
block|{
return|return
name|isaccessible
argument_list|(
name|file
argument_list|,
name|F_OK
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns non-zero if the argument file is readable.  */
end_comment

begin_function
name|int
name|isreadable
parameter_list|(
name|file
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
block|{
return|return
name|isaccessible
argument_list|(
name|file
argument_list|,
name|R_OK
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns non-zero if the argument file is writable.  */
end_comment

begin_function
name|int
name|iswritable
parameter_list|(
name|file
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
block|{
return|return
name|isaccessible
argument_list|(
name|file
argument_list|,
name|W_OK
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns non-zero if the argument file is accessable according to  * mode.  If compiled with SETXID_SUPPORT also works if cvs has setxid  * bits set.  */
end_comment

begin_function
name|int
name|isaccessible
parameter_list|(
name|file
parameter_list|,
name|mode
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
specifier|const
name|int
name|mode
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|SETXID_SUPPORT
name|struct
name|stat
name|sb
decl_stmt|;
name|int
name|umask
init|=
literal|0
decl_stmt|;
name|int
name|gmask
init|=
literal|0
decl_stmt|;
name|int
name|omask
init|=
literal|0
decl_stmt|;
name|int
name|uid
decl_stmt|,
name|mask
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mode
operator|==
name|F_OK
condition|)
return|return
literal|1
return|;
name|uid
operator|=
name|geteuid
argument_list|()
expr_stmt|;
if|if
condition|(
name|uid
operator|==
literal|0
condition|)
comment|/* superuser */
block|{
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|X_OK
operator|)
operator|||
operator|(
name|sb
operator|.
name|st_mode
operator|&
operator|(
name|S_IXUSR
operator||
name|S_IXGRP
operator||
name|S_IXOTH
operator|)
operator|)
condition|)
return|return
literal|1
return|;
name|errno
operator|=
name|EACCES
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|mode
operator|&
name|R_OK
condition|)
block|{
name|umask
operator||=
name|S_IRUSR
expr_stmt|;
name|gmask
operator||=
name|S_IRGRP
expr_stmt|;
name|omask
operator||=
name|S_IROTH
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|&
name|W_OK
condition|)
block|{
name|umask
operator||=
name|S_IWUSR
expr_stmt|;
name|gmask
operator||=
name|S_IWGRP
expr_stmt|;
name|omask
operator||=
name|S_IWOTH
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|&
name|X_OK
condition|)
block|{
name|umask
operator||=
name|S_IXUSR
expr_stmt|;
name|gmask
operator||=
name|S_IXGRP
expr_stmt|;
name|omask
operator||=
name|S_IXOTH
expr_stmt|;
block|}
name|mask
operator|=
name|sb
operator|.
name|st_uid
operator|==
name|uid
condition|?
name|umask
else|:
name|sb
operator|.
name|st_gid
operator|==
name|getegid
argument_list|()
condition|?
name|gmask
else|:
name|omask
expr_stmt|;
if|if
condition|(
operator|(
name|sb
operator|.
name|st_mode
operator|&
name|mask
operator|)
operator|==
name|mask
condition|)
return|return
literal|1
return|;
name|errno
operator|=
name|EACCES
expr_stmt|;
return|return
literal|0
return|;
else|#
directive|else
return|return
name|access
argument_list|(
name|file
argument_list|,
name|mode
argument_list|)
operator|==
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Open a file and die if it fails  */
end_comment

begin_function
name|FILE
modifier|*
name|open_file
parameter_list|(
name|name
parameter_list|,
name|mode
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|mode
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|fp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Make a directory and die if it fails  */
end_comment

begin_function
name|void
name|make_directory
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|!
name|S_ISDIR
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s already exists but is not a directory"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|noexec
operator|&&
name|mkdir
argument_list|(
name|name
argument_list|,
literal|0777
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot make directory %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Make a path to the argument directory, printing a message if something  * goes wrong.  */
end_comment

begin_function
name|void
name|make_directories
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|noexec
condition|)
return|return;
if|if
condition|(
name|mkdir
argument_list|(
name|name
argument_list|,
literal|0777
argument_list|)
operator|==
literal|0
operator|||
name|errno
operator|==
name|EEXIST
condition|)
return|return;
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot make path to %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|make_directories
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
return|return;
operator|(
name|void
operator|)
name|mkdir
argument_list|(
name|name
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create directory NAME if it does not already exist; fatal error for    other errors.  Returns 0 if directory was created; 1 if it already    existed.  */
end_comment

begin_function
name|int
name|mkdir_if_needed
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|mkdir
argument_list|(
name|name
argument_list|,
literal|0777
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EEXIST
operator|&&
operator|!
name|isdir
argument_list|(
name|name
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot make directory %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Change the mode of a file, either adding write permissions, or removing  * all write permissions.  Either change honors the current umask setting.  *  * Don't do anything if PreservePermissions is set to `yes'.  This may  * have unexpected consequences for some uses of xchmod.  */
end_comment

begin_function
name|void
name|xchmod
parameter_list|(
name|fname
parameter_list|,
name|writable
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|writable
decl_stmt|;
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|mode_t
name|mode
decl_stmt|,
name|oumask
decl_stmt|;
if|if
condition|(
name|preserve_perms
condition|)
return|return;
if|if
condition|(
name|stat
argument_list|(
name|fname
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|noexec
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot stat %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return;
block|}
name|oumask
operator|=
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|oumask
argument_list|)
expr_stmt|;
if|if
condition|(
name|writable
condition|)
block|{
name|mode
operator|=
name|sb
operator|.
name|st_mode
operator||
operator|(
operator|~
name|oumask
operator|&
operator|(
operator|(
operator|(
name|sb
operator|.
name|st_mode
operator|&
name|S_IRUSR
operator|)
condition|?
name|S_IWUSR
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|sb
operator|.
name|st_mode
operator|&
name|S_IRGRP
operator|)
condition|?
name|S_IWGRP
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|sb
operator|.
name|st_mode
operator|&
name|S_IROTH
operator|)
condition|?
name|S_IWOTH
else|:
literal|0
operator|)
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|mode
operator|=
name|sb
operator|.
name|st_mode
operator|&
operator|~
operator|(
name|S_IWRITE
operator||
name|S_IWGRP
operator||
name|S_IWOTH
operator|)
operator|&
operator|~
name|oumask
expr_stmt|;
block|}
if|if
condition|(
name|trace
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s-> chmod(%s,%o)\n"
argument_list|,
name|CLIENT_SERVER_STR
argument_list|,
name|fname
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|noexec
condition|)
return|return;
if|if
condition|(
name|chmod
argument_list|(
name|fname
argument_list|,
name|mode
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot change mode of file %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Rename a file and die if it fails  */
end_comment

begin_function
name|void
name|rename_file
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
specifier|const
name|char
modifier|*
name|from
decl_stmt|;
specifier|const
name|char
modifier|*
name|to
decl_stmt|;
block|{
if|if
condition|(
name|trace
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s-> rename(%s,%s)\n"
argument_list|,
name|CLIENT_SERVER_STR
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|noexec
condition|)
return|return;
if|if
condition|(
name|rename
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot rename file %s to %s"
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * unlink a file, if possible.  */
end_comment

begin_function
name|int
name|unlink_file
parameter_list|(
name|f
parameter_list|)
specifier|const
name|char
modifier|*
name|f
decl_stmt|;
block|{
if|if
condition|(
name|trace
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s-> unlink_file(%s)\n"
argument_list|,
name|CLIENT_SERVER_STR
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|noexec
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|CVS_UNLINK
argument_list|(
name|f
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unlink a file or dir, if possible.  If it is a directory do a deep  * removal of all of the files in the directory.  Return -1 on error  * (in which case errno is set).  */
end_comment

begin_function
name|int
name|unlink_file_dir
parameter_list|(
name|f
parameter_list|)
specifier|const
name|char
modifier|*
name|f
decl_stmt|;
block|{
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
name|trace
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
comment|/* This is called by the server parent process in contexts where 	   it is not OK to send output (e.g. after we sent "ok" to the 	   client).  */
operator|&&
operator|!
name|server_active
endif|#
directive|endif
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-> unlink_file_dir(%s)\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|noexec
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* For at least some unices, if root tries to unlink() a directory,        instead of doing something rational like returning EISDIR,        the system will gleefully go ahead and corrupt the filesystem.        So we first call stat() to see if it is OK to call unlink().  This        doesn't quite work--if someone creates a directory between the        call to stat() and the call to unlink(), we'll still corrupt        the filesystem.  Where is the Unix Haters Handbook when you need        it?  */
if|if
condition|(
name|stat
argument_list|(
name|f
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
block|{
comment|/* The file or directory doesn't exist anyhow.  */
return|return
operator|-
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|S_ISDIR
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
return|return
name|deep_remove_dir
argument_list|(
name|f
argument_list|)
return|;
return|return
name|CVS_UNLINK
argument_list|(
name|f
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Remove a directory and everything it contains.  Returns 0 for  * success, -1 for failure (in which case errno is set).  */
end_comment

begin_function
specifier|static
name|int
name|deep_remove_dir
parameter_list|(
name|path
parameter_list|)
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
block|{
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
name|rmdir
argument_list|(
name|path
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOTEMPTY
operator|||
name|errno
operator|==
name|EEXIST
comment|/* Ugly workaround for ugly AIX 4.1 (and 3.2) header bug 	       (it defines ENOTEMPTY and EEXIST to 17 but actually 	       returns 87).  */
operator|||
operator|(
name|ENOTEMPTY
operator|==
literal|17
operator|&&
name|EEXIST
operator|==
literal|17
operator|&&
name|errno
operator|==
literal|87
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|dirp
operator|=
name|CVS_OPENDIR
argument_list|(
name|path
argument_list|)
operator|)
operator|==
name|NULL
condition|)
comment|/* If unable to open the directory return 		 * an error 		 */
return|return
operator|-
literal|1
return|;
name|errno
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|dp
operator|=
name|CVS_READDIR
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|buf
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
name|strlen
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/%s"
argument_list|,
name|path
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
comment|/* See comment in unlink_file_dir explanation of why we use 		   isdir instead of just calling unlink and checking the 		   status.  */
if|if
condition|(
name|isdir
argument_list|(
name|buf
argument_list|)
condition|)
block|{
if|if
condition|(
name|deep_remove_dir
argument_list|(
name|buf
argument_list|)
condition|)
block|{
name|CVS_CLOSEDIR
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|CVS_UNLINK
argument_list|(
name|buf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|CVS_CLOSEDIR
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|CVS_CLOSEDIR
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|CVS_CLOSEDIR
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
return|return
name|rmdir
argument_list|(
name|path
argument_list|)
return|;
block|}
else|else
return|return
operator|-
literal|1
return|;
block|}
comment|/* Was able to remove the directory return 0 */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Read NCHARS bytes from descriptor FD into BUF.    Return the number of characters successfully read.    The number returned is always NCHARS unless end-of-file or error.  */
end_comment

begin_function
specifier|static
name|size_t
name|block_read
parameter_list|(
name|fd
parameter_list|,
name|buf
parameter_list|,
name|nchars
parameter_list|)
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|nchars
decl_stmt|;
block|{
name|char
modifier|*
name|bp
init|=
name|buf
decl_stmt|;
name|size_t
name|nread
decl_stmt|;
do|do
block|{
name|nread
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|bp
argument_list|,
name|nchars
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|EINTR
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
endif|#
directive|endif
return|return
operator|(
name|size_t
operator|)
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|nread
operator|==
literal|0
condition|)
break|break;
name|bp
operator|+=
name|nread
expr_stmt|;
name|nchars
operator|-=
name|nread
expr_stmt|;
block|}
do|while
condition|(
name|nchars
operator|!=
literal|0
condition|)
do|;
return|return
name|bp
operator|-
name|buf
return|;
block|}
end_function

begin_comment
comment|/*  * Compare "file1" to "file2". Return non-zero if they don't compare exactly.  * If FILE1 and FILE2 are special files, compare their salient characteristics  * (i.e. major/minor device numbers, links, etc.  */
end_comment

begin_function
name|int
name|xcmp
parameter_list|(
name|file1
parameter_list|,
name|file2
parameter_list|)
specifier|const
name|char
modifier|*
name|file1
decl_stmt|;
specifier|const
name|char
modifier|*
name|file2
decl_stmt|;
block|{
name|char
modifier|*
name|buf1
decl_stmt|,
modifier|*
name|buf2
decl_stmt|;
name|struct
name|stat
name|sb1
decl_stmt|,
name|sb2
decl_stmt|;
name|int
name|fd1
decl_stmt|,
name|fd2
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|CVS_LSTAT
argument_list|(
name|file1
argument_list|,
operator|&
name|sb1
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot lstat %s"
argument_list|,
name|file1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVS_LSTAT
argument_list|(
name|file2
argument_list|,
operator|&
name|sb2
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot lstat %s"
argument_list|,
name|file2
argument_list|)
expr_stmt|;
comment|/* If FILE1 and FILE2 are not the same file type, they are unequal. */
if|if
condition|(
operator|(
name|sb1
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
operator|(
name|sb2
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
condition|)
return|return
literal|1
return|;
comment|/* If FILE1 and FILE2 are symlinks, they are equal if they point to        the same thing. */
if|if
condition|(
name|S_ISLNK
argument_list|(
name|sb1
operator|.
name|st_mode
argument_list|)
operator|&&
name|S_ISLNK
argument_list|(
name|sb2
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|int
name|result
decl_stmt|;
name|buf1
operator|=
name|xreadlink
argument_list|(
name|file1
argument_list|)
expr_stmt|;
name|buf2
operator|=
name|xreadlink
argument_list|(
name|file2
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
name|strcmp
argument_list|(
name|buf1
argument_list|,
name|buf2
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
name|free
argument_list|(
name|buf1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/* If FILE1 and FILE2 are devices, they are equal if their device        numbers match. */
if|if
condition|(
name|S_ISBLK
argument_list|(
name|sb1
operator|.
name|st_mode
argument_list|)
operator|||
name|S_ISCHR
argument_list|(
name|sb1
operator|.
name|st_mode
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_STRUCT_STAT_ST_RDEV
if|if
condition|(
name|sb1
operator|.
name|st_rdev
operator|==
name|sb2
operator|.
name|st_rdev
condition|)
return|return
literal|0
return|;
else|else
return|return
literal|1
return|;
else|#
directive|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot compare device files on this system (%s and %s)"
argument_list|,
name|file1
argument_list|,
name|file2
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|(
name|fd1
operator|=
name|open
argument_list|(
name|file1
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot open file %s for comparing"
argument_list|,
name|file1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd2
operator|=
name|open
argument_list|(
name|file2
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot open file %s for comparing"
argument_list|,
name|file2
argument_list|)
expr_stmt|;
comment|/* A generic file compare routine might compare st_dev& st_ino here         to see if the two files being compared are actually the same file.        But that won't happen in CVS, so we won't bother. */
if|if
condition|(
name|sb1
operator|.
name|st_size
operator|!=
name|sb2
operator|.
name|st_size
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|sb1
operator|.
name|st_size
operator|==
literal|0
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* FIXME: compute the optimal buffer size by computing the least 	   common multiple of the files st_blocks field */
name|size_t
name|buf_size
init|=
literal|8
operator|*
literal|1024
decl_stmt|;
name|size_t
name|read1
decl_stmt|;
name|size_t
name|read2
decl_stmt|;
name|buf1
operator|=
name|xmalloc
argument_list|(
name|buf_size
argument_list|)
expr_stmt|;
name|buf2
operator|=
name|xmalloc
argument_list|(
name|buf_size
argument_list|)
expr_stmt|;
do|do
block|{
name|read1
operator|=
name|block_read
argument_list|(
name|fd1
argument_list|,
name|buf1
argument_list|,
name|buf_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|read1
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot read file %s for comparing"
argument_list|,
name|file1
argument_list|)
expr_stmt|;
name|read2
operator|=
name|block_read
argument_list|(
name|fd2
argument_list|,
name|buf2
argument_list|,
name|buf_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|read2
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot read file %s for comparing"
argument_list|,
name|file2
argument_list|)
expr_stmt|;
comment|/* assert (read1 == read2); */
name|ret
operator|=
name|memcmp
argument_list|(
name|buf1
argument_list|,
name|buf2
argument_list|,
name|read1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ret
operator|==
literal|0
operator|&&
name|read1
operator|==
name|buf_size
condition|)
do|;
name|free
argument_list|(
name|buf1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd2
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate a unique temporary filename.  Returns a pointer to a newly  * malloc'd string containing the name.  Returns successfully or not at  * all.  *  *     THIS FUNCTION IS DEPRECATED!!!  USE cvs_temp_file INSTEAD!!!  *  * and yes, I know about the way the rcs commands use temp files.  I think  * they should be converted too but I don't have time to look into it right  * now.  */
end_comment

begin_function
name|char
modifier|*
name|cvs_temp_name
parameter_list|()
block|{
name|char
modifier|*
name|fn
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|fp
operator|=
name|cvs_temp_file
argument_list|(
operator|&
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"Failed to create temporary file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"Failed to close temporary file %s"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
return|return
name|fn
return|;
block|}
end_function

begin_comment
comment|/* Generate a unique temporary filename and return an open file stream  * to the truncated file by that name  *  *  INPUTS  *	filename	where to place the pointer to the newly allocated file  *   			name string  *  *  OUTPUTS  *	filename	dereferenced, will point to the newly allocated file  *			name string.  This value is undefined if the function  *			returns an error.  *  *  RETURNS  *	An open file pointer to a read/write mode empty temporary file with the  *	unique file name or NULL on failure.  *  *  ERRORS  *	on error, errno will be set to some value either by CVS_FOPEN or  *	whatever system function is called to generate the temporary file name  */
end_comment

begin_comment
comment|/* There are at least four functions for generating temporary  * filenames.  We use mkstemp (BSD 4.3) if possible, else tempnam (SVID 3),  * else mktemp (BSD 4.3), and as last resort tmpnam (POSIX).  Reason is that  * mkstemp, tempnam, and mktemp both allow to specify the directory in which  * the temporary file will be created.  *  * And the _correct_ way to use the deprecated functions probably involves  * opening file descriptors using O_EXCL& O_CREAT and even doing the annoying  * NFS locking thing, but until I hear of more problems, I'm not going to  * bother.  */
end_comment

begin_function
name|FILE
modifier|*
name|cvs_temp_file
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
modifier|*
name|filename
decl_stmt|;
block|{
name|char
modifier|*
name|fn
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* FIXME - I'd like to be returning NULL here in noexec mode, but I think      * some of the rcs& diff functions which rely on a temp file run in      * noexec mode too.      */
name|assert
argument_list|(
name|filename
operator|!=
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_MKSTEMP
block|{
name|int
name|fd
decl_stmt|;
name|fn
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|Tmpdir
argument_list|)
operator|+
literal|11
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|fn
argument_list|,
literal|"%s/%s"
argument_list|,
name|Tmpdir
argument_list|,
literal|"cvsXXXXXX"
argument_list|)
expr_stmt|;
name|fd
operator|=
name|mkstemp
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* a NULL return will be interpreted by callers as an error and      * errno should still be set      */
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
name|fp
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|fp
operator|=
name|CVS_FDOPEN
argument_list|(
name|fd
argument_list|,
literal|"w+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* attempt to close and unlink the file since mkstemp returned sucessfully and 	 * we believe it's been created and opened 	 */
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"Failed to close temporary file %s"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVS_UNLINK
argument_list|(
name|fn
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"Failed to unlink temporary file %s"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|free
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* mkstemp is defined to open mode 0600 using glibc 2.0.7+ */
comment|/* FIXME - configure can probably tell us which version of glibc we are      * linking to and not chmod for 2.0.7+      */
else|else
name|chmod
argument_list|(
name|fn
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
block|}
elif|#
directive|elif
name|HAVE_TEMPNAM
comment|/* tempnam has been deprecated due to under-specification */
name|fn
operator|=
name|tempnam
argument_list|(
name|Tmpdir
argument_list|,
literal|"cvs"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
operator|==
name|NULL
condition|)
name|fp
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|fn
argument_list|,
literal|"w+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|free
argument_list|(
name|fn
argument_list|)
expr_stmt|;
else|else
name|chmod
argument_list|(
name|fn
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
comment|/* tempnam returns a pointer to a newly malloc'd string, so there's      * no need for a xstrdup      */
elif|#
directive|elif
name|HAVE_MKTEMP
comment|/* mktemp has been deprecated due to the BSD 4.3 specification specifying      * that XXXXXX will be replaced by a PID and a letter, creating only 26      * possibilities, a security risk, and a race condition.      */
block|{
name|char
modifier|*
name|ifn
decl_stmt|;
name|ifn
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|Tmpdir
argument_list|)
operator|+
literal|11
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ifn
argument_list|,
literal|"%s/%s"
argument_list|,
name|Tmpdir
argument_list|,
literal|"cvsXXXXXX"
argument_list|)
expr_stmt|;
name|fn
operator|=
name|mktemp
argument_list|(
name|ifn
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
operator|==
name|NULL
condition|)
name|fp
operator|=
name|NULL
expr_stmt|;
else|else
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|fn
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|free
argument_list|(
name|ifn
argument_list|)
expr_stmt|;
else|else
name|chmod
argument_list|(
name|fn
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* use tmpnam if all else fails */
comment|/* tmpnam is deprecated */
block|{
name|char
name|ifn
index|[
name|L_tmpnam
operator|+
literal|1
index|]
decl_stmt|;
name|fn
operator|=
name|tmpnam
argument_list|(
name|ifn
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
operator|==
name|NULL
condition|)
name|fp
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|ifn
argument_list|,
literal|"w+"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|fn
operator|=
name|xstrdup
argument_list|(
name|ifn
argument_list|)
expr_stmt|;
name|chmod
argument_list|(
name|fn
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
operator|*
name|filename
operator|=
name|fn
expr_stmt|;
return|return
name|fp
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero iff FILENAME is absolute.    Trivial under Unix, but more complicated under other systems.  */
end_comment

begin_function
name|int
name|isabsolute
parameter_list|(
name|filename
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
return|return
name|filename
index|[
literal|0
index|]
operator|==
literal|'/'
return|;
block|}
end_function

begin_comment
comment|/*  * Return a string (dynamically allocated) with the name of the file to which  * LINK is symlinked.  */
end_comment

begin_function
name|char
modifier|*
name|xreadlink
parameter_list|(
name|link
parameter_list|)
specifier|const
name|char
modifier|*
name|link
decl_stmt|;
block|{
name|char
modifier|*
name|file
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|tfile
decl_stmt|;
name|int
name|buflen
init|=
name|BUFSIZ
decl_stmt|;
name|int
name|linklen
decl_stmt|;
if|if
condition|(
operator|!
name|islink
argument_list|(
name|link
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* Get the name of the file to which `from' is linked.        FIXME: what portability issues arise here?  Are readlink&        ENAMETOOLONG defined on all systems? -twp */
do|do
block|{
name|file
operator|=
name|xrealloc
argument_list|(
name|file
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|linklen
operator|=
name|readlink
argument_list|(
name|link
argument_list|,
name|file
argument_list|,
name|buflen
operator|-
literal|1
argument_list|)
expr_stmt|;
name|buflen
operator|*=
literal|2
expr_stmt|;
block|}
do|while
condition|(
name|linklen
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|ENAMETOOLONG
condition|)
do|;
if|if
condition|(
name|linklen
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot readlink %s"
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|file
index|[
name|linklen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|tfile
operator|=
name|xstrdup
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
name|tfile
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer into PATH's last component.  */
end_comment

begin_function
name|char
modifier|*
name|last_component
parameter_list|(
name|path
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
block|{
name|char
modifier|*
name|last
init|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|last
operator|&&
operator|(
name|last
operator|!=
name|path
operator|)
condition|)
return|return
name|last
operator|+
literal|1
return|;
else|else
return|return
name|path
return|;
block|}
end_function

begin_comment
comment|/* Return the home directory.  Returns a pointer to storage    managed by this function or its callees (currently getenv).    This function will return the same thing every time it is    called.  Returns NULL if there is no home directory.     Note that for a pserver server, this may return root's home    directory.  What typically happens is that upon being started from    inetd, before switching users, the code in cvsrc.c calls    get_homedir which remembers root's home directory in the static    variable.  Then the switch happens and get_homedir might return a    directory that we don't even have read or execute permissions for    (which is bad, when various parts of CVS try to read there).  One    fix would be to make the value returned by get_homedir only good    until the next call (which would free the old value).  Another fix    would be to just always malloc our answer, and let the caller free    it (that is best, because some day we may need to be reentrant).     The workaround is to put -f in inetd.conf which means that    get_homedir won't get called until after the switch in user ID.     The whole concept of a "home directory" on the server is pretty    iffy, although I suppose some people probably are relying on it for    .cvsrc and such, in the cases where it works.  */
end_comment

begin_function
name|char
modifier|*
name|get_homedir
parameter_list|()
block|{
specifier|static
name|char
modifier|*
name|home
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|env
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
if|if
condition|(
name|home
operator|!=
name|NULL
condition|)
return|return
name|home
return|;
if|if
condition|(
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
operator|!
name|server_active
operator|&&
endif|#
directive|endif
operator|(
name|env
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|home
operator|=
name|env
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|pw
operator|=
operator|(
expr|struct
name|passwd
operator|*
operator|)
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
operator|)
operator|&&
name|pw
operator|->
name|pw_dir
condition|)
name|home
operator|=
name|xstrdup
argument_list|(
name|pw
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
return|return
name|home
return|;
block|}
end_function

begin_comment
comment|/* Compose a path to a file in the home directory.  This is necessary because  * of different behavior on UNIX and VMS.  See the notes in vms/filesubr.c.  *  * A more clean solution would be something more along the lines of a  * "join a directory to a filename" kind of thing which was not specific to  * the homedir.  This should aid portability between UNIX, Mac, Windows, VMS,  * and possibly others.  This is already handled by Perl - it might be  * interesting to see how much of the code was written in C since Perl is under  * the GPL and the Artistic license - we might be able to use it.  */
end_comment

begin_function
name|char
modifier|*
name|strcat_filename_onto_homedir
parameter_list|(
name|dir
parameter_list|,
name|file
parameter_list|)
specifier|const
name|char
modifier|*
name|dir
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|char
modifier|*
name|path
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|path
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
name|path
return|;
block|}
end_function

begin_comment
comment|/* See cvs.h for description.  On unix this does nothing, because the    shell expands the wildcards.  */
end_comment

begin_function
name|void
name|expand_wild
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pargc
parameter_list|,
name|pargv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
modifier|*
name|pargc
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|pargv
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
operator|*
name|pargc
operator|=
name|argc
expr_stmt|;
operator|*
name|pargv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
operator|(
operator|*
name|pargv
operator|)
index|[
name|i
index|]
operator|=
name|xstrdup
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
end_ifdef

begin_comment
comment|/* Case-insensitive string compare.  I know that some systems    have such a routine, but I'm not sure I see any reasons for    dealing with the hair of figuring out whether they do (I haven't    looked into whether this is a performance bottleneck; I would guess    not).  */
end_comment

begin_function
name|int
name|cvs_casecmp
parameter_list|(
name|str1
parameter_list|,
name|str2
parameter_list|)
name|char
modifier|*
name|str1
decl_stmt|;
name|char
modifier|*
name|str2
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|int
name|pqdiff
decl_stmt|;
name|p
operator|=
name|str1
expr_stmt|;
name|q
operator|=
name|str2
expr_stmt|;
while|while
condition|(
operator|(
name|pqdiff
operator|=
name|tolower
argument_list|(
operator|*
name|p
argument_list|)
operator|-
name|tolower
argument_list|(
operator|*
name|q
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
operator|++
name|p
expr_stmt|;
operator|++
name|q
expr_stmt|;
block|}
return|return
name|pqdiff
return|;
block|}
end_function

begin_comment
comment|/* Case-insensitive file open.  As you can see, this is an expensive    call.  We don't regard it as our main strategy for dealing with    case-insensitivity.  Returns errno code or 0 for success.  Puts the    new file in *FP.  NAME and MODE are as for fopen.  If PATHP is not    NULL, then put a malloc'd string containing the pathname as found    into *PATHP.  *PATHP is only set if the return value is 0.     Might be cleaner to separate the file finding (which just gives    *PATHP) from the file opening (which the caller can do).  For one    thing, might make it easier to know whether to put NAME or *PATHP    into error messages.  */
end_comment

begin_function
name|int
name|fopen_case
parameter_list|(
name|name
parameter_list|,
name|mode
parameter_list|,
name|fp
parameter_list|,
name|pathp
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|mode
decl_stmt|;
name|FILE
modifier|*
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
modifier|*
name|pathp
decl_stmt|;
block|{
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|char
modifier|*
name|found_name
decl_stmt|;
name|int
name|retval
decl_stmt|;
comment|/* Separate NAME into directory DIR and filename within the directory        FNAME.  */
name|dir
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|fname
operator|=
name|strrchr
argument_list|(
name|dir
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"internal error: relative pathname in fopen_case"
argument_list|)
expr_stmt|;
operator|*
name|fname
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|found_name
operator|=
name|NULL
expr_stmt|;
name|dirp
operator|=
name|CVS_OPENDIR
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
block|{
comment|/* This can happen if we are looking in the Attic and the Attic 	       directory does not exist.  Return the error to the caller; 	       they know what to do with it.  */
name|retval
operator|=
name|errno
expr_stmt|;
goto|goto
name|out
goto|;
block|}
else|else
block|{
comment|/* Give a fatal error; that way the error message can be 	       more specific than if we returned the error to the caller.  */
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot read directory %s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
block|}
name|errno
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|dp
operator|=
name|CVS_READDIR
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cvs_casecmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|fname
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|found_name
operator|!=
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s is ambiguous; could mean %s or %s"
argument_list|,
name|fname
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
name|found_name
argument_list|)
expr_stmt|;
name|found_name
operator|=
name|xstrdup
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot read directory %s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|CVS_CLOSEDIR
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
if|if
condition|(
name|found_name
operator|==
name|NULL
condition|)
block|{
operator|*
name|fp
operator|=
name|NULL
expr_stmt|;
name|retval
operator|=
name|ENOENT
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Copy the found name back into DIR.  We are assuming that 	   found_name is the same length as fname, which is true as 	   long as the above code is just ignoring case and not other 	   aspects of filename syntax.  */
name|p
operator|=
name|dir
operator|+
name|strlen
argument_list|(
name|dir
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|found_name
argument_list|)
expr_stmt|;
operator|*
name|fp
operator|=
name|fopen
argument_list|(
name|dir
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|fp
operator|==
name|NULL
condition|)
name|retval
operator|=
name|errno
expr_stmt|;
else|else
name|retval
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pathp
operator|==
name|NULL
condition|)
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
else|else
operator|*
name|pathp
operator|=
name|dir
expr_stmt|;
name|free
argument_list|(
name|found_name
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|retval
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SERVER_SUPPORT */
end_comment

begin_comment
comment|/* vim:tabstop=8:shiftwidth=4  */
end_comment

end_unit

