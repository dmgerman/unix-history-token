begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* filesubr.c --- subroutines for dealing with files    Jim Blandy<jimb@cyclic.com>     This file is part of GNU CVS.     GNU CVS is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by the    Free Software Foundation; either version 2, or (at your option) any    later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* These functions were moved out of subr.c because they need different    definitions under operating systems (like, say, Windows NT) with different    file system semantics.  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_comment
comment|/*  * I don't know of a convenient way to test this at configure time, or else  * I'd certainly do it there.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NeXT
argument_list|)
end_if

begin_define
define|#
directive|define
name|LOSING_TMPNAM_FUNCTION
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|deep_remove_dir
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|path
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Copies "from" to "to".  */
end_comment

begin_function
name|void
name|copy_file
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
specifier|const
name|char
modifier|*
name|from
decl_stmt|;
specifier|const
name|char
modifier|*
name|to
decl_stmt|;
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|struct
name|utimbuf
name|t
decl_stmt|;
name|int
name|fdin
decl_stmt|,
name|fdout
decl_stmt|;
if|if
condition|(
name|trace
condition|)
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%c-> copy(%s,%s)\n"
argument_list|,
operator|(
name|server_active
operator|)
condition|?
literal|'S'
else|:
literal|' '
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-> copy(%s,%s)\n"
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|noexec
condition|)
return|return;
if|if
condition|(
operator|(
name|fdin
operator|=
name|open
argument_list|(
name|from
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s for copying"
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fdin
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot fstat %s"
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fdout
operator|=
name|creat
argument_list|(
name|to
argument_list|,
operator|(
name|int
operator|)
name|sb
operator|.
name|st_mode
operator|&
literal|07777
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot create %s for copying"
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|.
name|st_size
operator|>
literal|0
condition|)
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|n
operator|=
name|read
argument_list|(
name|fdin
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|EINTR
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
endif|#
directive|endif
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot read file %s for copying"
argument_list|,
name|from
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|write
argument_list|(
name|fdout
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
operator|!=
name|n
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot write file %s for copying"
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|HAVE_FSYNC
if|if
condition|(
name|fsync
argument_list|(
name|fdout
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot fsync file %s after copying"
argument_list|,
name|to
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|close
argument_list|(
name|fdin
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|fdout
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|to
argument_list|)
expr_stmt|;
comment|/* now, set the times for the copied file to match those of the original */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|t
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|.
name|actime
operator|=
name|sb
operator|.
name|st_atime
expr_stmt|;
name|t
operator|.
name|modtime
operator|=
name|sb
operator|.
name|st_mtime
expr_stmt|;
operator|(
name|void
operator|)
name|utime
argument_list|(
name|to
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* FIXME-krp: these functions would benefit from caching the char *&    stat buf.  */
end_comment

begin_comment
comment|/*  * Returns non-zero if the argument file is a directory, or is a symbolic  * link which points to a directory.  */
end_comment

begin_function
name|int
name|isdir
parameter_list|(
name|file
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|S_ISDIR
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns non-zero if the argument file is a symbolic link.  */
end_comment

begin_function
name|int
name|islink
parameter_list|(
name|file
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|S_ISLNK
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|file
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|S_ISLNK
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
operator|)
return|;
else|#
directive|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Returns non-zero if the argument file exists.  */
end_comment

begin_function
name|int
name|isfile
parameter_list|(
name|file
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
block|{
return|return
name|isaccessible
argument_list|(
name|file
argument_list|,
name|F_OK
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns non-zero if the argument file is readable.  */
end_comment

begin_function
name|int
name|isreadable
parameter_list|(
name|file
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
block|{
return|return
name|isaccessible
argument_list|(
name|file
argument_list|,
name|R_OK
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns non-zero if the argument file is writable.  */
end_comment

begin_function
name|int
name|iswritable
parameter_list|(
name|file
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
block|{
return|return
name|isaccessible
argument_list|(
name|file
argument_list|,
name|W_OK
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns non-zero if the argument file is accessable according to  * mode.  If compiled with SETXID_SUPPORT also works if cvs has setxid  * bits set.  */
end_comment

begin_function
name|int
name|isaccessible
parameter_list|(
name|file
parameter_list|,
name|mode
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
specifier|const
name|int
name|mode
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|SETXID_SUPPORT
name|struct
name|stat
name|sb
decl_stmt|;
name|int
name|umask
init|=
literal|0
decl_stmt|;
name|int
name|gmask
init|=
literal|0
decl_stmt|;
name|int
name|omask
init|=
literal|0
decl_stmt|;
name|int
name|uid
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mode
operator|==
name|F_OK
condition|)
return|return
literal|1
return|;
name|uid
operator|=
name|geteuid
argument_list|()
expr_stmt|;
if|if
condition|(
name|uid
operator|==
literal|0
condition|)
comment|/* superuser */
block|{
if|if
condition|(
name|mode
operator|&
name|X_OK
condition|)
return|return
name|sb
operator|.
name|st_mode
operator|&
operator|(
name|S_IXUSR
operator||
name|S_IXGRP
operator||
name|S_IXOTH
operator|)
return|;
else|else
return|return
literal|1
return|;
block|}
if|if
condition|(
name|mode
operator|&
name|R_OK
condition|)
block|{
name|umask
operator||=
name|S_IRUSR
expr_stmt|;
name|gmask
operator||=
name|S_IRGRP
expr_stmt|;
name|omask
operator||=
name|S_IROTH
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|&
name|W_OK
condition|)
block|{
name|umask
operator||=
name|S_IWUSR
expr_stmt|;
name|gmask
operator||=
name|S_IWGRP
expr_stmt|;
name|omask
operator||=
name|S_IWOTH
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|&
name|X_OK
condition|)
block|{
name|umask
operator||=
name|S_IXUSR
expr_stmt|;
name|gmask
operator||=
name|S_IXGRP
expr_stmt|;
name|omask
operator||=
name|S_IXOTH
expr_stmt|;
block|}
if|if
condition|(
name|sb
operator|.
name|st_uid
operator|==
name|uid
condition|)
return|return
operator|(
name|sb
operator|.
name|st_mode
operator|&
name|umask
operator|)
operator|==
name|umask
return|;
elseif|else
if|if
condition|(
name|sb
operator|.
name|st_gid
operator|==
name|getegid
argument_list|()
condition|)
return|return
operator|(
name|sb
operator|.
name|st_mode
operator|&
name|gmask
operator|)
operator|==
name|gmask
return|;
else|else
return|return
operator|(
name|sb
operator|.
name|st_mode
operator|&
name|omask
operator|)
operator|==
name|omask
return|;
else|#
directive|else
return|return
name|access
argument_list|(
name|file
argument_list|,
name|mode
argument_list|)
operator|==
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Open a file and die if it fails  */
end_comment

begin_function
name|FILE
modifier|*
name|open_file
parameter_list|(
name|name
parameter_list|,
name|mode
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|mode
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|fp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Make a directory and die if it fails  */
end_comment

begin_function
name|void
name|make_directory
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|!
name|S_ISDIR
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s already exists but is not a directory"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|noexec
operator|&&
name|mkdir
argument_list|(
name|name
argument_list|,
literal|0777
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot make directory %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Make a path to the argument directory, printing a message if something  * goes wrong.  */
end_comment

begin_function
name|void
name|make_directories
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|noexec
condition|)
return|return;
if|if
condition|(
name|mkdir
argument_list|(
name|name
argument_list|,
literal|0777
argument_list|)
operator|==
literal|0
operator|||
name|errno
operator|==
name|EEXIST
condition|)
return|return;
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot make path to %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|make_directories
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
return|return;
operator|(
name|void
operator|)
name|mkdir
argument_list|(
name|name
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Change the mode of a file, either adding write permissions, or removing  * all write permissions.  Either change honors the current umask setting.  */
end_comment

begin_function
name|void
name|xchmod
parameter_list|(
name|fname
parameter_list|,
name|writable
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|writable
decl_stmt|;
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|mode_t
name|mode
decl_stmt|,
name|oumask
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|fname
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|noexec
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot stat %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return;
block|}
name|oumask
operator|=
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|oumask
argument_list|)
expr_stmt|;
if|if
condition|(
name|writable
condition|)
block|{
name|mode
operator|=
name|sb
operator|.
name|st_mode
operator||
operator|(
operator|~
name|oumask
operator|&
operator|(
operator|(
operator|(
name|sb
operator|.
name|st_mode
operator|&
name|S_IRUSR
operator|)
condition|?
name|S_IWUSR
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|sb
operator|.
name|st_mode
operator|&
name|S_IRGRP
operator|)
condition|?
name|S_IWGRP
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|sb
operator|.
name|st_mode
operator|&
name|S_IROTH
operator|)
condition|?
name|S_IWOTH
else|:
literal|0
operator|)
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|mode
operator|=
name|sb
operator|.
name|st_mode
operator|&
operator|~
operator|(
name|S_IWRITE
operator||
name|S_IWGRP
operator||
name|S_IWOTH
operator|)
operator|&
operator|~
name|oumask
expr_stmt|;
block|}
if|if
condition|(
name|trace
condition|)
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%c-> chmod(%s,%o)\n"
argument_list|,
operator|(
name|server_active
operator|)
condition|?
literal|'S'
else|:
literal|' '
argument_list|,
name|fname
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|mode
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-> chmod(%s,%o)\n"
argument_list|,
name|fname
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|noexec
condition|)
return|return;
if|if
condition|(
name|chmod
argument_list|(
name|fname
argument_list|,
name|mode
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot change mode of file %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Rename a file and die if it fails  */
end_comment

begin_function
name|void
name|rename_file
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
specifier|const
name|char
modifier|*
name|from
decl_stmt|;
specifier|const
name|char
modifier|*
name|to
decl_stmt|;
block|{
if|if
condition|(
name|trace
condition|)
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%c-> rename(%s,%s)\n"
argument_list|,
operator|(
name|server_active
operator|)
condition|?
literal|'S'
else|:
literal|' '
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-> rename(%s,%s)\n"
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|noexec
condition|)
return|return;
if|if
condition|(
name|rename
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot rename file %s to %s"
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * link a file, if possible.  Warning: the Windows NT version of this  * function just copies the file, so only use this function in ways  * that can deal with either a link or a copy.  */
end_comment

begin_function
name|int
name|link_file
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
specifier|const
name|char
modifier|*
name|from
decl_stmt|;
specifier|const
name|char
modifier|*
name|to
decl_stmt|;
block|{
if|if
condition|(
name|trace
condition|)
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%c-> link(%s,%s)\n"
argument_list|,
operator|(
name|server_active
operator|)
condition|?
literal|'S'
else|:
literal|' '
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-> link(%s,%s)\n"
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|noexec
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|link
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * unlink a file, if possible.  */
end_comment

begin_function
name|int
name|unlink_file
parameter_list|(
name|f
parameter_list|)
specifier|const
name|char
modifier|*
name|f
decl_stmt|;
block|{
if|if
condition|(
name|trace
condition|)
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%c-> unlink(%s)\n"
argument_list|,
operator|(
name|server_active
operator|)
condition|?
literal|'S'
else|:
literal|' '
argument_list|,
name|f
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-> unlink(%s)\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|noexec
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|unlink
argument_list|(
name|f
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unlink a file or dir, if possible.  If it is a directory do a deep  * removal of all of the files in the directory.  Return -1 on error  * (in which case errno is set).  */
end_comment

begin_function
name|int
name|unlink_file_dir
parameter_list|(
name|f
parameter_list|)
specifier|const
name|char
modifier|*
name|f
decl_stmt|;
block|{
if|if
condition|(
name|trace
condition|)
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%c-> unlink_file_dir(%s)\n"
argument_list|,
operator|(
name|server_active
operator|)
condition|?
literal|'S'
else|:
literal|' '
argument_list|,
name|f
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-> unlink_file_dir(%s)\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|noexec
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* For at least some unices, if root tries to unlink() a directory,        instead of doing something rational like returning EISDIR,        the system will gleefully go ahead and corrupt the filesystem.        So we first call isdir() to see if it is OK to call unlink().  This        doesn't quite work--if someone creates a directory between the        call to isdir() and the call to unlink(), we'll still corrupt        the filesystem.  Where is the Unix Haters Handbook when you need        it?  */
if|if
condition|(
name|isdir
argument_list|(
name|f
argument_list|)
condition|)
return|return
name|deep_remove_dir
argument_list|(
name|f
argument_list|)
return|;
else|else
block|{
if|if
condition|(
name|unlink
argument_list|(
name|f
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* We were able to remove the file from the disk */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Remove a directory and everything it contains.  Returns 0 for  * success, -1 for failure (in which case errno is set).  */
end_comment

begin_function
specifier|static
name|int
name|deep_remove_dir
parameter_list|(
name|path
parameter_list|)
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
block|{
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
name|char
name|buf
index|[
name|PATH_MAX
index|]
decl_stmt|;
if|if
condition|(
name|rmdir
argument_list|(
name|path
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|errno
operator|==
name|ENOTEMPTY
operator|||
name|errno
operator|==
name|EEXIST
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
name|path
argument_list|)
operator|)
operator|==
name|NULL
condition|)
comment|/* If unable to open the directory return 	     * an error 	     */
return|return
operator|-
literal|1
return|;
while|while
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/%s"
argument_list|,
name|path
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
comment|/* See comment in unlink_file_dir explanation of why we use 	       isdir instead of just calling unlink and checking the 	       status.  */
if|if
condition|(
name|isdir
argument_list|(
name|buf
argument_list|)
condition|)
block|{
if|if
condition|(
name|deep_remove_dir
argument_list|(
name|buf
argument_list|)
condition|)
block|{
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|unlink
argument_list|(
name|buf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
return|return
name|rmdir
argument_list|(
name|path
argument_list|)
return|;
block|}
comment|/* Was able to remove the directory return 0 */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Read NCHARS bytes from descriptor FD into BUF.    Return the number of characters successfully read.    The number returned is always NCHARS unless end-of-file or error.  */
end_comment

begin_function
specifier|static
name|size_t
name|block_read
parameter_list|(
name|fd
parameter_list|,
name|buf
parameter_list|,
name|nchars
parameter_list|)
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|nchars
decl_stmt|;
block|{
name|char
modifier|*
name|bp
init|=
name|buf
decl_stmt|;
name|size_t
name|nread
decl_stmt|;
do|do
block|{
name|nread
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|bp
argument_list|,
name|nchars
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|EINTR
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
endif|#
directive|endif
return|return
operator|(
name|size_t
operator|)
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|nread
operator|==
literal|0
condition|)
break|break;
name|bp
operator|+=
name|nread
expr_stmt|;
name|nchars
operator|-=
name|nread
expr_stmt|;
block|}
do|while
condition|(
name|nchars
operator|!=
literal|0
condition|)
do|;
return|return
name|bp
operator|-
name|buf
return|;
block|}
end_function

begin_comment
comment|/*  * Compare "file1" to "file2". Return non-zero if they don't compare exactly.  */
end_comment

begin_function
name|int
name|xcmp
parameter_list|(
name|file1
parameter_list|,
name|file2
parameter_list|)
specifier|const
name|char
modifier|*
name|file1
decl_stmt|;
specifier|const
name|char
modifier|*
name|file2
decl_stmt|;
block|{
name|char
modifier|*
name|buf1
decl_stmt|,
modifier|*
name|buf2
decl_stmt|;
name|struct
name|stat
name|sb1
decl_stmt|,
name|sb2
decl_stmt|;
name|int
name|fd1
decl_stmt|,
name|fd2
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|fd1
operator|=
name|open
argument_list|(
name|file1
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot open file %s for comparing"
argument_list|,
name|file1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd2
operator|=
name|open
argument_list|(
name|file2
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot open file %s for comparing"
argument_list|,
name|file2
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fd1
argument_list|,
operator|&
name|sb1
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot fstat %s"
argument_list|,
name|file1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fd2
argument_list|,
operator|&
name|sb2
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot fstat %s"
argument_list|,
name|file2
argument_list|)
expr_stmt|;
comment|/* A generic file compare routine might compare st_dev& st_ino here         to see if the two files being compared are actually the same file.        But that won't happen in CVS, so we won't bother. */
if|if
condition|(
name|sb1
operator|.
name|st_size
operator|!=
name|sb2
operator|.
name|st_size
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|sb1
operator|.
name|st_size
operator|==
literal|0
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* FIXME: compute the optimal buffer size by computing the least 	   common multiple of the files st_blocks field */
name|size_t
name|buf_size
init|=
literal|8
operator|*
literal|1024
decl_stmt|;
name|size_t
name|read1
decl_stmt|;
name|size_t
name|read2
decl_stmt|;
name|buf1
operator|=
name|xmalloc
argument_list|(
name|buf_size
argument_list|)
expr_stmt|;
name|buf2
operator|=
name|xmalloc
argument_list|(
name|buf_size
argument_list|)
expr_stmt|;
do|do
block|{
name|read1
operator|=
name|block_read
argument_list|(
name|fd1
argument_list|,
name|buf1
argument_list|,
name|buf_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|read1
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot read file %s for comparing"
argument_list|,
name|file1
argument_list|)
expr_stmt|;
name|read2
operator|=
name|block_read
argument_list|(
name|fd2
argument_list|,
name|buf2
argument_list|,
name|buf_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|read2
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot read file %s for comparing"
argument_list|,
name|file2
argument_list|)
expr_stmt|;
comment|/* assert (read1 == read2); */
name|ret
operator|=
name|memcmp
argument_list|(
name|buf1
argument_list|,
name|buf2
argument_list|,
name|read1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ret
operator|==
literal|0
operator|&&
name|read1
operator|==
name|buf_size
condition|)
do|;
name|free
argument_list|(
name|buf1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd2
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|LOSING_TMPNAM_FUNCTION
end_ifdef

begin_function
name|char
modifier|*
name|tmpnam
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
specifier|static
name|char
name|value
index|[
name|L_tmpnam
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|strcpy
argument_list|(
name|s
argument_list|,
literal|"/tmp/cvsXXXXXX"
argument_list|)
expr_stmt|;
name|mktemp
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|value
argument_list|,
literal|"/tmp/cvsXXXXXX"
argument_list|)
expr_stmt|;
name|mktemp
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return non-zero iff FILENAME is absolute.    Trivial under Unix, but more complicated under other systems.  */
end_comment

begin_function
name|int
name|isabsolute
parameter_list|(
name|filename
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
return|return
name|filename
index|[
literal|0
index|]
operator|==
literal|'/'
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer into PATH's last component.  */
end_comment

begin_function
name|char
modifier|*
name|last_component
parameter_list|(
name|path
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
block|{
name|char
modifier|*
name|last
init|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|last
condition|)
return|return
name|last
operator|+
literal|1
return|;
else|else
return|return
name|path
return|;
block|}
end_function

begin_comment
comment|/* Return the home directory.  Returns a pointer to storage    managed by this function or its callees (currently getenv).  */
end_comment

begin_function
name|char
modifier|*
name|get_homedir
parameter_list|()
block|{
return|return
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* See cvs.h for description.  On unix this does nothing, because the    shell expands the wildcards.  */
end_comment

begin_function
name|void
name|expand_wild
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pargc
parameter_list|,
name|pargv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
modifier|*
name|pargc
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|pargv
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
operator|*
name|pargc
operator|=
name|argc
expr_stmt|;
operator|*
name|pargv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
operator|(
operator|*
name|pargv
operator|)
index|[
name|i
index|]
operator|=
name|xstrdup
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

