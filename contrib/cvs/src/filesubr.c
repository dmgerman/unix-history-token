begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* filesubr.c --- subroutines for dealing with files    Jim Blandy<jimb@cyclic.com>     This file is part of GNU CVS.     GNU CVS is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by the    Free Software Foundation; either version 2, or (at your option) any    later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.  */
end_comment

begin_comment
comment|/* These functions were moved out of subr.c because they need different    definitions under operating systems (like, say, Windows NT) with different    file system semantics.  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|deep_remove_dir
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|path
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Copies "from" to "to".  */
end_comment

begin_function
name|void
name|copy_file
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
specifier|const
name|char
modifier|*
name|from
decl_stmt|;
specifier|const
name|char
modifier|*
name|to
decl_stmt|;
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|struct
name|utimbuf
name|t
decl_stmt|;
name|int
name|fdin
decl_stmt|,
name|fdout
decl_stmt|;
if|if
condition|(
name|trace
condition|)
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%c-> copy(%s,%s)\n"
argument_list|,
operator|(
name|server_active
operator|)
condition|?
literal|'S'
else|:
literal|' '
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-> copy(%s,%s)\n"
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|noexec
condition|)
return|return;
if|if
condition|(
operator|(
name|fdin
operator|=
name|open
argument_list|(
name|from
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s for copying"
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fdin
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot fstat %s"
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fdout
operator|=
name|creat
argument_list|(
name|to
argument_list|,
operator|(
name|int
operator|)
name|sb
operator|.
name|st_mode
operator|&
literal|07777
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot create %s for copying"
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|.
name|st_size
operator|>
literal|0
condition|)
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|n
operator|=
name|read
argument_list|(
name|fdin
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|EINTR
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
endif|#
directive|endif
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot read file %s for copying"
argument_list|,
name|from
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|write
argument_list|(
name|fdout
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
operator|!=
name|n
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot write file %s for copying"
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|HAVE_FSYNC
if|if
condition|(
name|fsync
argument_list|(
name|fdout
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot fsync file %s after copying"
argument_list|,
name|to
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|close
argument_list|(
name|fdin
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|fdout
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|to
argument_list|)
expr_stmt|;
comment|/* now, set the times for the copied file to match those of the original */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|t
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|.
name|actime
operator|=
name|sb
operator|.
name|st_atime
expr_stmt|;
name|t
operator|.
name|modtime
operator|=
name|sb
operator|.
name|st_mtime
expr_stmt|;
operator|(
name|void
operator|)
name|utime
argument_list|(
name|to
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* FIXME-krp: these functions would benefit from caching the char *&    stat buf.  */
end_comment

begin_comment
comment|/*  * Returns non-zero if the argument file is a directory, or is a symbolic  * link which points to a directory.  */
end_comment

begin_function
name|int
name|isdir
parameter_list|(
name|file
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|S_ISDIR
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns non-zero if the argument file is a symbolic link.  */
end_comment

begin_function
name|int
name|islink
parameter_list|(
name|file
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|S_ISLNK
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|file
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|S_ISLNK
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
operator|)
return|;
else|#
directive|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Returns non-zero if the argument file exists.  */
end_comment

begin_function
name|int
name|isfile
parameter_list|(
name|file
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
block|{
return|return
name|isaccessible
argument_list|(
name|file
argument_list|,
name|F_OK
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns non-zero if the argument file is readable.  */
end_comment

begin_function
name|int
name|isreadable
parameter_list|(
name|file
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
block|{
return|return
name|isaccessible
argument_list|(
name|file
argument_list|,
name|R_OK
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns non-zero if the argument file is writable.  */
end_comment

begin_function
name|int
name|iswritable
parameter_list|(
name|file
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
block|{
return|return
name|isaccessible
argument_list|(
name|file
argument_list|,
name|W_OK
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns non-zero if the argument file is accessable according to  * mode.  If compiled with SETXID_SUPPORT also works if cvs has setxid  * bits set.  */
end_comment

begin_function
name|int
name|isaccessible
parameter_list|(
name|file
parameter_list|,
name|mode
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
specifier|const
name|int
name|mode
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|SETXID_SUPPORT
name|struct
name|stat
name|sb
decl_stmt|;
name|int
name|umask
init|=
literal|0
decl_stmt|;
name|int
name|gmask
init|=
literal|0
decl_stmt|;
name|int
name|omask
init|=
literal|0
decl_stmt|;
name|int
name|uid
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mode
operator|==
name|F_OK
condition|)
return|return
literal|1
return|;
name|uid
operator|=
name|geteuid
argument_list|()
expr_stmt|;
if|if
condition|(
name|uid
operator|==
literal|0
condition|)
comment|/* superuser */
block|{
if|if
condition|(
name|mode
operator|&
name|X_OK
condition|)
return|return
name|sb
operator|.
name|st_mode
operator|&
operator|(
name|S_IXUSR
operator||
name|S_IXGRP
operator||
name|S_IXOTH
operator|)
return|;
else|else
return|return
literal|1
return|;
block|}
if|if
condition|(
name|mode
operator|&
name|R_OK
condition|)
block|{
name|umask
operator||=
name|S_IRUSR
expr_stmt|;
name|gmask
operator||=
name|S_IRGRP
expr_stmt|;
name|omask
operator||=
name|S_IROTH
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|&
name|W_OK
condition|)
block|{
name|umask
operator||=
name|S_IWUSR
expr_stmt|;
name|gmask
operator||=
name|S_IWGRP
expr_stmt|;
name|omask
operator||=
name|S_IWOTH
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|&
name|X_OK
condition|)
block|{
name|umask
operator||=
name|S_IXUSR
expr_stmt|;
name|gmask
operator||=
name|S_IXGRP
expr_stmt|;
name|omask
operator||=
name|S_IXOTH
expr_stmt|;
block|}
if|if
condition|(
name|sb
operator|.
name|st_uid
operator|==
name|uid
condition|)
return|return
operator|(
name|sb
operator|.
name|st_mode
operator|&
name|umask
operator|)
operator|==
name|umask
return|;
elseif|else
if|if
condition|(
name|sb
operator|.
name|st_gid
operator|==
name|getegid
argument_list|()
condition|)
return|return
operator|(
name|sb
operator|.
name|st_mode
operator|&
name|gmask
operator|)
operator|==
name|gmask
return|;
else|else
return|return
operator|(
name|sb
operator|.
name|st_mode
operator|&
name|omask
operator|)
operator|==
name|omask
return|;
else|#
directive|else
return|return
name|access
argument_list|(
name|file
argument_list|,
name|mode
argument_list|)
operator|==
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Open a file and die if it fails  */
end_comment

begin_function
name|FILE
modifier|*
name|open_file
parameter_list|(
name|name
parameter_list|,
name|mode
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|mode
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|fp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Make a directory and die if it fails  */
end_comment

begin_function
name|void
name|make_directory
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|!
name|S_ISDIR
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s already exists but is not a directory"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|noexec
operator|&&
name|mkdir
argument_list|(
name|name
argument_list|,
literal|0777
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot make directory %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Make a path to the argument directory, printing a message if something  * goes wrong.  */
end_comment

begin_function
name|void
name|make_directories
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|noexec
condition|)
return|return;
if|if
condition|(
name|mkdir
argument_list|(
name|name
argument_list|,
literal|0777
argument_list|)
operator|==
literal|0
operator|||
name|errno
operator|==
name|EEXIST
condition|)
return|return;
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot make path to %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|make_directories
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
return|return;
operator|(
name|void
operator|)
name|mkdir
argument_list|(
name|name
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create directory NAME if it does not already exist; fatal error for    other errors.  Returns 0 if directory was created; 1 if it already    existed.  */
end_comment

begin_function
name|int
name|mkdir_if_needed
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|mkdir
argument_list|(
name|name
argument_list|,
literal|0777
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|errno
operator|==
name|EEXIST
operator|||
operator|(
name|errno
operator|==
name|EACCES
operator|&&
name|isdir
argument_list|(
name|name
argument_list|)
operator|)
operator|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot make directory %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Change the mode of a file, either adding write permissions, or removing  * all write permissions.  Either change honors the current umask setting.  */
end_comment

begin_function
name|void
name|xchmod
parameter_list|(
name|fname
parameter_list|,
name|writable
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|writable
decl_stmt|;
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|mode_t
name|mode
decl_stmt|,
name|oumask
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|fname
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|noexec
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot stat %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return;
block|}
name|oumask
operator|=
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|oumask
argument_list|)
expr_stmt|;
if|if
condition|(
name|writable
condition|)
block|{
name|mode
operator|=
name|sb
operator|.
name|st_mode
operator||
operator|(
operator|~
name|oumask
operator|&
operator|(
operator|(
operator|(
name|sb
operator|.
name|st_mode
operator|&
name|S_IRUSR
operator|)
condition|?
name|S_IWUSR
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|sb
operator|.
name|st_mode
operator|&
name|S_IRGRP
operator|)
condition|?
name|S_IWGRP
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|sb
operator|.
name|st_mode
operator|&
name|S_IROTH
operator|)
condition|?
name|S_IWOTH
else|:
literal|0
operator|)
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|mode
operator|=
name|sb
operator|.
name|st_mode
operator|&
operator|~
operator|(
name|S_IWRITE
operator||
name|S_IWGRP
operator||
name|S_IWOTH
operator|)
operator|&
operator|~
name|oumask
expr_stmt|;
block|}
if|if
condition|(
name|trace
condition|)
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%c-> chmod(%s,%o)\n"
argument_list|,
operator|(
name|server_active
operator|)
condition|?
literal|'S'
else|:
literal|' '
argument_list|,
name|fname
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|mode
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-> chmod(%s,%o)\n"
argument_list|,
name|fname
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|noexec
condition|)
return|return;
if|if
condition|(
name|chmod
argument_list|(
name|fname
argument_list|,
name|mode
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot change mode of file %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Rename a file and die if it fails  */
end_comment

begin_function
name|void
name|rename_file
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
specifier|const
name|char
modifier|*
name|from
decl_stmt|;
specifier|const
name|char
modifier|*
name|to
decl_stmt|;
block|{
if|if
condition|(
name|trace
condition|)
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%c-> rename(%s,%s)\n"
argument_list|,
operator|(
name|server_active
operator|)
condition|?
literal|'S'
else|:
literal|' '
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-> rename(%s,%s)\n"
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|noexec
condition|)
return|return;
if|if
condition|(
name|rename
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot rename file %s to %s"
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * link a file, if possible.  Warning: the Windows NT version of this  * function just copies the file, so only use this function in ways  * that can deal with either a link or a copy.  */
end_comment

begin_function
name|int
name|link_file
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
specifier|const
name|char
modifier|*
name|from
decl_stmt|;
specifier|const
name|char
modifier|*
name|to
decl_stmt|;
block|{
if|if
condition|(
name|trace
condition|)
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%c-> link(%s,%s)\n"
argument_list|,
operator|(
name|server_active
operator|)
condition|?
literal|'S'
else|:
literal|' '
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-> link(%s,%s)\n"
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|noexec
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|link
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * unlink a file, if possible.  */
end_comment

begin_function
name|int
name|unlink_file
parameter_list|(
name|f
parameter_list|)
specifier|const
name|char
modifier|*
name|f
decl_stmt|;
block|{
if|if
condition|(
name|trace
condition|)
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%c-> unlink(%s)\n"
argument_list|,
operator|(
name|server_active
operator|)
condition|?
literal|'S'
else|:
literal|' '
argument_list|,
name|f
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-> unlink(%s)\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|noexec
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|unlink
argument_list|(
name|f
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unlink a file or dir, if possible.  If it is a directory do a deep  * removal of all of the files in the directory.  Return -1 on error  * (in which case errno is set).  */
end_comment

begin_function
name|int
name|unlink_file_dir
parameter_list|(
name|f
parameter_list|)
specifier|const
name|char
modifier|*
name|f
decl_stmt|;
block|{
if|if
condition|(
name|trace
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
comment|/* This is called by the server parent process in contexts where 	   it is not OK to send output (e.g. after we sent "ok" to the 	   client).  */
operator|&&
operator|!
name|server_active
endif|#
directive|endif
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-> unlink_file_dir(%s)\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|noexec
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* For at least some unices, if root tries to unlink() a directory,        instead of doing something rational like returning EISDIR,        the system will gleefully go ahead and corrupt the filesystem.        So we first call isdir() to see if it is OK to call unlink().  This        doesn't quite work--if someone creates a directory between the        call to isdir() and the call to unlink(), we'll still corrupt        the filesystem.  Where is the Unix Haters Handbook when you need        it?  */
if|if
condition|(
name|isdir
argument_list|(
name|f
argument_list|)
condition|)
return|return
name|deep_remove_dir
argument_list|(
name|f
argument_list|)
return|;
else|else
block|{
if|if
condition|(
name|unlink
argument_list|(
name|f
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* We were able to remove the file from the disk */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Remove a directory and everything it contains.  Returns 0 for  * success, -1 for failure (in which case errno is set).  */
end_comment

begin_function
specifier|static
name|int
name|deep_remove_dir
parameter_list|(
name|path
parameter_list|)
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
block|{
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
name|rmdir
argument_list|(
name|path
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOTEMPTY
operator|||
name|errno
operator|==
name|EEXIST
comment|/* Ugly workaround for ugly AIX 4.1 (and 3.2) header bug 	       (it defines ENOTEMPTY and EEXIST to 17 but actually 	       returns 87).  */
operator|||
operator|(
name|ENOTEMPTY
operator|==
literal|17
operator|&&
name|EEXIST
operator|==
literal|17
operator|&&
name|errno
operator|==
literal|87
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
name|path
argument_list|)
operator|)
operator|==
name|NULL
condition|)
comment|/* If unable to open the directory return 		 * an error 		 */
return|return
operator|-
literal|1
return|;
while|while
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|buf
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
name|strlen
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/%s"
argument_list|,
name|path
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
comment|/* See comment in unlink_file_dir explanation of why we use 		   isdir instead of just calling unlink and checking the 		   status.  */
if|if
condition|(
name|isdir
argument_list|(
name|buf
argument_list|)
condition|)
block|{
if|if
condition|(
name|deep_remove_dir
argument_list|(
name|buf
argument_list|)
condition|)
block|{
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|unlink
argument_list|(
name|buf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
return|return
name|rmdir
argument_list|(
name|path
argument_list|)
return|;
block|}
else|else
return|return
operator|-
literal|1
return|;
block|}
comment|/* Was able to remove the directory return 0 */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Read NCHARS bytes from descriptor FD into BUF.    Return the number of characters successfully read.    The number returned is always NCHARS unless end-of-file or error.  */
end_comment

begin_function
specifier|static
name|size_t
name|block_read
parameter_list|(
name|fd
parameter_list|,
name|buf
parameter_list|,
name|nchars
parameter_list|)
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|nchars
decl_stmt|;
block|{
name|char
modifier|*
name|bp
init|=
name|buf
decl_stmt|;
name|size_t
name|nread
decl_stmt|;
do|do
block|{
name|nread
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|bp
argument_list|,
name|nchars
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|EINTR
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
endif|#
directive|endif
return|return
operator|(
name|size_t
operator|)
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|nread
operator|==
literal|0
condition|)
break|break;
name|bp
operator|+=
name|nread
expr_stmt|;
name|nchars
operator|-=
name|nread
expr_stmt|;
block|}
do|while
condition|(
name|nchars
operator|!=
literal|0
condition|)
do|;
return|return
name|bp
operator|-
name|buf
return|;
block|}
end_function

begin_comment
comment|/*  * Compare "file1" to "file2". Return non-zero if they don't compare exactly.  */
end_comment

begin_function
name|int
name|xcmp
parameter_list|(
name|file1
parameter_list|,
name|file2
parameter_list|)
specifier|const
name|char
modifier|*
name|file1
decl_stmt|;
specifier|const
name|char
modifier|*
name|file2
decl_stmt|;
block|{
name|char
modifier|*
name|buf1
decl_stmt|,
modifier|*
name|buf2
decl_stmt|;
name|struct
name|stat
name|sb1
decl_stmt|,
name|sb2
decl_stmt|;
name|int
name|fd1
decl_stmt|,
name|fd2
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|fd1
operator|=
name|open
argument_list|(
name|file1
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot open file %s for comparing"
argument_list|,
name|file1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd2
operator|=
name|open
argument_list|(
name|file2
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot open file %s for comparing"
argument_list|,
name|file2
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fd1
argument_list|,
operator|&
name|sb1
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot fstat %s"
argument_list|,
name|file1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fd2
argument_list|,
operator|&
name|sb2
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot fstat %s"
argument_list|,
name|file2
argument_list|)
expr_stmt|;
comment|/* A generic file compare routine might compare st_dev& st_ino here         to see if the two files being compared are actually the same file.        But that won't happen in CVS, so we won't bother. */
if|if
condition|(
name|sb1
operator|.
name|st_size
operator|!=
name|sb2
operator|.
name|st_size
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|sb1
operator|.
name|st_size
operator|==
literal|0
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* FIXME: compute the optimal buffer size by computing the least 	   common multiple of the files st_blocks field */
name|size_t
name|buf_size
init|=
literal|8
operator|*
literal|1024
decl_stmt|;
name|size_t
name|read1
decl_stmt|;
name|size_t
name|read2
decl_stmt|;
name|buf1
operator|=
name|xmalloc
argument_list|(
name|buf_size
argument_list|)
expr_stmt|;
name|buf2
operator|=
name|xmalloc
argument_list|(
name|buf_size
argument_list|)
expr_stmt|;
do|do
block|{
name|read1
operator|=
name|block_read
argument_list|(
name|fd1
argument_list|,
name|buf1
argument_list|,
name|buf_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|read1
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot read file %s for comparing"
argument_list|,
name|file1
argument_list|)
expr_stmt|;
name|read2
operator|=
name|block_read
argument_list|(
name|fd2
argument_list|,
name|buf2
argument_list|,
name|buf_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|read2
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot read file %s for comparing"
argument_list|,
name|file2
argument_list|)
expr_stmt|;
comment|/* assert (read1 == read2); */
name|ret
operator|=
name|memcmp
argument_list|(
name|buf1
argument_list|,
name|buf2
argument_list|,
name|read1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ret
operator|==
literal|0
operator|&&
name|read1
operator|==
name|buf_size
condition|)
do|;
name|free
argument_list|(
name|buf1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd2
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate a unique temporary filename.  Returns a pointer to a newly    malloc'd string containing the name.  Returns successfully or not at    all.  */
end_comment

begin_comment
comment|/* There are at least three functions for generating temporary    filenames.  We use tempnam (SVID 3) if possible, else mktemp (BSD    4.3), and as last resort tmpnam (POSIX). Reason is that tempnam and    mktemp both allow to specify the directory in which the temporary    file will be created.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TEMPNAM
end_ifdef

begin_function
name|char
modifier|*
name|cvs_temp_name
parameter_list|()
block|{
name|char
modifier|*
name|retval
decl_stmt|;
name|retval
operator|=
name|tempnam
argument_list|(
name|Tmpdir
argument_list|,
literal|"cvs"
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot generate temporary filename"
argument_list|)
expr_stmt|;
comment|/* tempnam returns a pointer to a newly malloc'd string, so there's        no need for a xstrdup  */
return|return
name|retval
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|char
modifier|*
name|cvs_temp_name
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|HAVE_MKTEMP
name|char
modifier|*
name|value
decl_stmt|;
name|char
modifier|*
name|retval
decl_stmt|;
name|value
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|Tmpdir
argument_list|)
operator|+
literal|40
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|value
argument_list|,
literal|"%s/%s"
argument_list|,
name|Tmpdir
argument_list|,
literal|"cvsXXXXXX"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mktemp
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot generate temporary filename"
argument_list|)
expr_stmt|;
return|return
name|value
return|;
else|#
directive|else
name|char
name|value
index|[
name|L_tmpnam
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|retval
decl_stmt|;
name|retval
operator|=
name|tmpnam
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot generate temporary filename"
argument_list|)
expr_stmt|;
return|return
name|xstrdup
argument_list|(
name|value
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Return non-zero iff FILENAME is absolute.    Trivial under Unix, but more complicated under other systems.  */
end_comment

begin_function
name|int
name|isabsolute
parameter_list|(
name|filename
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
return|return
name|filename
index|[
literal|0
index|]
operator|==
literal|'/'
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer into PATH's last component.  */
end_comment

begin_function
name|char
modifier|*
name|last_component
parameter_list|(
name|path
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
block|{
name|char
modifier|*
name|last
init|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|last
condition|)
return|return
name|last
operator|+
literal|1
return|;
else|else
return|return
name|path
return|;
block|}
end_function

begin_comment
comment|/* Return the home directory.  Returns a pointer to storage    managed by this function or its callees (currently getenv).    This function will return the same thing every time it is    called.  Returns NULL if there is no home directory.     Note that for a pserver server, this may return root's home    directory.  What typically happens is that upon being started from    inetd, before switching users, the code in cvsrc.c calls    get_homedir which remembers root's home directory in the static    variable.  Then the switch happens and get_homedir might return a    directory that we don't even have read or execute permissions for    (which is bad, when various parts of CVS try to read there).  One    fix would be to make the value returned by get_homedir only good    until the next call (which would free the old value).  Another fix    would be to just always malloc our answer, and let the caller free    it (that is best, because some day we may need to be reentrant).     The workaround is to put -f in inetd.conf which means that    get_homedir won't get called until after the switch in user ID.     The whole concept of a "home directory" on the server is pretty    iffy, although I suppose some people probably are relying on it for    .cvsrc and such, in the cases where it works.  */
end_comment

begin_function
name|char
modifier|*
name|get_homedir
parameter_list|()
block|{
specifier|static
name|char
modifier|*
name|home
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|env
init|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
if|if
condition|(
name|home
operator|!=
name|NULL
condition|)
return|return
name|home
return|;
if|if
condition|(
name|env
condition|)
name|home
operator|=
name|env
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|pw
operator|=
operator|(
expr|struct
name|passwd
operator|*
operator|)
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
operator|)
operator|&&
name|pw
operator|->
name|pw_dir
condition|)
name|home
operator|=
name|xstrdup
argument_list|(
name|pw
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
return|return
name|home
return|;
block|}
end_function

begin_comment
comment|/* See cvs.h for description.  On unix this does nothing, because the    shell expands the wildcards.  */
end_comment

begin_function
name|void
name|expand_wild
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|pargc
parameter_list|,
name|pargv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
modifier|*
name|pargc
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|pargv
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
operator|*
name|pargc
operator|=
name|argc
expr_stmt|;
operator|*
name|pargv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
operator|(
operator|*
name|pargv
operator|)
index|[
name|i
index|]
operator|=
name|xstrdup
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
end_ifdef

begin_comment
comment|/* Case-insensitive string compare.  I know that some systems    have such a routine, but I'm not sure I see any reasons for    dealing with the hair of figuring out whether they do (I haven't    looked into whether this is a performance bottleneck; I would guess    not).  */
end_comment

begin_function
name|int
name|cvs_casecmp
parameter_list|(
name|str1
parameter_list|,
name|str2
parameter_list|)
name|char
modifier|*
name|str1
decl_stmt|;
name|char
modifier|*
name|str2
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|int
name|pqdiff
decl_stmt|;
name|p
operator|=
name|str1
expr_stmt|;
name|q
operator|=
name|str2
expr_stmt|;
while|while
condition|(
operator|(
name|pqdiff
operator|=
name|tolower
argument_list|(
operator|*
name|p
argument_list|)
operator|-
name|tolower
argument_list|(
operator|*
name|q
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
operator|++
name|p
expr_stmt|;
operator|++
name|q
expr_stmt|;
block|}
return|return
name|pqdiff
return|;
block|}
end_function

begin_comment
comment|/* Case-insensitive file open.  As you can see, this is an expensive    call.  We don't regard it as our main strategy for dealing with    case-insensitivity.  Returns errno code or 0 for success.  Puts the    new file in *FP.  NAME and MODE are as for fopen.  If PATHP is not    NULL, then put a malloc'd string containing the pathname as found    into *PATHP.  *PATHP is only set if the return value is 0.     Might be cleaner to separate the file finding (which just gives    *PATHP) from the file opening (which the caller can do).  For one    thing, might make it easier to know whether to put NAME or *PATHP    into error messages.  */
end_comment

begin_function
name|int
name|fopen_case
parameter_list|(
name|name
parameter_list|,
name|mode
parameter_list|,
name|fp
parameter_list|,
name|pathp
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|mode
decl_stmt|;
name|FILE
modifier|*
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
modifier|*
name|pathp
decl_stmt|;
block|{
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|char
modifier|*
name|found_name
decl_stmt|;
name|int
name|retval
decl_stmt|;
comment|/* Separate NAME into directory DIR and filename within the directory        FNAME.  */
name|dir
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|fname
operator|=
name|strrchr
argument_list|(
name|dir
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"internal error: relative pathname in fopen_case"
argument_list|)
expr_stmt|;
operator|*
name|fname
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|found_name
operator|=
name|NULL
expr_stmt|;
name|dirp
operator|=
name|CVS_OPENDIR
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
block|{
comment|/* This can happen if we are looking in the Attic and the Attic 	       directory does not exist.  Return the error to the caller; 	       they know what to do with it.  */
name|retval
operator|=
name|errno
expr_stmt|;
goto|goto
name|out
goto|;
block|}
else|else
block|{
comment|/* Give a fatal error; that way the error message can be 	       more specific than if we returned the error to the caller.  */
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot read directory %s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
block|}
name|errno
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cvs_casecmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|fname
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|found_name
operator|!=
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s is ambiguous; could mean %s or %s"
argument_list|,
name|fname
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
name|found_name
argument_list|)
expr_stmt|;
name|found_name
operator|=
name|xstrdup
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot read directory %s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
if|if
condition|(
name|found_name
operator|==
name|NULL
condition|)
block|{
operator|*
name|fp
operator|=
name|NULL
expr_stmt|;
name|retval
operator|=
name|ENOENT
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Copy the found name back into DIR.  We are assuming that 	   found_name is the same length as fname, which is true as 	   long as the above code is just ignoring case and not other 	   aspects of filename syntax.  */
name|p
operator|=
name|dir
operator|+
name|strlen
argument_list|(
name|dir
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|found_name
argument_list|)
expr_stmt|;
operator|*
name|fp
operator|=
name|fopen
argument_list|(
name|dir
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|fp
operator|==
name|NULL
condition|)
name|retval
operator|=
name|errno
expr_stmt|;
else|else
name|retval
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pathp
operator|==
name|NULL
condition|)
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
else|else
operator|*
name|pathp
operator|=
name|dir
expr_stmt|;
name|free
argument_list|(
name|found_name
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|retval
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SERVER_SUPPORT */
end_comment

end_unit

