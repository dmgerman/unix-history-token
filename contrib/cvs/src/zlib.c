begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* zlib.c --- interface to the zlib compression library    Ian Lance Taylor<ian@cygnus.com>     This file is part of GNU CVS.     GNU CVS is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by the    Free Software Foundation; either version 2, or (at your option) any    later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.  */
end_comment

begin_comment
comment|/* The routines in this file are the interface between the CVS    client/server support and the zlib compression library.  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SERVER_SUPPORT
argument_list|)
operator|||
name|defined
argument_list|(
name|CLIENT_SUPPORT
argument_list|)
end_if

begin_include
include|#
directive|include
file|"zlib.h"
end_include

begin_comment
comment|/* OS/2 doesn't have EIO.  FIXME: this whole notion of turning    a different error into EIO strikes me as pretty dubious.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|EIO
argument_list|)
end_if

begin_define
define|#
directive|define
name|EIO
value|EBADPOS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The compression interface is built upon the buffer data structure.    We provide a buffer type which compresses or decompresses the data    which passes through it.  An input buffer decompresses the data    read from an underlying buffer, and an output buffer compresses the    data before writing it to an underlying buffer.  */
end_comment

begin_comment
comment|/* This structure is the closure field of the buffer.  */
end_comment

begin_struct
struct|struct
name|compress_buffer
block|{
comment|/* The underlying buffer.  */
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
comment|/* The compression information.  */
name|z_stream
name|zstr
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|compress_error
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|z_stream
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compress_buffer_input
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compress_buffer_output
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compress_buffer_flush
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compress_buffer_block
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compress_buffer_shutdown_input
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compress_buffer_shutdown_output
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Report an error from one of the zlib functions.  */
end_comment

begin_function
specifier|static
name|void
name|compress_error
parameter_list|(
name|status
parameter_list|,
name|zstatus
parameter_list|,
name|zstr
parameter_list|,
name|msg
parameter_list|)
name|int
name|status
decl_stmt|;
name|int
name|zstatus
decl_stmt|;
name|z_stream
modifier|*
name|zstr
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|int
name|hold_errno
decl_stmt|;
specifier|const
name|char
modifier|*
name|zmsg
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|hold_errno
operator|=
name|errno
expr_stmt|;
name|zmsg
operator|=
name|zstr
operator|->
name|msg
expr_stmt|;
if|if
condition|(
name|zmsg
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"error %d"
argument_list|,
name|zstatus
argument_list|)
expr_stmt|;
name|zmsg
operator|=
name|buf
expr_stmt|;
block|}
name|error
argument_list|(
name|status
argument_list|,
name|zstatus
operator|==
name|Z_ERRNO
condition|?
name|hold_errno
else|:
literal|0
argument_list|,
literal|"%s: %s"
argument_list|,
name|msg
argument_list|,
name|zmsg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a compression buffer.  */
end_comment

begin_function_decl
name|struct
name|buffer
modifier|*
name|compress_buffer_initialize
parameter_list|(
name|buf
parameter_list|,
name|input
parameter_list|,
name|level
parameter_list|,
name|memory
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
name|int
name|input
decl_stmt|;
name|int
name|level
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*memory
end_function_decl

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|compress_buffer
modifier|*
name|n
decl_stmt|;
name|int
name|zstatus
decl_stmt|;
name|n
operator|=
operator|(
expr|struct
name|compress_buffer
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|n
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|n
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|n
argument_list|)
expr_stmt|;
name|n
operator|->
name|buf
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|input
condition|)
name|zstatus
operator|=
name|inflateInit
argument_list|(
operator|&
name|n
operator|->
name|zstr
argument_list|)
expr_stmt|;
else|else
name|zstatus
operator|=
name|deflateInit
argument_list|(
operator|&
name|n
operator|->
name|zstr
argument_list|,
name|level
argument_list|)
expr_stmt|;
if|if
condition|(
name|zstatus
operator|!=
name|Z_OK
condition|)
name|compress_error
argument_list|(
literal|1
argument_list|,
name|zstatus
argument_list|,
operator|&
name|n
operator|->
name|zstr
argument_list|,
literal|"compression initialization"
argument_list|)
expr_stmt|;
comment|/* There may already be data buffered on BUF.  For an output        buffer, this is OK, because these routines will just use the        buffer routines to append data to the (uncompressed) data        already on BUF.  An input buffer expects to handle a single        buffer_data of buffered input to be uncompressed, so that is OK        provided there is only one buffer.  At present that is all        there ever will be; if this changes, compress_buffer_input must        be modified to handle multiple input buffers.  */
name|assert
argument_list|(
operator|!
name|input
operator|||
name|buf
operator|->
name|data
operator|==
name|NULL
operator|||
name|buf
operator|->
name|data
operator|->
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|buf_initialize
argument_list|(
name|input
condition|?
name|compress_buffer_input
else|:
name|NULL
argument_list|,
name|input
condition|?
name|NULL
else|:
name|compress_buffer_output
argument_list|,
name|input
condition|?
name|NULL
else|:
name|compress_buffer_flush
argument_list|,
name|compress_buffer_block
argument_list|,
operator|(
name|input
condition|?
name|compress_buffer_shutdown_input
else|:
name|compress_buffer_shutdown_output
operator|)
argument_list|,
name|memory
argument_list|,
name|n
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Input data from a compression buffer.  */
end_comment

begin_function
specifier|static
name|int
name|compress_buffer_input
parameter_list|(
name|closure
parameter_list|,
name|data
parameter_list|,
name|need
parameter_list|,
name|size
parameter_list|,
name|got
parameter_list|)
name|void
modifier|*
name|closure
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|need
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
modifier|*
name|got
decl_stmt|;
block|{
name|struct
name|compress_buffer
modifier|*
name|cb
init|=
operator|(
expr|struct
name|compress_buffer
operator|*
operator|)
name|closure
decl_stmt|;
name|struct
name|buffer_data
modifier|*
name|bd
decl_stmt|;
if|if
condition|(
name|cb
operator|->
name|buf
operator|->
name|input
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* We use a single buffer_data structure to buffer up data which        the z_stream structure won't use yet.  We can safely store this        on cb->buf->data, because we never call the buffer routines on        cb->buf; we only call the buffer input routine, since that        gives us the semantics we want.  As noted in        compress_buffer_initialize, the buffer_data structure may        already exist, and hold data which was already read and        buffered before the decompression began.  */
name|bd
operator|=
name|cb
operator|->
name|buf
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|bd
operator|==
name|NULL
condition|)
block|{
name|bd
operator|=
operator|(
operator|(
expr|struct
name|buffer_data
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|buffer_data
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|bd
operator|==
name|NULL
condition|)
return|return
operator|-
literal|2
return|;
name|bd
operator|->
name|text
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|BUFFER_DATA_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|bd
operator|->
name|text
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|bd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
name|bd
operator|->
name|bufp
operator|=
name|bd
operator|->
name|text
expr_stmt|;
name|bd
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|buf
operator|->
name|data
operator|=
name|bd
expr_stmt|;
block|}
name|cb
operator|->
name|zstr
operator|.
name|avail_out
operator|=
name|size
expr_stmt|;
name|cb
operator|->
name|zstr
operator|.
name|next_out
operator|=
operator|(
name|Bytef
operator|*
operator|)
name|data
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|zstatus
decl_stmt|,
name|sofar
decl_stmt|,
name|status
decl_stmt|,
name|nread
decl_stmt|;
comment|/* First try to inflate any data we already have buffered up. 	   This is useful even if we don't have any buffered data, 	   because there may be data buffered inside the z_stream 	   structure.  */
name|cb
operator|->
name|zstr
operator|.
name|avail_in
operator|=
name|bd
operator|->
name|size
expr_stmt|;
name|cb
operator|->
name|zstr
operator|.
name|next_in
operator|=
operator|(
name|Bytef
operator|*
operator|)
name|bd
operator|->
name|bufp
expr_stmt|;
do|do
block|{
name|zstatus
operator|=
name|inflate
argument_list|(
operator|&
name|cb
operator|->
name|zstr
argument_list|,
name|Z_NO_FLUSH
argument_list|)
expr_stmt|;
if|if
condition|(
name|zstatus
operator|==
name|Z_STREAM_END
condition|)
break|break;
if|if
condition|(
name|zstatus
operator|!=
name|Z_OK
operator|&&
name|zstatus
operator|!=
name|Z_BUF_ERROR
condition|)
block|{
name|compress_error
argument_list|(
literal|0
argument_list|,
name|zstatus
argument_list|,
operator|&
name|cb
operator|->
name|zstr
argument_list|,
literal|"inflate"
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
block|}
do|while
condition|(
name|cb
operator|->
name|zstr
operator|.
name|avail_in
operator|>
literal|0
operator|&&
name|cb
operator|->
name|zstr
operator|.
name|avail_out
operator|>
literal|0
condition|)
do|;
name|bd
operator|->
name|size
operator|=
name|cb
operator|->
name|zstr
operator|.
name|avail_in
expr_stmt|;
name|bd
operator|->
name|bufp
operator|=
operator|(
name|char
operator|*
operator|)
name|cb
operator|->
name|zstr
operator|.
name|next_in
expr_stmt|;
if|if
condition|(
name|zstatus
operator|==
name|Z_STREAM_END
condition|)
return|return
operator|-
literal|1
return|;
comment|/* If we have obtained NEED bytes, then return, unless NEED is            zero and we haven't obtained anything at all.  If NEED is            zero, we will keep reading from the underlying buffer until            we either can't read anything, or we have managed to            inflate at least one byte.  */
name|sofar
operator|=
name|size
operator|-
name|cb
operator|->
name|zstr
operator|.
name|avail_out
expr_stmt|;
if|if
condition|(
name|sofar
operator|>
literal|0
operator|&&
name|sofar
operator|>=
name|need
condition|)
break|break;
comment|/* All our buffered data should have been processed at this            point.  */
name|assert
argument_list|(
name|bd
operator|->
name|size
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* This will work well in the server, because this call will 	   do an unblocked read and fetch all the available data.  In 	   the client, this will read a single byte from the stdio 	   stream, which will cause us to call inflate once per byte. 	   It would be more efficient if we could make a call which 	   would fetch all the available bytes, and at least one byte.  */
name|status
operator|=
call|(
modifier|*
name|cb
operator|->
name|buf
operator|->
name|input
call|)
argument_list|(
name|cb
operator|->
name|buf
operator|->
name|closure
argument_list|,
name|bd
operator|->
name|text
argument_list|,
name|need
operator|>
literal|0
condition|?
literal|1
else|:
literal|0
argument_list|,
name|BUFFER_DATA_SIZE
argument_list|,
operator|&
name|nread
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|status
return|;
comment|/* If we didn't read anything, then presumably the buffer is            in nonblocking mode, and we should just get out now with            whatever we've inflated.  */
if|if
condition|(
name|nread
operator|==
literal|0
condition|)
block|{
name|assert
argument_list|(
name|need
operator|==
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|bd
operator|->
name|bufp
operator|=
name|bd
operator|->
name|text
expr_stmt|;
name|bd
operator|->
name|size
operator|=
name|nread
expr_stmt|;
block|}
operator|*
name|got
operator|=
name|size
operator|-
name|cb
operator|->
name|zstr
operator|.
name|avail_out
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Output data to a compression buffer.  */
end_comment

begin_function
specifier|static
name|int
name|compress_buffer_output
parameter_list|(
name|closure
parameter_list|,
name|data
parameter_list|,
name|have
parameter_list|,
name|wrote
parameter_list|)
name|void
modifier|*
name|closure
decl_stmt|;
specifier|const
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|have
decl_stmt|;
name|int
modifier|*
name|wrote
decl_stmt|;
block|{
name|struct
name|compress_buffer
modifier|*
name|cb
init|=
operator|(
expr|struct
name|compress_buffer
operator|*
operator|)
name|closure
decl_stmt|;
name|cb
operator|->
name|zstr
operator|.
name|avail_in
operator|=
name|have
expr_stmt|;
name|cb
operator|->
name|zstr
operator|.
name|next_in
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|data
expr_stmt|;
while|while
condition|(
name|cb
operator|->
name|zstr
operator|.
name|avail_in
operator|>
literal|0
condition|)
block|{
name|char
name|buffer
index|[
name|BUFFER_DATA_SIZE
index|]
decl_stmt|;
name|int
name|zstatus
decl_stmt|;
name|cb
operator|->
name|zstr
operator|.
name|avail_out
operator|=
name|BUFFER_DATA_SIZE
expr_stmt|;
name|cb
operator|->
name|zstr
operator|.
name|next_out
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buffer
expr_stmt|;
name|zstatus
operator|=
name|deflate
argument_list|(
operator|&
name|cb
operator|->
name|zstr
argument_list|,
name|Z_NO_FLUSH
argument_list|)
expr_stmt|;
if|if
condition|(
name|zstatus
operator|!=
name|Z_OK
condition|)
block|{
name|compress_error
argument_list|(
literal|0
argument_list|,
name|zstatus
argument_list|,
operator|&
name|cb
operator|->
name|zstr
argument_list|,
literal|"deflate"
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
if|if
condition|(
name|cb
operator|->
name|zstr
operator|.
name|avail_out
operator|!=
name|BUFFER_DATA_SIZE
condition|)
name|buf_output
argument_list|(
name|cb
operator|->
name|buf
argument_list|,
name|buffer
argument_list|,
name|BUFFER_DATA_SIZE
operator|-
name|cb
operator|->
name|zstr
operator|.
name|avail_out
argument_list|)
expr_stmt|;
block|}
operator|*
name|wrote
operator|=
name|have
expr_stmt|;
comment|/* We will only be here because buf_send_output was called on the        compression buffer.  That means that we should now call        buf_send_output on the underlying buffer.  */
return|return
name|buf_send_output
argument_list|(
name|cb
operator|->
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Flush a compression buffer.  */
end_comment

begin_function
specifier|static
name|int
name|compress_buffer_flush
parameter_list|(
name|closure
parameter_list|)
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|struct
name|compress_buffer
modifier|*
name|cb
init|=
operator|(
expr|struct
name|compress_buffer
operator|*
operator|)
name|closure
decl_stmt|;
name|cb
operator|->
name|zstr
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|zstr
operator|.
name|next_in
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|char
name|buffer
index|[
name|BUFFER_DATA_SIZE
index|]
decl_stmt|;
name|int
name|zstatus
decl_stmt|;
name|cb
operator|->
name|zstr
operator|.
name|avail_out
operator|=
name|BUFFER_DATA_SIZE
expr_stmt|;
name|cb
operator|->
name|zstr
operator|.
name|next_out
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buffer
expr_stmt|;
name|zstatus
operator|=
name|deflate
argument_list|(
operator|&
name|cb
operator|->
name|zstr
argument_list|,
name|Z_SYNC_FLUSH
argument_list|)
expr_stmt|;
comment|/* The deflate function will return Z_BUF_ERROR if it can't do            anything, which in this case means that all data has been            flushed.  */
if|if
condition|(
name|zstatus
operator|==
name|Z_BUF_ERROR
condition|)
break|break;
if|if
condition|(
name|zstatus
operator|!=
name|Z_OK
condition|)
block|{
name|compress_error
argument_list|(
literal|0
argument_list|,
name|zstatus
argument_list|,
operator|&
name|cb
operator|->
name|zstr
argument_list|,
literal|"deflate flush"
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
if|if
condition|(
name|cb
operator|->
name|zstr
operator|.
name|avail_out
operator|!=
name|BUFFER_DATA_SIZE
condition|)
name|buf_output
argument_list|(
name|cb
operator|->
name|buf
argument_list|,
name|buffer
argument_list|,
name|BUFFER_DATA_SIZE
operator|-
name|cb
operator|->
name|zstr
operator|.
name|avail_out
argument_list|)
expr_stmt|;
comment|/* If the deflate function did not fill the output buffer,            then all data has been flushed.  */
if|if
condition|(
name|cb
operator|->
name|zstr
operator|.
name|avail_out
operator|>
literal|0
condition|)
break|break;
block|}
comment|/* Now flush the underlying buffer.  Note that if the original        call to buf_flush passed 1 for the BLOCK argument, then the        buffer will already have been set into blocking mode, so we        should always pass 0 here.  */
return|return
name|buf_flush
argument_list|(
name|cb
operator|->
name|buf
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The block routine for a compression buffer.  */
end_comment

begin_function
specifier|static
name|int
name|compress_buffer_block
parameter_list|(
name|closure
parameter_list|,
name|block
parameter_list|)
name|void
modifier|*
name|closure
decl_stmt|;
name|int
name|block
decl_stmt|;
block|{
name|struct
name|compress_buffer
modifier|*
name|cb
init|=
operator|(
expr|struct
name|compress_buffer
operator|*
operator|)
name|closure
decl_stmt|;
if|if
condition|(
name|block
condition|)
return|return
name|set_block
argument_list|(
name|cb
operator|->
name|buf
argument_list|)
return|;
else|else
return|return
name|set_nonblock
argument_list|(
name|cb
operator|->
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Shut down an input buffer.  */
end_comment

begin_function
specifier|static
name|int
name|compress_buffer_shutdown_input
parameter_list|(
name|closure
parameter_list|)
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|struct
name|compress_buffer
modifier|*
name|cb
init|=
operator|(
expr|struct
name|compress_buffer
operator|*
operator|)
name|closure
decl_stmt|;
name|int
name|zstatus
decl_stmt|;
comment|/* Pick up any trailing data, such as the checksum.  */
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|status
decl_stmt|,
name|nread
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|status
operator|=
name|compress_buffer_input
argument_list|(
name|cb
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
operator|&
name|nread
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|status
return|;
block|}
name|zstatus
operator|=
name|inflateEnd
argument_list|(
operator|&
name|cb
operator|->
name|zstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|zstatus
operator|!=
name|Z_OK
condition|)
block|{
name|compress_error
argument_list|(
literal|0
argument_list|,
name|zstatus
argument_list|,
operator|&
name|cb
operator|->
name|zstr
argument_list|,
literal|"inflateEnd"
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
return|return
name|buf_shutdown
argument_list|(
name|cb
operator|->
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Shut down an output buffer.  */
end_comment

begin_function
specifier|static
name|int
name|compress_buffer_shutdown_output
parameter_list|(
name|closure
parameter_list|)
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|struct
name|compress_buffer
modifier|*
name|cb
init|=
operator|(
expr|struct
name|compress_buffer
operator|*
operator|)
name|closure
decl_stmt|;
name|int
name|zstatus
decl_stmt|,
name|status
decl_stmt|;
do|do
block|{
name|char
name|buffer
index|[
name|BUFFER_DATA_SIZE
index|]
decl_stmt|;
name|cb
operator|->
name|zstr
operator|.
name|avail_out
operator|=
name|BUFFER_DATA_SIZE
expr_stmt|;
name|cb
operator|->
name|zstr
operator|.
name|next_out
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buffer
expr_stmt|;
name|zstatus
operator|=
name|deflate
argument_list|(
operator|&
name|cb
operator|->
name|zstr
argument_list|,
name|Z_FINISH
argument_list|)
expr_stmt|;
if|if
condition|(
name|zstatus
operator|!=
name|Z_OK
operator|&&
name|zstatus
operator|!=
name|Z_STREAM_END
condition|)
block|{
name|compress_error
argument_list|(
literal|0
argument_list|,
name|zstatus
argument_list|,
operator|&
name|cb
operator|->
name|zstr
argument_list|,
literal|"deflate finish"
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
if|if
condition|(
name|cb
operator|->
name|zstr
operator|.
name|avail_out
operator|!=
name|BUFFER_DATA_SIZE
condition|)
name|buf_output
argument_list|(
name|cb
operator|->
name|buf
argument_list|,
name|buffer
argument_list|,
name|BUFFER_DATA_SIZE
operator|-
name|cb
operator|->
name|zstr
operator|.
name|avail_out
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|zstatus
operator|!=
name|Z_STREAM_END
condition|)
do|;
name|zstatus
operator|=
name|deflateEnd
argument_list|(
operator|&
name|cb
operator|->
name|zstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|zstatus
operator|!=
name|Z_OK
condition|)
block|{
name|compress_error
argument_list|(
literal|0
argument_list|,
name|zstatus
argument_list|,
operator|&
name|cb
operator|->
name|zstr
argument_list|,
literal|"deflateEnd"
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
name|status
operator|=
name|buf_flush
argument_list|(
name|cb
operator|->
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|status
return|;
return|return
name|buf_shutdown
argument_list|(
name|cb
operator|->
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Here is our librarified gzip implementation.  It is very minimal    but attempts to be RFC1952 compliant.  */
end_comment

begin_comment
comment|/* Note that currently only the client uses the gzip library.  If we    make the server use it too (which should be straightforward), then    filter_stream_through_program, filter_through_gzip, and    filter_through_gunzip can go away.  */
end_comment

begin_comment
comment|/* BUF should contain SIZE bytes of gzipped data (RFC1952/RFC1951).    We are to uncompress the data and write the result to the file    descriptor FD.  If something goes wrong, give an error message    mentioning FULLNAME as the name of the file for FD (and make it a    fatal error if we can't recover from it).  */
end_comment

begin_function
name|void
name|gunzip_and_write
parameter_list|(
name|fd
parameter_list|,
name|fullname
parameter_list|,
name|buf
parameter_list|,
name|size
parameter_list|)
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|fullname
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
name|size_t
name|pos
decl_stmt|;
name|z_stream
name|zstr
decl_stmt|;
name|int
name|zstatus
decl_stmt|;
name|unsigned
name|char
name|outbuf
index|[
literal|32768
index|]
decl_stmt|;
name|unsigned
name|long
name|crc
decl_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|31
operator|||
name|buf
index|[
literal|1
index|]
operator|!=
literal|139
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"gzipped data does not start with gzip identification"
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|2
index|]
operator|!=
literal|8
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"only the deflate compression method is supported"
argument_list|)
expr_stmt|;
comment|/* Skip over the fixed header, and then skip any of the variable-length        fields.  */
name|pos
operator|=
literal|10
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|3
index|]
operator|&
literal|4
condition|)
name|pos
operator|+=
name|buf
index|[
name|pos
index|]
operator|+
operator|(
name|buf
index|[
name|pos
operator|+
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|3
index|]
operator|&
literal|8
condition|)
name|pos
operator|+=
name|strlen
argument_list|(
name|buf
operator|+
name|pos
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|3
index|]
operator|&
literal|16
condition|)
name|pos
operator|+=
name|strlen
argument_list|(
name|buf
operator|+
name|pos
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|3
index|]
operator|&
literal|2
condition|)
name|pos
operator|+=
literal|2
expr_stmt|;
name|memset
argument_list|(
operator|&
name|zstr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|zstr
argument_list|)
expr_stmt|;
comment|/* Passing a negative argument tells zlib not to look for a zlib        (RFC1950) header.  This is an undocumented feature; I suppose if        we wanted to be anal we could synthesize a header instead,        but why bother?  */
name|zstatus
operator|=
name|inflateInit2
argument_list|(
operator|&
name|zstr
argument_list|,
operator|-
literal|15
argument_list|)
expr_stmt|;
if|if
condition|(
name|zstatus
operator|!=
name|Z_OK
condition|)
name|compress_error
argument_list|(
literal|1
argument_list|,
name|zstatus
argument_list|,
operator|&
name|zstr
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
comment|/* I don't see why we should have to include the 8 byte trailer in        avail_in.  But I see that zlib/gzio.c does, and it seemed to fix        a fairly rare bug in which we'd get a Z_BUF_ERROR for no obvious        reason.  */
name|zstr
operator|.
name|avail_in
operator|=
name|size
operator|-
name|pos
expr_stmt|;
name|zstr
operator|.
name|next_in
operator|=
name|buf
operator|+
name|pos
expr_stmt|;
name|crc
operator|=
name|crc32
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
do|do
block|{
name|zstr
operator|.
name|avail_out
operator|=
sizeof|sizeof
argument_list|(
name|outbuf
argument_list|)
expr_stmt|;
name|zstr
operator|.
name|next_out
operator|=
name|outbuf
expr_stmt|;
name|zstatus
operator|=
name|inflate
argument_list|(
operator|&
name|zstr
argument_list|,
name|Z_NO_FLUSH
argument_list|)
expr_stmt|;
if|if
condition|(
name|zstatus
operator|!=
name|Z_STREAM_END
operator|&&
name|zstatus
operator|!=
name|Z_OK
condition|)
name|compress_error
argument_list|(
literal|1
argument_list|,
name|zstatus
argument_list|,
operator|&
name|zstr
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|outbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|outbuf
argument_list|)
operator|-
name|zstr
operator|.
name|avail_out
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"writing decompressed file %s"
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
name|crc
operator|=
name|crc32
argument_list|(
name|crc
argument_list|,
name|outbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|outbuf
argument_list|)
operator|-
name|zstr
operator|.
name|avail_out
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|zstatus
operator|!=
name|Z_STREAM_END
condition|)
do|;
name|zstatus
operator|=
name|inflateEnd
argument_list|(
operator|&
name|zstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|zstatus
operator|!=
name|Z_OK
condition|)
name|compress_error
argument_list|(
literal|0
argument_list|,
name|zstatus
argument_list|,
operator|&
name|zstr
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
if|if
condition|(
name|crc
operator|!=
operator|(
name|buf
index|[
name|zstr
operator|.
name|total_in
operator|+
literal|10
index|]
operator|+
operator|(
name|buf
index|[
name|zstr
operator|.
name|total_in
operator|+
literal|11
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|buf
index|[
name|zstr
operator|.
name|total_in
operator|+
literal|12
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|buf
index|[
name|zstr
operator|.
name|total_in
operator|+
literal|13
index|]
operator|<<
literal|24
operator|)
operator|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"CRC error uncompressing %s"
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
if|if
condition|(
name|zstr
operator|.
name|total_out
operator|!=
operator|(
name|buf
index|[
name|zstr
operator|.
name|total_in
operator|+
literal|14
index|]
operator|+
operator|(
name|buf
index|[
name|zstr
operator|.
name|total_in
operator|+
literal|15
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|buf
index|[
name|zstr
operator|.
name|total_in
operator|+
literal|16
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|buf
index|[
name|zstr
operator|.
name|total_in
operator|+
literal|17
index|]
operator|<<
literal|24
operator|)
operator|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"invalid length uncompressing %s"
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read all of FD and put the gzipped data (RFC1952/RFC1951) into *BUF,    replacing previous contents of *BUF.  *BUF is malloc'd and *SIZE is    its allocated size.  Put the actual number of bytes of data in    *LEN.  If something goes wrong, give an error message mentioning    FULLNAME as the name of the file for FD (and make it a fatal error    if we can't recover from it).  LEVEL is the compression level (1-9).  */
end_comment

begin_function
name|void
name|read_and_gzip
parameter_list|(
name|fd
parameter_list|,
name|fullname
parameter_list|,
name|buf
parameter_list|,
name|size
parameter_list|,
name|len
parameter_list|,
name|level
parameter_list|)
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|fullname
decl_stmt|;
name|unsigned
name|char
modifier|*
modifier|*
name|buf
decl_stmt|;
name|size_t
modifier|*
name|size
decl_stmt|;
name|size_t
modifier|*
name|len
decl_stmt|;
name|int
name|level
decl_stmt|;
block|{
name|z_stream
name|zstr
decl_stmt|;
name|int
name|zstatus
decl_stmt|;
name|unsigned
name|char
name|inbuf
index|[
literal|8192
index|]
decl_stmt|;
name|int
name|nread
decl_stmt|;
name|unsigned
name|long
name|crc
decl_stmt|;
if|if
condition|(
operator|*
name|size
operator|<
literal|1024
condition|)
block|{
operator|*
name|size
operator|=
literal|1024
expr_stmt|;
operator|*
name|buf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
operator|*
name|buf
argument_list|,
operator|*
name|size
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|buf
operator|)
index|[
literal|0
index|]
operator|=
literal|31
expr_stmt|;
operator|(
operator|*
name|buf
operator|)
index|[
literal|1
index|]
operator|=
literal|139
expr_stmt|;
operator|(
operator|*
name|buf
operator|)
index|[
literal|2
index|]
operator|=
literal|8
expr_stmt|;
operator|(
operator|*
name|buf
operator|)
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|buf
operator|)
index|[
literal|4
index|]
operator|=
operator|(
operator|*
name|buf
operator|)
index|[
literal|5
index|]
operator|=
operator|(
operator|*
name|buf
operator|)
index|[
literal|6
index|]
operator|=
operator|(
operator|*
name|buf
operator|)
index|[
literal|7
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Could set this based on level, but why bother?  */
operator|(
operator|*
name|buf
operator|)
index|[
literal|8
index|]
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|buf
operator|)
index|[
literal|9
index|]
operator|=
literal|255
expr_stmt|;
name|memset
argument_list|(
operator|&
name|zstr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|zstr
argument_list|)
expr_stmt|;
name|zstatus
operator|=
name|deflateInit2
argument_list|(
operator|&
name|zstr
argument_list|,
name|level
argument_list|,
name|Z_DEFLATED
argument_list|,
operator|-
literal|15
argument_list|,
literal|8
argument_list|,
name|Z_DEFAULT_STRATEGY
argument_list|)
expr_stmt|;
name|crc
operator|=
name|crc32
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|zstatus
operator|!=
name|Z_OK
condition|)
name|compress_error
argument_list|(
literal|1
argument_list|,
name|zstatus
argument_list|,
operator|&
name|zstr
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
name|zstr
operator|.
name|avail_out
operator|=
operator|*
name|size
expr_stmt|;
name|zstr
operator|.
name|next_out
operator|=
operator|*
name|buf
operator|+
literal|10
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|finish
init|=
literal|0
decl_stmt|;
name|nread
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|inbuf
argument_list|,
sizeof|sizeof
name|inbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nread
operator|==
literal|0
condition|)
comment|/* End of file.  */
name|finish
operator|=
literal|1
expr_stmt|;
name|crc
operator|=
name|crc32
argument_list|(
name|crc
argument_list|,
name|inbuf
argument_list|,
name|nread
argument_list|)
expr_stmt|;
name|zstr
operator|.
name|next_in
operator|=
name|inbuf
expr_stmt|;
name|zstr
operator|.
name|avail_in
operator|=
name|nread
expr_stmt|;
do|do
block|{
name|size_t
name|offset
decl_stmt|;
comment|/* I don't see this documented anywhere, but deflate seems 	       to tend to dump core sometimes if we pass it Z_FINISH and 	       a small (e.g. 2147 byte) avail_out.  So we insist on at 	       least 4096 bytes (that is what zlib/gzio.c uses).  */
if|if
condition|(
name|zstr
operator|.
name|avail_out
operator|<
literal|4096
condition|)
block|{
name|offset
operator|=
name|zstr
operator|.
name|next_out
operator|-
operator|*
name|buf
expr_stmt|;
operator|*
name|size
operator|*=
literal|2
expr_stmt|;
operator|*
name|buf
operator|=
name|xrealloc
argument_list|(
operator|*
name|buf
argument_list|,
operator|*
name|size
argument_list|)
expr_stmt|;
name|zstr
operator|.
name|next_out
operator|=
operator|*
name|buf
operator|+
name|offset
expr_stmt|;
name|zstr
operator|.
name|avail_out
operator|=
operator|*
name|size
operator|-
name|offset
expr_stmt|;
block|}
name|zstatus
operator|=
name|deflate
argument_list|(
operator|&
name|zstr
argument_list|,
name|finish
condition|?
name|Z_FINISH
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|zstatus
operator|==
name|Z_STREAM_END
condition|)
goto|goto
name|done
goto|;
elseif|else
if|if
condition|(
name|zstatus
operator|!=
name|Z_OK
condition|)
name|compress_error
argument_list|(
literal|0
argument_list|,
name|zstatus
argument_list|,
operator|&
name|zstr
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|zstr
operator|.
name|avail_out
operator|==
literal|0
condition|)
do|;
block|}
name|done
label|:
operator|*
operator|(
operator|*
name|buf
operator|+
name|zstr
operator|.
name|total_out
operator|+
literal|10
operator|)
operator|=
name|crc
operator|&
literal|0xff
expr_stmt|;
operator|*
operator|(
operator|*
name|buf
operator|+
name|zstr
operator|.
name|total_out
operator|+
literal|11
operator|)
operator|=
operator|(
name|crc
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
operator|(
operator|*
name|buf
operator|+
name|zstr
operator|.
name|total_out
operator|+
literal|12
operator|)
operator|=
operator|(
name|crc
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
operator|(
operator|*
name|buf
operator|+
name|zstr
operator|.
name|total_out
operator|+
literal|13
operator|)
operator|=
operator|(
name|crc
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
operator|(
operator|*
name|buf
operator|+
name|zstr
operator|.
name|total_out
operator|+
literal|14
operator|)
operator|=
name|zstr
operator|.
name|total_in
operator|&
literal|0xff
expr_stmt|;
operator|*
operator|(
operator|*
name|buf
operator|+
name|zstr
operator|.
name|total_out
operator|+
literal|15
operator|)
operator|=
operator|(
name|zstr
operator|.
name|total_in
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
operator|(
operator|*
name|buf
operator|+
name|zstr
operator|.
name|total_out
operator|+
literal|16
operator|)
operator|=
operator|(
name|zstr
operator|.
name|total_in
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
operator|(
operator|*
name|buf
operator|+
name|zstr
operator|.
name|total_out
operator|+
literal|17
operator|)
operator|=
operator|(
name|zstr
operator|.
name|total_in
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
name|len
operator|=
name|zstr
operator|.
name|total_out
operator|+
literal|18
expr_stmt|;
name|zstatus
operator|=
name|deflateEnd
argument_list|(
operator|&
name|zstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|zstatus
operator|!=
name|Z_OK
condition|)
name|compress_error
argument_list|(
literal|0
argument_list|,
name|zstatus
argument_list|,
operator|&
name|zstr
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined (SERVER_SUPPORT) || defined (CLIENT_SUPPORT) */
end_comment

end_unit

