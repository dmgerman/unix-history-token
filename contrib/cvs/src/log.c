begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  * Copyright (c) 1989-1992, Brian Berliner  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS source distribution.  *   * Print Log Information  *   * Prints the RCS "log" (rlog) information for the specified files.  With no  * argument, prints the log information for all the files in the directory  * (recursive by default).  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_comment
comment|/* This structure holds information parsed from the -r option.  */
end_comment

begin_struct
struct|struct
name|option_revlist
block|{
comment|/* The next -r option.  */
name|struct
name|option_revlist
modifier|*
name|next
decl_stmt|;
comment|/* The first revision to print.  This is NULL if the range is        :rev, or if no revision is given.  */
name|char
modifier|*
name|first
decl_stmt|;
comment|/* The last revision to print.  This is NULL if the range is rev:,        or if no revision is given.  If there is no colon, first and        last are the same.  */
name|char
modifier|*
name|last
decl_stmt|;
comment|/* Nonzero if there was a trailing `.', which means to print only        the head revision of a branch.  */
name|int
name|branchhead
decl_stmt|;
comment|/* Nonzero if first and last are inclusive.  */
name|int
name|inclusive
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This structure holds information derived from option_revlist given    a particular RCS file.  */
end_comment

begin_struct
struct|struct
name|revlist
block|{
comment|/* The next pair.  */
name|struct
name|revlist
modifier|*
name|next
decl_stmt|;
comment|/* The first numeric revision to print.  */
name|char
modifier|*
name|first
decl_stmt|;
comment|/* The last numeric revision to print.  */
name|char
modifier|*
name|last
decl_stmt|;
comment|/* The number of fields in these revisions (one more than        numdots).  */
name|int
name|fields
decl_stmt|;
comment|/* Whether first& last are to be included or excluded.  */
name|int
name|inclusive
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This structure holds information parsed from the -d option.  */
end_comment

begin_struct
struct|struct
name|datelist
block|{
comment|/* The next date.  */
name|struct
name|datelist
modifier|*
name|next
decl_stmt|;
comment|/* The starting date.  */
name|char
modifier|*
name|start
decl_stmt|;
comment|/* The ending date.  */
name|char
modifier|*
name|end
decl_stmt|;
comment|/* Nonzero if the range is inclusive rather than exclusive.  */
name|int
name|inclusive
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This structure is used to pass information through start_recursion.  */
end_comment

begin_struct
struct|struct
name|log_data
block|{
comment|/* Nonzero if the -R option was given, meaning that only the name        of the RCS file should be printed.  */
name|int
name|nameonly
decl_stmt|;
comment|/* Nonzero if the -h option was given, meaning that only header        information should be printed.  */
name|int
name|header
decl_stmt|;
comment|/* Nonzero if the -t option was given, meaning that only the        header and the descriptive text should be printed.  */
name|int
name|long_header
decl_stmt|;
comment|/* Nonzero if the -N option was seen, meaning that tag information        should not be printed.  */
name|int
name|notags
decl_stmt|;
comment|/* Nonzero if the -b option was seen, meaning that only revisions        on the default branch should be printed.  */
name|int
name|default_branch
decl_stmt|;
comment|/* Nonzero if the -S option was seen, meaning that the header/name        should be suppressed if no revisions are selected.  */
name|int
name|sup_header
decl_stmt|;
comment|/* If not NULL, the value given for the -r option, which lists        sets of revisions to be printed.  */
name|struct
name|option_revlist
modifier|*
name|revlist
decl_stmt|;
comment|/* If not NULL, the date pairs given for the -d option, which        select date ranges to print.  */
name|struct
name|datelist
modifier|*
name|datelist
decl_stmt|;
comment|/* If not NULL, the single dates given for the -d option, which        select specific revisions to print based on a date.  */
name|struct
name|datelist
modifier|*
name|singledatelist
decl_stmt|;
comment|/* If not NULL, the list of states given for the -s option, which        only prints revisions of given states.  */
name|List
modifier|*
name|statelist
decl_stmt|;
comment|/* If not NULL, the list of login names given for the -w option,        which only prints revisions checked in by given users.  */
name|List
modifier|*
name|authorlist
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This structure is used to pass information through walklist.  */
end_comment

begin_struct
struct|struct
name|log_data_and_rcs
block|{
name|struct
name|log_data
modifier|*
name|log_data
decl_stmt|;
name|struct
name|revlist
modifier|*
name|revlist
decl_stmt|;
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|rlog_proc
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|,
name|char
operator|*
name|xwhere
operator|,
name|char
operator|*
name|mwhere
operator|,
name|char
operator|*
name|mfile
operator|,
name|int
name|shorten
operator|,
name|int
name|local_specified
operator|,
name|char
operator|*
name|mname
operator|,
name|char
operator|*
name|msg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Dtype
name|log_dirproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
name|char
operator|*
name|dir
operator|,
name|char
operator|*
name|repository
operator|,
name|char
operator|*
name|update_dir
operator|,
name|List
operator|*
name|entries
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|log_fileproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
expr|struct
name|file_info
operator|*
name|finfo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|option_revlist
modifier|*
name|log_parse_revlist
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|log_parse_date
name|PROTO
argument_list|(
operator|(
expr|struct
name|log_data
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|log_parse_list
name|PROTO
argument_list|(
operator|(
name|List
operator|*
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|revlist
modifier|*
name|log_expand_revlist
name|PROTO
argument_list|(
operator|(
name|RCSNode
operator|*
operator|,
expr|struct
name|option_revlist
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|log_free_revlist
name|PROTO
argument_list|(
operator|(
expr|struct
name|revlist
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|log_version_requested
name|PROTO
argument_list|(
operator|(
expr|struct
name|log_data
operator|*
operator|,
expr|struct
name|revlist
operator|*
operator|,
name|RCSNode
operator|*
operator|,
name|RCSVers
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|log_symbol
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|log_count
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|log_fix_singledate
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|log_count_print
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|log_tree
name|PROTO
argument_list|(
operator|(
expr|struct
name|log_data
operator|*
operator|,
expr|struct
name|revlist
operator|*
operator|,
name|RCSNode
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|log_abranch
name|PROTO
argument_list|(
operator|(
expr|struct
name|log_data
operator|*
operator|,
expr|struct
name|revlist
operator|*
operator|,
name|RCSNode
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|log_version
name|PROTO
argument_list|(
operator|(
expr|struct
name|log_data
operator|*
operator|,
expr|struct
name|revlist
operator|*
operator|,
name|RCSNode
operator|*
operator|,
name|RCSVers
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|log_branch
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|version_compare
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|log_data
name|log_data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_rlog
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|log_usage
index|[]
init|=
block|{
literal|"Usage: %s %s [-lRhtNb] [-r[revisions]] [-d dates] [-s states]\n"
block|,
literal|"    [-w[logins]] [files...]\n"
block|,
literal|"\t-l\tLocal directory only, no recursion.\n"
block|,
literal|"\t-R\tOnly print name of RCS file.\n"
block|,
literal|"\t-h\tOnly print header.\n"
block|,
literal|"\t-t\tOnly print header and descriptive text.\n"
block|,
literal|"\t-N\tDo not list tags.\n"
block|,
literal|"\t-S\tDo not print name/header if no revisions selected.\n"
block|,
literal|"\t-b\tOnly list revisions on the default branch.\n"
block|,
literal|"\t-r[revisions]\tA comma-separated list of revisions to print:\n"
block|,
literal|"\t   rev1:rev2   Between rev1 and rev2, including rev1 and rev2.\n"
block|,
literal|"\t   rev1::rev2  Between rev1 and rev2, excluding rev1.\n"
block|,
literal|"\t   rev:        rev and following revisions on the same branch.\n"
block|,
literal|"\t   rev::       After rev on the same branch.\n"
block|,
literal|"\t   :rev        rev and previous revisions on the same branch.\n"
block|,
literal|"\t   ::rev       rev and previous revisions on the same branch.\n"
block|,
literal|"\t   rev         Just rev.\n"
block|,
literal|"\t   branch      All revisions on the branch.\n"
block|,
literal|"\t   branch.     The last revision on the branch.\n"
block|,
literal|"\t-d dates\tA semicolon-separated list of dates\n"
block|,
literal|"\t        \t(D1<D2 for range, D for latest before).\n"
block|,
literal|"\t-s states\tOnly list revisions with specified states.\n"
block|,
literal|"\t-w[logins]\tOnly list revisions checked in by specified logins.\n"
block|,
literal|"(Specify the --help global option for a list of other help options)\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
end_ifdef

begin_comment
comment|/* Helper function for send_arg_list.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|send_one
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|send_one
parameter_list|(
name|node
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|node
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|char
modifier|*
name|option
init|=
operator|(
name|char
operator|*
operator|)
name|closure
decl_stmt|;
name|send_to_server
argument_list|(
literal|"Argument "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|node
operator|->
name|key
argument_list|,
literal|"@@MYSELF"
argument_list|)
operator|==
literal|0
condition|)
comment|/* It is a bare -w option.  Note that we must send it as 	   -w rather than messing with getcaller() or something (which on 	   the client will return garbage).  */
empty_stmt|;
else|else
name|send_to_server
argument_list|(
name|node
operator|->
name|key
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* For each element in ARG, send an argument consisting of OPTION    concatenated with that element.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|send_arg_list
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|List
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|send_arg_list
parameter_list|(
name|option
parameter_list|,
name|arg
parameter_list|)
name|char
modifier|*
name|option
decl_stmt|;
name|List
modifier|*
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
return|return;
name|walklist
argument_list|(
name|arg
argument_list|,
name|send_one
argument_list|,
operator|(
name|void
operator|*
operator|)
name|option
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|cvslog
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|local
init|=
literal|0
decl_stmt|;
name|struct
name|option_revlist
modifier|*
modifier|*
name|prl
decl_stmt|;
name|is_rlog
operator|=
operator|(
name|strcmp
argument_list|(
name|command_name
argument_list|,
literal|"rlog"
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
operator|-
literal|1
condition|)
name|usage
argument_list|(
name|log_usage
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|log_data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|log_data
argument_list|)
expr_stmt|;
name|prl
operator|=
operator|&
name|log_data
operator|.
name|revlist
expr_stmt|;
name|optind
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"+bd:hlNSRr::s:tw::"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'b'
case|:
name|log_data
operator|.
name|default_branch
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|log_parse_date
argument_list|(
operator|&
name|log_data
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|log_data
operator|.
name|header
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|local
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|log_data
operator|.
name|notags
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|log_data
operator|.
name|sup_header
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|log_data
operator|.
name|nameonly
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
operator|*
name|prl
operator|=
name|log_parse_revlist
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|prl
operator|=
operator|&
operator|(
operator|*
name|prl
operator|)
operator|->
name|next
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|log_parse_list
argument_list|(
operator|&
name|log_data
operator|.
name|statelist
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|log_data
operator|.
name|long_header
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
if|if
condition|(
name|optarg
operator|!=
name|NULL
condition|)
name|log_parse_list
argument_list|(
operator|&
name|log_data
operator|.
name|authorlist
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
else|else
name|log_parse_list
argument_list|(
operator|&
name|log_data
operator|.
name|authorlist
argument_list|,
literal|"@@MYSELF"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
name|log_usage
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
name|wrap_setup
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
if|if
condition|(
name|current_parsed_root
operator|->
name|isremote
condition|)
block|{
name|struct
name|datelist
modifier|*
name|p
decl_stmt|;
name|struct
name|option_revlist
modifier|*
name|rp
decl_stmt|;
name|char
name|datetmp
index|[
name|MAXDATELEN
index|]
decl_stmt|;
comment|/* We're the local client.  Fire up the remote server.  */
name|start_server
argument_list|()
expr_stmt|;
if|if
condition|(
name|is_rlog
operator|&&
operator|!
name|supported_request
argument_list|(
literal|"rlog"
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"server does not support rlog"
argument_list|)
expr_stmt|;
name|ign_setup
argument_list|()
expr_stmt|;
if|if
condition|(
name|log_data
operator|.
name|default_branch
condition|)
name|send_arg
argument_list|(
literal|"-b"
argument_list|)
expr_stmt|;
while|while
condition|(
name|log_data
operator|.
name|datelist
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|log_data
operator|.
name|datelist
expr_stmt|;
name|log_data
operator|.
name|datelist
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|send_to_server
argument_list|(
literal|"Argument -d\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"Argument "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|date_to_internet
argument_list|(
name|datetmp
argument_list|,
name|p
operator|->
name|start
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|datetmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|inclusive
condition|)
name|send_to_server
argument_list|(
literal|"<="
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|send_to_server
argument_list|(
literal|"<"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|date_to_internet
argument_list|(
name|datetmp
argument_list|,
name|p
operator|->
name|end
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|datetmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|start
condition|)
name|free
argument_list|(
name|p
operator|->
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|end
condition|)
name|free
argument_list|(
name|p
operator|->
name|end
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|log_data
operator|.
name|singledatelist
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|log_data
operator|.
name|singledatelist
expr_stmt|;
name|log_data
operator|.
name|singledatelist
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|send_to_server
argument_list|(
literal|"Argument -d\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"Argument "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|date_to_internet
argument_list|(
name|datetmp
argument_list|,
name|p
operator|->
name|end
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
name|datetmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|end
condition|)
name|free
argument_list|(
name|p
operator|->
name|end
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|log_data
operator|.
name|header
condition|)
name|send_arg
argument_list|(
literal|"-h"
argument_list|)
expr_stmt|;
if|if
condition|(
name|local
condition|)
name|send_arg
argument_list|(
literal|"-l"
argument_list|)
expr_stmt|;
if|if
condition|(
name|log_data
operator|.
name|notags
condition|)
name|send_arg
argument_list|(
literal|"-N"
argument_list|)
expr_stmt|;
if|if
condition|(
name|log_data
operator|.
name|sup_header
condition|)
name|send_arg
argument_list|(
literal|"-S"
argument_list|)
expr_stmt|;
if|if
condition|(
name|log_data
operator|.
name|nameonly
condition|)
name|send_arg
argument_list|(
literal|"-R"
argument_list|)
expr_stmt|;
if|if
condition|(
name|log_data
operator|.
name|long_header
condition|)
name|send_arg
argument_list|(
literal|"-t"
argument_list|)
expr_stmt|;
while|while
condition|(
name|log_data
operator|.
name|revlist
operator|!=
name|NULL
condition|)
block|{
name|rp
operator|=
name|log_data
operator|.
name|revlist
expr_stmt|;
name|log_data
operator|.
name|revlist
operator|=
name|rp
operator|->
name|next
expr_stmt|;
name|send_to_server
argument_list|(
literal|"Argument -r"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|branchhead
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|first
operator|!=
name|NULL
condition|)
name|send_to_server
argument_list|(
name|rp
operator|->
name|first
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"."
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rp
operator|->
name|first
operator|!=
name|NULL
condition|)
name|send_to_server
argument_list|(
name|rp
operator|->
name|first
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|":"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rp
operator|->
name|inclusive
condition|)
name|send_to_server
argument_list|(
literal|":"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|last
operator|!=
name|NULL
condition|)
name|send_to_server
argument_list|(
name|rp
operator|->
name|last
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|send_to_server
argument_list|(
literal|"\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|first
condition|)
name|free
argument_list|(
name|rp
operator|->
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|last
condition|)
name|free
argument_list|(
name|rp
operator|->
name|last
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
name|send_arg_list
argument_list|(
literal|"-s"
argument_list|,
name|log_data
operator|.
name|statelist
argument_list|)
expr_stmt|;
name|dellist
argument_list|(
operator|&
name|log_data
operator|.
name|statelist
argument_list|)
expr_stmt|;
name|send_arg_list
argument_list|(
literal|"-w"
argument_list|,
name|log_data
operator|.
name|authorlist
argument_list|)
expr_stmt|;
name|dellist
argument_list|(
operator|&
name|log_data
operator|.
name|authorlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_rlog
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
name|send_arg
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"rlog\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|send_files
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
literal|0
argument_list|,
name|SEND_NO_CONTENTS
argument_list|)
expr_stmt|;
name|send_file_names
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|SEND_EXPAND_WILD
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"log\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|get_responses_and_close
argument_list|()
expr_stmt|;
return|return
name|err
return|;
block|}
endif|#
directive|endif
comment|/* OK, now that we know we are local/server, we can resolve @@MYSELF        into our user name.  */
if|if
condition|(
name|findnode
argument_list|(
name|log_data
operator|.
name|authorlist
argument_list|,
literal|"@@MYSELF"
argument_list|)
operator|!=
name|NULL
condition|)
name|log_parse_list
argument_list|(
operator|&
name|log_data
operator|.
name|authorlist
argument_list|,
name|getcaller
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_rlog
condition|)
block|{
name|DBM
modifier|*
name|db
decl_stmt|;
name|int
name|i
decl_stmt|;
name|db
operator|=
name|open_module
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|err
operator|+=
name|do_module
argument_list|(
name|db
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|MISC
argument_list|,
literal|"Logging"
argument_list|,
name|rlog_proc
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|local
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|close_module
argument_list|(
name|db
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|rlog_proc
argument_list|(
name|argc
operator|+
literal|1
argument_list|,
name|argv
operator|-
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|local
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|log_data
operator|.
name|revlist
condition|)
block|{
name|struct
name|option_revlist
modifier|*
name|rl
init|=
name|log_data
operator|.
name|revlist
operator|->
name|next
decl_stmt|;
if|if
condition|(
name|log_data
operator|.
name|revlist
operator|->
name|first
condition|)
name|free
argument_list|(
name|log_data
operator|.
name|revlist
operator|->
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|log_data
operator|.
name|revlist
operator|->
name|last
condition|)
name|free
argument_list|(
name|log_data
operator|.
name|revlist
operator|->
name|last
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|log_data
operator|.
name|revlist
argument_list|)
expr_stmt|;
name|log_data
operator|.
name|revlist
operator|=
name|rl
expr_stmt|;
block|}
while|while
condition|(
name|log_data
operator|.
name|datelist
condition|)
block|{
name|struct
name|datelist
modifier|*
name|nd
init|=
name|log_data
operator|.
name|datelist
operator|->
name|next
decl_stmt|;
if|if
condition|(
name|log_data
operator|.
name|datelist
operator|->
name|start
condition|)
name|free
argument_list|(
name|log_data
operator|.
name|datelist
operator|->
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|log_data
operator|.
name|datelist
operator|->
name|end
condition|)
name|free
argument_list|(
name|log_data
operator|.
name|datelist
operator|->
name|end
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|log_data
operator|.
name|datelist
argument_list|)
expr_stmt|;
name|log_data
operator|.
name|datelist
operator|=
name|nd
expr_stmt|;
block|}
while|while
condition|(
name|log_data
operator|.
name|singledatelist
condition|)
block|{
name|struct
name|datelist
modifier|*
name|nd
init|=
name|log_data
operator|.
name|singledatelist
operator|->
name|next
decl_stmt|;
if|if
condition|(
name|log_data
operator|.
name|singledatelist
operator|->
name|start
condition|)
name|free
argument_list|(
name|log_data
operator|.
name|singledatelist
operator|->
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|log_data
operator|.
name|singledatelist
operator|->
name|end
condition|)
name|free
argument_list|(
name|log_data
operator|.
name|singledatelist
operator|->
name|end
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|log_data
operator|.
name|singledatelist
argument_list|)
expr_stmt|;
name|log_data
operator|.
name|singledatelist
operator|=
name|nd
expr_stmt|;
block|}
name|dellist
argument_list|(
operator|&
name|log_data
operator|.
name|statelist
argument_list|)
expr_stmt|;
name|dellist
argument_list|(
operator|&
name|log_data
operator|.
name|authorlist
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rlog_proc
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|xwhere
parameter_list|,
name|mwhere
parameter_list|,
name|mfile
parameter_list|,
name|shorten
parameter_list|,
name|local
parameter_list|,
name|mname
parameter_list|,
name|msg
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|xwhere
decl_stmt|;
name|char
modifier|*
name|mwhere
decl_stmt|;
name|char
modifier|*
name|mfile
decl_stmt|;
name|int
name|shorten
decl_stmt|;
name|int
name|local
decl_stmt|;
name|char
modifier|*
name|mname
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
block|{
comment|/* Begin section which is identical to patch_proc--should this        be abstracted out somehow?  */
name|char
modifier|*
name|myargv
index|[
literal|2
index|]
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|which
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|where
decl_stmt|;
if|if
condition|(
name|is_rlog
condition|)
block|{
name|repository
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|current_parsed_root
operator|->
name|directory
argument_list|)
operator|+
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|+
operator|(
name|mfile
operator|==
name|NULL
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|mfile
argument_list|)
operator|+
literal|1
operator|)
operator|+
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|repository
argument_list|,
literal|"%s/%s"
argument_list|,
name|current_parsed_root
operator|->
name|directory
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|where
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|+
operator|(
name|mfile
operator|==
name|NULL
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|mfile
argument_list|)
operator|+
literal|1
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|where
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* if mfile isn't null, we need to set up to do only part of the module */
if|if
condition|(
name|mfile
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
comment|/* if the portion of the module is a path, put the dir part on repos */
if|if
condition|(
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|mfile
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|repository
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|repository
argument_list|,
name|mfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|where
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|where
argument_list|,
name|mfile
argument_list|)
expr_stmt|;
name|mfile
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
block|}
comment|/* take care of the rest */
name|path
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|repository
argument_list|)
operator|+
name|strlen
argument_list|(
name|mfile
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|path
argument_list|,
literal|"%s/%s"
argument_list|,
name|repository
argument_list|,
name|mfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdir
argument_list|(
name|path
argument_list|)
condition|)
block|{
comment|/* directory means repository gets the dir tacked on */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|repository
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|where
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|where
argument_list|,
name|mfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|myargv
index|[
literal|0
index|]
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|myargv
index|[
literal|1
index|]
operator|=
name|mfile
expr_stmt|;
name|argc
operator|=
literal|2
expr_stmt|;
name|argv
operator|=
name|myargv
expr_stmt|;
block|}
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
comment|/* cd to the starting repository */
if|if
condition|(
name|CVS_CHDIR
argument_list|(
name|repository
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot chdir to %s"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repository
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|free
argument_list|(
name|repository
argument_list|)
expr_stmt|;
comment|/* End section which is identical to patch_proc.  */
name|which
operator|=
name|W_REPOS
operator||
name|W_ATTIC
expr_stmt|;
block|}
else|else
block|{
name|where
operator|=
name|NULL
expr_stmt|;
name|which
operator|=
name|W_LOCAL
operator||
name|W_REPOS
operator||
name|W_ATTIC
expr_stmt|;
block|}
name|err
operator|=
name|start_recursion
argument_list|(
name|log_fileproc
argument_list|,
operator|(
name|FILESDONEPROC
operator|)
name|NULL
argument_list|,
name|log_dirproc
argument_list|,
operator|(
name|DIRLEAVEPROC
operator|)
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|log_data
argument_list|,
name|argc
operator|-
literal|1
argument_list|,
name|argv
operator|+
literal|1
argument_list|,
name|local
argument_list|,
name|which
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|where
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/*  * Parse a revision list specification.  */
end_comment

begin_function
specifier|static
name|struct
name|option_revlist
modifier|*
name|log_parse_revlist
parameter_list|(
name|argstring
parameter_list|)
specifier|const
name|char
modifier|*
name|argstring
decl_stmt|;
block|{
name|char
modifier|*
name|orig_copy
decl_stmt|,
modifier|*
name|copy
decl_stmt|;
name|struct
name|option_revlist
modifier|*
name|ret
decl_stmt|,
modifier|*
modifier|*
name|pr
decl_stmt|;
comment|/* Unfortunately, rlog accepts -r without an argument to mean that        latest revision on the default branch, so we must support that        for compatibility.  */
if|if
condition|(
name|argstring
operator|==
name|NULL
condition|)
name|argstring
operator|=
literal|""
expr_stmt|;
name|ret
operator|=
name|NULL
expr_stmt|;
name|pr
operator|=
operator|&
name|ret
expr_stmt|;
comment|/* Copy the argument into memory so that we can change it.  We        don't want to change the argument because, at least as of this        writing, we will use it if we send the arguments to the server.  */
name|orig_copy
operator|=
name|copy
operator|=
name|xstrdup
argument_list|(
name|argstring
argument_list|)
expr_stmt|;
while|while
condition|(
name|copy
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|comma
decl_stmt|;
name|struct
name|option_revlist
modifier|*
name|r
decl_stmt|;
name|comma
operator|=
name|strchr
argument_list|(
name|copy
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|comma
operator|!=
name|NULL
condition|)
operator|*
name|comma
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|r
operator|=
operator|(
expr|struct
name|option_revlist
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|r
argument_list|)
expr_stmt|;
name|r
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|r
operator|->
name|first
operator|=
name|copy
expr_stmt|;
name|r
operator|->
name|branchhead
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|last
operator|=
name|strchr
argument_list|(
name|copy
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|last
operator|!=
name|NULL
condition|)
block|{
operator|*
name|r
operator|->
name|last
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|r
operator|->
name|inclusive
operator|=
operator|(
operator|*
name|r
operator|->
name|last
operator|!=
literal|':'
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
operator|->
name|inclusive
condition|)
name|r
operator|->
name|last
operator|++
expr_stmt|;
block|}
else|else
block|{
name|r
operator|->
name|last
operator|=
name|r
operator|->
name|first
expr_stmt|;
name|r
operator|->
name|inclusive
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|first
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|r
operator|->
name|first
index|[
name|strlen
argument_list|(
name|r
operator|->
name|first
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
name|r
operator|->
name|branchhead
operator|=
literal|1
expr_stmt|;
name|r
operator|->
name|first
index|[
name|strlen
argument_list|(
name|r
operator|->
name|first
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|r
operator|->
name|first
operator|==
literal|'\0'
condition|)
name|r
operator|->
name|first
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|r
operator|->
name|last
operator|==
literal|'\0'
condition|)
name|r
operator|->
name|last
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|first
operator|!=
name|NULL
condition|)
name|r
operator|->
name|first
operator|=
name|xstrdup
argument_list|(
name|r
operator|->
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|last
operator|!=
name|NULL
condition|)
name|r
operator|->
name|last
operator|=
name|xstrdup
argument_list|(
name|r
operator|->
name|last
argument_list|)
expr_stmt|;
operator|*
name|pr
operator|=
name|r
expr_stmt|;
name|pr
operator|=
operator|&
name|r
operator|->
name|next
expr_stmt|;
name|copy
operator|=
name|comma
expr_stmt|;
block|}
name|free
argument_list|(
name|orig_copy
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Parse a date specification.  */
end_comment

begin_function
specifier|static
name|void
name|log_parse_date
parameter_list|(
name|log_data
parameter_list|,
name|argstring
parameter_list|)
name|struct
name|log_data
modifier|*
name|log_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|argstring
decl_stmt|;
block|{
name|char
modifier|*
name|orig_copy
decl_stmt|,
modifier|*
name|copy
decl_stmt|;
comment|/* Copy the argument into memory so that we can change it.  We        don't want to change the argument because, at least as of this        writing, we will use it if we send the arguments to the server.  */
name|orig_copy
operator|=
name|copy
operator|=
name|xstrdup
argument_list|(
name|argstring
argument_list|)
expr_stmt|;
while|while
condition|(
name|copy
operator|!=
name|NULL
condition|)
block|{
name|struct
name|datelist
modifier|*
name|nd
decl_stmt|,
modifier|*
modifier|*
name|pd
decl_stmt|;
name|char
modifier|*
name|cpend
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ds
decl_stmt|,
modifier|*
name|de
decl_stmt|;
name|nd
operator|=
operator|(
expr|struct
name|datelist
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|nd
argument_list|)
expr_stmt|;
name|cpend
operator|=
name|strchr
argument_list|(
name|copy
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpend
operator|!=
name|NULL
condition|)
operator|*
name|cpend
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|pd
operator|=
operator|&
name|log_data
operator|->
name|datelist
expr_stmt|;
name|nd
operator|->
name|inclusive
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|copy
argument_list|,
literal|'>'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'='
condition|)
block|{
operator|++
name|cp
expr_stmt|;
name|nd
operator|->
name|inclusive
operator|=
literal|1
expr_stmt|;
block|}
name|ds
operator|=
name|cp
expr_stmt|;
name|de
operator|=
name|copy
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|copy
argument_list|,
literal|'<'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'='
condition|)
block|{
operator|++
name|cp
expr_stmt|;
name|nd
operator|->
name|inclusive
operator|=
literal|1
expr_stmt|;
block|}
name|ds
operator|=
name|copy
expr_stmt|;
name|de
operator|=
name|cp
expr_stmt|;
block|}
else|else
block|{
name|ds
operator|=
name|NULL
expr_stmt|;
name|de
operator|=
name|copy
expr_stmt|;
name|pd
operator|=
operator|&
name|log_data
operator|->
name|singledatelist
expr_stmt|;
block|}
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
name|nd
operator|->
name|start
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|ds
operator|!=
literal|'\0'
condition|)
name|nd
operator|->
name|start
operator|=
name|Make_Date
argument_list|(
name|ds
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* 1970 was the beginning of time, as far as get_date and 	     Make_Date are concerned.  FIXME: That is true only if time_t 	     is a POSIX-style time and there is nothing in ANSI that 	     mandates that.  It would be cleaner to set a flag saying 	     whether or not there is a start date.  */
name|nd
operator|->
name|start
operator|=
name|Make_Date
argument_list|(
literal|"1/1/1970 UTC"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|de
operator|!=
literal|'\0'
condition|)
name|nd
operator|->
name|end
operator|=
name|Make_Date
argument_list|(
name|de
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* We want to set the end date to some time sufficiently far 	       in the future to pick up all revisions that have been 	       created since the specified date and the time `cvs log' 	       completes.  FIXME: The date in question only makes sense 	       if time_t is a POSIX-style time and it is 32 bits 	       and signed.  We should instead be setting a flag saying 	       whether or not there is an end date.  Note that using 	       something like "next week" would break the testsuite (and, 	       perhaps less importantly, loses if the clock is set grossly 	       wrong).  */
name|nd
operator|->
name|end
operator|=
name|Make_Date
argument_list|(
literal|"2038-01-01"
argument_list|)
expr_stmt|;
block|}
name|nd
operator|->
name|next
operator|=
operator|*
name|pd
expr_stmt|;
operator|*
name|pd
operator|=
name|nd
expr_stmt|;
name|copy
operator|=
name|cpend
expr_stmt|;
block|}
name|free
argument_list|(
name|orig_copy
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Parse a comma separated list of items, and add each one to *PLIST.  */
end_comment

begin_function
specifier|static
name|void
name|log_parse_list
parameter_list|(
name|plist
parameter_list|,
name|argstring
parameter_list|)
name|List
modifier|*
modifier|*
name|plist
decl_stmt|;
specifier|const
name|char
modifier|*
name|argstring
decl_stmt|;
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|argstring
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|argstring
argument_list|)
expr_stmt|;
else|else
block|{
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|cp
operator|-
name|argstring
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|p
operator|->
name|key
argument_list|,
name|argstring
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|key
index|[
name|len
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|plist
operator|==
name|NULL
condition|)
operator|*
name|plist
operator|=
name|getlist
argument_list|()
expr_stmt|;
if|if
condition|(
name|addnode
argument_list|(
operator|*
name|plist
argument_list|,
name|p
argument_list|)
operator|!=
literal|0
condition|)
name|freenode
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
break|break;
name|argstring
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|printlock_proc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|printlock_proc
parameter_list|(
name|lock
parameter_list|,
name|foo
parameter_list|)
name|Node
modifier|*
name|lock
decl_stmt|;
name|void
modifier|*
name|foo
decl_stmt|;
block|{
name|cvs_output
argument_list|(
literal|"\n\t"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|lock
operator|->
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|": "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|lock
operator|->
name|key
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Do an rlog on a file  */
end_comment

begin_function
specifier|static
name|int
name|log_fileproc
parameter_list|(
name|callerdat
parameter_list|,
name|finfo
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
block|{
name|struct
name|log_data
modifier|*
name|log_data
init|=
operator|(
expr|struct
name|log_data
operator|*
operator|)
name|callerdat
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
name|int
name|selrev
init|=
operator|-
literal|1
decl_stmt|;
name|RCSNode
modifier|*
name|rcsfile
decl_stmt|;
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|;
name|struct
name|revlist
modifier|*
name|revlist
decl_stmt|;
name|struct
name|log_data_and_rcs
name|log_data_and_rcs
decl_stmt|;
if|if
condition|(
operator|(
name|rcsfile
operator|=
name|finfo
operator|->
name|rcs
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* no rcs file.  What *do* we know about this file? */
name|p
operator|=
name|findnode
argument_list|(
name|finfo
operator|->
name|entries
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|Entnode
modifier|*
name|e
decl_stmt|;
name|e
operator|=
operator|(
name|Entnode
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|version
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
name|e
operator|->
name|version
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|!
name|really_quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s has been added, but not committed"
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|!
name|really_quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"nothing known about %s"
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|log_data
operator|->
name|sup_header
operator|||
operator|!
name|log_data
operator|->
name|nameonly
condition|)
block|{
comment|/* We will need all the information in the RCS file.  */
name|RCS_fully_parse
argument_list|(
name|rcsfile
argument_list|)
expr_stmt|;
comment|/* Turn any symbolic revisions in the revision list into numeric 	   revisions.  */
name|revlist
operator|=
name|log_expand_revlist
argument_list|(
name|rcsfile
argument_list|,
name|log_data
operator|->
name|revlist
argument_list|,
name|log_data
operator|->
name|default_branch
argument_list|)
expr_stmt|;
if|if
condition|(
name|log_data
operator|->
name|sup_header
operator|||
operator|(
operator|!
name|log_data
operator|->
name|header
operator|&&
operator|!
name|log_data
operator|->
name|long_header
operator|)
condition|)
block|{
name|log_data_and_rcs
operator|.
name|log_data
operator|=
name|log_data
expr_stmt|;
name|log_data_and_rcs
operator|.
name|revlist
operator|=
name|revlist
expr_stmt|;
name|log_data_and_rcs
operator|.
name|rcs
operator|=
name|rcsfile
expr_stmt|;
comment|/* If any single dates were specified, we need to identify the 	       revisions they select.  Each one selects the single 	       revision, which is otherwise selected, of that date or 	       earlier.  The log_fix_singledate routine will fill in the 	       start date for each specific revision.  */
if|if
condition|(
name|log_data
operator|->
name|singledatelist
operator|!=
name|NULL
condition|)
name|walklist
argument_list|(
name|rcsfile
operator|->
name|versions
argument_list|,
name|log_fix_singledate
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|log_data_and_rcs
argument_list|)
expr_stmt|;
name|selrev
operator|=
name|walklist
argument_list|(
name|rcsfile
operator|->
name|versions
argument_list|,
name|log_count_print
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|log_data_and_rcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|log_data
operator|->
name|sup_header
operator|&&
name|selrev
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|log_data
operator|->
name|nameonly
condition|)
block|{
name|cvs_output
argument_list|(
name|rcsfile
operator|->
name|path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* The output here is intended to be exactly compatible with the        output of rlog.  I'm not sure whether this code should be here        or in rcs.c; I put it here because it is specific to the log        function, even though it uses information gathered by the        functions in rcs.c.  */
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"RCS file: "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|rcsfile
operator|->
name|path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_rlog
condition|)
block|{
name|cvs_output
argument_list|(
literal|"\nWorking file: "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|finfo
operator|->
name|update_dir
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|cvs_output
argument_list|(
name|finfo
operator|->
name|update_dir
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"/"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|cvs_output
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|cvs_output
argument_list|(
literal|"\nhead:"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcsfile
operator|->
name|head
operator|!=
name|NULL
condition|)
block|{
name|cvs_output
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|rcsfile
operator|->
name|head
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|cvs_output
argument_list|(
literal|"\nbranch:"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcsfile
operator|->
name|branch
operator|!=
name|NULL
condition|)
block|{
name|cvs_output
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|rcsfile
operator|->
name|branch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|cvs_output
argument_list|(
literal|"\nlocks:"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcsfile
operator|->
name|strict_locks
condition|)
name|cvs_output
argument_list|(
literal|" strict"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|walklist
argument_list|(
name|RCS_getlocks
argument_list|(
name|rcsfile
argument_list|)
argument_list|,
name|printlock_proc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\naccess list:"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcsfile
operator|->
name|access
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|rcsfile
operator|->
name|access
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
specifier|const
name|char
modifier|*
name|cp2
decl_stmt|;
name|cvs_output
argument_list|(
literal|"\n\t"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cp2
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp2
argument_list|)
operator|&&
operator|*
name|cp2
operator|!=
literal|'\0'
condition|)
operator|++
name|cp2
expr_stmt|;
name|cvs_output
argument_list|(
name|cp
argument_list|,
name|cp2
operator|-
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|cp2
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
operator|++
name|cp
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|log_data
operator|->
name|notags
condition|)
block|{
name|List
modifier|*
name|syms
decl_stmt|;
name|cvs_output
argument_list|(
literal|"\nsymbolic names:"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|syms
operator|=
name|RCS_symbols
argument_list|(
name|rcsfile
argument_list|)
expr_stmt|;
name|walklist
argument_list|(
name|syms
argument_list|,
name|log_symbol
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|cvs_output
argument_list|(
literal|"\nkeyword substitution: "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcsfile
operator|->
name|expand
operator|==
name|NULL
condition|)
name|cvs_output
argument_list|(
literal|"kv"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|else
name|cvs_output
argument_list|(
name|rcsfile
operator|->
name|expand
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|"\ntotal revisions: "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|walklist
argument_list|(
name|rcsfile
operator|->
name|versions
argument_list|,
name|log_count
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|selrev
operator|>=
literal|0
condition|)
block|{
name|cvs_output
argument_list|(
literal|";\tselected revisions: "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|selrev
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|log_data
operator|->
name|header
operator|||
name|log_data
operator|->
name|long_header
condition|)
block|{
name|cvs_output
argument_list|(
literal|"description:\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcsfile
operator|->
name|desc
operator|!=
name|NULL
condition|)
name|cvs_output
argument_list|(
name|rcsfile
operator|->
name|desc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|log_data
operator|->
name|header
operator|&&
operator|!
name|log_data
operator|->
name|long_header
operator|&&
name|rcsfile
operator|->
name|head
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|findnode
argument_list|(
name|rcsfile
operator|->
name|versions
argument_list|,
name|rcsfile
operator|->
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"can not find head revision in `%s'"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|RCSVers
modifier|*
name|vers
decl_stmt|;
name|vers
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
name|log_version
argument_list|(
name|log_data
argument_list|,
name|revlist
argument_list|,
name|rcsfile
argument_list|,
name|vers
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|vers
operator|->
name|next
operator|==
name|NULL
condition|)
name|p
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|p
operator|=
name|findnode
argument_list|(
name|rcsfile
operator|->
name|versions
argument_list|,
name|vers
operator|->
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"can not find next revision `%s' in `%s'"
argument_list|,
name|vers
operator|->
name|next
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
block|}
block|}
name|log_tree
argument_list|(
name|log_data
argument_list|,
name|revlist
argument_list|,
name|rcsfile
argument_list|,
name|rcsfile
operator|->
name|head
argument_list|)
expr_stmt|;
block|}
name|cvs_output
argument_list|(
literal|"\ =============================================================================\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Free up the new revlist and restore the old one.  */
name|log_free_revlist
argument_list|(
name|revlist
argument_list|)
expr_stmt|;
comment|/* If singledatelist is not NULL, free up the start dates we added        to it.  */
if|if
condition|(
name|log_data
operator|->
name|singledatelist
operator|!=
name|NULL
condition|)
block|{
name|struct
name|datelist
modifier|*
name|d
decl_stmt|;
for|for
control|(
name|d
operator|=
name|log_data
operator|->
name|singledatelist
init|;
name|d
operator|!=
name|NULL
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
if|if
condition|(
name|d
operator|->
name|start
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|d
operator|->
name|start
argument_list|)
expr_stmt|;
name|d
operator|->
name|start
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Fix up a revision list in order to compare it against versions.  * Expand any symbolic revisions.  */
end_comment

begin_function
specifier|static
name|struct
name|revlist
modifier|*
name|log_expand_revlist
parameter_list|(
name|rcs
parameter_list|,
name|revlist
parameter_list|,
name|default_branch
parameter_list|)
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|struct
name|option_revlist
modifier|*
name|revlist
decl_stmt|;
name|int
name|default_branch
decl_stmt|;
block|{
name|struct
name|option_revlist
modifier|*
name|r
decl_stmt|;
name|struct
name|revlist
modifier|*
name|ret
decl_stmt|,
modifier|*
modifier|*
name|pr
decl_stmt|;
name|ret
operator|=
name|NULL
expr_stmt|;
name|pr
operator|=
operator|&
name|ret
expr_stmt|;
for|for
control|(
name|r
operator|=
name|revlist
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
block|{
name|struct
name|revlist
modifier|*
name|nr
decl_stmt|;
name|nr
operator|=
operator|(
expr|struct
name|revlist
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|nr
argument_list|)
expr_stmt|;
name|nr
operator|->
name|inclusive
operator|=
name|r
operator|->
name|inclusive
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|first
operator|==
name|NULL
operator|&&
name|r
operator|->
name|last
operator|==
name|NULL
condition|)
block|{
comment|/* If both first and last are NULL, it means that we want 	       just the head of the default branch, which is RCS_head.  */
name|nr
operator|->
name|first
operator|=
name|RCS_head
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
name|nr
operator|->
name|last
operator|=
name|xstrdup
argument_list|(
name|nr
operator|->
name|first
argument_list|)
expr_stmt|;
name|nr
operator|->
name|fields
operator|=
name|numdots
argument_list|(
name|nr
operator|->
name|first
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|->
name|branchhead
condition|)
block|{
name|char
modifier|*
name|branch
decl_stmt|;
comment|/* Print just the head of the branch.  */
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|r
operator|->
name|first
index|[
literal|0
index|]
argument_list|)
condition|)
name|nr
operator|->
name|first
operator|=
name|RCS_getbranch
argument_list|(
name|rcs
argument_list|,
name|r
operator|->
name|first
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|branch
operator|=
name|RCS_whatbranch
argument_list|(
name|rcs
argument_list|,
name|r
operator|->
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|branch
operator|==
name|NULL
condition|)
name|nr
operator|->
name|first
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|nr
operator|->
name|first
operator|=
name|RCS_getbranch
argument_list|(
name|rcs
argument_list|,
name|branch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|branch
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nr
operator|->
name|first
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: no branch `%s' in `%s'"
argument_list|,
name|r
operator|->
name|first
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|nr
operator|->
name|last
operator|=
name|NULL
expr_stmt|;
name|nr
operator|->
name|fields
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|nr
operator|->
name|last
operator|=
name|xstrdup
argument_list|(
name|nr
operator|->
name|first
argument_list|)
expr_stmt|;
name|nr
operator|->
name|fields
operator|=
name|numdots
argument_list|(
name|nr
operator|->
name|first
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|r
operator|->
name|first
operator|==
name|NULL
operator|||
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|r
operator|->
name|first
index|[
literal|0
index|]
argument_list|)
condition|)
name|nr
operator|->
name|first
operator|=
name|xstrdup
argument_list|(
name|r
operator|->
name|first
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|RCS_nodeisbranch
argument_list|(
name|rcs
argument_list|,
name|r
operator|->
name|first
argument_list|)
condition|)
name|nr
operator|->
name|first
operator|=
name|RCS_whatbranch
argument_list|(
name|rcs
argument_list|,
name|r
operator|->
name|first
argument_list|)
expr_stmt|;
else|else
name|nr
operator|->
name|first
operator|=
name|RCS_gettag
argument_list|(
name|rcs
argument_list|,
name|r
operator|->
name|first
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|nr
operator|->
name|first
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: no revision `%s' in `%s'"
argument_list|,
name|r
operator|->
name|first
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|r
operator|->
name|last
operator|==
name|r
operator|->
name|first
operator|||
operator|(
name|r
operator|->
name|last
operator|!=
name|NULL
operator|&&
name|r
operator|->
name|first
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|r
operator|->
name|last
argument_list|,
name|r
operator|->
name|first
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|nr
operator|->
name|last
operator|=
name|xstrdup
argument_list|(
name|nr
operator|->
name|first
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|last
operator|==
name|NULL
operator|||
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|r
operator|->
name|last
index|[
literal|0
index|]
argument_list|)
condition|)
name|nr
operator|->
name|last
operator|=
name|xstrdup
argument_list|(
name|r
operator|->
name|last
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|RCS_nodeisbranch
argument_list|(
name|rcs
argument_list|,
name|r
operator|->
name|last
argument_list|)
condition|)
name|nr
operator|->
name|last
operator|=
name|RCS_whatbranch
argument_list|(
name|rcs
argument_list|,
name|r
operator|->
name|last
argument_list|)
expr_stmt|;
else|else
name|nr
operator|->
name|last
operator|=
name|RCS_gettag
argument_list|(
name|rcs
argument_list|,
name|r
operator|->
name|last
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|nr
operator|->
name|last
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"warning: no revision `%s' in `%s'"
argument_list|,
name|r
operator|->
name|last
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Process the revision numbers the same way that rlog                does.  This code is a bit cryptic for my tastes, but                keeping the same implementation as rlog ensures a                certain degree of compatibility.  */
if|if
condition|(
name|r
operator|->
name|first
operator|==
name|NULL
operator|&&
name|nr
operator|->
name|last
operator|!=
name|NULL
condition|)
block|{
name|nr
operator|->
name|fields
operator|=
name|numdots
argument_list|(
name|nr
operator|->
name|last
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|nr
operator|->
name|fields
operator|<
literal|2
condition|)
name|nr
operator|->
name|first
operator|=
name|xstrdup
argument_list|(
literal|".0"
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|nr
operator|->
name|first
operator|=
name|xstrdup
argument_list|(
name|nr
operator|->
name|last
argument_list|)
expr_stmt|;
name|cp
operator|=
name|strrchr
argument_list|(
name|nr
operator|->
name|first
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cp
argument_list|,
literal|".0"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|r
operator|->
name|last
operator|==
name|NULL
operator|&&
name|nr
operator|->
name|first
operator|!=
name|NULL
condition|)
block|{
name|nr
operator|->
name|fields
operator|=
name|numdots
argument_list|(
name|nr
operator|->
name|first
argument_list|)
operator|+
literal|1
expr_stmt|;
name|nr
operator|->
name|last
operator|=
name|xstrdup
argument_list|(
name|nr
operator|->
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|nr
operator|->
name|fields
operator|<
literal|2
condition|)
name|nr
operator|->
name|last
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|strrchr
argument_list|(
name|nr
operator|->
name|last
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|nr
operator|->
name|first
operator|!=
name|NULL
operator|&&
name|nr
operator|->
name|last
operator|!=
name|NULL
condition|)
block|{
name|nr
operator|->
name|fields
operator|=
name|numdots
argument_list|(
name|nr
operator|->
name|first
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|nr
operator|->
name|fields
operator|!=
name|numdots
argument_list|(
name|nr
operator|->
name|last
argument_list|)
operator|+
literal|1
operator|||
operator|(
name|nr
operator|->
name|fields
operator|>
literal|2
operator|&&
name|version_compare
argument_list|(
name|nr
operator|->
name|first
argument_list|,
name|nr
operator|->
name|last
argument_list|,
name|nr
operator|->
name|fields
operator|-
literal|1
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"invalid branch or revision pair %s:%s in `%s'"
argument_list|,
name|r
operator|->
name|first
argument_list|,
name|r
operator|->
name|last
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nr
operator|->
name|first
argument_list|)
expr_stmt|;
name|nr
operator|->
name|first
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|nr
operator|->
name|last
argument_list|)
expr_stmt|;
name|nr
operator|->
name|last
operator|=
name|NULL
expr_stmt|;
name|nr
operator|->
name|fields
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|version_compare
argument_list|(
name|nr
operator|->
name|first
argument_list|,
name|nr
operator|->
name|last
argument_list|,
name|nr
operator|->
name|fields
argument_list|)
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
name|nr
operator|->
name|first
expr_stmt|;
name|nr
operator|->
name|first
operator|=
name|nr
operator|->
name|last
expr_stmt|;
name|nr
operator|->
name|last
operator|=
name|tmp
expr_stmt|;
block|}
block|}
else|else
name|nr
operator|->
name|fields
operator|=
literal|0
expr_stmt|;
block|}
name|nr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|pr
operator|=
name|nr
expr_stmt|;
name|pr
operator|=
operator|&
name|nr
operator|->
name|next
expr_stmt|;
block|}
comment|/* If the default branch was requested, add a revlist entry for        it.  This is how rlog handles this option.  */
if|if
condition|(
name|default_branch
operator|&&
operator|(
name|rcs
operator|->
name|head
operator|!=
name|NULL
operator|||
name|rcs
operator|->
name|branch
operator|!=
name|NULL
operator|)
condition|)
block|{
name|struct
name|revlist
modifier|*
name|nr
decl_stmt|;
name|nr
operator|=
operator|(
expr|struct
name|revlist
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|nr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcs
operator|->
name|branch
operator|!=
name|NULL
condition|)
name|nr
operator|->
name|first
operator|=
name|xstrdup
argument_list|(
name|rcs
operator|->
name|branch
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|nr
operator|->
name|first
operator|=
name|xstrdup
argument_list|(
name|rcs
operator|->
name|head
argument_list|)
expr_stmt|;
name|cp
operator|=
name|strrchr
argument_list|(
name|nr
operator|->
name|first
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
name|nr
operator|->
name|last
operator|=
name|xstrdup
argument_list|(
name|nr
operator|->
name|first
argument_list|)
expr_stmt|;
name|nr
operator|->
name|fields
operator|=
name|numdots
argument_list|(
name|nr
operator|->
name|first
argument_list|)
operator|+
literal|1
expr_stmt|;
name|nr
operator|->
name|inclusive
operator|=
literal|1
expr_stmt|;
name|nr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|pr
operator|=
name|nr
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Free a revlist created by log_expand_revlist.  */
end_comment

begin_function
specifier|static
name|void
name|log_free_revlist
parameter_list|(
name|revlist
parameter_list|)
name|struct
name|revlist
modifier|*
name|revlist
decl_stmt|;
block|{
name|struct
name|revlist
modifier|*
name|r
decl_stmt|;
name|r
operator|=
name|revlist
expr_stmt|;
while|while
condition|(
name|r
operator|!=
name|NULL
condition|)
block|{
name|struct
name|revlist
modifier|*
name|next
decl_stmt|;
if|if
condition|(
name|r
operator|->
name|first
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|r
operator|->
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|last
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|r
operator|->
name|last
argument_list|)
expr_stmt|;
name|next
operator|=
name|r
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|r
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Return nonzero if a revision should be printed, based on the  * options provided.  */
end_comment

begin_function
specifier|static
name|int
name|log_version_requested
parameter_list|(
name|log_data
parameter_list|,
name|revlist
parameter_list|,
name|rcs
parameter_list|,
name|vnode
parameter_list|)
name|struct
name|log_data
modifier|*
name|log_data
decl_stmt|;
name|struct
name|revlist
modifier|*
name|revlist
decl_stmt|;
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|RCSVers
modifier|*
name|vnode
decl_stmt|;
block|{
comment|/* Handle the list of states from the -s option.  */
if|if
condition|(
name|log_data
operator|->
name|statelist
operator|!=
name|NULL
operator|&&
name|findnode
argument_list|(
name|log_data
operator|->
name|statelist
argument_list|,
name|vnode
operator|->
name|state
argument_list|)
operator|==
name|NULL
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* Handle the list of authors from the -w option.  */
if|if
condition|(
name|log_data
operator|->
name|authorlist
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|vnode
operator|->
name|author
operator|!=
name|NULL
operator|&&
name|findnode
argument_list|(
name|log_data
operator|->
name|authorlist
argument_list|,
name|vnode
operator|->
name|author
argument_list|)
operator|==
name|NULL
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
comment|/* rlog considers all the -d options together when it decides        whether to print a revision, so we must be compatible.  */
if|if
condition|(
name|log_data
operator|->
name|datelist
operator|!=
name|NULL
operator|||
name|log_data
operator|->
name|singledatelist
operator|!=
name|NULL
condition|)
block|{
name|struct
name|datelist
modifier|*
name|d
decl_stmt|;
for|for
control|(
name|d
operator|=
name|log_data
operator|->
name|datelist
init|;
name|d
operator|!=
name|NULL
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
name|int
name|cmp
decl_stmt|;
name|cmp
operator|=
name|RCS_datecmp
argument_list|(
name|vnode
operator|->
name|date
argument_list|,
name|d
operator|->
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|>
literal|0
operator|||
operator|(
name|cmp
operator|==
literal|0
operator|&&
name|d
operator|->
name|inclusive
operator|)
condition|)
block|{
name|cmp
operator|=
name|RCS_datecmp
argument_list|(
name|vnode
operator|->
name|date
argument_list|,
name|d
operator|->
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
operator|||
operator|(
name|cmp
operator|==
literal|0
operator|&&
name|d
operator|->
name|inclusive
operator|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
block|{
comment|/* Look through the list of specific dates.  We want to 	       select the revision with the exact date found in the 	       start field.  The commit code ensures that it is 	       impossible to check in multiple revisions of a single 	       file in a single second, so checking the date this way 	       should never select more than one revision.  */
for|for
control|(
name|d
operator|=
name|log_data
operator|->
name|singledatelist
init|;
name|d
operator|!=
name|NULL
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
if|if
condition|(
name|d
operator|->
name|start
operator|!=
name|NULL
operator|&&
name|RCS_datecmp
argument_list|(
name|vnode
operator|->
name|date
argument_list|,
name|d
operator|->
name|start
argument_list|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
block|}
block|}
comment|/* If the -r or -b options were used, REVLIST will be non NULL,        and we print the union of the specified revisions.  */
if|if
condition|(
name|revlist
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|v
decl_stmt|;
name|int
name|vfields
decl_stmt|;
name|struct
name|revlist
modifier|*
name|r
decl_stmt|;
comment|/* This code is taken from rlog.  */
name|v
operator|=
name|vnode
operator|->
name|version
expr_stmt|;
name|vfields
operator|=
name|numdots
argument_list|(
name|v
argument_list|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|r
operator|=
name|revlist
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
block|{
if|if
condition|(
name|vfields
operator|==
name|r
operator|->
name|fields
operator|+
operator|(
name|r
operator|->
name|fields
operator|&
literal|1
operator|)
operator|&&
operator|(
name|r
operator|->
name|inclusive
condition|?
name|version_compare
argument_list|(
name|v
argument_list|,
name|r
operator|->
name|first
argument_list|,
name|r
operator|->
name|fields
argument_list|)
operator|>=
literal|0
else|:
name|version_compare
argument_list|(
name|v
argument_list|,
name|r
operator|->
name|first
argument_list|,
name|r
operator|->
name|fields
argument_list|)
operator|>
literal|0
operator|)
operator|&&
name|version_compare
argument_list|(
name|v
argument_list|,
name|r
operator|->
name|last
argument_list|,
name|r
operator|->
name|fields
argument_list|)
operator|<=
literal|0
condition|)
block|{
return|return
literal|1
return|;
block|}
block|}
comment|/* If we get here, then the -b and/or the -r option was used,            but did not match this revision, so we reject it.  */
return|return
literal|0
return|;
block|}
comment|/* By default, we print all revisions.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Output a single symbol.  This is called via walklist.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|log_symbol
parameter_list|(
name|p
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|cvs_output
argument_list|(
literal|"\n\t"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|p
operator|->
name|key
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|": "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|p
operator|->
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Count the number of entries on a list.  This is called via walklist.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|log_count
parameter_list|(
name|p
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Sort out a single date specification by narrowing down the date  * until we find the specific selected revision.  */
end_comment

begin_function
specifier|static
name|int
name|log_fix_singledate
parameter_list|(
name|p
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|struct
name|log_data_and_rcs
modifier|*
name|data
init|=
operator|(
expr|struct
name|log_data_and_rcs
operator|*
operator|)
name|closure
decl_stmt|;
name|Node
modifier|*
name|pv
decl_stmt|;
name|RCSVers
modifier|*
name|vnode
decl_stmt|;
name|struct
name|datelist
modifier|*
name|holdsingle
decl_stmt|,
modifier|*
name|holddate
decl_stmt|;
name|int
name|requested
decl_stmt|;
name|pv
operator|=
name|findnode
argument_list|(
name|data
operator|->
name|rcs
operator|->
name|versions
argument_list|,
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|pv
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"missing version `%s' in RCS file `%s'"
argument_list|,
name|p
operator|->
name|key
argument_list|,
name|data
operator|->
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|vnode
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|pv
operator|->
name|data
expr_stmt|;
comment|/* We are only interested if this revision passes any other tests.        Temporarily clear log_data->singledatelist to avoid confusing        log_version_requested.  We also clear log_data->datelist,        because rlog considers all the -d options together.  We don't        want to reject a revision because it does not match a date pair        if we are going to select it on the basis of the singledate.  */
name|holdsingle
operator|=
name|data
operator|->
name|log_data
operator|->
name|singledatelist
expr_stmt|;
name|data
operator|->
name|log_data
operator|->
name|singledatelist
operator|=
name|NULL
expr_stmt|;
name|holddate
operator|=
name|data
operator|->
name|log_data
operator|->
name|datelist
expr_stmt|;
name|data
operator|->
name|log_data
operator|->
name|datelist
operator|=
name|NULL
expr_stmt|;
name|requested
operator|=
name|log_version_requested
argument_list|(
name|data
operator|->
name|log_data
argument_list|,
name|data
operator|->
name|revlist
argument_list|,
name|data
operator|->
name|rcs
argument_list|,
name|vnode
argument_list|)
expr_stmt|;
name|data
operator|->
name|log_data
operator|->
name|singledatelist
operator|=
name|holdsingle
expr_stmt|;
name|data
operator|->
name|log_data
operator|->
name|datelist
operator|=
name|holddate
expr_stmt|;
if|if
condition|(
name|requested
condition|)
block|{
name|struct
name|datelist
modifier|*
name|d
decl_stmt|;
comment|/* For each single date, if this revision is before the 	   specified date, but is closer than the previously selected 	   revision, select it instead.  */
for|for
control|(
name|d
operator|=
name|data
operator|->
name|log_data
operator|->
name|singledatelist
init|;
name|d
operator|!=
name|NULL
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
block|{
if|if
condition|(
name|RCS_datecmp
argument_list|(
name|vnode
operator|->
name|date
argument_list|,
name|d
operator|->
name|end
argument_list|)
operator|<=
literal|0
operator|&&
operator|(
name|d
operator|->
name|start
operator|==
name|NULL
operator|||
name|RCS_datecmp
argument_list|(
name|vnode
operator|->
name|date
argument_list|,
name|d
operator|->
name|start
argument_list|)
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|start
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|d
operator|->
name|start
argument_list|)
expr_stmt|;
name|d
operator|->
name|start
operator|=
name|xstrdup
argument_list|(
name|vnode
operator|->
name|date
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Count the number of revisions we are going to print.  */
end_comment

begin_function
specifier|static
name|int
name|log_count_print
parameter_list|(
name|p
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|struct
name|log_data_and_rcs
modifier|*
name|data
init|=
operator|(
expr|struct
name|log_data_and_rcs
operator|*
operator|)
name|closure
decl_stmt|;
name|Node
modifier|*
name|pv
decl_stmt|;
name|pv
operator|=
name|findnode
argument_list|(
name|data
operator|->
name|rcs
operator|->
name|versions
argument_list|,
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|pv
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"missing version `%s' in RCS file `%s'"
argument_list|,
name|p
operator|->
name|key
argument_list|,
name|data
operator|->
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|log_version_requested
argument_list|(
name|data
operator|->
name|log_data
argument_list|,
name|data
operator|->
name|revlist
argument_list|,
name|data
operator|->
name|rcs
argument_list|,
operator|(
name|RCSVers
operator|*
operator|)
name|pv
operator|->
name|data
argument_list|)
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Print the list of changes, not including the trunk, in reverse  * order for each branch.  */
end_comment

begin_function
specifier|static
name|void
name|log_tree
parameter_list|(
name|log_data
parameter_list|,
name|revlist
parameter_list|,
name|rcs
parameter_list|,
name|ver
parameter_list|)
name|struct
name|log_data
modifier|*
name|log_data
decl_stmt|;
name|struct
name|revlist
modifier|*
name|revlist
decl_stmt|;
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
specifier|const
name|char
modifier|*
name|ver
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|RCSVers
modifier|*
name|vnode
decl_stmt|;
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|ver
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"missing version `%s' in RCS file `%s'"
argument_list|,
name|ver
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|vnode
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|vnode
operator|->
name|next
operator|!=
name|NULL
condition|)
name|log_tree
argument_list|(
name|log_data
argument_list|,
name|revlist
argument_list|,
name|rcs
argument_list|,
name|vnode
operator|->
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|vnode
operator|->
name|branches
operator|!=
name|NULL
condition|)
block|{
name|Node
modifier|*
name|head
decl_stmt|,
modifier|*
name|branch
decl_stmt|;
comment|/* We need to do the branches in reverse order.  This breaks            the List abstraction, but so does most of the branch            manipulation in rcs.c.  */
name|head
operator|=
name|vnode
operator|->
name|branches
operator|->
name|list
expr_stmt|;
for|for
control|(
name|branch
operator|=
name|head
operator|->
name|prev
init|;
name|branch
operator|!=
name|head
condition|;
name|branch
operator|=
name|branch
operator|->
name|prev
control|)
block|{
name|log_abranch
argument_list|(
name|log_data
argument_list|,
name|revlist
argument_list|,
name|rcs
argument_list|,
name|branch
operator|->
name|key
argument_list|)
expr_stmt|;
name|log_tree
argument_list|(
name|log_data
argument_list|,
name|revlist
argument_list|,
name|rcs
argument_list|,
name|branch
operator|->
name|key
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Log the changes for a branch, in reverse order.  */
end_comment

begin_function
specifier|static
name|void
name|log_abranch
parameter_list|(
name|log_data
parameter_list|,
name|revlist
parameter_list|,
name|rcs
parameter_list|,
name|ver
parameter_list|)
name|struct
name|log_data
modifier|*
name|log_data
decl_stmt|;
name|struct
name|revlist
modifier|*
name|revlist
decl_stmt|;
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
specifier|const
name|char
modifier|*
name|ver
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|RCSVers
modifier|*
name|vnode
decl_stmt|;
name|p
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|ver
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"missing version `%s' in RCS file `%s'"
argument_list|,
name|ver
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|vnode
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|vnode
operator|->
name|next
operator|!=
name|NULL
condition|)
name|log_abranch
argument_list|(
name|log_data
argument_list|,
name|revlist
argument_list|,
name|rcs
argument_list|,
name|vnode
operator|->
name|next
argument_list|)
expr_stmt|;
name|log_version
argument_list|(
name|log_data
argument_list|,
name|revlist
argument_list|,
name|rcs
argument_list|,
name|vnode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print the log output for a single version.  */
end_comment

begin_function
specifier|static
name|void
name|log_version
parameter_list|(
name|log_data
parameter_list|,
name|revlist
parameter_list|,
name|rcs
parameter_list|,
name|ver
parameter_list|,
name|trunk
parameter_list|)
name|struct
name|log_data
modifier|*
name|log_data
decl_stmt|;
name|struct
name|revlist
modifier|*
name|revlist
decl_stmt|;
name|RCSNode
modifier|*
name|rcs
decl_stmt|;
name|RCSVers
modifier|*
name|ver
decl_stmt|;
name|int
name|trunk
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|int
name|year
decl_stmt|,
name|mon
decl_stmt|,
name|mday
decl_stmt|,
name|hour
decl_stmt|,
name|min
decl_stmt|,
name|sec
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|Node
modifier|*
name|padd
decl_stmt|,
modifier|*
name|pdel
decl_stmt|;
if|if
condition|(
operator|!
name|log_version_requested
argument_list|(
name|log_data
argument_list|,
name|revlist
argument_list|,
name|rcs
argument_list|,
name|ver
argument_list|)
condition|)
return|return;
name|cvs_output
argument_list|(
literal|"----------------------------\nrevision "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|ver
operator|->
name|version
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|findnode
argument_list|(
name|RCS_getlocks
argument_list|(
name|rcs
argument_list|)
argument_list|,
name|ver
operator|->
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|cvs_output
argument_list|(
literal|"\tlocked by: "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|p
operator|->
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|";"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|cvs_output
argument_list|(
literal|"\ndate: "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sscanf
argument_list|(
name|ver
operator|->
name|date
argument_list|,
name|SDATEFORM
argument_list|,
operator|&
name|year
argument_list|,
operator|&
name|mon
argument_list|,
operator|&
name|mday
argument_list|,
operator|&
name|hour
argument_list|,
operator|&
name|min
argument_list|,
operator|&
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|year
operator|<
literal|1900
condition|)
name|year
operator|+=
literal|1900
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%04d/%02d/%02d %02d:%02d:%02d"
argument_list|,
name|year
argument_list|,
name|mon
argument_list|,
name|mday
argument_list|,
name|hour
argument_list|,
name|min
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|";  author: "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|ver
operator|->
name|author
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|";  state: "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|ver
operator|->
name|state
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|";"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|trunk
condition|)
block|{
name|padd
operator|=
name|findnode
argument_list|(
name|ver
operator|->
name|other
argument_list|,
literal|";add"
argument_list|)
expr_stmt|;
name|pdel
operator|=
name|findnode
argument_list|(
name|ver
operator|->
name|other
argument_list|,
literal|";delete"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ver
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
name|padd
operator|=
name|NULL
expr_stmt|;
name|pdel
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|Node
modifier|*
name|nextp
decl_stmt|;
name|RCSVers
modifier|*
name|nextver
decl_stmt|;
name|nextp
operator|=
name|findnode
argument_list|(
name|rcs
operator|->
name|versions
argument_list|,
name|ver
operator|->
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"missing version `%s' in `%s'"
argument_list|,
name|ver
operator|->
name|next
argument_list|,
name|rcs
operator|->
name|path
argument_list|)
expr_stmt|;
name|nextver
operator|=
operator|(
name|RCSVers
operator|*
operator|)
name|nextp
operator|->
name|data
expr_stmt|;
name|pdel
operator|=
name|findnode
argument_list|(
name|nextver
operator|->
name|other
argument_list|,
literal|";add"
argument_list|)
expr_stmt|;
name|padd
operator|=
name|findnode
argument_list|(
name|nextver
operator|->
name|other
argument_list|,
literal|";delete"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|padd
operator|!=
name|NULL
condition|)
block|{
name|cvs_output
argument_list|(
literal|"  lines: +"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|padd
operator|->
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
literal|" -"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cvs_output
argument_list|(
name|pdel
operator|->
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ver
operator|->
name|branches
operator|!=
name|NULL
condition|)
block|{
name|cvs_output
argument_list|(
literal|"\nbranches:"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|walklist
argument_list|(
name|ver
operator|->
name|branches
argument_list|,
name|log_branch
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|findnode
argument_list|(
name|ver
operator|->
name|other
argument_list|,
literal|"log"
argument_list|)
expr_stmt|;
comment|/* The p->date == NULL case is the normal one for an empty log        message (rcs-14 in sanity.sh).  I don't think the case where        p->data is "" can happen (getrcskey in rcs.c checks for an        empty string and set the value to NULL in that case).  My guess        would be the p == NULL case would mean an RCS file which was        missing the "log" keyword (which is illegal according to        rcsfile.5).  */
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|p
operator|->
name|data
operator|==
name|NULL
operator|||
name|p
operator|->
name|data
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|cvs_output
argument_list|(
literal|"*** empty log message ***\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* FIXME: Technically, the log message could contain a null            byte.  */
name|cvs_output
argument_list|(
name|p
operator|->
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|data
index|[
name|strlen
argument_list|(
name|p
operator|->
name|data
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Output a branch version.  This is called via walklist.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|log_branch
parameter_list|(
name|p
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|cvs_output
argument_list|(
literal|"  "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|numdots
argument_list|(
name|p
operator|->
name|key
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|cvs_output
argument_list|(
name|p
operator|->
name|key
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|f
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|f
operator|=
name|xstrdup
argument_list|(
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
name|cp
operator|=
name|strrchr
argument_list|(
name|f
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|cvs_output
argument_list|(
name|f
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
name|cvs_output
argument_list|(
literal|";"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Print a warm fuzzy message  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|Dtype
name|log_dirproc
parameter_list|(
name|callerdat
parameter_list|,
name|dir
parameter_list|,
name|repository
parameter_list|,
name|update_dir
parameter_list|,
name|entries
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|isdir
argument_list|(
name|dir
argument_list|)
condition|)
return|return
operator|(
name|R_SKIP_ALL
operator|)
return|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Logging %s"
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
return|return
operator|(
name|R_PROCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compare versions.  This is taken from RCS compartial.  */
end_comment

begin_function
specifier|static
name|int
name|version_compare
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|,
name|len
parameter_list|)
specifier|const
name|char
modifier|*
name|v1
decl_stmt|;
specifier|const
name|char
modifier|*
name|v2
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|d1
decl_stmt|,
name|d2
decl_stmt|,
name|r
decl_stmt|;
if|if
condition|(
operator|*
name|v1
operator|==
literal|'\0'
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|*
name|v2
operator|==
literal|'\0'
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
operator|*
name|v1
operator|==
literal|'0'
condition|)
operator|++
name|v1
expr_stmt|;
for|for
control|(
name|d1
operator|=
literal|0
init|;
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|v1
index|[
name|d1
index|]
argument_list|)
condition|;
operator|++
name|d1
control|)
empty_stmt|;
while|while
condition|(
operator|*
name|v2
operator|==
literal|'0'
condition|)
operator|++
name|v2
expr_stmt|;
for|for
control|(
name|d2
operator|=
literal|0
init|;
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|v2
index|[
name|d2
index|]
argument_list|)
condition|;
operator|++
name|d2
control|)
empty_stmt|;
if|if
condition|(
name|d1
operator|!=
name|d2
condition|)
return|return
name|d1
operator|<
name|d2
condition|?
operator|-
literal|1
else|:
literal|1
return|;
name|r
operator|=
name|memcmp
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|,
name|d1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
return|return
name|r
return|;
operator|--
name|len
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|v1
operator|+=
name|d1
expr_stmt|;
name|v2
operator|+=
name|d1
expr_stmt|;
if|if
condition|(
operator|*
name|v1
operator|==
literal|'.'
condition|)
operator|++
name|v1
expr_stmt|;
if|if
condition|(
operator|*
name|v2
operator|==
literal|'.'
condition|)
operator|++
name|v2
expr_stmt|;
block|}
block|}
end_function

end_unit

