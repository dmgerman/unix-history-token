begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Implementation for file attribute munging features.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"getline.h"
end_include

begin_include
include|#
directive|include
file|"fileattr.h"
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_decl_stmt
specifier|static
name|void
name|fileattr_read
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|writeattr_proc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Where to look for CVSREP_FILEATTR.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|fileattr_stored_repos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The in-memory attributes.  */
end_comment

begin_decl_stmt
specifier|static
name|List
modifier|*
name|attrlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|fileattr_default_attrs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We have already tried to read attributes and failed in this directory    (for example, there is no CVSREP_FILEATTR file).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|attr_read_attempted
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Have the in-memory attributes been modified since we read them?  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|attrs_modified
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* More in-memory attributes: linked list of unrecognized    fileattr lines.  We pass these on unchanged.  */
end_comment

begin_struct
struct|struct
name|unrecog
block|{
name|char
modifier|*
name|line
decl_stmt|;
name|struct
name|unrecog
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|unrecog
modifier|*
name|unrecog_head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Note that if noone calls fileattr_get, this is very cheap.  No stat(),    no open(), no nothing.  */
end_comment

begin_function
name|void
name|fileattr_startdir
parameter_list|(
name|repos
parameter_list|)
name|char
modifier|*
name|repos
decl_stmt|;
block|{
name|assert
argument_list|(
name|fileattr_stored_repos
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|fileattr_stored_repos
operator|=
name|xstrdup
argument_list|(
name|repos
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|attrlist
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|attr_read_attempted
operator|=
literal|0
expr_stmt|;
name|assert
argument_list|(
name|unrecog_head
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fileattr_delproc
parameter_list|(
name|node
parameter_list|)
name|Node
modifier|*
name|node
decl_stmt|;
block|{
name|assert
argument_list|(
name|node
operator|->
name|data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
operator|->
name|data
argument_list|)
expr_stmt|;
name|node
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read all the attributes for the current directory into memory.  */
end_comment

begin_function
specifier|static
name|void
name|fileattr_read
parameter_list|()
block|{
name|char
modifier|*
name|fname
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|line
init|=
name|NULL
decl_stmt|;
name|size_t
name|line_len
init|=
literal|0
decl_stmt|;
comment|/* If there are no attributes, don't waste time repeatedly looking        for the CVSREP_FILEATTR file.  */
if|if
condition|(
name|attr_read_attempted
condition|)
return|return;
comment|/* If NULL was passed to fileattr_startdir, then it isn't kosher to look        at attributes.  */
name|assert
argument_list|(
name|fileattr_stored_repos
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|fname
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|fileattr_stored_repos
argument_list|)
operator|+
literal|1
operator|+
sizeof|sizeof
argument_list|(
name|CVSREP_FILEATTR
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|fname
argument_list|,
name|fileattr_stored_repos
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|fname
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|fname
argument_list|,
name|CVSREP_FILEATTR
argument_list|)
expr_stmt|;
name|attr_read_attempted
operator|=
literal|1
expr_stmt|;
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|fname
argument_list|,
name|FOPEN_BINARY_READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
return|return;
block|}
name|attrlist
operator|=
name|getlist
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|nread
decl_stmt|;
name|nread
operator|=
name|getline
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|line_len
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|<
literal|0
condition|)
break|break;
comment|/* Remove trailing newline.  */
name|line
index|[
name|nread
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'F'
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|Node
modifier|*
name|newnode
decl_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|newnode
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|newnode
operator|->
name|type
operator|=
name|FILEATTR
expr_stmt|;
name|newnode
operator|->
name|delproc
operator|=
name|fileattr_delproc
expr_stmt|;
name|newnode
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|line
operator|+
literal|1
argument_list|)
expr_stmt|;
name|newnode
operator|->
name|data
operator|=
name|xstrdup
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|addnode
argument_list|(
name|attrlist
argument_list|,
name|newnode
argument_list|)
operator|!=
literal|0
condition|)
comment|/* If the same filename appears twice in the file, discard 		   any line other than the first for that filename.  This 		   is the way that CVS has behaved since file attributes 		   were first introduced.  */
name|free
argument_list|(
name|newnode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'D'
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Currently nothing to skip here, but for future expansion, 	       ignore anything located here.  */
name|p
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
operator|++
name|p
expr_stmt|;
name|fileattr_default_attrs
operator|=
name|xstrdup
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Unrecognized type, we want to just preserve the line without 	       changing it, for future expansion.  */
name|struct
name|unrecog
modifier|*
name|new
decl_stmt|;
name|new
operator|=
operator|(
expr|struct
name|unrecog
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|unrecog
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|line
operator|=
name|xstrdup
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|unrecog_head
expr_stmt|;
name|unrecog_head
operator|=
name|new
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|attrs_modified
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|fileattr_get
parameter_list|(
name|filename
parameter_list|,
name|attrname
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
specifier|const
name|char
modifier|*
name|attrname
decl_stmt|;
block|{
name|Node
modifier|*
name|node
decl_stmt|;
name|size_t
name|attrname_len
init|=
name|strlen
argument_list|(
name|attrname
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|attrlist
operator|==
name|NULL
condition|)
name|fileattr_read
argument_list|()
expr_stmt|;
if|if
condition|(
name|attrlist
operator|==
name|NULL
condition|)
comment|/* Either nothing has any attributes, or fileattr_read already printed 	   an error message.  */
return|return
name|NULL
return|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
name|p
operator|=
name|fileattr_default_attrs
expr_stmt|;
else|else
block|{
name|node
operator|=
name|findnode
argument_list|(
name|attrlist
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
comment|/* A file not mentioned has no attributes.  */
return|return
name|NULL
return|;
name|p
operator|=
name|node
operator|->
name|data
expr_stmt|;
block|}
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|attrname
argument_list|,
name|p
argument_list|,
name|attrname_len
argument_list|)
operator|==
literal|0
operator|&&
name|p
index|[
name|attrname_len
index|]
operator|==
literal|'='
condition|)
block|{
comment|/* Found it.  */
return|return
name|p
operator|+
name|attrname_len
operator|+
literal|1
return|;
block|}
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
break|break;
operator|++
name|p
expr_stmt|;
block|}
comment|/* The file doesn't have this attribute.  */
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|fileattr_get0
parameter_list|(
name|filename
parameter_list|,
name|attrname
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
specifier|const
name|char
modifier|*
name|attrname
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|cpend
decl_stmt|;
name|char
modifier|*
name|retval
decl_stmt|;
name|cp
operator|=
name|fileattr_get
argument_list|(
name|filename
argument_list|,
name|attrname
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|cpend
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpend
operator|==
name|NULL
condition|)
name|cpend
operator|=
name|cp
operator|+
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|retval
operator|=
name|xmalloc
argument_list|(
name|cpend
operator|-
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|retval
argument_list|,
name|cp
argument_list|,
name|cpend
operator|-
name|cp
argument_list|)
expr_stmt|;
name|retval
index|[
name|cpend
operator|-
name|cp
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|fileattr_modify
parameter_list|(
name|list
parameter_list|,
name|attrname
parameter_list|,
name|attrval
parameter_list|,
name|namevalsep
parameter_list|,
name|entsep
parameter_list|)
name|char
modifier|*
name|list
decl_stmt|;
specifier|const
name|char
modifier|*
name|attrname
decl_stmt|;
specifier|const
name|char
modifier|*
name|attrval
decl_stmt|;
name|int
name|namevalsep
decl_stmt|;
name|int
name|entsep
decl_stmt|;
block|{
name|char
modifier|*
name|retval
decl_stmt|;
name|char
modifier|*
name|rp
decl_stmt|;
name|size_t
name|attrname_len
init|=
name|strlen
argument_list|(
name|attrname
argument_list|)
decl_stmt|;
comment|/* Portion of list before the attribute to be replaced.  */
name|char
modifier|*
name|pre
decl_stmt|;
name|char
modifier|*
name|preend
decl_stmt|;
comment|/* Portion of list after the attribute to be replaced.  */
name|char
modifier|*
name|post
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|p2
decl_stmt|;
name|p
operator|=
name|list
expr_stmt|;
name|pre
operator|=
name|list
expr_stmt|;
name|preend
operator|=
name|NULL
expr_stmt|;
comment|/* post is NULL unless set otherwise.  */
name|post
operator|=
name|NULL
expr_stmt|;
name|p2
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|list
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|p2
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
name|entsep
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2
operator|==
name|NULL
condition|)
block|{
name|p2
operator|=
name|p
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|preend
operator|==
name|NULL
condition|)
name|preend
operator|=
name|p2
expr_stmt|;
block|}
else|else
operator|++
name|p2
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|attrname
argument_list|,
name|p
argument_list|,
name|attrname_len
argument_list|)
operator|==
literal|0
operator|&&
name|p
index|[
name|attrname_len
index|]
operator|==
name|namevalsep
condition|)
block|{
comment|/* Found it.  */
name|preend
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|preend
operator|>
name|list
condition|)
comment|/* Don't include the preceding entsep.  */
operator|--
name|preend
expr_stmt|;
name|post
operator|=
name|p2
expr_stmt|;
block|}
if|if
condition|(
name|p2
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
break|break;
name|p
operator|=
name|p2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|post
operator|==
name|NULL
condition|)
name|post
operator|=
name|p2
expr_stmt|;
if|if
condition|(
name|preend
operator|==
name|pre
operator|&&
name|attrval
operator|==
name|NULL
operator|&&
name|post
operator|==
name|p2
condition|)
return|return
name|NULL
return|;
name|retval
operator|=
name|xmalloc
argument_list|(
operator|(
name|preend
operator|-
name|pre
operator|)
operator|+
literal|1
operator|+
operator|(
name|attrval
operator|==
name|NULL
condition|?
literal|0
else|:
operator|(
name|attrname_len
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|attrval
argument_list|)
operator|)
operator|)
operator|+
literal|1
operator|+
operator|(
name|p2
operator|-
name|post
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|preend
operator|!=
name|pre
condition|)
block|{
name|strncpy
argument_list|(
name|retval
argument_list|,
name|pre
argument_list|,
name|preend
operator|-
name|pre
argument_list|)
expr_stmt|;
name|rp
operator|=
name|retval
operator|+
operator|(
name|preend
operator|-
name|pre
operator|)
expr_stmt|;
if|if
condition|(
name|attrval
operator|!=
name|NULL
condition|)
operator|*
name|rp
operator|++
operator|=
name|entsep
expr_stmt|;
operator|*
name|rp
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|retval
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|attrval
operator|!=
name|NULL
condition|)
block|{
name|strcat
argument_list|(
name|retval
argument_list|,
name|attrname
argument_list|)
expr_stmt|;
name|rp
operator|=
name|retval
operator|+
name|strlen
argument_list|(
name|retval
argument_list|)
expr_stmt|;
operator|*
name|rp
operator|++
operator|=
name|namevalsep
expr_stmt|;
name|strcpy
argument_list|(
name|rp
argument_list|,
name|attrval
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|post
operator|!=
name|p2
condition|)
block|{
name|rp
operator|=
name|retval
operator|+
name|strlen
argument_list|(
name|retval
argument_list|)
expr_stmt|;
if|if
condition|(
name|preend
operator|!=
name|pre
operator|||
name|attrval
operator|!=
name|NULL
condition|)
operator|*
name|rp
operator|++
operator|=
name|entsep
expr_stmt|;
name|strncpy
argument_list|(
name|rp
argument_list|,
name|post
argument_list|,
name|p2
operator|-
name|post
argument_list|)
expr_stmt|;
name|rp
operator|+=
name|p2
operator|-
name|post
expr_stmt|;
operator|*
name|rp
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_function
name|void
name|fileattr_set
parameter_list|(
name|filename
parameter_list|,
name|attrname
parameter_list|,
name|attrval
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
specifier|const
name|char
modifier|*
name|attrname
decl_stmt|;
specifier|const
name|char
modifier|*
name|attrval
decl_stmt|;
block|{
name|Node
modifier|*
name|node
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
block|{
name|p
operator|=
name|fileattr_modify
argument_list|(
name|fileattr_default_attrs
argument_list|,
name|attrname
argument_list|,
name|attrval
argument_list|,
literal|'='
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileattr_default_attrs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|fileattr_default_attrs
argument_list|)
expr_stmt|;
name|fileattr_default_attrs
operator|=
name|p
expr_stmt|;
name|attrs_modified
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|attrlist
operator|==
name|NULL
condition|)
name|fileattr_read
argument_list|()
expr_stmt|;
if|if
condition|(
name|attrlist
operator|==
name|NULL
condition|)
block|{
comment|/* Not sure this is a graceful way to handle things 	   in the case where fileattr_read was unable to read the file.  */
comment|/* No attributes existed previously.  */
name|attrlist
operator|=
name|getlist
argument_list|()
expr_stmt|;
block|}
name|node
operator|=
name|findnode
argument_list|(
name|attrlist
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|attrval
operator|==
name|NULL
condition|)
comment|/* Attempt to remove an attribute which wasn't there.  */
return|return;
comment|/* First attribute for this file.  */
name|node
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|node
operator|->
name|type
operator|=
name|FILEATTR
expr_stmt|;
name|node
operator|->
name|delproc
operator|=
name|fileattr_delproc
expr_stmt|;
name|node
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|node
operator|->
name|data
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|attrname
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|attrval
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|node
operator|->
name|data
argument_list|,
name|attrname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|node
operator|->
name|data
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|node
operator|->
name|data
argument_list|,
name|attrval
argument_list|)
expr_stmt|;
name|addnode
argument_list|(
name|attrlist
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|fileattr_modify
argument_list|(
name|node
operator|->
name|data
argument_list|,
name|attrname
argument_list|,
name|attrval
argument_list|,
literal|'='
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|delnode
argument_list|(
name|node
argument_list|)
expr_stmt|;
else|else
block|{
name|free
argument_list|(
name|node
operator|->
name|data
argument_list|)
expr_stmt|;
name|node
operator|->
name|data
operator|=
name|p
expr_stmt|;
block|}
name|attrs_modified
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|fileattr_getall
parameter_list|(
name|filename
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|Node
modifier|*
name|node
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|attrlist
operator|==
name|NULL
condition|)
name|fileattr_read
argument_list|()
expr_stmt|;
if|if
condition|(
name|attrlist
operator|==
name|NULL
condition|)
comment|/* Either nothing has any attributes, or fileattr_read already printed 	   an error message.  */
return|return
name|NULL
return|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
name|p
operator|=
name|fileattr_default_attrs
expr_stmt|;
else|else
block|{
name|node
operator|=
name|findnode
argument_list|(
name|attrlist
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
comment|/* A file not mentioned has no attributes.  */
return|return
name|NULL
return|;
name|p
operator|=
name|node
operator|->
name|data
expr_stmt|;
block|}
return|return
name|xstrdup
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|fileattr_setall
parameter_list|(
name|filename
parameter_list|,
name|attrs
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
specifier|const
name|char
modifier|*
name|attrs
decl_stmt|;
block|{
name|Node
modifier|*
name|node
decl_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|fileattr_default_attrs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|fileattr_default_attrs
argument_list|)
expr_stmt|;
name|fileattr_default_attrs
operator|=
name|xstrdup
argument_list|(
name|attrs
argument_list|)
expr_stmt|;
name|attrs_modified
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|attrlist
operator|==
name|NULL
condition|)
name|fileattr_read
argument_list|()
expr_stmt|;
if|if
condition|(
name|attrlist
operator|==
name|NULL
condition|)
block|{
comment|/* Not sure this is a graceful way to handle things 	   in the case where fileattr_read was unable to read the file.  */
comment|/* No attributes existed previously.  */
name|attrlist
operator|=
name|getlist
argument_list|()
expr_stmt|;
block|}
name|node
operator|=
name|findnode
argument_list|(
name|attrlist
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
block|{
comment|/* The file had no attributes.  Add them if we have any to add.  */
if|if
condition|(
name|attrs
operator|!=
name|NULL
condition|)
block|{
name|node
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|node
operator|->
name|type
operator|=
name|FILEATTR
expr_stmt|;
name|node
operator|->
name|delproc
operator|=
name|fileattr_delproc
expr_stmt|;
name|node
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|node
operator|->
name|data
operator|=
name|xstrdup
argument_list|(
name|attrs
argument_list|)
expr_stmt|;
name|addnode
argument_list|(
name|attrlist
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|attrs
operator|==
name|NULL
condition|)
name|delnode
argument_list|(
name|node
argument_list|)
expr_stmt|;
else|else
block|{
name|free
argument_list|(
name|node
operator|->
name|data
argument_list|)
expr_stmt|;
name|node
operator|->
name|data
operator|=
name|xstrdup
argument_list|(
name|attrs
argument_list|)
expr_stmt|;
block|}
block|}
name|attrs_modified
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fileattr_newfile
parameter_list|(
name|filename
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|Node
modifier|*
name|node
decl_stmt|;
if|if
condition|(
name|attrlist
operator|==
name|NULL
condition|)
name|fileattr_read
argument_list|()
expr_stmt|;
if|if
condition|(
name|fileattr_default_attrs
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|attrlist
operator|==
name|NULL
condition|)
block|{
comment|/* Not sure this is a graceful way to handle things 	   in the case where fileattr_read was unable to read the file.  */
comment|/* No attributes existed previously.  */
name|attrlist
operator|=
name|getlist
argument_list|()
expr_stmt|;
block|}
name|node
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|node
operator|->
name|type
operator|=
name|FILEATTR
expr_stmt|;
name|node
operator|->
name|delproc
operator|=
name|fileattr_delproc
expr_stmt|;
name|node
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|node
operator|->
name|data
operator|=
name|xstrdup
argument_list|(
name|fileattr_default_attrs
argument_list|)
expr_stmt|;
name|addnode
argument_list|(
name|attrlist
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|attrs_modified
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|writeattr_proc
parameter_list|(
name|node
parameter_list|,
name|data
parameter_list|)
name|Node
modifier|*
name|node
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
init|=
operator|(
name|FILE
operator|*
operator|)
name|data
decl_stmt|;
name|fputs
argument_list|(
literal|"F"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|node
operator|->
name|key
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|node
operator|->
name|data
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\012"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|fileattr_write
parameter_list|()
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|mode_t
name|omask
decl_stmt|;
if|if
condition|(
operator|!
name|attrs_modified
condition|)
return|return;
if|if
condition|(
name|noexec
condition|)
return|return;
comment|/* If NULL was passed to fileattr_startdir, then it isn't kosher to set        attributes.  */
name|assert
argument_list|(
name|fileattr_stored_repos
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|fname
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|fileattr_stored_repos
argument_list|)
operator|+
literal|1
operator|+
sizeof|sizeof
argument_list|(
name|CVSREP_FILEATTR
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|fname
argument_list|,
name|fileattr_stored_repos
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|fname
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|fname
argument_list|,
name|CVSREP_FILEATTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_isempty
argument_list|(
name|attrlist
argument_list|)
operator|&&
name|fileattr_default_attrs
operator|==
name|NULL
operator|&&
name|unrecog_head
operator|==
name|NULL
condition|)
block|{
comment|/* There are no attributes.  */
if|if
condition|(
name|unlink_file
argument_list|(
name|fname
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now remove CVSREP directory, if empty.  The main reason we bother 	   is that CVS 1.6 and earlier will choke if a CVSREP directory 	   exists, so provide the user a graceful way to remove it.  */
name|strcpy
argument_list|(
name|fname
argument_list|,
name|fileattr_stored_repos
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|fname
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|fname
argument_list|,
name|CVSREP
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVS_RMDIR
argument_list|(
name|fname
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOTEMPTY
comment|/* Don't know why we would be here if there is no CVSREP 		   directory, but it seemed to be happening anyway, so 		   check for it.  */
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
return|return;
block|}
name|omask
operator|=
name|umask
argument_list|(
name|cvsumask
argument_list|)
expr_stmt|;
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|fname
argument_list|,
name|FOPEN_BINARY_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
block|{
comment|/* Maybe the CVSREP directory doesn't exist.  Try creating it.  */
name|char
modifier|*
name|repname
decl_stmt|;
name|repname
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|fileattr_stored_repos
argument_list|)
operator|+
literal|1
operator|+
sizeof|sizeof
argument_list|(
name|CVSREP
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|repname
argument_list|,
name|fileattr_stored_repos
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|repname
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|repname
argument_list|,
name|CVSREP
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVS_MKDIR
argument_list|(
name|repname
argument_list|,
literal|0777
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EEXIST
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot make directory %s"
argument_list|,
name|repname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repname
argument_list|)
expr_stmt|;
return|return;
block|}
name|free
argument_list|(
name|repname
argument_list|)
expr_stmt|;
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|fname
argument_list|,
name|FOPEN_BINARY_WRITE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot write %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
operator|(
name|void
operator|)
name|umask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
comment|/* First write the "F" attributes.  */
name|walklist
argument_list|(
name|attrlist
argument_list|,
name|writeattr_proc
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* Then the "D" attribute.  */
if|if
condition|(
name|fileattr_default_attrs
operator|!=
name|NULL
condition|)
block|{
name|fputs
argument_list|(
literal|"D\t"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|fileattr_default_attrs
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\012"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
comment|/* Then any other attributes.  */
while|while
condition|(
name|unrecog_head
operator|!=
name|NULL
condition|)
block|{
name|struct
name|unrecog
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|unrecog_head
expr_stmt|;
name|fputs
argument_list|(
name|p
operator|->
name|line
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\012"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|unrecog_head
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|attrs_modified
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fileattr_free
parameter_list|()
block|{
comment|/* Note that attrs_modified will ordinarily be zero, but there are        a few cases in which fileattr_write will fail to zero it (if        noexec is set, or error conditions).  This probably is the way        it should be.  */
name|dellist
argument_list|(
operator|&
name|attrlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileattr_stored_repos
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|fileattr_stored_repos
argument_list|)
expr_stmt|;
name|fileattr_stored_repos
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fileattr_default_attrs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|fileattr_default_attrs
argument_list|)
expr_stmt|;
name|fileattr_default_attrs
operator|=
name|NULL
expr_stmt|;
block|}
end_function

end_unit

