begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  * Copyright (c) 1989-1992, Brian Berliner  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS source distribution.  *   * Set Lock  *   * Lock file support for CVS.  */
end_comment

begin_comment
comment|/* The node Concurrency in doc/cvs.texinfo has a brief introduction to    how CVS locks function, and some of the user-visible consequences of    their existence.  Here is a summary of why they exist (and therefore,    the consequences of hacking CVS to read a repository without creating    locks):     There are two uses.  One is the ability to prevent there from being    two writers at the same time.  This is necessary for any number of    reasons (fileattr code, probably others).  Commit needs to lock the    whole tree so that nothing happens between the up-to-date check and    the actual checkin.     The second use is the ability to ensure that there is not a writer    and a reader at the same time (several readers are allowed).  Reasons    for this are:     * Readlocks ensure that once CVS has found a collection of rcs    files using Find_Names, the files will still exist when it reads    them (they may have moved in or out of the attic).     * Readlocks provide some modicum of consistency, although this is    kind of limited--see the node Concurrency in cvs.texinfo.     * Readlocks ensure that the RCS file does not change between    RCS_parse and RCS_reparsercsfile time.  This one strikes me as    important, although I haven't thought up what bad scenarios might    be.     * Readlocks ensure that we won't find the file in the state in    which it is in between the calls to add_rcs_file and RCS_checkin in    commit.c (when a file is being added).  This state is a state in    which the RCS file parsing routines in rcs.c cannot parse the file.     * Readlocks ensure that a reader won't try to look at a    half-written fileattr file (fileattr is not updated atomically).     (see also the description of anonymous read-only access in    "Password authentication security" node in doc/cvs.texinfo).     While I'm here, I'll try to summarize a few random suggestions    which periodically get made about how locks might be different:     1.  Check for EROFS.  Maybe useful, although in the presence of NFS    EROFS does *not* mean that the file system is unchanging.     2.  Provide a means to put the cvs locks in some directory apart from    the repository (CVSROOT/locks; a -l option in modules; etc.).     3.  Provide an option to disable locks for operations which only    read (see above for some of the consequences).     4.  Have a server internally do the locking.  Probably a good    long-term solution, and many people have been working hard on code    changes which would eventually make it possible to have a server    which can handle various connections in one process, but there is    much, much work still to be done before this is feasible.     5.  Like #4 but use shared memory or something so that the servers    merely need to all be on the same machine.  This is a much smaller    change to CVS (it functions much like #2; shared memory might be an    unneeded complication although it presumably would be faster).  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_struct
struct|struct
name|lock
block|{
comment|/* This is the directory in which we may have a lock named by the        readlock variable, a lock named by the writelock variable, and/or        a lock named CVSLCK.  The storage is not allocated along with the        struct lock; it is allocated by the Reader_Lock caller or in the        case of writelocks, it is just a pointer to the storage allocated        for the ->key field.  */
name|char
modifier|*
name|repository
decl_stmt|;
comment|/* Do we have a lock named CVSLCK?  */
name|int
name|have_lckdir
decl_stmt|;
comment|/* Note there is no way of knowing whether the readlock and writelock        exist.  The code which sets the locks doesn't use SIG_beginCrSect        to set a flag like we do for CVSLCK.  */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|remove_locks
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|readers_exist
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|repository
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|set_lock
name|PROTO
argument_list|(
operator|(
expr|struct
name|lock
operator|*
name|lock
operator|,
name|int
name|will_wait
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_lock
name|PROTO
argument_list|(
operator|(
expr|struct
name|lock
operator|*
name|lock
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_lockers_name
name|PROTO
argument_list|(
operator|(
expr|struct
name|stat
operator|*
name|statp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|set_writelock_proc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|,
name|void
operator|*
name|closure
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|unlock_proc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|,
name|void
operator|*
name|closure
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|write_lock
name|PROTO
argument_list|(
operator|(
expr|struct
name|lock
operator|*
name|lock
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lock_simple_remove
name|PROTO
argument_list|(
operator|(
expr|struct
name|lock
operator|*
name|lock
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lock_wait
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|repository
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lock_obtained
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|repository
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Malloc'd array containing the username of the whoever has the lock.    Will always be non-NULL in the cases where it is needed.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lockers_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Malloc'd array specifying name of a readlock within a directory.    Or NULL if none.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|readlock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Malloc'd array specifying name of a writelock within a directory.    Or NULL if none.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|writelock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Malloc'd array specifying the name of a CVSLCK file (absolute pathname).    Will always be non-NULL in the cases where it is used.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|masterlock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|List
modifier|*
name|locklist
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|L_OK
value|0
end_define

begin_comment
comment|/* success */
end_comment

begin_define
define|#
directive|define
name|L_ERROR
value|1
end_define

begin_comment
comment|/* error condition */
end_comment

begin_define
define|#
directive|define
name|L_LOCKED
value|2
end_define

begin_comment
comment|/* lock owned by someone else */
end_comment

begin_comment
comment|/* This is the (single) readlock which is set by Reader_Lock.  The    repository field is NULL if there is no such lock.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|lock
name|global_readlock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of locks set by lock_tree_for_write.  This is redundant    with locklist, sort of.  */
end_comment

begin_decl_stmt
specifier|static
name|List
modifier|*
name|lock_tree_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If we set locks with lock_dir_for_write, then locked_dir contains    the malloc'd name of the repository directory which we have locked.    locked_list is the same thing packaged into a list and is redundant    with locklist the same way that lock_tree_list is.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|locked_dir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|List
modifier|*
name|locked_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Clean up all outstanding locks  */
end_comment

begin_function
name|void
name|Lock_Cleanup
parameter_list|()
block|{
name|remove_locks
argument_list|()
expr_stmt|;
name|dellist
argument_list|(
operator|&
name|lock_tree_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|locked_dir
operator|!=
name|NULL
condition|)
block|{
name|dellist
argument_list|(
operator|&
name|locked_list
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|locked_dir
argument_list|)
expr_stmt|;
name|locked_dir
operator|=
name|NULL
expr_stmt|;
name|locked_list
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Remove locks without discarding the lock information  */
end_comment

begin_function
specifier|static
name|void
name|remove_locks
parameter_list|()
block|{
comment|/* clean up simple locks (if any) */
if|if
condition|(
name|global_readlock
operator|.
name|repository
operator|!=
name|NULL
condition|)
block|{
name|lock_simple_remove
argument_list|(
operator|&
name|global_readlock
argument_list|)
expr_stmt|;
name|global_readlock
operator|.
name|repository
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* clean up multiple locks (if any) */
if|if
condition|(
name|locklist
operator|!=
operator|(
name|List
operator|*
operator|)
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|walklist
argument_list|(
name|locklist
argument_list|,
name|unlock_proc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|locklist
operator|=
operator|(
name|List
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * walklist proc for removing a list of locks  */
end_comment

begin_function
specifier|static
name|int
name|unlock_proc
parameter_list|(
name|p
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|lock_simple_remove
argument_list|(
operator|(
expr|struct
name|lock
operator|*
operator|)
name|p
operator|->
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Remove the lock files.  */
end_comment

begin_function
specifier|static
name|void
name|lock_simple_remove
parameter_list|(
name|lock
parameter_list|)
name|struct
name|lock
modifier|*
name|lock
decl_stmt|;
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
comment|/* If readlock is set, the lock directory *might* have been created, but        since Reader_Lock doesn't use SIG_beginCrSect the way that set_lock        does, we don't know that.  That is why we need to check for        existence_error here.  */
if|if
condition|(
name|readlock
operator|!=
name|NULL
condition|)
block|{
name|tmp
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|lock
operator|->
name|repository
argument_list|)
operator|+
name|strlen
argument_list|(
name|readlock
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s"
argument_list|,
name|lock
operator|->
name|repository
argument_list|,
name|readlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVS_UNLINK
argument_list|(
name|tmp
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"failed to remove lock %s"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* If writelock is set, the lock directory *might* have been created, but        since write_lock doesn't use SIG_beginCrSect the way that set_lock        does, we don't know that.  That is why we need to check for        existence_error here.  */
if|if
condition|(
name|writelock
operator|!=
name|NULL
condition|)
block|{
name|tmp
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|lock
operator|->
name|repository
argument_list|)
operator|+
name|strlen
argument_list|(
name|writelock
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s"
argument_list|,
name|lock
operator|->
name|repository
argument_list|,
name|writelock
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVS_UNLINK
argument_list|(
name|tmp
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"failed to remove lock %s"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lock
operator|->
name|have_lckdir
condition|)
block|{
name|tmp
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|lock
operator|->
name|repository
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSLCK
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s"
argument_list|,
name|lock
operator|->
name|repository
argument_list|,
name|CVSLCK
argument_list|)
expr_stmt|;
name|SIG_beginCrSect
argument_list|()
expr_stmt|;
if|if
condition|(
name|CVS_RMDIR
argument_list|(
name|tmp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"failed to remove lock dir %s"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|lock
operator|->
name|have_lckdir
operator|=
literal|0
expr_stmt|;
name|SIG_endCrSect
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Create a lock file for readers  */
end_comment

begin_function
name|int
name|Reader_Lock
parameter_list|(
name|xrepository
parameter_list|)
name|char
modifier|*
name|xrepository
decl_stmt|;
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|noexec
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* we only do one directory at a time for read locks! */
if|if
condition|(
name|global_readlock
operator|.
name|repository
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Reader_Lock called while read locks set - Help!"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|readlock
operator|==
name|NULL
condition|)
block|{
name|readlock
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|hostname
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSRFL
argument_list|)
operator|+
literal|40
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|readlock
argument_list|,
ifdef|#
directive|ifdef
name|HAVE_LONG_FILE_NAMES
literal|"%s.%s.%ld"
argument_list|,
name|CVSRFL
argument_list|,
name|hostname
argument_list|,
else|#
directive|else
literal|"%s.%ld"
argument_list|,
name|CVSRFL
argument_list|,
endif|#
directive|endif
operator|(
name|long
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* remember what we're locking (for Lock_Cleanup) */
name|global_readlock
operator|.
name|repository
operator|=
name|xrepository
expr_stmt|;
comment|/* get the lock dir for our own */
if|if
condition|(
name|set_lock
argument_list|(
operator|&
name|global_readlock
argument_list|,
literal|1
argument_list|)
operator|!=
name|L_OK
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"failed to obtain dir lock in repository `%s'"
argument_list|,
name|xrepository
argument_list|)
expr_stmt|;
if|if
condition|(
name|readlock
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|readlock
argument_list|)
expr_stmt|;
name|readlock
operator|=
name|NULL
expr_stmt|;
comment|/* We don't set global_readlock.repository to NULL.  I think this 	   only works because recurse.c will give a fatal error if we return 	   a nonzero value.  */
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* write a read-lock */
name|tmp
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|xrepository
argument_list|)
operator|+
name|strlen
argument_list|(
name|readlock
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s"
argument_list|,
name|xrepository
argument_list|,
name|readlock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|tmp
argument_list|,
literal|"w+"
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot create read lock in repository `%s'"
argument_list|,
name|xrepository
argument_list|)
expr_stmt|;
if|if
condition|(
name|readlock
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|readlock
argument_list|)
expr_stmt|;
name|readlock
operator|=
name|NULL
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
comment|/* free the lock dir */
name|clear_lock
argument_list|(
operator|&
name|global_readlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lock a list of directories for writing  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lock_error_repos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lock_error
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|Writer_Lock
name|PROTO
argument_list|(
operator|(
name|List
operator|*
name|list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|Writer_Lock
parameter_list|(
name|list
parameter_list|)
name|List
modifier|*
name|list
decl_stmt|;
block|{
name|char
modifier|*
name|wait_repos
decl_stmt|;
if|if
condition|(
name|noexec
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* We only know how to do one list at a time */
if|if
condition|(
name|locklist
operator|!=
operator|(
name|List
operator|*
operator|)
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Writer_Lock called while write locks set - Help!"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|wait_repos
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* try to lock everything on the list */
name|lock_error
operator|=
name|L_OK
expr_stmt|;
comment|/* init for set_writelock_proc */
name|lock_error_repos
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* init for set_writelock_proc */
name|locklist
operator|=
name|list
expr_stmt|;
comment|/* init for Lock_Cleanup */
if|if
condition|(
name|lockers_name
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|lockers_name
argument_list|)
expr_stmt|;
name|lockers_name
operator|=
name|xstrdup
argument_list|(
literal|"unknown"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|walklist
argument_list|(
name|list
argument_list|,
name|set_writelock_proc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|lock_error
condition|)
block|{
case|case
name|L_ERROR
case|:
comment|/* Real Error */
if|if
condition|(
name|wait_repos
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|wait_repos
argument_list|)
expr_stmt|;
name|Lock_Cleanup
argument_list|()
expr_stmt|;
comment|/* clean up any locks we set */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"lock failed - giving up"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|L_LOCKED
case|:
comment|/* Someone already had a lock */
name|remove_locks
argument_list|()
expr_stmt|;
comment|/* clean up any locks we set */
name|lock_wait
argument_list|(
name|lock_error_repos
argument_list|)
expr_stmt|;
comment|/* sleep a while and try again */
name|wait_repos
operator|=
name|xstrdup
argument_list|(
name|lock_error_repos
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|L_OK
case|:
comment|/* we got the locks set */
if|if
condition|(
name|wait_repos
operator|!=
name|NULL
condition|)
block|{
name|lock_obtained
argument_list|(
name|wait_repos
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|wait_repos
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
default|default:
if|if
condition|(
name|wait_repos
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|wait_repos
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"unknown lock status %d in Writer_Lock"
argument_list|,
name|lock_error
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * walklist proc for setting write locks  */
end_comment

begin_function
specifier|static
name|int
name|set_writelock_proc
parameter_list|(
name|p
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
comment|/* if some lock was not OK, just skip this one */
if|if
condition|(
name|lock_error
operator|!=
name|L_OK
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* apply the write lock */
name|lock_error_repos
operator|=
name|p
operator|->
name|key
expr_stmt|;
name|lock_error
operator|=
name|write_lock
argument_list|(
operator|(
expr|struct
name|lock
operator|*
operator|)
name|p
operator|->
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a lock file for writers returns L_OK if lock set ok, L_LOCKED if  * lock held by someone else or L_ERROR if an error occurred  */
end_comment

begin_function
specifier|static
name|int
name|write_lock
parameter_list|(
name|lock
parameter_list|)
name|struct
name|lock
modifier|*
name|lock
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|writelock
operator|==
name|NULL
condition|)
block|{
name|writelock
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|hostname
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSWFL
argument_list|)
operator|+
literal|40
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|writelock
argument_list|,
ifdef|#
directive|ifdef
name|HAVE_LONG_FILE_NAMES
literal|"%s.%s.%ld"
argument_list|,
name|CVSWFL
argument_list|,
name|hostname
argument_list|,
else|#
directive|else
literal|"%s.%ld"
argument_list|,
name|CVSWFL
argument_list|,
endif|#
directive|endif
operator|(
name|long
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* make sure the lock dir is ours (not necessarily unique to us!) */
name|status
operator|=
name|set_lock
argument_list|(
name|lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|L_OK
condition|)
block|{
comment|/* we now own a writer - make sure there are no readers */
if|if
condition|(
name|readers_exist
argument_list|(
name|lock
operator|->
name|repository
argument_list|)
condition|)
block|{
comment|/* clean up the lock dir if we created it */
if|if
condition|(
name|status
operator|==
name|L_OK
condition|)
block|{
name|clear_lock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
block|}
comment|/* indicate we failed due to read locks instead of error */
return|return
operator|(
name|L_LOCKED
operator|)
return|;
block|}
comment|/* write the write-lock file */
name|tmp
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|lock
operator|->
name|repository
argument_list|)
operator|+
name|strlen
argument_list|(
name|writelock
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s"
argument_list|,
name|lock
operator|->
name|repository
argument_list|,
name|writelock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|tmp
argument_list|,
literal|"w+"
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|int
name|xerrno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|CVS_UNLINK
argument_list|(
name|tmp
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"failed to remove lock %s"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* free the lock dir if we created it */
if|if
condition|(
name|status
operator|==
name|L_OK
condition|)
block|{
name|clear_lock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
block|}
comment|/* return the error */
name|error
argument_list|(
literal|0
argument_list|,
name|xerrno
argument_list|,
literal|"cannot create write lock in repository `%s'"
argument_list|,
name|lock
operator|->
name|repository
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|L_ERROR
operator|)
return|;
block|}
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|L_OK
operator|)
return|;
block|}
else|else
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * readers_exist() returns 0 if there are no reader lock files remaining in  * the repository; else 1 is returned, to indicate that the caller should  * sleep a while and try again.  */
end_comment

begin_function
specifier|static
name|int
name|readers_exist
parameter_list|(
name|repository
parameter_list|)
name|char
modifier|*
name|repository
decl_stmt|;
block|{
name|char
modifier|*
name|line
decl_stmt|;
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|CVS_FUDGELOCKS
name|again
label|:
endif|#
directive|endif
if|if
condition|(
operator|(
name|dirp
operator|=
name|CVS_OPENDIR
argument_list|(
name|repository
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot open directory %s"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|CVS_FNMATCH
argument_list|(
name|CVSRFLPAT
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|CVS_FUDGELOCKS
name|time_t
name|now
decl_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|line
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|repository
argument_list|)
operator|+
name|strlen
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%s/%s"
argument_list|,
name|repository
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVS_STAT
argument_list|(
name|line
argument_list|,
operator|&
name|sb
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|CVS_FUDGELOCKS
comment|/* 		 * If the create time of the file is more than CVSLCKAGE  		 * seconds ago, try to clean-up the lock file, and if 		 * successful, re-open the directory and try again. 		 */
if|if
condition|(
name|now
operator|>=
operator|(
name|sb
operator|.
name|st_ctime
operator|+
name|CVSLCKAGE
operator|)
operator|&&
name|CVS_UNLINK
argument_list|(
name|line
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
endif|#
directive|endif
name|set_lockers_name
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If the file doesn't exist, it just means that it disappeared 		   between the time we did the readdir and the time we did 		   the stat.  */
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot stat %s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"error reading directory %s"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the static variable lockers_name appropriately, based on the stat  * structure passed in.  */
end_comment

begin_function
specifier|static
name|void
name|set_lockers_name
parameter_list|(
name|statp
parameter_list|)
name|struct
name|stat
modifier|*
name|statp
decl_stmt|;
block|{
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
if|if
condition|(
name|lockers_name
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|lockers_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pw
operator|=
operator|(
expr|struct
name|passwd
operator|*
operator|)
name|getpwuid
argument_list|(
name|statp
operator|->
name|st_uid
argument_list|)
operator|)
operator|!=
operator|(
expr|struct
name|passwd
operator|*
operator|)
name|NULL
condition|)
block|{
name|lockers_name
operator|=
name|xstrdup
argument_list|(
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lockers_name
operator|=
name|xmalloc
argument_list|(
literal|20
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|lockers_name
argument_list|,
literal|"uid%lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|statp
operator|->
name|st_uid
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Persistently tries to make the directory "lckdir",, which serves as a  * lock. If the create time on the directory is greater than CVSLCKAGE  * seconds old, just try to remove the directory.  */
end_comment

begin_function
specifier|static
name|int
name|set_lock
parameter_list|(
name|lock
parameter_list|,
name|will_wait
parameter_list|)
name|struct
name|lock
modifier|*
name|lock
decl_stmt|;
name|int
name|will_wait
decl_stmt|;
block|{
name|int
name|waited
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|mode_t
name|omask
decl_stmt|;
ifdef|#
directive|ifdef
name|CVS_FUDGELOCKS
name|time_t
name|now
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|masterlock
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|masterlock
argument_list|)
expr_stmt|;
name|masterlock
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|lock
operator|->
name|repository
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSLCK
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|masterlock
argument_list|,
literal|"%s/%s"
argument_list|,
name|lock
operator|->
name|repository
argument_list|,
name|CVSLCK
argument_list|)
expr_stmt|;
comment|/*      * Note that it is up to the callers of set_lock() to arrange for signal      * handlers that do the appropriate things, like remove the lock      * directory before they exit.      */
name|waited
operator|=
literal|0
expr_stmt|;
name|lock
operator|->
name|have_lckdir
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|status
init|=
operator|-
literal|1
decl_stmt|;
name|omask
operator|=
name|umask
argument_list|(
name|cvsumask
argument_list|)
expr_stmt|;
name|SIG_beginCrSect
argument_list|()
expr_stmt|;
if|if
condition|(
name|CVS_MKDIR
argument_list|(
name|masterlock
argument_list|,
literal|0777
argument_list|)
operator|==
literal|0
condition|)
block|{
name|lock
operator|->
name|have_lckdir
operator|=
literal|1
expr_stmt|;
name|SIG_endCrSect
argument_list|()
expr_stmt|;
name|status
operator|=
name|L_OK
expr_stmt|;
if|if
condition|(
name|waited
condition|)
name|lock_obtained
argument_list|(
name|lock
operator|->
name|repository
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|SIG_endCrSect
argument_list|()
expr_stmt|;
name|out
label|:
operator|(
name|void
operator|)
name|umask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
operator|-
literal|1
condition|)
return|return
name|status
return|;
if|if
condition|(
name|errno
operator|!=
name|EEXIST
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"failed to create lock directory in repository `%s'"
argument_list|,
name|lock
operator|->
name|repository
argument_list|)
expr_stmt|;
return|return
operator|(
name|L_ERROR
operator|)
return|;
block|}
comment|/* Find out who owns the lock.  If the lock directory is 	   non-existent, re-try the loop since someone probably just 	   removed it (thus releasing the lock).  */
if|if
condition|(
name|CVS_STAT
argument_list|(
name|masterlock
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
continue|continue;
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"couldn't stat lock directory `%s'"
argument_list|,
name|masterlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|L_ERROR
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|CVS_FUDGELOCKS
comment|/* 	 * If the create time of the directory is more than CVSLCKAGE seconds 	 * ago, try to clean-up the lock directory, and if successful, just 	 * quietly retry to make it. 	 */
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|now
operator|>=
operator|(
name|sb
operator|.
name|st_ctime
operator|+
name|CVSLCKAGE
operator|)
condition|)
block|{
if|if
condition|(
name|CVS_RMDIR
argument_list|(
name|masterlock
argument_list|)
operator|>=
literal|0
condition|)
continue|continue;
block|}
endif|#
directive|endif
comment|/* set the lockers name */
name|set_lockers_name
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
comment|/* if he wasn't willing to wait, return an error */
if|if
condition|(
operator|!
name|will_wait
condition|)
return|return
operator|(
name|L_LOCKED
operator|)
return|;
name|lock_wait
argument_list|(
name|lock
operator|->
name|repository
argument_list|)
expr_stmt|;
name|waited
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Clear master lock.  We don't have to recompute the lock name since  * clear_lock is never called except after a successful set_lock().  */
end_comment

begin_function
specifier|static
name|void
name|clear_lock
parameter_list|(
name|lock
parameter_list|)
name|struct
name|lock
modifier|*
name|lock
decl_stmt|;
block|{
name|SIG_beginCrSect
argument_list|()
expr_stmt|;
if|if
condition|(
name|CVS_RMDIR
argument_list|(
name|masterlock
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"failed to remove lock dir `%s'"
argument_list|,
name|masterlock
argument_list|)
expr_stmt|;
name|lock
operator|->
name|have_lckdir
operator|=
literal|0
expr_stmt|;
name|SIG_endCrSect
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print out a message that the lock is still held, then sleep a while.  */
end_comment

begin_function
specifier|static
name|void
name|lock_wait
parameter_list|(
name|repos
parameter_list|)
name|char
modifier|*
name|repos
decl_stmt|;
block|{
name|time_t
name|now
decl_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"[%8.8s] waiting for %s's lock in %s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|now
argument_list|)
operator|+
literal|11
argument_list|,
name|lockers_name
argument_list|,
name|repos
argument_list|)
expr_stmt|;
comment|/* Call cvs_flusherr to ensure that the user sees this message as        soon as possible.  */
name|cvs_flusherr
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|sleep
argument_list|(
name|CVSLCKSLEEP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print out a message when we obtain a lock.  */
end_comment

begin_function
specifier|static
name|void
name|lock_obtained
parameter_list|(
name|repos
parameter_list|)
name|char
modifier|*
name|repos
decl_stmt|;
block|{
name|time_t
name|now
decl_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"[%8.8s] obtained lock in %s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|now
argument_list|)
operator|+
literal|11
argument_list|,
name|repos
argument_list|)
expr_stmt|;
comment|/* Call cvs_flusherr to ensure that the user sees this message as        soon as possible.  */
name|cvs_flusherr
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|lock_filesdoneproc
name|PROTO
argument_list|(
operator|(
name|void
operator|*
name|callerdat
operator|,
name|int
name|err
operator|,
name|char
operator|*
name|repository
operator|,
name|char
operator|*
name|update_dir
operator|,
name|List
operator|*
name|entries
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fsortcmp
name|PROTO
argument_list|(
operator|(
specifier|const
name|Node
operator|*
name|p
operator|,
specifier|const
name|Node
operator|*
name|q
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Create a list of repositories to lock  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|lock_filesdoneproc
parameter_list|(
name|callerdat
parameter_list|,
name|err
parameter_list|,
name|repository
parameter_list|,
name|update_dir
parameter_list|,
name|entries
parameter_list|)
name|void
modifier|*
name|callerdat
decl_stmt|;
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|LOCK
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|repository
argument_list|)
expr_stmt|;
name|p
operator|->
name|data
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lock
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|lock
operator|*
operator|)
name|p
operator|->
name|data
operator|)
operator|->
name|repository
operator|=
name|p
operator|->
name|key
expr_stmt|;
operator|(
operator|(
expr|struct
name|lock
operator|*
operator|)
name|p
operator|->
name|data
operator|)
operator|->
name|have_lckdir
operator|=
literal|0
expr_stmt|;
comment|/* FIXME-KRP: this error condition should not simply be passed by. */
if|if
condition|(
name|p
operator|->
name|key
operator|==
name|NULL
operator|||
name|addnode
argument_list|(
name|lock_tree_list
argument_list|,
name|p
argument_list|)
operator|!=
literal|0
condition|)
name|freenode
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * compare two lock list nodes (for sort)  */
end_comment

begin_function
specifier|static
name|int
name|fsortcmp
parameter_list|(
name|p
parameter_list|,
name|q
parameter_list|)
specifier|const
name|Node
modifier|*
name|p
decl_stmt|;
specifier|const
name|Node
modifier|*
name|q
decl_stmt|;
block|{
return|return
operator|(
name|strcmp
argument_list|(
name|p
operator|->
name|key
argument_list|,
name|q
operator|->
name|key
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|lock_tree_for_write
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|local
parameter_list|,
name|aflag
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|local
decl_stmt|;
name|int
name|aflag
decl_stmt|;
block|{
name|int
name|err
decl_stmt|;
comment|/*      * Run the recursion processor to find all the dirs to lock and lock all      * the dirs      */
name|lock_tree_list
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|err
operator|=
name|start_recursion
argument_list|(
operator|(
name|FILEPROC
operator|)
name|NULL
argument_list|,
name|lock_filesdoneproc
argument_list|,
operator|(
name|DIRENTPROC
operator|)
name|NULL
argument_list|,
operator|(
name|DIRLEAVEPROC
operator|)
name|NULL
argument_list|,
name|NULL
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|W_LOCAL
argument_list|,
name|aflag
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sortlist
argument_list|(
name|lock_tree_list
argument_list|,
name|fsortcmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|Writer_Lock
argument_list|(
name|lock_tree_list
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"lock failed - giving up"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Lock a single directory in REPOSITORY.  It is OK to call this if    a lock has been set with lock_dir_for_write; the new lock will replace    the old one.  If REPOSITORY is NULL, don't do anything.  */
end_comment

begin_function
name|void
name|lock_dir_for_write
parameter_list|(
name|repository
parameter_list|)
name|char
modifier|*
name|repository
decl_stmt|;
block|{
if|if
condition|(
name|repository
operator|!=
name|NULL
operator|&&
operator|(
name|locked_dir
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|locked_dir
argument_list|,
name|repository
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|Node
modifier|*
name|node
decl_stmt|;
if|if
condition|(
name|locked_dir
operator|!=
name|NULL
condition|)
name|Lock_Cleanup
argument_list|()
expr_stmt|;
name|locked_dir
operator|=
name|xstrdup
argument_list|(
name|repository
argument_list|)
expr_stmt|;
name|locked_list
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|node
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|node
operator|->
name|type
operator|=
name|LOCK
expr_stmt|;
name|node
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|repository
argument_list|)
expr_stmt|;
name|node
operator|->
name|data
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lock
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|lock
operator|*
operator|)
name|node
operator|->
name|data
operator|)
operator|->
name|repository
operator|=
name|node
operator|->
name|key
expr_stmt|;
operator|(
operator|(
expr|struct
name|lock
operator|*
operator|)
name|node
operator|->
name|data
operator|)
operator|->
name|have_lckdir
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|locked_list
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|Writer_Lock
argument_list|(
name|locked_list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

