begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  * Copyright (c) 1989-1992, Brian Berliner  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS source distribution.  *   * Add  *   * Adds a file or directory to the RCS source repository.  For a file,  * the entry is marked as "needing to be added" in the user's own CVS  * directory, and really added to the repository when it is committed.  * For a directory, it is added at the appropriate place in the source  * repository and a CVS directory is generated within the directory.  *   * The -m option is currently the only supported option.  Some may wish to  * supply standard "rcs" options here, but I've found that this causes more  * trouble than anything else.  *   * The user files or directories must already exist.  For a directory, it must  * not already have a CVS file in it.  *   * An "add" on a file that has been "remove"d but not committed will cause the  * file to be resurrected.  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"savecwd.h"
end_include

begin_include
include|#
directive|include
file|"fileattr.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|add_directory
name|PROTO
argument_list|(
operator|(
expr|struct
name|file_info
operator|*
name|finfo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|build_entry
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|repository
operator|,
specifier|const
name|char
operator|*
name|user
operator|,
specifier|const
name|char
operator|*
name|options
operator|,
specifier|const
name|char
operator|*
name|message
operator|,
name|List
operator|*
name|entries
operator|,
specifier|const
name|char
operator|*
name|tag
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|add_usage
index|[]
init|=
block|{
literal|"Usage: %s %s [-k rcs-kflag] [-m message] files...\n"
block|,
literal|"\t-k\tUse \"rcs-kflag\" to add the file with the specified kflag.\n"
block|,
literal|"\t-m\tUse \"message\" for the creation log.\n"
block|,
literal|"(Specify the --help global option for a list of other help options)\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|add
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|message
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|added_files
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|options
init|=
name|NULL
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
name|Vers_TS
modifier|*
name|vers
decl_stmt|;
name|struct
name|saved_cwd
name|cwd
decl_stmt|;
comment|/* Nonzero if we found a slash, and are thus adding files in a        subdirectory.  */
name|int
name|found_slash
init|=
literal|0
decl_stmt|;
name|size_t
name|cvsroot_len
decl_stmt|;
if|if
condition|(
name|argc
operator|==
literal|1
operator|||
name|argc
operator|==
operator|-
literal|1
condition|)
name|usage
argument_list|(
name|add_usage
argument_list|)
expr_stmt|;
name|wrap_setup
argument_list|()
expr_stmt|;
comment|/* parse args */
name|optind
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"+k:m:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'k'
case|:
if|if
condition|(
name|options
condition|)
name|free
argument_list|(
name|options
argument_list|)
expr_stmt|;
name|options
operator|=
name|RCS_check_kflag
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|message
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
name|add_usage
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|0
condition|)
name|usage
argument_list|(
name|add_usage
argument_list|)
expr_stmt|;
name|cvsroot_len
operator|=
name|strlen
argument_list|(
name|current_parsed_root
operator|->
name|directory
argument_list|)
expr_stmt|;
comment|/* First some sanity checks.  I know that the CVS case is (sort of)        also handled by add_directory, but we need to check here so the        client won't get all confused in send_file_names.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|int
name|skip_file
init|=
literal|0
decl_stmt|;
comment|/* If it were up to me I'd probably make this a fatal error. 	   But some people are really fond of their "cvs add *", and 	   don't seem to object to the warnings. 	   Whatever.  */
name|strip_trailing_slashes
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
operator|||
name|fncmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|CVSADM
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot add special file `%s'; skipping"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|skip_file
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|ISDIRSEP
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|found_slash
operator|=
literal|1
expr_stmt|;
break|break;
block|}
operator|++
name|p
expr_stmt|;
block|}
block|}
if|if
condition|(
name|skip_file
condition|)
block|{
name|int
name|j
decl_stmt|;
comment|/* FIXME: We don't do anything about free'ing argv[i].  But 	       the problem is that it is only sometimes allocated (see 	       cvsrc.c).  */
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|argc
operator|-
literal|1
condition|;
operator|++
name|j
control|)
name|argv
index|[
name|j
index|]
operator|=
name|argv
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
operator|--
name|argc
expr_stmt|;
comment|/* Check the new argv[i] again.  */
operator|--
name|i
expr_stmt|;
operator|++
name|err
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|CLIENT_SUPPORT
if|if
condition|(
name|current_parsed_root
operator|->
name|isremote
condition|)
block|{
name|int
name|j
decl_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
comment|/* We snipped out all the arguments in the above sanity 	       check.  We can just forget the whole thing (and we 	       better, because if we fired up the server and passed it 	       nothing, it would spit back a usage message).  */
return|return
name|err
return|;
name|start_server
argument_list|()
expr_stmt|;
name|ign_setup
argument_list|()
expr_stmt|;
if|if
condition|(
name|options
condition|)
block|{
name|send_arg
argument_list|(
name|options
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|options
argument_list|)
expr_stmt|;
block|}
name|option_with_arg
argument_list|(
literal|"-m"
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|send_arg
argument_list|(
literal|"--"
argument_list|)
expr_stmt|;
comment|/* If !found_slash, refrain from sending "Directory", for 	   CVS 1.9 compatibility.  If we only tried to deal with servers 	   which are at least CVS 1.9.26 or so, we wouldn't have to 	   special-case this.  */
if|if
condition|(
name|found_slash
condition|)
block|{
name|repository
operator|=
name|Name_Repository
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|send_a_repository
argument_list|(
literal|""
argument_list|,
name|repository
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repository
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|argc
condition|;
operator|++
name|j
control|)
block|{
comment|/* FIXME: Does this erroneously call Create_Admin in error 	       conditions which are only detected once the server gets its 	       hands on things?  */
comment|/* FIXME-also: if filenames are case-insensitive on the 	       client, and the directory in the repository already 	       exists and is named "foo", and the command is "cvs add 	       FOO", this call to Create_Admin puts the wrong thing in 	       CVS/Repository and so a subsequent "cvs update" will 	       give an error.  The fix will be to have the server report 	       back what it actually did (e.g. use tagged text for the 	       "Directory %s added" message), and then Create_Admin, 	       which should also fix the error handling concerns.  */
if|if
condition|(
name|isdir
argument_list|(
name|argv
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|char
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|date
decl_stmt|;
name|int
name|nonbranch
decl_stmt|;
name|char
modifier|*
name|rcsdir
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
comment|/* This is some mungeable storage into which we can point 		   with p and/or update_dir.  */
name|char
modifier|*
name|filedir
decl_stmt|;
if|if
condition|(
name|save_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
condition|)
name|error_exit
argument_list|()
expr_stmt|;
name|filedir
operator|=
name|xstrdup
argument_list|(
name|argv
index|[
name|j
index|]
argument_list|)
expr_stmt|;
comment|/* Deliberately discard the const below since we know we just                  * allocated filedir and can do what we like with it.                  */
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|last_component
argument_list|(
name|filedir
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|filedir
condition|)
block|{
name|update_dir
operator|=
literal|""
expr_stmt|;
block|}
else|else
block|{
name|p
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|update_dir
operator|=
name|filedir
expr_stmt|;
if|if
condition|(
name|CVS_CHDIR
argument_list|(
name|update_dir
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not chdir to %s"
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
block|}
comment|/* find the repository associated with our current dir */
name|repository
operator|=
name|Name_Repository
argument_list|(
name|NULL
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
comment|/* don't add stuff to Emptydir */
if|if
condition|(
name|strncmp
argument_list|(
name|repository
argument_list|,
name|current_parsed_root
operator|->
name|directory
argument_list|,
name|cvsroot_len
argument_list|)
operator|==
literal|0
operator|&&
name|ISDIRSEP
argument_list|(
name|repository
index|[
name|cvsroot_len
index|]
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|repository
operator|+
name|cvsroot_len
operator|+
literal|1
argument_list|,
name|CVSROOTADM
argument_list|,
sizeof|sizeof
name|CVSROOTADM
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|&&
name|ISDIRSEP
argument_list|(
name|repository
index|[
name|cvsroot_len
operator|+
sizeof|sizeof
name|CVSROOTADM
index|]
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|repository
operator|+
name|cvsroot_len
operator|+
sizeof|sizeof
name|CVSROOTADM
operator|+
literal|1
argument_list|,
name|CVSNULLREPOS
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot add to %s"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
comment|/* before we do anything else, see if we have any 		   per-directory tags */
name|ParseTag
argument_list|(
operator|&
name|tag
argument_list|,
operator|&
name|date
argument_list|,
operator|&
name|nonbranch
argument_list|)
expr_stmt|;
name|rcsdir
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|repository
argument_list|)
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|rcsdir
argument_list|,
literal|"%s/%s"
argument_list|,
name|repository
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|Create_Admin
argument_list|(
name|p
argument_list|,
name|argv
index|[
name|j
index|]
argument_list|,
name|rcsdir
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
name|nonbranch
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|found_slash
condition|)
name|send_a_repository
argument_list|(
literal|""
argument_list|,
name|repository
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|restore_cwd
argument_list|(
operator|&
name|cwd
argument_list|,
name|NULL
argument_list|)
condition|)
name|error_exit
argument_list|()
expr_stmt|;
name|free_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
condition|)
name|free
argument_list|(
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|date
condition|)
name|free
argument_list|(
name|date
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rcsdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|filedir
condition|)
name|Subdir_Register
argument_list|(
operator|(
name|List
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|argv
index|[
name|j
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|Subdir_Register
argument_list|(
operator|(
name|List
operator|*
operator|)
name|NULL
argument_list|,
name|update_dir
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|repository
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filedir
argument_list|)
expr_stmt|;
block|}
block|}
name|send_files
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SEND_BUILD_DIRS
operator||
name|SEND_NO_CONTENTS
argument_list|)
expr_stmt|;
name|send_file_names
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|SEND_EXPAND_WILD
argument_list|)
expr_stmt|;
name|send_to_server
argument_list|(
literal|"add\012"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|message
condition|)
name|free
argument_list|(
name|message
argument_list|)
expr_stmt|;
return|return
name|err
operator|+
name|get_responses_and_close
argument_list|()
return|;
block|}
endif|#
directive|endif
comment|/* walk the arg list adding files/dirs */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|int
name|begin_err
init|=
name|err
decl_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
name|int
name|begin_added_files
init|=
name|added_files
decl_stmt|;
endif|#
directive|endif
name|struct
name|file_info
name|finfo
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|memset
argument_list|(
operator|&
name|finfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|finfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|save_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
condition|)
name|error_exit
argument_list|()
expr_stmt|;
name|finfo
operator|.
name|fullname
operator|=
name|xstrdup
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|filename
operator|=
name|xstrdup
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* We know we can discard the const below since we just allocated 	 * filename and can do as we like with it.          */
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|last_component
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|filename
condition|)
block|{
name|finfo
operator|.
name|update_dir
operator|=
literal|""
expr_stmt|;
name|finfo
operator|.
name|file
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
name|p
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|finfo
operator|.
name|update_dir
operator|=
name|filename
expr_stmt|;
name|finfo
operator|.
name|file
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|CVS_CHDIR
argument_list|(
name|finfo
operator|.
name|update_dir
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not chdir to %s"
argument_list|,
name|finfo
operator|.
name|update_dir
argument_list|)
expr_stmt|;
block|}
comment|/* Add wrappers for this directory.  They exist only until 	   the next call to wrap_add_file.  */
name|wrap_add_file
argument_list|(
name|CVSDOTWRAPPER
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|rcs
operator|=
name|NULL
expr_stmt|;
comment|/* Find the repository associated with our current dir.  */
name|repository
operator|=
name|Name_Repository
argument_list|(
name|NULL
argument_list|,
name|finfo
operator|.
name|update_dir
argument_list|)
expr_stmt|;
comment|/* don't add stuff to Emptydir */
if|if
condition|(
name|strncmp
argument_list|(
name|repository
argument_list|,
name|current_parsed_root
operator|->
name|directory
argument_list|,
name|cvsroot_len
argument_list|)
operator|==
literal|0
operator|&&
name|ISDIRSEP
argument_list|(
name|repository
index|[
name|cvsroot_len
index|]
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|repository
operator|+
name|cvsroot_len
operator|+
literal|1
argument_list|,
name|CVSROOTADM
argument_list|,
sizeof|sizeof
name|CVSROOTADM
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|&&
name|ISDIRSEP
argument_list|(
name|repository
index|[
name|cvsroot_len
operator|+
sizeof|sizeof
name|CVSROOTADM
index|]
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|repository
operator|+
name|cvsroot_len
operator|+
sizeof|sizeof
name|CVSROOTADM
operator|+
literal|1
argument_list|,
name|CVSNULLREPOS
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot add to %s"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|entries
operator|=
name|Entries_Open
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|finfo
operator|.
name|repository
operator|=
name|repository
expr_stmt|;
name|finfo
operator|.
name|entries
operator|=
name|entries
expr_stmt|;
comment|/* We pass force_tag_match as 1.  If the directory has a            sticky branch tag, and there is already an RCS file which            does not have that tag, then the head revision is            meaningless to us.  */
name|vers
operator|=
name|Version_TS
argument_list|(
operator|&
name|finfo
argument_list|,
name|options
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vers
operator|->
name|vn_user
operator|==
name|NULL
condition|)
block|{
comment|/* No entry available, ts_rcs is invalid */
if|if
condition|(
name|vers
operator|->
name|vn_rcs
operator|==
name|NULL
condition|)
block|{
comment|/* There is no RCS file either */
if|if
condition|(
name|vers
operator|->
name|ts_user
operator|==
name|NULL
condition|)
block|{
comment|/* There is no user file either */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"nothing known about %s"
argument_list|,
name|finfo
operator|.
name|fullname
argument_list|)
expr_stmt|;
name|err
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|isdir
argument_list|(
name|finfo
operator|.
name|file
argument_list|)
operator|||
name|wrap_name_has
argument_list|(
name|finfo
operator|.
name|file
argument_list|,
name|WRAP_TOCVS
argument_list|)
condition|)
block|{
comment|/* 		     * See if a directory exists in the repository with 		     * the same name.  If so, blow this request off. 		     */
name|char
modifier|*
name|dname
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|repository
argument_list|)
operator|+
name|strlen
argument_list|(
name|finfo
operator|.
name|file
argument_list|)
operator|+
literal|10
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dname
argument_list|,
literal|"%s/%s"
argument_list|,
name|repository
argument_list|,
name|finfo
operator|.
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdir
argument_list|(
name|dname
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot add file `%s' since the directory"
argument_list|,
name|finfo
operator|.
name|fullname
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"`%s' already exists in the repository"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"illegal filename overlap"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|vers
operator|->
name|options
operator|==
name|NULL
operator|||
operator|*
name|vers
operator|->
name|options
operator|==
literal|'\0'
condition|)
block|{
comment|/* No options specified on command line (or in 			   rcs file if it existed, e.g. the file exists 			   on another branch).  Check for a value from 			   the wrapper stuff.  */
if|if
condition|(
name|wrap_name_has
argument_list|(
name|finfo
operator|.
name|file
argument_list|,
name|WRAP_RCSOPTION
argument_list|)
condition|)
block|{
if|if
condition|(
name|vers
operator|->
name|options
condition|)
name|free
argument_list|(
name|vers
operator|->
name|options
argument_list|)
expr_stmt|;
name|vers
operator|->
name|options
operator|=
name|wrap_rcsoption
argument_list|(
name|finfo
operator|.
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|vers
operator|->
name|nonbranch
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot add file on non-branch tag %s"
argument_list|,
name|vers
operator|->
name|tag
argument_list|)
expr_stmt|;
operator|++
name|err
expr_stmt|;
block|}
else|else
block|{
comment|/* There is a user file, so build the entry for it */
if|if
condition|(
name|build_entry
argument_list|(
name|repository
argument_list|,
name|finfo
operator|.
name|file
argument_list|,
name|vers
operator|->
name|options
argument_list|,
name|message
argument_list|,
name|entries
argument_list|,
name|vers
operator|->
name|tag
argument_list|)
operator|!=
literal|0
condition|)
name|err
operator|++
expr_stmt|;
else|else
block|{
name|added_files
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
if|if
condition|(
name|vers
operator|->
name|tag
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"\ scheduling %s `%s' for addition on branch `%s'"
argument_list|,
operator|(
name|wrap_name_has
argument_list|(
name|finfo
operator|.
name|file
argument_list|,
name|WRAP_TOCVS
argument_list|)
condition|?
literal|"wrapper"
else|:
literal|"file"
operator|)
argument_list|,
name|finfo
operator|.
name|fullname
argument_list|,
name|vers
operator|->
name|tag
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"scheduling %s `%s' for addition"
argument_list|,
operator|(
name|wrap_name_has
argument_list|(
name|finfo
operator|.
name|file
argument_list|,
name|WRAP_TOCVS
argument_list|)
condition|?
literal|"wrapper"
else|:
literal|"file"
operator|)
argument_list|,
name|finfo
operator|.
name|fullname
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|RCS_isdead
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|)
condition|)
block|{
if|if
condition|(
name|isdir
argument_list|(
name|finfo
operator|.
name|file
argument_list|)
operator|&&
operator|!
name|wrap_name_has
argument_list|(
name|finfo
operator|.
name|file
argument_list|,
name|WRAP_TOCVS
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"\ the directory `%s' cannot be added because a file of the"
argument_list|,
name|finfo
operator|.
name|fullname
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"\ same name already exists in the repository."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|vers
operator|->
name|nonbranch
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot add file on non-branch tag %s"
argument_list|,
name|vers
operator|->
name|tag
argument_list|)
expr_stmt|;
operator|++
name|err
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|timestamp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|vers
operator|->
name|ts_user
operator|==
name|NULL
condition|)
block|{
comment|/* If this file does not exist locally, assume that 			     * the last version on the branch is being 			     * resurrected. 			     * 			     * Compute previous revision.  We assume that it 			     * exists and that it is not a revision on the 			     * trunk of the form X.1 (1.1, 2.1, 3.1, ...).  We 			     * also assume that it is not dead, which seems 			     * fair since we know vers->vn_rcs is dead 			     * and we shouldn't see two dead revisions in a 			     * row. 			     */
name|char
modifier|*
name|prev
init|=
name|previous_rev
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|)
decl_stmt|;
name|int
name|status
decl_stmt|;
name|assert
argument_list|(
name|prev
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Resurrecting file `%s' from revision %s."
argument_list|,
name|finfo
operator|.
name|fullname
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|status
operator|=
name|RCS_checkout
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|finfo
operator|.
name|file
argument_list|,
name|prev
argument_list|,
name|vers
operator|->
name|tag
argument_list|,
name|vers
operator|->
name|options
argument_list|,
name|RUN_TTY
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xchmod
argument_list|(
name|finfo
operator|.
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Failed to resurrect revision %s"
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|err
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* I don't actually set vers->ts_user here 				 * because it would confuse server_update(). 				 */
name|timestamp
operator|=
name|time_stamp
argument_list|(
name|finfo
operator|.
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|really_quiet
condition|)
name|write_letter
argument_list|(
operator|&
name|finfo
argument_list|,
literal|'U'
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|prev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
if|if
condition|(
name|vers
operator|->
name|tag
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"file `%s' will be added on branch `%s' from version %s"
argument_list|,
name|finfo
operator|.
name|fullname
argument_list|,
name|vers
operator|->
name|tag
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|)
expr_stmt|;
else|else
comment|/* I'm not sure that mentioning 				   vers->vn_rcs makes any sense here; I 				   can't think of a way to word the 				   message which is not confusing.  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Re-adding file `%s' (in place of dead revision %s)."
argument_list|,
name|finfo
operator|.
name|fullname
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|)
expr_stmt|;
block|}
name|Register
argument_list|(
name|entries
argument_list|,
name|finfo
operator|.
name|file
argument_list|,
literal|"0"
argument_list|,
name|timestamp
condition|?
name|timestamp
else|:
name|vers
operator|->
name|ts_user
argument_list|,
name|vers
operator|->
name|options
argument_list|,
name|vers
operator|->
name|tag
argument_list|,
name|vers
operator|->
name|date
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|timestamp
condition|)
name|free
argument_list|(
name|timestamp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
operator|&&
name|vers
operator|->
name|ts_user
operator|==
name|NULL
condition|)
block|{
comment|/* If we resurrected the file from the archive, we 			     * need to tell the client about it. 			     */
name|server_updated
argument_list|(
operator|&
name|finfo
argument_list|,
name|vers
argument_list|,
name|SERVER_UPDATED
argument_list|,
operator|(
name|mode_t
operator|)
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* This is kinda hacky or, at least, it renders the 			     * name "begin_added_files" obsolete, but we want 			     * the added_files to be counted without triggering 			     * the check that causes server_checked_in() to be 			     * called below since we have already called 			     * server_updated() to complete the resurrection. 			     */
operator|++
name|begin_added_files
expr_stmt|;
block|}
endif|#
directive|endif
operator|++
name|added_files
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 		 * There is an RCS file already, so somebody else must've 		 * added it 		 */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s added independently by second party"
argument_list|,
name|finfo
operator|.
name|fullname
argument_list|)
expr_stmt|;
name|err
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|vers
operator|->
name|vn_user
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
name|vers
operator|->
name|vn_user
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* 	     * An entry for a new-born file, ts_rcs is dummy, but that is 	     * inappropriate here 	     */
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s has already been entered"
argument_list|,
name|finfo
operator|.
name|fullname
argument_list|)
expr_stmt|;
name|err
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vers
operator|->
name|vn_user
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
comment|/* An entry for a removed file, ts_rcs is invalid */
if|if
condition|(
name|vers
operator|->
name|ts_user
operator|==
name|NULL
condition|)
block|{
comment|/* There is no user file (as it should be) */
if|if
condition|(
name|vers
operator|->
name|vn_rcs
operator|==
name|NULL
condition|)
block|{
comment|/* 		     * There is no RCS file, so somebody else must've removed 		     * it from under us 		     */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"\ cannot resurrect %s; RCS file removed by second party"
argument_list|,
name|finfo
operator|.
name|fullname
argument_list|)
expr_stmt|;
name|err
operator|++
expr_stmt|;
block|}
else|else
block|{
name|int
name|status
decl_stmt|;
comment|/* 		     * There is an RCS file, so remove the "-" from the 		     * version number and restore the file 		     */
name|char
modifier|*
name|tmp
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|vers
operator|->
name|vn_user
argument_list|)
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tmp
argument_list|,
name|vers
operator|->
name|vn_user
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|vers
operator|->
name|vn_user
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|status
operator|=
name|RCS_checkout
argument_list|(
name|vers
operator|->
name|srcfile
argument_list|,
name|finfo
operator|.
name|file
argument_list|,
name|vers
operator|->
name|vn_user
argument_list|,
name|vers
operator|->
name|tag
argument_list|,
name|vers
operator|->
name|options
argument_list|,
name|RUN_TTY
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xchmod
argument_list|(
name|finfo
operator|.
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Failed to resurrect revision %s"
argument_list|,
name|vers
operator|->
name|vn_user
argument_list|)
expr_stmt|;
name|err
operator|++
expr_stmt|;
name|tmp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* I don't actually set vers->ts_user here because it 			 * would confuse server_update(). 			 */
name|tmp
operator|=
name|time_stamp
argument_list|(
name|finfo
operator|.
name|file
argument_list|)
expr_stmt|;
name|write_letter
argument_list|(
operator|&
name|finfo
argument_list|,
literal|'U'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s, version %s, resurrected"
argument_list|,
name|finfo
operator|.
name|fullname
argument_list|,
name|vers
operator|->
name|vn_user
argument_list|)
expr_stmt|;
block|}
name|Register
argument_list|(
name|entries
argument_list|,
name|finfo
operator|.
name|file
argument_list|,
name|vers
operator|->
name|vn_user
argument_list|,
name|tmp
argument_list|,
name|vers
operator|->
name|options
argument_list|,
name|vers
operator|->
name|tag
argument_list|,
name|vers
operator|->
name|date
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
block|{
comment|/* If we resurrected the file from the archive, we 			 * need to tell the client about it. 			 */
name|server_updated
argument_list|(
operator|&
name|finfo
argument_list|,
name|vers
argument_list|,
name|SERVER_UPDATED
argument_list|,
operator|(
name|mode_t
operator|)
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* We don't increment added_files here because this isn't 		    * a change that needs to be committed. 		    */
endif|#
directive|endif
block|}
block|}
else|else
block|{
comment|/* The user file shouldn't be there */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"\ %s should be removed and is still there (or is back again)"
argument_list|,
name|finfo
operator|.
name|fullname
argument_list|)
expr_stmt|;
name|err
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* A normal entry, ts_rcs is valid, so it must already be there */
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s already exists, with version number %s"
argument_list|,
name|finfo
operator|.
name|fullname
argument_list|,
name|vers
operator|->
name|vn_user
argument_list|)
expr_stmt|;
name|err
operator|++
expr_stmt|;
block|}
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
comment|/* passed all the checks.  Go ahead and add it if its a directory */
if|if
condition|(
name|begin_err
operator|==
name|err
operator|&&
name|isdir
argument_list|(
name|finfo
operator|.
name|file
argument_list|)
operator|&&
operator|!
name|wrap_name_has
argument_list|(
name|finfo
operator|.
name|file
argument_list|,
name|WRAP_TOCVS
argument_list|)
condition|)
block|{
name|err
operator|+=
name|add_directory
argument_list|(
operator|&
name|finfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
operator|&&
name|begin_added_files
operator|!=
name|added_files
condition|)
name|server_checked_in
argument_list|(
name|finfo
operator|.
name|file
argument_list|,
name|finfo
operator|.
name|update_dir
argument_list|,
name|repository
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|free
argument_list|(
name|repository
argument_list|)
expr_stmt|;
name|Entries_Close
argument_list|(
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|restore_cwd
argument_list|(
operator|&
name|cwd
argument_list|,
name|NULL
argument_list|)
condition|)
name|error_exit
argument_list|()
expr_stmt|;
name|free_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
expr_stmt|;
comment|/* It's okay to discard the const to free this - we allocated this 	 * above.  The const is for everybody else. 	 */
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|finfo
operator|.
name|fullname
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|filename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|added_files
operator|&&
operator|!
name|really_quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"use '%s commit' to add %s permanently"
argument_list|,
name|program_name
argument_list|,
operator|(
name|added_files
operator|==
literal|1
operator|)
condition|?
literal|"this file"
else|:
literal|"these files"
argument_list|)
expr_stmt|;
if|if
condition|(
name|message
condition|)
name|free
argument_list|(
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
condition|)
name|free
argument_list|(
name|options
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The specified user file is really a directory.  So, let's make sure that  * it is created in the RCS source repository, and that the user's directory  * is updated to include a CVS directory.  *   * Returns 1 on failure, 0 on success.  */
end_comment

begin_function
specifier|static
name|int
name|add_directory
parameter_list|(
name|finfo
parameter_list|)
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|repository
init|=
name|finfo
operator|->
name|repository
decl_stmt|;
name|List
modifier|*
name|entries
init|=
name|finfo
operator|->
name|entries
decl_stmt|;
specifier|const
name|char
modifier|*
name|dir
init|=
name|finfo
operator|->
name|file
decl_stmt|;
name|char
modifier|*
name|rcsdir
init|=
name|NULL
decl_stmt|;
name|struct
name|saved_cwd
name|cwd
decl_stmt|;
name|char
modifier|*
name|message
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|,
modifier|*
name|date
decl_stmt|;
name|int
name|nonbranch
decl_stmt|;
name|char
modifier|*
name|attrs
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|dir
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* "Can't happen".  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"directory %s not added; must be a direct sub-directory"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|fncmp
argument_list|(
name|dir
argument_list|,
name|CVSADM
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"cannot add a `%s' directory"
argument_list|,
name|CVSADM
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* before we do anything else, see if we have any per-directory tags */
name|ParseTag
argument_list|(
operator|&
name|tag
argument_list|,
operator|&
name|date
argument_list|,
operator|&
name|nonbranch
argument_list|)
expr_stmt|;
comment|/* Remember the default attributes from this directory, so we can apply        them to the new directory.  */
name|fileattr_startdir
argument_list|(
name|repository
argument_list|)
expr_stmt|;
name|attrs
operator|=
name|fileattr_getall
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|fileattr_free
argument_list|()
expr_stmt|;
comment|/* now, remember where we were, so we can get back */
if|if
condition|(
name|save_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|CVS_CHDIR
argument_list|(
name|dir
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot chdir to %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
operator|!
name|server_active
operator|&&
name|isfile
argument_list|(
name|CVSADM
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
name|isfile
argument_list|(
name|CVSADM
argument_list|)
condition|)
endif|#
directive|endif
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s/%s already exists"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|,
name|CVSADM
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|rcsdir
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|repository
argument_list|)
operator|+
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|rcsdir
argument_list|,
literal|"%s/%s"
argument_list|,
name|repository
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|isfile
argument_list|(
name|rcsdir
argument_list|)
operator|&&
operator|!
name|isdir
argument_list|(
name|rcsdir
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"%s is not a directory; %s not added"
argument_list|,
name|rcsdir
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* setup the log message */
name|message
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|rcsdir
argument_list|)
operator|+
literal|80
operator|+
operator|(
name|tag
operator|==
name|NULL
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|tag
argument_list|)
operator|+
literal|80
operator|)
operator|+
operator|(
name|date
operator|==
name|NULL
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|date
argument_list|)
operator|+
literal|80
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"Directory %s added to the repository\n"
argument_list|,
name|rcsdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
condition|)
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|message
argument_list|,
literal|"--> Using per-directory sticky tag `"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|message
argument_list|,
name|tag
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|message
argument_list|,
literal|"'\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|date
condition|)
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|message
argument_list|,
literal|"--> Using per-directory sticky date `"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|message
argument_list|,
name|date
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|message
argument_list|,
literal|"'\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isdir
argument_list|(
name|rcsdir
argument_list|)
condition|)
block|{
name|mode_t
name|omask
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
name|List
modifier|*
name|ulist
decl_stmt|;
name|struct
name|logfile_info
modifier|*
name|li
decl_stmt|;
comment|/* There used to be some code here which would prompt for 	   whether to add the directory.  The details of that code had 	   bitrotted, but more to the point it can't work 	   client/server, doesn't ask in the right way for GUIs, etc. 	   A better way of making it harder to accidentally add 	   directories would be to have to add and commit directories 	   like for files.  The code was #if 0'd at least since CVS 1.5.  */
if|if
condition|(
operator|!
name|noexec
condition|)
block|{
name|omask
operator|=
name|umask
argument_list|(
name|cvsumask
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVS_MKDIR
argument_list|(
name|rcsdir
argument_list|,
literal|0777
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot mkdir %s"
argument_list|,
name|rcsdir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
operator|(
name|void
operator|)
name|umask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
block|}
comment|/* Now set the default file attributes to the ones we inherited 	   from the parent directory.  */
name|fileattr_startdir
argument_list|(
name|rcsdir
argument_list|)
expr_stmt|;
name|fileattr_setall
argument_list|(
name|NULL
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
name|fileattr_write
argument_list|()
expr_stmt|;
name|fileattr_free
argument_list|()
expr_stmt|;
if|if
condition|(
name|attrs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|attrs
argument_list|)
expr_stmt|;
comment|/* 	 * Set up an update list with a single title node for Update_Logfile 	 */
name|ulist
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|UPDATE
expr_stmt|;
name|p
operator|->
name|delproc
operator|=
name|update_delproc
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
literal|"- New directory"
argument_list|)
expr_stmt|;
name|li
operator|=
operator|(
expr|struct
name|logfile_info
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|logfile_info
argument_list|)
argument_list|)
expr_stmt|;
name|li
operator|->
name|type
operator|=
name|T_TITLE
expr_stmt|;
name|li
operator|->
name|tag
operator|=
name|xstrdup
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|li
operator|->
name|rev_old
operator|=
name|li
operator|->
name|rev_new
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|data
operator|=
name|li
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|ulist
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|Update_Logfile
argument_list|(
name|rcsdir
argument_list|,
name|message
argument_list|,
operator|(
name|FILE
operator|*
operator|)
name|NULL
argument_list|,
name|ulist
argument_list|)
expr_stmt|;
name|dellist
argument_list|(
operator|&
name|ulist
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
operator|!
name|server_active
condition|)
endif|#
directive|endif
name|Create_Admin
argument_list|(
literal|"."
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|,
name|rcsdir
argument_list|,
name|tag
argument_list|,
name|date
argument_list|,
name|nonbranch
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
condition|)
name|free
argument_list|(
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|date
condition|)
name|free
argument_list|(
name|date
argument_list|)
expr_stmt|;
if|if
condition|(
name|restore_cwd
argument_list|(
operator|&
name|cwd
argument_list|,
name|NULL
argument_list|)
condition|)
name|error_exit
argument_list|()
expr_stmt|;
name|free_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
expr_stmt|;
name|Subdir_Register
argument_list|(
name|entries
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|really_quiet
condition|)
name|cvs_output
argument_list|(
name|message
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rcsdir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|message
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|out
label|:
if|if
condition|(
name|restore_cwd
argument_list|(
operator|&
name|cwd
argument_list|,
name|NULL
argument_list|)
condition|)
name|error_exit
argument_list|()
expr_stmt|;
name|free_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcsdir
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rcsdir
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Builds an entry for a new file and sets up "CVS/file",[pt] by  * interrogating the user.  Returns non-zero on error.  */
end_comment

begin_function
specifier|static
name|int
name|build_entry
parameter_list|(
name|repository
parameter_list|,
name|user
parameter_list|,
name|options
parameter_list|,
name|message
parameter_list|,
name|entries
parameter_list|,
name|tag
parameter_list|)
specifier|const
name|char
modifier|*
name|repository
decl_stmt|;
specifier|const
name|char
modifier|*
name|user
decl_stmt|;
specifier|const
name|char
modifier|*
name|options
decl_stmt|;
specifier|const
name|char
modifier|*
name|message
decl_stmt|;
name|List
modifier|*
name|entries
decl_stmt|;
specifier|const
name|char
modifier|*
name|tag
decl_stmt|;
block|{
name|char
modifier|*
name|fname
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|noexec
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*      * The requested log is read directly from the user and stored in the      * file user,t.  If the "message" argument is set, use it as the      * initial creation log (which typically describes the file).      */
name|fname
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|user
argument_list|)
operator|+
literal|80
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fname
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|CVSADM
argument_list|,
name|user
argument_list|,
name|CVSEXT_LOG
argument_list|)
expr_stmt|;
name|fp
operator|=
name|open_file
argument_list|(
name|fname
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|message
operator|&&
name|fputs
argument_list|(
name|message
argument_list|,
name|fp
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot write to %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
comment|/*      * Create the entry now, since this allows the user to interrupt us above      * without needing to clean anything up (well, we could clean up the      * ,t file, but who cares).      */
name|line
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|user
argument_list|)
operator|+
literal|20
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"Initial %s"
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|Register
argument_list|(
name|entries
argument_list|,
name|user
argument_list|,
literal|"0"
argument_list|,
name|line
argument_list|,
name|options
argument_list|,
name|tag
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

