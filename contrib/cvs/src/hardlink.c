begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.  */
end_comment

begin_comment
comment|/* Collect and manage hardlink info associated with a particular file.  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"hardlink.h"
end_include

begin_comment
comment|/* The structure currently used to manage hardlink info is a list.    Therefore, most of the functions which manipulate hardlink data    are walklist procedures.  This is not a very efficient implementation;    if someone decides to use a real hash table (for instance), then    much of this code can be rewritten to be a little less arcane.     Each element of `hardlist' represents an inode.  It is keyed on the    inode number, and points to a list of files.  This is to make it    easy to find out what files are linked to a given file FOO: find    FOO's inode, look it up in hardlist, and retrieve the list of files    associated with that inode.     Each file node, in turn, is represented by a `hardlink_info' struct,    which includes `status' and `links' fields.  The `status' field should    be used by a procedure like commit_fileproc or update_fileproc to    record each file's status; that way, after all file links have been    recorded, CVS can check the linkage of files which are in doubt    (i.e. T_NEEDS_MERGE files).     TODO: a diagram of an example hardlist would help here. */
end_comment

begin_comment
comment|/* TODO: change this to something with a marginal degree of    efficiency, like maybe a hash table.  Yeah. */
end_comment

begin_decl_stmt
name|List
modifier|*
name|hardlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record hardlink information for working files */
end_comment

begin_decl_stmt
name|char
modifier|*
name|working_dir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The top-level working directory, used for 			   constructing full pathnames. */
end_comment

begin_comment
comment|/* For check_link_proc: list all of the files named in an inode list. */
end_comment

begin_function
specifier|static
name|int
name|list_files_proc
parameter_list|(
name|node
parameter_list|,
name|vstrp
parameter_list|)
name|Node
modifier|*
name|node
decl_stmt|;
name|void
modifier|*
name|vstrp
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|strp
decl_stmt|,
modifier|*
name|file
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* Get the file's basename.  This is because -- VERY IMPORTANT --        the `hardlinks' field is presently defined only to include links        within a directory.  So the hardlinks field might be `foo' or        `mumble grump flink', but not `foo bar com/baz' or `wham ../bam        ../thank/you'.  Someday it would be nice to extend this to        permit cross-directory links, but the issues involved are        hideous. */
name|file
operator|=
name|strrchr
argument_list|(
name|node
operator|->
name|key
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
condition|)
operator|++
name|file
expr_stmt|;
else|else
name|file
operator|=
name|node
operator|->
name|key
expr_stmt|;
comment|/* Is it safe to cast vstrp to (char **) here, and then play with        the contents?  I think so, since vstrp will have started out        a char ** to begin with, so we should not have alignment bugs. */
name|strp
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|vstrp
expr_stmt|;
name|len
operator|=
operator|(
operator|*
name|strp
operator|==
name|NULL
condition|?
literal|0
else|:
name|strlen
argument_list|(
operator|*
name|strp
argument_list|)
operator|)
expr_stmt|;
operator|*
name|strp
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
operator|*
name|strp
argument_list|,
name|len
operator|+
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|strp
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"could not allocate memory"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|sprintf
argument_list|(
operator|*
name|strp
operator|+
name|len
argument_list|,
literal|"%s "
argument_list|,
name|file
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"could not compile file list"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Set the link field of each hardlink_info node to `data', which is a    list of linked files. */
end_comment

begin_function
specifier|static
name|int
name|set_hardlink_field_proc
parameter_list|(
name|node
parameter_list|,
name|data
parameter_list|)
name|Node
modifier|*
name|node
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|hardlink_info
modifier|*
name|hlinfo
init|=
operator|(
expr|struct
name|hardlink_info
operator|*
operator|)
name|node
operator|->
name|data
decl_stmt|;
name|hlinfo
operator|->
name|links
operator|=
name|xstrdup
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* For each file being checked in, compile a list of the files linked    to it, and cache the list in the file's hardlink_info field. */
end_comment

begin_function
name|int
name|cache_hardlinks_proc
parameter_list|(
name|node
parameter_list|,
name|data
parameter_list|)
name|Node
modifier|*
name|node
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|List
modifier|*
name|inode_links
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|linked_files
init|=
name|NULL
decl_stmt|;
name|int
name|err
decl_stmt|;
name|inode_links
operator|=
operator|(
name|List
operator|*
operator|)
name|node
operator|->
name|data
expr_stmt|;
comment|/* inode->data is a list of hardlink_info structures: all the        files linked to this inode.  We compile a string of each file        named in this list, in alphabetical order, separated by spaces.        Then store this string in the `links' field of each        hardlink_info structure, so that RCS_checkin can easily add        it to the `hardlinks' field of a new delta node. */
name|sortlist
argument_list|(
name|inode_links
argument_list|,
name|fsortcmp
argument_list|)
expr_stmt|;
name|err
operator|=
name|walklist
argument_list|(
name|inode_links
argument_list|,
name|list_files_proc
argument_list|,
operator|&
name|linked_files
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
comment|/* Trim trailing whitespace. */
name|p
operator|=
name|linked_files
operator|+
name|strlen
argument_list|(
name|linked_files
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|p
operator|>
name|linked_files
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|--
operator|=
literal|'\0'
expr_stmt|;
name|err
operator|=
name|walklist
argument_list|(
name|inode_links
argument_list|,
name|set_hardlink_field_proc
argument_list|,
name|linked_files
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to FILEPATH's node in the hardlist.  This means    looking up its inode, retrieving the list of files linked to that    inode, and then looking up FILE in that list.  If the file doesn't    seem to exist, return NULL. */
end_comment

begin_function
name|Node
modifier|*
name|lookup_file_by_inode
parameter_list|(
name|filepath
parameter_list|)
specifier|const
name|char
modifier|*
name|filepath
decl_stmt|;
block|{
name|char
modifier|*
name|inodestr
decl_stmt|,
modifier|*
name|file
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|Node
modifier|*
name|hp
decl_stmt|,
modifier|*
name|p
decl_stmt|;
comment|/* Get file's basename, so that we can stat it. */
name|file
operator|=
name|strrchr
argument_list|(
name|filepath
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
condition|)
operator|++
name|file
expr_stmt|;
else|else
name|file
operator|=
operator|(
name|char
operator|*
operator|)
name|filepath
expr_stmt|;
comment|/* inodestr contains the hexadecimal representation of an        inode, so it requires two bytes of text to represent        each byte of the inode number. */
name|inodestr
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|ino_t
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
comment|/* The file doesn't exist; we may be doing an update on a 	       file that's been removed.  A nonexistent file has no 	       link information, so return without changing hardlist. */
name|free
argument_list|(
name|inodestr
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot stat %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|inodestr
argument_list|,
literal|"%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sb
operator|.
name|st_ino
argument_list|)
expr_stmt|;
comment|/* Find out if this inode is already in the hardlist, adding        a new entry to the list if not. */
name|hp
operator|=
name|findnode
argument_list|(
name|hardlist
argument_list|,
name|inodestr
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
name|hp
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|hp
operator|->
name|type
operator|=
name|UNKNOWN
expr_stmt|;
name|hp
operator|->
name|key
operator|=
name|inodestr
expr_stmt|;
name|hp
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|getlist
argument_list|()
expr_stmt|;
name|hp
operator|->
name|delproc
operator|=
name|dellist
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|hardlist
argument_list|,
name|hp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|inodestr
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|findnode
argument_list|(
operator|(
name|List
operator|*
operator|)
name|hp
operator|->
name|data
argument_list|,
name|filepath
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|UNKNOWN
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|filepath
argument_list|)
expr_stmt|;
name|p
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
operator|(
name|List
operator|*
operator|)
name|hp
operator|->
name|data
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* After a file has been checked out, add a node for it to the hardlist    (if necessary) and mark it as checked out. */
end_comment

begin_function
name|void
name|update_hardlink_info
parameter_list|(
name|file
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|char
modifier|*
name|path
decl_stmt|;
name|Node
modifier|*
name|n
decl_stmt|;
name|struct
name|hardlink_info
modifier|*
name|hlinfo
decl_stmt|;
if|if
condition|(
name|file
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|path
operator|=
name|xstrdup
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* file is a relative pathname; assume it's from the current 	   working directory. */
name|char
modifier|*
name|dir
init|=
name|xgetwd
argument_list|()
decl_stmt|;
name|path
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
operator|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|path
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
name|lookup_file_by_inode
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
comment|/* Something is *really* wrong if the file doesn't exist here; 	   update_hardlink_info should be called only when a file has 	   just been checked out to a working directory. */
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"lost hardlink info for %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|->
name|data
operator|==
name|NULL
condition|)
name|n
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hardlink_info
argument_list|)
argument_list|)
expr_stmt|;
name|hlinfo
operator|=
operator|(
expr|struct
name|hardlink_info
operator|*
operator|)
name|n
operator|->
name|data
expr_stmt|;
name|hlinfo
operator|->
name|status
operator|=
name|T_UPTODATE
expr_stmt|;
name|hlinfo
operator|->
name|checked_out
operator|=
literal|1
expr_stmt|;
name|hlinfo
operator|->
name|links
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a string listing all the files known to be linked to FILE in    the working directory.  Used by special_file_mismatch, to determine    whether it is safe to merge two files. */
end_comment

begin_function
name|char
modifier|*
name|list_files_linked_to
parameter_list|(
name|file
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|char
modifier|*
name|inodestr
decl_stmt|,
modifier|*
name|filelist
decl_stmt|,
modifier|*
name|path
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|Node
modifier|*
name|n
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* If hardlist is NULL, we have not been doing an operation that        would permit us to know anything about the file's hardlinks        (cvs update, cvs commit, etc).  Return an empty string. */
if|if
condition|(
name|hardlist
operator|==
name|NULL
condition|)
return|return
name|xstrdup
argument_list|(
literal|""
argument_list|)
return|;
comment|/* Get the full pathname of file (assuming the working directory) */
if|if
condition|(
name|file
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|path
operator|=
name|xstrdup
argument_list|(
name|file
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|dir
init|=
name|xgetwd
argument_list|()
decl_stmt|;
name|path
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
operator|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|path
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
comment|/* We do an extra lookup_file here just to make sure that there        is a node for `path' in the hardlist.  If that were not so,        comparing the working directory linkage against the repository        linkage for a file would always fail. */
operator|(
name|void
operator|)
name|lookup_file_by_inode
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot stat %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* inodestr contains the hexadecimal representation of an        inode, so it requires two bytes of text to represent        each byte of the inode number. */
name|inodestr
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|ino_t
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|inodestr
argument_list|,
literal|"%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sb
operator|.
name|st_ino
argument_list|)
expr_stmt|;
comment|/* Make sure the files linked to this inode are sorted. */
name|n
operator|=
name|findnode
argument_list|(
name|hardlist
argument_list|,
name|inodestr
argument_list|)
expr_stmt|;
name|sortlist
argument_list|(
operator|(
name|List
operator|*
operator|)
name|n
operator|->
name|data
argument_list|,
name|fsortcmp
argument_list|)
expr_stmt|;
name|filelist
operator|=
name|NULL
expr_stmt|;
name|err
operator|=
name|walklist
argument_list|(
operator|(
name|List
operator|*
operator|)
name|n
operator|->
name|data
argument_list|,
name|list_files_proc
argument_list|,
operator|&
name|filelist
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"cannot get list of hardlinks for %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|inodestr
argument_list|)
expr_stmt|;
return|return
name|filelist
return|;
block|}
end_function

end_unit

