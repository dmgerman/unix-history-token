begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.  */
end_comment

begin_comment
comment|/* Collect and manage hardlink info associated with a particular file.  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"hardlink.h"
end_include

begin_comment
comment|/* The structure currently used to manage hardlink info is a list.    Therefore, most of the functions which manipulate hardlink data    are walklist procedures.  This is not a very efficient implementation;    if someone decides to use a real hash table (for instance), then    much of this code can be rewritten to be a little less arcane.     Each element of `hardlist' represents an inode.  It is keyed on the    inode number, and points to a list of files.  This is to make it    easy to find out what files are linked to a given file FOO: find    FOO's inode, look it up in hardlist, and retrieve the list of files    associated with that inode.     Each file node, in turn, is represented by a `hardlink_info' struct,    which includes `status' and `links' fields.  The `status' field should    be used by a procedure like commit_fileproc or update_fileproc to    record each file's status; that way, after all file links have been    recorded, CVS can check the linkage of files which are in doubt    (i.e. T_NEEDS_MERGE files).     TODO: a diagram of an example hardlist would help here. */
end_comment

begin_comment
comment|/* TODO: change this to something with a marginal degree of    efficiency, like maybe a hash table.  Yeah. */
end_comment

begin_decl_stmt
name|List
modifier|*
name|hardlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record hardlink information for working files */
end_comment

begin_decl_stmt
name|char
modifier|*
name|working_dir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The top-level working directory, used for 			   constructing full pathnames. */
end_comment

begin_comment
comment|/* Return a pointer to FILEPATH's node in the hardlist.  This means    looking up its inode, retrieving the list of files linked to that    inode, and then looking up FILE in that list.  If the file doesn't    seem to exist, return NULL. */
end_comment

begin_function
name|Node
modifier|*
name|lookup_file_by_inode
parameter_list|(
name|filepath
parameter_list|)
specifier|const
name|char
modifier|*
name|filepath
decl_stmt|;
block|{
name|char
modifier|*
name|inodestr
decl_stmt|,
modifier|*
name|file
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|Node
modifier|*
name|hp
decl_stmt|,
modifier|*
name|p
decl_stmt|;
comment|/* Get file's basename, so that we can stat it. */
name|file
operator|=
name|strrchr
argument_list|(
name|filepath
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
condition|)
operator|++
name|file
expr_stmt|;
else|else
name|file
operator|=
operator|(
name|char
operator|*
operator|)
name|filepath
expr_stmt|;
comment|/* inodestr contains the hexadecimal representation of an        inode, so it requires two bytes of text to represent        each byte of the inode number. */
name|inodestr
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|ino_t
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
block|{
comment|/* The file doesn't exist; we may be doing an update on a 	       file that's been removed.  A nonexistent file has no 	       link information, so return without changing hardlist. */
name|free
argument_list|(
name|inodestr
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot stat %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|inodestr
argument_list|,
literal|"%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sb
operator|.
name|st_ino
argument_list|)
expr_stmt|;
comment|/* Find out if this inode is already in the hardlist, adding        a new entry to the list if not. */
name|hp
operator|=
name|findnode
argument_list|(
name|hardlist
argument_list|,
name|inodestr
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
name|hp
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|hp
operator|->
name|type
operator|=
name|NT_UNKNOWN
expr_stmt|;
name|hp
operator|->
name|key
operator|=
name|inodestr
expr_stmt|;
name|hp
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|getlist
argument_list|()
expr_stmt|;
name|hp
operator|->
name|delproc
operator|=
name|dellist
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|hardlist
argument_list|,
name|hp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|inodestr
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|findnode
argument_list|(
operator|(
name|List
operator|*
operator|)
name|hp
operator|->
name|data
argument_list|,
name|filepath
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|NT_UNKNOWN
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|filepath
argument_list|)
expr_stmt|;
name|p
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
operator|(
name|List
operator|*
operator|)
name|hp
operator|->
name|data
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* After a file has been checked out, add a node for it to the hardlist    (if necessary) and mark it as checked out. */
end_comment

begin_function
name|void
name|update_hardlink_info
parameter_list|(
name|file
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|char
modifier|*
name|path
decl_stmt|;
name|Node
modifier|*
name|n
decl_stmt|;
name|struct
name|hardlink_info
modifier|*
name|hlinfo
decl_stmt|;
if|if
condition|(
name|file
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|path
operator|=
name|xstrdup
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* file is a relative pathname; assume it's from the current 	   working directory. */
name|char
modifier|*
name|dir
init|=
name|xgetwd
argument_list|()
decl_stmt|;
name|path
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|path
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
name|lookup_file_by_inode
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
comment|/* Something is *really* wrong if the file doesn't exist here; 	   update_hardlink_info should be called only when a file has 	   just been checked out to a working directory. */
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"lost hardlink info for %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|->
name|data
operator|==
name|NULL
condition|)
name|n
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hardlink_info
argument_list|)
argument_list|)
expr_stmt|;
name|hlinfo
operator|=
operator|(
expr|struct
name|hardlink_info
operator|*
operator|)
name|n
operator|->
name|data
expr_stmt|;
name|hlinfo
operator|->
name|status
operator|=
name|T_UPTODATE
expr_stmt|;
name|hlinfo
operator|->
name|checked_out
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a List with all the files known to be linked to FILE in    the working directory.  Used by special_file_mismatch, to determine    whether it is safe to merge two files.     FIXME: What is the memory allocation for the return value?  We seem    to sometimes allocate a new list (getlist() call below) and sometimes    return an existing list (where we return n->data).  */
end_comment

begin_function
name|List
modifier|*
name|list_linked_files_on_disk
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|char
modifier|*
name|inodestr
decl_stmt|,
modifier|*
name|path
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|Node
modifier|*
name|n
decl_stmt|;
comment|/* If hardlist is NULL, we have not been doing an operation that        would permit us to know anything about the file's hardlinks        (cvs update, cvs commit, etc).  Return an empty list. */
if|if
condition|(
name|hardlist
operator|==
name|NULL
condition|)
return|return
name|getlist
argument_list|()
return|;
comment|/* Get the full pathname of file (assuming the working directory) */
if|if
condition|(
name|file
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|path
operator|=
name|xstrdup
argument_list|(
name|file
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|dir
init|=
name|xgetwd
argument_list|()
decl_stmt|;
name|path
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|path
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
comment|/* We do an extra lookup_file here just to make sure that there        is a node for `path' in the hardlist.  If that were not so,        comparing the working directory linkage against the repository        linkage for a file would always fail. */
operator|(
name|void
operator|)
name|lookup_file_by_inode
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot stat %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* inodestr contains the hexadecimal representation of an        inode, so it requires two bytes of text to represent        each byte of the inode number. */
name|inodestr
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|ino_t
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|inodestr
argument_list|,
literal|"%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sb
operator|.
name|st_ino
argument_list|)
expr_stmt|;
comment|/* Make sure the files linked to this inode are sorted. */
name|n
operator|=
name|findnode
argument_list|(
name|hardlist
argument_list|,
name|inodestr
argument_list|)
expr_stmt|;
name|sortlist
argument_list|(
operator|(
name|List
operator|*
operator|)
name|n
operator|->
name|data
argument_list|,
name|fsortcmp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|inodestr
argument_list|)
expr_stmt|;
return|return
operator|(
name|List
operator|*
operator|)
name|n
operator|->
name|data
return|;
block|}
end_function

begin_comment
comment|/* Compare the files in the `key' fields of two lists, returning 1 if    the lists are equivalent and 0 otherwise.     Only the basenames of each file are compared. This is an awful hack    that exists because list_linked_files_on_disk returns full paths    and the `hardlinks' structure of a RCSVers node contains only    basenames.  That in turn is a result of the awful hack that only    basenames are stored in the RCS file.  If anyone ever solves the    problem of correctly managing cross-directory hardlinks, this    function (along with most functions in this file) must be fixed. */
end_comment

begin_function
name|int
name|compare_linkage_lists
parameter_list|(
name|links1
parameter_list|,
name|links2
parameter_list|)
name|List
modifier|*
name|links1
decl_stmt|;
name|List
modifier|*
name|links2
decl_stmt|;
block|{
name|Node
modifier|*
name|n1
decl_stmt|,
modifier|*
name|n2
decl_stmt|;
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|sortlist
argument_list|(
name|links1
argument_list|,
name|fsortcmp
argument_list|)
expr_stmt|;
name|sortlist
argument_list|(
name|links2
argument_list|,
name|fsortcmp
argument_list|)
expr_stmt|;
name|n1
operator|=
name|links1
operator|->
name|list
operator|->
name|next
expr_stmt|;
name|n2
operator|=
name|links2
operator|->
name|list
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|n1
operator|!=
name|links1
operator|->
name|list
operator|&&
name|n2
operator|!=
name|links2
operator|->
name|list
condition|)
block|{
comment|/* Get the basenames of both files. */
name|p1
operator|=
name|strrchr
argument_list|(
name|n1
operator|->
name|key
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|==
name|NULL
condition|)
name|p1
operator|=
name|n1
operator|->
name|key
expr_stmt|;
else|else
operator|++
name|p1
expr_stmt|;
name|p2
operator|=
name|strrchr
argument_list|(
name|n2
operator|->
name|key
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2
operator|==
name|NULL
condition|)
name|p2
operator|=
name|n2
operator|->
name|key
expr_stmt|;
else|else
operator|++
name|p2
expr_stmt|;
comment|/* Compare the files' basenames. */
if|if
condition|(
name|strcmp
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|n1
operator|=
name|n1
operator|->
name|next
expr_stmt|;
name|n2
operator|=
name|n2
operator|->
name|next
expr_stmt|;
block|}
comment|/* At this point we should be at the end of both lists; if not,        one file has more links than the other, and return 1. */
return|return
operator|(
name|n1
operator|==
name|links1
operator|->
name|list
operator|&&
name|n2
operator|==
name|links2
operator|->
name|list
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find a checked-out file in a list of filenames.  Used by RCS_checkout    when checking out a new hardlinked file, to decide whether this file    can be linked to any others that already exist.  The return value    is not currently used. */
end_comment

begin_function
name|int
name|find_checkedout_proc
parameter_list|(
name|node
parameter_list|,
name|data
parameter_list|)
name|Node
modifier|*
name|node
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|Node
modifier|*
modifier|*
name|uptodate
init|=
operator|(
name|Node
operator|*
operator|*
operator|)
name|data
decl_stmt|;
name|Node
modifier|*
name|link
decl_stmt|;
name|char
modifier|*
name|dir
init|=
name|xgetwd
argument_list|()
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|struct
name|hardlink_info
modifier|*
name|hlinfo
decl_stmt|;
comment|/* If we have already found a file, don't do anything. */
if|if
condition|(
operator|*
name|uptodate
operator|!=
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Look at this file in the hardlist and see whether the checked_out        field is 1, meaning that it has been checked out during this CVS run. */
name|path
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
name|strlen
argument_list|(
name|node
operator|->
name|key
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|path
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|node
operator|->
name|key
argument_list|)
expr_stmt|;
name|link
operator|=
name|lookup_file_by_inode
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
operator|==
name|NULL
condition|)
block|{
comment|/* We haven't seen this file -- maybe it hasn't been checked 	   out yet at all. */
return|return
literal|0
return|;
block|}
name|hlinfo
operator|=
operator|(
expr|struct
name|hardlink_info
operator|*
operator|)
name|link
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|hlinfo
operator|->
name|checked_out
condition|)
block|{
comment|/* This file has been checked out recently, so it's safe to            link to it. */
operator|*
name|uptodate
operator|=
name|link
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

