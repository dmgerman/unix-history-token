begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"watch.h"
end_include

begin_include
include|#
directive|include
file|"edit.h"
end_include

begin_include
include|#
directive|include
file|"fileattr.h"
end_include

begin_include
include|#
directive|include
file|"getline.h"
end_include

begin_include
include|#
directive|include
file|"buffer.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SERVER_SUPPORT
argument_list|)
operator|||
name|defined
argument_list|(
name|CLIENT_SUPPORT
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GSSAPI
end_ifdef

begin_comment
comment|/* This stuff isn't included solely with SERVER_SUPPORT since some of these  * functions (encryption& the like) get compiled with or without server  * support.  *  * FIXME - They should be in a different file.  */
end_comment

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|"xgssapi.h"
end_include

begin_comment
comment|/* We use Kerberos 5 routines to map the GSSAPI credential to a user    name.  */
end_comment

begin_include
include|#
directive|include
file|<krb5.h>
end_include

begin_comment
comment|/* We need this to wrap data.  */
end_comment

begin_decl_stmt
specifier|static
name|gss_ctx_id_t
name|gcontext
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gserver_authenticate_connection
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether we are already wrapping GSSAPI communication.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cvs_gssapi_wrapping
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ENCRYPTION
end_ifdef

begin_comment
comment|/* Whether to encrypt GSSAPI communication.  We use a global variable    like this because we use the same buffer type (gssapi_wrap) to    handle both authentication and encryption, and we don't want    multiple instances of that buffer in the communication stream.  */
end_comment

begin_decl_stmt
name|int
name|cvs_gssapi_encrypt
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_GSSAPI */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(SERVER_SUPPORT) || defined(CLIENT_SUPPORT) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_WINSOCK_H
end_ifdef

begin_include
include|#
directive|include
file|<winsock.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|AUTH_SERVER_SUPPORT
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_KERBEROS
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_GSSAPI
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYSLOG_H
end_ifdef

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|LOG_DAEMON
end_ifndef

begin_comment
comment|/* for ancient syslogs */
end_comment

begin_define
define|#
directive|define
name|LOG_DAEMON
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_KERBEROS
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<krb.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_KRB_GET_ERR_TEXT
end_ifndef

begin_define
define|#
directive|define
name|krb_get_err_text
parameter_list|(
name|status
parameter_list|)
value|krb_err_txt[status]
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Information we need if we are going to use Kerberos encryption.  */
end_comment

begin_decl_stmt
specifier|static
name|C_Block
name|kblock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Key_schedule
name|sched
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* for select */
end_comment

begin_include
include|#
directive|include
file|"xselect.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|O_NONBLOCK
end_ifndef

begin_define
define|#
directive|define
name|O_NONBLOCK
value|O_NDELAY
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EWOULDBLOCK is not defined by POSIX, but some BSD systems will    return it, rather than EAGAIN, for nonblocking writes.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EWOULDBLOCK
end_ifdef

begin_define
define|#
directive|define
name|blocking_error
parameter_list|(
name|err
parameter_list|)
value|((err) == EWOULDBLOCK || (err) == EAGAIN)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|blocking_error
parameter_list|(
name|err
parameter_list|)
value|((err) == EAGAIN)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* For initgroups().  */
end_comment

begin_if
if|#
directive|if
name|HAVE_INITGROUPS
end_if

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_INITGROUPS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AUTH_SERVER_SUPPORT
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GETSPNAM
end_ifdef

begin_include
include|#
directive|include
file|<shadow.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The cvs username sent by the client, which might or might not be    the same as the system username the server eventually switches to    run as.  CVS_Username gets set iff password authentication is    successful. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|CVS_Username
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to check that same repos is transmitted in pserver auth and in    later CVS protocol.  Exported because root.c also uses. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|Pserver_Repos
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Should we check for system usernames/passwords?  Can be changed by    CVSROOT/config.  */
end_comment

begin_decl_stmt
name|int
name|system_auth
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTH_SERVER_SUPPORT */
end_comment

begin_escape
end_escape

begin_comment
comment|/* While processing requests, this buffer accumulates data to be sent to    the client, and then once we are in do_cvs_command, we use it    for all the data to be sent.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|buffer
modifier|*
name|buf_to_net
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This buffer is used to read input from the client.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|buffer
modifier|*
name|buf_from_net
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This is where we stash stuff we are going to use.  Format string  * which expects a single directory within it, starting with a slash.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|server_temp_dir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the original value of server_temp_dir, before any possible    changes inserted by serve_max_dotdot.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|orig_server_temp_dir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we should keep the temp directory around after we exit.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dont_delete_temp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|server_write_entries
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All server communication goes through buffer structures.  Most of    the buffers are built on top of a file descriptor.  This structure    is used as the closure field in a buffer.  */
end_comment

begin_struct
struct|struct
name|fd_buffer
block|{
comment|/* The file descriptor.  */
name|int
name|fd
decl_stmt|;
comment|/* Nonzero if the file descriptor is in blocking mode.  */
name|int
name|blocking
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|buffer
modifier|*
name|fd_buffer_initialize
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
expr|struct
name|buffer
operator|*
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fd_buffer_input
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fd_buffer_output
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fd_buffer_flush
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fd_buffer_block
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fd_buffer_shutdown
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize a buffer built on a file descriptor.  FD is the file    descriptor.  INPUT is nonzero if this is for input, zero if this is    for output.  MEMORY is the function to call when a memory error    occurs.  */
end_comment

begin_function_decl
specifier|static
name|struct
name|buffer
modifier|*
name|fd_buffer_initialize
parameter_list|(
name|fd
parameter_list|,
name|input
parameter_list|,
name|memory
parameter_list|)
name|int
name|fd
decl_stmt|;
name|int
name|input
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*memory
end_function_decl

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|fd_buffer
modifier|*
name|n
decl_stmt|;
name|n
operator|=
operator|(
expr|struct
name|fd_buffer
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|n
argument_list|)
expr_stmt|;
name|n
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|n
operator|->
name|blocking
operator|=
literal|1
expr_stmt|;
return|return
name|buf_initialize
argument_list|(
name|input
condition|?
name|fd_buffer_input
else|:
name|NULL
argument_list|,
name|input
condition|?
name|NULL
else|:
name|fd_buffer_output
argument_list|,
name|input
condition|?
name|NULL
else|:
name|fd_buffer_flush
argument_list|,
name|fd_buffer_block
argument_list|,
name|fd_buffer_shutdown
argument_list|,
name|memory
argument_list|,
name|n
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* The buffer input function for a buffer built on a file descriptor.  */
end_comment

begin_function
specifier|static
name|int
name|fd_buffer_input
parameter_list|(
name|closure
parameter_list|,
name|data
parameter_list|,
name|need
parameter_list|,
name|size
parameter_list|,
name|got
parameter_list|)
name|void
modifier|*
name|closure
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|need
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
modifier|*
name|got
decl_stmt|;
block|{
name|struct
name|fd_buffer
modifier|*
name|fd
init|=
operator|(
expr|struct
name|fd_buffer
operator|*
operator|)
name|closure
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
if|if
condition|(
operator|!
name|fd
operator|->
name|blocking
condition|)
name|nbytes
operator|=
name|read
argument_list|(
name|fd
operator|->
name|fd
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* This case is not efficient.  Fortunately, I don't think it 	   ever actually happens.  */
name|nbytes
operator|=
name|read
argument_list|(
name|fd
operator|->
name|fd
argument_list|,
name|data
argument_list|,
name|need
operator|==
literal|0
condition|?
literal|1
else|:
name|need
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nbytes
operator|>
literal|0
condition|)
block|{
operator|*
name|got
operator|=
name|nbytes
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|got
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nbytes
operator|==
literal|0
condition|)
block|{
comment|/* End of file.  This assumes that we are using POSIX or BSD 	   style nonblocking I/O.  On System V we will get a zero 	   return if there is no data, even when not at EOF.  */
return|return
operator|-
literal|1
return|;
block|}
comment|/* Some error occurred.  */
if|if
condition|(
name|blocking_error
argument_list|(
name|errno
argument_list|)
condition|)
block|{
comment|/* Everything's fine, we just didn't get any data.  */
return|return
literal|0
return|;
block|}
return|return
name|errno
return|;
block|}
end_function

begin_comment
comment|/* The buffer output function for a buffer built on a file descriptor.  */
end_comment

begin_function
specifier|static
name|int
name|fd_buffer_output
parameter_list|(
name|closure
parameter_list|,
name|data
parameter_list|,
name|have
parameter_list|,
name|wrote
parameter_list|)
name|void
modifier|*
name|closure
decl_stmt|;
specifier|const
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|have
decl_stmt|;
name|int
modifier|*
name|wrote
decl_stmt|;
block|{
name|struct
name|fd_buffer
modifier|*
name|fd
init|=
operator|(
expr|struct
name|fd_buffer
operator|*
operator|)
name|closure
decl_stmt|;
operator|*
name|wrote
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|have
operator|>
literal|0
condition|)
block|{
name|int
name|nbytes
decl_stmt|;
name|nbytes
operator|=
name|write
argument_list|(
name|fd
operator|->
name|fd
argument_list|,
name|data
argument_list|,
name|have
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|fd
operator|->
name|blocking
operator|&&
operator|(
name|nbytes
operator|==
literal|0
operator|||
name|blocking_error
argument_list|(
name|errno
argument_list|)
operator|)
condition|)
block|{
comment|/* A nonblocking write failed to write any data.  Just 		   return.  */
return|return
literal|0
return|;
block|}
comment|/* Some sort of error occurred.  */
if|if
condition|(
name|nbytes
operator|==
literal|0
condition|)
return|return
name|EIO
return|;
return|return
name|errno
return|;
block|}
operator|*
name|wrote
operator|+=
name|nbytes
expr_stmt|;
name|data
operator|+=
name|nbytes
expr_stmt|;
name|have
operator|-=
name|nbytes
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The buffer flush function for a buffer built on a file descriptor.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|fd_buffer_flush
parameter_list|(
name|closure
parameter_list|)
name|void
modifier|*
name|closure
decl_stmt|;
block|{
comment|/* Nothing to do.  File descriptors are always flushed.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The buffer block function for a buffer built on a file descriptor.  */
end_comment

begin_function
specifier|static
name|int
name|fd_buffer_block
parameter_list|(
name|closure
parameter_list|,
name|block
parameter_list|)
name|void
modifier|*
name|closure
decl_stmt|;
name|int
name|block
decl_stmt|;
block|{
name|struct
name|fd_buffer
modifier|*
name|fd
init|=
operator|(
expr|struct
name|fd_buffer
operator|*
operator|)
name|closure
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|flags
operator|=
name|fcntl
argument_list|(
name|fd
operator|->
name|fd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|<
literal|0
condition|)
return|return
name|errno
return|;
if|if
condition|(
name|block
condition|)
name|flags
operator|&=
operator|~
name|O_NONBLOCK
expr_stmt|;
else|else
name|flags
operator||=
name|O_NONBLOCK
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
name|fd
operator|->
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|flags
argument_list|)
operator|<
literal|0
condition|)
return|return
name|errno
return|;
name|fd
operator|->
name|blocking
operator|=
name|block
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The buffer shutdown function for a buffer built on a file descriptor.  */
end_comment

begin_function
specifier|static
name|int
name|fd_buffer_shutdown
parameter_list|(
name|buf
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
block|{
name|free
argument_list|(
name|buf
operator|->
name|closure
argument_list|)
expr_stmt|;
name|buf
operator|->
name|closure
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Populate all of the directories between BASE_DIR and its relative    subdirectory DIR with CVSADM directories.  Return 0 for success or    errno value.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|create_adm_p
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|create_adm_p
parameter_list|(
name|base_dir
parameter_list|,
name|dir
parameter_list|)
name|char
modifier|*
name|base_dir
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
block|{
name|char
modifier|*
name|dir_where_cvsadm_lives
decl_stmt|,
modifier|*
name|dir_to_register
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|int
name|retval
decl_stmt|,
name|done
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|dir
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* nothing to do */
comment|/* Allocate some space for our directory-munging string. */
name|p
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|dir_where_cvsadm_lives
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|base_dir
argument_list|)
operator|+
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir_where_cvsadm_lives
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
comment|/* Allocate some space for the temporary string in which we will        construct filenames. */
name|tmp
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|base_dir
argument_list|)
operator|+
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
comment|/* We make several passes through this loop.  On the first pass,        we simply create the CVSADM directory in the deepest directory.        For each subsequent pass, we try to remove the last path        element from DIR, create the CVSADM directory in the remaining        pathname, and register the subdirectory in the newly created        CVSADM directory. */
name|retval
operator|=
name|done
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dir_where_cvsadm_lives
argument_list|,
name|base_dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dir_where_cvsadm_lives
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dir_where_cvsadm_lives
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|dir_to_register
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Create CVSADM. */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir_where_cvsadm_lives
argument_list|,
name|CVSADM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|CVS_MKDIR
argument_list|(
name|tmp
argument_list|,
literal|0777
argument_list|)
operator|<
literal|0
operator|)
operator|&&
operator|(
name|errno
operator|!=
name|EEXIST
operator|)
condition|)
block|{
name|retval
operator|=
name|errno
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
comment|/* Create CVSADM_REP. */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir_where_cvsadm_lives
argument_list|,
name|CVSADM_REP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isfile
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
comment|/* Use Emptydir as the placeholder until the client sends 	       us the real value.  This code is similar to checkout.c 	       (emptydir_name), but the code below returns errors 	       differently.  */
name|char
modifier|*
name|empty
decl_stmt|;
name|empty
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|current_parsed_root
operator|->
name|directory
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSROOTADM
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSNULLREPOS
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|empty
condition|)
block|{
name|retval
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
comment|/* Create the directory name. */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|empty
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|current_parsed_root
operator|->
name|directory
argument_list|,
name|CVSROOTADM
argument_list|,
name|CVSNULLREPOS
argument_list|)
expr_stmt|;
comment|/* Create the directory if it doesn't exist. */
if|if
condition|(
operator|!
name|isfile
argument_list|(
name|empty
argument_list|)
condition|)
block|{
name|mode_t
name|omask
decl_stmt|;
name|omask
operator|=
name|umask
argument_list|(
name|cvsumask
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVS_MKDIR
argument_list|(
name|empty
argument_list|,
literal|0777
argument_list|)
operator|<
literal|0
condition|)
block|{
name|retval
operator|=
name|errno
expr_stmt|;
name|free
argument_list|(
name|empty
argument_list|)
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
operator|(
name|void
operator|)
name|umask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
block|}
name|f
operator|=
name|CVS_FOPEN
argument_list|(
name|tmp
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|retval
operator|=
name|errno
expr_stmt|;
name|free
argument_list|(
name|empty
argument_list|)
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
comment|/* Write the directory name to CVSADM_REP. */
if|if
condition|(
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s\n"
argument_list|,
name|empty
argument_list|)
operator|<
literal|0
condition|)
block|{
name|retval
operator|=
name|errno
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|empty
argument_list|)
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|retval
operator|=
name|errno
expr_stmt|;
name|free
argument_list|(
name|empty
argument_list|)
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
comment|/* Clean up after ourselves. */
name|free
argument_list|(
name|empty
argument_list|)
expr_stmt|;
block|}
comment|/* Create CVSADM_ENT.  We open in append mode because we 	   don't want to clobber an existing Entries file.  */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir_where_cvsadm_lives
argument_list|,
name|CVSADM_ENT
argument_list|)
expr_stmt|;
name|f
operator|=
name|CVS_FOPEN
argument_list|(
name|tmp
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|retval
operator|=
name|errno
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|retval
operator|=
name|errno
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
if|if
condition|(
name|dir_to_register
operator|!=
name|NULL
condition|)
block|{
comment|/* FIXME: Yes, this results in duplicate entries in the 	       Entries.Log file, but it doesn't currently matter.  We 	       might need to change this later on to make sure that we 	       only write one entry.  */
name|Subdir_Register
argument_list|(
operator|(
name|List
operator|*
operator|)
name|NULL
argument_list|,
name|dir_where_cvsadm_lives
argument_list|,
name|dir_to_register
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|done
condition|)
break|break;
name|dir_to_register
operator|=
name|strrchr
argument_list|(
name|p
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir_to_register
operator|==
name|NULL
condition|)
block|{
name|dir_to_register
operator|=
name|p
expr_stmt|;
name|strcpy
argument_list|(
name|dir_where_cvsadm_lives
argument_list|,
name|base_dir
argument_list|)
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|dir_to_register
operator|=
literal|'\0'
expr_stmt|;
name|dir_to_register
operator|++
expr_stmt|;
name|strcpy
argument_list|(
name|dir_where_cvsadm_lives
argument_list|,
name|base_dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dir_where_cvsadm_lives
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dir_where_cvsadm_lives
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
name|finish
label|:
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dir_where_cvsadm_lives
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * Make directory DIR, including all intermediate directories if necessary.  * Returns 0 for success or errno code.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mkdir_p
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|mkdir_p
parameter_list|(
name|dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|retval
decl_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|retval
operator|=
literal|0
expr_stmt|;
comment|/*      * Skip over leading slash if present.  We won't bother to try to      * make '/'.      */
name|p
operator|=
name|dir
operator|+
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
operator|*
name|p
operator|!=
literal|'/'
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
block|{
name|strncpy
argument_list|(
name|q
argument_list|,
name|dir
argument_list|,
name|p
operator|-
name|dir
argument_list|)
expr_stmt|;
name|q
index|[
name|p
operator|-
name|dir
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|q
index|[
name|p
operator|-
name|dir
operator|-
literal|1
index|]
operator|!=
literal|'/'
operator|&&
name|CVS_MKDIR
argument_list|(
name|q
argument_list|,
literal|0777
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|saved_errno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|saved_errno
operator|!=
name|EEXIST
operator|&&
operator|(
operator|(
name|saved_errno
operator|!=
name|EACCES
operator|&&
name|saved_errno
operator|!=
name|EROFS
operator|)
operator|||
operator|!
name|isdir
argument_list|(
name|q
argument_list|)
operator|)
condition|)
block|{
name|retval
operator|=
name|saved_errno
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
operator|++
name|p
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|CVS_MKDIR
argument_list|(
name|dir
argument_list|,
literal|0777
argument_list|)
operator|<
literal|0
condition|)
name|retval
operator|=
name|errno
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|done
label|:
name|free
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Print the error response for error code STATUS.  The caller is  * reponsible for making sure we get back to the command loop without  * any further output occuring.  * Must be called only in contexts where it is OK to send output.  */
end_comment

begin_function
specifier|static
name|void
name|print_error
parameter_list|(
name|status
parameter_list|)
name|int
name|status
decl_stmt|;
block|{
name|char
modifier|*
name|msg
decl_stmt|;
name|char
name|tmpstr
index|[
literal|80
index|]
decl_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"error  "
argument_list|)
expr_stmt|;
name|msg
operator|=
name|strerror
argument_list|(
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|tmpstr
argument_list|,
literal|"unknown error %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|msg
operator|=
name|tmpstr
expr_stmt|;
block|}
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|buf_append_char
argument_list|(
name|buf_to_net
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|buf_flush
argument_list|(
name|buf_to_net
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|pending_error
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Malloc'd text for pending error.  Each line must start with "E ".  The  * last line should not end with a newline.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pending_error_text
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If an error is pending, print it and return 1.  If not, return 0.    Must be called only in contexts where it is OK to send output.  */
end_comment

begin_function
specifier|static
name|int
name|print_pending_error
parameter_list|()
block|{
if|if
condition|(
name|pending_error_text
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|pending_error_text
argument_list|)
expr_stmt|;
name|buf_append_char
argument_list|(
name|buf_to_net
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_error
condition|)
name|print_error
argument_list|(
name|pending_error
argument_list|)
expr_stmt|;
else|else
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"error  \n"
argument_list|)
expr_stmt|;
name|buf_flush
argument_list|(
name|buf_to_net
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pending_error
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|pending_error_text
argument_list|)
expr_stmt|;
name|pending_error_text
operator|=
name|NULL
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|pending_error
condition|)
block|{
name|print_error
argument_list|(
name|pending_error
argument_list|)
expr_stmt|;
name|pending_error
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Is an error pending?  */
end_comment

begin_define
define|#
directive|define
name|error_pending
parameter_list|()
value|(pending_error || pending_error_text)
end_define

begin_decl_stmt
specifier|static
name|int
name|alloc_pending
name|PROTO
argument_list|(
operator|(
name|size_t
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate SIZE bytes for pending_error_text and return nonzero    if we could do it.  */
end_comment

begin_function
specifier|static
name|int
name|alloc_pending
parameter_list|(
name|size
parameter_list|)
name|size_t
name|size
decl_stmt|;
block|{
if|if
condition|(
name|error_pending
argument_list|()
condition|)
comment|/* Probably alloc_pending callers will have already checked for 	   this case.  But we might as well handle it if they don't, I 	   guess.  */
return|return
literal|0
return|;
name|pending_error_text
operator|=
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_error_text
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|void
name|serve_is_modified
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|supported_response
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|supported_response
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|response
modifier|*
name|rs
decl_stmt|;
for|for
control|(
name|rs
operator|=
name|responses
init|;
name|rs
operator|->
name|name
operator|!=
name|NULL
condition|;
operator|++
name|rs
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|rs
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|rs
operator|->
name|status
operator|==
name|rs_supported
return|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"internal error: testing support for unknown response?"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_valid_responses
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|arg
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|struct
name|response
modifier|*
name|rs
decl_stmt|;
do|do
block|{
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|rs
operator|=
name|responses
init|;
name|rs
operator|->
name|name
operator|!=
name|NULL
condition|;
operator|++
name|rs
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|rs
operator|->
name|name
argument_list|,
name|p
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|rs
operator|->
name|name
operator|==
name|NULL
condition|)
comment|/* 	     * It is a response we have never heard of (and thus never 	     * will want to use).  So don't worry about it. 	     */
empty_stmt|;
else|else
name|rs
operator|->
name|status
operator|=
name|rs_supported
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
do|while
condition|(
name|q
operator|!=
name|NULL
condition|)
do|;
for|for
control|(
name|rs
operator|=
name|responses
init|;
name|rs
operator|->
name|name
operator|!=
name|NULL
condition|;
operator|++
name|rs
control|)
block|{
if|if
condition|(
name|rs
operator|->
name|status
operator|==
name|rs_essential
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"E response `"
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|rs
operator|->
name|name
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"' not supported by client\nerror  \n"
argument_list|)
expr_stmt|;
comment|/* FIXME: This call to buf_flush could conceivably 	       cause deadlock, as noted in server_cleanup.  */
name|buf_flush
argument_list|(
name|buf_to_net
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|error_exit
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rs
operator|->
name|status
operator|==
name|rs_optional
condition|)
name|rs
operator|->
name|status
operator|=
name|rs_not_supported
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|serve_root
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|char
modifier|*
name|env
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
if|if
condition|(
name|error_pending
argument_list|()
condition|)
return|return;
if|if
condition|(
operator|!
name|isabsolute
argument_list|(
name|arg
argument_list|)
condition|)
block|{
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E Root %s must be an absolute pathname"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Sending "Root" twice is illegal.         The other way to handle a duplicate Root requests would be as a        request to clear out all state and start over as if it was a        new connection.  Doing this would cause interoperability        headaches, so it should be a different request, if there is        any reason why such a feature is needed.  */
if|if
condition|(
name|current_parsed_root
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E Protocol error: Duplicate Root request, for %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|AUTH_SERVER_SUPPORT
if|if
condition|(
name|Pserver_Repos
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|Pserver_Repos
argument_list|,
name|arg
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|Pserver_Repos
argument_list|)
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
comment|/* The explicitness is to aid people who are writing clients. 		   I don't see how this information could help an 		   attacker.  */
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"\ E Protocol error: Root says \"%s\" but pserver says \"%s\""
argument_list|,
name|arg
argument_list|,
name|Pserver_Repos
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
name|current_parsed_root
operator|=
name|local_cvsroot
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* For pserver, this will already have happened, and the call will do        nothing.  But for rsh, we need to do it now.  */
name|parse_config
argument_list|(
name|current_parsed_root
operator|->
name|directory
argument_list|)
expr_stmt|;
name|path
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|current_parsed_root
operator|->
name|directory
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|CVSROOTADM
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|path
argument_list|,
literal|"%s/%s"
argument_list|,
name|current_parsed_root
operator|->
name|directory
argument_list|,
name|CVSROOTADM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isaccessible
argument_list|(
name|path
argument_list|,
name|R_OK
operator||
name|X_OK
argument_list|)
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|path
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E Cannot access %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|save_errno
expr_stmt|;
block|}
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PUTENV
name|env
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|CVSROOT_ENV
argument_list|)
operator|+
name|strlen
argument_list|(
name|current_parsed_root
operator|->
name|directory
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|env
argument_list|,
literal|"%s=%s"
argument_list|,
name|CVSROOT_ENV
argument_list|,
name|current_parsed_root
operator|->
name|directory
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
comment|/* do not free env, as putenv has control of it */
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|max_dotdot_limit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Is this pathname OK to recurse into when we are running as the server?    If not, call error() with a fatal error.  */
end_comment

begin_function
name|void
name|server_pathname_check
parameter_list|(
name|path
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
block|{
comment|/* An absolute pathname is almost surely a path on the *client* machine,        and is unlikely to do us any good here.  It also is probably capable        of being a security hole in the anonymous readonly case.  */
if|if
condition|(
name|isabsolute
argument_list|(
name|path
argument_list|)
condition|)
comment|/* Giving an error is actually kind of a cop-out, in the sense 	   that it would be nice for "cvs co -d /foo/bar/baz" to work. 	   A quick fix in the server would be requiring Max-dotdot of 	   at least one if pathnames are absolute, and then putting 	   /abs/foo/bar/baz in the temp dir beside the /d/d/d stuff. 	   A cleaner fix in the server might be to decouple the 	   pathnames we pass back to the client from pathnames in our 	   temp directory (this would also probably remove the need 	   for Max-dotdot).  A fix in the client would have the client 	   turn it into "cd /foo/bar; cvs co -d baz" (more or less). 	   This probably has some problems with pathnames which appear 	   in messages.  */
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"absolute pathname `%s' illegal for server"
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|pathname_levels
argument_list|(
name|path
argument_list|)
operator|>
name|max_dotdot_limit
condition|)
block|{
comment|/* Similar to the isabsolute case in security implications.  */
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"protocol error: `%s' contains more leading .."
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"than the %d which Max-dotdot specified"
argument_list|,
name|max_dotdot_limit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|outside_root
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Is file or directory REPOS an absolute pathname within the    current_parsed_root->directory?  If yes, return 0.  If no, set pending_error    and return 1.  */
end_comment

begin_function
specifier|static
name|int
name|outside_root
parameter_list|(
name|repos
parameter_list|)
name|char
modifier|*
name|repos
decl_stmt|;
block|{
name|size_t
name|repos_len
init|=
name|strlen
argument_list|(
name|repos
argument_list|)
decl_stmt|;
name|size_t
name|root_len
init|=
name|strlen
argument_list|(
name|current_parsed_root
operator|->
name|directory
argument_list|)
decl_stmt|;
comment|/* isabsolute (repos) should always be true, but        this is a good security precaution regardless. -DRP      */
if|if
condition|(
operator|!
name|isabsolute
argument_list|(
name|repos
argument_list|)
condition|)
block|{
if|if
condition|(
name|alloc_pending
argument_list|(
name|repos_len
operator|+
literal|80
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"\ E protocol error: %s is not absolute"
argument_list|,
name|repos
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|repos_len
operator|<
name|root_len
operator|||
name|strncmp
argument_list|(
name|current_parsed_root
operator|->
name|directory
argument_list|,
name|repos
argument_list|,
name|root_len
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|not_within
label|:
if|if
condition|(
name|alloc_pending
argument_list|(
name|strlen
argument_list|(
name|current_parsed_root
operator|->
name|directory
argument_list|)
operator|+
name|strlen
argument_list|(
name|repos
argument_list|)
operator|+
literal|80
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"\ E protocol error: directory '%s' not within root '%s'"
argument_list|,
name|repos
argument_list|,
name|current_parsed_root
operator|->
name|directory
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|repos_len
operator|>
name|root_len
condition|)
block|{
if|if
condition|(
name|repos
index|[
name|root_len
index|]
operator|!=
literal|'/'
condition|)
goto|goto
name|not_within
goto|;
if|if
condition|(
name|pathname_levels
argument_list|(
name|repos
operator|+
name|root_len
operator|+
literal|1
argument_list|)
operator|>
literal|0
condition|)
goto|goto
name|not_within
goto|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|outside_dir
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Is file or directory FILE outside the current directory (that is, does    it contain '/')?  If no, return 0.  If yes, set pending_error    and return 1.  */
end_comment

begin_function
specifier|static
name|int
name|outside_dir
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
if|if
condition|(
name|strchr
argument_list|(
name|file
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|alloc_pending
argument_list|(
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
literal|80
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"\ E protocol error: directory '%s' not within current directory"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Add as many directories to the temp directory as the client tells us it  * will use "..", so we never try to access something outside the temp  * directory via "..".  */
end_comment

begin_function
specifier|static
name|void
name|serve_max_dotdot
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|int
name|lim
init|=
name|atoi
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|lim
operator|<
literal|0
operator|||
name|lim
operator|>
literal|10000
condition|)
return|return;
name|p
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|server_temp_dir
argument_list|)
operator|+
literal|2
operator|*
name|lim
operator|+
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|p
argument_list|,
name|server_temp_dir
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lim
condition|;
operator|++
name|i
control|)
name|strcat
argument_list|(
name|p
argument_list|,
literal|"/d"
argument_list|)
expr_stmt|;
if|if
condition|(
name|server_temp_dir
operator|!=
name|orig_server_temp_dir
condition|)
name|free
argument_list|(
name|server_temp_dir
argument_list|)
expr_stmt|;
name|server_temp_dir
operator|=
name|p
expr_stmt|;
name|max_dotdot_limit
operator|=
name|lim
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dir_name
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|dirswitch
parameter_list|(
name|dir
parameter_list|,
name|repos
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|repos
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|size_t
name|dir_len
decl_stmt|;
name|server_write_entries
argument_list|()
expr_stmt|;
if|if
condition|(
name|error_pending
argument_list|()
condition|)
return|return;
comment|/* Check for bad directory name.         FIXME: could/should unify these checks with server_pathname_check        except they need to report errors differently.  */
if|if
condition|(
name|isabsolute
argument_list|(
name|dir
argument_list|)
condition|)
block|{
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|dir
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E absolute pathname `%s' illegal for server"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pathname_levels
argument_list|(
name|dir
argument_list|)
operator|>
name|max_dotdot_limit
condition|)
block|{
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|dir
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E protocol error: `%s' has too many .."
argument_list|,
name|dir
argument_list|)
expr_stmt|;
return|return;
block|}
name|dir_len
operator|=
name|strlen
argument_list|(
name|dir
argument_list|)
expr_stmt|;
comment|/* Check for a trailing '/'.  This is not ISDIRSEP because \ in the        protocol is an ordinary character, not a directory separator (of        course, it is perhaps unwise to use it in directory names, but that        is another issue).  */
if|if
condition|(
name|dir_len
operator|>
literal|0
operator|&&
name|dir
index|[
name|dir_len
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|dir_len
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E protocol error: invalid directory syntax in %s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dir_name
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|dir_name
argument_list|)
expr_stmt|;
name|dir_name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|server_temp_dir
argument_list|)
operator|+
name|dir_len
operator|+
literal|40
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir_name
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|dir_name
argument_list|,
name|server_temp_dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dir_name
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dir_name
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|status
operator|=
name|mkdir_p
argument_list|(
name|dir_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
operator|&&
name|status
operator|!=
name|EEXIST
condition|)
block|{
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|dir_name
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot mkdir %s"
argument_list|,
name|dir_name
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|status
expr_stmt|;
return|return;
block|}
comment|/* We need to create adm directories in all path elements because        we want the server to descend them, even if the client hasn't        sent the appropriate "Argument xxx" command to match the        already-sent "Directory xxx" command.  See recurse.c        (start_recursion) for a big discussion of this.  */
name|status
operator|=
name|create_adm_p
argument_list|(
name|server_temp_dir
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|dir_name
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot create_adm_p %s"
argument_list|,
name|dir_name
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|status
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|CVS_CHDIR
argument_list|(
name|dir_name
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|dir_name
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot change to %s"
argument_list|,
name|dir_name
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|save_errno
expr_stmt|;
return|return;
block|}
comment|/*      * This is pretty much like calling Create_Admin, but Create_Admin doesn't      * report errors in the right way for us.      */
if|if
condition|(
operator|(
name|CVS_MKDIR
argument_list|(
name|CVSADM
argument_list|,
literal|0777
argument_list|)
operator|<
literal|0
operator|)
operator|&&
operator|(
name|errno
operator|!=
name|EEXIST
operator|)
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|dir_name
argument_list|)
operator|+
name|strlen
argument_list|(
name|CVSADM
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot mkdir %s/%s"
argument_list|,
name|dir_name
argument_list|,
name|CVSADM
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|save_errno
expr_stmt|;
return|return;
block|}
comment|/* The following will overwrite the contents of CVSADM_REP.  This        is the correct behavior -- mkdir_p may have written a        placeholder value to this file and we need to insert the        correct value. */
name|f
operator|=
name|CVS_FOPEN
argument_list|(
name|CVSADM_REP
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|dir_name
argument_list|)
operator|+
name|strlen
argument_list|(
name|CVSADM_REP
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot open %s/%s"
argument_list|,
name|dir_name
argument_list|,
name|CVSADM_REP
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|save_errno
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s"
argument_list|,
name|repos
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|dir_name
argument_list|)
operator|+
name|strlen
argument_list|(
name|CVSADM_REP
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E error writing %s/%s"
argument_list|,
name|dir_name
argument_list|,
name|CVSADM_REP
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|save_errno
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Non-remote CVS handles a module representing the entire tree        (e.g., an entry like ``world -a .'') by putting /. at the end        of the Repository file, so we do the same.  */
if|if
condition|(
name|strcmp
argument_list|(
name|dir
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
operator|&&
name|current_parsed_root
operator|!=
name|NULL
operator|&&
name|current_parsed_root
operator|->
name|directory
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|current_parsed_root
operator|->
name|directory
argument_list|,
name|repos
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"/."
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|dir_name
argument_list|)
operator|+
name|strlen
argument_list|(
name|CVSADM_REP
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E error writing %s/%s"
argument_list|,
name|dir_name
argument_list|,
name|CVSADM_REP
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|save_errno
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|dir_name
argument_list|)
operator|+
name|strlen
argument_list|(
name|CVSADM_REP
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E error writing %s/%s"
argument_list|,
name|dir_name
argument_list|,
name|CVSADM_REP
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|save_errno
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|dir_name
argument_list|)
operator|+
name|strlen
argument_list|(
name|CVSADM_REP
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E error closing %s/%s"
argument_list|,
name|dir_name
argument_list|,
name|CVSADM_REP
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|save_errno
expr_stmt|;
return|return;
block|}
comment|/* We open in append mode because we don't want to clobber an        existing Entries file.  */
name|f
operator|=
name|CVS_FOPEN
argument_list|(
name|CVSADM_ENT
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|CVSADM_ENT
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot open %s"
argument_list|,
name|CVSADM_ENT
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|save_errno
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|CVSADM_ENT
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot close %s"
argument_list|,
name|CVSADM_ENT
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|save_errno
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|serve_repository
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
argument_list|)
condition|)
name|strcpy
argument_list|(
name|pending_error_text
argument_list|,
literal|"E Repository request is obsolete; aborted"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_directory
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|char
modifier|*
name|repos
decl_stmt|;
name|status
operator|=
name|buf_read_line
argument_list|(
name|buf_from_net
argument_list|,
operator|&
name|repos
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|outside_root
argument_list|(
name|repos
argument_list|)
condition|)
name|dirswitch
argument_list|(
name|arg
argument_list|,
name|repos
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repos
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
operator|-
literal|2
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
block|}
else|else
block|{
name|pending_error_text
operator|=
name|xmalloc
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_error_text
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
block|{
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E end of file reading mode for %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E error reading mode for %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|status
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|serve_static_directory
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|error_pending
argument_list|()
condition|)
return|return;
name|f
operator|=
name|CVS_FOPEN
argument_list|(
name|CVSADM_ENTSTAT
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|CVSADM_ENTSTAT
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot open %s"
argument_list|,
name|CVSADM_ENTSTAT
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|save_errno
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|CVSADM_ENTSTAT
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot close %s"
argument_list|,
name|CVSADM_ENTSTAT
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|save_errno
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|serve_sticky
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|error_pending
argument_list|()
condition|)
return|return;
name|f
operator|=
name|CVS_FOPEN
argument_list|(
name|CVSADM_TAG
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|CVSADM_TAG
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot open %s"
argument_list|,
name|CVSADM_TAG
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|save_errno
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s\n"
argument_list|,
name|arg
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|CVSADM_TAG
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot write to %s"
argument_list|,
name|CVSADM_TAG
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|save_errno
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|CVSADM_TAG
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot close %s"
argument_list|,
name|CVSADM_TAG
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|save_errno
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Read SIZE bytes from buf_from_net, write them to FILE.  *  * Currently this isn't really used for receiving parts of a file --  * the file is still sent over in one chunk.  But if/when we get  * spiffy in-process gzip support working, perhaps the compressed  * pieces could be sent over as they're ready, if the network is fast  * enough.  Or something.  */
end_comment

begin_function
specifier|static
name|void
name|receive_partial_file
parameter_list|(
name|size
parameter_list|,
name|file
parameter_list|)
name|int
name|size
decl_stmt|;
name|int
name|file
decl_stmt|;
block|{
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|int
name|status
decl_stmt|,
name|nread
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|status
operator|=
name|buf_read_data
argument_list|(
name|buf_from_net
argument_list|,
name|size
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|nread
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|status
operator|==
operator|-
literal|2
condition|)
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
else|else
block|{
name|pending_error_text
operator|=
name|xmalloc
argument_list|(
literal|80
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_error_text
operator|==
name|NULL
condition|)
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
block|{
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E premature end of file from client"
argument_list|)
expr_stmt|;
name|pending_error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E error reading from client"
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|status
expr_stmt|;
block|}
block|}
return|return;
block|}
name|size
operator|-=
name|nread
expr_stmt|;
while|while
condition|(
name|nread
operator|>
literal|0
condition|)
block|{
name|int
name|nwrote
decl_stmt|;
name|nwrote
operator|=
name|write
argument_list|(
name|file
argument_list|,
name|data
argument_list|,
name|nread
argument_list|)
expr_stmt|;
if|if
condition|(
name|nwrote
operator|<
literal|0
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|40
argument_list|)
condition|)
name|strcpy
argument_list|(
name|pending_error_text
argument_list|,
literal|"E unable to write"
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|save_errno
expr_stmt|;
comment|/* Read and discard the file data.  */
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|int
name|status
decl_stmt|,
name|nread
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|status
operator|=
name|buf_read_data
argument_list|(
name|buf_from_net
argument_list|,
name|size
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|nread
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return;
name|size
operator|-=
name|nread
expr_stmt|;
block|}
return|return;
block|}
name|nread
operator|-=
name|nwrote
expr_stmt|;
name|data
operator|+=
name|nwrote
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Receive SIZE bytes, write to filename FILE.  */
end_comment

begin_function
specifier|static
name|void
name|receive_file
parameter_list|(
name|size
parameter_list|,
name|file
parameter_list|,
name|gzipped
parameter_list|)
name|int
name|size
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|gzipped
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|arg
init|=
name|file
decl_stmt|;
comment|/* Write the file.  */
name|fd
operator|=
name|CVS_OPEN
argument_list|(
name|arg
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|40
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot open %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|save_errno
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|gzipped
condition|)
block|{
comment|/* Using gunzip_and_write isn't really a high-performance 	   approach, because it keeps the whole thing in memory 	   (contiguous memory, worse yet).  But it seems easier to 	   code than the alternative (and less vulnerable to subtle 	   bugs).  Given that this feature is mainly for 	   compatibility, that is the better tradeoff.  */
name|int
name|toread
init|=
name|size
decl_stmt|;
name|char
modifier|*
name|filebuf
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|filebuf
operator|=
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|p
operator|=
name|filebuf
expr_stmt|;
comment|/* If NULL, we still want to read the data and discard it.  */
while|while
condition|(
name|toread
operator|>
literal|0
condition|)
block|{
name|int
name|status
decl_stmt|,
name|nread
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|status
operator|=
name|buf_read_data
argument_list|(
name|buf_from_net
argument_list|,
name|toread
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|nread
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|status
operator|==
operator|-
literal|2
condition|)
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
else|else
block|{
name|pending_error_text
operator|=
name|xmalloc
argument_list|(
literal|80
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_error_text
operator|==
name|NULL
condition|)
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
block|{
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E premature end of file from client"
argument_list|)
expr_stmt|;
name|pending_error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E error reading from client"
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|status
expr_stmt|;
block|}
block|}
return|return;
block|}
name|toread
operator|-=
name|nread
expr_stmt|;
if|if
condition|(
name|filebuf
operator|!=
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
name|p
argument_list|,
name|data
argument_list|,
name|nread
argument_list|)
expr_stmt|;
name|p
operator|+=
name|nread
expr_stmt|;
block|}
block|}
if|if
condition|(
name|filebuf
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|gunzip_and_write
argument_list|(
name|fd
argument_list|,
name|file
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|filebuf
argument_list|,
name|size
argument_list|)
condition|)
block|{
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E aborting due to compression error"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|filebuf
argument_list|)
expr_stmt|;
block|}
else|else
name|receive_partial_file
argument_list|(
name|size
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_error_text
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|xrealloc
argument_list|(
name|pending_error_text
argument_list|,
name|strlen
argument_list|(
name|pending_error_text
argument_list|)
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|30
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|pending_error_text
operator|=
name|p
expr_stmt|;
name|sprintf
argument_list|(
name|p
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|,
literal|", file %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
comment|/* else original string is supposed to be unchanged */
block|}
name|out
label|:
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|error_pending
argument_list|()
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|40
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot close %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|save_errno
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Kopt for the next file sent in Modified or Is-modified.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|kopt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Timestamp (Checkin-time) for next file sent in Modified or    Is-modified.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|checkin_time_valid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|time_t
name|checkin_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|serve_modified
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_modified
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|int
name|size
decl_stmt|,
name|status
decl_stmt|;
name|char
modifier|*
name|size_text
decl_stmt|;
name|char
modifier|*
name|mode_text
decl_stmt|;
name|int
name|gzipped
init|=
literal|0
decl_stmt|;
comment|/*      * This used to return immediately if error_pending () was true.      * However, that fails, because it causes each line of the file to      * be echoed back to the client as an unrecognized command.  The      * client isn't reading from the socket, so eventually both      * processes block trying to write to the other.  Now, we try to      * read the file if we can.      */
name|status
operator|=
name|buf_read_line
argument_list|(
name|buf_from_net
argument_list|,
operator|&
name|mode_text
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|status
operator|==
operator|-
literal|2
condition|)
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
else|else
block|{
name|pending_error_text
operator|=
name|xmalloc
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_error_text
operator|==
name|NULL
condition|)
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
else|else
block|{
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E end of file reading mode for %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E error reading mode for %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|status
expr_stmt|;
block|}
block|}
block|}
return|return;
block|}
name|status
operator|=
name|buf_read_line
argument_list|(
name|buf_from_net
argument_list|,
operator|&
name|size_text
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|status
operator|==
operator|-
literal|2
condition|)
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
else|else
block|{
name|pending_error_text
operator|=
name|xmalloc
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_error_text
operator|==
name|NULL
condition|)
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
else|else
block|{
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E end of file reading size for %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E error reading size for %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|status
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|mode_text
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|size_text
index|[
literal|0
index|]
operator|==
literal|'z'
condition|)
block|{
name|gzipped
operator|=
literal|1
expr_stmt|;
name|size
operator|=
name|atoi
argument_list|(
name|size_text
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|size
operator|=
name|atoi
argument_list|(
name|size_text
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|size_text
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_pending
argument_list|()
condition|)
block|{
comment|/* Now that we know the size, read and discard the file data.  */
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|int
name|status
decl_stmt|,
name|nread
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|status
operator|=
name|buf_read_data
argument_list|(
name|buf_from_net
argument_list|,
name|size
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|nread
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return;
name|size
operator|-=
name|nread
expr_stmt|;
block|}
name|free
argument_list|(
name|mode_text
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|outside_dir
argument_list|(
name|arg
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|mode_text
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|size
operator|>=
literal|0
condition|)
block|{
name|receive_file
argument_list|(
name|size
argument_list|,
name|arg
argument_list|,
name|gzipped
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_pending
argument_list|()
condition|)
block|{
name|free
argument_list|(
name|mode_text
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|checkin_time_valid
condition|)
block|{
name|struct
name|utimbuf
name|t
decl_stmt|;
name|memset
argument_list|(
operator|&
name|t
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|.
name|modtime
operator|=
name|t
operator|.
name|actime
operator|=
name|checkin_time
expr_stmt|;
if|if
condition|(
name|utime
argument_list|(
name|arg
argument_list|,
operator|&
name|t
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot utime %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|save_errno
expr_stmt|;
name|free
argument_list|(
name|mode_text
argument_list|)
expr_stmt|;
return|return;
block|}
name|checkin_time_valid
operator|=
literal|0
expr_stmt|;
block|}
block|{
name|int
name|status
init|=
name|change_mode
argument_list|(
name|arg
argument_list|,
name|mode_text
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|mode_text
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
if|if
condition|(
name|alloc_pending
argument_list|(
literal|40
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot change mode for %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|status
expr_stmt|;
return|return;
block|}
block|}
comment|/* Make sure that the Entries indicate the right kopt.  We probably        could do this even in the non-kopt case and, I think, save a stat()        call in time_stamp_server.  But for conservatism I'm leaving the        non-kopt case alone.  */
if|if
condition|(
name|kopt
operator|!=
name|NULL
condition|)
name|serve_is_modified
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|serve_enable_unchanged
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{ }
end_function

begin_struct
struct|struct
name|an_entry
block|{
name|struct
name|an_entry
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|entry
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|an_entry
modifier|*
name|entries
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|serve_unchanged
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_unchanged
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|an_entry
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|timefield
decl_stmt|;
if|if
condition|(
name|error_pending
argument_list|()
condition|)
return|return;
if|if
condition|(
name|outside_dir
argument_list|(
name|arg
argument_list|)
condition|)
return|return;
comment|/* Rewrite entries file to have `=' in timestamp field.  */
for|for
control|(
name|p
operator|=
name|entries
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|name
operator|=
name|p
operator|->
name|entry
operator|+
literal|1
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
operator|&&
name|strlen
argument_list|(
name|arg
argument_list|)
operator|==
name|cp
operator|-
name|name
operator|&&
name|strncmp
argument_list|(
name|arg
argument_list|,
name|name
argument_list|,
name|cp
operator|-
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|timefield
operator|=
name|strchr
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|||
operator|*
operator|++
name|timefield
operator|==
literal|'\0'
condition|)
block|{
comment|/* We didn't find the record separator or it is followed by 		 * the end of the string, so just exit. 		 */
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E Malformed Entry encountered."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If the time field is not currently empty, then one of 	     * serve_modified, serve_is_modified,& serve_unchanged were 	     * already called for this file.  We would like to ignore the 	     * reinvocation silently or, better yet, exit with an error 	     * message, but we just avoid the copy-forward and overwrite the 	     * value from the last invocation instead.  See the comment below 	     * for more. 	     */
if|if
condition|(
operator|*
name|timefield
operator|==
literal|'/'
condition|)
block|{
comment|/* Copy forward one character.  Space was allocated for this 		 * already in serve_entry().  */
name|cp
operator|=
name|timefield
operator|+
name|strlen
argument_list|(
name|timefield
argument_list|)
expr_stmt|;
name|cp
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|cp
operator|>
name|timefield
condition|)
block|{
operator|*
name|cp
operator|=
name|cp
index|[
operator|-
literal|1
index|]
expr_stmt|;
operator|--
name|cp
expr_stmt|;
block|}
block|}
comment|/* If *TIMEFIELD wasn't "/", we assume that it was because of 	     * multiple calls to Is-Modified& Unchanged by the client and 	     * just overwrite the value from the last call.  Technically, we 	     * should probably either ignore calls after the first or send the 	     * client an error, since the client/server protocol specification 	     * specifies that only one call to either Is-Modified or Unchanged 	     * is allowed, but broken versions of WinCVS& TortoiseCVS rely on 	     * this behavior. 	     */
operator|*
name|timefield
operator|=
literal|'='
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|serve_is_modified
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|an_entry
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|timefield
decl_stmt|;
comment|/* Have we found this file in "entries" yet.  */
name|int
name|found
decl_stmt|;
if|if
condition|(
name|error_pending
argument_list|()
condition|)
return|return;
if|if
condition|(
name|outside_dir
argument_list|(
name|arg
argument_list|)
condition|)
return|return;
comment|/* Rewrite entries file to have `M' in timestamp field.  */
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|entries
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|name
operator|=
name|p
operator|->
name|entry
operator|+
literal|1
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
operator|&&
name|strlen
argument_list|(
name|arg
argument_list|)
operator|==
name|cp
operator|-
name|name
operator|&&
name|strncmp
argument_list|(
name|arg
argument_list|,
name|name
argument_list|,
name|cp
operator|-
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|timefield
operator|=
name|strchr
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|||
operator|*
operator|++
name|timefield
operator|==
literal|'\0'
condition|)
block|{
comment|/* We didn't find the record separator or it is followed by 		 * the end of the string, so just exit. 		 */
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E Malformed Entry encountered."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If the time field is not currently empty, then one of 	     * serve_modified, serve_is_modified,& serve_unchanged were 	     * already called for this file.  We would like to ignore the 	     * reinvocation silently or, better yet, exit with an error 	     * message, but we just avoid the copy-forward and overwrite the 	     * value from the last invocation instead.  See the comment below 	     * for more. 	     */
if|if
condition|(
operator|*
name|timefield
operator|==
literal|'/'
condition|)
block|{
comment|/* Copy forward one character.  Space was allocated for this 		 * already in serve_entry().  */
name|cp
operator|=
name|timefield
operator|+
name|strlen
argument_list|(
name|timefield
argument_list|)
expr_stmt|;
name|cp
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|cp
operator|>
name|timefield
condition|)
block|{
operator|*
name|cp
operator|=
name|cp
index|[
operator|-
literal|1
index|]
expr_stmt|;
operator|--
name|cp
expr_stmt|;
block|}
block|}
comment|/* If *TIMEFIELD wasn't "/", we assume that it was because of 	     * multiple calls to Is-Modified& Unchanged by the client and 	     * just overwrite the value from the last call.  Technically, we 	     * should probably either ignore calls after the first or send the 	     * client an error, since the client/server protocol specification 	     * specifies that only one call to either Is-Modified or Unchanged 	     * is allowed, but broken versions of WinCVS& TortoiseCVS rely on 	     * this behavior. 	     */
operator|*
name|timefield
operator|=
literal|'M'
expr_stmt|;
if|if
condition|(
name|kopt
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|alloc_pending
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|80
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E protocol error: both Kopt and Entry for %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|kopt
argument_list|)
expr_stmt|;
name|kopt
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
comment|/* We got Is-modified but no Entry.  Add a dummy entry. 	   The "D" timestamp is what makes it a dummy.  */
name|p
operator|=
operator|(
expr|struct
name|an_entry
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|an_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
name|p
operator|->
name|entry
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|80
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|entry
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|p
operator|->
name|entry
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|p
operator|->
name|entry
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|p
operator|->
name|entry
argument_list|,
literal|"//D/"
argument_list|)
expr_stmt|;
if|if
condition|(
name|kopt
operator|!=
name|NULL
condition|)
block|{
name|strcat
argument_list|(
name|p
operator|->
name|entry
argument_list|,
name|kopt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|kopt
argument_list|)
expr_stmt|;
name|kopt
operator|=
name|NULL
expr_stmt|;
block|}
name|strcat
argument_list|(
name|p
operator|->
name|entry
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|entries
expr_stmt|;
name|entries
operator|=
name|p
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|serve_entry
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_entry
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|an_entry
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|error_pending
argument_list|()
condition|)
return|return;
comment|/* Verify that the entry is well-formed.  This can avoid problems later.      * At the moment we only check that the Entry contains five slashes in      * approximately the correct locations since some of the code makes      * assumptions about this.      */
name|cp
operator|=
name|arg
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'D'
condition|)
name|cp
operator|++
expr_stmt|;
while|while
condition|(
name|i
operator|++
operator|<
literal|5
condition|)
block|{
if|if
condition|(
operator|!
name|cp
operator|||
operator|*
name|cp
operator|!=
literal|'/'
condition|)
block|{
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E protocol error: Malformed Entry"
argument_list|)
expr_stmt|;
return|return;
block|}
name|cp
operator|=
name|strchr
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|an_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
comment|/* Leave space for serve_unchanged to write '=' if it wants.  */
name|cp
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|cp
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|entries
expr_stmt|;
name|p
operator|->
name|entry
operator|=
name|cp
expr_stmt|;
name|entries
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|serve_kopt
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_kopt
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|error_pending
argument_list|()
condition|)
return|return;
if|if
condition|(
name|kopt
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E protocol error: duplicate Kopt request: %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Do some sanity checks.  In particular, that it is not too long.        This lets the rest of the code not worry so much about buffer        overrun attacks.  Probably should call RCS_check_kflag here,        but that would mean changing RCS_check_kflag to handle errors        other than via exit(), fprintf(), and such.  */
if|if
condition|(
name|strlen
argument_list|(
name|arg
argument_list|)
operator|>
literal|10
condition|)
block|{
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E protocol error: invalid Kopt request: %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return;
block|}
name|kopt
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|kopt
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|kopt
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|serve_checkin_time
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_checkin_time
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|error_pending
argument_list|()
condition|)
return|return;
if|if
condition|(
name|checkin_time_valid
condition|)
block|{
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E protocol error: duplicate Checkin-time request: %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return;
block|}
name|checkin_time
operator|=
name|get_date
argument_list|(
name|arg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|checkin_time
operator|==
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot parse date %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return;
block|}
name|checkin_time_valid
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|server_write_entries
parameter_list|()
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|struct
name|an_entry
modifier|*
name|p
decl_stmt|;
name|struct
name|an_entry
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|entries
operator|==
name|NULL
condition|)
return|return;
name|f
operator|=
name|NULL
expr_stmt|;
comment|/* Note that we free all the entries regardless of errors.  */
if|if
condition|(
operator|!
name|error_pending
argument_list|()
condition|)
block|{
comment|/* We open in append mode because we don't want to clobber an 	   existing Entries file.  If we are checking out a module 	   which explicitly lists more than one file in a particular 	   directory, then we will wind up calling 	   server_write_entries for each such file.  */
name|f
operator|=
name|CVS_FOPEN
argument_list|(
name|CVSADM_ENT
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|CVSADM_ENT
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot open %s"
argument_list|,
name|CVSADM_ENT
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|save_errno
expr_stmt|;
block|}
block|}
for|for
control|(
name|p
operator|=
name|entries
init|;
name|p
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|error_pending
argument_list|()
condition|)
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s\n"
argument_list|,
name|p
operator|->
name|entry
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|CVSADM_ENT
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot write to %s"
argument_list|,
name|CVSADM_ENT
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|save_errno
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|p
operator|->
name|entry
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
name|entries
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|NULL
operator|&&
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
operator|&&
operator|!
name|error_pending
argument_list|()
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|CVSADM_ENT
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot close %s"
argument_list|,
name|CVSADM_ENT
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|save_errno
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|notify_note
block|{
comment|/* Directory in which this notification happens.  xmalloc'd*/
name|char
modifier|*
name|dir
decl_stmt|;
comment|/* xmalloc'd.  */
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* The following three all in one xmalloc'd block, pointed to by TYPE.        Each '\0' terminated.  */
comment|/* "E" or "U".  */
name|char
modifier|*
name|type
decl_stmt|;
comment|/* time+host+dir */
name|char
modifier|*
name|val
decl_stmt|;
name|char
modifier|*
name|watches
decl_stmt|;
name|struct
name|notify_note
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|notify_note
modifier|*
name|notify_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used while building list, to point to the last node that already exists.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|notify_note
modifier|*
name|last_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|serve_notify
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_notify
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|notify_note
modifier|*
name|new
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|data
init|=
name|NULL
decl_stmt|;
name|int
name|status
decl_stmt|;
if|if
condition|(
name|error_pending
argument_list|()
condition|)
return|return;
if|if
condition|(
name|outside_dir
argument_list|(
name|arg
argument_list|)
condition|)
return|return;
if|if
condition|(
name|dir_name
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
name|new
operator|=
operator|(
expr|struct
name|notify_note
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|notify_note
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
name|new
operator|->
name|dir
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|dir_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|new
operator|->
name|filename
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|->
name|dir
operator|==
name|NULL
operator|||
name|new
operator|->
name|filename
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
if|if
condition|(
name|new
operator|->
name|dir
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|new
operator|->
name|dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new
argument_list|)
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|new
operator|->
name|dir
argument_list|,
name|dir_name
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new
operator|->
name|filename
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|status
operator|=
name|buf_read_line
argument_list|(
name|buf_from_net
argument_list|,
operator|&
name|data
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|status
operator|==
operator|-
literal|2
condition|)
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
else|else
block|{
name|pending_error_text
operator|=
name|xmalloc
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_error_text
operator|==
name|NULL
condition|)
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
else|else
block|{
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E end of file reading notification for %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E error reading notification for %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|status
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|new
operator|->
name|filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new
operator|->
name|dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|!
name|data
index|[
literal|0
index|]
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|strchr
argument_list|(
name|data
argument_list|,
literal|'+'
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|new
operator|->
name|type
operator|=
name|data
expr_stmt|;
if|if
condition|(
name|data
index|[
literal|1
index|]
operator|!=
literal|'\t'
condition|)
goto|goto
name|error
goto|;
name|data
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|=
name|data
operator|+
literal|2
expr_stmt|;
name|new
operator|->
name|val
operator|=
name|cp
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
operator|*
name|cp
operator|++
operator|=
literal|'+'
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
operator|*
name|cp
operator|++
operator|=
literal|'+'
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|new
operator|->
name|watches
operator|=
name|cp
expr_stmt|;
comment|/* If there is another tab, ignore everything after it, 	   for future expansion.  */
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
name|new
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|last_node
operator|==
name|NULL
condition|)
block|{
name|notify_list
operator|=
name|new
expr_stmt|;
block|}
else|else
name|last_node
operator|->
name|next
operator|=
name|new
expr_stmt|;
name|last_node
operator|=
name|new
expr_stmt|;
block|}
return|return;
name|error
label|:
name|pending_error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
argument_list|)
condition|)
name|strcpy
argument_list|(
name|pending_error_text
argument_list|,
literal|"E Protocol error; misformed Notify request"
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|new
operator|->
name|filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new
operator|->
name|dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* Process all the Notify requests that we have stored up.  Returns 0    if successful, if not prints error message (via error()) and    returns negative value.  */
end_comment

begin_function
specifier|static
name|int
name|server_notify
parameter_list|()
block|{
name|struct
name|notify_note
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|repos
decl_stmt|;
while|while
condition|(
name|notify_list
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|CVS_CHDIR
argument_list|(
name|notify_list
operator|->
name|dir
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot change to %s"
argument_list|,
name|notify_list
operator|->
name|dir
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|repos
operator|=
name|Name_Repository
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|lock_dir_for_write
argument_list|(
name|repos
argument_list|)
expr_stmt|;
name|fileattr_startdir
argument_list|(
name|repos
argument_list|)
expr_stmt|;
name|notify_do
argument_list|(
operator|*
name|notify_list
operator|->
name|type
argument_list|,
name|notify_list
operator|->
name|filename
argument_list|,
name|getcaller
argument_list|()
argument_list|,
name|notify_list
operator|->
name|val
argument_list|,
name|notify_list
operator|->
name|watches
argument_list|,
name|repos
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"Notified "
argument_list|)
expr_stmt|;
block|{
name|char
modifier|*
name|dir
init|=
name|notify_list
operator|->
name|dir
operator|+
name|strlen
argument_list|(
name|server_temp_dir
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|buf_append_char
argument_list|(
name|buf_to_net
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
else|else
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|buf_append_char
argument_list|(
name|buf_to_net
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|buf_append_char
argument_list|(
name|buf_to_net
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|repos
argument_list|)
expr_stmt|;
name|buf_append_char
argument_list|(
name|buf_to_net
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|notify_list
operator|->
name|filename
argument_list|)
expr_stmt|;
name|buf_append_char
argument_list|(
name|buf_to_net
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repos
argument_list|)
expr_stmt|;
name|p
operator|=
name|notify_list
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|notify_list
operator|->
name|filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|notify_list
operator|->
name|dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|notify_list
operator|->
name|type
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|notify_list
argument_list|)
expr_stmt|;
name|notify_list
operator|=
name|p
expr_stmt|;
name|fileattr_write
argument_list|()
expr_stmt|;
name|fileattr_free
argument_list|()
expr_stmt|;
name|Lock_Cleanup
argument_list|()
expr_stmt|;
block|}
name|last_node
operator|=
name|NULL
expr_stmt|;
comment|/* The code used to call fflush (stdout) here, but that is no        longer necessary.  The data is now buffered in buf_to_net,        which will be flushed by the caller, do_cvs_command.  */
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|argument_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|argument_vector
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|argument_vector_size
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_argument
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|error_pending
argument_list|()
condition|)
return|return;
if|if
condition|(
name|argument_count
operator|>=
literal|10000
condition|)
block|{
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E Protocol error: too many arguments"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|argument_vector_size
operator|<=
name|argument_count
condition|)
block|{
name|argument_vector_size
operator|*=
literal|2
expr_stmt|;
name|argument_vector
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argument_vector
argument_list|,
name|argument_vector_size
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|argument_vector
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
block|}
name|p
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|p
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|argument_vector
index|[
name|argument_count
operator|++
index|]
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_argumentx
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|error_pending
argument_list|()
condition|)
return|return;
if|if
condition|(
name|argument_count
operator|<=
literal|1
condition|)
block|{
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E Protocol error: called argumentx without prior call to argument"
argument_list|)
expr_stmt|;
return|return;
block|}
name|p
operator|=
name|argument_vector
index|[
name|argument_count
operator|-
literal|1
index|]
expr_stmt|;
name|p
operator|=
name|xrealloc
argument_list|(
name|p
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
name|strcat
argument_list|(
name|p
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|p
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|argument_vector
index|[
name|argument_count
operator|-
literal|1
index|]
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_global_option
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|||
name|arg
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
name|arg
index|[
literal|2
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|error_return
label|:
if|if
condition|(
name|alloc_pending
argument_list|(
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|80
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E Protocol error: bad global option %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|arg
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'l'
case|:
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"WARNING: global `-l' option ignored."
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|noexec
operator|=
literal|1
expr_stmt|;
name|logoff
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|cvswrite
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
name|really_quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|trace
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
goto|goto
name|error_return
goto|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|serve_set
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
comment|/* FIXME: This sends errors immediately (I think); they should be        put into pending_error.  */
name|variable_set
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ENCRYPTION
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_KERBEROS
end_ifdef

begin_function
specifier|static
name|void
name|serve_kerberos_encrypt
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
comment|/* All future communication with the client will be encrypted.  */
name|buf_to_net
operator|=
name|krb_encrypt_buffer_initialize
argument_list|(
name|buf_to_net
argument_list|,
literal|0
argument_list|,
name|sched
argument_list|,
name|kblock
argument_list|,
name|buf_to_net
operator|->
name|memory_error
argument_list|)
expr_stmt|;
name|buf_from_net
operator|=
name|krb_encrypt_buffer_initialize
argument_list|(
name|buf_from_net
argument_list|,
literal|1
argument_list|,
name|sched
argument_list|,
name|kblock
argument_list|,
name|buf_from_net
operator|->
name|memory_error
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_KERBEROS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GSSAPI
end_ifdef

begin_function
specifier|static
name|void
name|serve_gssapi_encrypt
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|cvs_gssapi_wrapping
condition|)
block|{
comment|/* We're already using a gssapi_wrap buffer for stream 	   authentication.  Flush everything we've output so far, and 	   turn on encryption for future data.  On the input side, we 	   should only have unwrapped as far as the Gssapi-encrypt 	   command, so future unwrapping will become encrypted.  */
name|buf_flush
argument_list|(
name|buf_to_net
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cvs_gssapi_encrypt
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* All future communication with the client will be encrypted.  */
name|cvs_gssapi_encrypt
operator|=
literal|1
expr_stmt|;
name|buf_to_net
operator|=
name|cvs_gssapi_wrap_buffer_initialize
argument_list|(
name|buf_to_net
argument_list|,
literal|0
argument_list|,
name|gcontext
argument_list|,
name|buf_to_net
operator|->
name|memory_error
argument_list|)
expr_stmt|;
name|buf_from_net
operator|=
name|cvs_gssapi_wrap_buffer_initialize
argument_list|(
name|buf_from_net
argument_list|,
literal|1
argument_list|,
name|gcontext
argument_list|,
name|buf_from_net
operator|->
name|memory_error
argument_list|)
expr_stmt|;
name|cvs_gssapi_wrapping
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_GSSAPI */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ENCRYPTION */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GSSAPI
end_ifdef

begin_function
specifier|static
name|void
name|serve_gssapi_authenticate
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|cvs_gssapi_wrapping
condition|)
block|{
comment|/* We're already using a gssapi_wrap buffer for encryption. 	   That includes authentication, so we don't have to do 	   anything further.  */
return|return;
block|}
name|buf_to_net
operator|=
name|cvs_gssapi_wrap_buffer_initialize
argument_list|(
name|buf_to_net
argument_list|,
literal|0
argument_list|,
name|gcontext
argument_list|,
name|buf_to_net
operator|->
name|memory_error
argument_list|)
expr_stmt|;
name|buf_from_net
operator|=
name|cvs_gssapi_wrap_buffer_initialize
argument_list|(
name|buf_from_net
argument_list|,
literal|1
argument_list|,
name|gcontext
argument_list|,
name|buf_from_net
operator|->
name|memory_error
argument_list|)
expr_stmt|;
name|cvs_gssapi_wrapping
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_GSSAPI */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SERVER_FLOWCONTROL
end_ifdef

begin_comment
comment|/* The maximum we'll queue to the remote client before blocking.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SERVER_HI_WATER
end_ifndef

begin_define
define|#
directive|define
name|SERVER_HI_WATER
value|(2 * 1024 * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SERVER_HI_WATER */
end_comment

begin_comment
comment|/* When the buffer drops to this, we restart the child */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SERVER_LO_WATER
end_ifndef

begin_define
define|#
directive|define
name|SERVER_LO_WATER
value|(1 * 1024 * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SERVER_LO_WATER */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SERVER_FLOWCONTROL */
end_comment

begin_decl_stmt
specifier|static
name|void
name|serve_questionable
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_questionable
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
specifier|static
name|int
name|initted
decl_stmt|;
if|if
condition|(
operator|!
name|initted
condition|)
block|{
comment|/* Pick up ignores from CVSROOTADM_IGNORE, $HOME/.cvsignore on server, 	   and CVSIGNORE on server.  */
name|ign_setup
argument_list|()
expr_stmt|;
name|initted
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|dir_name
operator|==
name|NULL
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"E Protocol error: 'Directory' missing"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|outside_dir
argument_list|(
name|arg
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|ign_name
argument_list|(
name|arg
argument_list|)
condition|)
block|{
name|char
modifier|*
name|update_dir
decl_stmt|;
name|buf_output
argument_list|(
name|buf_to_net
argument_list|,
literal|"M ? "
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|update_dir
operator|=
name|dir_name
operator|+
name|strlen
argument_list|(
name|server_temp_dir
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|update_dir
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
name|buf_output
argument_list|(
name|buf_to_net
argument_list|,
literal|"/"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|buf_output
argument_list|(
name|buf_to_net
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|buffer
modifier|*
name|protocol
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the output which we are saving up to send to the server, in the    child process.  We will push it through, via the `protocol' buffer, when    we have a complete line.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|buffer
modifier|*
name|saved_output
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Likewise, but stuff which will go to stderr.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|buffer
modifier|*
name|saved_outerr
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
specifier|static
name|void
name|protocol_memory_error
parameter_list|(
name|buf
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
block|{
name|error
argument_list|(
literal|1
argument_list|,
name|ENOMEM
argument_list|,
literal|"Virtual memory exhausted"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process IDs of the subprocess, or negative if that subprocess  * does not exist.  */
end_comment

begin_decl_stmt
specifier|static
name|pid_t
name|command_pid
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|outbuf_memory_error
parameter_list|(
name|buf
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
block|{
specifier|static
specifier|const
name|char
name|msg
index|[]
init|=
literal|"E Fatal server error\n\ error ENOMEM Virtual memory exhausted.\n"
decl_stmt|;
if|if
condition|(
name|command_pid
operator|>
literal|0
condition|)
name|kill
argument_list|(
name|command_pid
argument_list|,
name|SIGTERM
argument_list|)
expr_stmt|;
comment|/*      * We have arranged things so that printing this now either will      * be legal, or the "E fatal error" line will get glommed onto the      * end of an existing "E" or "M" response.      */
comment|/* If this gives an error, not much we could do.  syslog() it?  */
name|write
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SYSLOG_H
name|syslog
argument_list|(
name|LOG_DAEMON
operator||
name|LOG_ERR
argument_list|,
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|input_memory_error
parameter_list|(
name|buf
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
block|{
name|outbuf_memory_error
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If command is legal, return 1.  * Else if command is illegal and croak_on_illegal is set, then die.  * Else just return 0 to indicate that command is illegal.  */
end_comment

begin_function
specifier|static
name|int
name|check_command_legal_p
parameter_list|(
name|cmd_name
parameter_list|)
name|char
modifier|*
name|cmd_name
decl_stmt|;
block|{
comment|/* Right now, only pserver notices illegal commands -- namely,      * write attempts by a read-only user.  Therefore, if CVS_Username      * is not set, this just returns 1, because CVS_Username unset      * means pserver is not active.      */
ifdef|#
directive|ifdef
name|AUTH_SERVER_SUPPORT
if|if
condition|(
name|CVS_Username
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|lookup_command_attribute
argument_list|(
name|cmd_name
argument_list|)
operator|&
name|CVS_CMD_MODIFIES_REPOSITORY
condition|)
block|{
comment|/* This command has the potential to modify the repository, so 	 * we check if the user have permission to do that. 	 * 	 * (Only relevant for remote users -- local users can do 	 * whatever normal Unix file permissions allow them to do.) 	 * 	 * The decision method: 	 * 	 *    If $CVSROOT/CVSADMROOT_READERS exists and user is listed 	 *    in it, then read-only access for user. 	 * 	 *    Or if $CVSROOT/CVSADMROOT_WRITERS exists and user NOT 	 *    listed in it, then also read-only access for user. 	 * 	 *    Else read-write access for user. 	 */
name|char
modifier|*
name|linebuf
init|=
name|NULL
decl_stmt|;
name|int
name|num_red
init|=
literal|0
decl_stmt|;
name|size_t
name|linebuf_len
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|size_t
name|flen
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|found_it
init|=
literal|0
decl_stmt|;
comment|/* else */
name|flen
operator|=
name|strlen
argument_list|(
name|current_parsed_root
operator|->
name|directory
argument_list|)
operator|+
name|strlen
argument_list|(
name|CVSROOTADM
argument_list|)
operator|+
name|strlen
argument_list|(
name|CVSROOTADM_READERS
argument_list|)
operator|+
literal|3
expr_stmt|;
name|fname
operator|=
name|xmalloc
argument_list|(
name|flen
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fname
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|current_parsed_root
operator|->
name|directory
argument_list|,
name|CVSROOTADM
argument_list|,
name|CVSROOTADM_READERS
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
block|{
comment|/* Need to deny access, so that attackers can't fool 		    us with some sort of denial of service attack.  */
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
comment|/* successfully opened readers file */
block|{
while|while
condition|(
operator|(
name|num_red
operator|=
name|getline
argument_list|(
operator|&
name|linebuf
argument_list|,
operator|&
name|linebuf_len
argument_list|,
name|fp
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
comment|/* Hmmm, is it worth importing my own readline 		    library into CVS?  It takes care of chopping 		    leading and trailing whitespace, "#" comments, and 		    newlines automatically when so requested.  Would 		    save some code here...  -kff */
comment|/* Chop newline by hand, for strcmp()'s sake. */
if|if
condition|(
name|num_red
operator|>
literal|0
operator|&&
name|linebuf
index|[
name|num_red
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|linebuf
index|[
name|num_red
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|linebuf
argument_list|,
name|CVS_Username
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|handle_illegal
goto|;
block|}
if|if
condition|(
name|num_red
operator|<
literal|0
operator|&&
operator|!
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
comment|/* If not listed specifically as a reader, then this user 		has write access by default unless writers are also 		specified in a file . */
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
comment|/* Now check the writers file.  */
name|flen
operator|=
name|strlen
argument_list|(
name|current_parsed_root
operator|->
name|directory
argument_list|)
operator|+
name|strlen
argument_list|(
name|CVSROOTADM
argument_list|)
operator|+
name|strlen
argument_list|(
name|CVSROOTADM_WRITERS
argument_list|)
operator|+
literal|3
expr_stmt|;
name|fname
operator|=
name|xmalloc
argument_list|(
name|flen
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fname
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|current_parsed_root
operator|->
name|directory
argument_list|,
name|CVSROOTADM
argument_list|,
name|CVSROOTADM_WRITERS
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|linebuf
condition|)
name|free
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
block|{
comment|/* Writers file does not exist, so everyone is a writer, 		    by default.  */
name|free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
comment|/* Need to deny access, so that attackers can't fool 		    us with some sort of denial of service attack.  */
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|found_it
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|num_red
operator|=
name|getline
argument_list|(
operator|&
name|linebuf
argument_list|,
operator|&
name|linebuf_len
argument_list|,
name|fp
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
comment|/* Chop newline by hand, for strcmp()'s sake. */
if|if
condition|(
name|num_red
operator|>
literal|0
operator|&&
name|linebuf
index|[
name|num_red
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|linebuf
index|[
name|num_red
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|linebuf
argument_list|,
name|CVS_Username
argument_list|)
operator|==
literal|0
condition|)
block|{
name|found_it
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|num_red
operator|<
literal|0
operator|&&
operator|!
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|found_it
condition|)
block|{
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|linebuf
condition|)
name|free
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
comment|/* writers file exists, but this user not listed in it */
block|{
name|handle_illegal
label|:
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|linebuf
condition|)
name|free
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
endif|#
directive|endif
comment|/* AUTH_SERVER_SUPPORT */
comment|/* If ever reach end of this function, command must be legal. */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Execute COMMAND in a subprocess with the approriate funky things done.  */
end_comment

begin_struct
specifier|static
struct|struct
name|fd_set_wrapper
block|{
name|fd_set
name|fds
decl_stmt|;
block|}
name|command_fds_to_drain
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|SUNOS_KLUDGE
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|max_command_fd
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SERVER_FLOWCONTROL
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|flowcontrol_pipe
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SERVER_FLOWCONTROL */
end_comment

begin_comment
comment|/*  * Set buffer FD to non-blocking I/O.  Returns 0 for success or errno  * code.  */
end_comment

begin_function
name|int
name|set_nonblock_fd
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
name|int
name|flags
decl_stmt|;
name|flags
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|<
literal|0
condition|)
return|return
name|errno
return|;
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|flags
operator||
name|O_NONBLOCK
argument_list|)
operator|<
literal|0
condition|)
return|return
name|errno
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|do_cvs_command
parameter_list|(
name|cmd_name
parameter_list|,
name|command
parameter_list|)
name|char
modifier|*
name|cmd_name
decl_stmt|;
function_decl|int
parameter_list|(
function_decl|*command
end_function_decl

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/*      * The following file descriptors are set to -1 if that file is not      * currently open.      */
comment|/* Data on these pipes is a series of '\n'-terminated lines.  */
name|int
name|stdout_pipe
index|[
literal|2
index|]
decl_stmt|;
name|int
name|stderr_pipe
index|[
literal|2
index|]
decl_stmt|;
comment|/*      * Data on this pipe is a series of counted (see buf_send_counted)      * packets.  Each packet must be processed atomically (i.e. not      * interleaved with data from stdout_pipe or stderr_pipe).      */
name|int
name|protocol_pipe
index|[
literal|2
index|]
decl_stmt|;
name|int
name|dev_null_fd
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|errs
decl_stmt|;
name|command_pid
operator|=
operator|-
literal|1
expr_stmt|;
name|stdout_pipe
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|stdout_pipe
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|stderr_pipe
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|stderr_pipe
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|protocol_pipe
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|protocol_pipe
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|server_write_entries
argument_list|()
expr_stmt|;
if|if
condition|(
name|print_pending_error
argument_list|()
condition|)
goto|goto
name|free_args_and_return
goto|;
comment|/* Global `cvs_cmd_name' is probably "server" right now -- only        serve_export() sets it to anything else.  So we will use local        parameter `cmd_name' to determine if this command is legal for        this user.  */
if|if
condition|(
operator|!
name|check_command_legal_p
argument_list|(
name|cmd_name
argument_list|)
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"E "
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|" [server aborted]: \""
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|cmd_name
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"\" requires write access to the repository\n\ error  \n"
argument_list|)
expr_stmt|;
goto|goto
name|free_args_and_return
goto|;
block|}
name|cvs_cmd_name
operator|=
name|cmd_name
expr_stmt|;
operator|(
name|void
operator|)
name|server_notify
argument_list|()
expr_stmt|;
comment|/*      * We use a child process which actually does the operation.  This      * is so we can intercept its standard output.  Even if all of CVS      * were written to go to some special routine instead of writing      * to stdout or stderr, we would still need to do the same thing      * for the RCS commands.      */
if|if
condition|(
name|pipe
argument_list|(
name|stdout_pipe
argument_list|)
operator|<
literal|0
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"E pipe failed\n"
argument_list|)
expr_stmt|;
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
if|if
condition|(
name|pipe
argument_list|(
name|stderr_pipe
argument_list|)
operator|<
literal|0
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"E pipe failed\n"
argument_list|)
expr_stmt|;
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
if|if
condition|(
name|pipe
argument_list|(
name|protocol_pipe
argument_list|)
operator|<
literal|0
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"E pipe failed\n"
argument_list|)
expr_stmt|;
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
ifdef|#
directive|ifdef
name|SERVER_FLOWCONTROL
if|if
condition|(
name|pipe
argument_list|(
name|flowcontrol_pipe
argument_list|)
operator|<
literal|0
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"E pipe failed\n"
argument_list|)
expr_stmt|;
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
name|set_nonblock_fd
argument_list|(
name|flowcontrol_pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|set_nonblock_fd
argument_list|(
name|flowcontrol_pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SERVER_FLOWCONTROL */
name|dev_null_fd
operator|=
name|CVS_OPEN
argument_list|(
name|DEVNULL
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_null_fd
operator|<
literal|0
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"E open /dev/null failed\n"
argument_list|)
expr_stmt|;
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
comment|/* We shouldn't have any partial lines from cvs_output and        cvs_outerr, but we handle them here in case there is a bug.  */
comment|/* FIXME: appending a newline, rather than using "MT" as we        do in the child process, is probably not really a very good        way to "handle" them.  */
if|if
condition|(
operator|!
name|buf_empty_p
argument_list|(
name|saved_output
argument_list|)
condition|)
block|{
name|buf_append_char
argument_list|(
name|saved_output
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|buf_copy_lines
argument_list|(
name|buf_to_net
argument_list|,
name|saved_output
argument_list|,
literal|'M'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|buf_empty_p
argument_list|(
name|saved_outerr
argument_list|)
condition|)
block|{
name|buf_append_char
argument_list|(
name|saved_outerr
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|buf_copy_lines
argument_list|(
name|buf_to_net
argument_list|,
name|saved_outerr
argument_list|,
literal|'E'
argument_list|)
expr_stmt|;
block|}
comment|/* Flush out any pending data.  */
name|buf_flush
argument_list|(
name|buf_to_net
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Don't use vfork; we're not going to exec().  */
name|command_pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|command_pid
operator|<
literal|0
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"E fork failed\n"
argument_list|)
expr_stmt|;
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
if|if
condition|(
name|command_pid
operator|==
literal|0
condition|)
block|{
name|int
name|exitstatus
decl_stmt|;
comment|/* Since we're in the child, and the parent is going to take 	   care of packaging up our error messages, we can clear this 	   flag.  */
name|error_use_protocol
operator|=
literal|0
expr_stmt|;
name|protocol
operator|=
name|fd_buffer_initialize
argument_list|(
name|protocol_pipe
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|protocol_memory_error
argument_list|)
expr_stmt|;
comment|/* At this point we should no longer be using buf_to_net and 	   buf_from_net.  Instead, everything should go through 	   protocol.  */
if|if
condition|(
name|buf_to_net
operator|!=
name|NULL
condition|)
block|{
name|buf_free
argument_list|(
name|buf_to_net
argument_list|)
expr_stmt|;
name|buf_to_net
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|buf_from_net
operator|!=
name|NULL
condition|)
block|{
name|buf_free
argument_list|(
name|buf_from_net
argument_list|)
expr_stmt|;
name|buf_from_net
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* These were originally set up to use outbuf_memory_error. 	   Since we're now in the child, we should use the simpler 	   protocol_memory_error function.  */
name|saved_output
operator|->
name|memory_error
operator|=
name|protocol_memory_error
expr_stmt|;
name|saved_outerr
operator|->
name|memory_error
operator|=
name|protocol_memory_error
expr_stmt|;
if|if
condition|(
name|dup2
argument_list|(
name|dev_null_fd
argument_list|,
name|STDIN_FILENO
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"can't set up pipes"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup2
argument_list|(
name|stdout_pipe
index|[
literal|1
index|]
argument_list|,
name|STDOUT_FILENO
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"can't set up pipes"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup2
argument_list|(
name|stderr_pipe
index|[
literal|1
index|]
argument_list|,
name|STDERR_FILENO
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"can't set up pipes"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|dev_null_fd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|stdout_pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|stdout_pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|stderr_pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|stderr_pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|protocol_pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close_on_exec
argument_list|(
name|protocol_pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_FLOWCONTROL
name|close_on_exec
argument_list|(
name|flowcontrol_pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|flowcontrol_pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SERVER_FLOWCONTROL */
comment|/* 	 * Set this in .bashrc if you want to give yourself time to attach 	 * to the subprocess with a debugger. 	 */
if|if
condition|(
name|getenv
argument_list|(
literal|"CVS_SERVER_SLEEP"
argument_list|)
condition|)
block|{
name|int
name|secs
init|=
name|atoi
argument_list|(
name|getenv
argument_list|(
literal|"CVS_SERVER_SLEEP"
argument_list|)
argument_list|)
decl_stmt|;
name|sleep
argument_list|(
name|secs
argument_list|)
expr_stmt|;
block|}
name|exitstatus
operator|=
call|(
modifier|*
name|command
call|)
argument_list|(
name|argument_count
argument_list|,
name|argument_vector
argument_list|)
expr_stmt|;
comment|/* Output any partial lines.  If the client doesn't support 	   "MT", we go ahead and just tack on a newline since the 	   protocol doesn't support anything better.  */
if|if
condition|(
operator|!
name|buf_empty_p
argument_list|(
name|saved_output
argument_list|)
condition|)
block|{
name|buf_output0
argument_list|(
name|protocol
argument_list|,
name|supported_response
argument_list|(
literal|"MT"
argument_list|)
condition|?
literal|"MT text "
else|:
literal|"M "
argument_list|)
expr_stmt|;
name|buf_append_buffer
argument_list|(
name|protocol
argument_list|,
name|saved_output
argument_list|)
expr_stmt|;
name|buf_output
argument_list|(
name|protocol
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|buf_send_counted
argument_list|(
name|protocol
argument_list|)
expr_stmt|;
block|}
comment|/* For now we just discard partial lines on stderr.  I suspect 	   that CVS can't write such lines unless there is a bug.  */
name|buf_free
argument_list|(
name|protocol
argument_list|)
expr_stmt|;
comment|/* Close the pipes explicitly in order to send an EOF to the parent, 	 * then wait for the parent to close the flow control pipe.  This 	 * avoids a race condition where a child which dumped more than the 	 * high water mark into the pipes could complete its job and exit, 	 * leaving the parent process to attempt to write a stop byte to the 	 * closed flow control pipe, which earned the parent a SIGPIPE, which 	 * it normally only expects on the network pipe and that causes it to 	 * exit with an error message, rather than the SIGCHILD that it knows 	 * how to handle correctly. 	 */
comment|/* Let exit() close STDIN - it's from /dev/null anyhow.  */
name|fclose
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|protocol_pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_FLOWCONTROL
block|{
name|char
name|junk
decl_stmt|;
name|ssize_t
name|status
decl_stmt|;
while|while
condition|(
operator|(
name|status
operator|=
name|read
argument_list|(
name|flowcontrol_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|junk
argument_list|,
literal|1
argument_list|)
operator|)
operator|>
literal|0
operator|||
operator|(
name|status
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EAGAIN
operator|)
condition|)
empty_stmt|;
block|}
comment|/* FIXME: No point in printing an error message with error(), 	 * as STDERR is already closed, but perhaps this could be syslogged? 	 */
endif|#
directive|endif
name|exit
argument_list|(
name|exitstatus
argument_list|)
expr_stmt|;
block|}
comment|/* OK, sit around getting all the input from the child.  */
block|{
name|struct
name|buffer
modifier|*
name|stdoutbuf
decl_stmt|;
name|struct
name|buffer
modifier|*
name|stderrbuf
decl_stmt|;
name|struct
name|buffer
modifier|*
name|protocol_inbuf
decl_stmt|;
comment|/* Number of file descriptors to check in select ().  */
name|int
name|num_to_check
decl_stmt|;
name|int
name|count_needed
init|=
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|SERVER_FLOWCONTROL
name|int
name|have_flowcontrolled
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* SERVER_FLOWCONTROL */
name|FD_ZERO
argument_list|(
operator|&
name|command_fds_to_drain
operator|.
name|fds
argument_list|)
expr_stmt|;
name|num_to_check
operator|=
name|stdout_pipe
index|[
literal|0
index|]
expr_stmt|;
name|FD_SET
argument_list|(
name|stdout_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|command_fds_to_drain
operator|.
name|fds
argument_list|)
expr_stmt|;
if|if
condition|(
name|stderr_pipe
index|[
literal|0
index|]
operator|>
name|num_to_check
condition|)
name|num_to_check
operator|=
name|stderr_pipe
index|[
literal|0
index|]
expr_stmt|;
name|FD_SET
argument_list|(
name|stderr_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|command_fds_to_drain
operator|.
name|fds
argument_list|)
expr_stmt|;
if|if
condition|(
name|protocol_pipe
index|[
literal|0
index|]
operator|>
name|num_to_check
condition|)
name|num_to_check
operator|=
name|protocol_pipe
index|[
literal|0
index|]
expr_stmt|;
name|FD_SET
argument_list|(
name|protocol_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|command_fds_to_drain
operator|.
name|fds
argument_list|)
expr_stmt|;
if|if
condition|(
name|STDOUT_FILENO
operator|>
name|num_to_check
condition|)
name|num_to_check
operator|=
name|STDOUT_FILENO
expr_stmt|;
ifdef|#
directive|ifdef
name|SUNOS_KLUDGE
name|max_command_fd
operator|=
name|num_to_check
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * File descriptors are numbered from 0, so num_to_check needs to 	 * be one larger than the largest descriptor. 	 */
operator|++
name|num_to_check
expr_stmt|;
if|if
condition|(
name|num_to_check
operator|>
name|FD_SETSIZE
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"E internal error: FD_SETSIZE not big enough.\n\ error  \n"
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
name|stdoutbuf
operator|=
name|fd_buffer_initialize
argument_list|(
name|stdout_pipe
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|,
name|input_memory_error
argument_list|)
expr_stmt|;
name|stderrbuf
operator|=
name|fd_buffer_initialize
argument_list|(
name|stderr_pipe
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|,
name|input_memory_error
argument_list|)
expr_stmt|;
name|protocol_inbuf
operator|=
name|fd_buffer_initialize
argument_list|(
name|protocol_pipe
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|,
name|input_memory_error
argument_list|)
expr_stmt|;
name|set_nonblock
argument_list|(
name|buf_to_net
argument_list|)
expr_stmt|;
name|set_nonblock
argument_list|(
name|stdoutbuf
argument_list|)
expr_stmt|;
name|set_nonblock
argument_list|(
name|stderrbuf
argument_list|)
expr_stmt|;
name|set_nonblock
argument_list|(
name|protocol_inbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|stdout_pipe
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"E close failed\n"
argument_list|)
expr_stmt|;
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
name|stdout_pipe
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|stderr_pipe
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"E close failed\n"
argument_list|)
expr_stmt|;
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
name|stderr_pipe
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|protocol_pipe
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"E close failed\n"
argument_list|)
expr_stmt|;
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
name|protocol_pipe
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_FLOWCONTROL
if|if
condition|(
name|close
argument_list|(
name|flowcontrol_pipe
index|[
literal|0
index|]
argument_list|)
operator|<
literal|0
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"E close failed\n"
argument_list|)
expr_stmt|;
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
name|flowcontrol_pipe
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* SERVER_FLOWCONTROL */
if|if
condition|(
name|close
argument_list|(
name|dev_null_fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"E close failed\n"
argument_list|)
expr_stmt|;
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
name|dev_null_fd
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|stdout_pipe
index|[
literal|0
index|]
operator|>=
literal|0
operator|||
name|stderr_pipe
index|[
literal|0
index|]
operator|>=
literal|0
operator|||
name|protocol_pipe
index|[
literal|0
index|]
operator|>=
literal|0
operator|||
name|count_needed
operator|<=
literal|0
condition|)
block|{
name|fd_set
name|readfds
decl_stmt|;
name|fd_set
name|writefds
decl_stmt|;
name|int
name|numfds
decl_stmt|;
name|struct
name|timeval
modifier|*
name|timeout_ptr
decl_stmt|;
name|struct
name|timeval
name|timeout
decl_stmt|;
ifdef|#
directive|ifdef
name|SERVER_FLOWCONTROL
name|int
name|bufmemsize
decl_stmt|;
comment|/* 	     * See if we are swamping the remote client and filling our VM. 	     * Tell child to hold off if we do. 	     */
name|bufmemsize
operator|=
name|buf_count_mem
argument_list|(
name|buf_to_net
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|have_flowcontrolled
operator|&&
operator|(
name|bufmemsize
operator|>
name|SERVER_HI_WATER
operator|)
condition|)
block|{
if|if
condition|(
name|write
argument_list|(
name|flowcontrol_pipe
index|[
literal|1
index|]
argument_list|,
literal|"S"
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
name|have_flowcontrolled
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|have_flowcontrolled
operator|&&
operator|(
name|bufmemsize
operator|<
name|SERVER_LO_WATER
operator|)
condition|)
block|{
if|if
condition|(
name|write
argument_list|(
name|flowcontrol_pipe
index|[
literal|1
index|]
argument_list|,
literal|"G"
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
name|have_flowcontrolled
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SERVER_FLOWCONTROL */
name|FD_ZERO
argument_list|(
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|writefds
argument_list|)
expr_stmt|;
if|if
condition|(
name|count_needed
operator|<=
literal|0
condition|)
block|{
comment|/* there is data pending which was read from the protocol pipe 		 * so don't block if we don't find any data 		 */
name|timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|timeout_ptr
operator|=
operator|&
name|timeout
expr_stmt|;
block|}
else|else
block|{
comment|/* block indefinately */
name|timeout_ptr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|buf_empty_p
argument_list|(
name|buf_to_net
argument_list|)
condition|)
name|FD_SET
argument_list|(
name|STDOUT_FILENO
argument_list|,
operator|&
name|writefds
argument_list|)
expr_stmt|;
if|if
condition|(
name|stdout_pipe
index|[
literal|0
index|]
operator|>=
literal|0
condition|)
block|{
name|FD_SET
argument_list|(
name|stdout_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|readfds
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stderr_pipe
index|[
literal|0
index|]
operator|>=
literal|0
condition|)
block|{
name|FD_SET
argument_list|(
name|stderr_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|readfds
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|protocol_pipe
index|[
literal|0
index|]
operator|>=
literal|0
condition|)
block|{
name|FD_SET
argument_list|(
name|protocol_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|readfds
argument_list|)
expr_stmt|;
block|}
comment|/* This process of selecting on the three pipes means that 	     we might not get output in the same order in which it 	     was written, thus producing the well-known 	     "out-of-order" bug.  If the child process uses 	     cvs_output and cvs_outerr, it will send everything on 	     the protocol_pipe and avoid this problem, so the 	     solution is to use cvs_output and cvs_outerr in the 	     child process.  */
do|do
block|{
comment|/* This used to select on exceptions too, but as far 		   as I know there was never any reason to do that and 		   SCO doesn't let you select on exceptions on pipes.  */
name|numfds
operator|=
name|select
argument_list|(
name|num_to_check
argument_list|,
operator|&
name|readfds
argument_list|,
operator|&
name|writefds
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
name|timeout_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|numfds
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"E select failed\n"
argument_list|)
expr_stmt|;
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
block|}
do|while
condition|(
name|numfds
operator|<
literal|0
condition|)
do|;
if|if
condition|(
name|numfds
operator|==
literal|0
condition|)
block|{
name|FD_ZERO
argument_list|(
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|writefds
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|FD_ISSET
argument_list|(
name|STDOUT_FILENO
argument_list|,
operator|&
name|writefds
argument_list|)
condition|)
block|{
comment|/* What should we do with errors?  syslog() them?  */
name|buf_send_output
argument_list|(
name|buf_to_net
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|protocol_pipe
index|[
literal|0
index|]
operator|>=
literal|0
operator|&&
operator|(
name|FD_ISSET
argument_list|(
name|protocol_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|readfds
argument_list|)
operator|)
condition|)
block|{
name|int
name|status
decl_stmt|;
name|int
name|count_read
decl_stmt|;
name|status
operator|=
name|buf_input_data
argument_list|(
name|protocol_inbuf
argument_list|,
operator|&
name|count_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|protocol_pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|protocol_pipe
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|>
literal|0
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"E buf_input_data failed\n"
argument_list|)
expr_stmt|;
name|print_error
argument_list|(
name|status
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
comment|/* 		 * We only call buf_copy_counted if we have read 		 * enough bytes to make it worthwhile.  This saves us 		 * from continually recounting the amount of data we 		 * have. 		 */
name|count_needed
operator|-=
name|count_read
expr_stmt|;
block|}
comment|/* this is still part of the protocol pipe procedure, but it is 	     * outside the above conditional so that unprocessed data can be 	     * left in the buffer and stderr/stdout can be read when a flush 	     * signal is received and control can return here without passing 	     * through the select code and maybe blocking 	     */
while|while
condition|(
name|count_needed
operator|<=
literal|0
condition|)
block|{
name|int
name|special
init|=
literal|0
decl_stmt|;
name|count_needed
operator|=
name|buf_copy_counted
argument_list|(
name|buf_to_net
argument_list|,
name|protocol_inbuf
argument_list|,
operator|&
name|special
argument_list|)
expr_stmt|;
comment|/* What should we do with errors?  syslog() them?  */
name|buf_send_output
argument_list|(
name|buf_to_net
argument_list|)
expr_stmt|;
comment|/* If SPECIAL got set to<0, it means that the child 		 * wants us to flush the pipe& maybe stderr or stdout. 		 * 		 * After that we break to read stderr& stdout again before 		 * going back to the protocol pipe 		 * 		 * Upon breaking, count_needed = 0, so the next pass will only 		 * perform a non-blocking select before returning here to finish 		 * processing data we already read from the protocol buffer 		 */
if|if
condition|(
name|special
operator|==
operator|-
literal|1
condition|)
block|{
name|cvs_flushout
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|special
operator|==
operator|-
literal|2
condition|)
block|{
comment|/* If the client supports the 'F' command, we send it. */
if|if
condition|(
name|supported_response
argument_list|(
literal|"F"
argument_list|)
condition|)
block|{
name|buf_append_char
argument_list|(
name|buf_to_net
argument_list|,
literal|'F'
argument_list|)
expr_stmt|;
name|buf_append_char
argument_list|(
name|buf_to_net
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|cvs_flusherr
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|stdout_pipe
index|[
literal|0
index|]
operator|>=
literal|0
operator|&&
operator|(
name|FD_ISSET
argument_list|(
name|stdout_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|readfds
argument_list|)
operator|)
condition|)
block|{
name|int
name|status
decl_stmt|;
name|status
operator|=
name|buf_input_data
argument_list|(
name|stdoutbuf
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|buf_copy_lines
argument_list|(
name|buf_to_net
argument_list|,
name|stdoutbuf
argument_list|,
literal|'M'
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|stdout_pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|stdout_pipe
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|>
literal|0
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"E buf_input_data failed\n"
argument_list|)
expr_stmt|;
name|print_error
argument_list|(
name|status
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
comment|/* What should we do with errors?  syslog() them?  */
name|buf_send_output
argument_list|(
name|buf_to_net
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stderr_pipe
index|[
literal|0
index|]
operator|>=
literal|0
operator|&&
operator|(
name|FD_ISSET
argument_list|(
name|stderr_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|readfds
argument_list|)
operator|)
condition|)
block|{
name|int
name|status
decl_stmt|;
name|status
operator|=
name|buf_input_data
argument_list|(
name|stderrbuf
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|buf_copy_lines
argument_list|(
name|buf_to_net
argument_list|,
name|stderrbuf
argument_list|,
literal|'E'
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|stderr_pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|stderr_pipe
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|>
literal|0
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"E buf_input_data failed\n"
argument_list|)
expr_stmt|;
name|print_error
argument_list|(
name|status
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
comment|/* What should we do with errors?  syslog() them?  */
name|buf_send_output
argument_list|(
name|buf_to_net
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * OK, we've gotten EOF on all the pipes.  If there is 	 * anything left on stdoutbuf or stderrbuf (this could only 	 * happen if there was no trailing newline), send it over. 	 */
if|if
condition|(
operator|!
name|buf_empty_p
argument_list|(
name|stdoutbuf
argument_list|)
condition|)
block|{
name|buf_append_char
argument_list|(
name|stdoutbuf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|buf_copy_lines
argument_list|(
name|buf_to_net
argument_list|,
name|stdoutbuf
argument_list|,
literal|'M'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|buf_empty_p
argument_list|(
name|stderrbuf
argument_list|)
condition|)
block|{
name|buf_append_char
argument_list|(
name|stderrbuf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|buf_copy_lines
argument_list|(
name|buf_to_net
argument_list|,
name|stderrbuf
argument_list|,
literal|'E'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|buf_empty_p
argument_list|(
name|protocol_inbuf
argument_list|)
condition|)
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"E Protocol error: uncounted data discarded\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_FLOWCONTROL
name|close
argument_list|(
name|flowcontrol_pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|flowcontrol_pipe
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* SERVER_FLOWCONTROL */
name|errs
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|command_pid
operator|>
literal|0
condition|)
block|{
name|int
name|status
decl_stmt|;
name|pid_t
name|waited_pid
decl_stmt|;
name|waited_pid
operator|=
name|waitpid
argument_list|(
name|command_pid
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|waited_pid
operator|<
literal|0
condition|)
block|{
comment|/* 		 * Intentionally ignoring EINTR.  Other errors 		 * "can't happen". 		 */
continue|continue;
block|}
if|if
condition|(
name|WIFEXITED
argument_list|(
name|status
argument_list|)
condition|)
name|errs
operator|+=
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|sig
init|=
name|WTERMSIG
argument_list|(
name|status
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|;
comment|/* 		 * This is really evil, because signals might be numbered 		 * differently on the two systems.  We should be using 		 * signal names (either of the "Terminated" or the "SIGTERM" 		 * variety).  But cvs doesn't currently use libiberty...we 		 * could roll our own....  FIXME. 		 */
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"E Terminated with fatal signal "
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d\n"
argument_list|,
name|sig
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* Test for a core dump.  */
if|if
condition|(
name|WCOREDUMP
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"E Core dumped; preserving "
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|orig_server_temp_dir
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|" on server.\n\ E CVS locks may need cleaning up.\n"
argument_list|)
expr_stmt|;
name|dont_delete_temp
operator|=
literal|1
expr_stmt|;
block|}
operator|++
name|errs
expr_stmt|;
block|}
if|if
condition|(
name|waited_pid
operator|==
name|command_pid
condition|)
name|command_pid
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 	 * OK, we've waited for the child.  By now all CVS locks are free 	 * and it's OK to block on the network. 	 */
name|set_block
argument_list|(
name|buf_to_net
argument_list|)
expr_stmt|;
name|buf_flush
argument_list|(
name|buf_to_net
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|buf_shutdown
argument_list|(
name|protocol_inbuf
argument_list|)
expr_stmt|;
name|buf_free
argument_list|(
name|protocol_inbuf
argument_list|)
expr_stmt|;
name|protocol_inbuf
operator|=
name|NULL
expr_stmt|;
name|buf_shutdown
argument_list|(
name|stderrbuf
argument_list|)
expr_stmt|;
name|buf_free
argument_list|(
name|stderrbuf
argument_list|)
expr_stmt|;
name|stderrbuf
operator|=
name|NULL
expr_stmt|;
name|buf_shutdown
argument_list|(
name|stdoutbuf
argument_list|)
expr_stmt|;
name|buf_free
argument_list|(
name|stdoutbuf
argument_list|)
expr_stmt|;
name|stdoutbuf
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|errs
condition|)
comment|/* We will have printed an error message already.  */
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"error  \n"
argument_list|)
expr_stmt|;
else|else
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"ok\n"
argument_list|)
expr_stmt|;
goto|goto
name|free_args_and_return
goto|;
name|error_exit
label|:
if|if
condition|(
name|command_pid
operator|>
literal|0
condition|)
name|kill
argument_list|(
name|command_pid
argument_list|,
name|SIGTERM
argument_list|)
expr_stmt|;
while|while
condition|(
name|command_pid
operator|>
literal|0
condition|)
block|{
name|pid_t
name|waited_pid
decl_stmt|;
name|waited_pid
operator|=
name|waitpid
argument_list|(
name|command_pid
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|waited_pid
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
if|if
condition|(
name|waited_pid
operator|==
name|command_pid
condition|)
name|command_pid
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|close
argument_list|(
name|dev_null_fd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|protocol_pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|protocol_pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|stderr_pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|stderr_pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|stdout_pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|stdout_pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_FLOWCONTROL
name|close
argument_list|(
name|flowcontrol_pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|flowcontrol_pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SERVER_FLOWCONTROL */
name|free_args_and_return
label|:
comment|/* Now free the arguments.  */
block|{
comment|/* argument_vector[0] is a dummy argument, we don't mess with it.  */
name|char
modifier|*
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|argument_vector
operator|+
literal|1
init|;
name|cp
operator|<
name|argument_vector
operator|+
name|argument_count
condition|;
operator|++
name|cp
control|)
name|free
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
name|argument_count
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Flush out any data not yet sent.  */
name|set_block
argument_list|(
name|buf_to_net
argument_list|)
expr_stmt|;
name|buf_flush
argument_list|(
name|buf_to_net
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|SERVER_FLOWCONTROL
end_ifdef

begin_comment
comment|/*  * Called by the child at convenient points in the server's execution for  * the server child to block.. ie: when it has no locks active.  */
end_comment

begin_function
name|void
name|server_pause_check
parameter_list|()
block|{
name|int
name|paused
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
literal|1
index|]
decl_stmt|;
while|while
condition|(
name|read
argument_list|(
name|flowcontrol_pipe
index|[
literal|0
index|]
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|buf
operator|==
literal|'S'
condition|)
comment|/* Stop */
name|paused
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|buf
operator|==
literal|'G'
condition|)
comment|/* Go */
name|paused
operator|=
literal|0
expr_stmt|;
else|else
return|return;
comment|/* ??? */
block|}
while|while
condition|(
name|paused
condition|)
block|{
name|int
name|numfds
decl_stmt|,
name|numtocheck
decl_stmt|;
name|fd_set
name|fds
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|flowcontrol_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fds
argument_list|)
expr_stmt|;
name|numtocheck
operator|=
name|flowcontrol_pipe
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
do|do
block|{
name|numfds
operator|=
name|select
argument_list|(
name|numtocheck
argument_list|,
operator|&
name|fds
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|numfds
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"E select failed\n"
argument_list|)
expr_stmt|;
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
do|while
condition|(
name|numfds
operator|<
literal|0
condition|)
do|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|flowcontrol_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fds
argument_list|)
condition|)
block|{
name|int
name|got
decl_stmt|;
while|while
condition|(
operator|(
name|got
operator|=
name|read
argument_list|(
name|flowcontrol_pipe
index|[
literal|0
index|]
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|buf
operator|==
literal|'S'
condition|)
comment|/* Stop */
name|paused
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|buf
operator|==
literal|'G'
condition|)
comment|/* Go */
name|paused
operator|=
literal|0
expr_stmt|;
else|else
return|return;
comment|/* ??? */
block|}
comment|/* This assumes that we are using BSD or POSIX nonblocking 	       I/O.  System V nonblocking I/O returns zero if there is 	       nothing to read.  */
if|if
condition|(
name|got
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"flow control EOF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|got
operator|<
literal|0
operator|&&
operator|!
name|blocking_error
argument_list|(
name|errno
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"flow control read failed"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SERVER_FLOWCONTROL */
end_comment

begin_comment
comment|/* This variable commented in server.h.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|server_dir
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_dir
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|output_dir
parameter_list|(
name|update_dir
parameter_list|,
name|repository
parameter_list|)
specifier|const
name|char
modifier|*
name|update_dir
decl_stmt|;
specifier|const
name|char
modifier|*
name|repository
decl_stmt|;
block|{
if|if
condition|(
name|server_dir
operator|!=
name|NULL
condition|)
block|{
name|buf_output0
argument_list|(
name|protocol
argument_list|,
name|server_dir
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
else|else
name|buf_output0
argument_list|(
name|protocol
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"/\n"
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Entries line that we are squirreling away to send to the client when  * we are ready.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|entries_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * File which has been Scratch_File'd, we are squirreling away that fact  * to inform the client when we are ready.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|scratched_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The scratched_file will need to be removed as well as having its entry  * removed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|kill_scratched_file
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|server_register
parameter_list|(
name|name
parameter_list|,
name|version
parameter_list|,
name|timestamp
parameter_list|,
name|options
parameter_list|,
name|tag
parameter_list|,
name|date
parameter_list|,
name|conflict
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|version
decl_stmt|;
specifier|const
name|char
modifier|*
name|timestamp
decl_stmt|;
specifier|const
name|char
modifier|*
name|options
decl_stmt|;
specifier|const
name|char
modifier|*
name|tag
decl_stmt|;
specifier|const
name|char
modifier|*
name|date
decl_stmt|;
specifier|const
name|char
modifier|*
name|conflict
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
name|options
operator|==
name|NULL
condition|)
name|options
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|trace
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s-> server_register(%s, %s, %s, %s, %s, %s, %s)\n"
argument_list|,
name|CLIENT_SERVER_STR
argument_list|,
name|name
argument_list|,
name|version
argument_list|,
name|timestamp
condition|?
name|timestamp
else|:
literal|""
argument_list|,
name|options
argument_list|,
name|tag
condition|?
name|tag
else|:
literal|""
argument_list|,
name|date
condition|?
name|date
else|:
literal|""
argument_list|,
name|conflict
condition|?
name|conflict
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|entries_line
operator|!=
name|NULL
condition|)
block|{
comment|/* 	 * If CVS decides to Register it more than once (which happens 	 * on "cvs update foo/foo.c" where foo and foo.c are already 	 * checked out), use the last of the entries lines Register'd. 	 */
name|free
argument_list|(
name|entries_line
argument_list|)
expr_stmt|;
block|}
comment|/*      * I have reports of Scratch_Entry and Register both happening, in      * two different cases.  Using the last one which happens is almost      * surely correct; I haven't tracked down why they both happen (or      * even verified that they are for the same file).      */
if|if
condition|(
name|scratched_file
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|scratched_file
argument_list|)
expr_stmt|;
name|scratched_file
operator|=
name|NULL
expr_stmt|;
block|}
name|len
operator|=
operator|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|version
argument_list|)
operator|+
name|strlen
argument_list|(
name|options
argument_list|)
operator|+
literal|80
operator|)
expr_stmt|;
if|if
condition|(
name|tag
condition|)
name|len
operator|+=
name|strlen
argument_list|(
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|date
condition|)
name|len
operator|+=
name|strlen
argument_list|(
name|date
argument_list|)
expr_stmt|;
name|entries_line
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|entries_line
argument_list|,
literal|"/%s/%s/"
argument_list|,
name|name
argument_list|,
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|conflict
operator|!=
name|NULL
condition|)
block|{
name|strcat
argument_list|(
name|entries_line
argument_list|,
literal|"+="
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|entries_line
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|entries_line
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|entries_line
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|!=
name|NULL
condition|)
block|{
name|strcat
argument_list|(
name|entries_line
argument_list|,
literal|"T"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|entries_line
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|date
operator|!=
name|NULL
condition|)
block|{
name|strcat
argument_list|(
name|entries_line
argument_list|,
literal|"D"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|entries_line
argument_list|,
name|date
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|server_scratch
parameter_list|(
name|fname
parameter_list|)
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
block|{
comment|/*      * I have reports of Scratch_Entry and Register both happening, in      * two different cases.  Using the last one which happens is almost      * surely correct; I haven't tracked down why they both happen (or      * even verified that they are for the same file).      *      * Don't know if this is what whoever wrote the above comment was      * talking about, but this can happen in the case where a join      * removes a file - the call to Register puts the '-vers' into the      * Entries file after the file is removed      */
if|if
condition|(
name|entries_line
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|entries_line
argument_list|)
expr_stmt|;
name|entries_line
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|scratched_file
operator|!=
name|NULL
condition|)
block|{
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"E CVS server internal error: duplicate Scratch_Entry\n"
argument_list|)
expr_stmt|;
name|buf_send_counted
argument_list|(
name|protocol
argument_list|)
expr_stmt|;
return|return;
block|}
name|scratched_file
operator|=
name|xstrdup
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|kill_scratched_file
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|server_scratch_entry_only
parameter_list|()
block|{
name|kill_scratched_file
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a new entries line, from a previous server_register.  */
end_comment

begin_function
specifier|static
name|void
name|new_entries_line
parameter_list|()
block|{
if|if
condition|(
name|entries_line
condition|)
block|{
name|buf_output0
argument_list|(
name|protocol
argument_list|,
name|entries_line
argument_list|)
expr_stmt|;
name|buf_output
argument_list|(
name|protocol
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Return the error message as the Entries line.  */
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"CVS server internal error: Register missing\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entries_line
argument_list|)
expr_stmt|;
name|entries_line
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|serve_ci
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"commit"
argument_list|,
name|commit
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|checked_in_response
parameter_list|(
name|file
parameter_list|,
name|update_dir
parameter_list|,
name|repository
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
block|{
if|if
condition|(
name|supported_response
argument_list|(
literal|"Mode"
argument_list|)
condition|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|char
modifier|*
name|mode_string
decl_stmt|;
if|if
condition|(
name|CVS_STAT
argument_list|(
name|file
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Not clear to me why the file would fail to exist, but it 	       was happening somewhere in the testsuite.  */
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot stat %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"Mode "
argument_list|)
expr_stmt|;
name|mode_string
operator|=
name|mode_to_string
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
name|mode_string
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mode_string
argument_list|)
expr_stmt|;
block|}
block|}
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"Checked-in "
argument_list|)
expr_stmt|;
name|output_dir
argument_list|(
name|update_dir
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|buf_output
argument_list|(
name|protocol
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|new_entries_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|server_checked_in
parameter_list|(
name|file
parameter_list|,
name|update_dir
parameter_list|,
name|repository
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
specifier|const
name|char
modifier|*
name|update_dir
decl_stmt|;
specifier|const
name|char
modifier|*
name|repository
decl_stmt|;
block|{
if|if
condition|(
name|noexec
condition|)
return|return;
if|if
condition|(
name|scratched_file
operator|!=
name|NULL
operator|&&
name|entries_line
operator|==
name|NULL
condition|)
block|{
comment|/* 	 * This happens if we are now doing a "cvs remove" after a previous 	 * "cvs add" (without a "cvs ci" in between). 	 */
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"Remove-entry "
argument_list|)
expr_stmt|;
name|output_dir
argument_list|(
name|update_dir
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|buf_output
argument_list|(
name|protocol
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|scratched_file
argument_list|)
expr_stmt|;
name|scratched_file
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|checked_in_response
argument_list|(
name|file
argument_list|,
name|update_dir
argument_list|,
name|repository
argument_list|)
expr_stmt|;
block|}
name|buf_send_counted
argument_list|(
name|protocol
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|server_update_entries
parameter_list|(
name|file
parameter_list|,
name|update_dir
parameter_list|,
name|repository
parameter_list|,
name|updated
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
specifier|const
name|char
modifier|*
name|update_dir
decl_stmt|;
specifier|const
name|char
modifier|*
name|repository
decl_stmt|;
name|enum
name|server_updated_arg4
name|updated
decl_stmt|;
block|{
if|if
condition|(
name|noexec
condition|)
return|return;
if|if
condition|(
name|updated
operator|==
name|SERVER_UPDATED
condition|)
name|checked_in_response
argument_list|(
name|file
argument_list|,
name|update_dir
argument_list|,
name|repository
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|supported_response
argument_list|(
literal|"New-entry"
argument_list|)
condition|)
return|return;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"New-entry "
argument_list|)
expr_stmt|;
name|output_dir
argument_list|(
name|update_dir
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|buf_output
argument_list|(
name|protocol
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|new_entries_line
argument_list|()
expr_stmt|;
block|}
name|buf_send_counted
argument_list|(
name|protocol
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|serve_update
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"update"
argument_list|,
name|update
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_diff
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"diff"
argument_list|,
name|diff
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_log
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"log"
argument_list|,
name|cvslog
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_rlog
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"rlog"
argument_list|,
name|cvslog
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_add
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"add"
argument_list|,
name|add
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_remove
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"remove"
argument_list|,
name|cvsremove
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_status
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"status"
argument_list|,
name|cvsstatus
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_rdiff
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"rdiff"
argument_list|,
name|patch
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_tag
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"tag"
argument_list|,
name|cvstag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_rtag
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"rtag"
argument_list|,
name|cvstag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_import
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"import"
argument_list|,
name|import
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_admin
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"admin"
argument_list|,
name|admin
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_history
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"history"
argument_list|,
name|history
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_release
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"release"
argument_list|,
name|release
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|serve_watch_on
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_watch_on
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"watch"
argument_list|,
name|watch_on
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|serve_watch_off
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_watch_off
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"watch"
argument_list|,
name|watch_off
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|serve_watch_add
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_watch_add
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"watch"
argument_list|,
name|watch_add
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|serve_watch_remove
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_watch_remove
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"watch"
argument_list|,
name|watch_remove
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|serve_watchers
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_watchers
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"watchers"
argument_list|,
name|watchers
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|serve_editors
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_editors
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"editors"
argument_list|,
name|editors
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|serve_noop
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_noop
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|server_write_entries
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|print_pending_error
argument_list|()
condition|)
block|{
operator|(
name|void
operator|)
name|server_notify
argument_list|()
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"ok\n"
argument_list|)
expr_stmt|;
block|}
name|buf_flush
argument_list|(
name|buf_to_net
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|serve_version
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_version
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"version"
argument_list|,
name|version
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|serve_init
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_init
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|cvsroot_t
modifier|*
name|saved_parsed_root
decl_stmt|;
if|if
condition|(
operator|!
name|isabsolute
argument_list|(
name|arg
argument_list|)
condition|)
block|{
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E init %s must be an absolute pathname"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AUTH_SERVER_SUPPORT
elseif|else
if|if
condition|(
name|Pserver_Repos
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|Pserver_Repos
argument_list|,
name|arg
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|Pserver_Repos
argument_list|)
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
comment|/* The explicitness is to aid people who are writing clients. 		   I don't see how this information could help an 		   attacker.  */
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"\ E Protocol error: init says \"%s\" but pserver says \"%s\""
argument_list|,
name|arg
argument_list|,
name|Pserver_Repos
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|print_pending_error
argument_list|()
condition|)
return|return;
name|saved_parsed_root
operator|=
name|current_parsed_root
expr_stmt|;
name|current_parsed_root
operator|=
name|local_cvsroot
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|do_cvs_command
argument_list|(
literal|"init"
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|free_cvsroot_t
argument_list|(
name|current_parsed_root
argument_list|)
expr_stmt|;
name|current_parsed_root
operator|=
name|saved_parsed_root
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|serve_annotate
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_annotate
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"annotate"
argument_list|,
name|annotate
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|serve_rannotate
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_rannotate
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
literal|"rannotate"
argument_list|,
name|annotate
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|serve_co
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|char
modifier|*
name|tempdir
decl_stmt|;
name|int
name|status
decl_stmt|;
if|if
condition|(
name|print_pending_error
argument_list|()
condition|)
return|return;
if|if
condition|(
operator|!
name|isdir
argument_list|(
name|CVSADM
argument_list|)
condition|)
block|{
comment|/* 	 * The client has not sent a "Repository" line.  Check out 	 * into a pristine directory. 	 */
name|tempdir
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|server_temp_dir
argument_list|)
operator|+
literal|80
argument_list|)
expr_stmt|;
if|if
condition|(
name|tempdir
operator|==
name|NULL
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"E Out of memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|tempdir
argument_list|,
name|server_temp_dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tempdir
argument_list|,
literal|"/checkout-dir"
argument_list|)
expr_stmt|;
name|status
operator|=
name|mkdir_p
argument_list|(
name|tempdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
operator|&&
name|status
operator|!=
name|EEXIST
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"E Cannot create "
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|tempdir
argument_list|)
expr_stmt|;
name|buf_append_char
argument_list|(
name|buf_to_net
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tempdir
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|CVS_CHDIR
argument_list|(
name|tempdir
argument_list|)
operator|<
literal|0
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"E Cannot change to directory "
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|tempdir
argument_list|)
expr_stmt|;
name|buf_append_char
argument_list|(
name|buf_to_net
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tempdir
argument_list|)
expr_stmt|;
return|return;
block|}
name|free
argument_list|(
name|tempdir
argument_list|)
expr_stmt|;
block|}
comment|/* Compensate for server_export()'s setting of cvs_cmd_name.      *      * [It probably doesn't matter if do_cvs_command() gets "export"      *  or "checkout", but we ought to be accurate where possible.]      */
name|do_cvs_command
argument_list|(
operator|(
name|strcmp
argument_list|(
name|cvs_cmd_name
argument_list|,
literal|"export"
argument_list|)
operator|==
literal|0
operator|)
condition|?
literal|"export"
else|:
literal|"checkout"
argument_list|,
name|checkout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_export
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
comment|/* Tell checkout() to behave like export not checkout.  */
name|cvs_cmd_name
operator|=
literal|"export"
expr_stmt|;
name|serve_co
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|server_copy_file
parameter_list|(
name|file
parameter_list|,
name|update_dir
parameter_list|,
name|repository
parameter_list|,
name|newfile
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
specifier|const
name|char
modifier|*
name|update_dir
decl_stmt|;
specifier|const
name|char
modifier|*
name|repository
decl_stmt|;
specifier|const
name|char
modifier|*
name|newfile
decl_stmt|;
block|{
comment|/* At least for now, our practice is to have the server enforce        noexec for the repository and the client enforce it for the        working directory.  This might want more thought, and/or        documentation in cvsclient.texi (other responses do it        differently).  */
if|if
condition|(
operator|!
name|supported_response
argument_list|(
literal|"Copy-file"
argument_list|)
condition|)
return|return;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"Copy-file "
argument_list|)
expr_stmt|;
name|output_dir
argument_list|(
name|update_dir
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
name|newfile
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* See server.h for description.  */
end_comment

begin_function
name|void
name|server_modtime
parameter_list|(
name|finfo
parameter_list|,
name|vers_ts
parameter_list|)
name|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
name|Vers_TS
modifier|*
name|vers_ts
decl_stmt|;
block|{
name|char
name|date
index|[
name|MAXDATELEN
index|]
decl_stmt|;
name|char
name|outdate
index|[
name|MAXDATELEN
index|]
decl_stmt|;
name|assert
argument_list|(
name|vers_ts
operator|->
name|vn_rcs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|supported_response
argument_list|(
literal|"Mod-time"
argument_list|)
condition|)
return|return;
if|if
condition|(
name|RCS_getrevtime
argument_list|(
name|finfo
operator|->
name|rcs
argument_list|,
name|vers_ts
operator|->
name|vn_rcs
argument_list|,
name|date
argument_list|,
literal|0
argument_list|)
operator|==
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
comment|/* FIXME? should we be printing some kind of warning?  For one 	   thing I'm not 100% sure whether this happens in non-error 	   circumstances.  */
return|return;
name|date_to_internet
argument_list|(
name|outdate
argument_list|,
name|date
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"Mod-time "
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
name|outdate
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* See server.h for description.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_PROTOTYPES
argument_list|)
condition|?
name|USE_PROTOTYPES
expr|:
name|defined
argument_list|(
name|__STDC__
argument_list|)
end_if

begin_comment
comment|/* Need to prototype because mode_t might be smaller than int.  */
end_comment

begin_decl_stmt
name|void
name|server_updated
argument_list|(
expr|struct
name|file_info
operator|*
name|finfo
argument_list|,
name|Vers_TS
operator|*
name|vers
argument_list|,
expr|enum
name|server_updated_arg4
name|updated
argument_list|,
name|mode_t
name|mode
argument_list|,
name|unsigned
name|char
operator|*
name|checksum
argument_list|,
expr|struct
name|buffer
operator|*
name|filebuf
argument_list|)
else|#
directive|else
name|void
name|server_updated
argument_list|(
name|finfo
argument_list|,
name|vers
argument_list|,
name|updated
argument_list|,
name|mode
argument_list|,
name|checksum
argument_list|,
name|filebuf
argument_list|)
decl|struct
name|file_info
modifier|*
name|finfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Vers_TS
modifier|*
name|vers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|server_updated_arg4
name|updated
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|mode_t
name|mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|checksum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|buffer
modifier|*
name|filebuf
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
if|if
condition|(
name|noexec
condition|)
block|{
comment|/* Hmm, maybe if we did the same thing for entries_file, we 	   could get rid of the kludges in server_register and 	   server_scratch which refrain from warning if both 	   Scratch_Entry and Register get called.  Maybe.  */
if|if
condition|(
name|scratched_file
condition|)
block|{
name|free
argument_list|(
name|scratched_file
argument_list|)
expr_stmt|;
name|scratched_file
operator|=
name|NULL
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|entries_line
operator|!=
name|NULL
operator|&&
name|scratched_file
operator|==
name|NULL
condition|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|struct
name|buffer_data
modifier|*
name|list
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|char
name|size_text
index|[
literal|80
index|]
decl_stmt|;
comment|/* The contents of the file will be in one of filebuf, 	   list/last, or here.  */
name|unsigned
name|char
modifier|*
name|file
decl_stmt|;
name|size_t
name|file_allocated
decl_stmt|;
name|size_t
name|file_used
decl_stmt|;
if|if
condition|(
name|filebuf
operator|!=
name|NULL
condition|)
block|{
name|size
operator|=
name|buf_length
argument_list|(
name|filebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
operator|(
name|mode_t
operator|)
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"\ CVS server internal error: no mode in server_updated"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
name|CVS_STAT
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
block|{
comment|/* If we have a sticky tag for a branch on which 		       the file is dead, and cvs update the directory, 		       it gets a T_CHECKOUT but no file.  So in this 		       case just forget the whole thing.  */
name|free
argument_list|(
name|entries_line
argument_list|)
expr_stmt|;
name|entries_line
operator|=
name|NULL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"reading %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
block|}
name|size
operator|=
name|sb
operator|.
name|st_size
expr_stmt|;
if|if
condition|(
name|mode
operator|==
operator|(
name|mode_t
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* FIXME: When we check out files the umask of the 		   server (set in .bashrc if rsh is in use) affects 		   what mode we send, and it shouldn't.  */
name|mode
operator|=
name|sb
operator|.
name|st_mode
expr_stmt|;
block|}
block|}
if|if
condition|(
name|checksum
operator|!=
name|NULL
condition|)
block|{
specifier|static
name|int
name|checksum_supported
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|checksum_supported
operator|==
operator|-
literal|1
condition|)
block|{
name|checksum_supported
operator|=
name|supported_response
argument_list|(
literal|"Checksum"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|checksum_supported
condition|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|3
index|]
decl_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"Checksum "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%02x"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|checksum
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|buf_append_char
argument_list|(
name|protocol
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|updated
operator|==
name|SERVER_UPDATED
condition|)
block|{
name|Node
modifier|*
name|node
decl_stmt|;
name|Entnode
modifier|*
name|entnode
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|supported_response
argument_list|(
literal|"Created"
argument_list|)
operator|&&
name|supported_response
argument_list|(
literal|"Update-existing"
argument_list|)
operator|)
condition|)
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"Updated "
argument_list|)
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
name|vers
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|vers
operator|->
name|ts_user
operator|==
name|NULL
condition|)
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"Created "
argument_list|)
expr_stmt|;
else|else
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"Update-existing "
argument_list|)
expr_stmt|;
block|}
comment|/* Now munge the entries to say that the file is unmodified, 	       in case we end up processing it again (e.g. modules3-6 	       in the testsuite).  */
name|node
operator|=
name|findnode_fn
argument_list|(
name|finfo
operator|->
name|entries
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|entnode
operator|=
name|node
operator|->
name|data
expr_stmt|;
name|free
argument_list|(
name|entnode
operator|->
name|timestamp
argument_list|)
expr_stmt|;
name|entnode
operator|->
name|timestamp
operator|=
name|xstrdup
argument_list|(
literal|"="
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|updated
operator|==
name|SERVER_MERGED
condition|)
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"Merged "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|updated
operator|==
name|SERVER_PATCHED
condition|)
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"Patched "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|updated
operator|==
name|SERVER_RCS_DIFF
condition|)
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"Rcs-diff "
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|output_dir
argument_list|(
name|finfo
operator|->
name|update_dir
argument_list|,
name|finfo
operator|->
name|repository
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|buf_output
argument_list|(
name|protocol
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|new_entries_line
argument_list|()
expr_stmt|;
block|{
name|char
modifier|*
name|mode_string
decl_stmt|;
name|mode_string
operator|=
name|mode_to_string
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
name|mode_string
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mode_string
argument_list|)
expr_stmt|;
block|}
name|list
operator|=
name|last
operator|=
name|NULL
expr_stmt|;
name|file
operator|=
name|NULL
expr_stmt|;
name|file_allocated
operator|=
literal|0
expr_stmt|;
name|file_used
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
comment|/* Throughout this section we use binary mode to read the 	       file we are sending.  The client handles any line ending 	       translation if necessary.  */
if|if
condition|(
name|file_gzip_level
comment|/* 		 * For really tiny files, the gzip process startup 		 * time will outweigh the compression savings.  This 		 * might be computable somehow; using 100 here is just 		 * a first approximation. 		 */
operator|&&
name|size
operator|>
literal|100
condition|)
block|{
comment|/* Basing this routine on read_and_gzip is not a 		   high-performance approach.  But it seems easier 		   to code than the alternative (and less 		   vulnerable to subtle bugs).  Given that this feature 		   is mainly for compatibility, that is the better 		   tradeoff.  */
name|int
name|fd
decl_stmt|;
comment|/* Callers must avoid passing us a buffer if 		   file_gzip_level is set.  We could handle this case, 		   but it's not worth it since this case never arises 		   with a current client and server.  */
if|if
condition|(
name|filebuf
operator|!=
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"\ CVS server internal error: unhandled case in server_updated"
argument_list|)
expr_stmt|;
name|fd
operator|=
name|CVS_OPEN
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
name|O_RDONLY
operator||
name|OPEN_BINARY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"reading %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_and_gzip
argument_list|(
name|fd
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|,
operator|&
name|file
argument_list|,
operator|&
name|file_allocated
argument_list|,
operator|&
name|file_used
argument_list|,
name|file_gzip_level
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"aborting due to compression error"
argument_list|)
expr_stmt|;
name|size
operator|=
name|file_used
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"reading %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
comment|/* Prepending length with "z" is flag for using gzip here.  */
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"z"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|filebuf
operator|==
name|NULL
condition|)
block|{
name|long
name|status
decl_stmt|;
name|f
operator|=
name|CVS_FOPEN
argument_list|(
name|finfo
operator|->
name|file
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"reading %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|status
operator|=
name|buf_read_file
argument_list|(
name|f
argument_list|,
name|size
argument_list|,
operator|&
name|list
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
operator|-
literal|2
condition|)
call|(
modifier|*
name|protocol
operator|->
name|memory_error
call|)
argument_list|(
name|protocol
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|ferror
argument_list|(
name|f
argument_list|)
condition|?
name|errno
else|:
literal|0
argument_list|,
literal|"reading %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"reading %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
block|}
block|}
name|sprintf
argument_list|(
name|size_text
argument_list|,
literal|"%lu\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
name|size_text
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|!=
name|NULL
condition|)
block|{
name|buf_output
argument_list|(
name|protocol
argument_list|,
operator|(
name|char
operator|*
operator|)
name|file
argument_list|,
name|file_used
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|file
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|filebuf
operator|==
name|NULL
condition|)
name|buf_append_data
argument_list|(
name|protocol
argument_list|,
name|list
argument_list|,
name|last
argument_list|)
expr_stmt|;
else|else
block|{
name|buf_append_buffer
argument_list|(
name|protocol
argument_list|,
name|filebuf
argument_list|)
expr_stmt|;
block|}
comment|/* Note we only send a newline here if the file ended with one.  */
comment|/* 	 * Avoid using up too much disk space for temporary files. 	 * A file which does not exist indicates that the file is up-to-date, 	 * which is now the case.  If this is SERVER_MERGED, the file is 	 * not up-to-date, and we indicate that by leaving the file there. 	 * I'm thinking of cases like "cvs update foo/foo.c foo". 	 */
if|if
condition|(
operator|(
name|updated
operator|==
name|SERVER_UPDATED
operator|||
name|updated
operator|==
name|SERVER_PATCHED
operator|||
name|updated
operator|==
name|SERVER_RCS_DIFF
operator|)
operator|&&
name|filebuf
operator|==
name|NULL
comment|/* But if we are joining, we'll need the file when we call 	       join_file.  */
operator|&&
operator|!
name|joining
argument_list|()
condition|)
block|{
if|if
condition|(
name|CVS_UNLINK
argument_list|(
name|finfo
operator|->
name|file
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot remove temp file for %s"
argument_list|,
name|finfo
operator|->
name|fullname
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|scratched_file
operator|!=
name|NULL
operator|&&
name|entries_line
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|scratched_file
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"CVS server internal error: `%s' vs. `%s' scratched"
argument_list|,
name|scratched_file
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|scratched_file
argument_list|)
expr_stmt|;
name|scratched_file
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|kill_scratched_file
condition|)
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"Removed "
argument_list|)
expr_stmt|;
else|else
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"Remove-entry "
argument_list|)
expr_stmt|;
name|output_dir
argument_list|(
name|finfo
operator|->
name|update_dir
argument_list|,
name|finfo
operator|->
name|repository
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
name|finfo
operator|->
name|file
argument_list|)
expr_stmt|;
name|buf_output
argument_list|(
name|protocol
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* keep the vers structure up to date in case we do a join 	 * - if there isn't a file, it can't very well have a version number, can it? 	 * 	 * we do it here on the assumption that since we just told the client 	 * to remove the file/entry, it will, and we want to remember that. 	 * If it fails, that's the client's problem, not ours 	 */
if|if
condition|(
name|vers
operator|&&
name|vers
operator|->
name|vn_user
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|vers
operator|->
name|vn_user
argument_list|)
expr_stmt|;
name|vers
operator|->
name|vn_user
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|vers
operator|&&
name|vers
operator|->
name|ts_user
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|vers
operator|->
name|ts_user
argument_list|)
expr_stmt|;
name|vers
operator|->
name|ts_user
operator|=
name|NULL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|scratched_file
operator|==
name|NULL
operator|&&
name|entries_line
operator|==
name|NULL
condition|)
block|{
comment|/* 	 * This can happen with death support if we were processing 	 * a dead file in a checkout. 	 */
block|}
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"CVS server internal error: Register *and* Scratch_Entry.\n"
argument_list|)
expr_stmt|;
name|buf_send_counted
argument_list|(
name|protocol
argument_list|)
expr_stmt|;
name|done
label|:
empty_stmt|;
block|}
end_block

begin_comment
comment|/* Return whether we should send patches in RCS format.  */
end_comment

begin_function
name|int
name|server_use_rcs_diff
parameter_list|()
block|{
return|return
name|supported_response
argument_list|(
literal|"Rcs-diff"
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|server_set_entstat
parameter_list|(
name|update_dir
parameter_list|,
name|repository
parameter_list|)
specifier|const
name|char
modifier|*
name|update_dir
decl_stmt|;
specifier|const
name|char
modifier|*
name|repository
decl_stmt|;
block|{
specifier|static
name|int
name|set_static_supported
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|set_static_supported
operator|==
operator|-
literal|1
condition|)
name|set_static_supported
operator|=
name|supported_response
argument_list|(
literal|"Set-static-directory"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set_static_supported
condition|)
return|return;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"Set-static-directory "
argument_list|)
expr_stmt|;
name|output_dir
argument_list|(
name|update_dir
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|buf_send_counted
argument_list|(
name|protocol
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|server_clear_entstat
parameter_list|(
name|update_dir
parameter_list|,
name|repository
parameter_list|)
specifier|const
name|char
modifier|*
name|update_dir
decl_stmt|;
specifier|const
name|char
modifier|*
name|repository
decl_stmt|;
block|{
specifier|static
name|int
name|clear_static_supported
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|clear_static_supported
operator|==
operator|-
literal|1
condition|)
name|clear_static_supported
operator|=
name|supported_response
argument_list|(
literal|"Clear-static-directory"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|clear_static_supported
condition|)
return|return;
if|if
condition|(
name|noexec
condition|)
return|return;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"Clear-static-directory "
argument_list|)
expr_stmt|;
name|output_dir
argument_list|(
name|update_dir
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|buf_send_counted
argument_list|(
name|protocol
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|server_set_sticky
parameter_list|(
name|update_dir
parameter_list|,
name|repository
parameter_list|,
name|tag
parameter_list|,
name|date
parameter_list|,
name|nonbranch
parameter_list|)
specifier|const
name|char
modifier|*
name|update_dir
decl_stmt|;
specifier|const
name|char
modifier|*
name|repository
decl_stmt|;
specifier|const
name|char
modifier|*
name|tag
decl_stmt|;
specifier|const
name|char
modifier|*
name|date
decl_stmt|;
name|int
name|nonbranch
decl_stmt|;
block|{
specifier|static
name|int
name|set_sticky_supported
init|=
operator|-
literal|1
decl_stmt|;
name|assert
argument_list|(
name|update_dir
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_sticky_supported
operator|==
operator|-
literal|1
condition|)
name|set_sticky_supported
operator|=
name|supported_response
argument_list|(
literal|"Set-sticky"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set_sticky_supported
condition|)
return|return;
if|if
condition|(
name|noexec
condition|)
return|return;
if|if
condition|(
name|tag
operator|==
name|NULL
operator|&&
name|date
operator|==
name|NULL
condition|)
block|{
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"Clear-sticky "
argument_list|)
expr_stmt|;
name|output_dir
argument_list|(
name|update_dir
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"Set-sticky "
argument_list|)
expr_stmt|;
name|output_dir
argument_list|(
name|update_dir
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|nonbranch
condition|)
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"N"
argument_list|)
expr_stmt|;
else|else
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"T"
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"D"
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
name|date
argument_list|)
expr_stmt|;
block|}
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|buf_send_counted
argument_list|(
name|protocol
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|template_proc_data
block|{
specifier|const
name|char
modifier|*
name|update_dir
decl_stmt|;
specifier|const
name|char
modifier|*
name|repository
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Here as a static until we get around to fixing Parse_Info to pass along    a void * for it.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|template_proc_data
modifier|*
name|tpd
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|template_proc
parameter_list|(
name|repository
parameter_list|,
name|template
parameter_list|)
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|template
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|struct
name|template_proc_data
modifier|*
name|data
init|=
name|tpd
decl_stmt|;
if|if
condition|(
operator|!
name|supported_response
argument_list|(
literal|"Template"
argument_list|)
condition|)
comment|/* Might want to warn the user that the rcsinfo feature won't work.  */
return|return
literal|0
return|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"Template "
argument_list|)
expr_stmt|;
name|output_dir
argument_list|(
name|data
operator|->
name|update_dir
argument_list|,
name|data
operator|->
name|repository
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|template
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"Couldn't open rcsinfo template file %s"
argument_list|,
name|template
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot stat rcsinfo template file %s"
argument_list|,
name|template
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|sb
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|protocol
argument_list|,
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|n
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|buf_output
argument_list|(
name|protocol
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read rcsinfo template file %s"
argument_list|,
name|template
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|buf_send_counted
argument_list|(
name|protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close rcsinfo template file %s"
argument_list|,
name|template
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|server_template
parameter_list|(
name|update_dir
parameter_list|,
name|repository
parameter_list|)
specifier|const
name|char
modifier|*
name|update_dir
decl_stmt|;
specifier|const
name|char
modifier|*
name|repository
decl_stmt|;
block|{
name|struct
name|template_proc_data
name|data
decl_stmt|;
name|data
operator|.
name|update_dir
operator|=
name|update_dir
expr_stmt|;
name|data
operator|.
name|repository
operator|=
name|repository
expr_stmt|;
name|tpd
operator|=
operator|&
name|data
expr_stmt|;
operator|(
name|void
operator|)
name|Parse_Info
argument_list|(
name|CVSROOTADM_RCSINFO
argument_list|,
name|repository
argument_list|,
name|template_proc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_gzip_contents
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|int
name|level
decl_stmt|;
name|level
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|==
literal|0
condition|)
name|level
operator|=
literal|6
expr_stmt|;
name|file_gzip_level
operator|=
name|level
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_gzip_stream
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|int
name|level
decl_stmt|;
name|level
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|==
literal|0
condition|)
name|level
operator|=
literal|6
expr_stmt|;
comment|/* All further communication with the client will be compressed.  */
name|buf_to_net
operator|=
name|compress_buffer_initialize
argument_list|(
name|buf_to_net
argument_list|,
literal|0
argument_list|,
name|level
argument_list|,
name|buf_to_net
operator|->
name|memory_error
argument_list|)
expr_stmt|;
name|buf_from_net
operator|=
name|compress_buffer_initialize
argument_list|(
name|buf_from_net
argument_list|,
literal|1
argument_list|,
name|level
argument_list|,
name|buf_from_net
operator|->
name|memory_error
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Tell the client about RCS options set in CVSROOT/cvswrappers. */
end_comment

begin_function
specifier|static
name|void
name|serve_wrapper_sendme_rcs_options
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
comment|/* Actually, this is kind of sdrawkcab-ssa: the client wants      * verbatim lines from a cvswrappers file, but the server has      * already parsed the cvswrappers file into the wrap_list struct.      * Therefore, the server loops over wrap_list, unparsing each      * entry before sending it.      */
name|char
modifier|*
name|wrapper_line
init|=
name|NULL
decl_stmt|;
name|wrap_setup
argument_list|()
expr_stmt|;
for|for
control|(
name|wrap_unparse_rcs_options
argument_list|(
operator|&
name|wrapper_line
argument_list|,
literal|1
argument_list|)
init|;
name|wrapper_line
condition|;
name|wrap_unparse_rcs_options
argument_list|(
operator|&
name|wrapper_line
argument_list|,
literal|0
argument_list|)
control|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"Wrapper-rcsOption "
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|wrapper_line
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"\012"
argument_list|)
expr_stmt|;
empty_stmt|;
name|free
argument_list|(
name|wrapper_line
argument_list|)
expr_stmt|;
block|}
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"ok\012"
argument_list|)
expr_stmt|;
comment|/* The client is waiting for us, so we better send the data now.  */
name|buf_flush
argument_list|(
name|buf_to_net
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|serve_ignore
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
comment|/*      * Just ignore this command.  This is used to support the      * update-patches command, which is not a real command, but a signal      * to the client that update will accept the -u argument.      */
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|expand_proc
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|where
parameter_list|,
name|mwhere
parameter_list|,
name|mfile
parameter_list|,
name|shorten
parameter_list|,
name|local_specified
parameter_list|,
name|omodule
parameter_list|,
name|msg
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|where
decl_stmt|;
name|char
modifier|*
name|mwhere
decl_stmt|;
name|char
modifier|*
name|mfile
decl_stmt|;
name|int
name|shorten
decl_stmt|;
name|int
name|local_specified
decl_stmt|;
name|char
modifier|*
name|omodule
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|dir
init|=
name|argv
index|[
literal|0
index|]
decl_stmt|;
comment|/* If mwhere has been specified, the thing we're expanding is a        module -- just return its name so the client will ask for the        right thing later.  If it is an alias or a real directory,        mwhere will not be set, so send out the appropriate        expansion. */
if|if
condition|(
name|mwhere
operator|!=
name|NULL
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"Module-expansion "
argument_list|)
expr_stmt|;
if|if
condition|(
name|server_dir
operator|!=
name|NULL
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|server_dir
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|mwhere
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfile
operator|!=
name|NULL
condition|)
block|{
name|buf_append_char
argument_list|(
name|buf_to_net
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|mfile
argument_list|)
expr_stmt|;
block|}
name|buf_append_char
argument_list|(
name|buf_to_net
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We may not need to do this anymore -- check the definition 	   of aliases before removing */
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"Module-expansion "
argument_list|)
expr_stmt|;
if|if
condition|(
name|server_dir
operator|!=
name|NULL
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|server_dir
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|buf_append_char
argument_list|(
name|buf_to_net
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"Module-expansion "
argument_list|)
expr_stmt|;
if|if
condition|(
name|server_dir
operator|!=
name|NULL
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|server_dir
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|buf_append_char
argument_list|(
name|buf_to_net
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|buf_append_char
argument_list|(
name|buf_to_net
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_expand_modules
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|err
decl_stmt|;
name|DBM
modifier|*
name|db
decl_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
name|db
operator|=
name|open_module
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argument_count
condition|;
name|i
operator|++
control|)
name|err
operator|+=
name|do_module
argument_list|(
name|db
argument_list|,
name|argument_vector
index|[
name|i
index|]
argument_list|,
name|CHECKOUT
argument_list|,
literal|"Updating"
argument_list|,
name|expand_proc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|close_module
argument_list|(
name|db
argument_list|)
expr_stmt|;
block|{
comment|/* argument_vector[0] is a dummy argument, we don't mess with it.  */
name|char
modifier|*
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|argument_vector
operator|+
literal|1
init|;
name|cp
operator|<
name|argument_vector
operator|+
name|argument_count
condition|;
operator|++
name|cp
control|)
name|free
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
name|argument_count
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
comment|/* We will have printed an error message already.  */
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"error  \n"
argument_list|)
expr_stmt|;
else|else
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"ok\n"
argument_list|)
expr_stmt|;
comment|/* The client is waiting for the module expansions, so we must        send the output now.  */
name|buf_flush
argument_list|(
name|buf_to_net
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|serve_valid_requests
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|arg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SERVER_SUPPORT */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SERVER_SUPPORT
argument_list|)
operator|||
name|defined
argument_list|(
name|CLIENT_SUPPORT
argument_list|)
end_if

begin_comment
comment|/*  * Parts of this table are shared with the client code,  * but the client doesn't need to know about the handler  * functions.  */
end_comment

begin_decl_stmt
name|struct
name|request
name|requests
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
define|#
directive|define
name|REQ_LINE
parameter_list|(
name|n
parameter_list|,
name|f
parameter_list|,
name|s
parameter_list|)
value|{n, f, s}
else|#
directive|else
define|#
directive|define
name|REQ_LINE
parameter_list|(
name|n
parameter_list|,
name|f
parameter_list|,
name|s
parameter_list|)
value|{n, s}
endif|#
directive|endif
name|REQ_LINE
argument_list|(
literal|"Root"
argument_list|,
name|serve_root
argument_list|,
name|RQ_ESSENTIAL
operator||
name|RQ_ROOTLESS
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Valid-responses"
argument_list|,
name|serve_valid_responses
argument_list|,
name|RQ_ESSENTIAL
operator||
name|RQ_ROOTLESS
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"valid-requests"
argument_list|,
name|serve_valid_requests
argument_list|,
name|RQ_ESSENTIAL
operator||
name|RQ_ROOTLESS
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Repository"
argument_list|,
name|serve_repository
argument_list|,
literal|0
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Directory"
argument_list|,
name|serve_directory
argument_list|,
name|RQ_ESSENTIAL
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Max-dotdot"
argument_list|,
name|serve_max_dotdot
argument_list|,
literal|0
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Static-directory"
argument_list|,
name|serve_static_directory
argument_list|,
literal|0
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Sticky"
argument_list|,
name|serve_sticky
argument_list|,
literal|0
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Entry"
argument_list|,
name|serve_entry
argument_list|,
name|RQ_ESSENTIAL
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Kopt"
argument_list|,
name|serve_kopt
argument_list|,
literal|0
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Checkin-time"
argument_list|,
name|serve_checkin_time
argument_list|,
literal|0
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Modified"
argument_list|,
name|serve_modified
argument_list|,
name|RQ_ESSENTIAL
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Is-modified"
argument_list|,
name|serve_is_modified
argument_list|,
literal|0
argument_list|)
block|,
comment|/* The client must send this request to interoperate with CVS 1.5      through 1.9 servers.  The server must support it (although it can      be and is a noop) to interoperate with CVS 1.5 to 1.9 clients.  */
name|REQ_LINE
argument_list|(
literal|"UseUnchanged"
argument_list|,
name|serve_enable_unchanged
argument_list|,
name|RQ_ENABLEME
operator||
name|RQ_ROOTLESS
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Unchanged"
argument_list|,
name|serve_unchanged
argument_list|,
name|RQ_ESSENTIAL
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Notify"
argument_list|,
name|serve_notify
argument_list|,
literal|0
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Questionable"
argument_list|,
name|serve_questionable
argument_list|,
literal|0
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Argument"
argument_list|,
name|serve_argument
argument_list|,
name|RQ_ESSENTIAL
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Argumentx"
argument_list|,
name|serve_argumentx
argument_list|,
name|RQ_ESSENTIAL
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Global_option"
argument_list|,
name|serve_global_option
argument_list|,
name|RQ_ROOTLESS
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Gzip-stream"
argument_list|,
name|serve_gzip_stream
argument_list|,
literal|0
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"wrapper-sendme-rcsOptions"
argument_list|,
name|serve_wrapper_sendme_rcs_options
argument_list|,
literal|0
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Set"
argument_list|,
name|serve_set
argument_list|,
name|RQ_ROOTLESS
argument_list|)
block|,
ifdef|#
directive|ifdef
name|ENCRYPTION
ifdef|#
directive|ifdef
name|HAVE_KERBEROS
name|REQ_LINE
argument_list|(
literal|"Kerberos-encrypt"
argument_list|,
name|serve_kerberos_encrypt
argument_list|,
literal|0
argument_list|)
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_GSSAPI
name|REQ_LINE
argument_list|(
literal|"Gssapi-encrypt"
argument_list|,
name|serve_gssapi_encrypt
argument_list|,
literal|0
argument_list|)
block|,
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_GSSAPI
name|REQ_LINE
argument_list|(
literal|"Gssapi-authenticate"
argument_list|,
name|serve_gssapi_authenticate
argument_list|,
literal|0
argument_list|)
block|,
endif|#
directive|endif
name|REQ_LINE
argument_list|(
literal|"expand-modules"
argument_list|,
name|serve_expand_modules
argument_list|,
literal|0
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"ci"
argument_list|,
name|serve_ci
argument_list|,
name|RQ_ESSENTIAL
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"co"
argument_list|,
name|serve_co
argument_list|,
name|RQ_ESSENTIAL
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"update"
argument_list|,
name|serve_update
argument_list|,
name|RQ_ESSENTIAL
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"diff"
argument_list|,
name|serve_diff
argument_list|,
literal|0
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"log"
argument_list|,
name|serve_log
argument_list|,
literal|0
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"rlog"
argument_list|,
name|serve_rlog
argument_list|,
literal|0
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"add"
argument_list|,
name|serve_add
argument_list|,
literal|0
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"remove"
argument_list|,
name|serve_remove
argument_list|,
literal|0
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"update-patches"
argument_list|,
name|serve_ignore
argument_list|,
literal|0
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"gzip-file-contents"
argument_list|,
name|serve_gzip_contents
argument_list|,
literal|0
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"status"
argument_list|,
name|serve_status
argument_list|,
literal|0
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"rdiff"
argument_list|,
name|serve_rdiff
argument_list|,
literal|0
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"tag"
argument_list|,
name|serve_tag
argument_list|,
literal|0
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"rtag"
argument_list|,
name|serve_rtag
argument_list|,
literal|0
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"import"
argument_list|,
name|serve_import
argument_list|,
literal|0
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"admin"
argument_list|,
name|serve_admin
argument_list|,
literal|0
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"export"
argument_list|,
name|serve_export
argument_list|,
literal|0
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"history"
argument_list|,
name|serve_history
argument_list|,
literal|0
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"release"
argument_list|,
name|serve_release
argument_list|,
literal|0
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"watch-on"
argument_list|,
name|serve_watch_on
argument_list|,
literal|0
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"watch-off"
argument_list|,
name|serve_watch_off
argument_list|,
literal|0
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"watch-add"
argument_list|,
name|serve_watch_add
argument_list|,
literal|0
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"watch-remove"
argument_list|,
name|serve_watch_remove
argument_list|,
literal|0
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"watchers"
argument_list|,
name|serve_watchers
argument_list|,
literal|0
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"editors"
argument_list|,
name|serve_editors
argument_list|,
literal|0
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"init"
argument_list|,
name|serve_init
argument_list|,
name|RQ_ROOTLESS
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"annotate"
argument_list|,
name|serve_annotate
argument_list|,
literal|0
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"rannotate"
argument_list|,
name|serve_rannotate
argument_list|,
literal|0
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"noop"
argument_list|,
name|serve_noop
argument_list|,
name|RQ_ROOTLESS
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"version"
argument_list|,
name|serve_version
argument_list|,
name|RQ_ROOTLESS
argument_list|)
block|,
name|REQ_LINE
argument_list|(
argument|NULL
argument_list|,
argument|NULL
argument_list|,
literal|0
argument_list|)
undef|#
directive|undef
name|REQ_LINE
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SERVER_SUPPORT or CLIENT_SUPPORT */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
end_ifdef

begin_function
specifier|static
name|void
name|serve_valid_requests
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|request
modifier|*
name|rq
decl_stmt|;
if|if
condition|(
name|print_pending_error
argument_list|()
condition|)
return|return;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"Valid-requests"
argument_list|)
expr_stmt|;
for|for
control|(
name|rq
operator|=
name|requests
init|;
name|rq
operator|->
name|name
operator|!=
name|NULL
condition|;
name|rq
operator|++
control|)
block|{
if|if
condition|(
name|rq
operator|->
name|func
operator|!=
name|NULL
condition|)
block|{
name|buf_append_char
argument_list|(
name|buf_to_net
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|rq
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"\nok\n"
argument_list|)
expr_stmt|;
comment|/* The client is waiting for the list of valid requests, so we        must send the output now.  */
name|buf_flush
argument_list|(
name|buf_to_net
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SUNOS_KLUDGE
end_ifdef

begin_comment
comment|/*  * Delete temporary files.  SIG is the signal making this happen, or  * 0 if not called as a result of a signal.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|command_pid_is_dead
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|wait_sig
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|pid_t
name|r
init|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|command_pid
condition|)
name|command_pid_is_dead
operator|++
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SUNOS_KLUDGE */
end_comment

begin_function
name|void
name|server_cleanup
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
comment|/* Do "rm -rf" on the temp directory.  */
name|int
name|status
decl_stmt|;
name|int
name|save_noexec
decl_stmt|;
if|if
condition|(
name|buf_to_net
operator|!=
name|NULL
condition|)
block|{
comment|/* Since we're done, go ahead and put BUF_TO_NET back into blocking 	 * mode and send any pending output.  In the usual case there won't 	 * won't be any, but there might be if an error occured. 	 */
name|set_block
argument_list|(
name|buf_to_net
argument_list|)
expr_stmt|;
name|buf_flush
argument_list|(
name|buf_to_net
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Next we shut down BUF_FROM_NET.  That will pick up the checksum 	 * generated when the client shuts down its buffer.  Then, after we 	 * have generated any final output, we shut down BUF_TO_NET. 	 */
if|if
condition|(
name|buf_from_net
operator|!=
name|NULL
condition|)
block|{
name|status
operator|=
name|buf_shutdown
argument_list|(
name|buf_from_net
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|status
argument_list|,
literal|"shutting down buffer from client"
argument_list|)
expr_stmt|;
name|buf_free
argument_list|(
name|buf_from_net
argument_list|)
expr_stmt|;
name|buf_from_net
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|dont_delete_temp
condition|)
block|{
operator|(
name|void
operator|)
name|buf_flush
argument_list|(
name|buf_to_net
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|buf_shutdown
argument_list|(
name|buf_to_net
argument_list|)
expr_stmt|;
name|buf_free
argument_list|(
name|buf_to_net
argument_list|)
expr_stmt|;
name|buf_to_net
operator|=
name|NULL
expr_stmt|;
name|error_use_protocol
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|dont_delete_temp
condition|)
return|return;
comment|/* What a bogus kludge.  This disgusting code makes all kinds of        assumptions about SunOS, and is only for a bug in that system.        So only enable it on Suns.  */
ifdef|#
directive|ifdef
name|SUNOS_KLUDGE
if|if
condition|(
name|command_pid
operator|>
literal|0
condition|)
block|{
comment|/* To avoid crashes on SunOS due to bugs in SunOS tmpfs 	   triggered by the use of rename() in RCS, wait for the 	   subprocess to die.  Unfortunately, this means draining output 	   while waiting for it to unblock the signal we sent it.  Yuck!  */
name|int
name|status
decl_stmt|;
name|pid_t
name|r
decl_stmt|;
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|wait_sig
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig
condition|)
comment|/* Perhaps SIGTERM would be more correct.  But the child 	       process will delay the SIGINT delivery until its own 	       children have exited.  */
name|kill
argument_list|(
name|command_pid
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
comment|/* The caller may also have sent a signal to command_pid, so 	   always try waiting.  First, though, check and see if it's still 	   there....  */
name|do_waitpid
label|:
name|r
operator|=
name|waitpid
argument_list|(
name|command_pid
argument_list|,
operator|&
name|status
argument_list|,
name|WNOHANG
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|r
operator|==
name|command_pid
condition|)
name|command_pid_is_dead
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ECHILD
case|:
name|command_pid_is_dead
operator|++
expr_stmt|;
break|break;
case|case
name|EINTR
case|:
goto|goto
name|do_waitpid
goto|;
block|}
else|else
comment|/* waitpid should always return one of the above values */
name|abort
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|command_pid_is_dead
condition|)
block|{
name|struct
name|timeval
name|timeout
decl_stmt|;
name|struct
name|fd_set_wrapper
name|readfds
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Use a non-zero timeout to avoid eating up CPU cycles.  */
name|timeout
operator|.
name|tv_sec
operator|=
literal|2
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|readfds
operator|=
name|command_fds_to_drain
expr_stmt|;
switch|switch
condition|(
name|select
argument_list|(
name|max_command_fd
operator|+
literal|1
argument_list|,
operator|&
name|readfds
operator|.
name|fds
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|timeout
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
name|abort
argument_list|()
expr_stmt|;
case|case
literal|0
case|:
comment|/* timeout */
break|break;
case|case
literal|1
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|max_command_fd
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|FD_ISSET
argument_list|(
name|i
argument_list|,
operator|&
name|readfds
operator|.
name|fds
argument_list|)
condition|)
continue|continue;
comment|/* this fd is non-blocking */
while|while
condition|(
name|read
argument_list|(
name|i
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|>=
literal|1
condition|)
empty_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* SUNOS_KLUDGE */
name|CVS_CHDIR
argument_list|(
name|Tmpdir
argument_list|)
expr_stmt|;
comment|/* Temporarily clear noexec, so that we clean up our temp directory        regardless of it (this could more cleanly be handled by moving        the noexec check to all the unlink_file_dir callers from        unlink_file_dir itself).  */
name|save_noexec
operator|=
name|noexec
expr_stmt|;
name|noexec
operator|=
literal|0
expr_stmt|;
comment|/* FIXME?  Would be nice to not ignore errors.  But what should we do?        We could try to do this before we shut down the network connection,        and try to notify the client (but the client might not be waiting        for responses).  We could try something like syslog() or our own        log file.  */
name|unlink_file_dir
argument_list|(
name|orig_server_temp_dir
argument_list|)
expr_stmt|;
name|noexec
operator|=
name|save_noexec
expr_stmt|;
if|if
condition|(
name|buf_to_net
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|buf_flush
argument_list|(
name|buf_to_net
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|buf_shutdown
argument_list|(
name|buf_to_net
argument_list|)
expr_stmt|;
name|buf_free
argument_list|(
name|buf_to_net
argument_list|)
expr_stmt|;
name|buf_to_net
operator|=
name|NULL
expr_stmt|;
name|error_use_protocol
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
name|int
name|server_active
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|server
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|error_prog_name
decl_stmt|;
comment|/* Used in error messages */
if|if
condition|(
name|argc
operator|==
operator|-
literal|1
condition|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|msg
index|[]
init|=
block|{
literal|"Usage: %s %s\n"
block|,
literal|"  Normally invoked by a cvs client on a remote machine.\n"
block|,
name|NULL
block|}
decl_stmt|;
name|usage
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
comment|/* Ignore argc and argv.  They might be from .cvsrc.  */
name|buf_to_net
operator|=
name|fd_buffer_initialize
argument_list|(
name|STDOUT_FILENO
argument_list|,
literal|0
argument_list|,
name|outbuf_memory_error
argument_list|)
expr_stmt|;
name|buf_from_net
operator|=
name|stdio_buffer_initialize
argument_list|(
name|stdin
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|outbuf_memory_error
argument_list|)
expr_stmt|;
name|saved_output
operator|=
name|buf_nonio_initialize
argument_list|(
name|outbuf_memory_error
argument_list|)
expr_stmt|;
name|saved_outerr
operator|=
name|buf_nonio_initialize
argument_list|(
name|outbuf_memory_error
argument_list|)
expr_stmt|;
comment|/* Since we're in the server parent process, error should use the        protocol to report error messages.  */
name|error_use_protocol
operator|=
literal|1
expr_stmt|;
comment|/* OK, now figure out where we stash our temporary files.  */
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* The code which wants to chdir into server_temp_dir is not set 	   up to deal with it being a relative path.  So give an error 	   for that case.  */
if|if
condition|(
operator|!
name|isabsolute
argument_list|(
name|Tmpdir
argument_list|)
condition|)
block|{
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|Tmpdir
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E Value of %s for TMPDIR is not absolute"
argument_list|,
name|Tmpdir
argument_list|)
expr_stmt|;
comment|/* FIXME: we would like this error to be persistent, that 	       is, not cleared by print_pending_error.  The current client 	       will exit as soon as it gets an error, but the protocol spec 	       does not require a client to do so.  */
block|}
else|else
block|{
name|int
name|status
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|server_temp_dir
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|Tmpdir
argument_list|)
operator|+
literal|80
argument_list|)
expr_stmt|;
if|if
condition|(
name|server_temp_dir
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Strictly speaking, we're not supposed to output anything 		 * now.  But we're about to exit(), give it a try. 		 */
name|printf
argument_list|(
literal|"E Fatal server error, aborting.\n\ error ENOMEM Virtual memory exhausted.\n"
argument_list|)
expr_stmt|;
name|error_exit
argument_list|()
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|server_temp_dir
argument_list|,
name|Tmpdir
argument_list|)
expr_stmt|;
comment|/* Remove a trailing slash from TMPDIR if present.  */
name|p
operator|=
name|server_temp_dir
operator|+
name|strlen
argument_list|(
name|server_temp_dir
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	     * I wanted to use cvs-serv/PID, but then you have to worry about 	     * the permissions on the cvs-serv directory being right.  So 	     * use cvs-servPID. 	     */
name|strcat
argument_list|(
name|server_temp_dir
argument_list|,
literal|"/cvs-serv"
argument_list|)
expr_stmt|;
name|p
operator|=
name|server_temp_dir
operator|+
name|strlen
argument_list|(
name|server_temp_dir
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|orig_server_temp_dir
operator|=
name|server_temp_dir
expr_stmt|;
comment|/* Create the temporary directory, and set the mode to 	       700, to discourage random people from tampering with 	       it.  */
while|while
condition|(
operator|(
name|status
operator|=
name|mkdir_p
argument_list|(
name|server_temp_dir
argument_list|)
operator|)
operator|==
name|EEXIST
condition|)
block|{
specifier|static
specifier|const
name|char
name|suffix
index|[]
init|=
literal|"abcdefghijklmnopqrstuvwxyz"
decl_stmt|;
if|if
condition|(
name|i
operator|>=
sizeof|sizeof
name|suffix
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|p
operator|=
name|server_temp_dir
operator|+
name|strlen
argument_list|(
name|server_temp_dir
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|suffix
index|[
name|i
operator|++
index|]
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|server_temp_dir
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E can't create temporary directory %s"
argument_list|,
name|server_temp_dir
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|status
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|CHMOD_BROKEN
elseif|else
if|if
condition|(
name|chmod
argument_list|(
name|server_temp_dir
argument_list|,
name|S_IRWXU
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|server_temp_dir
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot change permissions on temporary directory %s"
argument_list|,
name|server_temp_dir
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|save_errno
expr_stmt|;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|CVS_CHDIR
argument_list|(
name|server_temp_dir
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|server_temp_dir
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot change to temporary directory %s"
argument_list|,
name|server_temp_dir
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|save_errno
expr_stmt|;
block|}
block|}
block|}
comment|/* Now initialize our argument vector (for arguments from the client).  */
comment|/* Small for testing.  */
name|argument_vector_size
operator|=
literal|1
expr_stmt|;
name|argument_vector
operator|=
name|xmalloc
argument_list|(
name|argument_vector_size
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|argument_count
operator|=
literal|1
expr_stmt|;
comment|/* This gets printed if the client supports an option which the        server doesn't, causing the server to print a usage message.        FIXME: just a nit, I suppose, but the usage message the server        prints isn't literally true--it suggests "cvs server" followed        by options which are for a particular command.  Might be nice to        say something like "client apparently supports an option not supported        by this server" or something like that instead of usage message.  */
name|error_prog_name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|program_name
argument_list|)
operator|+
literal|8
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|error_prog_name
argument_list|,
literal|"%s server"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|argument_vector
index|[
literal|0
index|]
operator|=
name|error_prog_name
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|char
modifier|*
name|cmd
decl_stmt|,
modifier|*
name|orig_cmd
decl_stmt|;
name|struct
name|request
modifier|*
name|rq
decl_stmt|;
name|int
name|status
decl_stmt|;
name|status
operator|=
name|buf_read_line
argument_list|(
name|buf_from_net
argument_list|,
operator|&
name|cmd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
operator|-
literal|2
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"E Fatal server error, aborting.\n\ error ENOMEM Virtual memory exhausted.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
break|break;
name|orig_cmd
operator|=
name|cmd
expr_stmt|;
for|for
control|(
name|rq
operator|=
name|requests
init|;
name|rq
operator|->
name|name
operator|!=
name|NULL
condition|;
operator|++
name|rq
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|cmd
argument_list|,
name|rq
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|rq
operator|->
name|name
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|rq
operator|->
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmd
index|[
name|len
index|]
operator|==
literal|'\0'
condition|)
name|cmd
operator|+=
name|len
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd
index|[
name|len
index|]
operator|==
literal|' '
condition|)
name|cmd
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
else|else
comment|/* 		     * The first len characters match, but it's a different 		     * command.  e.g. the command is "cooperate" but we matched 		     * "co". 		     */
continue|continue;
if|if
condition|(
operator|!
operator|(
name|rq
operator|->
name|flags
operator|&
name|RQ_ROOTLESS
operator|)
operator|&&
name|current_parsed_root
operator|==
name|NULL
condition|)
block|{
comment|/* For commands which change the way in which data 		       is sent and received, for example Gzip-stream, 		       this does the wrong thing.  Since the client 		       assumes that everything is being compressed, 		       unconditionally, there is no way to give this 		       error to the client without turning on 		       compression.  The obvious fix would be to make 		       Gzip-stream RQ_ROOTLESS (with the corresponding 		       change to the spec), and that might be a good 		       idea but then again I can see some settings in 		       CVSROOT about what compression level to allow. 		       I suppose a more baroque answer would be to 		       turn on compression (say, at level 1), just 		       enough to give the "Root request missing" 		       error.  For now we just lose.  */
if|if
condition|(
name|alloc_pending
argument_list|(
literal|80
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E Protocol error: Root request missing"
argument_list|)
expr_stmt|;
block|}
else|else
call|(
modifier|*
name|rq
operator|->
name|func
call|)
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rq
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|print_pending_error
argument_list|()
condition|)
block|{
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
literal|"error  unrecognized request `"
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf_to_net
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|buf_append_char
argument_list|(
name|buf_to_net
argument_list|,
literal|'\''
argument_list|)
expr_stmt|;
name|buf_append_char
argument_list|(
name|buf_to_net
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|orig_cmd
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|error_prog_name
argument_list|)
expr_stmt|;
comment|/* We expect the client is done talking to us at this point.  If there is      * any data in the buffer or on the network pipe, then something we didn't      * prepare for is happening.      */
if|if
condition|(
operator|!
name|buf_empty
argument_list|(
name|buf_from_net
argument_list|)
condition|)
block|{
comment|/* Try to send the error message to the client, but also syslog it, in 	 * case the client isn't listening anymore. 	 */
ifdef|#
directive|ifdef
name|HAVE_SYSLOG_H
comment|/* FIXME: Can the IP address of the connecting client be retrieved 	 * and printed here? 	 */
name|syslog
argument_list|(
name|LOG_DAEMON
operator||
name|LOG_ERR
argument_list|,
literal|"Dying gasps received from client."
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Dying gasps received from client."
argument_list|)
expr_stmt|;
block|}
comment|/* This command will actually close the network buffers.  */
name|server_cleanup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_KERBEROS
argument_list|)
operator|||
name|defined
argument_list|(
name|AUTH_SERVER_SUPPORT
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_GSSAPI
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|void
name|switch_to_user
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|switch_to_user
parameter_list|(
name|cvs_username
parameter_list|,
name|username
parameter_list|)
specifier|const
name|char
modifier|*
name|cvs_username
decl_stmt|;
comment|/* Only used for error messages. */
specifier|const
name|char
modifier|*
name|username
decl_stmt|;
block|{
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|pw
operator|=
name|getpwnam
argument_list|(
name|username
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
block|{
comment|/* check_password contains a similar check, so this usually won't be 	   reached unless the CVS user is mapped to an invalid system user.  */
name|printf
argument_list|(
literal|"E Fatal error, aborting.\n\ error 0 %s: no such system user\n"
argument_list|,
name|username
argument_list|)
expr_stmt|;
comment|/* Don't worry about server_cleanup; server_active isn't set yet.  */
name|error_exit
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|pw
operator|->
name|pw_uid
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SYSLOG_H
comment|/* FIXME: Can the IP address of the connecting client be retrieved 	     * and printed here? 	     */
name|syslog
argument_list|(
name|LOG_DAEMON
operator||
name|LOG_ALERT
argument_list|,
literal|"attempt to root from account: %s"
argument_list|,
name|cvs_username
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"error 0: root not allowed\n"
argument_list|)
expr_stmt|;
name|error_exit
argument_list|()
expr_stmt|;
block|}
if|#
directive|if
name|HAVE_INITGROUPS
if|if
condition|(
name|initgroups
argument_list|(
name|pw
operator|->
name|pw_name
argument_list|,
name|pw
operator|->
name|pw_gid
argument_list|)
operator|<
literal|0
ifdef|#
directive|ifdef
name|EPERM
comment|/* At least on the system I tried, initgroups() only works as root. 	   But we do still want to report ENOMEM and whatever other 	   errors initgroups() might dish up.  */
operator|&&
name|errno
operator|!=
name|EPERM
endif|#
directive|endif
condition|)
block|{
comment|/* This could be a warning, but I'm not sure I see the point 	   in doing that instead of an error given that it would happen 	   on every connection.  We could log it somewhere and not tell 	   the user.  But at least for now make it an error.  */
name|printf
argument_list|(
literal|"error 0 initgroups failed: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't worry about server_cleanup; server_active isn't set yet.  */
name|error_exit
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_INITGROUPS */
ifdef|#
directive|ifdef
name|SETXID_SUPPORT
comment|/* honor the setgid bit iff set*/
if|if
condition|(
name|getgid
argument_list|()
operator|!=
name|getegid
argument_list|()
condition|)
block|{
if|if
condition|(
name|setgid
argument_list|(
name|getegid
argument_list|()
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* See comments at setuid call below for more discussion.  */
name|printf
argument_list|(
literal|"error 0 setgid failed: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't worry about server_cleanup; 	       server_active isn't set yet.  */
name|error_exit
argument_list|()
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
if|if
condition|(
name|setgid
argument_list|(
name|pw
operator|->
name|pw_gid
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* See comments at setuid call below for more discussion.  */
name|printf
argument_list|(
literal|"error 0 setgid failed: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SYSLOG_H
name|syslog
argument_list|(
name|LOG_DAEMON
operator||
name|LOG_ERR
argument_list|,
literal|"setgid to %d failed (%m): real %d/%d, effective %d/%d "
argument_list|,
name|pw
operator|->
name|pw_gid
argument_list|,
name|getuid
argument_list|()
argument_list|,
name|getgid
argument_list|()
argument_list|,
name|geteuid
argument_list|()
argument_list|,
name|getegid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Don't worry about server_cleanup; 	       server_active isn't set yet.  */
name|error_exit
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|setuid
argument_list|(
name|pw
operator|->
name|pw_uid
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Note that this means that if run as a non-root user, 	   CVSROOT/passwd must contain the user we are running as 	   (e.g. "joe:FsEfVcu:cvs" if run as "cvs" user).  This seems 	   cleaner than ignoring the error like CVS 1.10 and older but 	   it does mean that some people might need to update their 	   CVSROOT/passwd file.  */
name|printf
argument_list|(
literal|"error 0 setuid failed: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SYSLOG_H
name|syslog
argument_list|(
name|LOG_DAEMON
operator||
name|LOG_ERR
argument_list|,
literal|"setuid to %d failed (%m): real %d/%d, effective %d/%d "
argument_list|,
name|pw
operator|->
name|pw_uid
argument_list|,
name|getuid
argument_list|()
argument_list|,
name|getgid
argument_list|()
argument_list|,
name|geteuid
argument_list|()
argument_list|,
name|getegid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Don't worry about server_cleanup; server_active isn't set yet.  */
name|error_exit
argument_list|()
expr_stmt|;
block|}
comment|/* We don't want our umask to change file modes.  The modes should        be set by the modes used in the repository, and by the umask of        the client.  */
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTH_SERVER_SUPPORT
comment|/* Make sure our CVS_Username has been set. */
if|if
condition|(
name|CVS_Username
operator|==
name|NULL
condition|)
name|CVS_Username
operator|=
name|xstrdup
argument_list|(
name|username
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_PUTENV
comment|/* Set LOGNAME, USER and CVS_USER in the environment, in case they        are already set to something else.  */
block|{
name|char
modifier|*
name|env
decl_stmt|;
name|env
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
expr|"LOGNAME="
operator|+
name|strlen
argument_list|(
name|username
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|env
argument_list|,
literal|"LOGNAME=%s"
argument_list|,
name|username
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|env
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
expr|"USER="
operator|+
name|strlen
argument_list|(
name|username
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|env
argument_list|,
literal|"USER=%s"
argument_list|,
name|username
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTH_SERVER_SUPPORT
name|env
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
expr|"CVS_USER="
operator|+
name|strlen
argument_list|(
name|CVS_Username
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|env
argument_list|,
literal|"CVS_USER=%s"
argument_list|,
name|CVS_Username
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* HAVE_PUTENV */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|AUTH_SERVER_SUPPORT
end_ifdef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|crypt
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  * 0 means no entry found for this user.  * 1 means entry found and password matches (or found password is empty)  * 2 means entry found, but password does not match.  *  * If 1, host_user_ptr will be set to point at the system  * username (i.e., the "real" identity, which may or may not be the  * CVS username) of this user; caller may free this.  Global  * CVS_Username will point at an allocated copy of cvs username (i.e.,  * the username argument below).  * kff todo: FIXME: last sentence is not true, it applies to caller.  */
end_comment

begin_function
specifier|static
name|int
name|check_repository_password
parameter_list|(
name|username
parameter_list|,
name|password
parameter_list|,
name|repository
parameter_list|,
name|host_user_ptr
parameter_list|)
name|char
modifier|*
name|username
decl_stmt|,
decl|*
name|password
decl_stmt|,
modifier|*
name|repository
decl_stmt|,
modifier|*
modifier|*
name|host_user_ptr
decl_stmt|;
end_function

begin_block
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|linebuf
init|=
name|NULL
decl_stmt|;
name|size_t
name|linebuf_len
decl_stmt|;
name|int
name|found_it
init|=
literal|0
decl_stmt|;
name|int
name|namelen
decl_stmt|;
comment|/* We don't use current_parsed_root->directory because it hasn't been      * set yet -- our `repository' argument came from the authentication      * protocol, not the regular CVS protocol.      */
name|filename
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|repository
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|CVSROOTADM
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|CVSROOTADM_PASSWD
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|filename
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|repository
argument_list|,
name|CVSROOTADM
argument_list|,
name|CVSROOTADM_PASSWD
argument_list|)
expr_stmt|;
name|fp
operator|=
name|CVS_FOPEN
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Look for a relevant line -- one with this user's name. */
name|namelen
operator|=
name|strlen
argument_list|(
name|username
argument_list|)
expr_stmt|;
while|while
condition|(
name|getline
argument_list|(
operator|&
name|linebuf
argument_list|,
operator|&
name|linebuf_len
argument_list|,
name|fp
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|linebuf
argument_list|,
name|username
argument_list|,
name|namelen
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|linebuf
index|[
name|namelen
index|]
operator|==
literal|':'
operator|)
condition|)
block|{
name|found_it
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/* If found_it, then linebuf contains the information we need. */
if|if
condition|(
name|found_it
condition|)
block|{
name|char
modifier|*
name|found_password
decl_stmt|,
modifier|*
name|host_user_tmp
decl_stmt|;
name|char
modifier|*
name|non_cvsuser_portion
decl_stmt|;
comment|/* We need to make sure lines such as 	 * 	 *    "username::sysuser\n" 	 *    "username:\n" 	 *    "username:  \n" 	 * 	 * all result in a found_password of NULL, but we also need to 	 * make sure that 	 * 	 *    "username:   :sysuser\n" 	 *    "username:<whatever>:sysuser\n" 	 * 	 * continues to result in an impossible password.  That way, 	 * an admin would be on safe ground by going in and tacking a 	 * space onto the front of a password to disable the account 	 * (a technique some people use to close accounts 	 * temporarily). 	 */
comment|/* Make `non_cvsuser_portion' contain everything after the CVS 	   username, but null out any final newline. */
name|non_cvsuser_portion
operator|=
name|linebuf
operator|+
name|namelen
expr_stmt|;
name|strtok
argument_list|(
name|non_cvsuser_portion
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* If there's a colon now, we just want to inch past it. */
if|if
condition|(
name|strchr
argument_list|(
name|non_cvsuser_portion
argument_list|,
literal|':'
argument_list|)
operator|==
name|non_cvsuser_portion
condition|)
name|non_cvsuser_portion
operator|++
expr_stmt|;
comment|/* Okay, after this conditional chain, found_password and 	   host_user_tmp will have useful values: */
if|if
condition|(
operator|(
name|non_cvsuser_portion
operator|==
name|NULL
operator|)
operator|||
operator|(
name|strlen
argument_list|(
name|non_cvsuser_portion
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|strspn
argument_list|(
name|non_cvsuser_portion
argument_list|,
literal|" \t"
argument_list|)
operator|)
operator|==
name|strlen
argument_list|(
name|non_cvsuser_portion
argument_list|)
operator|)
condition|)
block|{
name|found_password
operator|=
name|NULL
expr_stmt|;
name|host_user_tmp
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|non_cvsuser_portion
argument_list|,
literal|":"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|found_password
operator|=
name|NULL
expr_stmt|;
name|host_user_tmp
operator|=
name|non_cvsuser_portion
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|host_user_tmp
argument_list|)
operator|==
literal|0
condition|)
name|host_user_tmp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|found_password
operator|=
name|strtok
argument_list|(
name|non_cvsuser_portion
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|host_user_tmp
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
comment|/* Of course, maybe there was no system user portion... */
if|if
condition|(
name|host_user_tmp
operator|==
name|NULL
condition|)
name|host_user_tmp
operator|=
name|username
expr_stmt|;
comment|/* Verify blank passwords directly, otherwise use crypt(). */
if|if
condition|(
operator|(
name|found_password
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|strcmp
argument_list|(
name|found_password
argument_list|,
name|crypt
argument_list|(
name|password
argument_list|,
name|found_password
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* Give host_user_ptr permanent storage. */
operator|*
name|host_user_ptr
operator|=
name|xstrdup
argument_list|(
name|host_user_tmp
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|LOG_AUTHPRIV
name|syslog
argument_list|(
name|LOG_AUTHPRIV
operator||
name|LOG_NOTICE
argument_list|,
literal|"password mismatch for %s in %s: %s vs. %s"
argument_list|,
name|username
argument_list|,
name|repository
argument_list|,
name|crypt
argument_list|(
name|password
argument_list|,
name|found_password
argument_list|)
argument_list|,
name|found_password
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|host_user_ptr
operator|=
name|NULL
expr_stmt|;
name|retval
operator|=
literal|2
expr_stmt|;
block|}
block|}
else|else
comment|/* Didn't find this user, so deny access. */
block|{
operator|*
name|host_user_ptr
operator|=
name|NULL
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
block|}
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|linebuf
condition|)
name|free
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_block

begin_comment
comment|/* Return a hosting username if password matches, else NULL. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|check_password
parameter_list|(
name|username
parameter_list|,
name|password
parameter_list|,
name|repository
parameter_list|)
name|char
modifier|*
name|username
decl_stmt|,
decl|*
name|password
decl_stmt|,
modifier|*
name|repository
decl_stmt|;
end_function

begin_block
block|{
name|int
name|rc
decl_stmt|;
name|char
modifier|*
name|host_user
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|found_passwd
init|=
name|NULL
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
comment|/* First we see if this user has a password in the CVS-specific        password file.  If so, that's enough to authenticate with.  If        not, we'll check /etc/passwd. */
name|rc
operator|=
name|check_repository_password
argument_list|(
name|username
argument_list|,
name|password
argument_list|,
name|repository
argument_list|,
operator|&
name|host_user
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|2
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|rc
operator|==
literal|1
condition|)
block|{
comment|/* host_user already set by reference, so just return. */
goto|goto
name|handle_return
goto|;
block|}
name|assert
argument_list|(
name|rc
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|system_auth
condition|)
block|{
comment|/* Note that the message _does_ distinguish between the case in 	   which we check for a system password and the case in which 	   we do not.  It is a real pain to track down why it isn't 	   letting you in if it won't say why, and I am not convinced 	   that the potential information disclosure to an attacker 	   outweighs this.  */
name|printf
argument_list|(
literal|"error 0 no such user %s in CVSROOT/passwd\n"
argument_list|,
name|username
argument_list|)
expr_stmt|;
name|error_exit
argument_list|()
expr_stmt|;
block|}
comment|/* No cvs password found, so try /etc/passwd. */
ifdef|#
directive|ifdef
name|HAVE_GETSPNAM
block|{
name|struct
name|spwd
modifier|*
name|spw
decl_stmt|;
name|spw
operator|=
name|getspnam
argument_list|(
name|username
argument_list|)
expr_stmt|;
if|if
condition|(
name|spw
operator|!=
name|NULL
condition|)
block|{
name|found_passwd
operator|=
name|spw
operator|->
name|sp_pwdp
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|found_passwd
operator|==
name|NULL
operator|&&
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|username
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|found_passwd
operator|=
name|pw
operator|->
name|pw_passwd
expr_stmt|;
block|}
if|if
condition|(
name|found_passwd
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"E Fatal error, aborting.\n\ error 0 %s: no such user\n"
argument_list|,
name|username
argument_list|)
expr_stmt|;
name|error_exit
argument_list|()
expr_stmt|;
block|}
comment|/* Allow for dain bramaged HPUX passwd aging      *  - Basically, HPUX adds a comma and some data      *    about whether the passwd has expired or not      *    on the end of the passwd field.      *  - This code replaces the ',' with '\0'.      *      * FIXME - our workaround is brain damaged too.  I'm      * guessing that HPUX WANTED other systems to think the      * password was wrong so logins would fail if the      * system didn't handle expired passwds and the passwd      * might be expired.  I think the way to go here      * is with PAM.      */
name|strtok
argument_list|(
name|found_passwd
argument_list|,
literal|","
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|found_passwd
condition|)
block|{
comment|/* user exists and has a password */
if|if
condition|(
name|strcmp
argument_list|(
name|found_passwd
argument_list|,
name|crypt
argument_list|(
name|password
argument_list|,
name|found_passwd
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|host_user
operator|=
name|xstrdup
argument_list|(
name|username
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|host_user
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG_AUTHPRIV
name|syslog
argument_list|(
name|LOG_AUTHPRIV
operator||
name|LOG_NOTICE
argument_list|,
literal|"password mismatch for %s: %s vs. %s"
argument_list|,
name|username
argument_list|,
name|crypt
argument_list|(
name|password
argument_list|,
name|found_passwd
argument_list|)
argument_list|,
name|found_passwd
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
goto|goto
name|handle_return
goto|;
block|}
if|if
condition|(
name|password
operator|&&
operator|*
name|password
condition|)
block|{
comment|/* user exists and has no system password, but we got 	   one as parameter */
name|host_user
operator|=
name|xstrdup
argument_list|(
name|username
argument_list|)
expr_stmt|;
goto|goto
name|handle_return
goto|;
block|}
comment|/* user exists but has no password at all */
name|host_user
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG_AUTHPRIV
name|syslog
argument_list|(
name|LOG_AUTHPRIV
operator||
name|LOG_NOTICE
argument_list|,
literal|"login refused for %s: user has no password"
argument_list|,
name|username
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|handle_return
label|:
if|if
condition|(
name|host_user
condition|)
block|{
comment|/* Set CVS_Username here, in allocated space. 	   It might or might not be the same as host_user. */
name|CVS_Username
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|username
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|CVS_Username
argument_list|,
name|username
argument_list|)
expr_stmt|;
block|}
return|return
name|host_user
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTH_SERVER_SUPPORT */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|AUTH_SERVER_SUPPORT
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_GSSAPI
argument_list|)
end_if

begin_comment
comment|/* Read username and password from client (i.e., stdin).    If correct, then switch to run as that user and send an ACK to the    client via stdout, else send NACK and die. */
end_comment

begin_function
name|void
name|pserver_authenticate_connection
parameter_list|()
block|{
name|char
modifier|*
name|tmp
init|=
name|NULL
decl_stmt|;
name|size_t
name|tmp_allocated
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|AUTH_SERVER_SUPPORT
name|char
modifier|*
name|repository
init|=
name|NULL
decl_stmt|;
name|size_t
name|repository_allocated
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|username
init|=
name|NULL
decl_stmt|;
name|size_t
name|username_allocated
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|password
init|=
name|NULL
decl_stmt|;
name|size_t
name|password_allocated
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|host_user
decl_stmt|;
name|char
modifier|*
name|descrambled_password
decl_stmt|;
endif|#
directive|endif
comment|/* AUTH_SERVER_SUPPORT */
name|int
name|verify_and_exit
init|=
literal|0
decl_stmt|;
comment|/* The Authentication Protocol.  Client sends:      *      *   BEGIN AUTH REQUEST\n      *<REPOSITORY>\n      *<USERNAME>\n      *<PASSWORD>\n      *   END AUTH REQUEST\n      *      * Server uses above information to authenticate, then sends      *      *   I LOVE YOU\n      *      * if it grants access, else      *      *   I HATE YOU\n      *      * if it denies access (and it exits if denying).      *      * When the client is "cvs login", the user does not desire actual      * repository access, but would like to confirm the password with      * the server.  In this case, the start and stop strings are      *      *   BEGIN VERIFICATION REQUEST\n      *      *	    and      *      *   END VERIFICATION REQUEST\n      *      * On a verification request, the server's responses are the same      * (with the obvious semantics), but it exits immediately after      * sending the response in both cases.      *      * Why is the repository sent?  Well, note that the actual      * client/server protocol can't start up until authentication is      * successful.  But in order to perform authentication, the server      * needs to look up the password in the special CVS passwd file,      * before trying /etc/passwd.  So the client transmits the      * repository as part of the "authentication protocol".  The      * repository will be redundantly retransmitted later, but that's no      * big deal.      */
ifdef|#
directive|ifdef
name|SO_KEEPALIVE
comment|/* Set SO_KEEPALIVE on the socket, so that we don't hang forever        if the client dies while we are waiting for input.  */
block|{
name|int
name|on
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|STDIN_FILENO
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_KEEPALIVE
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
name|on
argument_list|)
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SYSLOG_H
name|syslog
argument_list|(
name|LOG_DAEMON
operator||
name|LOG_ERR
argument_list|,
literal|"error setting KEEPALIVE: %m"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
endif|#
directive|endif
comment|/* Make sure the protocol starts off on the right foot... */
if|if
condition|(
name|getline_safe
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|tmp_allocated
argument_list|,
name|stdin
argument_list|,
name|PATH_MAX
argument_list|)
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SYSLOG_H
name|syslog
argument_list|(
name|LOG_DAEMON
operator||
name|LOG_NOTICE
argument_list|,
literal|"bad auth protocol start: EOF"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"bad auth protocol start: EOF"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|tmp
argument_list|,
literal|"BEGIN VERIFICATION REQUEST\n"
argument_list|)
operator|==
literal|0
condition|)
name|verify_and_exit
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|tmp
argument_list|,
literal|"BEGIN AUTH REQUEST\n"
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|tmp
argument_list|,
literal|"BEGIN GSSAPI REQUEST\n"
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_GSSAPI
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|gserver_authenticate_connection
argument_list|()
expr_stmt|;
return|return;
else|#
directive|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"GSSAPI authentication not supported by this server"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"bad auth protocol start: %s"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|AUTH_SERVER_SUPPORT
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Password authentication not supported by this server"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* AUTH_SERVER_SUPPORT */
comment|/* Get the three important pieces of information in order. */
comment|/* See above comment about error handling.  */
name|getline_safe
argument_list|(
operator|&
name|repository
argument_list|,
operator|&
name|repository_allocated
argument_list|,
name|stdin
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
name|getline_safe
argument_list|(
operator|&
name|username
argument_list|,
operator|&
name|username_allocated
argument_list|,
name|stdin
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
name|getline_safe
argument_list|(
operator|&
name|password
argument_list|,
operator|&
name|password_allocated
argument_list|,
name|stdin
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
comment|/* Make them pure.      *      * We check that none of the lines were truncated by getnline in order      * to be sure that we don't accidentally allow a blind DOS attack to      * authenticate, however slim the odds of that might be.      */
if|if
condition|(
operator|!
name|strip_trailing_newlines
argument_list|(
name|repository
argument_list|)
operator|||
operator|!
name|strip_trailing_newlines
argument_list|(
name|username
argument_list|)
operator|||
operator|!
name|strip_trailing_newlines
argument_list|(
name|password
argument_list|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Maximum line length exceeded during authentication."
argument_list|)
expr_stmt|;
comment|/* ... and make sure the protocol ends on the right foot. */
comment|/* See above comment about error handling.  */
name|getline_safe
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|tmp_allocated
argument_list|,
name|stdin
argument_list|,
name|PATH_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|tmp
argument_list|,
name|verify_and_exit
condition|?
literal|"END VERIFICATION REQUEST\n"
else|:
literal|"END AUTH REQUEST\n"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"bad auth protocol end: %s"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|root_allow_ok
argument_list|(
name|repository
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"error 0 %s: no such repository\n"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SYSLOG_H
name|syslog
argument_list|(
name|LOG_DAEMON
operator||
name|LOG_NOTICE
argument_list|,
literal|"login refused for %s"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|i_hate_you
goto|;
block|}
comment|/* OK, now parse the config file, so we can use it to control how        to check passwords.  If there was an error parsing the config        file, parse_config already printed an error.  We keep going.        Why?  Because if we didn't, then there would be no way to check        in a new CVSROOT/config file to fix the broken one!  */
name|parse_config
argument_list|(
name|repository
argument_list|)
expr_stmt|;
comment|/* We need the real cleartext before we hash it. */
name|descrambled_password
operator|=
name|descramble
argument_list|(
name|password
argument_list|)
expr_stmt|;
name|host_user
operator|=
name|check_password
argument_list|(
name|username
argument_list|,
name|descrambled_password
argument_list|,
name|repository
argument_list|)
expr_stmt|;
if|if
condition|(
name|host_user
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SYSLOG_H
name|syslog
argument_list|(
name|LOG_DAEMON
operator||
name|LOG_NOTICE
argument_list|,
literal|"login failure (for %s)"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
name|descrambled_password
argument_list|,
literal|0
argument_list|,
name|strlen
argument_list|(
name|descrambled_password
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|descrambled_password
argument_list|)
expr_stmt|;
name|i_hate_you
label|:
name|printf
argument_list|(
literal|"I HATE YOU\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* Don't worry about server_cleanup, server_active isn't set 	   yet.  */
name|error_exit
argument_list|()
expr_stmt|;
block|}
name|memset
argument_list|(
name|descrambled_password
argument_list|,
literal|0
argument_list|,
name|strlen
argument_list|(
name|descrambled_password
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|descrambled_password
argument_list|)
expr_stmt|;
comment|/* Don't go any farther if we're just responding to "cvs login". */
if|if
condition|(
name|verify_and_exit
condition|)
block|{
name|printf
argument_list|(
literal|"I LOVE YOU\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SYSTEM_CLEANUP
comment|/* Hook for OS-specific behavior, for example socket subsystems on 	   NT and OS2 or dealing with windows and arguments on Mac.  */
name|SYSTEM_CLEANUP
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Set Pserver_Repos so that we can check later that the same        repository is sent in later client/server protocol. */
name|Pserver_Repos
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|repository
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|Pserver_Repos
argument_list|,
name|repository
argument_list|)
expr_stmt|;
comment|/* Switch to run as this user. */
name|switch_to_user
argument_list|(
name|username
argument_list|,
name|host_user
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|host_user
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repository
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|username
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|password
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"I LOVE YOU\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* AUTH_SERVER_SUPPORT */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTH_SERVER_SUPPORT || HAVE_GSSAPI */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_KERBEROS
end_ifdef

begin_function
name|void
name|kserver_authenticate_connection
parameter_list|()
block|{
name|int
name|status
decl_stmt|;
name|char
name|instance
index|[
name|INST_SZ
index|]
decl_stmt|;
name|struct
name|sockaddr_in
name|peer
decl_stmt|;
name|struct
name|sockaddr_in
name|laddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|KTEXT_ST
name|ticket
decl_stmt|;
name|AUTH_DAT
name|auth
decl_stmt|;
name|char
name|version
index|[
name|KRB_SENDAUTH_VLEN
index|]
decl_stmt|;
name|char
name|user
index|[
name|ANAME_SZ
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|instance
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
name|peer
expr_stmt|;
if|if
condition|(
name|getpeername
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|peer
argument_list|,
operator|&
name|len
argument_list|)
operator|<
literal|0
operator|||
name|getsockname
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|laddr
argument_list|,
operator|&
name|len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"E Fatal error, aborting.\n\ error %s getpeername or getsockname failed\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|error_exit
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SO_KEEPALIVE
comment|/* Set SO_KEEPALIVE on the socket, so that we don't hang forever        if the client dies while we are waiting for input.  */
block|{
name|int
name|on
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|STDIN_FILENO
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_KEEPALIVE
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
name|on
argument_list|)
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SYSLOG_H
name|syslog
argument_list|(
name|LOG_DAEMON
operator||
name|LOG_ERR
argument_list|,
literal|"error setting KEEPALIVE: %m"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
endif|#
directive|endif
name|status
operator|=
name|krb_recvauth
argument_list|(
name|KOPT_DO_MUTUAL
argument_list|,
name|STDIN_FILENO
argument_list|,
operator|&
name|ticket
argument_list|,
literal|"rcmd"
argument_list|,
name|instance
argument_list|,
operator|&
name|peer
argument_list|,
operator|&
name|laddr
argument_list|,
operator|&
name|auth
argument_list|,
literal|""
argument_list|,
name|sched
argument_list|,
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|KSUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"E Fatal error, aborting.\n\ error 0 kerberos: %s\n"
argument_list|,
name|krb_get_err_text
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|error_exit
argument_list|()
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|kblock
argument_list|,
name|auth
operator|.
name|session
argument_list|,
sizeof|sizeof
argument_list|(
name|C_Block
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the local name.  */
name|status
operator|=
name|krb_kntoln
argument_list|(
operator|&
name|auth
argument_list|,
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|KSUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"E Fatal error, aborting.\n\ error 0 kerberos: can't get local name: %s\n"
argument_list|,
name|krb_get_err_text
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|error_exit
argument_list|()
expr_stmt|;
block|}
comment|/* Switch to run as this user. */
name|switch_to_user
argument_list|(
literal|"Kerberos 4"
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_KERBEROS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GSSAPI
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|MAXHOSTNAMELEN
end_ifndef

begin_define
define|#
directive|define
name|MAXHOSTNAMELEN
value|(256)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Authenticate a GSSAPI connection.  This is called from    pserver_authenticate_connection, and it handles success and failure    the same way.  */
end_comment

begin_function
specifier|static
name|void
name|gserver_authenticate_connection
parameter_list|()
block|{
name|char
name|hostname
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|gss_buffer_desc
name|tok_in
decl_stmt|,
name|tok_out
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|credbuf
decl_stmt|;
name|size_t
name|credbuflen
decl_stmt|;
name|OM_uint32
name|stat_min
decl_stmt|,
name|ret
decl_stmt|;
name|gss_name_t
name|server_name
decl_stmt|,
name|client_name
decl_stmt|;
name|gss_cred_id_t
name|server_creds
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
name|gss_OID
name|mechid
decl_stmt|;
name|gethostname
argument_list|(
name|hostname
argument_list|,
sizeof|sizeof
name|hostname
argument_list|)
expr_stmt|;
name|hp
operator|=
name|gethostbyname
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"can't get canonical hostname"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"cvs@%s"
argument_list|,
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
name|tok_in
operator|.
name|value
operator|=
name|buf
expr_stmt|;
name|tok_in
operator|.
name|length
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|gss_import_name
argument_list|(
operator|&
name|stat_min
argument_list|,
operator|&
name|tok_in
argument_list|,
name|GSS_C_NT_HOSTBASED_SERVICE
argument_list|,
operator|&
name|server_name
argument_list|)
operator|!=
name|GSS_S_COMPLETE
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"could not import GSSAPI service name %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* Acquire the server credential to verify the client's        authentication.  */
if|if
condition|(
name|gss_acquire_cred
argument_list|(
operator|&
name|stat_min
argument_list|,
name|server_name
argument_list|,
literal|0
argument_list|,
name|GSS_C_NULL_OID_SET
argument_list|,
name|GSS_C_ACCEPT
argument_list|,
operator|&
name|server_creds
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|!=
name|GSS_S_COMPLETE
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"could not acquire GSSAPI server credentials"
argument_list|)
expr_stmt|;
name|gss_release_name
argument_list|(
operator|&
name|stat_min
argument_list|,
operator|&
name|server_name
argument_list|)
expr_stmt|;
comment|/* The client will send us a two byte length followed by that many        bytes.  */
if|if
condition|(
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
name|stdin
argument_list|)
operator|!=
literal|2
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"read of length failed"
argument_list|)
expr_stmt|;
name|nbytes
operator|=
operator|(
operator|(
name|buf
index|[
literal|0
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|buf
index|[
literal|1
index|]
operator|&
literal|0xff
operator|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|<=
sizeof|sizeof
name|buf
condition|)
block|{
name|credbuf
operator|=
name|buf
expr_stmt|;
name|credbuflen
operator|=
sizeof|sizeof
name|buf
expr_stmt|;
block|}
else|else
block|{
name|credbuflen
operator|=
name|nbytes
expr_stmt|;
name|credbuf
operator|=
name|xmalloc
argument_list|(
name|credbuflen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fread
argument_list|(
name|credbuf
argument_list|,
literal|1
argument_list|,
name|nbytes
argument_list|,
name|stdin
argument_list|)
operator|!=
name|nbytes
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"read of data failed"
argument_list|)
expr_stmt|;
name|gcontext
operator|=
name|GSS_C_NO_CONTEXT
expr_stmt|;
name|tok_in
operator|.
name|length
operator|=
name|nbytes
expr_stmt|;
name|tok_in
operator|.
name|value
operator|=
name|credbuf
expr_stmt|;
if|if
condition|(
name|gss_accept_sec_context
argument_list|(
operator|&
name|stat_min
argument_list|,
operator|&
name|gcontext
argument_list|,
comment|/* context_handle */
name|server_creds
argument_list|,
comment|/* verifier_cred_handle */
operator|&
name|tok_in
argument_list|,
comment|/* input_token */
name|NULL
argument_list|,
comment|/* channel bindings */
operator|&
name|client_name
argument_list|,
comment|/* src_name */
operator|&
name|mechid
argument_list|,
comment|/* mech_type */
operator|&
name|tok_out
argument_list|,
comment|/* output_token */
operator|&
name|ret
argument_list|,
name|NULL
argument_list|,
comment|/* ignore time_rec */
name|NULL
argument_list|)
comment|/* ignore del_cred_handle */
operator|!=
name|GSS_S_COMPLETE
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"could not verify credentials"
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME: Use Kerberos v5 specific code to authenticate to a user.        We could instead use an authentication to access mapping.  */
block|{
name|krb5_context
name|kc
decl_stmt|;
name|krb5_principal
name|p
decl_stmt|;
name|gss_buffer_desc
name|desc
decl_stmt|;
name|krb5_init_context
argument_list|(
operator|&
name|kc
argument_list|)
expr_stmt|;
if|if
condition|(
name|gss_display_name
argument_list|(
operator|&
name|stat_min
argument_list|,
name|client_name
argument_list|,
operator|&
name|desc
argument_list|,
operator|&
name|mechid
argument_list|)
operator|!=
name|GSS_S_COMPLETE
operator|||
name|krb5_parse_name
argument_list|(
name|kc
argument_list|,
operator|(
operator|(
name|gss_buffer_t
operator|)
operator|&
name|desc
operator|)
operator|->
name|value
argument_list|,
operator|&
name|p
argument_list|)
operator|!=
literal|0
operator|||
name|krb5_aname_to_localname
argument_list|(
name|kc
argument_list|,
name|p
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|buf
argument_list|)
operator|!=
literal|0
operator|||
name|krb5_kuserok
argument_list|(
name|kc
argument_list|,
name|p
argument_list|,
name|buf
argument_list|)
operator|!=
name|TRUE
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"access denied"
argument_list|)
expr_stmt|;
block|}
name|krb5_free_principal
argument_list|(
name|kc
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|krb5_free_context
argument_list|(
name|kc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tok_out
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
name|char
name|cbuf
index|[
literal|2
index|]
decl_stmt|;
name|cbuf
index|[
literal|0
index|]
operator|=
operator|(
name|tok_out
operator|.
name|length
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|cbuf
index|[
literal|1
index|]
operator|=
name|tok_out
operator|.
name|length
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
name|cbuf
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
name|stdout
argument_list|)
operator|!=
literal|2
operator|||
operator|(
name|fwrite
argument_list|(
name|tok_out
operator|.
name|value
argument_list|,
literal|1
argument_list|,
name|tok_out
operator|.
name|length
argument_list|,
name|stdout
argument_list|)
operator|!=
name|tok_out
operator|.
name|length
operator|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"fwrite failed"
argument_list|)
expr_stmt|;
block|}
name|switch_to_user
argument_list|(
literal|"GSSAPI"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|credbuf
operator|!=
name|buf
condition|)
name|free
argument_list|(
name|credbuf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"I LOVE YOU\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_GSSAPI */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SERVER_SUPPORT */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CLIENT_SUPPORT
argument_list|)
operator|||
name|defined
argument_list|(
name|SERVER_SUPPORT
argument_list|)
end_if

begin_comment
comment|/* This global variable is non-zero if the user requests encryption on    the command line.  */
end_comment

begin_decl_stmt
name|int
name|cvsencrypt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This global variable is non-zero if the users requests stream    authentication on the command line.  */
end_comment

begin_decl_stmt
name|int
name|cvsauthenticate
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GSSAPI
end_ifdef

begin_comment
comment|/* An buffer interface using GSSAPI.  This is built on top of a    packetizing buffer.  */
end_comment

begin_comment
comment|/* This structure is the closure field of the GSSAPI translation    routines.  */
end_comment

begin_struct
struct|struct
name|cvs_gssapi_wrap_data
block|{
comment|/* The GSSAPI context.  */
name|gss_ctx_id_t
name|gcontext
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|cvs_gssapi_wrap_input
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cvs_gssapi_wrap_output
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create a GSSAPI wrapping buffer.  We use a packetizing buffer with    GSSAPI wrapping routines.  */
end_comment

begin_function_decl
name|struct
name|buffer
modifier|*
name|cvs_gssapi_wrap_buffer_initialize
parameter_list|(
name|buf
parameter_list|,
name|input
parameter_list|,
name|gcontext
parameter_list|,
name|memory
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
name|int
name|input
decl_stmt|;
name|gss_ctx_id_t
name|gcontext
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*memory
end_function_decl

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|cvs_gssapi_wrap_data
modifier|*
name|gd
decl_stmt|;
name|gd
operator|=
operator|(
expr|struct
name|cvs_gssapi_wrap_data
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|gd
argument_list|)
expr_stmt|;
name|gd
operator|->
name|gcontext
operator|=
name|gcontext
expr_stmt|;
return|return
operator|(
name|packetizing_buffer_initialize
argument_list|(
name|buf
argument_list|,
name|input
condition|?
name|cvs_gssapi_wrap_input
else|:
name|NULL
argument_list|,
name|input
condition|?
name|NULL
else|:
name|cvs_gssapi_wrap_output
argument_list|,
name|gd
argument_list|,
name|memory
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Unwrap data using GSSAPI.  */
end_comment

begin_function
specifier|static
name|int
name|cvs_gssapi_wrap_input
parameter_list|(
name|fnclosure
parameter_list|,
name|input
parameter_list|,
name|output
parameter_list|,
name|size
parameter_list|)
name|void
modifier|*
name|fnclosure
decl_stmt|;
specifier|const
name|char
modifier|*
name|input
decl_stmt|;
name|char
modifier|*
name|output
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|struct
name|cvs_gssapi_wrap_data
modifier|*
name|gd
init|=
operator|(
expr|struct
name|cvs_gssapi_wrap_data
operator|*
operator|)
name|fnclosure
decl_stmt|;
name|gss_buffer_desc
name|inbuf
decl_stmt|,
name|outbuf
decl_stmt|;
name|OM_uint32
name|stat_min
decl_stmt|;
name|int
name|conf
decl_stmt|;
name|inbuf
operator|.
name|value
operator|=
operator|(
name|void
operator|*
operator|)
name|input
expr_stmt|;
name|inbuf
operator|.
name|length
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|gss_unwrap
argument_list|(
operator|&
name|stat_min
argument_list|,
name|gd
operator|->
name|gcontext
argument_list|,
operator|&
name|inbuf
argument_list|,
operator|&
name|outbuf
argument_list|,
operator|&
name|conf
argument_list|,
name|NULL
argument_list|)
operator|!=
name|GSS_S_COMPLETE
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"gss_unwrap failed"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outbuf
operator|.
name|length
operator|>
name|size
condition|)
name|abort
argument_list|()
expr_stmt|;
name|memcpy
argument_list|(
name|output
argument_list|,
name|outbuf
operator|.
name|value
argument_list|,
name|outbuf
operator|.
name|length
argument_list|)
expr_stmt|;
comment|/* The real packet size is stored in the data, so we don't need to        remember outbuf.length.  */
name|gss_release_buffer
argument_list|(
operator|&
name|stat_min
argument_list|,
operator|&
name|outbuf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Wrap data using GSSAPI.  */
end_comment

begin_function
specifier|static
name|int
name|cvs_gssapi_wrap_output
parameter_list|(
name|fnclosure
parameter_list|,
name|input
parameter_list|,
name|output
parameter_list|,
name|size
parameter_list|,
name|translated
parameter_list|)
name|void
modifier|*
name|fnclosure
decl_stmt|;
specifier|const
name|char
modifier|*
name|input
decl_stmt|;
name|char
modifier|*
name|output
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
modifier|*
name|translated
decl_stmt|;
block|{
name|struct
name|cvs_gssapi_wrap_data
modifier|*
name|gd
init|=
operator|(
expr|struct
name|cvs_gssapi_wrap_data
operator|*
operator|)
name|fnclosure
decl_stmt|;
name|gss_buffer_desc
name|inbuf
decl_stmt|,
name|outbuf
decl_stmt|;
name|OM_uint32
name|stat_min
decl_stmt|;
name|int
name|conf_req
decl_stmt|,
name|conf
decl_stmt|;
name|inbuf
operator|.
name|value
operator|=
operator|(
name|void
operator|*
operator|)
name|input
expr_stmt|;
name|inbuf
operator|.
name|length
operator|=
name|size
expr_stmt|;
ifdef|#
directive|ifdef
name|ENCRYPTION
name|conf_req
operator|=
name|cvs_gssapi_encrypt
expr_stmt|;
else|#
directive|else
name|conf_req
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|gss_wrap
argument_list|(
operator|&
name|stat_min
argument_list|,
name|gd
operator|->
name|gcontext
argument_list|,
name|conf_req
argument_list|,
name|GSS_C_QOP_DEFAULT
argument_list|,
operator|&
name|inbuf
argument_list|,
operator|&
name|conf
argument_list|,
operator|&
name|outbuf
argument_list|)
operator|!=
name|GSS_S_COMPLETE
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"gss_wrap failed"
argument_list|)
expr_stmt|;
comment|/* The packetizing buffer only permits us to add 100 bytes.        FIXME: I don't know what, if anything, is guaranteed by GSSAPI.        This may need to be increased for a different GSSAPI        implementation, or we may need a different algorithm.  */
if|if
condition|(
name|outbuf
operator|.
name|length
operator|>
name|size
operator|+
literal|100
condition|)
name|abort
argument_list|()
expr_stmt|;
name|memcpy
argument_list|(
name|output
argument_list|,
name|outbuf
operator|.
name|value
argument_list|,
name|outbuf
operator|.
name|length
argument_list|)
expr_stmt|;
operator|*
name|translated
operator|=
name|outbuf
operator|.
name|length
expr_stmt|;
name|gss_release_buffer
argument_list|(
operator|&
name|stat_min
argument_list|,
operator|&
name|outbuf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_GSSAPI */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ENCRYPTION
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_KERBEROS
end_ifdef

begin_comment
comment|/* An encryption interface using Kerberos.  This is built on top of a    packetizing buffer.  */
end_comment

begin_comment
comment|/* This structure is the closure field of the Kerberos translation    routines.  */
end_comment

begin_struct
struct|struct
name|krb_encrypt_data
block|{
comment|/* The Kerberos key schedule.  */
name|Key_schedule
name|sched
decl_stmt|;
comment|/* The Kerberos DES block.  */
name|C_Block
name|block
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|krb_encrypt_input
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|krb_encrypt_output
name|PROTO
argument_list|(
operator|(
name|void
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create a Kerberos encryption buffer.  We use a packetizing buffer    with Kerberos encryption translation routines.  */
end_comment

begin_function_decl
name|struct
name|buffer
modifier|*
name|krb_encrypt_buffer_initialize
parameter_list|(
name|buf
parameter_list|,
name|input
parameter_list|,
name|sched
parameter_list|,
name|block
parameter_list|,
name|memory
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
name|int
name|input
decl_stmt|;
name|Key_schedule
name|sched
decl_stmt|;
name|C_Block
name|block
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*memory
end_function_decl

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|krb_encrypt_data
modifier|*
name|kd
decl_stmt|;
name|kd
operator|=
operator|(
expr|struct
name|krb_encrypt_data
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|kd
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|kd
operator|->
name|sched
argument_list|,
name|sched
argument_list|,
sizeof|sizeof
argument_list|(
name|Key_schedule
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|kd
operator|->
name|block
argument_list|,
name|block
argument_list|,
sizeof|sizeof
argument_list|(
name|C_Block
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|packetizing_buffer_initialize
argument_list|(
name|buf
argument_list|,
name|input
condition|?
name|krb_encrypt_input
else|:
name|NULL
argument_list|,
name|input
condition|?
name|NULL
else|:
name|krb_encrypt_output
argument_list|,
name|kd
argument_list|,
name|memory
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Decrypt Kerberos data.  */
end_comment

begin_function
specifier|static
name|int
name|krb_encrypt_input
parameter_list|(
name|fnclosure
parameter_list|,
name|input
parameter_list|,
name|output
parameter_list|,
name|size
parameter_list|)
name|void
modifier|*
name|fnclosure
decl_stmt|;
specifier|const
name|char
modifier|*
name|input
decl_stmt|;
name|char
modifier|*
name|output
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|struct
name|krb_encrypt_data
modifier|*
name|kd
init|=
operator|(
expr|struct
name|krb_encrypt_data
operator|*
operator|)
name|fnclosure
decl_stmt|;
name|int
name|tcount
decl_stmt|;
name|des_cbc_encrypt
argument_list|(
operator|(
name|C_Block
operator|*
operator|)
name|input
argument_list|,
operator|(
name|C_Block
operator|*
operator|)
name|output
argument_list|,
name|size
argument_list|,
name|kd
operator|->
name|sched
argument_list|,
operator|&
name|kd
operator|->
name|block
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* SIZE is the size of the buffer, which is set by the encryption        routine.  The packetizing buffer will arrange for the first two        bytes in the decrypted buffer to be the real (unaligned)        length.  As a safety check, make sure that the length in the        buffer corresponds to SIZE.  Note that the length in the buffer        is just the length of the data.  We must add 2 to account for        the buffer count itself.  */
name|tcount
operator|=
operator|(
operator|(
name|output
index|[
literal|0
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|(
name|output
index|[
literal|1
index|]
operator|&
literal|0xff
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|tcount
operator|+
literal|2
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
operator|)
operator|!=
name|size
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Decryption failure"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Encrypt Kerberos data.  */
end_comment

begin_function
specifier|static
name|int
name|krb_encrypt_output
parameter_list|(
name|fnclosure
parameter_list|,
name|input
parameter_list|,
name|output
parameter_list|,
name|size
parameter_list|,
name|translated
parameter_list|)
name|void
modifier|*
name|fnclosure
decl_stmt|;
specifier|const
name|char
modifier|*
name|input
decl_stmt|;
name|char
modifier|*
name|output
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
modifier|*
name|translated
decl_stmt|;
block|{
name|struct
name|krb_encrypt_data
modifier|*
name|kd
init|=
operator|(
expr|struct
name|krb_encrypt_data
operator|*
operator|)
name|fnclosure
decl_stmt|;
name|int
name|aligned
decl_stmt|;
comment|/* For security against a known plaintext attack, we should        initialize any padding bytes to random values.  Instead, we        just pick up whatever is on the stack, which is at least better        than using zero.  */
comment|/* Align SIZE to an 8 byte boundary.  Note that SIZE includes the        two byte buffer count at the start of INPUT which was added by        the packetizing buffer.  */
name|aligned
operator|=
operator|(
name|size
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
comment|/* We use des_cbc_encrypt rather than krb_mk_priv because the        latter sticks a timestamp in the block, and krb_rd_priv expects        that timestamp to be within five minutes of the current time.        Given the way the CVS server buffers up data, that can easily        fail over a long network connection.  We trust krb_recvauth to        guard against a replay attack.  */
name|des_cbc_encrypt
argument_list|(
operator|(
name|C_Block
operator|*
operator|)
name|input
argument_list|,
operator|(
name|C_Block
operator|*
operator|)
name|output
argument_list|,
name|aligned
argument_list|,
name|kd
operator|->
name|sched
argument_list|,
operator|&
name|kd
operator|->
name|block
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|translated
operator|=
name|aligned
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_KERBEROS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ENCRYPTION */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined (CLIENT_SUPPORT) || defined (SERVER_SUPPORT) */
end_comment

begin_comment
comment|/* Output LEN bytes at STR.  If LEN is zero, then output up to (not including)    the first '\0' byte.  */
end_comment

begin_function
name|void
name|cvs_output
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|error_use_protocol
operator|&&
name|buf_to_net
operator|!=
name|NULL
condition|)
block|{
name|buf_output
argument_list|(
name|saved_output
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf_copy_lines
argument_list|(
name|buf_to_net
argument_list|,
name|saved_output
argument_list|,
literal|'M'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|server_active
operator|&&
name|protocol
operator|!=
name|NULL
condition|)
block|{
name|buf_output
argument_list|(
name|saved_output
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf_copy_lines
argument_list|(
name|protocol
argument_list|,
name|saved_output
argument_list|,
literal|'M'
argument_list|)
expr_stmt|;
name|buf_send_counted
argument_list|(
name|protocol
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|size_t
name|written
decl_stmt|;
name|size_t
name|to_write
init|=
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|str
decl_stmt|;
comment|/* For symmetry with cvs_outerr we would call fflush (stderr) 	   here.  I guess the assumption is that stderr will be 	   unbuffered, so we don't need to.  That sounds like a sound 	   assumption from the manpage I looked at, but if there was 	   something fishy about it, my guess is that calling fflush 	   would not produce a significant performance problem.  */
while|while
condition|(
name|to_write
operator|>
literal|0
condition|)
block|{
name|written
operator|=
name|fwrite
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|to_write
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|written
operator|==
literal|0
condition|)
break|break;
name|p
operator|+=
name|written
expr_stmt|;
name|to_write
operator|-=
name|written
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Output LEN bytes at STR in binary mode.  If LEN is zero, then    output zero bytes.  */
end_comment

begin_function
name|void
name|cvs_output_binary
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|error_use_protocol
operator|||
name|server_active
condition|)
block|{
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
name|char
name|size_text
index|[
literal|40
index|]
decl_stmt|;
if|if
condition|(
name|error_use_protocol
condition|)
name|buf
operator|=
name|buf_to_net
expr_stmt|;
else|else
name|buf
operator|=
name|protocol
expr_stmt|;
if|if
condition|(
operator|!
name|supported_response
argument_list|(
literal|"Mbinary"
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"\ this client does not support writing binary files to stdout"
argument_list|)
expr_stmt|;
return|return;
block|}
name|buf_output0
argument_list|(
name|buf
argument_list|,
literal|"Mbinary\012"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|size_text
argument_list|,
literal|"%lu\012"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|len
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf
argument_list|,
name|size_text
argument_list|)
expr_stmt|;
comment|/* Not sure what would be involved in using buf_append_data here 	   without stepping on the toes of our caller (which is responsible 	   for the memory allocation of STR).  */
name|buf_output
argument_list|(
name|buf
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error_use_protocol
condition|)
name|buf_send_counted
argument_list|(
name|protocol
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|size_t
name|written
decl_stmt|;
name|size_t
name|to_write
init|=
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|str
decl_stmt|;
comment|/* For symmetry with cvs_outerr we would call fflush (stderr) 	   here.  I guess the assumption is that stderr will be 	   unbuffered, so we don't need to.  That sounds like a sound 	   assumption from the manpage I looked at, but if there was 	   something fishy about it, my guess is that calling fflush 	   would not produce a significant performance problem.  */
ifdef|#
directive|ifdef
name|USE_SETMODE_STDOUT
name|int
name|oldmode
decl_stmt|;
comment|/* It is possible that this should be the same ifdef as 	   USE_SETMODE_BINARY but at least for the moment we keep them 	   separate.  Mostly this is just laziness and/or a question 	   of what has been tested where.  Also there might be an 	   issue of setmode vs. _setmode.  */
comment|/* The Windows doc says to call setmode only right after startup. 	   I assume that what they are talking about can also be helped 	   by flushing the stream before changing the mode.  */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|oldmode
operator|=
name|_setmode
argument_list|(
name|_fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|OPEN_BINARY
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldmode
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"failed to setmode on stdout"
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|to_write
operator|>
literal|0
condition|)
block|{
name|written
operator|=
name|fwrite
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|to_write
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|written
operator|==
literal|0
condition|)
break|break;
name|p
operator|+=
name|written
expr_stmt|;
name|to_write
operator|-=
name|written
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USE_SETMODE_STDOUT
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|_setmode
argument_list|(
name|_fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|oldmode
argument_list|)
operator|!=
name|OPEN_BINARY
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"failed to setmode on stdout"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Like CVS_OUTPUT but output is for stderr not stdout.  */
end_comment

begin_function
name|void
name|cvs_outerr
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|error_use_protocol
condition|)
block|{
name|buf_output
argument_list|(
name|saved_outerr
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf_copy_lines
argument_list|(
name|buf_to_net
argument_list|,
name|saved_outerr
argument_list|,
literal|'E'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|server_active
condition|)
block|{
name|buf_output
argument_list|(
name|saved_outerr
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf_copy_lines
argument_list|(
name|protocol
argument_list|,
name|saved_outerr
argument_list|,
literal|'E'
argument_list|)
expr_stmt|;
name|buf_send_counted
argument_list|(
name|protocol
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|size_t
name|written
decl_stmt|;
name|size_t
name|to_write
init|=
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|str
decl_stmt|;
comment|/* Make sure that output appears in order if stdout and stderr 	   point to the same place.  For the server case this is taken 	   care of by the fact that saved_outerr always holds less 	   than a line.  */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
while|while
condition|(
name|to_write
operator|>
literal|0
condition|)
block|{
name|written
operator|=
name|fwrite
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|to_write
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|written
operator|==
literal|0
condition|)
break|break;
name|p
operator|+=
name|written
expr_stmt|;
name|to_write
operator|-=
name|written
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Flush stderr.  stderr is normally flushed automatically, of course,    but this function is used to flush information from the server back    to the client.  */
end_comment

begin_function
name|void
name|cvs_flusherr
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|error_use_protocol
condition|)
block|{
comment|/* skip the actual stderr flush in this case since the parent process 	 * on the server should only be writing to stdout anyhow 	 */
comment|/* Flush what we can to the network, but don't block.  */
name|buf_flush
argument_list|(
name|buf_to_net
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|server_active
condition|)
block|{
comment|/* make sure stderr is flushed before we send the flush count on the 	 * protocol pipe 	 */
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
comment|/* Send a special count to tell the parent to flush.  */
name|buf_send_special_count
argument_list|(
name|protocol
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make it possible for the user to see what has been written to    stdout (it is up to the implementation to decide exactly how far it    should go to ensure this).  */
end_comment

begin_function
name|void
name|cvs_flushout
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|error_use_protocol
condition|)
block|{
comment|/* Flush what we can to the network, but don't block.  */
name|buf_flush
argument_list|(
name|buf_to_net
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|server_active
condition|)
block|{
comment|/* Just do nothing.  This is because the code which 	   cvs_flushout replaces, setting stdout to line buffering in 	   main.c, didn't get called in the server child process.  But 	   in the future it is quite plausible that we'll want to make 	   this case work analogously to cvs_flusherr.  	   FIXME - DRP - I tried to implement this and triggered the following 	   error: "Protocol error: uncounted data discarded".  I don't need 	   this feature right now, so I'm not going to bother with it yet. 	 */
name|buf_send_special_count
argument_list|(
name|protocol
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output TEXT, tagging it according to TAG.  There are lots more    details about what TAG means in cvsclient.texi but for the simple    case (e.g. non-client/server), TAG is just "newline" to output a    newline (in which case TEXT must be NULL), and any other tag to    output normal text.     Note that there is no way to output either \0 or \n as part of TEXT.  */
end_comment

begin_function
name|void
name|cvs_output_tagged
parameter_list|(
name|tag
parameter_list|,
name|text
parameter_list|)
specifier|const
name|char
modifier|*
name|tag
decl_stmt|;
specifier|const
name|char
modifier|*
name|text
decl_stmt|;
block|{
if|if
condition|(
name|text
operator|!=
name|NULL
operator|&&
name|strchr
argument_list|(
name|text
argument_list|,
literal|'\n'
argument_list|)
operator|!=
name|NULL
condition|)
comment|/* Uh oh.  The protocol has no way to cope with this.  For now 	   we dump core, although that really isn't such a nice 	   response given that this probably can be caused by newlines 	   in filenames and other causes other than bugs in CVS.  Note 	   that we don't want to turn this into "MT newline" because 	   this case is a newline within a tagged item, not a newline 	   as extraneous sugar for the user.  */
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Start and end tags don't take any text, per cvsclient.texi.  */
if|if
condition|(
name|tag
index|[
literal|0
index|]
operator|==
literal|'+'
operator|||
name|tag
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|assert
argument_list|(
name|text
operator|==
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
operator|&&
name|supported_response
argument_list|(
literal|"MT"
argument_list|)
condition|)
block|{
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|error_use_protocol
condition|)
name|buf
operator|=
name|buf_to_net
expr_stmt|;
else|else
name|buf
operator|=
name|protocol
expr_stmt|;
name|buf_output0
argument_list|(
name|buf
argument_list|,
literal|"MT "
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|text
operator|!=
name|NULL
condition|)
block|{
name|buf_output
argument_list|(
name|buf
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
name|buf
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
name|buf_output
argument_list|(
name|buf
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error_use_protocol
condition|)
name|buf_send_counted
argument_list|(
name|protocol
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|tag
argument_list|,
literal|"newline"
argument_list|)
operator|==
literal|0
condition|)
name|cvs_output
argument_list|(
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|text
operator|!=
name|NULL
condition|)
name|cvs_output
argument_list|(
name|text
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

