begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"watch.h"
end_include

begin_include
include|#
directive|include
file|"edit.h"
end_include

begin_include
include|#
directive|include
file|"fileattr.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
end_ifdef

begin_comment
comment|/* for select */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_BSDTYPES_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/bsdtypes.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_if
if|#
directive|if
name|HAVE_SYS_SELECT_H
end_if

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_FCNTL_H
end_if

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_NONBLOCK
end_ifndef

begin_define
define|#
directive|define
name|O_NONBLOCK
value|O_NDELAY
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|AUTH_SERVER_SUPPORT
end_ifdef

begin_comment
comment|/* For initgroups().  */
end_comment

begin_if
if|#
directive|if
name|HAVE_INITGROUPS
end_if

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_INITGROUPS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTH_SERVER_SUPPORT */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Functions which the server calls.  */
end_comment

begin_decl_stmt
name|int
name|add
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|admin
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|checkout
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|commit
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|diff
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|history
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|import
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cvslog
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|patch
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|release
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cvsremove
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rtag
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|status
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tag
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|update
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  * This is where we stash stuff we are going to use.  Format string  * which expects a single directory within it, starting with a slash.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|server_temp_dir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we should keep the temp directory around after we exit.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dont_delete_temp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|no_mem_error
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NO_MEM_ERROR
value|(&no_mem_error)
end_define

begin_decl_stmt
specifier|static
name|void
name|server_write_entries
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Read a line from the stream "instream" without command line editing.  *  * Action is compatible with "readline", e.g. space for the result is  * malloc'd and should be freed by the caller.  *  * A NULL return means end of file.  A return of NO_MEM_ERROR means  * that we are out of memory.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|read_line
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|read_line
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|int
name|input_index
init|=
literal|0
decl_stmt|;
name|int
name|result_size
init|=
literal|80
decl_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|result_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
return|return
name|NO_MEM_ERROR
return|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|fgetc
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
break|break;
name|result
index|[
name|input_index
operator|++
index|]
operator|=
name|c
expr_stmt|;
while|while
condition|(
name|input_index
operator|>=
name|result_size
condition|)
block|{
name|result_size
operator|*=
literal|2
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|result
argument_list|,
name|result_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
return|return
name|NO_MEM_ERROR
return|;
block|}
block|}
name|result
index|[
name|input_index
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Make directory DIR, including all intermediate directories if necessary.  * Returns 0 for success or errno code.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mkdir_p
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|mkdir_p
parameter_list|(
name|dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
init|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|retval
decl_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
comment|/*      * Skip over leading slash if present.  We won't bother to try to      * make '/'.      */
name|p
operator|=
name|dir
operator|+
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
operator|*
name|p
operator|!=
literal|'/'
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
block|{
name|strncpy
argument_list|(
name|q
argument_list|,
name|dir
argument_list|,
name|p
operator|-
name|dir
argument_list|)
expr_stmt|;
name|q
index|[
name|p
operator|-
name|dir
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|CVS_MKDIR
argument_list|(
name|q
argument_list|,
literal|0777
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EEXIST
operator|&&
operator|(
name|errno
operator|!=
name|EACCES
operator|||
operator|!
name|isdir
argument_list|(
name|q
argument_list|)
operator|)
condition|)
block|{
name|retval
operator|=
name|errno
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
operator|++
name|p
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|CVS_MKDIR
argument_list|(
name|dir
argument_list|,
literal|0777
argument_list|)
operator|<
literal|0
condition|)
name|retval
operator|=
name|errno
expr_stmt|;
else|else
name|retval
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|done
label|:
name|free
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Print the error response for error code STATUS.  The caller is  * reponsible for making sure we get back to the command loop without  * any further output occuring.  */
end_comment

begin_function
specifier|static
name|void
name|print_error
parameter_list|(
name|status
parameter_list|)
name|int
name|status
decl_stmt|;
block|{
name|char
modifier|*
name|msg
decl_stmt|;
name|printf
argument_list|(
literal|"error  "
argument_list|)
expr_stmt|;
name|msg
operator|=
name|strerror
argument_list|(
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|pending_error
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Malloc'd text for pending error.  Each line must start with "E ".  The  * last line should not end with a newline.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pending_error_text
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If an error is pending, print it and return 1.  If not, return 0.  */
end_comment

begin_function
specifier|static
name|int
name|print_pending_error
parameter_list|()
block|{
if|if
condition|(
name|pending_error_text
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|pending_error_text
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_error
condition|)
name|print_error
argument_list|(
name|pending_error
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"error  \n"
argument_list|)
expr_stmt|;
name|pending_error
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|pending_error_text
argument_list|)
expr_stmt|;
name|pending_error_text
operator|=
name|NULL
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|pending_error
condition|)
block|{
name|print_error
argument_list|(
name|pending_error
argument_list|)
expr_stmt|;
name|pending_error
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Is an error pending?  */
end_comment

begin_define
define|#
directive|define
name|error_pending
parameter_list|()
value|(pending_error || pending_error_text)
end_define

begin_escape
end_escape

begin_function
name|int
name|supported_response
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|response
modifier|*
name|rs
decl_stmt|;
for|for
control|(
name|rs
operator|=
name|responses
init|;
name|rs
operator|->
name|name
operator|!=
name|NULL
condition|;
operator|++
name|rs
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|rs
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|rs
operator|->
name|status
operator|==
name|rs_supported
return|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"internal error: testing support for unknown response?"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_valid_responses
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|arg
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|struct
name|response
modifier|*
name|rs
decl_stmt|;
do|do
block|{
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|rs
operator|=
name|responses
init|;
name|rs
operator|->
name|name
operator|!=
name|NULL
condition|;
operator|++
name|rs
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|rs
operator|->
name|name
argument_list|,
name|p
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|rs
operator|->
name|name
operator|==
name|NULL
condition|)
comment|/* 	     * It is a response we have never heard of (and thus never 	     * will want to use).  So don't worry about it. 	     */
empty_stmt|;
else|else
name|rs
operator|->
name|status
operator|=
name|rs_supported
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
do|while
condition|(
name|q
operator|!=
name|NULL
condition|)
do|;
for|for
control|(
name|rs
operator|=
name|responses
init|;
name|rs
operator|->
name|name
operator|!=
name|NULL
condition|;
operator|++
name|rs
control|)
block|{
if|if
condition|(
name|rs
operator|->
name|status
operator|==
name|rs_essential
condition|)
block|{
name|printf
argument_list|(
literal|"E response `%s' not supported by client\nerror  \n"
argument_list|,
name|rs
operator|->
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rs
operator|->
name|status
operator|==
name|rs_optional
condition|)
name|rs
operator|->
name|status
operator|=
name|rs_not_supported
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|use_dir_and_repos
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_root
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|char
modifier|*
name|env
decl_stmt|;
specifier|extern
name|char
modifier|*
name|CVSroot
decl_stmt|;
name|char
name|path
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|int
name|save_errno
decl_stmt|;
if|if
condition|(
name|error_pending
argument_list|()
condition|)
return|return;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|path
argument_list|,
literal|"%s/%s"
argument_list|,
name|arg
argument_list|,
name|CVSROOTADM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isaccessible
argument_list|(
name|path
argument_list|,
name|R_OK
operator||
name|X_OK
argument_list|)
condition|)
block|{
name|save_errno
operator|=
name|errno
expr_stmt|;
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_error_text
operator|!=
name|NULL
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E Cannot access %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|save_errno
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|path
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|path
argument_list|,
name|CVSROOTADM_HISTORY
argument_list|)
expr_stmt|;
if|if
condition|(
name|isfile
argument_list|(
name|path
argument_list|)
operator|&&
operator|!
name|isaccessible
argument_list|(
name|path
argument_list|,
name|R_OK
operator||
name|W_OK
argument_list|)
condition|)
block|{
name|save_errno
operator|=
name|errno
expr_stmt|;
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_error_text
operator|!=
name|NULL
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E \ Sorry, you don't have read/write access to the history file %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|save_errno
expr_stmt|;
block|}
name|CVSroot
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVSroot
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|CVSroot
argument_list|,
name|arg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PUTENV
name|env
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|CVSROOT_ENV
argument_list|)
operator|+
name|strlen
argument_list|(
name|CVSroot
argument_list|)
operator|+
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|env
argument_list|,
literal|"%s=%s"
argument_list|,
name|CVSROOT_ENV
argument_list|,
name|arg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
comment|/* do not free env, as putenv has control of it */
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Add as many directories to the temp directory as the client tells us it  * will use "..", so we never try to access something outside the temp  * directory via "..".  */
end_comment

begin_function
specifier|static
name|void
name|serve_max_dotdot
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|int
name|lim
init|=
name|atoi
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|lim
operator|<
literal|0
condition|)
return|return;
name|p
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|server_temp_dir
argument_list|)
operator|+
literal|2
operator|*
name|lim
operator|+
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|p
argument_list|,
name|server_temp_dir
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lim
condition|;
operator|++
name|i
control|)
name|strcat
argument_list|(
name|p
argument_list|,
literal|"/d"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|server_temp_dir
argument_list|)
expr_stmt|;
name|server_temp_dir
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dir_name
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|dirswitch
parameter_list|(
name|dir
parameter_list|,
name|repos
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|repos
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|server_write_entries
argument_list|()
expr_stmt|;
if|if
condition|(
name|error_pending
argument_list|()
condition|)
return|return;
if|if
condition|(
name|dir_name
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|dir_name
argument_list|)
expr_stmt|;
name|dir_name
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|server_temp_dir
argument_list|)
operator|+
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
literal|40
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir_name
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|dir_name
argument_list|,
name|server_temp_dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dir_name
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dir_name
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|status
operator|=
name|mkdir_p
argument_list|(
name|dir_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
operator|&&
name|status
operator|!=
name|EEXIST
condition|)
block|{
name|pending_error
operator|=
name|status
expr_stmt|;
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|dir_name
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot mkdir %s"
argument_list|,
name|dir_name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|chdir
argument_list|(
name|dir_name
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|dir_name
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot change to %s"
argument_list|,
name|dir_name
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * This is pretty much like calling Create_Admin, but Create_Admin doesn't      * report errors in the right way for us.      */
if|if
condition|(
name|CVS_MKDIR
argument_list|(
name|CVSADM
argument_list|,
literal|0777
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EEXIST
condition|)
comment|/* Don't create the files again.  */
return|return;
name|pending_error
operator|=
name|errno
expr_stmt|;
return|return;
block|}
name|f
operator|=
name|fopen
argument_list|(
name|CVSADM_REP
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s\n"
argument_list|,
name|repos
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
return|return;
block|}
name|f
operator|=
name|fopen
argument_list|(
name|CVSADM_ENT
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|CVSADM_ENT
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot open %s"
argument_list|,
name|CVSADM_ENT
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|CVSADM_ENT
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot close %s"
argument_list|,
name|CVSADM_ENT
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|serve_repository
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|dirswitch
argument_list|(
name|arg
operator|+
literal|1
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_directory
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|char
modifier|*
name|repos
decl_stmt|;
name|use_dir_and_repos
operator|=
literal|1
expr_stmt|;
name|repos
operator|=
name|read_line
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|repos
operator|==
name|NULL
condition|)
block|{
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_error_text
condition|)
block|{
if|if
condition|(
name|feof
argument_list|(
name|stdin
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E end of file reading mode for %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E error reading mode for %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|errno
expr_stmt|;
block|}
block|}
else|else
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|repos
operator|==
name|NO_MEM_ERROR
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
block|}
else|else
block|{
name|dirswitch
argument_list|(
name|arg
argument_list|,
name|repos
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repos
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|serve_static_directory
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|CVSADM_ENTSTAT
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|CVSADM_ENTSTAT
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot open %s"
argument_list|,
name|CVSADM_ENTSTAT
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|CVSADM_ENTSTAT
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot close %s"
argument_list|,
name|CVSADM_ENTSTAT
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|serve_sticky
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|CVSADM_TAG
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|CVSADM_TAG
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot open %s"
argument_list|,
name|CVSADM_TAG
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s\n"
argument_list|,
name|arg
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|CVSADM_TAG
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot write to %s"
argument_list|,
name|CVSADM_TAG
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|CVSADM_TAG
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot close %s"
argument_list|,
name|CVSADM_TAG
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Read SIZE bytes from stdin, write them to FILE.  *  * Currently this isn't really used for receiving parts of a file --  * the file is still sent over in one chunk.  But if/when we get  * spiffy in-process gzip support working, perhaps the compressed  * pieces could be sent over as they're ready, if the network is fast  * enough.  Or something.  */
end_comment

begin_function
specifier|static
name|void
name|receive_partial_file
parameter_list|(
name|size
parameter_list|,
name|file
parameter_list|)
name|int
name|size
decl_stmt|;
name|int
name|file
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|16
operator|*
literal|1024
index|]
decl_stmt|,
modifier|*
name|bufp
decl_stmt|;
name|int
name|toread
decl_stmt|,
name|nread
decl_stmt|,
name|nwrote
decl_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|toread
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|toread
operator|>
name|size
condition|)
name|toread
operator|=
name|size
expr_stmt|;
name|nread
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|toread
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|feof
argument_list|(
name|stdin
argument_list|)
condition|)
block|{
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|80
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_error_text
condition|)
block|{
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E premature end of file from client"
argument_list|)
expr_stmt|;
name|pending_error
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ferror
argument_list|(
name|stdin
argument_list|)
condition|)
block|{
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|40
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_error_text
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E error reading from client"
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|errno
expr_stmt|;
block|}
else|else
block|{
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|40
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_error_text
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E short read from client"
argument_list|)
expr_stmt|;
name|pending_error
operator|=
literal|0
expr_stmt|;
block|}
return|return;
block|}
name|size
operator|-=
name|nread
expr_stmt|;
name|bufp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|nread
condition|)
block|{
name|nwrote
operator|=
name|write
argument_list|(
name|file
argument_list|,
name|bufp
argument_list|,
name|nread
argument_list|)
expr_stmt|;
if|if
condition|(
name|nwrote
operator|<
literal|0
condition|)
block|{
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|40
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_error_text
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E unable to write"
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|errno
expr_stmt|;
return|return;
block|}
name|nread
operator|-=
name|nwrote
expr_stmt|;
name|bufp
operator|+=
name|nwrote
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Receive SIZE bytes, write to filename FILE.  */
end_comment

begin_function
specifier|static
name|void
name|receive_file
parameter_list|(
name|size
parameter_list|,
name|file
parameter_list|,
name|gzipped
parameter_list|)
name|int
name|size
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|gzipped
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|arg
init|=
name|file
decl_stmt|;
name|pid_t
name|gzip_pid
init|=
literal|0
decl_stmt|;
name|int
name|gzip_status
decl_stmt|;
comment|/* Write the file.  */
name|fd
operator|=
name|open
argument_list|(
name|arg
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|40
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_error_text
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot open %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|errno
expr_stmt|;
return|return;
block|}
comment|/*      * FIXME: This doesn't do anything reasonable with gunzip's stderr, which      * means that if gunzip writes to stderr, it will cause all manner of      * protocol violations.      */
if|if
condition|(
name|gzipped
condition|)
name|fd
operator|=
name|filter_through_gunzip
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
operator|&
name|gzip_pid
argument_list|)
expr_stmt|;
name|receive_partial_file
argument_list|(
name|size
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_error_text
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|realloc
argument_list|(
name|pending_error_text
argument_list|,
name|strlen
argument_list|(
name|pending_error_text
argument_list|)
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|30
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|pending_error_text
operator|=
name|p
expr_stmt|;
name|sprintf
argument_list|(
name|p
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|,
literal|", file %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
comment|/* else original string is supposed to be unchanged */
block|}
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|error_pending
argument_list|()
condition|)
block|{
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|40
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_error_text
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot close %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|gzip_pid
condition|)
name|waitpid
argument_list|(
name|gzip_pid
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|gzip_pid
condition|)
block|{
if|if
condition|(
name|waitpid
argument_list|(
name|gzip_pid
argument_list|,
operator|&
name|gzip_status
argument_list|,
literal|0
argument_list|)
operator|!=
name|gzip_pid
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"waiting for gunzip process %ld"
argument_list|,
operator|(
name|long
operator|)
name|gzip_pid
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|gzip_status
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"gunzip exited %d"
argument_list|,
name|gzip_status
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|serve_modified
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|int
name|size
decl_stmt|;
name|char
modifier|*
name|size_text
decl_stmt|;
name|char
modifier|*
name|mode_text
decl_stmt|;
name|int
name|gzipped
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|error_pending
argument_list|()
condition|)
return|return;
name|mode_text
operator|=
name|read_line
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode_text
operator|==
name|NULL
condition|)
block|{
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_error_text
condition|)
block|{
if|if
condition|(
name|feof
argument_list|(
name|stdin
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E end of file reading mode for %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E error reading mode for %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|errno
expr_stmt|;
block|}
block|}
else|else
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|mode_text
operator|==
name|NO_MEM_ERROR
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
name|size_text
operator|=
name|read_line
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|size_text
operator|==
name|NULL
condition|)
block|{
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_error_text
condition|)
block|{
if|if
condition|(
name|feof
argument_list|(
name|stdin
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E end of file reading size for %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E error reading size for %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|errno
expr_stmt|;
block|}
block|}
else|else
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|size_text
operator|==
name|NO_MEM_ERROR
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|size_text
index|[
literal|0
index|]
operator|==
literal|'z'
condition|)
block|{
name|gzipped
operator|=
literal|1
expr_stmt|;
name|size
operator|=
name|atoi
argument_list|(
name|size_text
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|size
operator|=
name|atoi
argument_list|(
name|size_text
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|size_text
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>=
literal|0
condition|)
block|{
name|receive_file
argument_list|(
name|size
argument_list|,
name|arg
argument_list|,
name|gzipped
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_pending
argument_list|()
condition|)
return|return;
block|}
block|{
name|int
name|status
init|=
name|change_mode
argument_list|(
name|arg
argument_list|,
name|mode_text
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|mode_text
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|40
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_error_text
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot change mode for %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|status
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SERVER_SUPPORT */
end_comment

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SERVER_SUPPORT
argument_list|)
operator|||
name|defined
argument_list|(
name|CLIENT_SUPPORT
argument_list|)
end_if

begin_decl_stmt
name|int
name|use_unchanged
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
end_ifdef

begin_function
specifier|static
name|void
name|serve_enable_unchanged
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|use_unchanged
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_lost
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|use_unchanged
condition|)
block|{
comment|/* A missing file already indicates it is nonexistent.  */
return|return;
block|}
else|else
block|{
name|struct
name|utimbuf
name|ut
decl_stmt|;
name|int
name|fd
init|=
name|open
argument_list|(
name|arg
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0666
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
operator|||
name|close
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot open %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Set the times to the beginning of the epoch to tell time_stamp() 	 * that the file was lost. 	 */
name|ut
operator|.
name|actime
operator|=
literal|0
expr_stmt|;
name|ut
operator|.
name|modtime
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|utime
argument_list|(
name|arg
argument_list|,
operator|&
name|ut
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot utime %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_struct
struct|struct
name|an_entry
block|{
name|struct
name|an_entry
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|entry
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|an_entry
modifier|*
name|entries
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_unchanged
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|error_pending
argument_list|()
condition|)
return|return;
if|if
condition|(
operator|!
name|use_unchanged
condition|)
block|{
comment|/* A missing file already indicates it is unchanged.  */
return|return;
block|}
else|else
block|{
name|struct
name|an_entry
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|timefield
decl_stmt|;
comment|/* Rewrite entries file to have `=' in timestamp field.  */
for|for
control|(
name|p
operator|=
name|entries
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|name
operator|=
name|p
operator|->
name|entry
operator|+
literal|1
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
operator|&&
name|strlen
argument_list|(
name|arg
argument_list|)
operator|==
name|cp
operator|-
name|name
operator|&&
name|strncmp
argument_list|(
name|arg
argument_list|,
name|name
argument_list|,
name|cp
operator|-
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|timefield
operator|=
name|strchr
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|'/'
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|timefield
operator|!=
literal|'='
condition|)
block|{
name|cp
operator|=
name|timefield
operator|+
name|strlen
argument_list|(
name|timefield
argument_list|)
expr_stmt|;
name|cp
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|cp
operator|>
name|timefield
condition|)
block|{
operator|*
name|cp
operator|=
name|cp
index|[
operator|-
literal|1
index|]
expr_stmt|;
operator|--
name|cp
expr_stmt|;
block|}
operator|*
name|timefield
operator|=
literal|'='
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|serve_entry
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|an_entry
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|error_pending
argument_list|()
condition|)
return|return;
name|p
operator|=
operator|(
expr|struct
name|an_entry
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|an_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
comment|/* Leave space for serve_unchanged to write '=' if it wants.  */
name|cp
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|cp
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|entries
expr_stmt|;
name|p
operator|->
name|entry
operator|=
name|cp
expr_stmt|;
name|entries
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|server_write_entries
parameter_list|()
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|struct
name|an_entry
modifier|*
name|p
decl_stmt|;
name|struct
name|an_entry
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|entries
operator|==
name|NULL
condition|)
return|return;
name|f
operator|=
name|NULL
expr_stmt|;
comment|/* Note that we free all the entries regardless of errors.  */
if|if
condition|(
operator|!
name|error_pending
argument_list|()
condition|)
block|{
name|f
operator|=
name|fopen
argument_list|(
name|CVSADM_ENT
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|CVSADM_ENT
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot open %s"
argument_list|,
name|CVSADM_ENT
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|p
operator|=
name|entries
init|;
name|p
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|error_pending
argument_list|()
condition|)
block|{
if|if
condition|(
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s\n"
argument_list|,
name|p
operator|->
name|entry
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|CVSADM_ENT
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot write to %s"
argument_list|,
name|CVSADM_ENT
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|p
operator|->
name|entry
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
name|entries
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|NULL
operator|&&
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
operator|&&
operator|!
name|error_pending
argument_list|()
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|CVSADM_ENT
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot close %s"
argument_list|,
name|CVSADM_ENT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|notify_note
block|{
comment|/* Directory in which this notification happens.  malloc'd*/
name|char
modifier|*
name|dir
decl_stmt|;
comment|/* malloc'd.  */
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* The following three all in one malloc'd block, pointed to by TYPE.        Each '\0' terminated.  */
comment|/* "E" or "U".  */
name|char
modifier|*
name|type
decl_stmt|;
comment|/* time+host+dir */
name|char
modifier|*
name|val
decl_stmt|;
name|char
modifier|*
name|watches
decl_stmt|;
name|struct
name|notify_note
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|notify_note
modifier|*
name|notify_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used while building list, to point to the last node that already exists.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|notify_note
modifier|*
name|last_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|serve_notify
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_notify
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|notify_note
modifier|*
name|new
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
if|if
condition|(
name|error_pending
argument_list|()
condition|)
return|return;
name|new
operator|=
operator|(
expr|struct
name|notify_note
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|notify_note
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dir_name
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
name|new
operator|->
name|dir
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|dir_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|->
name|dir
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|new
operator|->
name|dir
argument_list|,
name|dir_name
argument_list|)
expr_stmt|;
name|new
operator|->
name|filename
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|->
name|filename
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|new
operator|->
name|filename
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|data
operator|=
name|read_line
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_error_text
condition|)
block|{
if|if
condition|(
name|feof
argument_list|(
name|stdin
argument_list|)
condition|)
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E end of file reading mode for %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E error reading mode for %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|pending_error
operator|=
name|errno
expr_stmt|;
block|}
block|}
else|else
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|data
operator|==
name|NO_MEM_ERROR
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|new
operator|->
name|type
operator|=
name|data
expr_stmt|;
if|if
condition|(
name|data
index|[
literal|1
index|]
operator|!=
literal|'\t'
condition|)
goto|goto
name|error
goto|;
name|data
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|=
name|data
operator|+
literal|2
expr_stmt|;
name|new
operator|->
name|val
operator|=
name|cp
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
operator|*
name|cp
operator|++
operator|=
literal|'+'
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
operator|*
name|cp
operator|++
operator|=
literal|'+'
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|new
operator|->
name|watches
operator|=
name|cp
expr_stmt|;
comment|/* If there is another tab, ignore everything after it, 	   for future expansion.  */
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
name|new
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|last_node
operator|==
name|NULL
condition|)
block|{
name|notify_list
operator|=
name|new
expr_stmt|;
block|}
else|else
name|last_node
operator|->
name|next
operator|=
name|new
expr_stmt|;
name|last_node
operator|=
name|new
expr_stmt|;
block|}
return|return;
name|error
label|:
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|40
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_error_text
condition|)
name|strcpy
argument_list|(
name|pending_error_text
argument_list|,
literal|"E Protocol error; misformed Notify request"
argument_list|)
expr_stmt|;
name|pending_error
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Process all the Notify requests that we have stored up.  Returns 0    if successful, if not prints error message (via error()) and    returns negative value.  */
end_comment

begin_function
specifier|static
name|int
name|server_notify
parameter_list|()
block|{
name|struct
name|notify_note
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|repos
decl_stmt|;
name|List
modifier|*
name|list
decl_stmt|;
name|Node
modifier|*
name|node
decl_stmt|;
name|int
name|status
decl_stmt|;
while|while
condition|(
name|notify_list
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|chdir
argument_list|(
name|notify_list
operator|->
name|dir
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot change to %s"
argument_list|,
name|notify_list
operator|->
name|dir
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|repos
operator|=
name|Name_Repository
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Now writelock.  */
name|list
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|node
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|node
operator|->
name|type
operator|=
name|LOCK
expr_stmt|;
name|node
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|repos
argument_list|)
expr_stmt|;
name|status
operator|=
name|addnode
argument_list|(
name|list
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|status
operator|==
literal|0
argument_list|)
expr_stmt|;
name|Writer_Lock
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|fileattr_startdir
argument_list|(
name|repos
argument_list|)
expr_stmt|;
name|notify_do
argument_list|(
operator|*
name|notify_list
operator|->
name|type
argument_list|,
name|notify_list
operator|->
name|filename
argument_list|,
name|getcaller
argument_list|()
argument_list|,
name|notify_list
operator|->
name|val
argument_list|,
name|notify_list
operator|->
name|watches
argument_list|,
name|repos
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Notified "
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_dir_and_repos
condition|)
block|{
name|char
modifier|*
name|dir
init|=
name|notify_list
operator|->
name|dir
operator|+
name|strlen
argument_list|(
name|server_temp_dir
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|fputs
argument_list|(
literal|"."
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
name|dir
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"/\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
name|repos
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"/"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|notify_list
operator|->
name|filename
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|p
operator|=
name|notify_list
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|notify_list
operator|->
name|filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|notify_list
operator|->
name|dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|notify_list
operator|->
name|type
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|notify_list
argument_list|)
expr_stmt|;
name|notify_list
operator|=
name|p
expr_stmt|;
name|fileattr_write
argument_list|()
expr_stmt|;
name|fileattr_free
argument_list|()
expr_stmt|;
comment|/* Remove the writelock.  */
name|Lock_Cleanup
argument_list|()
expr_stmt|;
name|dellist
argument_list|(
operator|&
name|list
argument_list|)
expr_stmt|;
block|}
comment|/* do_cvs_command writes to stdout via write(), not stdio, so better        flush out the buffer.  */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|argument_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|argument_vector
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|argument_vector_size
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_argument
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|error_pending
argument_list|()
condition|)
return|return;
if|if
condition|(
name|argument_vector_size
operator|<=
name|argument_count
condition|)
block|{
name|argument_vector_size
operator|*=
literal|2
expr_stmt|;
name|argument_vector
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argument_vector
argument_list|,
name|argument_vector_size
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|argument_vector
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
block|}
name|p
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|p
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|argument_vector
index|[
name|argument_count
operator|++
index|]
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_argumentx
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|error_pending
argument_list|()
condition|)
return|return;
name|p
operator|=
name|argument_vector
index|[
name|argument_count
operator|-
literal|1
index|]
expr_stmt|;
name|p
operator|=
name|realloc
argument_list|(
name|p
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
name|strcat
argument_list|(
name|p
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|p
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|argument_vector
index|[
name|argument_count
operator|-
literal|1
index|]
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_global_option
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|||
name|arg
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
name|arg
index|[
literal|2
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|error_return
label|:
name|pending_error_text
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|80
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E Protocol error: bad global option %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|arg
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'n'
case|:
name|noexec
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|cvswrite
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
name|really_quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|logoff
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|trace
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
goto|goto
name|error_return
goto|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|serve_set
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
comment|/* FIXME: This sends errors immediately (I think); they should be        put into pending_error.  */
name|variable_set
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * We must read data from a child process and send it across the  * network.  We do not want to block on writing to the network, so we  * store the data from the child process in memory.  A BUFFER  * structure holds the status of one communication, and uses a linked  * list of buffer_data structures to hold data.  */
end_comment

begin_struct
struct|struct
name|buffer
block|{
comment|/* Data.  */
name|struct
name|buffer_data
modifier|*
name|data
decl_stmt|;
comment|/* Last buffer on data chain.  */
name|struct
name|buffer_data
modifier|*
name|last
decl_stmt|;
comment|/* File descriptor to write to or read from.  */
name|int
name|fd
decl_stmt|;
comment|/* Nonzero if this is an output buffer (sanity check).  */
name|int
name|output
decl_stmt|;
comment|/* Nonzero if the file descriptor is in nonblocking mode.  */
name|int
name|nonblocking
decl_stmt|;
comment|/* Function to call if we can't allocate memory.  */
name|void
argument_list|(
argument|*memory_error
argument_list|)
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|)
argument_list|)
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Data is stored in lists of these structures.  */
end_comment

begin_struct
struct|struct
name|buffer_data
block|{
comment|/* Next buffer in linked list.  */
name|struct
name|buffer_data
modifier|*
name|next
decl_stmt|;
comment|/*      * A pointer into the data area pointed to by the text field.  This      * is where to find data that has not yet been written out.      */
name|char
modifier|*
name|bufp
decl_stmt|;
comment|/* The number of data bytes found at BUFP.  */
name|int
name|size
decl_stmt|;
comment|/*      * Actual buffer.  This never changes after the structure is      * allocated.  The buffer is BUFFER_DATA_SIZE bytes.      */
name|char
modifier|*
name|text
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The size we allocate for each buffer_data structure.  */
end_comment

begin_define
define|#
directive|define
name|BUFFER_DATA_SIZE
value|(4096)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|SERVER_FLOWCONTROL
end_ifdef

begin_comment
comment|/* The maximum we'll queue to the remote client before blocking.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SERVER_HI_WATER
end_ifndef

begin_define
define|#
directive|define
name|SERVER_HI_WATER
value|(2 * 1024 * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SERVER_HI_WATER */
end_comment

begin_comment
comment|/* When the buffer drops to this, we restart the child */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SERVER_LO_WATER
end_ifndef

begin_define
define|#
directive|define
name|SERVER_LO_WATER
value|(1 * 1024 * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SERVER_LO_WATER */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SERVER_FLOWCONTROL */
end_comment

begin_comment
comment|/* Linked list of available buffer_data structures.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|buffer_data
modifier|*
name|free_buffer_data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|allocate_buffer_datas
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|struct
name|buffer_data
modifier|*
name|get_buffer_data
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|buf_empty_p
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|buf_output
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|buf_output0
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|buf_append_char
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|buf_send_output
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|set_nonblock
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|set_block
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|buf_send_counted
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|buf_append_data
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|,
expr|struct
name|buffer_data
operator|*
operator|,
expr|struct
name|buffer_data
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|buf_read_file
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|long
operator|,
expr|struct
name|buffer_data
operator|*
operator|*
operator|,
expr|struct
name|buffer_data
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|buf_input_data
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|buf_copy_lines
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|,
expr|struct
name|buffer
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|buf_copy_counted
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|,
expr|struct
name|buffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SERVER_FLOWCONTROL
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|buf_count_mem
name|PROTO
argument_list|(
operator|(
expr|struct
name|buffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|set_nonblock_fd
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SERVER_FLOWCONTROL */
end_comment

begin_comment
comment|/* Allocate more buffer_data structures.  */
end_comment

begin_function
specifier|static
name|void
name|allocate_buffer_datas
parameter_list|()
block|{
name|struct
name|buffer_data
modifier|*
name|alc
decl_stmt|;
name|char
modifier|*
name|space
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Allocate buffer_data structures in blocks of 16.  */
define|#
directive|define
name|ALLOC_COUNT
value|(16)
name|alc
operator|=
operator|(
operator|(
expr|struct
name|buffer_data
operator|*
operator|)
name|malloc
argument_list|(
name|ALLOC_COUNT
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|buffer_data
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|space
operator|=
operator|(
name|char
operator|*
operator|)
name|valloc
argument_list|(
name|ALLOC_COUNT
operator|*
name|BUFFER_DATA_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|alc
operator|==
name|NULL
operator|||
name|space
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ALLOC_COUNT
condition|;
name|i
operator|++
operator|,
name|alc
operator|++
operator|,
name|space
operator|+=
name|BUFFER_DATA_SIZE
control|)
block|{
name|alc
operator|->
name|next
operator|=
name|free_buffer_data
expr_stmt|;
name|free_buffer_data
operator|=
name|alc
expr_stmt|;
name|alc
operator|->
name|text
operator|=
name|space
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Get a new buffer_data structure.  */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|buffer_data
modifier|*
name|get_buffer_data
parameter_list|()
block|{
name|struct
name|buffer_data
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|free_buffer_data
operator|==
name|NULL
condition|)
block|{
name|allocate_buffer_datas
argument_list|()
expr_stmt|;
if|if
condition|(
name|free_buffer_data
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
name|ret
operator|=
name|free_buffer_data
expr_stmt|;
name|free_buffer_data
operator|=
name|ret
operator|->
name|next
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* See whether a buffer is empty.  */
end_comment

begin_function
specifier|static
name|int
name|buf_empty_p
parameter_list|(
name|buf
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
block|{
name|struct
name|buffer_data
modifier|*
name|data
decl_stmt|;
for|for
control|(
name|data
operator|=
name|buf
operator|->
name|data
init|;
name|data
operator|!=
name|NULL
condition|;
name|data
operator|=
name|data
operator|->
name|next
control|)
if|if
condition|(
name|data
operator|->
name|size
operator|>
literal|0
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SERVER_FLOWCONTROL
end_ifdef

begin_comment
comment|/*  * Count how much data is stored in the buffer..  * Note that each buffer is a malloc'ed chunk BUFFER_DATA_SIZE.  */
end_comment

begin_function
specifier|static
name|int
name|buf_count_mem
parameter_list|(
name|buf
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
block|{
name|struct
name|buffer_data
modifier|*
name|data
decl_stmt|;
name|int
name|mem
init|=
literal|0
decl_stmt|;
for|for
control|(
name|data
operator|=
name|buf
operator|->
name|data
init|;
name|data
operator|!=
name|NULL
condition|;
name|data
operator|=
name|data
operator|->
name|next
control|)
name|mem
operator|+=
name|BUFFER_DATA_SIZE
expr_stmt|;
return|return
name|mem
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SERVER_FLOWCONTROL */
end_comment

begin_comment
comment|/* Add data DATA of length LEN to BUF.  */
end_comment

begin_function
specifier|static
name|void
name|buf_output
parameter_list|(
name|buf
parameter_list|,
name|data
parameter_list|,
name|len
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
specifier|const
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
if|if
condition|(
name|buf
operator|->
name|data
operator|!=
name|NULL
operator|&&
operator|(
operator|(
operator|(
name|buf
operator|->
name|last
operator|->
name|text
operator|+
name|BUFFER_DATA_SIZE
operator|)
operator|-
operator|(
name|buf
operator|->
name|last
operator|->
name|bufp
operator|+
name|buf
operator|->
name|last
operator|->
name|size
operator|)
operator|)
operator|>=
name|len
operator|)
condition|)
block|{
name|memcpy
argument_list|(
name|buf
operator|->
name|last
operator|->
name|bufp
operator|+
name|buf
operator|->
name|last
operator|->
name|size
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf
operator|->
name|last
operator|->
name|size
operator|+=
name|len
expr_stmt|;
return|return;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|struct
name|buffer_data
modifier|*
name|newdata
decl_stmt|;
name|newdata
operator|=
name|get_buffer_data
argument_list|()
expr_stmt|;
if|if
condition|(
name|newdata
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|buf
operator|->
name|memory_error
call|)
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|buf
operator|->
name|data
operator|==
name|NULL
condition|)
name|buf
operator|->
name|data
operator|=
name|newdata
expr_stmt|;
else|else
name|buf
operator|->
name|last
operator|->
name|next
operator|=
name|newdata
expr_stmt|;
name|newdata
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|last
operator|=
name|newdata
expr_stmt|;
name|newdata
operator|->
name|bufp
operator|=
name|newdata
operator|->
name|text
expr_stmt|;
if|if
condition|(
name|len
operator|<=
name|BUFFER_DATA_SIZE
condition|)
block|{
name|newdata
operator|->
name|size
operator|=
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|newdata
operator|->
name|text
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return;
block|}
name|newdata
operator|->
name|size
operator|=
name|BUFFER_DATA_SIZE
expr_stmt|;
name|memcpy
argument_list|(
name|newdata
operator|->
name|text
argument_list|,
name|data
argument_list|,
name|BUFFER_DATA_SIZE
argument_list|)
expr_stmt|;
name|data
operator|+=
name|BUFFER_DATA_SIZE
expr_stmt|;
name|len
operator|-=
name|BUFFER_DATA_SIZE
expr_stmt|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/* Add a '\0' terminated string to BUF.  */
end_comment

begin_function
specifier|static
name|void
name|buf_output0
parameter_list|(
name|buf
parameter_list|,
name|string
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|buf_output
argument_list|(
name|buf
argument_list|,
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a single character to BUF.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|buf_append_char
parameter_list|(
name|buf
parameter_list|,
name|ch
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
name|int
name|ch
decl_stmt|;
block|{
if|if
condition|(
name|buf
operator|->
name|data
operator|!=
name|NULL
operator|&&
operator|(
name|buf
operator|->
name|last
operator|->
name|text
operator|+
name|BUFFER_DATA_SIZE
operator|!=
name|buf
operator|->
name|last
operator|->
name|bufp
operator|+
name|buf
operator|->
name|last
operator|->
name|size
operator|)
condition|)
block|{
operator|*
operator|(
name|buf
operator|->
name|last
operator|->
name|bufp
operator|+
name|buf
operator|->
name|last
operator|->
name|size
operator|)
operator|=
name|ch
expr_stmt|;
operator|++
name|buf
operator|->
name|last
operator|->
name|size
expr_stmt|;
block|}
else|else
block|{
name|char
name|b
decl_stmt|;
name|b
operator|=
name|ch
expr_stmt|;
name|buf_output
argument_list|(
name|buf
argument_list|,
operator|&
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Send all the output we've been saving up.  Returns 0 for success or  * errno code.  If the buffer has been set to be nonblocking, this  * will just write until the write would block.  */
end_comment

begin_function
specifier|static
name|int
name|buf_send_output
parameter_list|(
name|buf
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|buf
operator|->
name|output
condition|)
name|abort
argument_list|()
expr_stmt|;
while|while
condition|(
name|buf
operator|->
name|data
operator|!=
name|NULL
condition|)
block|{
name|struct
name|buffer_data
modifier|*
name|data
decl_stmt|;
name|data
operator|=
name|buf
operator|->
name|data
expr_stmt|;
while|while
condition|(
name|data
operator|->
name|size
operator|>
literal|0
condition|)
block|{
name|int
name|nbytes
decl_stmt|;
name|nbytes
operator|=
name|write
argument_list|(
name|buf
operator|->
name|fd
argument_list|,
name|data
operator|->
name|bufp
argument_list|,
name|data
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|<=
literal|0
condition|)
block|{
name|int
name|status
decl_stmt|;
if|if
condition|(
name|buf
operator|->
name|nonblocking
operator|&&
operator|(
name|nbytes
operator|==
literal|0
ifdef|#
directive|ifdef
name|EWOULDBLOCK
operator|||
name|errno
operator|==
name|EWOULDBLOCK
endif|#
directive|endif
operator|||
name|errno
operator|==
name|EAGAIN
operator|)
condition|)
block|{
comment|/* 		     * A nonblocking write failed to write any data. 		     * Just return. 		     */
return|return
literal|0
return|;
block|}
comment|/* 		 * An error, or EOF.  Throw away all the data and 		 * return. 		 */
if|if
condition|(
name|nbytes
operator|==
literal|0
condition|)
name|status
operator|=
name|EIO
expr_stmt|;
else|else
name|status
operator|=
name|errno
expr_stmt|;
name|buf
operator|->
name|last
operator|->
name|next
operator|=
name|free_buffer_data
expr_stmt|;
name|free_buffer_data
operator|=
name|buf
operator|->
name|data
expr_stmt|;
name|buf
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|last
operator|=
name|NULL
expr_stmt|;
return|return
name|status
return|;
block|}
name|data
operator|->
name|size
operator|-=
name|nbytes
expr_stmt|;
name|data
operator|->
name|bufp
operator|+=
name|nbytes
expr_stmt|;
block|}
name|buf
operator|->
name|data
operator|=
name|data
operator|->
name|next
expr_stmt|;
name|data
operator|->
name|next
operator|=
name|free_buffer_data
expr_stmt|;
name|free_buffer_data
operator|=
name|data
expr_stmt|;
block|}
name|buf
operator|->
name|last
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SERVER_FLOWCONTROL
end_ifdef

begin_comment
comment|/*  * Set buffer BUF to non-blocking I/O.  Returns 0 for success or errno  * code.  */
end_comment

begin_function
specifier|static
name|int
name|set_nonblock_fd
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
name|int
name|flags
decl_stmt|;
name|flags
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|<
literal|0
condition|)
return|return
name|errno
return|;
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|flags
operator||
name|O_NONBLOCK
argument_list|)
operator|<
literal|0
condition|)
return|return
name|errno
return|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SERVER_FLOWCONTROL */
end_comment

begin_function
specifier|static
name|int
name|set_nonblock
parameter_list|(
name|buf
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
block|{
name|int
name|flags
decl_stmt|;
if|if
condition|(
name|buf
operator|->
name|nonblocking
condition|)
return|return
literal|0
return|;
name|flags
operator|=
name|fcntl
argument_list|(
name|buf
operator|->
name|fd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|<
literal|0
condition|)
return|return
name|errno
return|;
if|if
condition|(
name|fcntl
argument_list|(
name|buf
operator|->
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|flags
operator||
name|O_NONBLOCK
argument_list|)
operator|<
literal|0
condition|)
return|return
name|errno
return|;
name|buf
operator|->
name|nonblocking
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Set buffer BUF to blocking I/O.  Returns 0 for success or errno  * code.  */
end_comment

begin_function
specifier|static
name|int
name|set_block
parameter_list|(
name|buf
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
block|{
name|int
name|flags
decl_stmt|;
if|if
condition|(
operator|!
name|buf
operator|->
name|nonblocking
condition|)
return|return
literal|0
return|;
name|flags
operator|=
name|fcntl
argument_list|(
name|buf
operator|->
name|fd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|<
literal|0
condition|)
return|return
name|errno
return|;
if|if
condition|(
name|fcntl
argument_list|(
name|buf
operator|->
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|flags
operator|&
operator|~
name|O_NONBLOCK
argument_list|)
operator|<
literal|0
condition|)
return|return
name|errno
return|;
name|buf
operator|->
name|nonblocking
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Send a character count and some output.  Returns errno code or 0 for  * success.  *  * Sending the count in binary is OK since this is only used on a pipe  * within the same system.  */
end_comment

begin_function
specifier|static
name|int
name|buf_send_counted
parameter_list|(
name|buf
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
block|{
name|int
name|size
decl_stmt|;
name|struct
name|buffer_data
modifier|*
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|buf
operator|->
name|output
condition|)
name|abort
argument_list|()
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|data
operator|=
name|buf
operator|->
name|data
init|;
name|data
operator|!=
name|NULL
condition|;
name|data
operator|=
name|data
operator|->
name|next
control|)
name|size
operator|+=
name|data
operator|->
name|size
expr_stmt|;
name|data
operator|=
name|get_buffer_data
argument_list|()
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|buf
operator|->
name|memory_error
call|)
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|data
operator|->
name|next
operator|=
name|buf
operator|->
name|data
expr_stmt|;
name|buf
operator|->
name|data
operator|=
name|data
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|last
operator|==
name|NULL
condition|)
name|buf
operator|->
name|last
operator|=
name|data
expr_stmt|;
name|data
operator|->
name|bufp
operator|=
name|data
operator|->
name|text
expr_stmt|;
name|data
operator|->
name|size
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|->
name|text
operator|)
operator|=
name|size
expr_stmt|;
return|return
name|buf_send_output
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Append a list of buffer_data structures to an buffer.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|buf_append_data
parameter_list|(
name|buf
parameter_list|,
name|data
parameter_list|,
name|last
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
name|struct
name|buffer_data
modifier|*
name|data
decl_stmt|;
name|struct
name|buffer_data
modifier|*
name|last
decl_stmt|;
block|{
if|if
condition|(
name|data
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|buf
operator|->
name|data
operator|==
name|NULL
condition|)
name|buf
operator|->
name|data
operator|=
name|data
expr_stmt|;
else|else
name|buf
operator|->
name|last
operator|->
name|next
operator|=
name|data
expr_stmt|;
name|buf
operator|->
name|last
operator|=
name|last
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Copy the contents of file F into buffer_data structures.  We can't  * copy directly into an buffer, because we want to handle failure and  * succeess differently.  Returns 0 on success, or -2 if out of  * memory, or a status code on error.  Since the caller happens to  * know the size of the file, it is passed in as SIZE.  On success,  * this function sets *RETP and *LASTP, which may be passed to  * buf_append_data.  */
end_comment

begin_function
specifier|static
name|int
name|buf_read_file
parameter_list|(
name|f
parameter_list|,
name|size
parameter_list|,
name|retp
parameter_list|,
name|lastp
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|long
name|size
decl_stmt|;
name|struct
name|buffer_data
modifier|*
modifier|*
name|retp
decl_stmt|;
name|struct
name|buffer_data
modifier|*
modifier|*
name|lastp
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
operator|*
name|retp
operator|=
name|NULL
expr_stmt|;
operator|*
name|lastp
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|struct
name|buffer_data
modifier|*
name|data
decl_stmt|;
name|int
name|get
decl_stmt|;
name|data
operator|=
name|get_buffer_data
argument_list|()
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
name|status
operator|=
operator|-
literal|2
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
operator|*
name|retp
operator|==
name|NULL
condition|)
operator|*
name|retp
operator|=
name|data
expr_stmt|;
else|else
operator|(
operator|*
name|lastp
operator|)
operator|->
name|next
operator|=
name|data
expr_stmt|;
name|data
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|lastp
operator|=
name|data
expr_stmt|;
name|data
operator|->
name|bufp
operator|=
name|data
operator|->
name|text
expr_stmt|;
name|data
operator|->
name|size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|BUFFER_DATA_SIZE
condition|)
name|get
operator|=
name|BUFFER_DATA_SIZE
expr_stmt|;
else|else
name|get
operator|=
name|size
expr_stmt|;
name|errno
operator|=
name|EIO
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|data
operator|->
name|text
argument_list|,
name|get
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|status
operator|=
name|errno
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|data
operator|->
name|size
operator|+=
name|get
expr_stmt|;
name|size
operator|-=
name|get
expr_stmt|;
block|}
return|return
literal|0
return|;
name|error_return
label|:
if|if
condition|(
operator|*
name|retp
operator|!=
name|NULL
condition|)
block|{
operator|(
operator|*
name|lastp
operator|)
operator|->
name|next
operator|=
name|free_buffer_data
expr_stmt|;
name|free_buffer_data
operator|=
operator|*
name|retp
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|buf_read_file_to_eof
parameter_list|(
name|f
parameter_list|,
name|retp
parameter_list|,
name|lastp
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|struct
name|buffer_data
modifier|*
modifier|*
name|retp
decl_stmt|;
name|struct
name|buffer_data
modifier|*
modifier|*
name|lastp
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
operator|*
name|retp
operator|=
name|NULL
expr_stmt|;
operator|*
name|lastp
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|struct
name|buffer_data
modifier|*
name|data
decl_stmt|;
name|int
name|get
decl_stmt|,
name|nread
decl_stmt|;
name|data
operator|=
name|get_buffer_data
argument_list|()
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
name|status
operator|=
operator|-
literal|2
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
operator|*
name|retp
operator|==
name|NULL
condition|)
operator|*
name|retp
operator|=
name|data
expr_stmt|;
else|else
operator|(
operator|*
name|lastp
operator|)
operator|->
name|next
operator|=
name|data
expr_stmt|;
name|data
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|lastp
operator|=
name|data
expr_stmt|;
name|data
operator|->
name|bufp
operator|=
name|data
operator|->
name|text
expr_stmt|;
name|data
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|get
operator|=
name|BUFFER_DATA_SIZE
expr_stmt|;
name|errno
operator|=
name|EIO
expr_stmt|;
name|nread
operator|=
name|fread
argument_list|(
name|data
operator|->
name|text
argument_list|,
literal|1
argument_list|,
name|get
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|==
literal|0
operator|&&
operator|!
name|feof
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|status
operator|=
name|errno
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|data
operator|->
name|size
operator|=
name|nread
expr_stmt|;
block|}
return|return
literal|0
return|;
name|error_return
label|:
if|if
condition|(
operator|*
name|retp
operator|!=
name|NULL
condition|)
block|{
operator|(
operator|*
name|lastp
operator|)
operator|->
name|next
operator|=
name|free_buffer_data
expr_stmt|;
name|free_buffer_data
operator|=
operator|*
name|retp
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|buf_chain_length
parameter_list|(
name|buf
parameter_list|)
name|struct
name|buffer_data
modifier|*
name|buf
decl_stmt|;
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|buf
condition|)
block|{
name|size
operator|+=
name|buf
operator|->
name|size
expr_stmt|;
name|buf
operator|=
name|buf
operator|->
name|next
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/*  * Read an arbitrary amount of data from a file descriptor into an  * input buffer.  The file descriptor will be in nonblocking mode, and  * we just grab what we can.  Return 0 on success, or -1 on end of  * file, or -2 if out of memory, or an error code.  If COUNTP is not  * NULL, *COUNTP is set to the number of bytes read.  */
end_comment

begin_function
specifier|static
name|int
name|buf_input_data
parameter_list|(
name|buf
parameter_list|,
name|countp
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
name|int
modifier|*
name|countp
decl_stmt|;
block|{
if|if
condition|(
name|buf
operator|->
name|output
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|countp
operator|!=
name|NULL
condition|)
operator|*
name|countp
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|get
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
if|if
condition|(
name|buf
operator|->
name|data
operator|==
name|NULL
operator|||
operator|(
name|buf
operator|->
name|last
operator|->
name|bufp
operator|+
name|buf
operator|->
name|last
operator|->
name|size
operator|==
name|buf
operator|->
name|last
operator|->
name|text
operator|+
name|BUFFER_DATA_SIZE
operator|)
condition|)
block|{
name|struct
name|buffer_data
modifier|*
name|data
decl_stmt|;
name|data
operator|=
name|get_buffer_data
argument_list|()
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
call|(
modifier|*
name|buf
operator|->
name|memory_error
call|)
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
if|if
condition|(
name|buf
operator|->
name|data
operator|==
name|NULL
condition|)
name|buf
operator|->
name|data
operator|=
name|data
expr_stmt|;
else|else
name|buf
operator|->
name|last
operator|->
name|next
operator|=
name|data
expr_stmt|;
name|data
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|last
operator|=
name|data
expr_stmt|;
name|data
operator|->
name|bufp
operator|=
name|data
operator|->
name|text
expr_stmt|;
name|data
operator|->
name|size
operator|=
literal|0
expr_stmt|;
block|}
name|get
operator|=
operator|(
operator|(
name|buf
operator|->
name|last
operator|->
name|text
operator|+
name|BUFFER_DATA_SIZE
operator|)
operator|-
operator|(
name|buf
operator|->
name|last
operator|->
name|bufp
operator|+
name|buf
operator|->
name|last
operator|->
name|size
operator|)
operator|)
expr_stmt|;
name|nbytes
operator|=
name|read
argument_list|(
name|buf
operator|->
name|fd
argument_list|,
name|buf
operator|->
name|last
operator|->
name|bufp
operator|+
name|buf
operator|->
name|last
operator|->
name|size
argument_list|,
name|get
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|nbytes
operator|==
literal|0
condition|)
block|{
comment|/* 		 * This assumes that we are using POSIX or BSD style 		 * nonblocking I/O.  On System V we will get a zero 		 * return if there is no data, even when not at EOF. 		 */
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|errno
operator|==
name|EAGAIN
ifdef|#
directive|ifdef
name|EWOULDBLOCK
operator|||
name|errno
operator|==
name|EWOULDBLOCK
endif|#
directive|endif
condition|)
return|return
literal|0
return|;
return|return
name|errno
return|;
block|}
name|buf
operator|->
name|last
operator|->
name|size
operator|+=
name|nbytes
expr_stmt|;
if|if
condition|(
name|countp
operator|!=
name|NULL
condition|)
operator|*
name|countp
operator|+=
name|nbytes
expr_stmt|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/*  * Copy lines from an input buffer to an output buffer.  This copies  * all complete lines (characters up to a newline) from INBUF to  * OUTBUF.  Each line in OUTBUF is preceded by the character COMMAND  * and a space.  */
end_comment

begin_function
specifier|static
name|void
name|buf_copy_lines
parameter_list|(
name|outbuf
parameter_list|,
name|inbuf
parameter_list|,
name|command
parameter_list|)
name|struct
name|buffer
modifier|*
name|outbuf
decl_stmt|;
name|struct
name|buffer
modifier|*
name|inbuf
decl_stmt|;
name|int
name|command
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|outbuf
operator|->
name|output
operator|||
name|inbuf
operator|->
name|output
condition|)
name|abort
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|struct
name|buffer_data
modifier|*
name|data
decl_stmt|;
name|struct
name|buffer_data
modifier|*
name|nldata
decl_stmt|;
name|char
modifier|*
name|nl
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* See if there is a newline in INBUF.  */
name|nldata
operator|=
name|NULL
expr_stmt|;
name|nl
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|data
operator|=
name|inbuf
operator|->
name|data
init|;
name|data
operator|!=
name|NULL
condition|;
name|data
operator|=
name|data
operator|->
name|next
control|)
block|{
name|nl
operator|=
name|memchr
argument_list|(
name|data
operator|->
name|bufp
argument_list|,
literal|'\n'
argument_list|,
name|data
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
operator|!=
name|NULL
condition|)
block|{
name|nldata
operator|=
name|data
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|nldata
operator|==
name|NULL
condition|)
block|{
comment|/* There are no more lines in INBUF.  */
return|return;
block|}
comment|/* Put in the command.  */
name|buf_append_char
argument_list|(
name|outbuf
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|buf_append_char
argument_list|(
name|outbuf
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|inbuf
operator|->
name|data
operator|!=
name|nldata
condition|)
block|{
comment|/* 	     * Simply move over all the buffers up to the one containing 	     * the newline. 	     */
for|for
control|(
name|data
operator|=
name|inbuf
operator|->
name|data
init|;
name|data
operator|->
name|next
operator|!=
name|nldata
condition|;
name|data
operator|=
name|data
operator|->
name|next
control|)
empty_stmt|;
name|data
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|buf_append_data
argument_list|(
name|outbuf
argument_list|,
name|inbuf
operator|->
name|data
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|inbuf
operator|->
name|data
operator|=
name|nldata
expr_stmt|;
block|}
comment|/* 	 * If the newline is at the very end of the buffer, just move 	 * the buffer onto OUTBUF.  Otherwise we must copy the data. 	 */
name|len
operator|=
name|nl
operator|+
literal|1
operator|-
name|nldata
operator|->
name|bufp
expr_stmt|;
if|if
condition|(
name|len
operator|==
name|nldata
operator|->
name|size
condition|)
block|{
name|inbuf
operator|->
name|data
operator|=
name|nldata
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|inbuf
operator|->
name|data
operator|==
name|NULL
condition|)
name|inbuf
operator|->
name|last
operator|=
name|NULL
expr_stmt|;
name|nldata
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|buf_append_data
argument_list|(
name|outbuf
argument_list|,
name|nldata
argument_list|,
name|nldata
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf_output
argument_list|(
name|outbuf
argument_list|,
name|nldata
operator|->
name|bufp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|nldata
operator|->
name|bufp
operator|+=
name|len
expr_stmt|;
name|nldata
operator|->
name|size
operator|-=
name|len
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Copy counted data from one buffer to another.  The count is an  * integer, host size, host byte order (it is only used across a  * pipe).  If there is enough data, it should be moved over.  If there  * is not enough data, it should remain on the original buffer.  This  * returns the number of bytes it needs to see in order to actually  * copy something over.  */
end_comment

begin_function
specifier|static
name|int
name|buf_copy_counted
parameter_list|(
name|outbuf
parameter_list|,
name|inbuf
parameter_list|)
name|struct
name|buffer
modifier|*
name|outbuf
decl_stmt|;
name|struct
name|buffer
modifier|*
name|inbuf
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|outbuf
operator|->
name|output
operator|||
name|inbuf
operator|->
name|output
condition|)
name|abort
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|struct
name|buffer_data
modifier|*
name|data
decl_stmt|;
name|int
name|need
decl_stmt|;
union|union
block|{
name|char
name|intbuf
index|[
sizeof|sizeof
argument_list|(
name|int
argument_list|)
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
block|}
name|u
union|;
name|char
modifier|*
name|intp
decl_stmt|;
name|int
name|count
decl_stmt|;
name|struct
name|buffer_data
modifier|*
name|start
decl_stmt|;
name|int
name|startoff
decl_stmt|;
name|struct
name|buffer_data
modifier|*
name|stop
decl_stmt|;
name|int
name|stopwant
decl_stmt|;
comment|/* See if we have enough bytes to figure out the count.  */
name|need
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|intp
operator|=
name|u
operator|.
name|intbuf
expr_stmt|;
for|for
control|(
name|data
operator|=
name|inbuf
operator|->
name|data
init|;
name|data
operator|!=
name|NULL
condition|;
name|data
operator|=
name|data
operator|->
name|next
control|)
block|{
if|if
condition|(
name|data
operator|->
name|size
operator|>=
name|need
condition|)
block|{
name|memcpy
argument_list|(
name|intp
argument_list|,
name|data
operator|->
name|bufp
argument_list|,
name|need
argument_list|)
expr_stmt|;
break|break;
block|}
name|memcpy
argument_list|(
name|intp
argument_list|,
name|data
operator|->
name|bufp
argument_list|,
name|data
operator|->
name|size
argument_list|)
expr_stmt|;
name|intp
operator|+=
name|data
operator|->
name|size
expr_stmt|;
name|need
operator|-=
name|data
operator|->
name|size
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
comment|/* We don't have enough bytes to form an integer.  */
return|return
name|need
return|;
block|}
name|count
operator|=
name|u
operator|.
name|i
expr_stmt|;
name|start
operator|=
name|data
expr_stmt|;
name|startoff
operator|=
name|need
expr_stmt|;
comment|/* 	 * We have an integer in COUNT.  We have gotten all the data 	 * from INBUF in all buffers before START, and we have gotten 	 * STARTOFF bytes from START.  See if we have enough bytes 	 * remaining in INBUF. 	 */
name|need
operator|=
name|count
operator|-
operator|(
name|start
operator|->
name|size
operator|-
name|startoff
operator|)
expr_stmt|;
if|if
condition|(
name|need
operator|<=
literal|0
condition|)
block|{
name|stop
operator|=
name|start
expr_stmt|;
name|stopwant
operator|=
name|count
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|data
operator|=
name|start
operator|->
name|next
init|;
name|data
operator|!=
name|NULL
condition|;
name|data
operator|=
name|data
operator|->
name|next
control|)
block|{
if|if
condition|(
name|need
operator|<=
name|data
operator|->
name|size
condition|)
break|break;
name|need
operator|-=
name|data
operator|->
name|size
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
comment|/* We don't have enough bytes.  */
return|return
name|need
return|;
block|}
name|stop
operator|=
name|data
expr_stmt|;
name|stopwant
operator|=
name|need
expr_stmt|;
block|}
comment|/* 	 * We have enough bytes.  Free any buffers in INBUF before 	 * START, and remove STARTOFF bytes from START, so that we can 	 * forget about STARTOFF. 	 */
name|start
operator|->
name|bufp
operator|+=
name|startoff
expr_stmt|;
name|start
operator|->
name|size
operator|-=
name|startoff
expr_stmt|;
if|if
condition|(
name|start
operator|->
name|size
operator|==
literal|0
condition|)
name|start
operator|=
name|start
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|stop
operator|->
name|size
operator|==
name|stopwant
condition|)
block|{
name|stop
operator|=
name|stop
operator|->
name|next
expr_stmt|;
name|stopwant
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|inbuf
operator|->
name|data
operator|!=
name|start
condition|)
block|{
name|data
operator|=
name|inbuf
operator|->
name|data
expr_stmt|;
name|inbuf
operator|->
name|data
operator|=
name|data
operator|->
name|next
expr_stmt|;
name|data
operator|->
name|next
operator|=
name|free_buffer_data
expr_stmt|;
name|free_buffer_data
operator|=
name|data
expr_stmt|;
block|}
comment|/* 	 * We want to copy over the bytes from START through STOP.  We 	 * only want STOPWANT bytes from STOP. 	 */
if|if
condition|(
name|start
operator|!=
name|stop
condition|)
block|{
comment|/* Attach the buffers from START through STOP to OUTBUF.  */
for|for
control|(
name|data
operator|=
name|start
init|;
name|data
operator|->
name|next
operator|!=
name|stop
condition|;
name|data
operator|=
name|data
operator|->
name|next
control|)
empty_stmt|;
name|inbuf
operator|->
name|data
operator|=
name|stop
expr_stmt|;
name|data
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|buf_append_data
argument_list|(
name|outbuf
argument_list|,
name|start
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stopwant
operator|>
literal|0
condition|)
block|{
name|buf_output
argument_list|(
name|outbuf
argument_list|,
name|stop
operator|->
name|bufp
argument_list|,
name|stopwant
argument_list|)
expr_stmt|;
name|stop
operator|->
name|bufp
operator|+=
name|stopwant
expr_stmt|;
name|stop
operator|->
name|size
operator|-=
name|stopwant
expr_stmt|;
block|}
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* While processing requests, this buffer accumulates data to be sent to    the client, and then once we are in do_cvs_command, we use it    for all the data to be sent.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|buffer
name|buf_to_net
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|serve_questionable
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_questionable
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
specifier|static
name|int
name|initted
decl_stmt|;
if|if
condition|(
operator|!
name|initted
condition|)
block|{
comment|/* Pick up ignores from CVSROOTADM_IGNORE, $HOME/.cvsignore on server, 	   and CVSIGNORE on server.  */
name|ign_setup
argument_list|()
expr_stmt|;
name|initted
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|dir_name
operator|==
name|NULL
condition|)
block|{
name|buf_output0
argument_list|(
operator|&
name|buf_to_net
argument_list|,
literal|"E Protocol error: 'Directory' missing"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|ign_name
argument_list|(
name|arg
argument_list|)
condition|)
block|{
name|char
modifier|*
name|update_dir
decl_stmt|;
name|buf_output
argument_list|(
operator|&
name|buf_to_net
argument_list|,
literal|"M ? "
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|update_dir
operator|=
name|dir_name
operator|+
name|strlen
argument_list|(
name|server_temp_dir
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|update_dir
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|buf_output0
argument_list|(
operator|&
name|buf_to_net
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
name|buf_output
argument_list|(
operator|&
name|buf_to_net
argument_list|,
literal|"/"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|buf_output0
argument_list|(
operator|&
name|buf_to_net
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|buf_output
argument_list|(
operator|&
name|buf_to_net
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|serve_case
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_case
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|ign_case
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|struct
name|buffer
name|protocol
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the output which we are saving up to send to the server, in the    child process.  We will push it through, via the `protocol' buffer, when    we have a complete line.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|buffer
name|saved_output
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Likewise, but stuff which will go to stderr.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|buffer
name|saved_outerr
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
specifier|static
name|void
name|protocol_memory_error
parameter_list|(
name|buf
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
block|{
name|error
argument_list|(
literal|1
argument_list|,
name|ENOMEM
argument_list|,
literal|"Virtual memory exhausted"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process IDs of the subprocess, or negative if that subprocess  * does not exist.  */
end_comment

begin_decl_stmt
specifier|static
name|pid_t
name|command_pid
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|outbuf_memory_error
parameter_list|(
name|buf
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
block|{
specifier|static
specifier|const
name|char
name|msg
index|[]
init|=
literal|"E Fatal server error\n\ error ENOMEM Virtual memory exhausted.\n"
decl_stmt|;
if|if
condition|(
name|command_pid
operator|>
literal|0
condition|)
name|kill
argument_list|(
name|command_pid
argument_list|,
name|SIGTERM
argument_list|)
expr_stmt|;
comment|/*      * We have arranged things so that printing this now either will      * be legal, or the "E fatal error" line will get glommed onto the      * end of an existing "E" or "M" response.      */
comment|/* If this gives an error, not much we could do.  syslog() it?  */
name|write
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|server_cleanup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|input_memory_error
parameter_list|(
name|buf
parameter_list|)
name|struct
name|buffer
modifier|*
name|buf
decl_stmt|;
block|{
name|outbuf_memory_error
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Execute COMMAND in a subprocess with the approriate funky things done.  */
end_comment

begin_struct
specifier|static
struct|struct
name|fd_set_wrapper
block|{
name|fd_set
name|fds
decl_stmt|;
block|}
name|command_fds_to_drain
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|max_command_fd
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SERVER_FLOWCONTROL
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|flowcontrol_pipe
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SERVER_FLOWCONTROL */
end_comment

begin_function_decl
specifier|static
name|void
name|do_cvs_command
parameter_list|(
name|command
parameter_list|)
function_decl|int
parameter_list|(
function_decl|*command
end_function_decl

begin_expr_stmt
unit|)
name|PROTO
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/*      * The following file descriptors are set to -1 if that file is not      * currently open.      */
comment|/* Data on these pipes is a series of '\n'-terminated lines.  */
name|int
name|stdout_pipe
index|[
literal|2
index|]
decl_stmt|;
name|int
name|stderr_pipe
index|[
literal|2
index|]
decl_stmt|;
comment|/*      * Data on this pipe is a series of counted (see buf_send_counted)      * packets.  Each packet must be processed atomically (i.e. not      * interleaved with data from stdout_pipe or stderr_pipe).      */
name|int
name|protocol_pipe
index|[
literal|2
index|]
decl_stmt|;
name|int
name|dev_null_fd
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|errs
decl_stmt|;
name|command_pid
operator|=
operator|-
literal|1
expr_stmt|;
name|stdout_pipe
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|stdout_pipe
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|stderr_pipe
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|stderr_pipe
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|protocol_pipe
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|protocol_pipe
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|server_write_entries
argument_list|()
expr_stmt|;
if|if
condition|(
name|print_pending_error
argument_list|()
condition|)
goto|goto
name|free_args_and_return
goto|;
operator|(
name|void
operator|)
name|server_notify
argument_list|()
expr_stmt|;
comment|/*      * We use a child process which actually does the operation.  This      * is so we can intercept its standard output.  Even if all of CVS      * were written to go to some special routine instead of writing      * to stdout or stderr, we would still need to do the same thing      * for the RCS commands.      */
if|if
condition|(
name|pipe
argument_list|(
name|stdout_pipe
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
if|if
condition|(
name|pipe
argument_list|(
name|stderr_pipe
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
if|if
condition|(
name|pipe
argument_list|(
name|protocol_pipe
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
ifdef|#
directive|ifdef
name|SERVER_FLOWCONTROL
if|if
condition|(
name|pipe
argument_list|(
name|flowcontrol_pipe
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
name|set_nonblock_fd
argument_list|(
name|flowcontrol_pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|set_nonblock_fd
argument_list|(
name|flowcontrol_pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SERVER_FLOWCONTROL */
name|dev_null_fd
operator|=
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_null_fd
operator|<
literal|0
condition|)
block|{
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
comment|/* Don't use vfork; we're not going to exec().  */
name|command_pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|command_pid
operator|<
literal|0
condition|)
block|{
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
if|if
condition|(
name|command_pid
operator|==
literal|0
condition|)
block|{
name|int
name|exitstatus
decl_stmt|;
comment|/* Since we're in the child, and the parent is going to take 	   care of packaging up our error messages, we can clear this 	   flag.  */
name|error_use_protocol
operator|=
literal|0
expr_stmt|;
name|protocol
operator|.
name|data
operator|=
name|protocol
operator|.
name|last
operator|=
name|NULL
expr_stmt|;
name|protocol
operator|.
name|fd
operator|=
name|protocol_pipe
index|[
literal|1
index|]
expr_stmt|;
name|protocol
operator|.
name|output
operator|=
literal|1
expr_stmt|;
name|protocol
operator|.
name|nonblocking
operator|=
literal|0
expr_stmt|;
name|protocol
operator|.
name|memory_error
operator|=
name|protocol_memory_error
expr_stmt|;
name|saved_output
operator|.
name|data
operator|=
name|saved_output
operator|.
name|last
operator|=
name|NULL
expr_stmt|;
name|saved_output
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|saved_output
operator|.
name|output
operator|=
literal|0
expr_stmt|;
name|saved_output
operator|.
name|nonblocking
operator|=
literal|0
expr_stmt|;
name|saved_output
operator|.
name|memory_error
operator|=
name|protocol_memory_error
expr_stmt|;
name|saved_outerr
operator|=
name|saved_output
expr_stmt|;
if|if
condition|(
name|dup2
argument_list|(
name|dev_null_fd
argument_list|,
name|STDIN_FILENO
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"can't set up pipes"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup2
argument_list|(
name|stdout_pipe
index|[
literal|1
index|]
argument_list|,
name|STDOUT_FILENO
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"can't set up pipes"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup2
argument_list|(
name|stderr_pipe
index|[
literal|1
index|]
argument_list|,
name|STDERR_FILENO
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"can't set up pipes"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|stdout_pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|stderr_pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|protocol_pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_FLOWCONTROL
name|close
argument_list|(
name|flowcontrol_pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SERVER_FLOWCONTROL */
comment|/* 	 * Set this in .bashrc if you want to give yourself time to attach 	 * to the subprocess with a debugger. 	 */
if|if
condition|(
name|getenv
argument_list|(
literal|"CVS_SERVER_SLEEP"
argument_list|)
condition|)
block|{
name|int
name|secs
init|=
name|atoi
argument_list|(
name|getenv
argument_list|(
literal|"CVS_SERVER_SLEEP"
argument_list|)
argument_list|)
decl_stmt|;
name|sleep
argument_list|(
name|secs
argument_list|)
expr_stmt|;
block|}
name|exitstatus
operator|=
call|(
modifier|*
name|command
call|)
argument_list|(
name|argument_count
argument_list|,
name|argument_vector
argument_list|)
expr_stmt|;
comment|/* 	 * When we exit, that will close the pipes, giving an EOF to 	 * the parent. 	 */
name|exit
argument_list|(
name|exitstatus
argument_list|)
expr_stmt|;
block|}
comment|/* OK, sit around getting all the input from the child.  */
block|{
name|struct
name|buffer
name|stdoutbuf
decl_stmt|;
name|struct
name|buffer
name|stderrbuf
decl_stmt|;
name|struct
name|buffer
name|protocol_inbuf
decl_stmt|;
comment|/* Number of file descriptors to check in select ().  */
name|int
name|num_to_check
decl_stmt|;
name|int
name|count_needed
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|SERVER_FLOWCONTROL
name|int
name|have_flowcontrolled
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* SERVER_FLOWCONTROL */
name|FD_ZERO
argument_list|(
operator|&
name|command_fds_to_drain
operator|.
name|fds
argument_list|)
expr_stmt|;
name|num_to_check
operator|=
name|stdout_pipe
index|[
literal|0
index|]
expr_stmt|;
name|FD_SET
argument_list|(
name|stdout_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|command_fds_to_drain
operator|.
name|fds
argument_list|)
expr_stmt|;
if|if
condition|(
name|stderr_pipe
index|[
literal|0
index|]
operator|>
name|num_to_check
condition|)
name|num_to_check
operator|=
name|stderr_pipe
index|[
literal|0
index|]
expr_stmt|;
name|FD_SET
argument_list|(
name|stderr_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|command_fds_to_drain
operator|.
name|fds
argument_list|)
expr_stmt|;
if|if
condition|(
name|protocol_pipe
index|[
literal|0
index|]
operator|>
name|num_to_check
condition|)
name|num_to_check
operator|=
name|protocol_pipe
index|[
literal|0
index|]
expr_stmt|;
name|FD_SET
argument_list|(
name|protocol_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|command_fds_to_drain
operator|.
name|fds
argument_list|)
expr_stmt|;
if|if
condition|(
name|STDOUT_FILENO
operator|>
name|num_to_check
condition|)
name|num_to_check
operator|=
name|STDOUT_FILENO
expr_stmt|;
name|max_command_fd
operator|=
name|num_to_check
expr_stmt|;
comment|/* 	 * File descriptors are numbered from 0, so num_to_check needs to 	 * be one larger than the largest descriptor. 	 */
operator|++
name|num_to_check
expr_stmt|;
if|if
condition|(
name|num_to_check
operator|>
name|FD_SETSIZE
condition|)
block|{
name|printf
argument_list|(
literal|"E internal error: FD_SETSIZE not big enough.\nerror  \n"
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
name|stdoutbuf
operator|.
name|data
operator|=
name|stdoutbuf
operator|.
name|last
operator|=
name|NULL
expr_stmt|;
name|stdoutbuf
operator|.
name|fd
operator|=
name|stdout_pipe
index|[
literal|0
index|]
expr_stmt|;
name|stdoutbuf
operator|.
name|output
operator|=
literal|0
expr_stmt|;
name|stdoutbuf
operator|.
name|nonblocking
operator|=
literal|0
expr_stmt|;
name|stdoutbuf
operator|.
name|memory_error
operator|=
name|input_memory_error
expr_stmt|;
name|stderrbuf
operator|.
name|data
operator|=
name|stderrbuf
operator|.
name|last
operator|=
name|NULL
expr_stmt|;
name|stderrbuf
operator|.
name|fd
operator|=
name|stderr_pipe
index|[
literal|0
index|]
expr_stmt|;
name|stderrbuf
operator|.
name|output
operator|=
literal|0
expr_stmt|;
name|stderrbuf
operator|.
name|nonblocking
operator|=
literal|0
expr_stmt|;
name|stderrbuf
operator|.
name|memory_error
operator|=
name|input_memory_error
expr_stmt|;
name|protocol_inbuf
operator|.
name|data
operator|=
name|protocol_inbuf
operator|.
name|last
operator|=
name|NULL
expr_stmt|;
name|protocol_inbuf
operator|.
name|fd
operator|=
name|protocol_pipe
index|[
literal|0
index|]
expr_stmt|;
name|protocol_inbuf
operator|.
name|output
operator|=
literal|0
expr_stmt|;
name|protocol_inbuf
operator|.
name|nonblocking
operator|=
literal|0
expr_stmt|;
name|protocol_inbuf
operator|.
name|memory_error
operator|=
name|input_memory_error
expr_stmt|;
name|set_nonblock
argument_list|(
operator|&
name|buf_to_net
argument_list|)
expr_stmt|;
name|set_nonblock
argument_list|(
operator|&
name|stdoutbuf
argument_list|)
expr_stmt|;
name|set_nonblock
argument_list|(
operator|&
name|stderrbuf
argument_list|)
expr_stmt|;
name|set_nonblock
argument_list|(
operator|&
name|protocol_inbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|stdout_pipe
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
name|stdout_pipe
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|stderr_pipe
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
name|stderr_pipe
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|protocol_pipe
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
name|protocol_pipe
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_FLOWCONTROL
if|if
condition|(
name|close
argument_list|(
name|flowcontrol_pipe
index|[
literal|0
index|]
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
name|flowcontrol_pipe
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* SERVER_FLOWCONTROL */
if|if
condition|(
name|close
argument_list|(
name|dev_null_fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
name|dev_null_fd
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|stdout_pipe
index|[
literal|0
index|]
operator|>=
literal|0
operator|||
name|stderr_pipe
index|[
literal|0
index|]
operator|>=
literal|0
operator|||
name|protocol_pipe
index|[
literal|0
index|]
operator|>=
literal|0
condition|)
block|{
name|fd_set
name|readfds
decl_stmt|;
name|fd_set
name|writefds
decl_stmt|;
name|int
name|numfds
decl_stmt|;
ifdef|#
directive|ifdef
name|SERVER_FLOWCONTROL
name|int
name|bufmemsize
decl_stmt|;
comment|/* 	     * See if we are swamping the remote client and filling our VM. 	     * Tell child to hold off if we do. 	     */
name|bufmemsize
operator|=
name|buf_count_mem
argument_list|(
operator|&
name|buf_to_net
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|have_flowcontrolled
operator|&&
operator|(
name|bufmemsize
operator|>
name|SERVER_HI_WATER
operator|)
condition|)
block|{
if|if
condition|(
name|write
argument_list|(
name|flowcontrol_pipe
index|[
literal|1
index|]
argument_list|,
literal|"S"
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
name|have_flowcontrolled
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|have_flowcontrolled
operator|&&
operator|(
name|bufmemsize
operator|<
name|SERVER_LO_WATER
operator|)
condition|)
block|{
if|if
condition|(
name|write
argument_list|(
name|flowcontrol_pipe
index|[
literal|1
index|]
argument_list|,
literal|"G"
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
name|have_flowcontrolled
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SERVER_FLOWCONTROL */
name|FD_ZERO
argument_list|(
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|writefds
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf_empty_p
argument_list|(
operator|&
name|buf_to_net
argument_list|)
condition|)
name|FD_SET
argument_list|(
name|STDOUT_FILENO
argument_list|,
operator|&
name|writefds
argument_list|)
expr_stmt|;
if|if
condition|(
name|stdout_pipe
index|[
literal|0
index|]
operator|>=
literal|0
condition|)
block|{
name|FD_SET
argument_list|(
name|stdout_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|readfds
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stderr_pipe
index|[
literal|0
index|]
operator|>=
literal|0
condition|)
block|{
name|FD_SET
argument_list|(
name|stderr_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|readfds
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|protocol_pipe
index|[
literal|0
index|]
operator|>=
literal|0
condition|)
block|{
name|FD_SET
argument_list|(
name|protocol_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|readfds
argument_list|)
expr_stmt|;
block|}
do|do
block|{
comment|/* This used to select on exceptions too, but as far                    as I know there was never any reason to do that and                    SCO doesn't let you select on exceptions on pipes.  */
name|numfds
operator|=
name|select
argument_list|(
name|num_to_check
argument_list|,
operator|&
name|readfds
argument_list|,
operator|&
name|writefds
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|numfds
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
block|}
do|while
condition|(
name|numfds
operator|<
literal|0
condition|)
do|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|STDOUT_FILENO
argument_list|,
operator|&
name|writefds
argument_list|)
condition|)
block|{
comment|/* What should we do with errors?  syslog() them?  */
name|buf_send_output
argument_list|(
operator|&
name|buf_to_net
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stdout_pipe
index|[
literal|0
index|]
operator|>=
literal|0
operator|&&
operator|(
name|FD_ISSET
argument_list|(
name|stdout_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|readfds
argument_list|)
operator|)
condition|)
block|{
name|int
name|status
decl_stmt|;
name|status
operator|=
name|buf_input_data
argument_list|(
operator|&
name|stdoutbuf
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|buf_copy_lines
argument_list|(
operator|&
name|buf_to_net
argument_list|,
operator|&
name|stdoutbuf
argument_list|,
literal|'M'
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
name|stdout_pipe
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|>
literal|0
condition|)
block|{
name|print_error
argument_list|(
name|status
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
comment|/* What should we do with errors?  syslog() them?  */
name|buf_send_output
argument_list|(
operator|&
name|buf_to_net
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stderr_pipe
index|[
literal|0
index|]
operator|>=
literal|0
operator|&&
operator|(
name|FD_ISSET
argument_list|(
name|stderr_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|readfds
argument_list|)
operator|)
condition|)
block|{
name|int
name|status
decl_stmt|;
name|status
operator|=
name|buf_input_data
argument_list|(
operator|&
name|stderrbuf
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|buf_copy_lines
argument_list|(
operator|&
name|buf_to_net
argument_list|,
operator|&
name|stderrbuf
argument_list|,
literal|'E'
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
name|stderr_pipe
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|>
literal|0
condition|)
block|{
name|print_error
argument_list|(
name|status
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
comment|/* What should we do with errors?  syslog() them?  */
name|buf_send_output
argument_list|(
operator|&
name|buf_to_net
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|protocol_pipe
index|[
literal|0
index|]
operator|>=
literal|0
operator|&&
operator|(
name|FD_ISSET
argument_list|(
name|protocol_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|readfds
argument_list|)
operator|)
condition|)
block|{
name|int
name|status
decl_stmt|;
name|int
name|count_read
decl_stmt|;
name|status
operator|=
name|buf_input_data
argument_list|(
operator|&
name|protocol_inbuf
argument_list|,
operator|&
name|count_read
argument_list|)
expr_stmt|;
comment|/* 		 * We only call buf_copy_counted if we have read 		 * enough bytes to make it worthwhile.  This saves us 		 * from continually recounting the amount of data we 		 * have. 		 */
name|count_needed
operator|-=
name|count_read
expr_stmt|;
if|if
condition|(
name|count_needed
operator|<=
literal|0
condition|)
name|count_needed
operator|=
name|buf_copy_counted
argument_list|(
operator|&
name|buf_to_net
argument_list|,
operator|&
name|protocol_inbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
name|protocol_pipe
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|>
literal|0
condition|)
block|{
name|print_error
argument_list|(
name|status
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
comment|/* What should we do with errors?  syslog() them?  */
name|buf_send_output
argument_list|(
operator|&
name|buf_to_net
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * OK, we've gotten EOF on all the pipes.  If there is 	 * anything left on stdoutbuf or stderrbuf (this could only 	 * happen if there was no trailing newline), send it over. 	 */
if|if
condition|(
operator|!
name|buf_empty_p
argument_list|(
operator|&
name|stdoutbuf
argument_list|)
condition|)
block|{
name|buf_append_char
argument_list|(
operator|&
name|stdoutbuf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|buf_copy_lines
argument_list|(
operator|&
name|buf_to_net
argument_list|,
operator|&
name|stdoutbuf
argument_list|,
literal|'M'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|buf_empty_p
argument_list|(
operator|&
name|stderrbuf
argument_list|)
condition|)
block|{
name|buf_append_char
argument_list|(
operator|&
name|stderrbuf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|buf_copy_lines
argument_list|(
operator|&
name|buf_to_net
argument_list|,
operator|&
name|stderrbuf
argument_list|,
literal|'E'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|buf_empty_p
argument_list|(
operator|&
name|protocol_inbuf
argument_list|)
condition|)
name|buf_output0
argument_list|(
operator|&
name|buf_to_net
argument_list|,
literal|"E Protocol error: uncounted data discarded\n"
argument_list|)
expr_stmt|;
name|errs
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|command_pid
operator|>
literal|0
condition|)
block|{
name|int
name|status
decl_stmt|;
name|pid_t
name|waited_pid
decl_stmt|;
name|waited_pid
operator|=
name|waitpid
argument_list|(
name|command_pid
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|waited_pid
operator|<
literal|0
condition|)
block|{
comment|/* 		 * Intentionally ignoring EINTR.  Other errors 		 * "can't happen". 		 */
continue|continue;
block|}
if|if
condition|(
name|WIFEXITED
argument_list|(
name|status
argument_list|)
condition|)
name|errs
operator|+=
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|sig
init|=
name|WTERMSIG
argument_list|(
name|status
argument_list|)
decl_stmt|;
comment|/* 		 * This is really evil, because signals might be numbered 		 * differently on the two systems.  We should be using 		 * signal names (either of the "Terminated" or the "SIGTERM" 		 * variety).  But cvs doesn't currently use libiberty...we 		 * could roll our own....  FIXME. 		 */
name|printf
argument_list|(
literal|"E Terminated with fatal signal %d\n"
argument_list|,
name|sig
argument_list|)
expr_stmt|;
comment|/* Test for a core dump.  Is this portable?  */
if|if
condition|(
name|status
operator|&
literal|0x80
condition|)
block|{
name|printf
argument_list|(
literal|"E Core dumped; preserving %s on server.\n\ E CVS locks may need cleaning up.\n"
argument_list|,
name|server_temp_dir
argument_list|)
expr_stmt|;
name|dont_delete_temp
operator|=
literal|1
expr_stmt|;
block|}
operator|++
name|errs
expr_stmt|;
block|}
if|if
condition|(
name|waited_pid
operator|==
name|command_pid
condition|)
name|command_pid
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 	 * OK, we've waited for the child.  By now all CVS locks are free 	 * and it's OK to block on the network. 	 */
name|set_block
argument_list|(
operator|&
name|buf_to_net
argument_list|)
expr_stmt|;
name|buf_send_output
argument_list|(
operator|&
name|buf_to_net
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errs
condition|)
comment|/* We will have printed an error message already.  */
name|printf
argument_list|(
literal|"error  \n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"ok\n"
argument_list|)
expr_stmt|;
goto|goto
name|free_args_and_return
goto|;
name|error_exit
label|:
if|if
condition|(
name|command_pid
operator|>
literal|0
condition|)
name|kill
argument_list|(
name|command_pid
argument_list|,
name|SIGTERM
argument_list|)
expr_stmt|;
while|while
condition|(
name|command_pid
operator|>
literal|0
condition|)
block|{
name|pid_t
name|waited_pid
decl_stmt|;
name|waited_pid
operator|=
name|waitpid
argument_list|(
name|command_pid
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|waited_pid
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
if|if
condition|(
name|waited_pid
operator|==
name|command_pid
condition|)
name|command_pid
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|close
argument_list|(
name|dev_null_fd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|protocol_pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|protocol_pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|stderr_pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|stderr_pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|stdout_pipe
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|stdout_pipe
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|free_args_and_return
label|:
comment|/* Now free the arguments.  */
block|{
comment|/* argument_vector[0] is a dummy argument, we don't mess with it.  */
name|char
modifier|*
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|argument_vector
operator|+
literal|1
init|;
name|cp
operator|<
name|argument_vector
operator|+
name|argument_count
condition|;
operator|++
name|cp
control|)
name|free
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
name|argument_count
operator|=
literal|1
expr_stmt|;
block|}
return|return;
block|}
end_block

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|SERVER_FLOWCONTROL
end_ifdef

begin_comment
comment|/*  * Called by the child at convenient points in the server's execution for  * the server child to block.. ie: when it has no locks active.  */
end_comment

begin_function
name|void
name|server_pause_check
parameter_list|()
block|{
name|int
name|paused
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
literal|1
index|]
decl_stmt|;
while|while
condition|(
name|read
argument_list|(
name|flowcontrol_pipe
index|[
literal|0
index|]
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|buf
operator|==
literal|'S'
condition|)
comment|/* Stop */
name|paused
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|buf
operator|==
literal|'G'
condition|)
comment|/* Go */
name|paused
operator|=
literal|0
expr_stmt|;
else|else
return|return;
comment|/* ??? */
block|}
while|while
condition|(
name|paused
condition|)
block|{
name|int
name|numfds
decl_stmt|,
name|numtocheck
decl_stmt|;
name|fd_set
name|fds
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|flowcontrol_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fds
argument_list|)
expr_stmt|;
name|numtocheck
operator|=
name|flowcontrol_pipe
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
do|do
block|{
name|numfds
operator|=
name|select
argument_list|(
name|numtocheck
argument_list|,
operator|&
name|fds
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|numfds
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
do|while
condition|(
name|numfds
operator|<
literal|0
condition|)
do|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|flowcontrol_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fds
argument_list|)
condition|)
block|{
while|while
condition|(
name|read
argument_list|(
name|flowcontrol_pipe
index|[
literal|0
index|]
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|buf
operator|==
literal|'S'
condition|)
comment|/* Stop */
name|paused
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|buf
operator|==
literal|'G'
condition|)
comment|/* Go */
name|paused
operator|=
literal|0
expr_stmt|;
else|else
return|return;
comment|/* ??? */
block|}
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SERVER_FLOWCONTROL */
end_comment

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|void
name|output_dir
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|output_dir
parameter_list|(
name|update_dir
parameter_list|,
name|repository
parameter_list|)
name|char
modifier|*
name|update_dir
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
block|{
if|if
condition|(
name|use_dir_and_repos
condition|)
block|{
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
else|else
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
literal|"/\n"
argument_list|)
expr_stmt|;
block|}
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Entries line that we are squirreling away to send to the client when  * we are ready.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|entries_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * File which has been Scratch_File'd, we are squirreling away that fact  * to inform the client when we are ready.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|scratched_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The scratched_file will need to be removed as well as having its entry  * removed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|kill_scratched_file
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|server_register
parameter_list|(
name|name
parameter_list|,
name|version
parameter_list|,
name|timestamp
parameter_list|,
name|options
parameter_list|,
name|tag
parameter_list|,
name|date
parameter_list|,
name|conflict
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|version
decl_stmt|;
name|char
modifier|*
name|timestamp
decl_stmt|;
name|char
modifier|*
name|options
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|date
decl_stmt|;
name|char
modifier|*
name|conflict
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
name|options
operator|==
name|NULL
condition|)
name|options
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|trace
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%c-> server_register(%s, %s, %s, %s, %s, %s, %s)\n"
argument_list|,
operator|(
name|server_active
operator|)
condition|?
literal|'S'
else|:
literal|' '
argument_list|,
comment|/* silly */
name|name
argument_list|,
name|version
argument_list|,
name|timestamp
argument_list|,
name|options
argument_list|,
name|tag
condition|?
name|tag
else|:
literal|""
argument_list|,
name|date
condition|?
name|date
else|:
literal|""
argument_list|,
name|conflict
condition|?
name|conflict
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|entries_line
operator|!=
name|NULL
condition|)
block|{
comment|/* 	 * If CVS decides to Register it more than once (which happens 	 * on "cvs update foo/foo.c" where foo and foo.c are already 	 * checked out), use the last of the entries lines Register'd. 	 */
name|free
argument_list|(
name|entries_line
argument_list|)
expr_stmt|;
block|}
comment|/*      * I have reports of Scratch_Entry and Register both happening, in      * two different cases.  Using the last one which happens is almost      * surely correct; I haven't tracked down why they both happen (or      * even verified that they are for the same file).      */
if|if
condition|(
name|scratched_file
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|scratched_file
argument_list|)
expr_stmt|;
name|scratched_file
operator|=
name|NULL
expr_stmt|;
block|}
name|len
operator|=
operator|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|version
argument_list|)
operator|+
name|strlen
argument_list|(
name|options
argument_list|)
operator|+
literal|80
operator|)
expr_stmt|;
if|if
condition|(
name|tag
condition|)
name|len
operator|+=
name|strlen
argument_list|(
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|date
condition|)
name|len
operator|+=
name|strlen
argument_list|(
name|date
argument_list|)
expr_stmt|;
name|entries_line
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|entries_line
argument_list|,
literal|"/%s/%s/"
argument_list|,
name|name
argument_list|,
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|conflict
operator|!=
name|NULL
condition|)
block|{
name|strcat
argument_list|(
name|entries_line
argument_list|,
literal|"+="
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|entries_line
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|entries_line
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|entries_line
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|!=
name|NULL
condition|)
block|{
name|strcat
argument_list|(
name|entries_line
argument_list|,
literal|"T"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|entries_line
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|date
operator|!=
name|NULL
condition|)
block|{
name|strcat
argument_list|(
name|entries_line
argument_list|,
literal|"D"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|entries_line
argument_list|,
name|date
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|server_scratch
parameter_list|(
name|fname
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
block|{
comment|/*      * I have reports of Scratch_Entry and Register both happening, in      * two different cases.  Using the last one which happens is almost      * surely correct; I haven't tracked down why they both happen (or      * even verified that they are for the same file).      */
if|if
condition|(
name|entries_line
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|entries_line
argument_list|)
expr_stmt|;
name|entries_line
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|scratched_file
operator|!=
name|NULL
condition|)
block|{
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
literal|"E CVS server internal error: duplicate Scratch_Entry\n"
argument_list|)
expr_stmt|;
name|buf_send_counted
argument_list|(
operator|&
name|protocol
argument_list|)
expr_stmt|;
return|return;
block|}
name|scratched_file
operator|=
name|xstrdup
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|kill_scratched_file
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|server_scratch_entry_only
parameter_list|()
block|{
name|kill_scratched_file
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a new entries line, from a previous server_register.  */
end_comment

begin_function
specifier|static
name|void
name|new_entries_line
parameter_list|()
block|{
if|if
condition|(
name|entries_line
condition|)
block|{
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
name|entries_line
argument_list|)
expr_stmt|;
name|buf_output
argument_list|(
operator|&
name|protocol
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Return the error message as the Entries line.  */
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
literal|"CVS server internal error: Register missing\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entries_line
argument_list|)
expr_stmt|;
name|entries_line
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|serve_ci
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
name|commit
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|checked_in_response
parameter_list|(
name|file
parameter_list|,
name|update_dir
parameter_list|,
name|repository
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
block|{
if|if
condition|(
name|supported_response
argument_list|(
literal|"Mode"
argument_list|)
condition|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|char
modifier|*
name|mode_string
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Not clear to me why the file would fail to exist, but it 	       was happening somewhere in the testsuite.  */
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot stat %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
literal|"Mode "
argument_list|)
expr_stmt|;
name|mode_string
operator|=
name|mode_to_string
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
name|mode_string
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mode_string
argument_list|)
expr_stmt|;
block|}
block|}
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
literal|"Checked-in "
argument_list|)
expr_stmt|;
name|output_dir
argument_list|(
name|update_dir
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|buf_output
argument_list|(
operator|&
name|protocol
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|new_entries_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|server_checked_in
parameter_list|(
name|file
parameter_list|,
name|update_dir
parameter_list|,
name|repository
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
block|{
if|if
condition|(
name|noexec
condition|)
return|return;
if|if
condition|(
name|scratched_file
operator|!=
name|NULL
operator|&&
name|entries_line
operator|==
name|NULL
condition|)
block|{
comment|/* 	 * This happens if we are now doing a "cvs remove" after a previous 	 * "cvs add" (without a "cvs ci" in between). 	 */
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
literal|"Remove-entry "
argument_list|)
expr_stmt|;
name|output_dir
argument_list|(
name|update_dir
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|buf_output
argument_list|(
operator|&
name|protocol
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|scratched_file
argument_list|)
expr_stmt|;
name|scratched_file
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|checked_in_response
argument_list|(
name|file
argument_list|,
name|update_dir
argument_list|,
name|repository
argument_list|)
expr_stmt|;
block|}
name|buf_send_counted
argument_list|(
operator|&
name|protocol
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|server_update_entries
parameter_list|(
name|file
parameter_list|,
name|update_dir
parameter_list|,
name|repository
parameter_list|,
name|updated
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|enum
name|server_updated_arg4
name|updated
decl_stmt|;
block|{
if|if
condition|(
name|noexec
condition|)
return|return;
if|if
condition|(
name|updated
operator|==
name|SERVER_UPDATED
condition|)
name|checked_in_response
argument_list|(
name|file
argument_list|,
name|update_dir
argument_list|,
name|repository
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|supported_response
argument_list|(
literal|"New-entry"
argument_list|)
condition|)
return|return;
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
literal|"New-entry "
argument_list|)
expr_stmt|;
name|output_dir
argument_list|(
name|update_dir
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|buf_output
argument_list|(
operator|&
name|protocol
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|new_entries_line
argument_list|()
expr_stmt|;
block|}
name|buf_send_counted
argument_list|(
operator|&
name|protocol
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|serve_update
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
name|update
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_diff
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
name|diff
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_log
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
name|cvslog
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_add
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
name|add
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_remove
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
name|cvsremove
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_status
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_rdiff
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
name|patch
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_tag
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_rtag
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
name|rtag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_import
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
name|import
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_admin
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
name|admin
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_history
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
name|history
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_release
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
name|release
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|serve_watch_on
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_watch_on
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
name|watch_on
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|serve_watch_off
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_watch_off
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
name|watch_off
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|serve_watch_add
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_watch_add
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
name|watch_add
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|serve_watch_remove
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_watch_remove
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
name|watch_remove
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|serve_watchers
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_watchers
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
name|watchers
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|serve_editors
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_editors
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
name|editors
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|noop
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|noop
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|serve_noop
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_noop
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
name|noop
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|serve_init
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_init
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|CVSroot
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVSroot
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|ENOMEM
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|CVSroot
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|do_cvs_command
argument_list|(
name|init
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|serve_annotate
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serve_annotate
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|do_cvs_command
argument_list|(
name|annotate
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|serve_co
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|char
modifier|*
name|tempdir
decl_stmt|;
name|int
name|status
decl_stmt|;
if|if
condition|(
name|print_pending_error
argument_list|()
condition|)
return|return;
if|if
condition|(
operator|!
name|isdir
argument_list|(
name|CVSADM
argument_list|)
condition|)
block|{
comment|/* 	 * The client has not sent a "Repository" line.  Check out 	 * into a pristine directory. 	 */
name|tempdir
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|server_temp_dir
argument_list|)
operator|+
literal|80
argument_list|)
expr_stmt|;
if|if
condition|(
name|tempdir
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"E Out of memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|tempdir
argument_list|,
name|server_temp_dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tempdir
argument_list|,
literal|"/checkout-dir"
argument_list|)
expr_stmt|;
name|status
operator|=
name|mkdir_p
argument_list|(
name|tempdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
operator|&&
name|status
operator|!=
name|EEXIST
condition|)
block|{
name|printf
argument_list|(
literal|"E Cannot create %s\n"
argument_list|,
name|tempdir
argument_list|)
expr_stmt|;
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tempdir
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|chdir
argument_list|(
name|tempdir
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"E Cannot change to directory %s\n"
argument_list|,
name|tempdir
argument_list|)
expr_stmt|;
name|print_error
argument_list|(
name|errno
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tempdir
argument_list|)
expr_stmt|;
return|return;
block|}
name|free
argument_list|(
name|tempdir
argument_list|)
expr_stmt|;
block|}
name|do_cvs_command
argument_list|(
name|checkout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_export
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
comment|/* Tell checkout() to behave like export not checkout.  */
name|command_name
operator|=
literal|"export"
expr_stmt|;
name|serve_co
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|server_copy_file
parameter_list|(
name|file
parameter_list|,
name|update_dir
parameter_list|,
name|repository
parameter_list|,
name|newfile
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|newfile
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|supported_response
argument_list|(
literal|"Copy-file"
argument_list|)
condition|)
return|return;
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
literal|"Copy-file "
argument_list|)
expr_stmt|;
name|output_dir
argument_list|(
name|update_dir
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
name|newfile
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|server_updated
parameter_list|(
name|file
parameter_list|,
name|update_dir
parameter_list|,
name|repository
parameter_list|,
name|updated
parameter_list|,
name|file_info
parameter_list|,
name|checksum
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|update_dir
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|enum
name|server_updated_arg4
name|updated
decl_stmt|;
name|struct
name|stat
modifier|*
name|file_info
decl_stmt|;
name|unsigned
name|char
modifier|*
name|checksum
decl_stmt|;
block|{
name|char
modifier|*
name|short_pathname
decl_stmt|;
if|if
condition|(
name|noexec
condition|)
return|return;
name|short_pathname
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|update_dir
argument_list|)
operator|+
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|strcpy
argument_list|(
name|short_pathname
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|short_pathname
argument_list|,
literal|"%s/%s"
argument_list|,
name|update_dir
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|entries_line
operator|!=
name|NULL
operator|&&
name|scratched_file
operator|==
name|NULL
condition|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|struct
name|buffer_data
modifier|*
name|list
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|char
name|size_text
index|[
literal|80
index|]
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
block|{
comment|/* 		 * If we have a sticky tag for a branch on which the 		 * file is dead, and cvs update the directory, it gets 		 * a T_CHECKOUT but no file.  So in this case just 		 * forget the whole thing. 		 */
name|free
argument_list|(
name|entries_line
argument_list|)
expr_stmt|;
name|entries_line
operator|=
name|NULL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"reading %s"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|checksum
operator|!=
name|NULL
condition|)
block|{
specifier|static
name|int
name|checksum_supported
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|checksum_supported
operator|==
operator|-
literal|1
condition|)
block|{
name|checksum_supported
operator|=
name|supported_response
argument_list|(
literal|"Checksum"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|checksum_supported
condition|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|3
index|]
decl_stmt|;
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
literal|"Checksum "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%02x"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|checksum
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|buf_append_char
argument_list|(
operator|&
name|protocol
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|updated
operator|==
name|SERVER_UPDATED
condition|)
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
literal|"Updated "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|updated
operator|==
name|SERVER_MERGED
condition|)
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
literal|"Merged "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|updated
operator|==
name|SERVER_PATCHED
condition|)
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
literal|"Patched "
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|output_dir
argument_list|(
name|update_dir
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|buf_output
argument_list|(
operator|&
name|protocol
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|new_entries_line
argument_list|()
expr_stmt|;
block|{
name|char
modifier|*
name|mode_string
decl_stmt|;
comment|/* FIXME: When we check out files the umask of the server 	       (set in .bashrc if rsh is in use, or set in main.c in 	       the kerberos case, I think) affects what mode we send, 	       and it shouldn't.  */
if|if
condition|(
name|file_info
operator|!=
name|NULL
condition|)
name|mode_string
operator|=
name|mode_to_string
argument_list|(
name|file_info
operator|->
name|st_mode
argument_list|)
expr_stmt|;
else|else
name|mode_string
operator|=
name|mode_to_string
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
name|mode_string
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mode_string
argument_list|)
expr_stmt|;
block|}
name|list
operator|=
name|last
operator|=
name|NULL
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sb
operator|.
name|st_size
operator|>
literal|0
condition|)
block|{
comment|/* Throughout this section we use binary mode to read the 	       file we are sending.  The client handles any line ending 	       translation if necessary.  */
if|if
condition|(
name|gzip_level
comment|/* 		 * For really tiny files, the gzip process startup 		 * time will outweigh the compression savings.  This 		 * might be computable somehow; using 100 here is just 		 * a first approximation. 		 */
operator|&&
name|sb
operator|.
name|st_size
operator|>
literal|100
condition|)
block|{
name|int
name|status
decl_stmt|,
name|fd
decl_stmt|,
name|gzip_status
decl_stmt|;
name|pid_t
name|gzip_pid
decl_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|file
argument_list|,
name|O_RDONLY
operator||
name|OPEN_BINARY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"reading %s"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
name|fd
operator|=
name|filter_through_gzip
argument_list|(
name|fd
argument_list|,
literal|1
argument_list|,
name|gzip_level
argument_list|,
operator|&
name|gzip_pid
argument_list|)
expr_stmt|;
name|f
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
name|status
operator|=
name|buf_read_file_to_eof
argument_list|(
name|f
argument_list|,
operator|&
name|list
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
name|size
operator|=
name|buf_chain_length
argument_list|(
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
operator|-
literal|2
condition|)
call|(
modifier|*
name|protocol
operator|.
name|memory_error
call|)
argument_list|(
operator|&
name|protocol
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|ferror
argument_list|(
name|f
argument_list|)
condition|?
name|errno
else|:
literal|0
argument_list|,
literal|"reading %s"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"reading %s"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|waitpid
argument_list|(
name|gzip_pid
argument_list|,
operator|&
name|gzip_status
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"waiting for gzip process %ld"
argument_list|,
operator|(
name|long
operator|)
name|gzip_pid
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|gzip_status
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"gzip exited %d"
argument_list|,
name|gzip_status
argument_list|)
expr_stmt|;
comment|/* Prepending length with "z" is flag for using gzip here.  */
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
literal|"z"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|long
name|status
decl_stmt|;
name|size
operator|=
name|sb
operator|.
name|st_size
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"reading %s"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
name|status
operator|=
name|buf_read_file
argument_list|(
name|f
argument_list|,
name|sb
operator|.
name|st_size
argument_list|,
operator|&
name|list
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
operator|-
literal|2
condition|)
call|(
modifier|*
name|protocol
operator|.
name|memory_error
call|)
argument_list|(
operator|&
name|protocol
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|ferror
argument_list|(
name|f
argument_list|)
condition|?
name|errno
else|:
literal|0
argument_list|,
literal|"reading %s"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"reading %s"
argument_list|,
name|short_pathname
argument_list|)
expr_stmt|;
block|}
block|}
name|sprintf
argument_list|(
name|size_text
argument_list|,
literal|"%lu\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
name|size_text
argument_list|)
expr_stmt|;
name|buf_append_data
argument_list|(
operator|&
name|protocol
argument_list|,
name|list
argument_list|,
name|last
argument_list|)
expr_stmt|;
comment|/* Note we only send a newline here if the file ended with one.  */
comment|/* 	 * Avoid using up too much disk space for temporary files. 	 * A file which does not exist indicates that the file is up-to-date, 	 * which is now the case.  If this is SERVER_MERGED, the file is 	 * not up-to-date, and we indicate that by leaving the file there. 	 * I'm thinking of cases like "cvs update foo/foo.c foo". 	 */
if|if
condition|(
operator|(
name|updated
operator|==
name|SERVER_UPDATED
operator|||
name|updated
operator|==
name|SERVER_PATCHED
operator|)
comment|/* But if we are joining, we'll need the file when we call 	       join_file.  */
operator|&&
operator|!
name|joining
argument_list|()
condition|)
name|unlink
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scratched_file
operator|!=
name|NULL
operator|&&
name|entries_line
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|scratched_file
argument_list|,
name|file
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"CVS server internal error: `%s' vs. `%s' scratched"
argument_list|,
name|scratched_file
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|scratched_file
argument_list|)
expr_stmt|;
name|scratched_file
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|kill_scratched_file
condition|)
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
literal|"Removed "
argument_list|)
expr_stmt|;
else|else
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
literal|"Remove-entry "
argument_list|)
expr_stmt|;
name|output_dir
argument_list|(
name|update_dir
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|buf_output
argument_list|(
operator|&
name|protocol
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scratched_file
operator|==
name|NULL
operator|&&
name|entries_line
operator|==
name|NULL
condition|)
block|{
comment|/* 	 * This can happen with death support if we were processing 	 * a dead file in a checkout. 	 */
block|}
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"CVS server internal error: Register *and* Scratch_Entry.\n"
argument_list|)
expr_stmt|;
name|buf_send_counted
argument_list|(
operator|&
name|protocol
argument_list|)
expr_stmt|;
name|done
label|:
name|free
argument_list|(
name|short_pathname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|server_set_entstat
parameter_list|(
name|update_dir
parameter_list|,
name|repository
parameter_list|)
name|char
modifier|*
name|update_dir
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
block|{
specifier|static
name|int
name|set_static_supported
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|set_static_supported
operator|==
operator|-
literal|1
condition|)
name|set_static_supported
operator|=
name|supported_response
argument_list|(
literal|"Set-static-directory"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set_static_supported
condition|)
return|return;
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
literal|"Set-static-directory "
argument_list|)
expr_stmt|;
name|output_dir
argument_list|(
name|update_dir
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|buf_send_counted
argument_list|(
operator|&
name|protocol
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|server_clear_entstat
parameter_list|(
name|update_dir
parameter_list|,
name|repository
parameter_list|)
name|char
modifier|*
name|update_dir
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
block|{
specifier|static
name|int
name|clear_static_supported
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|clear_static_supported
operator|==
operator|-
literal|1
condition|)
name|clear_static_supported
operator|=
name|supported_response
argument_list|(
literal|"Clear-static-directory"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|clear_static_supported
condition|)
return|return;
if|if
condition|(
name|noexec
condition|)
return|return;
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
literal|"Clear-static-directory "
argument_list|)
expr_stmt|;
name|output_dir
argument_list|(
name|update_dir
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|buf_send_counted
argument_list|(
operator|&
name|protocol
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|server_set_sticky
parameter_list|(
name|update_dir
parameter_list|,
name|repository
parameter_list|,
name|tag
parameter_list|,
name|date
parameter_list|)
name|char
modifier|*
name|update_dir
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|date
decl_stmt|;
block|{
specifier|static
name|int
name|set_sticky_supported
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|set_sticky_supported
operator|==
operator|-
literal|1
condition|)
name|set_sticky_supported
operator|=
name|supported_response
argument_list|(
literal|"Set-sticky"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set_sticky_supported
condition|)
return|return;
if|if
condition|(
name|noexec
condition|)
return|return;
if|if
condition|(
name|tag
operator|==
name|NULL
operator|&&
name|date
operator|==
name|NULL
condition|)
block|{
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
literal|"Clear-sticky "
argument_list|)
expr_stmt|;
name|output_dir
argument_list|(
name|update_dir
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
literal|"Set-sticky "
argument_list|)
expr_stmt|;
name|output_dir
argument_list|(
name|update_dir
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|!=
name|NULL
condition|)
block|{
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
literal|"T"
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
literal|"D"
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
name|date
argument_list|)
expr_stmt|;
block|}
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|buf_send_counted
argument_list|(
operator|&
name|protocol
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|template_proc_data
block|{
name|char
modifier|*
name|update_dir
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Here as a static until we get around to fixing Parse_Info to pass along    a void * for it.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|template_proc_data
modifier|*
name|tpd
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|template_proc
parameter_list|(
name|repository
parameter_list|,
name|template
parameter_list|)
name|char
modifier|*
name|repository
decl_stmt|;
name|char
modifier|*
name|template
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|struct
name|template_proc_data
modifier|*
name|data
init|=
name|tpd
decl_stmt|;
if|if
condition|(
operator|!
name|supported_response
argument_list|(
literal|"Template"
argument_list|)
condition|)
comment|/* Might want to warn the user that the rcsinfo feature won't work.  */
return|return
literal|0
return|;
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
literal|"Template "
argument_list|)
expr_stmt|;
name|output_dir
argument_list|(
name|data
operator|->
name|update_dir
argument_list|,
name|data
operator|->
name|repository
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|template
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"Couldn't open rcsinfo template file %s"
argument_list|,
name|template
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot stat rcsinfo template file %s"
argument_list|,
name|template
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|sb
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|buf_output0
argument_list|(
operator|&
name|protocol
argument_list|,
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|n
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|buf_output
argument_list|(
operator|&
name|protocol
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read rcsinfo template file %s"
argument_list|,
name|template
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close rcsinfo template file %s"
argument_list|,
name|template
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|server_template
parameter_list|(
name|update_dir
parameter_list|,
name|repository
parameter_list|)
name|char
modifier|*
name|update_dir
decl_stmt|;
name|char
modifier|*
name|repository
decl_stmt|;
block|{
name|struct
name|template_proc_data
name|data
decl_stmt|;
name|data
operator|.
name|update_dir
operator|=
name|update_dir
expr_stmt|;
name|data
operator|.
name|repository
operator|=
name|repository
expr_stmt|;
name|tpd
operator|=
operator|&
name|data
expr_stmt|;
operator|(
name|void
operator|)
name|Parse_Info
argument_list|(
name|CVSROOTADM_RCSINFO
argument_list|,
name|repository
argument_list|,
name|template_proc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|serve_gzip_contents
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|int
name|level
decl_stmt|;
name|level
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|==
literal|0
condition|)
name|level
operator|=
literal|6
expr_stmt|;
name|gzip_level
operator|=
name|level
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|serve_ignore
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
comment|/*      * Just ignore this command.  This is used to support the      * update-patches command, which is not a real command, but a signal      * to the client that update will accept the -u argument.      */
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|expand_proc
parameter_list|(
name|pargc
parameter_list|,
name|argv
parameter_list|,
name|where
parameter_list|,
name|mwhere
parameter_list|,
name|mfile
parameter_list|,
name|shorten
parameter_list|,
name|local_specified
parameter_list|,
name|omodule
parameter_list|,
name|msg
parameter_list|)
name|int
modifier|*
name|pargc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|where
decl_stmt|;
name|char
modifier|*
name|mwhere
decl_stmt|;
name|char
modifier|*
name|mfile
decl_stmt|;
name|int
name|shorten
decl_stmt|;
name|int
name|local_specified
decl_stmt|;
name|char
modifier|*
name|omodule
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|dir
init|=
name|argv
index|[
literal|0
index|]
decl_stmt|;
comment|/* If mwhere has been specified, the thing we're expanding is a        module -- just return its name so the client will ask for the        right thing later.  If it is an alias or a real directory,        mwhere will not be set, so send out the appropriate        expansion. */
if|if
condition|(
name|mwhere
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Module-expansion %s"
argument_list|,
name|mwhere
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfile
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"/%s"
argument_list|,
name|mfile
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We may not need to do this anymore -- check the definition            of aliases before removing */
if|if
condition|(
operator|*
name|pargc
operator|==
literal|1
condition|)
name|printf
argument_list|(
literal|"Module-expansion %s\n"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
operator|*
name|pargc
condition|;
operator|++
name|i
control|)
name|printf
argument_list|(
literal|"Module-expansion %s/%s\n"
argument_list|,
name|dir
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_expand_modules
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|err
decl_stmt|;
name|DBM
modifier|*
name|db
decl_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
comment|/*      * FIXME: error handling is bogus; do_module can write to stdout and/or      * stderr and we're not using do_cvs_command.      */
name|server_expanding
operator|=
literal|1
expr_stmt|;
name|db
operator|=
name|open_module
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argument_count
condition|;
name|i
operator|++
control|)
name|err
operator|+=
name|do_module
argument_list|(
name|db
argument_list|,
name|argument_vector
index|[
name|i
index|]
argument_list|,
name|CHECKOUT
argument_list|,
literal|"Updating"
argument_list|,
name|expand_proc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|close_module
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|server_expanding
operator|=
literal|0
expr_stmt|;
block|{
comment|/* argument_vector[0] is a dummy argument, we don't mess with it.  */
name|char
modifier|*
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|argument_vector
operator|+
literal|1
init|;
name|cp
operator|<
name|argument_vector
operator|+
name|argument_count
condition|;
operator|++
name|cp
control|)
name|free
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
name|argument_count
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
comment|/* We will have printed an error message already.  */
name|printf
argument_list|(
literal|"error  \n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"ok\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|server_prog
parameter_list|(
name|dir
parameter_list|,
name|name
parameter_list|,
name|which
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|enum
name|progs
name|which
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|supported_response
argument_list|(
literal|"Set-checkin-prog"
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"E \ warning: this client does not support -i or -u flags in the modules file.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|PROG_CHECKIN
case|:
name|printf
argument_list|(
literal|"Set-checkin-prog "
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROG_UPDATE
case|:
name|printf
argument_list|(
literal|"Set-update-prog "
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"%s\n%s\n"
argument_list|,
name|dir
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serve_checkin_prog
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|CVSADM_CIPROG
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|CVSADM_CIPROG
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot open %s"
argument_list|,
name|CVSADM_CIPROG
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s\n"
argument_list|,
name|arg
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|CVSADM_CIPROG
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot write to %s"
argument_list|,
name|CVSADM_CIPROG
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|CVSADM_CIPROG
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot close %s"
argument_list|,
name|CVSADM_CIPROG
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|serve_update_prog
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|CVSADM_UPROG
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|CVSADM_UPROG
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot open %s"
argument_list|,
name|CVSADM_UPROG
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s\n"
argument_list|,
name|arg
argument_list|)
operator|<
literal|0
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|CVSADM_UPROG
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot write to %s"
argument_list|,
name|CVSADM_UPROG
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|pending_error
operator|=
name|errno
expr_stmt|;
name|pending_error_text
operator|=
name|malloc
argument_list|(
literal|80
operator|+
name|strlen
argument_list|(
name|CVSADM_UPROG
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|pending_error_text
argument_list|,
literal|"E cannot close %s"
argument_list|,
name|CVSADM_UPROG
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|void
name|serve_valid_requests
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|arg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SERVER_SUPPORT */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SERVER_SUPPORT
argument_list|)
operator|||
name|defined
argument_list|(
name|CLIENT_SUPPORT
argument_list|)
end_if

begin_comment
comment|/*  * Parts of this table are shared with the client code,  * but the client doesn't need to know about the handler  * functions.  */
end_comment

begin_decl_stmt
name|struct
name|request
name|requests
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
define|#
directive|define
name|REQ_LINE
parameter_list|(
name|n
parameter_list|,
name|f
parameter_list|,
name|s
parameter_list|)
value|{n, f, s}
else|#
directive|else
define|#
directive|define
name|REQ_LINE
parameter_list|(
name|n
parameter_list|,
name|f
parameter_list|,
name|s
parameter_list|)
value|{n, s}
endif|#
directive|endif
name|REQ_LINE
argument_list|(
literal|"Root"
argument_list|,
name|serve_root
argument_list|,
name|rq_essential
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Valid-responses"
argument_list|,
name|serve_valid_responses
argument_list|,
name|rq_essential
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"valid-requests"
argument_list|,
name|serve_valid_requests
argument_list|,
name|rq_essential
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Repository"
argument_list|,
name|serve_repository
argument_list|,
name|rq_essential
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Directory"
argument_list|,
name|serve_directory
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Max-dotdot"
argument_list|,
name|serve_max_dotdot
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Static-directory"
argument_list|,
name|serve_static_directory
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Sticky"
argument_list|,
name|serve_sticky
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Checkin-prog"
argument_list|,
name|serve_checkin_prog
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Update-prog"
argument_list|,
name|serve_update_prog
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Entry"
argument_list|,
name|serve_entry
argument_list|,
name|rq_essential
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Modified"
argument_list|,
name|serve_modified
argument_list|,
name|rq_essential
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Lost"
argument_list|,
name|serve_lost
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"UseUnchanged"
argument_list|,
name|serve_enable_unchanged
argument_list|,
name|rq_enableme
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Unchanged"
argument_list|,
name|serve_unchanged
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Notify"
argument_list|,
name|serve_notify
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Questionable"
argument_list|,
name|serve_questionable
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Case"
argument_list|,
name|serve_case
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Argument"
argument_list|,
name|serve_argument
argument_list|,
name|rq_essential
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Argumentx"
argument_list|,
name|serve_argumentx
argument_list|,
name|rq_essential
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Global_option"
argument_list|,
name|serve_global_option
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"Set"
argument_list|,
name|serve_set
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"expand-modules"
argument_list|,
name|serve_expand_modules
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"ci"
argument_list|,
name|serve_ci
argument_list|,
name|rq_essential
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"co"
argument_list|,
name|serve_co
argument_list|,
name|rq_essential
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"update"
argument_list|,
name|serve_update
argument_list|,
name|rq_essential
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"diff"
argument_list|,
name|serve_diff
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"log"
argument_list|,
name|serve_log
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"add"
argument_list|,
name|serve_add
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"remove"
argument_list|,
name|serve_remove
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"update-patches"
argument_list|,
name|serve_ignore
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"gzip-file-contents"
argument_list|,
name|serve_gzip_contents
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"status"
argument_list|,
name|serve_status
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"rdiff"
argument_list|,
name|serve_rdiff
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"tag"
argument_list|,
name|serve_tag
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"rtag"
argument_list|,
name|serve_rtag
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"import"
argument_list|,
name|serve_import
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"admin"
argument_list|,
name|serve_admin
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"export"
argument_list|,
name|serve_export
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"history"
argument_list|,
name|serve_history
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"release"
argument_list|,
name|serve_release
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"watch-on"
argument_list|,
name|serve_watch_on
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"watch-off"
argument_list|,
name|serve_watch_off
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"watch-add"
argument_list|,
name|serve_watch_add
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"watch-remove"
argument_list|,
name|serve_watch_remove
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"watchers"
argument_list|,
name|serve_watchers
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"editors"
argument_list|,
name|serve_editors
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"init"
argument_list|,
name|serve_init
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"annotate"
argument_list|,
name|serve_annotate
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
literal|"noop"
argument_list|,
name|serve_noop
argument_list|,
name|rq_optional
argument_list|)
block|,
name|REQ_LINE
argument_list|(
argument|NULL
argument_list|,
argument|NULL
argument_list|,
argument|rq_optional
argument_list|)
undef|#
directive|undef
name|REQ_LINE
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SERVER_SUPPORT or CLIENT_SUPPORT */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
end_ifdef

begin_function
specifier|static
name|void
name|serve_valid_requests
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|request
modifier|*
name|rq
decl_stmt|;
if|if
condition|(
name|print_pending_error
argument_list|()
condition|)
return|return;
name|printf
argument_list|(
literal|"Valid-requests"
argument_list|)
expr_stmt|;
for|for
control|(
name|rq
operator|=
name|requests
init|;
name|rq
operator|->
name|name
operator|!=
name|NULL
condition|;
name|rq
operator|++
control|)
if|if
condition|(
name|rq
operator|->
name|func
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|rq
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nok\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|sun
end_ifdef

begin_comment
comment|/*  * Delete temporary files.  SIG is the signal making this happen, or  * 0 if not called as a result of a signal.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|command_pid_is_dead
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|wait_sig
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|pid_t
name|r
init|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|command_pid
condition|)
name|command_pid_is_dead
operator|++
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|server_cleanup
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
comment|/* Do "rm -rf" on the temp directory.  */
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
name|char
modifier|*
name|temp_dir
decl_stmt|;
if|if
condition|(
name|dont_delete_temp
condition|)
return|return;
comment|/* What a bogus kludge.  This disgusting code makes all kinds of        assumptions about SunOS, and is only for a bug in that system.        So only enable it on Suns.  */
ifdef|#
directive|ifdef
name|sun
if|if
condition|(
name|command_pid
operator|>
literal|0
condition|)
block|{
comment|/* To avoid crashes on SunOS due to bugs in SunOS tmpfs 	 triggered by the use of rename() in RCS, wait for the 	 subprocess to die.  Unfortunately, this means draining output 	 while waiting for it to unblock the signal we sent it.  Yuck!  */
name|int
name|status
decl_stmt|;
name|pid_t
name|r
decl_stmt|;
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|wait_sig
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig
condition|)
comment|/* Perhaps SIGTERM would be more correct.  But the child 	   process will delay the SIGINT delivery until its own 	   children have exited.  */
name|kill
argument_list|(
name|command_pid
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
comment|/* The caller may also have sent a signal to command_pid, so 	 always try waiting.  First, though, check and see if it's still 	 there....  */
name|do_waitpid
label|:
name|r
operator|=
name|waitpid
argument_list|(
name|command_pid
argument_list|,
operator|&
name|status
argument_list|,
name|WNOHANG
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|r
operator|==
name|command_pid
condition|)
name|command_pid_is_dead
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ECHILD
case|:
name|command_pid_is_dead
operator|++
expr_stmt|;
break|break;
case|case
name|EINTR
case|:
goto|goto
name|do_waitpid
goto|;
block|}
else|else
comment|/* waitpid should always return one of the above values */
name|abort
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|command_pid_is_dead
condition|)
block|{
name|struct
name|timeval
name|timeout
decl_stmt|;
name|struct
name|fd_set_wrapper
name|readfds
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Use a non-zero timeout to avoid eating up CPU cycles.  */
name|timeout
operator|.
name|tv_sec
operator|=
literal|2
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|readfds
operator|=
name|command_fds_to_drain
expr_stmt|;
switch|switch
condition|(
name|select
argument_list|(
name|max_command_fd
operator|+
literal|1
argument_list|,
operator|&
name|readfds
operator|.
name|fds
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|timeout
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
name|abort
argument_list|()
expr_stmt|;
case|case
literal|0
case|:
comment|/* timeout */
break|break;
case|case
literal|1
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|max_command_fd
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|FD_ISSET
argument_list|(
name|i
argument_list|,
operator|&
name|readfds
operator|.
name|fds
argument_list|)
condition|)
continue|continue;
comment|/* this fd is non-blocking */
while|while
condition|(
name|read
argument_list|(
name|i
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|>=
literal|1
condition|)
empty_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* This might be set by the user in ~/.bashrc, ~/.cshrc, etc.  */
name|temp_dir
operator|=
name|getenv
argument_list|(
literal|"TMPDIR"
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_dir
operator|==
name|NULL
operator|||
name|temp_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|temp_dir
operator|=
literal|"/tmp"
expr_stmt|;
name|chdir
argument_list|(
name|temp_dir
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|server_temp_dir
argument_list|)
operator|+
literal|80
expr_stmt|;
name|cmd
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"E Cannot delete %s on server; out of memory\n"
argument_list|,
name|server_temp_dir
argument_list|)
expr_stmt|;
return|return;
block|}
name|sprintf
argument_list|(
name|cmd
argument_list|,
literal|"rm -rf %s"
argument_list|,
name|server_temp_dir
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|server_active
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|server_expanding
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|server
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
if|if
condition|(
name|argc
operator|==
operator|-
literal|1
condition|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|msg
index|[]
init|=
block|{
literal|"Usage: %s %s\n"
block|,
literal|"  Normally invoked by a cvs client on a remote machine.\n"
block|,
name|NULL
block|}
decl_stmt|;
name|usage
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
comment|/* Ignore argc and argv.  They might be from .cvsrc.  */
comment|/* Since we're in the server parent process, error should use the        protocol to report error messages.  */
name|error_use_protocol
operator|=
literal|1
expr_stmt|;
comment|/*      * Put Rcsbin at the start of PATH, so that rcs programs can find      * themselves.      */
ifdef|#
directive|ifdef
name|HAVE_PUTENV
if|if
condition|(
name|Rcsbin
operator|!=
name|NULL
operator|&&
operator|*
name|Rcsbin
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|env
decl_stmt|;
name|p
operator|=
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|env
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|Rcsbin
argument_list|)
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
sizeof|sizeof
expr|"PATH=:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
operator|!=
name|NULL
condition|)
name|sprintf
argument_list|(
name|env
argument_list|,
literal|"PATH=%s:%s"
argument_list|,
name|Rcsbin
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|env
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|Rcsbin
argument_list|)
operator|+
sizeof|sizeof
expr|"PATH="
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
operator|!=
name|NULL
condition|)
name|sprintf
argument_list|(
name|env
argument_list|,
literal|"PATH=%s"
argument_list|,
name|Rcsbin
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|env
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"E Fatal server error, aborting.\n\ error ENOMEM Virtual memory exhausted.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|putenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* OK, now figure out where we stash our temporary files.  */
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* This might be set by the user in ~/.bashrc, ~/.cshrc, etc.  */
name|char
modifier|*
name|temp_dir
init|=
name|getenv
argument_list|(
literal|"TMPDIR"
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp_dir
operator|==
name|NULL
operator|||
name|temp_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|temp_dir
operator|=
literal|"/tmp"
expr_stmt|;
name|server_temp_dir
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|temp_dir
argument_list|)
operator|+
literal|80
argument_list|)
expr_stmt|;
if|if
condition|(
name|server_temp_dir
operator|==
name|NULL
condition|)
block|{
comment|/* 	     * Strictly speaking, we're not supposed to output anything 	     * now.  But we're about to exit(), give it a try. 	     */
name|printf
argument_list|(
literal|"E Fatal server error, aborting.\n\ error ENOMEM Virtual memory exhausted.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|server_temp_dir
argument_list|,
name|temp_dir
argument_list|)
expr_stmt|;
comment|/* Remove a trailing slash from TMPDIR if present.  */
name|p
operator|=
name|server_temp_dir
operator|+
name|strlen
argument_list|(
name|server_temp_dir
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * I wanted to use cvs-serv/PID, but then you have to worry about 	 * the permissions on the cvs-serv directory being right.  So 	 * use cvs-servPID. 	 */
name|strcat
argument_list|(
name|server_temp_dir
argument_list|,
literal|"/cvs-serv"
argument_list|)
expr_stmt|;
name|p
operator|=
name|server_temp_dir
operator|+
name|strlen
argument_list|(
name|server_temp_dir
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGHUP
argument_list|,
name|server_cleanup
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGINT
argument_list|,
name|server_cleanup
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGQUIT
argument_list|,
name|server_cleanup
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGPIPE
argument_list|,
name|server_cleanup
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SIG_register
argument_list|(
name|SIGTERM
argument_list|,
name|server_cleanup
argument_list|)
expr_stmt|;
comment|/* Now initialize our argument vector (for arguments from the client).  */
comment|/* Small for testing.  */
name|argument_vector_size
operator|=
literal|1
expr_stmt|;
name|argument_vector
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|argument_vector_size
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|argument_vector
operator|==
name|NULL
condition|)
block|{
comment|/* 	 * Strictly speaking, we're not supposed to output anything 	 * now.  But we're about to exit(), give it a try. 	 */
name|printf
argument_list|(
literal|"E Fatal server error, aborting.\n\ error ENOMEM Virtual memory exhausted.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|argument_count
operator|=
literal|1
expr_stmt|;
name|argument_vector
index|[
literal|0
index|]
operator|=
literal|"Dummy argument 0"
expr_stmt|;
name|buf_to_net
operator|.
name|data
operator|=
name|buf_to_net
operator|.
name|last
operator|=
name|NULL
expr_stmt|;
name|buf_to_net
operator|.
name|fd
operator|=
name|STDOUT_FILENO
expr_stmt|;
name|buf_to_net
operator|.
name|output
operator|=
literal|1
expr_stmt|;
name|buf_to_net
operator|.
name|nonblocking
operator|=
literal|0
expr_stmt|;
name|buf_to_net
operator|.
name|memory_error
operator|=
name|outbuf_memory_error
expr_stmt|;
name|server_active
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|char
modifier|*
name|cmd
decl_stmt|,
modifier|*
name|orig_cmd
decl_stmt|;
name|struct
name|request
modifier|*
name|rq
decl_stmt|;
name|orig_cmd
operator|=
name|cmd
operator|=
name|read_line
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|cmd
operator|==
name|NO_MEM_ERROR
condition|)
block|{
name|printf
argument_list|(
literal|"E Fatal server error, aborting.\n\ error ENOMEM Virtual memory exhausted.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|rq
operator|=
name|requests
init|;
name|rq
operator|->
name|name
operator|!=
name|NULL
condition|;
operator|++
name|rq
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|cmd
argument_list|,
name|rq
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|rq
operator|->
name|name
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|rq
operator|->
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmd
index|[
name|len
index|]
operator|==
literal|'\0'
condition|)
name|cmd
operator|+=
name|len
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd
index|[
name|len
index|]
operator|==
literal|' '
condition|)
name|cmd
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
else|else
comment|/* 		     * The first len characters match, but it's a different 		     * command.  e.g. the command is "cooperate" but we matched 		     * "co". 		     */
continue|continue;
call|(
modifier|*
name|rq
operator|->
name|func
call|)
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rq
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|print_pending_error
argument_list|()
condition|)
name|printf
argument_list|(
literal|"error  unrecognized request `%s'\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|orig_cmd
argument_list|)
expr_stmt|;
block|}
name|server_cleanup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|AUTH_SERVER_SUPPORT
end_ifdef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|crypt
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This was test code, which we may need again. */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* If we were invoked this way, then stdin comes from the      client and stdout/stderr writes to it. */
end_comment

begin_endif
unit|int c;   while ((c = getc (stdin)) != EOF&& c != '*')     {       printf ("%c", toupper (c));       fflush (stdout);     }   exit (0);
endif|#
directive|endif
end_endif

begin_comment
comment|/* 1/0 */
end_comment

begin_escape
end_escape

begin_comment
comment|/*   * 0 means no entry found for this user.  * 1 means entry found and password matches.  * 2 means entry found, but password does not match.  */
end_comment

begin_function
name|int
name|check_repository_password
parameter_list|(
name|username
parameter_list|,
name|password
parameter_list|,
name|repository
parameter_list|,
name|host_user_ptr
parameter_list|)
name|char
modifier|*
name|username
decl_stmt|,
decl|*
name|password
decl_stmt|,
modifier|*
name|repository
decl_stmt|,
modifier|*
modifier|*
name|host_user_ptr
decl_stmt|;
end_function

begin_block
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|linebuf
decl_stmt|;
name|int
name|found_it
init|=
literal|0
decl_stmt|;
name|int
name|namelen
decl_stmt|;
name|filename
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|repository
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
literal|"CVSROOT"
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
literal|"passwd"
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|filename
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|filename
argument_list|,
literal|"/CVSROOT"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|filename
argument_list|,
literal|"/passwd"
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|existence_error
argument_list|(
name|errno
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot open %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Look for a relevant line -- one with this user's name. */
name|namelen
operator|=
name|strlen
argument_list|(
name|username
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|linebuf
operator|=
name|read_line
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|linebuf
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|linebuf
operator|==
name|NO_MEM_ERROR
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|linebuf
argument_list|,
name|username
argument_list|,
name|namelen
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|linebuf
index|[
name|namelen
index|]
operator|==
literal|':'
operator|)
condition|)
block|{
name|found_it
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|free
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot read %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"cannot close %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/* If found_it != 0, then linebuf contains the information we need. */
if|if
condition|(
name|found_it
condition|)
block|{
name|char
modifier|*
name|found_password
decl_stmt|;
name|strtok
argument_list|(
name|linebuf
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|found_password
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|": \n"
argument_list|)
expr_stmt|;
operator|*
name|host_user_ptr
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|": \n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|host_user_ptr
operator|==
name|NULL
condition|)
operator|*
name|host_user_ptr
operator|=
name|username
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|found_password
argument_list|,
name|crypt
argument_list|(
name|password
argument_list|,
name|found_password
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|retval
operator|=
literal|1
expr_stmt|;
else|else
name|retval
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
operator|*
name|host_user_ptr
operator|=
name|NULL
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
block|}
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_block

begin_comment
comment|/* Return a hosting username if password matches, else NULL. */
end_comment

begin_function
name|char
modifier|*
name|check_password
parameter_list|(
name|username
parameter_list|,
name|password
parameter_list|,
name|repository
parameter_list|)
name|char
modifier|*
name|username
decl_stmt|,
decl|*
name|password
decl_stmt|,
modifier|*
name|repository
decl_stmt|;
end_function

begin_block
block|{
name|int
name|rc
decl_stmt|;
name|char
modifier|*
name|host_user
decl_stmt|;
comment|/* First we see if this user has a password in the CVS-specific        password file.  If so, that's enough to authenticate with.  If        not, we'll check /etc/passwd. */
name|rc
operator|=
name|check_repository_password
argument_list|(
name|username
argument_list|,
name|password
argument_list|,
name|repository
argument_list|,
operator|&
name|host_user
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|1
condition|)
return|return
name|host_user
return|;
elseif|else
if|if
condition|(
name|rc
operator|==
literal|2
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
comment|/* No cvs password found, so try /etc/passwd. */
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|char
modifier|*
name|found_passwd
decl_stmt|;
name|pw
operator|=
name|getpwnam
argument_list|(
name|username
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"E Fatal error, aborting.\n\ error 0 %s: no such user\n"
argument_list|,
name|username
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|found_passwd
operator|=
name|pw
operator|->
name|pw_passwd
expr_stmt|;
if|if
condition|(
name|found_passwd
operator|&&
operator|*
name|found_passwd
condition|)
return|return
operator|(
operator|(
operator|!
name|strcmp
argument_list|(
name|found_passwd
argument_list|,
name|crypt
argument_list|(
name|password
argument_list|,
name|found_passwd
argument_list|)
argument_list|)
operator|)
condition|?
name|username
else|:
name|NULL
operator|)
return|;
elseif|else
if|if
condition|(
name|password
operator|&&
operator|*
name|password
condition|)
return|return
name|username
return|;
else|else
return|return
name|NULL
return|;
block|}
else|else
block|{
comment|/* Something strange happened.  We don't know what it was, but 	   we certainly won't grant authorization. */
return|return
name|NULL
return|;
block|}
block|}
end_block

begin_comment
comment|/* Read username and password from client (i.e., stdin).    If correct, then switch to run as that user and send an ACK to the    client via stdout, else send NACK and die. */
end_comment

begin_function
name|void
name|authenticate_connection
parameter_list|()
block|{
name|char
name|tmp
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
name|repository
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
name|username
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
name|password
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
modifier|*
name|host_user
decl_stmt|;
name|char
modifier|*
name|descrambled_password
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|int
name|verify_and_exit
init|=
literal|0
decl_stmt|;
comment|/* The Authentication Protocol.  Client sends:    *    *   BEGIN AUTH REQUEST\n    *<REPOSITORY>\n    *<USERNAME>\n    *<PASSWORD>\n    *   END AUTH REQUEST\n    *    * Server uses above information to authenticate, then sends    *    *   I LOVE YOU\n    *    * if it grants access, else    *    *   I HATE YOU\n    *    * if it denies access (and it exits if denying).    *    * When the client is "cvs login", the user does not desire actual    * repository access, but would like to confirm the password with    * the server.  In this case, the start and stop strings are    *    *   BEGIN VERIFICATION REQUEST\n    *    *            and    *    *   END VERIFICATION REQUEST\n    *    * On a verification request, the server's responses are the same    * (with the obvious semantics), but it exits immediately after    * sending the response in both cases.    *    * Why is the repository sent?  Well, note that the actual    * client/server protocol can't start up until authentication is    * successful.  But in order to perform authentication, the server    * needs to look up the password in the special CVS passwd file,    * before trying /etc/passwd.  So the client transmits the    * repository as part of the "authentication protocol".  The    * repository will be redundantly retransmitted later, but that's no    * big deal.    */
comment|/* Since we're in the server parent process, error should use the      protocol to report error messages.  */
name|error_use_protocol
operator|=
literal|1
expr_stmt|;
comment|/* Make sure the protocol starts off on the right foot... */
name|fgets
argument_list|(
name|tmp
argument_list|,
name|PATH_MAX
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|tmp
argument_list|,
literal|"BEGIN VERIFICATION REQUEST\n"
argument_list|)
operator|==
literal|0
condition|)
name|verify_and_exit
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|tmp
argument_list|,
literal|"BEGIN AUTH REQUEST\n"
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"bad auth protocol start: %s"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* Get the three important pieces of information in order. */
name|fgets
argument_list|(
name|repository
argument_list|,
name|PATH_MAX
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|username
argument_list|,
name|PATH_MAX
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|password
argument_list|,
name|PATH_MAX
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
comment|/* Make them pure. */
name|strip_trailing_newlines
argument_list|(
name|repository
argument_list|)
expr_stmt|;
name|strip_trailing_newlines
argument_list|(
name|username
argument_list|)
expr_stmt|;
name|strip_trailing_newlines
argument_list|(
name|password
argument_list|)
expr_stmt|;
comment|/* ... and make sure the protocol ends on the right foot. */
name|fgets
argument_list|(
name|tmp
argument_list|,
name|PATH_MAX
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|tmp
argument_list|,
name|verify_and_exit
condition|?
literal|"END VERIFICATION REQUEST\n"
else|:
literal|"END AUTH REQUEST\n"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"bad auth protocol end: %s"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* We need the real cleartext before we hash it. */
name|descrambled_password
operator|=
name|descramble
argument_list|(
name|password
argument_list|)
expr_stmt|;
name|host_user
operator|=
name|check_password
argument_list|(
name|username
argument_list|,
name|descrambled_password
argument_list|,
name|repository
argument_list|)
expr_stmt|;
if|if
condition|(
name|host_user
condition|)
block|{
name|printf
argument_list|(
literal|"I LOVE YOU\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|descrambled_password
argument_list|,
literal|0
argument_list|,
name|strlen
argument_list|(
name|descrambled_password
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|descrambled_password
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"I HATE YOU\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|descrambled_password
argument_list|,
literal|0
argument_list|,
name|strlen
argument_list|(
name|descrambled_password
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|descrambled_password
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
comment|/* Don't go any farther if we're just responding to "cvs login". */
if|if
condition|(
name|verify_and_exit
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Switch to run as this user. */
name|pw
operator|=
name|getpwnam
argument_list|(
name|host_user
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"fatal error, aborting.\nerror 0 %s: no such user\n"
argument_list|,
name|username
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|HAVE_INITGROUPS
name|initgroups
argument_list|(
name|pw
operator|->
name|pw_name
argument_list|,
name|pw
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_INITGROUPS */
name|setgid
argument_list|(
name|pw
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
name|setuid
argument_list|(
name|pw
operator|->
name|pw_uid
argument_list|)
expr_stmt|;
comment|/* Inhibit access by randoms.  Don't want people randomly      changing our temporary tree before we check things in.  */
name|umask
argument_list|(
literal|077
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_PUTENV
comment|/* Set LOGNAME and USER in the environment, in case they are      already set to something else.  */
block|{
name|char
modifier|*
name|env
decl_stmt|;
name|env
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
expr|"LOGNAME="
operator|+
name|strlen
argument_list|(
name|username
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|env
argument_list|,
literal|"LOGNAME=%s"
argument_list|,
name|username
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|env
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
expr|"USER="
operator|+
name|strlen
argument_list|(
name|username
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|env
argument_list|,
literal|"USER=%s"
argument_list|,
name|username
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_PUTENV */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTH_SERVER_SUPPORT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SERVER_SUPPORT */
end_comment

begin_comment
comment|/* Output LEN bytes at STR.  If LEN is zero, then output up to (not including)    the first '\0' byte.  Should not be called from the server parent process    (yet at least, in the future it might be extended so that works).  */
end_comment

begin_function
name|void
name|cvs_output
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_use_protocol
condition|)
comment|/* Eventually we'll probably want to make it so this case works, 	   but for now, callers who want to output something with 	   error_use_protocol in effect can just printf the "M foo" 	   themselves.  */
name|abort
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
block|{
name|buf_output
argument_list|(
operator|&
name|saved_output
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf_copy_lines
argument_list|(
operator|&
name|protocol
argument_list|,
operator|&
name|saved_output
argument_list|,
literal|'M'
argument_list|)
expr_stmt|;
name|buf_send_counted
argument_list|(
operator|&
name|protocol
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|size_t
name|written
decl_stmt|;
name|size_t
name|to_write
init|=
name|len
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|str
decl_stmt|;
while|while
condition|(
name|to_write
operator|>
literal|0
condition|)
block|{
name|written
operator|=
name|fwrite
argument_list|(
name|str
argument_list|,
literal|1
argument_list|,
name|to_write
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|written
operator|==
literal|0
condition|)
break|break;
name|p
operator|+=
name|written
expr_stmt|;
name|to_write
operator|-=
name|written
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Like CVS_OUTPUT but output is for stderr not stdout.  */
end_comment

begin_function
name|void
name|cvs_outerr
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_use_protocol
condition|)
comment|/* Eventually we'll probably want to make it so this case works, 	   but for now, callers who want to output something with 	   error_use_protocol in effect can just printf the "E foo" 	   themselves.  */
name|abort
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SERVER_SUPPORT
if|if
condition|(
name|server_active
condition|)
block|{
name|buf_output
argument_list|(
operator|&
name|saved_outerr
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf_copy_lines
argument_list|(
operator|&
name|protocol
argument_list|,
operator|&
name|saved_outerr
argument_list|,
literal|'E'
argument_list|)
expr_stmt|;
name|buf_send_counted
argument_list|(
operator|&
name|protocol
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|size_t
name|written
decl_stmt|;
name|size_t
name|to_write
init|=
name|len
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|str
decl_stmt|;
while|while
condition|(
name|to_write
operator|>
literal|0
condition|)
block|{
name|written
operator|=
name|fwrite
argument_list|(
name|str
argument_list|,
literal|1
argument_list|,
name|to_write
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|written
operator|==
literal|0
condition|)
break|break;
name|p
operator|+=
name|written
expr_stmt|;
name|to_write
operator|-=
name|written
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

